diff -urNp linux-5720/drivers/scsi/Config.in linux-5730/drivers/scsi/Config.in
--- linux-5720/drivers/scsi/Config.in
+++ linux-5730/drivers/scsi/Config.in
@@ -55,7 +55,6 @@ if [ "$CONFIG_EXPERIMENTAL" = "y" ]; the
    dep_tristate 'Adaptec AACRAID support (EXPERIMENTAL)' CONFIG_SCSI_AACRAID $CONFIG_SCSI $CONFIG_PCI
 fi
 source drivers/scsi/aic7xxx/Config.in
-source drivers/scsi/aic79xx/Config.in
 if [ "$CONFIG_SCSI_AIC7XXX" != "y" ]; then
    dep_tristate 'Old Adaptec AIC7xxx support' CONFIG_SCSI_AIC7XXX_OLD $CONFIG_SCSI
    if [ "$CONFIG_SCSI_AIC7XXX_OLD" != "n" ]; then
@@ -64,7 +63,9 @@ if [ "$CONFIG_SCSI_AIC7XXX" != "y" ]; th
       bool '  Collect statistics to report in /proc' CONFIG_AIC7XXX_OLD_PROC_STATS
    fi
 fi
-dep_tristate 'Adaptec I2O RAID support ' CONFIG_SCSI_DPT_I2O $CONFIG_SCSI
+if [ "$CONFIG_X86_64" != "y" ]; then
+  dep_tristate 'Adaptec I2O RAID support ' CONFIG_SCSI_DPT_I2O $CONFIG_SCSI
+fi
 dep_tristate 'AdvanSys SCSI support' CONFIG_SCSI_ADVANSYS $CONFIG_SCSI
 dep_tristate 'Always IN2000 SCSI support' CONFIG_SCSI_IN2000 $CONFIG_SCSI
 dep_tristate 'AM53/79C974 PCI SCSI support' CONFIG_SCSI_AM53C974 $CONFIG_SCSI $CONFIG_PCI
diff -urNp linux-5720/drivers/scsi/Makefile linux-5730/drivers/scsi/Makefile
--- linux-5720/drivers/scsi/Makefile
+++ linux-5730/drivers/scsi/Makefile
@@ -27,7 +27,7 @@ mod-subdirs	:= pcmcia ../acorn/scsi
 
 subdir-$(CONFIG_SCSI_AACRAID)	+= aacraid
 subdir-$(CONFIG_SCSI_AIC7XXX)	+= aic7xxx
-subdir-$(CONFIG_SCSI_AIC79XX)	+= aic79xx
+subdir-$(CONFIG_SCSI_AIC79XX)	+= aic7xxx
 subdir-$(CONFIG_PCMCIA)		+= pcmcia
 
 
@@ -73,7 +73,7 @@ ifeq ($(CONFIG_SCSI_AIC7XXX),y)
   obj-$(CONFIG_SCSI_AIC7XXX)	+= aic7xxx/aic7xxx.o
 endif
 ifeq ($(CONFIG_SCSI_AIC79XX),y)
-  obj-$(CONFIG_SCSI_AIC79XX)	+= aic79xx/aic79xx.o
+  obj-$(CONFIG_SCSI_AIC79XX)	+= aic7xxx/aic79xx.o
 endif
 obj-$(CONFIG_SCSI_AIC7XXX_OLD)	+= aic7xxx_old.o
 obj-$(CONFIG_SCSI_IPS)		+= ips.o
diff -urNp linux-5720/drivers/scsi/aic79xx/CHANGELOG linux-5730/drivers/scsi/aic79xx/CHANGELOG
--- linux-5720/drivers/scsi/aic79xx/CHANGELOG
+++ linux-5730/drivers/scsi/aic79xx/CHANGELOG
@@ -1,23260 +0,0 @@
-Change 1861 by scottl@scottl-template on 2003/01/21 18:26:00
-
-	       Update driver version to 1.3.0
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#108 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#25 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#28 edit
-
-Change 1859 by scottl@scottl-template on 2003/01/21 15:27:08
-
-	readme.txt:
-	README.aic7xxx:
-		Convert tabs to spaces.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/README.aic7xxx#4 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/readme.txt#4 edit
-
-Change 1858 by scottl@scottl-template on 2003/01/21 14:43:42
-
-	readme.txt:
-	README.aic79xx:
-		Fix the wording of the 1.3.0 version history line
-		Replace tabs with spaces.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/README.aic79xx#6 edit
-... //depot/linux_mod_devel/scsi.aic79xx/readme.txt#18 edit
-
-Change 1856 by gibbs@bitkeeper-linux-2.5 on 2003/01/21 12:37:08
-
-	Update the embedded aic7xxx driver README.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/README.aic7xxx#3 edit
-
-Change 1854 by gibbs@bitkeeper-linux-2.5 on 2003/01/21 12:12:27
-
-	Update aic79xx README used for embedding.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/README.aic79xx#5 edit
-
-Change 1851 by gibbs@bitkeeper-linux-2.5 on 2003/01/20 16:45:59
-
-	Bump aic7xxx driver to version 6.2.28.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#123 edit
-
-Change 1850 by scottl@scottl-template on 2003/01/20 16:29:28
-
-	       Update driver version to 1.3.0.RC2
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#107 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#24 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#27 edit
-
-Change 1849 by gibbs@bitkeeper-linux-2.4 on 2003/01/20 16:23:35
-
-	aic79xx_osm.c:
-		Correct the BUILD_SCSIID macro to take into account the
-		future removal of target, lun and channel from the
-		scsi_cmnd structure.
-	
-		Clean up ahd_linux_initialize_scsi_bus().  The indirection
-		was left over from the port from aic7xxx where twin
-		channel adapters come into play.  The result in the aic79xx
-		driver just looked silly.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#115 edit
-
-Change 1848 by gibbs@bitkeeper-linux-2.4 on 2003/01/20 16:20:47
-
-	aic79xx.c:
-		Fix a missed goal.period -> goal.offset change.  In
-		this case, the bug resulted in comparing a period
-		against an offset.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#156 edit
-
-Change 1847 by gibbs@bitkeeper-linux-2.4 on 2003/01/20 10:14:37
-
-	aic79xx.c:
-	aic7xxx.c:
-		Indicate the features, bugs, and flags set in the softc
-		that are used to control firmware patch download when
-		booting verbose.
-	
-	aic7xxx.c:
-		Fix an ifdef bug that caused sequencer debugging to
-		be enabled always.
-	
-		Clear the ultraenb flag in our tstate during startup.
-		The ultraenbled'ness of a device is recorded in the user
-		transfer settings.  tstate->ultraenb bitmask indicates
-		which devices we have negotiated an ultra speed with.
-		Just after initialization, we are async.  Setting the
-		ultraenb flag while async seems to be harmless, but it
-		was confusing to see the ULTRAENB flag set in the SCB.
-	
-		Allow ahc_dump_card_state() to be called when the sequencer
-		is not paused.  Add dump card state markers as in the U320
-		driver.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#155 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#112 edit
-
-Change 1846 by gibbs@bitkeeper-linux-2.4 on 2003/01/20 09:53:07
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Dump card state on DV timeouts when SHOW_DV debug
-		option is set.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#114 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#179 edit
-
-Change 1845 by gibbs@bitkeeper-linux-2.4 on 2003/01/17 14:46:30
-
-	aic79xx.c:
-	aic7xxx.c:
-		Force an SDTR after a rejected WDTR if the
-		syncrate is unkonwn.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#154 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#111 edit
-
-Change 1844 by gibbs@bitkeeper-linux-2.5 on 2003/01/17 13:20:26
-
-	aic7xxx_osm.h:
-		Bump driver version to 6.2.27.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#122 edit
-
-Change 1843 by gibbs@overdrive on 2003/01/17 13:06:51
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#22 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg_print.c#9 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#23 edit
-
-Change 1842 by scottl@scottl-template on 2003/01/17 12:39:50
-
-	       Update driver version to 1.3.0.RC1
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#106 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#23 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#26 edit
-
-Change 1841 by gibbs@bitkeeper-linux-2.4 on 2003/01/17 12:39:21
-
-	aic7xxx.c:
-	aic7xxx.h:
-	aic7xxx_pci.c:
-		Take another stab at disabling PCI errors in the aic7xxx
-		driver.  We now just clear the PERRRESEN bit in the command
-		register.  This option is now enabled via a new flag in
-		ahc->flags: AHC_DISABLE_PCI_PERR.
-	
-	aic7xxx_osm.c:
-		Hook the already existing pci_parity option.  Parity
-		defaults to off since so many Linux users have clunky
-		VIA chipsets that cause spurious warnings.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#110 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#70 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#57 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#178 edit
-
-Change 1840 by scottl@scottl-template on 2003/01/16 18:53:11
-
-	aic7xxx_osm.c:
-		Fix missed AHD->AHC substitutions from last commit.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#177 edit
-
-Change 1839 by scottl@scottl-template on 2003/01/16 18:51:20
-
-	aic7xxx_osm.c:
-		Traverse the array of targets and devices in
-		ahc_platform_free() and remove each device.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#176 edit
-
-Change 1838 by scottl@scottl-template on 2003/01/16 18:46:46
-
-	aic79xx_osm.c:
-		Traverse the arrays of targets and devices to free each
-		device when ahd_platform_free() is called.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#113 edit
-
-Change 1837 by gibbs@bitkeeper-linux-2.4 on 2003/01/16 16:24:58
-
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-	aic7xxx_osm.c:
-	aic7xxx_osm.h:
-		Adapt to upcoming 2.5.X change.  The host, target, channel,
-		and lun fields are disappearing from the scsi_cmnd structure.
-		We must instead get this data from the scsi_device structure
-		hung off the command.  The only trick in this is an update
-		to how we fake up DV commands.  We now need to fake up a
-		scsi_device too.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#112 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#105 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#175 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#121 edit
-
-Change 1836 by gibbs@bitkeeper-linux-2.4 on 2003/01/16 14:39:58
-
-	aic79xx.c:
-		Only send an async update to the luns affected by
-		the device reset now that ahd_handle_devreset is
-		called for lun resets too.
-	
-	aic79xx_osm.c:
-		Only bother dumping card state after we've determined
-		that the command to be aborted is still active on the
-		controller.
-	
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Have the AC_SENT_BDR handler manually set the was_reset
-		and expecting_cc_ua flags in all devices that are
-		affected by the target/lun reset.
-	
-		Never allow cmd->retries to go below zero.  cmd->retries
-		is not incremented when a command goes through recovery.
-		This could allow the retry count to suddenly become a
-		very large number.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#153 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#111 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#174 edit
-
-Change 1834 by gibbs@aslan on 2003/01/15 21:32:22
-
-	aic7xxx.seq:
-		Correct a target mode regression that prevented the
-		driver from properly handling unexpected
-		messages (negotiation, etc).
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#54 edit
-
-Change 1833 by gibbs@bitkeeper-linux-2.4 on 2003/01/15 21:27:13
-
-	aic79xx_osm.c:
-		Split out the abort handler from the dev reset handler.
-		The dev reset handler will now use a new SCB to issue
-		the dev reset.  This avoids a potential problem with
-		SCB race issues for dev resets.
-	
-		Manually set the task management function now that
-		ahd_queue_scb() doesn't do this for us.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#110 edit
-
-Change 1832 by gibbs@bitkeeper-linux-2.4 on 2003/01/15 21:20:59
-
-	aic79xx.c:
-		Update copyright for 2003.
-	
-		Modify ahd_handle_devreset so that it can handle
-		lun resets in addition to target resets.
-	
-		Correct a bug in the illegal phase handler that
-		caused us to drop down to narrow when handling the
-		unexpected command phase case after 3rd party
-		reset of a packetized device.
-	
-		Add some diagnostics to the task management function code.
-	
-		Use ahd_handle_devreset for lun and target reset task
-		management functions.
-	
-		Handle the abort task TMF race case better.  We now
-		wait until any current selections are over and then
-		set the TMF back to zero.  This should cause the sequencer
-		to ignore the abort TMF completion should it occur.
-	
-		Correct a regression in ahd_sent_msg that caused it to fail
-		to recognize any 1byte messages other than identify.
-	
-	aic79xx_inline.h:
-		Allow callers to ahd_send_scb() to set the task management
-		function.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#152 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#41 edit
-
-Change 1831 by scottl@scottl-template on 2003/01/15 17:37:56
-
-	Move aic_error_action and aic_calc_speed out of the osm's and
-	into aiclib.  Do slight header adjustment to make it work.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#69 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#109 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#104 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#173 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#120 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aiclib.c#6 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aiclib.h#6 edit
-
-Change 1830 by gibbs@bitkeeper-linux-2.4 on 2003/01/15 15:33:45
-
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-	aic7xxx_osm.c:
-	aic7xxx_osm.h:
-		Correct use of AHD_EH_UP_SEMAPHORE.  This should
-		unbreak the recovery handler.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#108 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#103 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#172 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#119 edit
-
-Change 1829 by gibbs@overdrive on 2003/01/15 11:18:20
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#54 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#35 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#55 edit
-
-Change 1828 by gibbs@bitkeeper-linux-2.5 on 2003/01/15 10:19:07
-
-	aic79xx_osm.c:
-		Continue to dump the card state on timeouts for the
-		time being.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#107 edit
-
-Change 1827 by gibbs@bitkeeper-linux-2.5 on 2003/01/15 10:18:44
-
-	aic7xxx.h:
-		Reformat a few comments to follow driver style.
-	
-		Add a controller flag that indicates that a controller
-		has not been initialized by the BIOS.
-	
-	aic7xxx.c:
-		Disable PCI error interrupts on PCI adapters prior
-		to the Ultra2 controllers.  This brings us in line
-		with what the other Adaptec drivers do, but it is
-		still not clear exactly why this status reporting
-		might be broken.
-	
-		Don't set our width to unknown when forcing negotiation
-		on narrow controllers.  This will confuse the negotiation
-		code into negotiating with a wide message on narrow
-		controllers.
-	
-		In ahc_reset(), record whether or not we found the
-		controller in a reset state.  If the controller was
-		already reset, assume that no BIOS has initialized
-		the controller and ignore left over scratch ram
-		settings.
-	
-		In ahc_dump_card_state() fix a logic reversal.  The
-		SCSIPHASE register only exists on U160 controllers.
-		The SCSISIGI register exists on all controllers.  Not
-		the other way around.
-	
-	aic7xxx_osm.c:
-		Format sense diagnostic in 16 byte rows.
-	
-		Remove a superfluous diagnostic printf.
-	
-	aic7xxx_pci.c:
-		Ensure that the PCIERRGENDIS bit is set in the
-		PCIERRGEN config space register.  Perhaps this
-		is a reason for the spurios parity errors reported
-		on U160 controllers.
-	
-		Honor the AHC_NO_BIOS_INIT flag.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#109 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#68 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#56 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#171 edit
-
-Change 1826 by gibbs@bitkeeper-linux-2.5 on 2003/01/15 10:10:47
-
-	aic79xx.reg:
-		Add SEQINT codes for handling task management
-		completions.
-	
-	aic79xx.seq:
-		Add notifications to the host of task management
-		completions as well as the completions for commands
-		that have a task management function pending but
-		not yet sent.
-	
-		Hold a critical section during select-out processing
-		until we have a fully identified connection.  This
-		removes a race condition with the legacy abort handler.
-	
-		Correct a few spelling errors in some comments.
-	
-	aic79xx_core.c
-		Flush the good status FIFO in ahd_flush_qoutfifo.
-		This routine should now catch all completed commands
-		in their various locations and states.
-	
-		Add support for task management function completions.
-	
-		If we are a narrow controller, don't set the current
-		width to unknown when forcing a future negotiation.
-		This just confuses the code into attempting a wide
-		negotiation on a narrow bus.
-	
-	aic79xx_osm.c:
-		Enable recovery code.  Behavior should be similar to
-		that of the aic7xxx driver for legacy devices.  For
-		packetized devices, we will now queue the appropriate
-		task management function.
-	
-		When printing out sense information, format in 16
-		byte rows.
-	
-	scsi_iu.h:
-		Add definitions for the task management codes sent
-		in SPI4 command information units.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#151 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#60 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#78 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#106 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/scsi_iu.h#4 edit
-
-Change 1825 by gibbs@bitkeeper-linux-2.5 on 2003/01/10 16:42:54
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Short cicuit domain validation if the inquiry
-		data for the device shows that it does not support
-		sync or wide transfers.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#105 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#170 edit
-
-Change 1820 by gibbs@bitkeeper-linux-2.5 on 2003/01/07 19:47:06
-
-	aic79xx_osm_pci.c:
-		Always set the pci_dma_mask.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#20 edit
-
-Change 1819 by gibbs@bitkeeper-linux-2.5 on 2003/01/07 19:44:50
-
-	aic7xxx_osm_pci.c:
-		Always initialize the pci_dma_mask.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#43 edit
-
-Change 1818 by gibbs@overdrive on 2003/01/07 19:11:29
-
-	aic79xx_osm.h:
-	aic7xxx_osm.h:
-		Correct version numbers.  We are now at aic7xxx 6.2.26,
-		and aic79xx 1.3.0_BETA2.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#102 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#118 edit
-
-Change 1817 by scottl@scottl-template on 2003/01/07 19:03:54
-
-	       Update driver version to 6.2.24
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#117 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/aic7xxx.spec#10 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/install.sh#14 edit
-
-Change 1815 by scottl@scottl-belfalas-template on 2003/01/07 18:58:15
-
-	Forward declare and static-ize aic7xxx_setup().
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#169 edit
-
-Change 1814 by gibbs@bitkeeper-linux-2.5 on 2003/01/07 18:35:16
-
-	aic7xxx_osm.h:
-		Add PCIM_CMD_SERRESPEN definition.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#116 edit
-
-Change 1813 by gibbs@overdrive on 2003/01/07 18:32:44
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#21 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg_print.c#8 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#22 edit
-
-Change 1812 by gibbs@aslan on 2003/01/07 17:38:33
-
-	aic79xx_pci.c:
-	aic7xxx_pci.c:
-		Disable SERR and pause the controller prior to performing
-		our mmapped I/O test.  This should handle the case of
-		controllers that do not "auto-access pause".  For legacy
-		controllers, use SCB ram instead of scratch ram since
-		the latter may contain settings left over from the BIOS
-		that we will use if an seeprom is not found.
-	
-	aic7xxx.h:
-	aic7xxx.c:
-		Remove the probe_stack code.  The stack is always
-		4 deep on legacy controllers, so probing is pointless.
-		This also avoids an issue where probing the stack would
-		upset the aic7770.
-	
-	aic7xxx.c:
-		Print out the ERROR register in ahc_dump_card_state().
-	
-	aic7xxx.reg:
-		Add a constant for the controller's stack size.
-	
-	aic7xxx.seq:
-		Style nit.  The source is implied to be the destination
-		unless overridden in an "and" instruction.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#61 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#108 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#67 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#37 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#53 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#55 edit
-
-Change 1811 by gibbs@aslan on 2003/01/07 14:20:42
-
-	aicasm_gram.y:
-		Remove the numerical_value portion of the grammer
-		which is no longer referenced.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#29 edit
-
-Change 1810 by scottl@scottl-template on 2003/01/07 09:29:00
-
-	       Update driver version to 1.3.0.BETA1
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#101 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#21 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#24 edit
-
-Change 1808 by gibbs@bitkeeper-linux-2.5 on 2003/01/06 14:21:46
-
-	aic7xxx_osm.c:
-		Correctly account for twin channel adapters in
-		pre-allocating target devices for initial DV scan.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#168 edit
-
-Change 1807 by gibbs@bitkeeper-linux-2.5 on 2003/01/06 11:58:41
-
-	aic79xx.c:
-		Correct ahd_find_syncrate() so that the actual
-		syncrate and not the "maximum syncrate" is modified
-		by tests that limit syncrate based on PPR options.
-	
-	aic7xxx.c:
-	aic79xx.c:
-		Enhance residual diagnostic to indicate if the residual
-		if for sense information or normal data transfers.
-	
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		For the initial DV scan, only instantiate target objects
-		for IDs that can exist (i.e. only up to ID 7 on narrow
-	
-		Record the maximum bus width for fallback in the target
-		structure and use this to ensure we never fallback to
-		wide on a narrow target.
-		channels).
-	
-		Add DV diagnostic for failed inquiry verification.
-	
-	aic79xx_osm.h:
-	aic7xxx_osm.h:
-		Add dv_max_width to target structures and shrink several
-		fields to 8bits.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#150 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#107 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#104 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#100 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#167 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#115 edit
-... //depot/linux-aic79xx-2.5.0/drivers/scsi/aic7xxx/Makefile#5 edit
-
-Change 1805 by scottl@scottl-junior-freebsd on 2002/12/30 21:13:11
-
-	Convert the use of MAXBSIZE in the dma tag to more appropriate values.
-	Use BUS_SPACE_MAXSIZE_32BIT for the parent dma tags, and
-	(NSEGS - 1) * PAGE_SIZE for the data buffer tags.  FreeBSD/sparc64 is
-	more strick about checking these values that other arches.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#149 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#106 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/ahc_eisa.c#10 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/ahc_pci.c#12 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/ahd_pci.c#12 edit
-
-Change 1804 by gibbs@bitkeeper-linux-2.5 on 2002/12/30 18:59:49
-
-	aic79xx_osm.h:
-		Bump version number to 1.3.0_ALPHA6
-	
-	aic7xxx_osm.h:
-		Bump version number to 6.2.25.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#99 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#114 edit
-
-Change 1803 by gibbs@bitkeeper-linux-2.4 on 2002/12/30 16:54:09
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Reorganize DV state machine so that full inquiry data
-		is retrieved prior to testing to see if the unit is ready.
-		We now use this full inquiry data to assume defaults if
-		for some reason the DV state machine fails to configure
-		the device.  This failsafe mechanism should ensure that
-		these devices are at least configured in the same fashion
-		as they were before the addition of DV to these drivers.
-	
-	aic79xx_osm.h:
-	aic7xxx_osm.h:
-		Re-arrange DV state enum to reflect current state machine
-		transitions.
-	
-		Add additional target flags used to implement the DV
-		failsafe mechanism.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#103 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#98 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#166 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#113 edit
-
-Change 1802 by gibbs@bitkeeper-linux-2.5 on 2002/12/30 14:59:22
-
-	aic7770_osm.c:
-	aic79xx_osm_pci.c:
-	aic7xxx_osm_pci.c:
-		Clean up check_region() usage.  It is deprecated in 2.5.X
-		and 2.4.X, but is still required in earlier kernels.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#12 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#19 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#42 edit
-
-Change 1801 by gibbs@bitkeeper-linux-2.5 on 2002/12/30 13:50:25
-
-	aiclib.c:
-		Ignore media not-present errors during DV.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aiclib.c#5 edit
-
-Change 1800 by gibbs@bitkeeper-linux-2.5 on 2002/12/30 13:50:10
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Use down_interruptable() rather than down() to avoid
-		having our thread counted toward the load average.
-		We disable all signal sources to that the down_interruptable()
-		is not really interruptable().  Singals are not required for
-		the drivers to terminate the DV threads on unload.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#102 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#165 edit
-
-Change 1799 by gibbs@bitkeeper-linux-2.5 on 2002/12/30 12:19:23
-
-	aicasm_symbol.c:
-		Fix the last reference to the reg_print.c file handle
-		in symtable_dump.  This allows the assembler to operate
-		without generating this file.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#24 edit
-
-Change 1798 by gibbs@bitkeeper-linux-2.5 on 2002/12/30 12:18:05
-
-	aiclib.h:
-		Restore driver style.  All functions are declared prior
-		to being defined.  The original bug was that the 2.4.X
-		declaration was used unconditionally.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aiclib.h#5 edit
-
-Change 1797 by gibbs@bitkeeper-linux-2.5 on 2002/12/30 12:17:23
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Enable highmem_io on 2.5.X kernels.  It turns out that
-		the CONFIG_HIGHIO option does not exist there.
-	
-		Call daemonize() on and provide a name for our dv threads.
-	
-	aic79xx_osm.h:
-	aic7xxx_osm.h:
-		Include smp_lock.h for (un)lock_kernel().
-	
-	aic7xxx_osm.c:
-		Add a diagnostic, similar to that in the aic79xx driver,
-		for printing out sense information.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#101 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#97 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#164 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#112 edit
-
-Change 1796 by gibbs@bitkeeper-linux-2.5 on 2002/12/30 12:14:42
-
-	aic7xxx.c:
-		Preface the "asserting atn" diagnostic with controller/target
-		information.
-	
-		Restore a call to ahc_assert_atn() that was inadvertantly
-		lost when the asserting atn diagnostic was added.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#105 edit
-
-Change 1795 by gibbs@bitkeeper-linux-2.5 on 2002/12/30 12:13:06
-
-	aic79xx_core.c:
-		Print out target information to preface the asserting
-		attention diagnostic.
-	
-		Correct a compilation warning.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#148 edit
-
-Change 1792 by gibbs@bitkeeper-linux-2.5 on 2002/12/20 17:52:04
-
-	Bump to version 6.2.24.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#111 edit
-
-Change 1788 by gibbs@aslan on 2002/12/20 16:39:14
-
-	aic79xx.c:
-		Remove stray debugging code.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#147 edit
-
-Change 1787 by scottl@scottl-template on 2002/12/20 16:04:59
-
-	       Update driver version to 1.3.0.ALPHA5
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#96 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#20 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#23 edit
-
-Change 1786 by gibbs@overdrive on 2002/12/19 16:10:05
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#53 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#34 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#54 edit
-
-Change 1785 by gibbs@aslan on 2002/12/19 16:08:47
-
-	aic79xx.c:
-		Add a statistics timer that decides when to enable
-		or disable interrupt coalessing based on load.
-	
-		Add ahd_flush_qoutfifo() which will run the qoutfifo
-		as well as complete any commands sitting on the 
-		sequencer's COMPLETE_SCB lists.  Use this routine in
-		several places that did similar things in an add-hoc,
-		but incomplete, fashion.  A call to this routine was
-		also added to ahd_abort_scbs() to close a race.
-	
-		Add a routine, ahd_reset_cmds_pending() which is used
-		to update the CMDS_PENDING sequencer variable whenever
-		error recovery compeltes SCBs without notifying the
-		sequencer.  Since ahd_reset_cmds_pending is called
-		during ahd_unpause() only if we've aborted SCBs, its
-		call to ahd_flush_qoutfifo should not cause recursion
-		through ahd_run_qoutfifo().  A panic has been added to
-		ensure that this recursion does not occur.
-	
-		In ahd_search_qinfifo, update the CMDS_PENDING sequencer
-		variable directly.  ahd_search_qinififo can be called
-		in situations where using ahd_reset_cmds_pending() might
-		cause recursion.  Since we can safely determine the
-		exact number to reduce CMDS_PENDING by in this scenario
-		without running the qoutfifo, the manual update is more
-		than adequate.
-	
-		Clean up diagnostics.
-	
-	aic79xx.h:
-		Update per-softc variables for the stats "daemon".
-		The defaults for interrupt coalessing have been updated
-		slightly, but these need additional tuning.  A new
-		tunable paramter "minimum commands still outstanding
-		required to attempt coalessing" has been added.
-	
-		Add a debug option for interrupt coalessing activities.
-	
-		Add two new softc flags:
-		o AHD_UPDATE_PEND_CMDS
-			Run ahd_reset_cmds_pending() on the next unpause.
-	
-		o AHD_RUNNING_QOUTFIFO
-			Used to catch recursion through ahd_run_qoutfifo().
-	
-	aic79xx.reg:
-		Break INTMASK in SEQITNCTL out into INTMASK1 and INTMASK2.
-		In at least the REV A, these are writable bits.  We make
-		use of that for a swtimer workaround in the sequencer.
-	
-		Add sequencer variables to recovery the min-commands
-		still outstanding for coalessing and the current number
-		of commands outstanding.
-	
-		Since HS_MAILBOX autoclears, provide a sequencer variable
-		to store its contents.
-	
-	aic79xx.seq:
-		In idle_loop_cchan, update LOCAL_HS_MAILBOX everytime
-		we are notified of an HS_MAILBOX update via the
-		HS_MAILBOX_ACT bit in QOFF_CTLSTA.
-	
-		Enhance our coalessing algorithm.  If we have more
-		SCBs to complete to the host (sitting in COMPLETE_SCB
-		lists), always try to coaless them up to our coalessing
-		limit.  If coalessing is enabled, but we have fewer
-		commands oustantind than the hosts limit, complete the
-		command immediately.
-	
-		Since we cannot disable the swtimer's countdown, simply
-		mask its interrupt once we no longer care about it firing.
-	
-		Add code to track the number of commands outstanding.
-		Commands are outstanding from the time they are placed
-		into the execution queue until the DMA to post completion
-		is setup.
-	
-		Add a workaround for intvec_2 interrupts on the H2A4.
-		In H2A4, the mode pointer is not saved for intvec2, but
-		is restored on iret.  This can lead to the restoration
-		of a bogus mode ptr.  Manually clear the intmask bits and
-		do a normal return to compensate.
-	
-	aic79xx_inline.h:
-		Call ahd_reset_cmds_pending() in ahd_unpause if required.
-	
-		Update cmdcmplt interrupt statistics in our interrupt
-		handler.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#146 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#78 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#59 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#77 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#40 edit
-
-Change 1784 by gibbs@bitkeeper-linux-2.5 on 2002/12/18 10:33:25
-
-	aic79xx_osm.c:
-		Remove a stray ';' that was short cicuiting an if statement.
-	
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-	aic79xx_osm.h:
-	aic7xxx_osm.h:
-		Only allow slave_destroy() to destroy a real device
-		if that device has had slave_configure() called on it.
-		This prevents "silly deletions" caused by bogons in
-		the scsi_scan code from deleting DV state for devices
-		that are still attached and will have a slave_alloc()
-		called for them as soon as the slave_destroy() returns.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#100 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#95 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#163 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#110 edit
-
-Change 1783 by gibbs@bitkeeper-linux-2.5 on 2002/12/18 10:29:46
-
-	aic7xxx.c:
-		Don't clobber ppr_options when forcing a renegotiation.
-		The current ppr_options may be referenced while queuing
-		new commands.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#104 edit
-
-Change 1782 by gibbs@bitkeeper-linux-2.5 on 2002/12/17 19:27:05
-
-	aic79xx_osm.c:
-		Add a prototype for ahd_linux_dv_fallback().
-	
-	aic7xxx_osm.c:
-		Complete the merge of the new biosparam API from
-		Christoph Hellwig.
-	
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Move the setting of max_sectors to the host template
-		to quiet a warning in 2.5.X.
-	
-		Add slave_alloc calls and "bootverbose" diagnostics
-		for help in sorting out exactly how this slave_*
-		API functions.
-	
-		Move call to ahd_linux_device_queue_depth to within
-		the test to see if dev is NULL.
-	
-		Add code to actually destroy our data structures to
-		the slave_destroy routine instead of waiting for a
-		command that may not come to do so.
-	
-		Initialize the name field of the host structure.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#99 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#162 edit
-
-Change 1781 by gibbs@bitkeeper-linux-2.5 on 2002/12/17 19:20:16
-
-	aic79xx.c:
-		Remove "Now packetized" diagnostic now that this
-		information is incorperated into the actual negotiation
-		messages that are displayed.
-	
-		When forcing renegotiation, don't clober the current
-		ppr_options.  Much of the driver uses this information
-		to determine if we are currently packetized or not.
-	
-		Remove some stray spaces at column 1 and ahd_set_tags.
-	
-		When complaining about getting a host message loop
-		request with no pending messages, print out the 
-		SCB_CONTROL register down on the card.
-	
-		Modify the ahd_sent_msg() routine to handle a search
-		for an outgoing identify message.  Use this to detect
-		a msg reject on an identify message which typically
-		indicates that the target thought we were packetized.
-		Force a renegotiation in this case.
-	
-		In ahd_search_qinfifo(), wait more effectively for SCB
-		DMA activities to cease.  We also clear out the state
-		that tells the sequencer that a DMA was in progress for
-		SCB fetch operations since we are about to change the
-		qinfifo.
-	
-		In ahd_pause_and_flush_work(), actually itterate through
-		the two Complete SCB lists.  Ooops.
-	
-		In ahd_qinfifo_count(), fix the qinfifo empty case.
-	
-		In ahd_dump_card_state(), print out CCSCBCTL in the
-		correct mode.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#145 edit
-
-Change 1780 by gibbs@bitkeeper-linux-2.5 on 2002/12/17 19:11:25
-
-	aic79xx.seq:
-		Add a missing ret to the last instruction in
-		load_overrun_buf.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#76 edit
-
-Change 1779 by gibbs@bitkeeper-linux-2.5 on 2002/12/17 19:10:42
-
-	aic79xx.reg:
-		Correct address for the DFDBCTL register.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#58 edit
-
-Change 1774 by scottl@scottl-template on 2002/12/16 03:08:08
-
-	       Update driver version to 1.3.0.ALPHA4
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#94 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#19 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#22 edit
-
-Change 1772 by scottl@scottl-belfalas-template on 2002/12/16 02:43:36
-
-	ahd_linux_fallback can't aquire the ahd lock since it might be
-	called from the completion handler.  Create a wrapper called
-	ahd_linux_dv_fallback that aquires and releases the ahd lock so
-	that is can be called from the DV code and still satisfy it's locking
-	needs.
-	Move the error stat code into ahd_linux_queue_cmd_complete so it
-	can catch more error conditions.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#98 edit
-
-Change 1771 by scottl@scottl-belfalas-template on 2002/12/16 02:39:22
-
-	aic79xx_proc.c:
-		Add a newline when printing the renegotiation pending message.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#11 edit
-
-Change 1770 by scottl@scottl-belfalas-template on 2002/12/15 23:38:06
-
-	aic79xx_osm.c:
-		Don't grab the ahd lock when updating error stats since
-		it's already held.
-		When deciding to do a fallback because of an error, don't
-		alias the existing devinfo struct with a new one.  Why
-		the compiler didn't catch this is beyond me.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#97 edit
-
-Change 1769 by scottl@scottl-hobbiton-0b47 on 2002/12/15 22:24:16
-
-	Regen firmware
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#52 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#33 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#53 edit
-
-Change 1768 by scottl@scottl-hobbiton-0b47 on 2002/12/15 22:24:02
-
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-		Switch to a bucket-based method of counting the number off
-		good commands in between bad ones.  Use only a single bucket
-		right now for simplicity, though this can grow in the future.
-		This also removes the stats timer.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#96 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#93 edit
-
-Change 1767 by scottl@scottl-hobbiton-0b47 on 2002/12/15 21:23:38
-
-	aic79xx_osm.h:
-		Move the errors_detected field to the target structure, and
-		add new_errors_detected field for doing stats decay.
-	
-	aic79xx_osm.c:
-		If a transmission error is detected, increment the
-		new_errors_detected counter.  If it's passed the threshold,
-		call for a speed fallback.
-		Update the errors_detected field with new_errors_detected and
-		reset new_errors_detected on every stats timeout call.
-	
-	aic79xx_proc.c:
-		Display the per-target errors detected field.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#95 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#92 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#10 edit
-
-Change 1766 by gibbs@aslan on 2002/12/15 19:32:13
-
-	Add interrupt coalessing hooks.
-	
-	aic79xx.c:
-		Keep a copy of the hs_mailbox in our softc so that
-		we can perform read/modify/write operations on the
-		hs_mailbox without having to pause the sequencer to
-		read the last written value.  Use the ENINT_COALESS
-		flag in the hs_mailbox to toggle interrupt coalessing.
-	
-		Add entrypoints for enabling interrupt coalessing and
-		setting both a timeout (how long to wait for commands
-		to be coalessed) and a maximum commands to coaless value. 
-	
-		In ahd_pause_and_flushwork() only return one selections
-		are safely disabled.  We now also flush the two sequencer
-		lists of completed commands.
-	
-	aic79xx.h:
-		Add coalessing and HS_MAILBOX fields.
-	
-	aic79xx.reg:
-		Correct register addresses related to the software timer.
-	
-		Add constants paramaterizing the software timer.
-	
-		Add scratch ram locations for storing interrupt coalessing
-		tunables.
-	
-	aic79xx.seq:
-		Use the software timer and a commands completed count to
-		implement interrupt coalessing.  The command complete is
-		deferred until either the maximum command threshold or a
-		timer since the first command completed since the last
-		completion expires.
-	
-		Move the test for the cfg4istat interrupt up an instruction
-		to hopefully close a race between the next outgoing selection
-		and our disabling of selections.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#144 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#77 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#57 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#75 edit
-
-Change 1765 by gibbs@aslan on 2002/12/15 17:48:29
-
-	aicasm_gram.y:
-		Allow constants to be complex expressions so long
-		as those expressions can be fully evaluated during
-		assembly.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#28 edit
-
-Change 1764 by scottl@scottl-hobbiton-0b47 on 2002/12/13 18:09:34
-
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-		Start of runtime fallback and interrupt caolescing stat
-		gathering.  Run ahd_linux_stats_update() every
-		AHD_LINUX_STATS_INTERVAL period.  Consense the packetized
-		and non-packetized autosense code and start some logic to
-		figure out what to do with the sense information.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#94 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#91 edit
-
-Change 1762 by gibbs@bitkeeper-linux-2.5 on 2002/12/13 13:08:43
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Remove *slave_alloc declarations as we don't need or
-		export this entry point.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#93 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#161 edit
-
-Change 1761 by gibbs@bitkeeper-linux-2.4 on 2002/12/12 14:31:11
-
-	aiclib.h:
-		Add aic_sector_div macro.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aiclib.h#4 edit
-
-Change 1760 by gibbs@bitkeeper-linux-2.4 on 2002/12/12 14:30:40
-
-	aic79xx_osm.h:
-	aic7xxx_osm.h:
-		Complete adjustment for host template changes.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#90 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#109 edit
-
-Change 1759 by gibbs@bitkeeper-linux-2.5 on 2002/12/12 14:25:19
-
-	aic79xx_osm.h:
-		Remove a stray reference to aic79xx_host.h.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#89 edit
-
-Change 1754 by gibbs@bitkeeper-linux-2.4 on 2002/12/12 11:45:59
-
-	aic79xx_host.h:
-	aic7xxx_host.h:
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Eliminate separate Linux host template files and move
-		all host template entry ponts to one section of the Linux
-		osm.c file.
-	
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Add support for larger disks under 2.5.X.
-	
-	Changes prodded by: Christoph Hellwig <hch@sgi.com>
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_host.h#14 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#92 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#18 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#16 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#160 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#41 edit
-
-Change 1751 by scottl@scottl-template on 2002/12/10 21:41:30
-
-	       Update driver version to 6.2.23
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#108 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/aic7xxx.spec#9 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/install.sh#12 edit
-
-Change 1750 by gibbs@bitkeeper-linux-2.4 on 2002/12/10 20:51:23
-
-	aic79xx_host.h:
-	aic7xxx_host.h:
-		Set single_sg_okay for RH AS 2.1 too.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_host.h#13 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#15 edit
-
-Change 1749 by gibbs@bitkeeper-linux-2.4 on 2002/12/10 20:45:35
-
-	aic79xx_host.h:
-	aic7xxx_host.h:
-		Use CONFIG_HIGHIO as the gating define for whether
-		the highmem_io host template field is present.  Also
-		assume that if the kernel version is less than 2.4.18,
-		then we must be under RedHat and need to call this field
-		can_dma_32.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_host.h#12 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#14 edit
-
-Change 1748 by scottl@scottl-template on 2002/12/10 19:54:55
-
-	       Update driver version to 1.3.0.ALPHA3
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#88 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#18 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#20 edit
-
-Change 1747 by gibbs@bitkeeper-linux-2.4 on 2002/12/10 18:49:21
-
-	aic79xx_host.h:
-	aic7xxx_host.h:
-		Enable the highmem_io option on kernels with the
-		new highmem bouncing code.
-	
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Fix compilation error in the non-debug enabled case.
-	
-	aic7xxx_osm.c:
-		Remove leftover #if 0'd code from DV merge.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_host.h#11 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#91 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#13 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#159 edit
-
-Change 1746 by gibbs@bitkeeper-linux-2.5 on 2002/12/10 12:05:15
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Disable the shutdown hook for 2.5.X since it is called
-		to early to be useful.  Some other strategy will need to
-		be found.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#90 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#158 edit
-
-Change 1745 by gibbs@bitkeeper-linux-2.5 on 2002/12/09 16:29:02
-
-	aic79xx_host.h:
-	aic79xx_osm.c:
-	aic79xx_osm_pci.c
-	aic7xxx_host.h:
-	aic7xxx_osm.c:
-	aic7xxx_osm_pci.c:
-		Conform to latest 2.5.X API changes.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_host.h#10 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#89 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#17 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#12 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#157 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#40 edit
-
-Change 1743 by gibbs@bitkeeper-linux-2.4 on 2002/12/09 15:16:31
-
-	aic79xx.c:
-		Limit the syncrate after all option conformance
-		changes have taken place in ahd_devlimited_syncrate.
-		Changes in options may change the final syncrate we
-		accept.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#143 edit
-
-Change 1741 by gibbs@bitkeeper-linux-2.4 on 2002/12/09 14:11:44
-
-	Makefile:
-		Turn off -g.
-
-Affected files ...
-
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Makefile#10 edit
-
-Change 1740 by scottl@scottl-template on 2002/12/09 10:15:50
-
-	       Update driver version to 6.2.22
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#107 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/aic7xxx.spec#8 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/install.sh#11 edit
-
-Change 1737 by scottl@scottl-template on 2002/12/06 16:14:24
-
-	       Update driver version to 1.3.0.ALPHA2
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#87 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#17 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#19 edit
-
-Change 1736 by gibbs@overdrive on 2002/12/06 16:04:51
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#51 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#32 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#52 edit
-
-Change 1735 by gibbs@bitkeeper-linux-2.4 on 2002/12/06 16:03:54
-
-	aic79xx.h:
-		Use consistent names for AH?_ASYNC_XFER_PERIOD.
-	
-	aic79xx.c:
-	aic79xx_proc.c:
-		Print out IU, QAS, and RTI features when showing
-		transfer options.
-	
-	aic79xx.c:
-		Save and restore the NEGOADDR address when setting
-		new transfer settings.  The sequencer performs lookups
-		in the negotiation table too and it expects NEGOADDR
-		to remain consistent across pause/unpause sessions.
-	
-		Consistently use "offset" instead of "period" to determine
-		if we are running sync or not.
-	
-		Add a SHOW_MESSAGES diagnostic for when we assert ATN
-		during message processing.
-	
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		In ah?_devlimited_syncrate enforce that we can never
-		attempt DT transfers if we are narrow. 
-	
-		Remove the ALLOW_MEMIO config option.
-	
-		Modify ah?_linux_filter_inquiry to assume that the
-		inquiry buffer is large enough and has been setup
-		correctly (i.e. memset to 0 prior to command issue)
-		so that range checks are unecessary.
-	
-		Remove comments about the need to perform short inquiry
-		requests.  The code does this now.
-	
-		Split out the bottom half handling of DV inquiry results
-		to make the code clearer.
-	
-		Re-arrange the DV state machine so that:
-	
-		o REB descriptor fetching is performed ASYNC so we
-		  don't confuse a failure with the need to fallback.
-		o Devices using Level 2 DV don't bother with Level 1
-		  DV.
-		o REB collisions are retried after a delay randomized
-		  by our ID on the bus.
-		o Level 2 DV is only attempted on devices that support
-		  DT transfers.
-	
-		Fix ah?_linux_fallback to always favor the fastest
-		speed during fallback and to favor sync over async speeds.
-	
-		Don't let a target reponding to a PPR message with 0
-		options set fool us into falling back to far.  We still
-		must try to negotiate without using PPR to get by some
-		expanders.		
-	
-		Use the SCB_SILENT flag on DV commands.
-		with 0 PPR options set
-	
-		Fix large inquiry size calculation.  It was off by one.
-		We need to add 5 and not 4.
-	
-	aic79xx_osm_pci.c:
-		Tell the user that our failure of the MMAP test is non
-		fatal.  We're just dropping back to PIO.
-	
-	aiclib.c:
-	aiclib.h:
-		Add flags for a randomized delay in response to an error.
-	
-		Include table entries for REB collisions.
-	
-		Add the proper response codes for sense codes indicating
-		inquiry data has changed.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#142 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#76 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#103 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#66 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#88 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#86 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#16 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#9 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#156 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#106 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#39 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aiclib.c#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aiclib.h#3 edit
-
-Change 1734 by gibbs@bitkeeper-linux-2.4 on 2002/12/06 15:49:37
-
-	Config.in:
-		With the advent of our command line option and the
-		new memory mapped register test, there is no need
-		for a kernel compile time option to allow memory
-		mapped I/O.  Remove it.
-
-Affected files ...
-
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Config.in#10 edit
-
-Change 1733 by gibbs@bitkeeper-linux-2.4 on 2002/12/06 15:31:31
-
-	aic79xx.seq:
-		Correct ignore wide residue processing check for
-		a wide negotiation being in effect.  We must be
-		in the SCSI register window in order to access the
-		negotiation table.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#74 edit
-
-Change 1732 by gibbs@aslan on 2002/12/06 15:14:01
-
-	aicasm_gram.y:
-		Add two missing ';'s that for some reason yacc/bison
-		never complained about as a syntax error.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#27 edit
-
-Change 1730 by cde@haywire on 2002/12/05 17:55:31
-
-	Add AHD_DV_STATE_INQ_SHORT_ASYNC to probe inquiry buff len
-	<enter description here>
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#87 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#85 edit
-
-Change 1729 by gibbs@aslan on 2002/12/05 17:23:45
-
-	aic7xxx.h:
-		AHD -> AHC.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#65 edit
-
-Change 1728 by gibbs@aslan on 2002/12/05 17:21:45
-
-	aic79xx.c:
-	aic79xx.h:
-	aic7xxx.c:
-	aic7xxx.h:
-		Cleanup usage of the SCB_SILENT flag by using
-		a new macro SCB_IS_SILENT(scb).
-	
-		Apply the silent treatment to outgoing LQ CRC
-		errors.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#141 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#75 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#102 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#64 edit
-
-Change 1727 by gibbs@aslan on 2002/12/05 17:01:15
-
-	aic79xx.c
-	aic7xxx.c:
-	aic79xx.h:
-	aic7xxx.h:
-		Implement the SCB_SILENT flag.  This is useful for
-		hushing up the driver during DV or other operations
-		that we expect to cause transmission errors.  The
-		messages will still print if the SHOW_MASKED_ERRORS
-		debug option is enabled.
-	
-	aic7xxx_inline.h:
-	aic7xxx_pci.c:
-		Implement ahc_[in|out][w|l|q].  This removes the need
-		for manual 'or and shift" type operations through out
-		the driver.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#140 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#74 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#101 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#63 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#39 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#54 edit
-
-Change 1726 by gibbs@overdrive on 2002/12/04 17:33:18
-
-	Regenerate Linux firmware
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#20 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg_print.c#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#21 edit
-
-Change 1725 by gibbs@aslan on 2002/12/04 17:32:26
-
-	aic7xxx.reg:
-		Add a definition for MAX_OFFSET.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#36 edit
-
-Change 1724 by gibbs@overdrive on 2002/12/04 16:35:11
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#50 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#31 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#51 edit
-
-Change 1723 by gibbs@aslan on 2002/12/04 16:34:34
-
-	aic79xx.seq:
-		The sequencer downloading code assumes that all jump
-		labels are acurate in relation to a fully compiled
-		sequencer program (all patches downloaded).  Correct
-		a few occurances of a relative jump across a macro
-		that ended up jumping us into the last instruction
-		of the macro.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#73 edit
-
-Change 1722 by scottl@scottl-via-freebsd on 2002/12/04 15:40:08
-
-	ahd_pci.c:
-		Add a newline to the MEMIO printf.
-	
-	aic79xx_pci.c:
-		Set the mode correctly for writing to SRAM_BASE in the MEMIO
-		test.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#60 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/ahd_pci.c#11 edit
-
-Change 1721 by scottl@scottl-junior-freebsd on 2002/12/04 14:49:34
-
-	aic79xx_pci.c:
-		Use SRAM and the 0xaa55 pattern for the MEMIO test.
-	
-	ahd_pci.c:
-		Go along with ahc_pci.c and retrieve the allow_memio hint
-		from the resource manager and act on it.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#59 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/ahd_pci.c#10 edit
-
-Change 1719 by gibbs@bitkeeper-linux-2.4 on 2002/12/03 17:04:22
-
-	aic79xx_pci.c:
-		Don't attempt to set reserved bits in memio test.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#58 edit
-
-Change 1718 by gibbs@overdrive on 2002/12/03 16:16:46
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#49 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#30 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#50 edit
-
-Change 1717 by gibbs@scottl-via-freebsd on 2002/12/03 15:29:57
-
-	aic79xx_pci.c:
-		Use the TYPEPTR register as a base for our
-		memory mapped I/O test.  The Rev B. will allow
-		multi-byte access to Scratch Ram, so it is not
-		a good test of write-combining or other bad
-		behavior.
-	
-		User CLRPCIINT and CLRSPLTINT in their respective
-		handlers.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#57 edit
-
-Change 1716 by gibbs@scottl-via-freebsd on 2002/12/03 15:27:24
-
-	aic79xx.reg:
-		Correct the location of the TARGPCISTAT register.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#56 edit
-
-Change 1715 by gibbs@aslan on 2002/12/03 10:34:23
-
-	aic79xx_pci.c:
-		Revamp memory mapped I/O test to match the algorithm
-		used in the aic7xxx driver.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#56 edit
-
-Change 1714 by scottl@scottl-via-freebsd on 2002/12/02 19:12:42
-
-	aic7xxx_pci.c:
-		In the memio test, clear the FAILDIS bit of the SEQCTL
-		before running the tests so that PCI errors will be
-		flagged.
-	
-		Write only 4 bytes to the SRAM to prevent VIA chipsets
-		from generating a burst transaction on the bus.
-	
-		Clear the PCIR_STATUS register and restore the SEQCTL
-		register before exiting.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#53 edit
-
-Change 1713 by gibbs@aslan on 2002/12/02 13:04:29
-
-	aic79xx_pci.c:
-		Properly report the aic7901A as an aic7901A.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#55 edit
-
-Change 1710 by scottl@scottl-junior-freebsd on 2002/11/27 02:05:18
-
-	Fix a spelling mistake and a whitespace goof.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#52 edit
-
-Change 1709 by scottl@scottl-junior-freebsd on 2002/11/26 22:12:00
-
-	Strip down the $FreeBSD$
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#11 edit
-
-Change 1708 by scottl@scottl-junior-freebsd on 2002/11/26 21:56:03
-
-	Revert whitespace changes in ahc_syncrates[] to reduce diffs.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#100 edit
-
-Change 1699 by gibbs@bitkeeper-linux-2.4 on 2002/11/20 14:14:13
-
-	aic79xx_osm_pci.c:
-	aic7xxx_osm_pci.c:
-		Make use of the new Core PCI routine for testing memory
-		mapped register access.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#15 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#38 edit
-
-Change 1698 by gibbs@bitkeeper-linux-2.4 on 2002/11/20 14:13:40
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Make the "ALLOW_MEMIO" config option actually work for
-		the "disabled" case.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#86 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#155 edit
-
-Change 1697 by gibbs@bitkeeper-linux-2.4 on 2002/11/20 14:12:43
-
-	aic79xx.h:
-	aic79xx_pci.c:
-	aic7xxx.h:
-	aic7xxx_pci.c:
-		Add a routine for testing memory mapped register access.
-		This will hopefully detect things like buggy via chipsets
-		so that the OSM can fallback to using I/O mapped access
-		when memory mapped I/O simply will not work.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#73 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#54 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#62 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#51 edit
-
-Change 1696 by gibbs@bitkeeper-linux-2.5 on 2002/11/19 11:43:33
-
-	aiclib.h:
-		Don't include the definition for REPORT_LUNS.  It conflicts
-		with the native Linux definition.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aiclib.h#2 edit
-
-Change 1695 by scottl@scottl-template on 2002/11/18 16:45:04
-
-	       Update driver version to 1.3.0.ALPHA1
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#84 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#16 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#18 edit
-
-Change 1690 by scottl@scottl-template on 2002/11/14 18:31:41
-
-	Fix type from previous commit
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#154 edit
-
-Change 1689 by scottl@scottl-template on 2002/11/14 18:26:58
-
-	       Update driver version to 6.2.21
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#105 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/aic7xxx.spec#7 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/install.sh#10 edit
-
-Change 1688 by scottl@scottl-template on 2002/11/14 17:38:10
-
-	       Update driver version to 1.2.0
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#83 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#14 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#17 edit
-
-Change 1687 by scottl@scottl-template on 2002/11/14 17:36:51
-
-	Remove the previous change for falling back in narrow.  It doesn't
-	seem to work.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#85 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#153 edit
-
-Change 1686 by scottl@scottl-template on 2002/11/14 12:40:42
-
-	       Update driver version to 1.1.14
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#82 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#13 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#16 edit
-
-Change 1685 by scottl@scottl-template on 2002/11/14 12:40:17
-
-	aic79xx_osm.c
-	aic7xxx_osm.c
-		Add a minimum bus settle delay after doing a bus reset from
-		the DV timeout handler.
-	
-		Limit the max period allowed for narrow when figuring out
-		the narrow fallback speed.
-	
-	aic7xxx.h
-		Add AHD_ULTRA2_XFER_PERIOD for narrow fallback calculations
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#61 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#84 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#152 edit
-
-Change 1683 by scottl@scottl-template on 2002/11/13 20:49:54
-
-	       Update driver version to 1.1.13
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#81 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#12 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#15 edit
-
-Change 1680 by gibbs@vas2209a on 2002/11/13 19:08:38
-
-	aic7xxx_osm.c:
-		Use ahc_set_tags rather than ahc_platform_set_tags so
-		that the core can be appraised of any tag type or depth
-		changes.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#151 edit
-
-Change 1679 by gibbs@vas2209a on 2002/11/13 19:03:23
-
-	aic7xxx_osm.c:
-		Add a back in a missing ahc_done_unlock() that was
-		lost in the last change.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#150 edit
-
-Change 1678 by gibbs@bitkeeper-linux-2.5 on 2002/11/13 18:26:28
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Requeue deferred command completions so that when the
-		timer does expire the entries are actually sent. <sigh>
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#83 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#149 edit
-
-Change 1676 by gibbs@bitkeeper-linux-2.5 on 2002/11/13 16:26:07
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Move a FALLTHROUGH label to the correct
-		location in the code.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#82 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#148 edit
-
-Change 1675 by gibbs@vas2209a on 2002/11/13 15:43:19
-
-	aic79xx.c:
-		Set WIDERESEN for Rev B which ensures that an
-		expected wide residue does not prevent the
-		FIFO from reporting FIFOEMP.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#139 edit
-
-Change 1674 by gibbs@vas2209a on 2002/11/13 14:27:15
-
-	aic79xx_host.h:
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Correct a few minor compile issues that fell out of
-		the port to 2.5.X.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_host.h#9 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#81 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#147 edit
-
-Change 1673 by gibbs@bitkeeper-linux-2.5 on 2002/11/13 13:43:15
-
-	aic79xx_host.h:
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-	aic7xxx_host.h:
-	aic7xxx_osm.c:
-	aic7xxx_osm.h:
-		Complete the port to Linux 2.5.X.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_host.h#8 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#80 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#80 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#11 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#146 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#104 edit
-
-Change 1672 by gibbs@bitkeeper-linux-2.4 on 2002/11/13 13:02:15
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Remove fallback from the Read Echo Buffer Descriptor
-		DV state.  This avoids issues with tape drives that
-		just hang if you issue the command.  We should really
-		be issuing the command async, but that is too complicated
-		a fix for PH1.2.  Defer that fix to PH1.3.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#79 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#145 edit
-
-Change 1671 by gibbs@aslan on 2002/11/13 12:10:23
-
-	aic79xx.c:
-		Correct code that restore the STACK.  It was
-		always placing a 0 in the high byte of the stack
-		address.
-	
-	aic7xxx.c:
-		Remove unecessary restoration of the STACK for older
-		chips.
-	
-	aic7xxx.h:
-	aic79xx.h:
-		Collapse SCB flag entries so they are bit contiguous.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#138 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#72 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#99 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#60 edit
-
-Change 1670 by gibbs@bitkeeper-linux-2.4 on 2002/11/13 11:46:51
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		To avoid stack explosion in the mid-layer, only complete
-		AH?_LINUX_MAX_RETURNED_ERRORS commands that have errors
-		at a time.  Any deferred entries will be returned via
-		a timer that runs the queue.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#78 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#144 edit
-
-Change 1669 by gibbs@vas2209a on 2002/11/13 00:14:42
-
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-	aic7xxx_osm.c:
-	aic7xxx_osm.h:
-		Don't allow the eh_sem to be up'ed twice in the
-		case of the eh timer expiring and the command completing
-		due to a future recovery action such as a bus reset.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#77 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#79 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#143 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#103 edit
-
-Change 1668 by gibbs@vas2209a on 2002/11/13 00:01:03
-
-	aic79xx.c:
-		Add DFFSTAT in mode 3 to ahd_dump_card_state().
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#137 edit
-
-Change 1667 by gibbs@overdrive on 2002/11/12 23:57:48
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#48 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#29 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#49 edit
-
-Change 1666 by gibbs@aslan on 2002/11/12 23:55:24
-
-	aic79xx.reg:
-	aic79xx.seq:
-		Workaround Rev B issue with CURRFIFO_0 having the
-		same value in "enhanced mode" as "standard mode"
-		for "writes".  Reads of the register behave as
-		expected. <sigh>
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#55 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#72 edit
-
-Change 1662 by gibbs@overdrive on 2002/11/12 14:59:39
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#47 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#28 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#48 edit
-
-Change 1661 by gibbs@vas2209a on 2002/11/12 14:58:23
-
-	aicasm_gram.y:
-		Use a direct move from allzeros to emulate a
-		mvi of 0.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#26 edit
-
-Change 1660 by gibbs@vas2209a on 2002/11/12 10:33:25
-
-	aic7xxx.h:
-		Add a missing typedef.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#59 edit
-
-Change 1659 by gibbs@overdrive on 2002/11/11 23:37:31
-
-	Regenerate Linux Firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#46 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#27 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#47 edit
-
-Change 1658 by gibbs@overdrive on 2002/11/11 23:35:30
-
-	aic79xx_pci.c:
-		Set the PREQDIS bit in DEVCONFIG1 for the B.  The
-		bit is misnamed, but seems to disable a work-around 
-		that breaks on the B on PCI busses.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#53 edit
-
-Change 1657 by gibbs@overdrive on 2002/11/11 23:34:43
-
-	aic79xx.seq:
-		Return to the SCSI mode prior to re-allocating a FIFO.
-		The alloc-FIFO routine assume we are in the SCSI mode.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#71 edit
-
-Change 1656 by gibbs@bitkeeper-linux-2.4 on 2002/11/11 15:37:54
-
-	aic79xx.c:
-		Printout the SAVED_MODE scratch ram location in ahd_dump_card_state.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#136 edit
-
-Change 1655 by gibbs@bitkeeper-linux-2.4 on 2002/11/11 14:22:01
-
-	aic79xx_osm.c:
-	aic79xx_osm.h
-	aic7xxx_osm.c:
-	aic7xxx_osm.h
-		Add a timer for deferred running of the completion
-		queue.  We use this to return commands back to the OS
-		when our queue is frozen that happen to arrive before
-		Linux sees that our host queue is blocked.  This avoids
-		a deadlock issue that occurs should we attempt to simply
-		scsi_done the command immediately.  This strategy also
-		guarantees that the commands are returned almost imediately
-		instead of having to wait for either a DV command or simq
-		release to occur.
-	
-		Add the ability to reset a command's timeout from within
-		the core.  We use this to give RequestSense operations
-		a new timer.
-	
-		Always perform DV thread operations while our ah?_lock
-		is held.
-	
-	aic79xx.c:
-	aic7xxx.c:
-		Make use of the new ah?_scb_timer_reset() api.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#135 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#98 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#76 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#78 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#142 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#102 edit
-
-Change 1654 by scottl@scottl-belfalas-rh72as on 2002/11/08 19:15:45
-
-	aic79xx_osm.c:
-		Remove unused variable.
-	
-		Move ahd_linux_thread_run_complete_queue() to its
-		proper location in the file.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#75 edit
-
-Change 1653 by scottl@scottl-belfalas-rh72as on 2002/11/08 19:10:04
-
-	aic79xx_osm.c:
-		Fix deadlock in ahd_linux_queue() when we want to
-		return a command immediately to the system because
-		our queue is blocked.  We now defer the return of
-		the command until either the simq is released or
-		the dv thread has an oportunity to flush the queue.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#74 edit
-
-Change 1652 by scottl@scottl-template on 2002/11/07 23:34:47
-
-	       Update driver version to 6.2.20
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#101 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/aic7xxx.spec#6 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/install.sh#8 edit
-
-Change 1650 by gibbs@aslan on 2002/11/07 13:55:31
-
-	aic79xx.c:
-		Avoid infinite loop in restoration of STACK contents
-		in ahd_dump_card_state().  Our interrator must be
-		signed.
-	
-	aic79xx.c:
-	aic7xxx.c:
-		Remove a diagnostic printf.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#134 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#97 edit
-
-Change 1649 by gibbs@bitkeeper-linux-2.4 on 2002/11/07 13:33:07
-
-	aic79xx.c:
-		Workaround printf format and integer sizing issues.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#133 edit
-
-Change 1648 by gibbs@bitkeeper-linux-2.4 on 2002/11/07 13:23:23
-
-	aic79xx.c:
-		Remove extraineous include of stdint.h.  The OSM
-		header file should be doing this.
-	
-		Remove unused variable warnings for debuging code.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#132 edit
-
-Change 1647 by gibbs@bitkeeper-linux-2.4 on 2002/11/07 13:19:35
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Mark devices as "configured" once the OS calls
-		select queue_depths.  This is required now that we
-		are no longer sniffing all inquiry cmds that the
-		OS performs.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#73 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#141 edit
-
-Change 1646 by scottl@scottl-template on 2002/11/06 23:07:03
-
-	       Update driver version to 1.1.12
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#131 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#77 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#11 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#12 edit
-
-Change 1645 by scottl@scottl-template on 2002/11/06 23:05:33
-
-	Follow the aic79xx driver and extend the timeout amount when
-	debug printing is enabled.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#140 edit
-
-Change 1644 by gibbs@bitkeeper-linux-2.4 on 2002/11/06 11:03:48
-
-	aic79xx_osm.c:
-		Be even more pessimistic about how long negotiation
-		messages take by bumping up the DV timeout a whole
-		1 second should negotiation debugging be enabled.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#72 edit
-
-Change 1643 by scottl@scottl-template on 2002/11/05 23:40:18
-
-	       Update driver version to 6.2.19
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#100 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/aic7xxx.spec#5 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/install.sh#7 edit
-
-Change 1642 by scottl@scottl-template on 2002/11/05 17:58:47
-
-	       Update driver version to 1.1.11
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#76 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#10 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#11 edit
-
-Change 1641 by gibbs@bitkeeper-linux-2.4 on 2002/11/05 16:33:24
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Not all Linux kernel versions honor the return value
-		from the queue_command driver entry point.  To deal with
-		these older kernels, always return "rejected" commands
-		via the scsi_done handler.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#71 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#139 edit
-
-Change 1640 by gibbs@bitkeeper-linux-2.4 on 2002/11/05 15:33:08
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Avoid taking the io_request lock twice.  This is a
-		regression from our port to 2.5.X.
-	
-	aic79xx_osm.c:
-		Put some more diagnostics under AHD_SHOW_RECOVERY.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#70 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#138 edit
-
-Change 1639 by gibbs@aslan on 2002/11/05 13:13:20
-
-	aic79xx.c:
-	aic79xx.h:
-	aic7xxx.c:
-	aic7xxx.h:
-		Save and restore stack contents during diagnostics.
-		Some chip variants overwrite stale entries on a 
-		stack "pop".
-	
-		Don't use 0 to probe the stack depth.  0 is the typical
-		value used to backfill the stack if entries are overwritten
-		on a "pop".
-	
-	aic79xx.c:
-	aic79xx.h:
-		Add the AHD_SHOW_RECOVERY debug option and use it to
-		control some diagnostic messages related to error recovery.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#130 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#71 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#96 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#58 edit
-
-Change 1638 by scottl@scottl-template on 2002/11/01 18:16:08
-
-	       Update driver version to 1.1.10
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#75 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#9 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#10 edit
-
-Change 1637 by gibbs@overdrive on 2002/11/01 17:17:04
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#45 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#26 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#46 edit
-
-Change 1636 by gibbs@bitkeeper-linux-2.4 on 2002/11/01 17:14:53
-
-	cam.h:
-		Add CAM_DEVQ_FROZEN to the cam_status enum.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#15 edit
-
-Change 1635 by gibbs@bitkeeper-linux-2.4 on 2002/11/01 17:14:34
-
-	Make "empty_string" static so it can be included in both the
-	aic7xxx and the aic79xx drivers.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aiclib.c#3 edit
-
-Change 1634 by gibbs@bitkeeper-linux-2.4 on 2002/11/01 17:14:08
-
-	aic7xxx.c:
-	aic7xxx.h:
-		Just for safety, have the aic7xxx driver probe
-		the stack depth too.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#95 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#57 edit
-
-Change 1633 by gibbs@bitkeeper-linux-2.4 on 2002/11/01 17:13:33
-
-	aic79xx_osm.c:
-		Correct a compile error.  The updated handling of
-		CAM_CMD_TIMEOUT was placed in the wrong routine.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#69 edit
-
-Change 1632 by gibbs@bitkeeper-linux-2.4 on 2002/11/01 17:12:22
-
-	aic79xx.seq:
-		Revert de-optimization in the fifo polling loop.
-		Our problem was caused by the larger stack size on
-		Rev B.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#70 edit
-
-Change 1631 by gibbs@bitkeeper-linux-2.4 on 2002/11/01 17:11:33
-
-	aic79xx.c:
-		Move ahd_probe_stack_size() so it matches the location
-		of its declaration.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#129 edit
-
-Change 1630 by gibbs@bitkeeper-linux-2.4 on 2002/11/01 16:19:58
-
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-	aic7xxx_osm.c:
-	aic7xxx_osm.h:
-		Actually freeze the device queue in response to a request
-		to do so from the Core.  This closes a race in the case
-		of things like QUEUE FULL or BUSY handling where the
-		OSM may be able to queue additional commands prior to
-		seeing the SCB that should have frozen or otherwise altered
-		the execution queue.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#68 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#74 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#137 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#99 edit
-
-Change 1629 by gibbs@overdrive on 2002/11/01 16:17:55
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#44 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#25 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#45 edit
-
-Change 1628 by gibbs@aslan on 2002/11/01 16:11:16
-
-	aic79xx.c:
-	aic79xx.h:
-	aic79xx.reg:
-		Add a routine to dynamically determine the size
-		of the sequencer stack.  It turns out that RevB
-		has a 9 entry stack rather than the 8 entry stack
-		of the A4.  Determining the stack depth programatically
-		should protect us from any future changes in this area.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#128 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#70 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#54 edit
-
-Change 1626 by scottl@scottl-template on 2002/10/31 16:38:49
-
-	       Update driver version to 1.1.9
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#73 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#8 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#9 edit
-
-Change 1625 by scottl@scottl-template on 2002/10/31 15:47:57
-
-	       Update driver version to 6.2.18
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#98 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/aic7xxx.spec#4 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/install.sh#6 edit
-
-Change 1623 by scottl@scottl-template on 2002/10/31 14:47:46
-
-	Define SCSI_NOSENSE_STRINGS to elimiate the asc/ascq description
-	strings.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aiclib.c#2 edit
-
-Change 1622 by scottl@scottl-template on 2002/10/31 14:44:19
-
-	Don't lock the io_request_lock until after calling
-	ahd_linux_register_host().
-	Release the ahd lock when calling kernel_thread()
-	
-	This fixes a deadlock when launching the DV thread in
-	older 2.4 SMP kernels.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#136 edit
-
-Change 1621 by scottl@scottl-template on 2002/10/31 14:17:54
-
-	Don't lock the io_request_lock until after calling
-	ahd_linux_register_host().
-	Release the ahd lock when calling kernel_thread()
-	
-	This fixes a deadlock when launching the DV thread in
-	older 2.4 kernels.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#67 edit
-
-Change 1618 by scottl@scottl-template on 2002/10/30 19:48:52
-
-	       Update driver version to 1.1.8
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#72 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/aic79xx.spec#7 edit
-... //depot/linux_mod_devel/scsi.aic79xx/rpm/install.sh#8 edit
-
-Change 1616 by scottl@scottl-template on 2002/10/30 19:05:51
-
-	       Update driver version to 6.2.17
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#97 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/aic7xxx.spec#3 edit
-... //depot/linux_mod_devel/scsi.aic7xxx/rpm/install.sh#3 edit
-
-Change 1615 by gibbs@overdrive on 2002/10/30 18:35:23
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#43 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#24 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#44 edit
-
-Change 1614 by gibbs@aslan on 2002/10/30 18:34:26
-
-	aic79xx.seq:
-		Rearrange idle_loop_service_fifo:  I have a hunch
-		that the sequencer does not like the optimized version
-		of this routine should we be paused at the start of
-		a longjmp handler.  We now change this to look just
-		as it did in PH 1.1.
-	
-		Clear the longjmp address of the p_data handler just
-		after we call disable_ccsgen.  Otherwise the longjmp
-		handler may not be deregistered until an extra call
-		into the handler or a new handler is installed.  The
-		first behavior might be dangerous if the FIFO is not
-		active.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#69 edit
-
-Change 1613 by gibbs@overdrive on 2002/10/30 16:52:10
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#42 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#23 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#43 edit
-
-Change 1612 by gibbs@aslan on 2002/10/30 16:50:11
-
-	aic79xx.seq:
-		Test for SCSIPERR instead of relying on SCSIPHASE
-		not setting on a SCSI parity error.  It seems that
-		this is not the case and that we occassionally coast
-		out of routines like phase_lock when a parity error
-		is pending.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#68 edit
-
-Change 1611 by gibbs@aslan on 2002/10/30 12:55:46
-
-	aic7770.c:
-		Add IDs for some Olivetti OEM aic7770 based cards.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#27 edit
-
-Change 1610 by gibbs@bitkeeper-linux-2.4 on 2002/10/30 12:27:14
-
-	aic7xxx.c:
-		Don't disable ENBUSFREE when single stepping on
-		a DT capable controller.  We cannot re-enable unexpected
-		busfree detection, so we must clear BUSFREE on each
-		step instead.
-	
-		Correct the lookup of the SCB ID in ahc_handle_proto_error.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#94 edit
-
-Change 1609 by gibbs@aslan on 2002/10/30 12:25:51
-
-	aic79xx.h:
-		Remove redundant declaration of ahd_print_devinfo().
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#69 edit
-
-Change 1608 by gibbs@bitkeeper-linux-2.4 on 2002/10/30 11:38:28
-
-	aic7xxx_osm.c:
-		Bring in DV state machine enhancements from the U320
-		driver.
-	
-	aic79xx_osm.c:
-		Remove a left over diagnostic.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#66 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#135 edit
-
-Change 1607 by gibbs@bitkeeper-linux-2.4 on 2002/10/30 10:13:52
-
-	Pull DV branch into the mainline.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#127 integrate
-... //depot/aic7xxx/aic7xxx/aic79xx.h#68 integrate
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#39 integrate
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#93 integrate
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#56 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#65 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#71 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#8 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#134 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#96 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#23 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aiclib.c#1 branch
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aiclib.h#1 branch
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#14 integrate
-
-Change 1604 by gibbs@overdrive on 2002/10/29 18:59:13
-
-	aic79xx_osm.c:
-		Correct module description to properly identify the
-		driver as AIC79XX.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#64 edit
-
-Change 1597 by gibbs@overdrive on 2002/10/29 14:09:41
-
-	aic79xx_osm_pci.c:
-		Remove redundant check for PCI-X controller.  The bug
-		flag should be enough.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#14 edit
-
-Change 1596 by gibbs@overdrive on 2002/10/29 14:09:13
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#41 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#22 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#42 edit
-
-Change 1592 by gibbs@aslan on 2002/10/29 11:05:58
-
-	Implement work around for the Interrupt collission problem
-	on the 7902B.
-	
-	aic79xx.c:
-		When a sequencer interrupt occurs on the B, unpause
-		the sequencer and allow it to clear SEQINTCODE with
-		a second SEQINT prior to processing the "real" seqint.
-		This clears SEQINTCODE without requiring an extra
-		interrupt.
-	
-		Convert the SAW_HWERR sequencer interrupt into a
-		call to ahd_handle_hwerrint().
-	
-	aic79xx.h:
-		Add AHD_INTCOLLISION_BUG.
-	
-		Add NO_SEQINT, which is the special value that we
-		use to initialize SEQINTCODE so that the host can
-		tell if there is a real SEQINT pending.
-	
-	aic79xx.reg:
-		Add SET_SEQINTCODE() macro to special case sequencer
-		interrupt processing based on AHD_INTCOLLISION_BUG.
-	
-	aic79xx.seq
-		Whenever the sequencer is restarted, insure that
-		SEQINTCODE is properly initialized.
-	
-		Convert a non-zero ERROR status to a SAW_HWERR
-		sequencer interrupt.
-	
-		Add set_seqint_work_around which will clear SEQINTCODE
-		after every SEQINT.
-	
-		Use SET_SEQINTCODE throughout the firmware.
-	
-	aic79xx_inline.h:
-		Use a read of HCNTRL to flush our write to CLRCMDCMPLT
-		on the RevB.  This allows us to check to see if the sequencer
-		is paused and to initiate the interrupt collision workaround
-		without incuring an extra read.
-	
-	aic79xx_pci_c:
-		Set AHD_INTCOLLISIONT_BUG for the Rev B.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#126 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#67 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#53 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#67 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#38 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#52 edit
-
-Change 1590 by gibbs@overdrive on 2002/10/28 18:12:32
-
-	Regernerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#40 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#21 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#41 edit
-
-Change 1588 by gibbs@aslan on 2002/10/28 14:39:15
-
-	aic79xx_inline.h:
-		Add our controller name to the front of our
-		diagnostic "Setting Mode" messages.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#37 edit
-
-Change 1587 by gibbs@aslan on 2002/10/28 14:38:45
-
-	aic79xx.c:
-	aic79xx.reg:
-		Some 160 devices incorrectly accept 0xfe as a
-		sync offset, but will overrun this value.  Limit
-		to 0x7f for speeds lower than U320 which will
-		avoid the persistent sync offset overruns.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#125 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#52 edit
-
-Change 1574 by gibbs@overdrive on 2002/10/26 20:42:36
-
-	aic7xxx_osm.c:
-		Add "paused = TRUE" in ahc_queue_recovery_cmd which
-		was lost in the conversion to use ahc_pause_and_flush_work().
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#133 edit
-
-Change 1572 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/10/26 01:10:28
-
-	       Update driver version
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#70 edit
-
-Change 1570 by gibbs@aslan on 2002/10/25 23:53:19
-
-	aic79xx_pci.c:
-		Remove stray/random extra 7901A generic PCI
-		table entry.  Also switch the correct 7901A
-		generic entry to use ID_ALL_MASK since we
-		can only differentiate the 7901A from the
-		7902 by checking for a "type field" of 0xE.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#51 edit
-
-Change 1565 by gibbs@overdrive on 2002/10/25 20:45:29
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#39 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#20 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#40 edit
-
-Change 1564 by gibbs@aslan on 2002/10/25 20:44:25
-
-	aic79xx.h:
-		Add "feature" AHD_NEW_DFCNTRL_OPTS for SCSIENWRDIS.
-	
-	aic79xx.reg:
-		Add the SCSNENWRDIS field and the PLLDELAY register
-		definitions.
-	
-	aic79xx.seq:
-		Use SCSIENWRDIS when setting PRELOADEN on all
-		SG element writes save the first one on chips
-		that support this feature so that SCSIEN does
-		not get corrupted.
-	
-		Correct a bug in the legacy bitbucket handler.
-		We must save and restore our mode pointer now
-		that we can be using both FIFOs.
-	
-	aic79xx_pci.c:
-		PREQDIS in DEVCONFIG1 went away after the A2.
-		Remove all code that references this bit.  This
-		is especially important since this bit was reused
-		in the B for a different HW fix workaround.
-	
-		Properly set the AHD_NEW_IOCELL_OPTS and
-		AHD_NEW_DFCNTRL_OPTS features for the B.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#66 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#51 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#66 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#50 edit
-
-Change 1540 by gibbs@bitkeeper-linux-2.4 on 2002/10/23 12:53:14
-
-	Make it possible for both the aic7xxx and the aic79xx driver
-	to rely on scsi_all.c yet still be built into the same kernel.
-	Since we can't use a module dependency to have a "library module",
-	symbols are renamed and the code included in each driver.
-
-Affected files ...
-
-... //depot/aic7xxx-dv/aic7xxx/aic79xx.c#8 edit
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#9 edit
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#8 edit
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#3 edit
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#30 edit
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#13 edit
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#3 edit
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/cam.c#2 delete
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/cam.h#4 edit
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/scsi_all.c#2 edit
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/scsi_all.h#2 edit
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Makefile#9 edit
-
-Change 1538 by gibbs@aslan on 2002/10/22 21:45:34
-
-	aic79xx.c:
-		Modify use_ppr handling in ahd_build_transfer_message
-		to match the aic7xxx driver.
-	
-	aic7xxx.c:
-		Move a comment and remove a useless clearing of use_ppr.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#124 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#92 edit
-
-Change 1537 by gibbs@aslan on 2002/10/22 21:38:02
-
-	aic7xxx.c:
-		Bring back "use_ppr".  We need to use_ppr anytime
-		doppr is true or we have non-zero protocol options.
-		The later case was not handled in the recent removal
-		of use_ppr.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#91 edit
-
-Change 1528 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/10/22 12:00:33
-
-	       Update driver version
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#69 edit
-
-Change 1526 by gibbs@bitkeeper-linux-2.4 on 2002/10/22 11:54:03
-
-	Integrate from Head into aic7xxx-dv.
-
-Affected files ...
-
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#6 integrate
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#6 integrate
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#6 integrate
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#3 integrate
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic7xxx_reg_print.c#3 integrate
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#3 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Makefile#8 edit
-
-Change 1525 by gibbs@overdrive on 2002/10/22 11:53:24
-
-	Regerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#38 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#19 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#39 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#19 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg_print.c#6 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#20 edit
-
-Change 1520 by gibbs@aslan on 2002/10/21 20:40:11
-
-	aic7xxx.c:
-		Add a newline to ahc_dump_card_state() output.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#90 edit
-
-Change 1519 by gibbs@aslan on 2002/10/21 20:39:23
-
-	aic7xxx.c:
-		Update ahc_reg_print() to handle a NULL cur_col.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#89 edit
-
-Change 1518 by gibbs@aslan on 2002/10/21 20:37:24
-
-	aic7xxx.c:
-		Add additional diagnostic output to ahc_dump_card_state(),
-		and have it use the register pretty printing functions.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#88 edit
-
-Change 1517 by gibbs@aslan on 2002/10/21 16:30:21
-
-	aic7xxx.seq:
-		Move data fifo CLRCHN to mesgin_rdptrs which is a safer
-		location for doing this operation.  This also saves a
-		sequencer instruction.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#52 edit
-
-Change 1516 by gibbs@aslan on 2002/10/21 16:18:49
-
-	aic79xx.seq:
-		Clarify a comment in the mesgin_rdptrs handler.
-		We need to clear the data fifo for CMD retries too.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#65 edit
-
-Change 1515 by gibbs@overdrive on 2002/10/21 16:06:12
-
-	aic7xxx_osm.c:
-		Adapt to conversion from IDENTIFY_SEEN to NO_IDENTIFIED.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#132 edit
-
-Change 1514 by gibbs@aslan on 2002/10/21 15:58:42
-
-	aic79xx.c:
-		Move "false parity error due to REQ release glitch"
-		workaround to the packetized busfree handler.  We
-		now only look to see if this is the potential cause
-		of the error if we have ruled out all other causes.
-		Before, it might be possible for this workaround
-		to trigger on "real" busfrees.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#123 edit
-
-Change 1513 by gibbs@overdrive on 2002/10/21 15:53:19
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#37 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#18 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#38 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#18 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg_print.c#5 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#19 edit
-
-Change 1512 by gibbs@aslan on 2002/10/21 15:51:41
-
-	aic79xx.c:
-	aic79xx.seq:
-		Handle unexpected command phases in the protocol violation
-		handler.  Right now we treat these just like data phase
-		protocol violations.
-	
-	aic79xx.seq:
-		Optimize out a few instructions by using a common label
-		for protocol violations in mesgin and status phases.  One
-		more instruction was removed by factoring out the status
-		received check in the mesgin_complete handler.
-	
-	aic7xxx.c:
-	aic7xxx.h:
-	aic7xxx.reg:
-	aic7xxx.seq:
-		Bring in the protocol violation handler from the U320
-		driver and replace the NO_IDENT sequencer interrupt code
-		with the PROTO_VIOLATION code.  Support for this code
-		required the following changes:
-	
-		SEQ_FLAGS:
-			IDENTIFY_SEEN -> NOT_IDENTIFIED
-			Added NO_CDB_SENT
-	
-		SCB_CONTROL:
-			TARGET_SCB == STATUS_RCVD for initiator mode
-	
-		scb->flags:
-			Added SCB_TARGET_SCB since we cannot rely on
-			TARGET_SCB as a target/initiator differentiator
-			due to it being overloaded in initiator mode to
-			indicate that status has been received.
-	
-	aic7xxx.seq:
-		Reset the FIFO whenever a short CDB transfer occurs
-		so that the FIFO contents do not corrupt a future CDB
-		transfer retry.
-	
-		Add support for catching the various protocol violations
-		handled by ahc_handle_protocol_violation.
-	
-		Reformat some comments.
-	
-	aic7xxx_osm.c:
-		Handle changes to SCB_CONTROL, scb->flags and SEQ_FLAGS.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#122 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#64 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#87 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#55 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#35 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#51 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.c#12 edit
-
-Change 1511 by gibbs@overdrive on 2002/10/18 17:37:10
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#36 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#17 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#37 edit
-
-Change 1509 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/10/18 17:33:40
-
-	Remove the DV framework from aic79xx.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#63 edit
-
-Change 1508 by scottl@scottl-template on 2002/10/18 15:27:23
-
-	Update to 6.2.13
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#95 edit
-
-Change 1505 by scottl@scottl-template on 2002/10/17 18:48:26
-
-	Integrate from aic7xxx-dv branch.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#86 integrate
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#54 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#62 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#131 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#94 integrate
-
-Change 1491 by gibbs@bitkeeper-linux-2.5 on 2002/10/15 18:51:15
-
-	aic79xx.reg:
-		Remove duplicate field.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#50 edit
-
-Change 1490 by gibbs@bitkeeper-linux-2.5 on 2002/10/15 18:44:45
-
-	aic79xx.reg:
-		Bring in Rev B SNAPSHOT and SLOWCRC bit fields from
-		the DV branch.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#49 integrate
-
-Change 1488 by gibbs@bitkeeper-linux-2.5 on 2002/10/15 18:38:54
-
-	README.aic79xx:
-		Correct rd_strm section to match correct syntax.
-	
-		Add amplitude, precomp, and slewrate options.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/README.aic79xx#4 edit
-
-Change 1487 by gibbs@bitkeeper-linux-2.5 on 2002/10/15 18:30:42
-
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-		Add code to set precomp, slewrate, and amplitude on
-		a per-controller basis.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#61 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#68 edit
-
-Change 1486 by gibbs@bitkeeper-linux-2.5 on 2002/10/15 18:30:16
-
-	aic79xx.h:
-	aic79xx_pci.c:
-		SLEW -> SLEWRATE
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#65 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#49 edit
-
-Change 1484 by gibbs@overdrive on 2002/10/15 17:00:52
-
-	Regenerate Linux firmware and register definitions.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#35 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#16 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#36 edit
-
-Change 1483 by gibbs@aslan on 2002/10/15 14:53:35
-
-	Move IOCell paramters into softc and add a hook for the
-	OSM to modify these as well as other settings prior to
-	committing them to the chip.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#121 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#64 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#48 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#48 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.h#15 edit
-
-Change 1482 by gibbs@bitkeeper-linux-2.5 on 2002/10/15 10:05:36
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Promote si.memsize to 64 bits pefore shifting by
-		PAGE_SIZE so that the returned value is not truncated
-		to 64GB.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#60 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#130 edit
-
-Change 1481 by scottl@scottl-template on 2002/10/15 00:59:37
-
-	Integrate debugging info nit from aic7xxx-dv
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#129 integrate
-
-Change 1480 by scottl@scottl-template on 2002/10/15 00:57:33
-
-	Update to version 6.2.12
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#93 edit
-
-Change 1478 by scottl@scottl-template on 2002/10/15 00:22:14
-
-	Integrate from the aic7xxx-dv branch
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#53 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#128 integrate
-
-Change 1474 by scottl@scottl-template on 2002/10/14 10:57:29
-
-	Integrate the aic7xxx dv work into head
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#85 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#127 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#92 edit
-
-Change 1465 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/10/10 16:11:43
-
-	Add three new insmod tunables for the IO Cell.  They let you control
-	the slewrate, precomp, and amplitude.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#120 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#59 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#67 edit
-
-Change 1462 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/10/09 21:49:56
-
-	Add updated H2B identifiers
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#47 edit
-... //depot/linux_mod_devel/scsi.aic79xx/dud/redhat/pcitable#2 edit
-
-Change 1457 by gibbs@bitkeeper-linux-2.4 on 2002/10/09 15:56:51
-
-	Integrate from aic7xxx -> aic7xxx_dv.
-
-Affected files ...
-
-... //depot/aic7xxx-dv/aic7xxx/aic79xx.c#3 integrate
-... //depot/aic7xxx-dv/aic7xxx/aic79xx.reg#3 integrate
-... //depot/aic7xxx-dv/aic7xxx/aic79xx.seq#3 integrate
-... //depot/aic7xxx-dv/aic7xxx/aic79xx_pci.c#3 integrate
-... //depot/aic7xxx-dv/aic7xxx/aic7xxx.c#2 integrate
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#2 integrate
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#3 integrate
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#3 integrate
-... //depot/aic7xxx-dv/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#3 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Makefile#7 edit
-
-Change 1455 by gibbs@bitkeeper-linux-2.4 on 2002/10/09 15:08:23
-
-	aic7xxx.c:
-		Only force a renegotiation on a selection timeout
-		if the SCB was valid.  Doing otherwise may be dangerous
-		as the connection was not valid for an unknown reason.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#84 edit
-
-Change 1454 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/10/09 14:45:23
-
-	       Update driver version
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#66 edit
-
-Change 1453 by gibbs@overdrive on 2002/10/09 14:44:21
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#34 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#15 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#35 edit
-
-Change 1452 by gibbs@aslan on 2002/10/09 14:43:31
-
-	The double write workaround for CURRSCB is only required if
-	abort pending is set.  Remove this work around and set the
-	abort pending bug bit on the B at least until we have better
-	confirmation that the double write is always safe.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#63 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#46 edit
-
-Change 1450 by gibbs@overdrive on 2002/10/09 00:32:41
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#33 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#14 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#34 edit
-
-Change 1449 by gibbs@aslan on 2002/10/09 00:31:44
-
-	aic79xx.c:
-		Enhance the packetized overrun handler to cover the
-		case of a data phase for an SCB that is not active.
-	
-		Update the comment on how CRC errors should be handled
-		in Harpoon2A and B.  The comment is still not fully
-		accurate.  We'll need more input from the hardware developers
-		before we can make the CRC handling really robust.
-	
-		Add diagnostics for unexpected busfrees that we take to
-		mean a negotiation message has been rejected.
-	
-		Fix several bugs in the iocell option setting code.  For
-		starters, the amplitude setting is in ANNEXCOL 6.  The
-		amplitude should also be set regardless of connection
-		speed.  The negotiation table is now updated in the
-		chip reset code which occurs after the profile information
-		is stored in our softc.  This avoids the problem of having
-		the chip reset code clear the neg table after the profile
-		code has written to it.  Lastly, only clear the negtable
-		manually on chip reset if we are on rev A.
-	
-		Remove the redundant setting of the ABORTPENDING bit.
-		I have yet to verify that aborts actually work on the B.
-	
-		Have ahd_qinfifo_requeue_tail() save and restore the
-		current mode and operate in the command channel mode.
-		ahd_qinfifo_count requires this mode and some of the
-		latest callers to ahd_qinfifo_requeue_tail() are not
-		already in the command channel mode.
-	
-		Allow register pretty printing with a NULL cur_column.
-	
-		Add a space in a register diagnostic and print out SIMODE0
-		in ahd_dump_card_state().
-	
-	aic79xx.reg:
-		Add a macro RESTORE_MODE that sets the current mode to
-		the value stored in the register passed to it.
-	
-		Add the DFFBITBUCKET bit for packetized bitbucket.
-	
-		Correct the definition of AHD_ANNEXCOL_IOCELL_OPT1.
-	
-	aic79xx.seq:
-		Clean up the structure of our idle loop.  This adds
-		a few instructions since the idle loop has been broken
-		into the following sub-routines that can be assembled
-		into customized idle loops:
-	
-			idle_loop_gsfifo	- Service the Good Status FIFO
-			idle_loop_service_fifos - Run any LONGJMP handlers
-			idle_loop_cchan		- Run command channel operations
-	
-		One or more of these routines are now called from the
-		main idle loop, the legacy idle loop, and the allocate_fifo
-		routine.  This removes a bunch of duplicated code and hopefully
-		clarifies the code flow.
-	
-		Optimize out a few instructions.
-	
-		Write to CURRSCB twice in a row since it seems that these
-		writes are sometimes flakey.
-	
-		Use the MK_MESSAGE bit in SCB_CONTROL as our abort bit.
-		We now set MK_MESSAGE on every SCB completion so that
-		reselections to idle SCBs trigger an automatic abort.
-	
-		Now that the other FIFO may be active doing packetized
-		things during a legacy connection, have the legacy
-		idle loop use a LONGJMP handler and process LONGJMP
-		handlers for both FIFOs.
-	
-		Have the CFG4OVERRUN handler use packetized bitbucket
-		if it is available.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#119 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#47 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#62 edit
-
-Change 1445 by gibbs@overdrive on 2002/10/05 00:10:28
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#32 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#13 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#33 edit
-
-Change 1444 by gibbs@aslan on 2002/10/05 00:07:22
-
-	aic79xx.c:
-		Add 4 TRACEPOINT sequencer interrupts useful for debugging.
-	
-		Record busfree time prior to clearing any critical sections
-		since we now clear any busfree interrupts while stepping.
-	
-		Add support for supressing unexpected busfree warnings
-		when we reject a QAS request after delivering a CRC
-		related message.
-	
-		Rev B hardware will not step with pending, pausing,
-		sequencer interrupts.  Turn off the interrupt enables
-		for all pausing interrupts save ENBUSFREE.  ENBUSFREE
-		must not be disabled or we will lose the ability to
-		detect unexpected busfree events until the start of
-		the next connection.  Diagnostics have also been added
-		to track the stepping process under the MISC debug category.
-	
-		Add CLROVERRUN to the list of interrupts cleared by
-		ahd_clear_intstat().
-	
-		Update PPR message conformance rules.  RTI must be
-		disabled for non-paced transfers.
-	
-		Don't apply RevA negtable corrections to the B.
-	
-		First pass at supporting RevB IOCELL settings.  Currently
-		the settings for precomp are the same for Rev A and B,
-		so they share code.  This will have to change if these
-		numbers are adjusted further.  It may be possible to remove
-		the RevA HP_BOARD options, but I still need to verify that
-		with Brandon Aubrey.
-	
-		If a device rejects a PPR message after the full PPR
-		message has been sent, assume it does not understand
-		SPI-4 PPR options and negotiate without them.  This
-		allows us to negotiate U160 with certain Fujitsu
-		U160 drives.
-	
-		Use enhanced DFFSTAT CURRFIFO status and adjust code
-		appropriately.
-	
-		CPQ->HP
-	
-		Set LQONOCHKOVER in LQOSCSCTL to avoid spurious LQO
-		overrun conditions.
-	
-		Negotiate RTI if it is available.
-	
-	aic79xx.h:
-		Add RTI and NEW_IOCELL_OPTS as AHD options enabled on
-		the B.
-	
-		Document each ahd_bug entry in the enumeration for quick
-		reference and add the AHD_LQOOVERRUN_BUG and
-		AHD_PACED_NEGTABLE_BUG entries.
-	
-		CPQ-HP
-	
-		Add the expect QAS reject busfree flag in ahd_msg_flags.
-	
-	aic79xx.reg:
-		Add four tracepoint sequencer interrupts.
-	
-		Modify CURRFIFO definition for Rev A backwards compatibility	
-		while using Rev B enhanced mode.
-	
-		Add the LQOSCSCTL register.
-	
-		Correct spelling of CURRFIFODEF in SCSCHKN.
-	
-		Add new IOCELL option ANNEX column definitions.
-	
-		Update CCSGCTL to move of CCSGEN in Rev B.  This
-		definition allows backwards compatibility, but may
-		change should we decide to optimize code due to this
-		change.
-	
-		Align QOUTFIFO_NEXT_ADDR on a 4 byte boundary since on
-		the B, this is required of any location that will be used
-		as the source for a block move to SCB/SGHADDR.
-	
-	aic79xx.seq:
-		Hit CCSCBRESET after setting the target address in
-		SCBHADDR to mirror what the CHIM sequencer does.  I
-		don't believe this has any real effect but was a holdover
-		from debugging command channel DMA operations up to
-		the host on the B.
-	
-		Simplify the run down of the qoutfifo loop by rearranging
-		it a bit.  We no longer special case loading first element.
-	
-		Allow non-pack transactions to use either FIFO without
-		waiting for the other FIFO to clear on Rev B.
-	
-		Remove an unecessary clear of SHCNT[1] and SHCNT[2] in
-		the embedded cdb transmission case.
-	
-		Do not rely on SCSIENACK being visible until at least one
-		sequencer instruction after it is written.  While this
-		is safe on RevA, the wait is required on RevB.
-	
-		Adapt to changes in the definition of CCSGCTL.
-	
-		Always perform aligned, 4byte block moves to SCB/SGHADDR.
-		Single RMW operations are still okay too.
-	
-	aic79xx_pci.c:
-		HP -> CPQ
-	
-		Rearrange IDs to better match which chips they use.
-	
-		Convert to uniform product description strings.
-	
-		Simplify 7901A setup function.
-	
-		Add the NONPACKFIFO_BUG and PACED_NEGTABLE_BUG entries
-		for the A.
-	
-		Add rev B bugs and features.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#118 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#63 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#46 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#61 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#45 edit
-
-Change 1441 by gibbs@overdrive on 2002/10/04 16:29:18
-
-	Add missing "{}"s around diagnostic code so that status packet
-	information is not printed unless the SHOW_SENSE debug flag is
-	set.  The message is only printed if the driver is compiled with
-	debug code enabled.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#117 edit
-
-Change 1432 by gibbs@overdrive on 2002/10/02 15:12:35
-
-	oder -> order.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/README.aic79xx#3 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/README.aic7xxx#2 edit
-
-Change 1427 by gibbs@bitkeeper-linux-2.4 on 2002/10/01 18:56:39
-
-	Have the Makefile do all the relative path including instead of
-	putting this in all of the include directives in the Linux OSMs.
-	This will make the module building framework happy on 8.0.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#58 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#65 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#126 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#91 edit
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Makefile#6 edit
-
-Change 1425 by gibbs@aslan on 2002/10/01 14:45:04
-
-	Add a space to the end of the ahc/ahd_print_devinfo routines
-	so that it behaves as expected by the code that uses it.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#116 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#83 edit
-
-Change 1424 by gibbs@bitkeeper-linux-2.4 on 2002/10/01 13:20:47
-
-	If the initial bus reset is diabled, attempt to negotiate async
-	rather than the fastest non-ppr rate below the user setting.  We
-	will negotiate up to the user setting once inquiry information is
-	available.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#57 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#125 edit
-
-Change 1423 by gibbs@aslan on 2002/10/01 13:13:22
-
-	aic79xx.c:
-		Fix a style nit.
-	
-		Attempt to recover from a selection timeout that
-		occurs with an invalid SCB.  This should never
-		happen, but its best to try and keep the machine
-		going.
-	
-		Force a renegotiation to a particular target after
-		a selection timeout.  This handles the case of a
-		temporary interruption in the cable that the target
-		might notice and switch back to async without creating
-		a unit attention condition.
-	
-		Add code to ignore busfree interrupts which are in
-		fact parity errors resulting from a glitchy REQ
-		release of the free running clock by a target transitioning
-		to the bus free phase.  This code needs to be tested by
-		FTL.  A diagnostic will be printed if the debugging code
-		is enabled with the AHD_SHOW_MASKED_ERRORS bit set in
-		the debugging bitmask.
-	
-		Remove a redundant setting of the mode in the busfree
-		handler.
-	
-	aic79xx.c:
-	aic79xx.h:
-	aic7xxx.c:
-	aic7xxx.h:
-		Change ahc/ahd_upate_neg_request() to take a "negotiation
-		type" enum that allows us to negotiate:
-			o only if the goal and current parameters differ.
-			o only if the goal is non-async
-			o always - even if the negotiation will be for async.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#115 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#62 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#82 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#52 edit
-
-Change 1422 by gibbs@aslan on 2002/09/30 17:09:13
-
-	Don't panic (as a diagnostic to catch bugs) if we decided to
-	force the renegotiation of async even if we believe we are
-	already async.  This should allow us to negotiate async instead
-	of the full user goal rate during startup if bus resets are disabled.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#114 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#81 edit
-
-Change 1420 by gibbs@aslan on 2002/09/30 13:49:47
-
-	Remove a left over '&' from the conversion to using our
-	softc referenced seeprom store.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#26 edit
-
-Change 1419 by gibbs@bitkeeper-linux-2.5 on 2002/09/27 16:44:04
-
-	Add a missing pair of curly braces to a conditional debug
-	statement.  This ensures that debug code doesn't trigger if
-	it isn't enabled. <blush>
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#80 edit
-
-Change 1418 by gibbs@bitkeeper-linux-2.5 on 2002/09/27 14:46:02
-
-	Reset commands_since_idle_or_otag in the mid-layer induced otag
-	case.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#56 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#124 edit
-
-Change 1417 by gibbs@bitkeeper-linux-2.5 on 2002/09/27 14:36:27
-
-	Honor ordered tagged requests from the mid-layer.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#55 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#123 edit
-
-Change 1416 by gibbs@aslan on 2002/09/26 21:19:05
-
-	Remove redundant inclusion of inttypes.h in aicasm_gram.y
-	and properly sort inttypes.h into list of includes.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#25 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_scan.l#7 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#18 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#23 edit
-
-Change 1415 by gibbs@aslan on 2002/09/26 16:02:22
-
-	Correct another BE issue in a printf.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#113 edit
-
-Change 1404 by gibbs@overdrive on 2002/09/24 17:27:07
-
-	Correct a spelling error.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#54 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#122 edit
-
-Change 1403 by gibbs@aslan on 2002/09/24 17:06:41
-
-	Correct a spelling mistake.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#79 edit
-
-Change 1400 by gibbs@overdrive on 2002/09/24 14:29:16
-
-	Make version numbers match what the driver prints on startup.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/README.aic79xx#2 edit
-
-Change 1399 by gibbs@overdrive on 2002/09/24 13:54:33
-
-	Add README files for embedded Linux drivers.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/README.aic79xx#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/README.aic7xxx#1 add
-
-Change 1398 by gibbs@bitkeeper-linux-2.5 on 2002/09/24 12:50:32
-
-	Bump Linux driver versions:
-		aic7xxx = 6.2.10
-		aic79xx = 1.1.1
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#64 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#90 edit
-
-Change 1397 by gibbs@bitkeeper-linux-2.4 on 2002/09/23 12:02:16
-
-	Add memory mapped I/O compile time option.
-
-Affected files ...
-
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Config.in#9 edit
-
-Change 1396 by gibbs@bitkeeper-linux-2.4 on 2002/09/23 12:01:01
-
-	Add memory mapped I/O option to both the aic7xxx and aic79xx drivers.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#53 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#63 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#13 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#121 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#89 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#37 edit
-
-Change 1395 by gibbs@overdrive on 2002/09/23 11:19:47
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Remove two spurious but benign if statements that
-		probably appeared due to an editing botch.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#52 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#120 edit
-
-Change 1393 by gibbs@bitkeeper-linux-2.5 on 2002/09/20 14:58:43
-
-	aic7xxx_host.h:
-		Port to 2.5.X.
-		 - Adapt to "biosparam" driver method specification
-	
-	aic7xxx_osm.c:
-		Port to 2.5.X.
-		 - Include scsicam.h for disk partition functions.
-		 - Switch from strtok to strsep.  Strtok is no longer
-		   available in 2.5.X.	
-		 - Adapt to the removal of the io_request lock and the
-		   mid-layer acquiring our own lock prior to calling us.
-		   This comes in the form of a new inline,
-		   ahc_midlayer_entrypoint_lock().  For 2.5.X, this is
-		   no-op since our lock is already held prior to entry
-		   into the driver.
-		 - Make use of scsi_assign_lock so that we can have our
-		   lock held before we have our host structure.  If we
-		   used the host lock in the host structure, we would
-		   not be able to acquire our lock in our interrupt handler
-		   should a shared interrupt occur before we allocated
-		   our host structure.
-		 - Added comments indicating why it is that we don't do
-		   the same ahc_unlock()/ahd_done_lock() dance in 2.5.X.
-		   Since the done lock and the ahc_lock are one and the
-		   same, it doesn't make sense to release and reacquire
-		   the same lock.  For older kernels, this dance is required
-		   to avoid lock order reversals.
-		 - In our error recovery entry points, move unlock_irq()
-		   calls down to where we sleep so it is more obvious why
-		   they are required.  Add some comments about this too.
-		 - Adapt to changes in the biosparam method specification.
-	
-		Turn runq scheduling into an inline to remove lots of
-		#ifdef clutter.
-	
-	aic7xxx_osm.h:
-		Make register pretty printing and option.
-	
-		Add ahc_midlayer_entrypoint_lock() inlines to help
-		manage the latest Linux mid-layer locking fiasco.
-	
-		ahc_done_lock/unlock are no-ops for 2.5.X.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#10 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#119 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#88 edit
-
-Change 1392 by gibbs@bitkeeper-linux-2.5 on 2002/09/20 14:47:28
-
-	Config.in:	
-		Bring both the aic7xxx and aic79xx sections of this
-		file up to date in regards to the latest options.
-	aic79xx_host.h:
-		Port to 2.5.X.
-		 - Adapt to "biosparam" driver method specification
-		 - Modify driver template to be 2.5.X compatible
-	
-	aic79xx_osm.c:
-		Port to 2.5.X.
-		 - Include scsicam.h for disk partition functions.
-		 - Switch from strtok to strsep.  Strtok is no longer
-		   available in 2.5.X.	
-		 - Adapt to the removal of the io_request lock and the
-		   mid-layer acquiring our own lock prior to calling us.
-		   This comes in the form of a new inline,
-		   ahd_midlayer_entrypoint_lock().  For 2.5.X, this is
-		   no-op since our lock is already held prior to entry
-		   into the driver.
-		 - Make use of scsi_assign_lock so that we can have our
-		   lock held before we have our host structure.  If we
-		   used the host lock in the host structure, we would
-		   not be able to acquire our lock in our interrupt handler
-		   should a shared interrupt occur before we allocated
-		   our host structure.
-		 - Added comments indicating why it is that we don't do
-		   the same ahd_unlock()/ahd_done_lock() dance in 2.5.X.
-		   Since the done lock and the ahd_lock are one and the
-		   same, it doesn't make sense to release and reacquire
-		   the same lock.  For older kernels, this dance is required
-		   to avoid lock order reversals.
-		 - In our error recovery entry points, move unlock_irq()
-		   calls down to where we sleep so it is more obvious why
-		   they are required.  Add some comments about this too.
-		 - Adapt to changes in the biosparam method specification.
-	
-		Turn runq scheduling into an inline to remove lots of
-		#ifdef clutter.
-	
-	aic79xx_osm.h:
-		Make register pretty printing and option.
-	
-		Add ahd_midlayer_entrypoint_lock() inlines to help
-		manage the latest Linux mid-layer locking fiasco.
-	
-		ahd_done_lock/unlock are no-ops for 2.5.X.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_host.h#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#51 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#62 edit
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Config.in#8 edit
-
-Change 1386 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/09/17 19:10:33
-
-	       Update driver version
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#61 edit
-
-Change 1385 by gibbs@overdrive on 2002/09/17 18:48:09
-
-	aic79xx_osm.c:
-		Correct a case in the aic79xx_rd_strm_info code where
-		it was referencing the tag_info array by mistake.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#50 edit
-
-Change 1380 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/09/16 14:46:03
-
-	Include <inttypes.h> to get uint8_t definitions
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#24 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_scan.l#6 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#17 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#22 edit
-
-Change 1378 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/09/16 12:49:34
-
-	       Update driver version
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#60 edit
-
-Change 1377 by gibbs@aslan on 2002/09/16 12:47:19
-
-	Print out LQOSTAT* registers in ahd_dump_card_state.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#112 edit
-
-Change 1373 by gibbs@aslan on 2002/09/12 12:33:53
-
-	aic79xx.c:
-		Cover the ENBUSFREE case for bus resets too.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#111 edit
-
-Change 1372 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/09/12 11:26:37
-
-	       Update driver version
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#59 edit
-
-Change 1371 by gibbs@aslan on 2002/09/12 11:24:42
-
-	aic79xx.c:
-		With the BUSFREEREV bug in effect, we must
-		muck with the ENBUSFREE toggle if the busfree
-		occurred in a non-pack connection.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#110 edit
-
-Change 1370 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/09/11 18:39:38
-
-	       Update driver version
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#58 edit
-
-Change 1369 by gibbs@overdrive on 2002/09/11 18:38:24
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#31 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#12 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#32 edit
-
-Change 1368 by gibbs@aslan on 2002/09/11 18:37:30
-
-	Implement workaround for broken busfree-rev in the A4.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#109 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#61 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#60 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#44 edit
-
-Change 1364 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/09/11 10:02:19
-
-	       Update driver version
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#57 edit
-
-Change 1363 by gibbs@overdrive on 2002/09/11 10:01:38
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#30 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#11 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#31 edit
-
-Change 1362 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/09/10 19:43:30
-
-	       Update driver version
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#56 edit
-
-Change 1361 by gibbs@aslan on 2002/09/10 18:57:05
-
-	aic79xx.c:
-		Aesthetic changes to the dump_sglist routine.
-		We now indicate that the LAST flag was set in
-		the last SG element.
-	
-	aic79xx_inline.h:
-		Don't use ahd_htole64 on a variable that may not
-		be 64bits wide.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#108 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#36 edit
-
-Change 1360 by gibbs@aslan on 2002/09/10 18:52:55
-
-	aicasm_gram.y:
-		Adjust support for mvi with immediate of 0 to
-		handle the downloaded constant case.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#23 edit
-
-Change 1354 by gibbs@aslan on 2002/09/10 15:09:50
-
-	aic79xx.h:
-		Add two new bug defines that only apply to the A:
-	
-		o AHD_REG_SLOW_SETTLE_BUG
-		  - Some Host registers take a few clocks to settle.
-	
-		o AHD_SET_MODE_BUG
-		  - Interrupts must be disabled when changing the mode
-	
-	aic79xx.reg:
-		Modify SET_MODE and add a new TOGGLE_DFF_MODE macro
-		to optimize out the AHD_SET_MODE_BUG workaround.
-	
-		Make P_BUSFREE a field instead of a member of an
-		enum with a mask that doesn't apply to its bit location.
-	
-	aic79xx.seq:
-		Optimize code based on the two new bug defines.  We
-		also iimplement, for the first time, the SLOW_REG
-		bug workaround.
-	
-		SET_MODE and TOGGLE_DFF_MODE can't have ';'s after
-		them now due to if/else clauses.
-	
-		Correct a ';' -> ':' syntax error.
-	
-	aic79xx_pci.c:
-		Add the two new bug defines to the list of bugs
-		that apply to the A4.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#60 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#45 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#59 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#43 edit
-
-Change 1352 by gibbs@aslan on 2002/09/10 14:44:31
-
-	aicasm_gram.y:
-		Allow mvi immediates of zero and have the assembler
-		convert these to the equivalent of a clr instruction.
-		This allows macros that do not know the value of the
-		immediate they are given DTRT.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#22 edit
-
-Change 1349 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/09/09 15:09:57
-
-	       Update driver version
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#55 edit
-
-Change 1347 by gibbs@aslan on 2002/09/09 15:08:20
-
-	aic79xx.seq:
-		In pkt_saveptrs, wait for FIFOEMP before issuing
-		the clearchn.  This seems to be the easiest way
-		to ensure that we don't complete the command to
-		the host prior to all data draining.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#58 edit
-
-Change 1346 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/09/08 17:46:07
-
-	       Update driver version
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#54 edit
-
-Change 1345 by gibbs@overdrive on 2002/09/08 17:41:10
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#29 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#10 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#30 edit
-
-Change 1344 by gibbs@aslan on 2002/09/08 17:40:23
-
-	aic79xx.seq:
-		Correct a comment.
-	
-		In pkt_saveptrs, only clear the saveptrs interrupt
-		status once the pointers are saved.  Otherwise we
-		may allow a cfg4data in the other FIFO to proceed
-		with incorrect data pointers.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#57 edit
-
-Change 1343 by gibbs@aslan on 2002/09/08 17:13:36
-
-	aic79xx.c:
-		Add diagnostic messages for DSPDATACTL workarounds.
-	
-		Negotiate HOLD_MCS for U320 transfers.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#107 edit
-
-Change 1342 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/09/06 17:46:11
-
-	       Update driver version
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#53 edit
-
-Change 1341 by gibbs@overdrive on 2002/09/06 17:45:16
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#28 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#9 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#29 edit
-
-Change 1340 by gibbs@aslan on 2002/09/06 17:44:20
-
-	aic79xx.seq:
-		Fix syntax error.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#56 edit
-
-Change 1339 by gibbs@aslan on 2002/09/06 17:42:26
-
-	aic79xx.seq:
-	aic79xx.reg:
-		Fix SCBPTR corruption during mixed pack/non-pack
-		processing.  When allocating a FIFO, an SCB can
-		complete using MODE3's SCBPTR.  Save the SCBID
-		requesting the allocation into a new scratch ram
-		location that is unused by any other code prior
-		to running any FIFO threads and restore it once
-		allocation is complete.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#44 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#55 edit
-
-Change 1338 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/09/05 22:06:27
-
-	       Update driver version
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#52 edit
-
-Change 1337 by gibbs@overdrive on 2002/09/05 21:48:01
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#27 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#8 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#28 edit
-
-Change 1336 by gibbs@overdrive on 2002/09/05 20:58:55
-
-	aic79xx.c:
-		Restart the sequencer prior to scheduling our
-		reset polling timer.  We want to be sure the
-		sequencer is reset prior to the timer firing.
-	
-		In ahd_reset_poll(), put us in the SCSI mode
-		prior to tweaking registers.
-	
-	aic79xx.reg:
-		Use consistent case in defining register addresses.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#106 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#43 edit
-
-Change 1335 by gibbs@overdrive on 2002/09/05 20:19:00
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#26 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#27 edit
-
-Change 1334 by gibbs@aslan on 2002/09/05 18:26:26
-
-	aic79xx.h:
-		Give AHD_SHOW_SG it's own value.	
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#59 edit
-
-Change 1333 by gibbs@aslan on 2002/09/05 18:25:32
-
-	aic79xx.c:
-		Remove a redundant ahd_update_modes();
-	
-		Only print scb path information in our SELTO handler
-		once we've verified that the SCB is not NULL.
-	
-		Fix formatting nits.
-	
-		Convert transmission error diagnostic code to ahd_reg_print().
-	
-		Correct the comment for ahd_handle_pkt_busfree().  We
-		can enter this routine in any of modes 0, 1 and 3.
-	
-		In ahd_handle_pkt_busfree(), ensure we are in mode 3
-		for dealing with LQOBUSFREE events, save and restore
-		the current SCBPTR in that mode, and use CURRSCB to
-		determine the SCB affected by the busfree rather than
-		the quite bogus SCBPTR.
-	
-		In ahd_abort_scbs(), operate in the SCSI mode so that
-		busy and clear TCL functions use that mode.  It is
-		the only safe mode to use for temporary changes to
-		the SCBPTR register unless you have guaranteed that
-		no SCB fetches are inprogress in which case the command
-		channel mode is safe.
-	
-		Add assertions in the busy_tcl code to ensure we are
-		in the SCSI mode.
-	
-		Save and restore the SCBPTR in ahd_dump_card_state().
-		We were always leaving SCBPTR pointing to the last
-		SCB traversed in our debug output.
-	
-		Use ahd_get_scbptr() in all cases.
-	
-		Cleanup some nits in ahd_dump_cardstate() output.
-	
-		Save and restore the scbptr in ahd_dump_scbs().
-	
-	aic79xx.reg:
-		Remove the SCB_DMA field in SEQ_FLAGS2.  It is not
-		needed for Harpoon's SCB dma fetch abort algorithm.
-	
-	aic79xx.seq:
-		Add a critical section around the SCB dma complete
-		code.  It was possible for the host driver to "abort"
-		this SCB fetch while the sequencer was in the process
-		of handling the completion.  The critical section
-		ensures that the SCB fetch is either aborted, or on
-		the waiting queue once we are outside of the critical
-		section.
-	
-		Complete the removal of the SCB_DMA flag.
-	
-		Fix the PDATA_REINIT case.  We neglected to jump
-		to the dma_loop once the kernel had completed the
-		reinitialization.
-	
-		Fix the non-packetized bitbucket handler.  We were not
-		properly waiting until the data phase was over.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#105 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#42 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#54 edit
-
-Change 1332 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/09/04 23:44:52
-
-	Version 1.0.12
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#51 edit
-
-Change 1331 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/09/04 23:43:46
-
-	Regen aic79xx firmware
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#25 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#6 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#26 edit
-
-Change 1330 by gibbs@aslan on 2002/09/04 18:04:26
-
-	aic79xx.c:
-		Don't call ahd_clear_intstat from our busfree handler.
-		The bus may well have moved on and we don't want to
-		clear state that pertains to the current connection.
-		If we get stray PERR status, it will now be handled
-		by the "catch-all" case in the SCSIINT handler.
-	
-		In ahd_clear_intstat(), deal with the AHD_CLRLQO_AUTOCLR_BUG.
-		This may have been the cause for the really strange
-		problems with mixed pack/non-pack configuratons.
-	
-		When clearing ENSELO in SCSISEQ0, make sure we are
-		in a known and safe mode.
-	
-		Remove "nonpkt_tag" from the "task_attribute_nonpkt_tag"
-		HSCB field.  We no longer need nonpkt_tag information
-		in the SCB.
-	
-		Another update from Gordon for the bus reset quiet
-		the controller algorithm.
-	
-		Print the current byte on the bus in ahd_dump_card_state().
-	
-		Remove spurious ','s from the printing of the pending list.
-	
-		Include SCB_TAG in pending list dumps.
-	
-	aic79xx.h:
-		Put SCB_TAG on a 4 byte boundary just to be paranoid.
-	
-		task_attribute_nonpkt_tag -> task_attribute
-	
-	aic79xx.reg:
-		Put SCB_TAG on a 4 byte boundary just to be paranoid.
-	
-	aic79xx.seq:
-		Remove extra AHD_MDFF_WSCBPTR_BUG code.  The failure
-		can never occur since, in the A, only the non-pack
-		FIFO can ever be active during non-pack processing.
-	
-		Clear the busfree status when entering non-pack processing
-		so we can rely on it in await_busfree.
-	
-	aic79xx_inline.h:
-		Remove what is hopefully the last chunk of untagged queue
-		code from the driver.
-	
-		Don't bother setting the nonpack_tag since it is always
-		the same as the low byte of SCBPTR.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#104 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#58 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#41 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#53 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#35 edit
-
-Change 1328 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/09/03 17:30:10
-
-	Version 1.0.11
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#50 edit
-
-Change 1327 by gibbs@overdrive on 2002/09/03 17:21:56
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#24 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#5 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#25 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#17 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg_print.c#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#18 edit
-
-Change 1326 by gibbs@aslan on 2002/09/03 17:20:25
-
-	Remove a spuriously expanded $FreeBSD$.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_scan.l#5 edit
-
-Change 1325 by gibbs@aslan on 2002/09/03 17:14:43
-
-	aic79xx.c:
-		Add a missing space in the pending list
-		debug output code.
-	
-	aic79xx.h:
-		Add AHD_MDFF_WSCBPTR_BUG.
-	
-	aic79xx.reg:
-		Reserve mode specific scratch location
-		REG2 for interrupt handler use only.
-		This avoids any potential races between
-		normal and interrupt contexts.
-	
-		Put target mode bits after initiator bits
-		so that the initiator mode ones are printed
-		during diagnostics.  We don't currently
-		support target mode.
-	
-	aic79xx.seq:
-		Add duplicate writes to SCBPTR when in modes
-		0 and 1.
-	
-		Switch one section of ISR code over to using
-		REG_ISR.
-	
-		Perform clear target state after releasing the
-		FIFO so the FIFO is free as soon as possible.
-	
-	aic79xx_pci.c:
-		Turn on AHD_MDFF_WSCBPTR_BUG.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#103 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#57 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#40 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#52 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#42 edit
-
-Change 1323 by gibbs@aslan on 2002/08/30 23:06:40
-
-	Strip back down to $FreeBSD$.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#25 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#78 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#51 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#34 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#17 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.h#12 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#38 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#50 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/ahc_eisa.c#8 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/ahc_pci.c#8 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#22 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.c#10 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.h#10 edit
-
-Change 1322 by gibbs@aslan on 2002/08/30 23:06:24
-
-	aic7xxx.seq:
-		Correct a bug in target mode handling of non-disconnected
-		transactions.  The host would indicate the correct SCB to
-		DMA by setting the SCB id in the currently selected hardware 
-		SCB.  Unfortunately, we would then immediated allocate a
-		hardware SCB which, depending on the access patern might not
-		be the same hardware SCB that the host setup for us.  Avoid
-		this by having the host put the SCBID into scratch ram.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#50 edit
-
-Change 1321 by gibbs@aslan on 2002/08/30 23:00:30
-
-	Strip back down to $FreeBSD$
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#22 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#14 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#21 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_gram.y#5 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#16 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#21 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#17 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aicasm/Makefile#1 add
-
-Change 1320 by gibbs@aslan on 2002/08/30 20:47:28
-
-	Expands revision tags.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#21 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#13 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#20 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#10 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_gram.y#4 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_scan.l#4 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#15 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#20 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#16 edit
-
-Change 1317 by gibbs@aslan on 2002/08/30 20:18:37
-
-	aic7xxx.c:
-		Make use of ahc_print_devinfo in the non-AHC_DEBUG case
-		to quiet GCC.  We'll be adding more non-debug uses later
-		anyway.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#77 edit
-
-Change 1316 by gibbs@aslan on 2002/08/30 17:37:39
-
-	Expand Ids.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#24 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.c#102 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#56 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#39 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#51 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#34 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#41 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#76 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#50 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#33 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#49 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#16 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.h#11 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#37 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#49 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/ahc_eisa.c#6 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/ahc_pci.c#6 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/ahd_pci.c#6 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#21 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.h#13 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.c#9 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.h#8 edit
-
-Change 1313 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/08/29 16:44:35
-
-	Version 1.0.10
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#49 edit
-
-Change 1312 by gibbs@overdrive on 2002/08/29 16:17:01
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#23 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#24 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#16 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg_print.c#3 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#17 edit
-
-Change 1311 by gibbs@aslan on 2002/08/29 16:08:39
-
-	aic79xx.c:
-		Correct negotiation regression in 1.0.9.  We need to
-		cancel the negotiations for any unstarted SCBs to avoid
-		the "AWAITING MSG with no waiting message" assertion.
-		In the packetized world, it is safe to cancel negotiations
-		so long as we are active on the bus preventing the execution
-		queue from being run.  Restore ahd_update_pending_scbs() to
-		update SCBs on the controller and have all callers only call
-		it for negotiation changes when the transaction is active.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#101 edit
-
-Change 1310 by gibbs@aslan on 2002/08/29 14:34:09
-
-	aic79xx.c:
-	aic7xxx.c:
-		Print pathing information with some diagnostics.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#100 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#75 edit
-
-Change 1309 by gibbs@aslan on 2002/08/29 14:01:21
-
-	aic7xxx.c:
-	aic7xxx.h:
-		Add support for AHC_SHOW_MESSAGES.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#74 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#49 edit
-
-Change 1308 by gibbs@aslan on 2002/08/29 14:00:48
-
-	aicasm.c:
-	aicasm.h:
-	aicasm_gram.y:
-	aicasm_scan.l:
-	aicasm_symbol.h:
-		Update copyrights.
-	
-	aicasm_symbol.c:
-		Update cpyright.
-	
-		Allow print reg functions for registers with
-		no fields.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#20 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#12 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#19 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#14 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#19 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#15 edit
-
-Change 1307 by gibbs@aslan on 2002/08/29 13:57:31
-
-	Update copyrights.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#50 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#33 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#40 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#20 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.h#11 edit
-
-Change 1306 by gibbs@aslan on 2002/08/29 13:56:41
-
-	aic79xx.c:
-		Use ahd_print_path() for selection timeout messages.
-	
-		Clear all interrupt sources, via ahd_clear_intstat(),
-		if we get an expected or unexpected busfree.  It turns
-		out that the hardware clears some of them, but not all
-		of them when a busfree occurs which can confuse our SCSIINT
-		handler down the road.
-	
-		Update ahd_clear_intstat() to clear LQO/LQI type interrupts.
-	
-		Remove duplicate phase printing in the AHD_SHOW_MESSAGES
-		code.
-	
-		Update ahd_dump_card_state to use more of the "reg print"
-		functions.
-	
-		Conditionalize SG list printing under AHD_SHOW_SG.
-	
-	aic79xx.h:
-		Add AHD_SHOW_SG.
-	
-	aic79xx.reg:
-		Add several changes for Rev. B.  These still need
-		to be verified.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#99 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#55 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#38 edit
-
-Change 1305 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/08/29 10:27:03
-
-	limit per-drive tags to 32
-
-Affected files ...
-
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Config.in#7 edit
-
-Change 1304 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/08/29 10:26:10
-
-	Sync up with the linux-aic79xx-2.4.18_rc4 version of this in order to 
-	get the new aic79xx_reg_print.o dependency.
-
-Affected files ...
-
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Makefile#5 integrate
-
-Change 1302 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/08/28 10:55:57
-
-	Version 1.0.9
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#48 edit
-
-Change 1301 by gibbs@overdrive on 2002/08/27 16:50:51
-
-	Regen Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#22 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#3 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#23 edit
-
-Change 1300 by gibbs@aslan on 2002/08/27 16:49:33
-
-	aic79xx.c:
-		Print out both bytes of SINDEX in a diagnostic.
-	
-		Remove redundant pausing of the sequencer prior
-		to calls to ahd_update_pending_scbs().  It performs
-		its own pause management.
-	
-		In ahd_update_pending_scbs(), don't mess with SCBs
-		already DMA'ed down to the card.  Fields in the
-		SCB control byte are referenced by the select out
-		code to determine queue state, so it is best to
-		leave them alone.  The U320 cards don't embed
-		negotiation information in the SCBs anyway, so
-		the update was of little use.
-	
-		Protect against freezing the SIM Q multiple times
-		should a second bus reset be initiate prior to the
-		completed processing of a previous bus reset event.
-	
-		Print out some additional registers in ahd_dump_card_state().
-	
-		Don't rely on the flexport seeprom type detection to
-		determine if an seeprom is present.  The logic is not
-		present on all board types (e.g. mule boards).
-	
-	aic79xx.h:
-		Add bit for AHD_RESET_POLL_ACTIVE.
-	
-	aic79xx.seq:
-		Correct a few comments about how the sequencer operates.
-	
-		Always clear SG_STATE in disable_ccsgen.  Leaving stale
-		info in there was confusing the non-packetized path.
-	
-		Inline the effect of a call to disable_ccsgen in the
-		S/G fetch code path.
-	
-	aic79xx_pci.c:
-		If bootverbose, indicate STPWLEVEL.
-	
-	aic79xx_osm.c:
-		Properly drop to a sync rate that does not require
-		information unit transfers if tagged queuing or the
-		disconnect privledge are not available.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#98 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#54 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#49 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#39 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#19 edit
-
-Change 1296 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/08/22 17:40:40
-
-	1.0.8
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#47 edit
-
-Change 1295 by gibbs@overdrive on 2002/08/22 17:35:03
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#21 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#22 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#15 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg_print.c#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#16 edit
-
-Change 1293 by gibbs@aslan on 2002/08/22 15:14:44
-
-	aic79xx.c
-		Style nits.
-	
-		Print out REG0 in the NO_MATCH case.  It is more
-		interesting than ARG_1.
-	
-		Use AHD_NUM_LUNS_NONPKT for loops over the busy
-		target table.  Packetized luns don't use the table.
-	
-		Use BUILD_TCL_RAW rather than rolling our own in
-		combination with BUILD_TCL in a few places.
-	
-	aic79xx.h:
-		Allow TCLs to store all lun bits.
-	
-		Lower bus reset hold time to 25us.
-	
-	aic79xx.seq:
-		Correct grammer in a comment.
-	
-		Simplify busy table operatins in mesgin_identify.
-	
-		Remove a commented-out diagnostic.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#97 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#53 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#48 edit
-
-Change 1292 by gibbs@aslan on 2002/08/22 15:10:03
-
-	aic7xxx.h:
-		Drop reset hold duration to 25us.
-	
-	aic7xxx.seq:
-		Correct the grammer in a comment.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#48 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#48 edit
-
-Change 1291 by gibbs@aslan on 2002/08/22 14:04:12
-
-	aicasm_symbol.c:
-	aicasm_symbol.h:
-		Fix symbol sorting logic.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#18 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#14 edit
-
-Change 1289 by gibbs@aslan on 2002/08/21 18:45:16
-
-	aic79xx.c:
-	aic7xxx.c:
-		Handle field values that can be 0 in ahd_print_register().
-		The code would get into an infinite loop before.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#96 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#73 edit
-
-Change 1288 by gibbs@aslan on 2002/08/21 16:30:00
-
-	aic79xx.reg:
-		Remove unused SEQINTCODEs.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#37 edit
-
-Change 1287 by gibbs@aslan on 2002/08/21 16:29:36
-
-	aic79xx.c:
-		It turns out that we can single step even if a
-		SCSIINT is pending.  Remove clearing/restoring of
-		SCSIINT interrupt enables.  This fixes an issue
-		with busfree detection getting turned off without
-		the possibility of re-enabling it.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#95 edit
-
-Change 1286 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/08/20 18:32:08
-
-	Update to 1.0.7, add required makefile changes
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#46 edit
-... //depot/linux_mod_devel/scsi.aic79xx/Makefile#2 edit
-
-Change 1285 by gibbs@aslan on 2002/08/20 18:30:47
-
-	aic79xx.c:
-		Implement the latest bus reset card shutdown procedure.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#94 edit
-
-Change 1282 by gibbs@overdrive on 2002/08/20 17:18:57
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#45 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#20 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg_print.c#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#21 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#87 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#14 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg_print.c#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#15 edit
-
-Change 1280 by gibbs@aslan on 2002/08/20 14:15:29
-
-	aic79xx.seq:
-		Add a PREFIX for ahd generated definitions.
-	
-		Clean up more code related to the now defunct
-		disconnected lists.
-	
-		Use *stable* references to the current scsiid
-		and lun (SAVED_SCSIID/SAVED_LUN) for indexing
-		into the busy targets table.  We were referring
-		to the possibly uninitialzied SCB_LUN of the
-		SCB we had indexed into.  Bad.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#47 edit
-
-Change 1279 by gibbs@aslan on 2002/08/20 14:13:20
-
-	aic7xxx.c:
-	aic7xxx.h:
-		Fix a few typos.
-	
-		Implement ahc_print_register.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#72 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#47 edit
-
-Change 1278 by gibbs@aslan on 2002/08/20 14:12:23
-
-	aic79xx.c:
-	aic79xx.h:
-		More work on the ahd_print_register routine.
-	
-		Use the pretty print register routines in a few places.
-	
-		Fix a few typos.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#93 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#52 edit
-
-Change 1277 by gibbs@aslan on 2002/08/20 14:10:38
-
-	aic7xxx.seq:
-		Add a PREFIX designator for use in making assembler
-		generated definitions, unique.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#47 edit
-
-Change 1276 by gibbs@aslan on 2002/08/20 14:09:03
-
-	aic79xx.reg:
-	aic7xxx.reg:
-		Adapt to new assembler syntax.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#36 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#32 edit
-
-Change 1275 by gibbs@aslan on 2002/08/20 14:06:35
-
-	aicasm.c:
-	aicasm_gram.y:
-	aicasm_scan.l:
-	aicasm_symbol.c:
-	aicasm_symbol.h:
-		Add support for generating register field tables for
-		use in pretty-printing register values.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#19 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#18 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#13 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#17 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#13 edit
-
-Change 1272 by gibbs@overdrive on 2002/08/14 14:16:46
-
-	aic79xx_osm_pci.c:
-		Move warning about failures to memory map our controller
-		under bootverbose.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#12 edit
-
-Change 1271 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/08/14 08:02:15
-
-	Version 1.0.6
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#44 edit
-
-Change 1270 by gibbs@overdrive on 2002/08/13 16:02:05
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Use MSG_EXT_PPR_QAS_REQ rather than SID_SPI_QAS
-		when dealing with PPR options.  The latter is used
-		when looking at inquiry information.  Ooops.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#49 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#118 edit
-
-Change 1269 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/08/09 13:09:26
-
-	veriosn 1.0.5
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#43 edit
-
-Change 1264 by gibbs@aslan on 2002/08/08 15:19:58
-
-	aic79xx.c:
-		Use CAM_SEQUENCE_FAIL for protocol violations.
-	
-		Add first cut at a register printing function.
-	
-		Use better markers for the beginning and end
-		of ahd_dump_card_state.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#92 edit
-
-Change 1263 by gibbs@aslan on 2002/08/08 15:18:52
-
-	aicasm.c:
-	aicasm.h:
-	aicasm_gram.y:
-	aicasm_scan.l:
-	aicasm_symbol.c:
-	aicasm_symbol.h:
-		First cut at outputing register printing tables.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#18 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#11 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#17 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#12 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#16 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#12 edit
-
-Change 1262 by gibbs@overdrive on 2002/08/08 14:21:43
-
-	cam.h:
-		Add a mapping for CAM_SEQUENCE_FAIL.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#13 edit
-
-Change 1261 by gibbs@overdrive on 2002/08/08 10:56:31
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		If QAS is not supported by a target, be sure to clear
-		the QAS flag in the ppr_options.  Otherwise we may
-		attempt a PPR on a device that does not support it.
-	
-		Use prot_version rather than the protocol version in
-		the tstate as the latter is not initialized until later
-		in the routine and will be 0 the first time an inquiry
-		is sent to a device.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#48 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#117 edit
-
-Change 1259 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/08/07 09:36:00
-
-	Version 1.0.4
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#42 edit
-
-Change 1258 by gibbs@aslan on 2002/08/06 16:58:52
-
-	aic79xx.c:
-		Move expected bus free handling code to ahd_set_syncrate()
-		so that it will work for message types other than PPR.
-	
-		Test for expected bus frees if the last phase was either
-		MESGIN or MESGOUT.  SPI4 dictates that the bus free will
-		occur once message phases are over, so we must handle the
-		case of other messages occuring prior to the bus going free.
-		We filter out other causes for the bus free (abort tag, etc.)
-		prior to treating this as an expected busfree.
-	
-		Wait a bus reset delay prior to performing the chip reset
-		for outgoing bus resets *just in case* this helps with the
-		stray arb issue.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#91 edit
-
-Change 1250 by gibbs@overdrive on 2002/08/05 14:23:13
-
-	aic7xxx_osm.c:
-	aic79xx_osm.c:
-		Fix off-by-one errors in calculations using the inquiry
-		data's additional_length field.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#47 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#116 edit
-
-Change 1248 by gibbs@overdrive on 2002/08/03 12:26:50
-
-	aic7xxx_proc.c:
-		Explicitly test for VLB and PCI cards in seeprom_write()
-		so we don't try this on EISA cards.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#22 edit
-
-Change 1246 by gibbs@overdrive on 2002/08/03 12:06:45
-
-	aic7xxx_proc.c:
-		AHC_PCI_CONFIG is always defined.  Test for > 0 instead.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#21 edit
-
-Change 1244 by gibbs@overdrive on 2002/08/03 12:01:55
-
-	aic7xxx_osm.c:
-		ahc_pause_and_flush_work() -> ahc_pause_and_flushwork().
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#115 edit
-
-Change 1243 by gibbs@overdrive on 2002/08/03 11:57:55
-
-	aic7xxx_proc.c:
-		Allow this to compile if PCI support is not
-		configured into the system.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#20 edit
-
-Change 1242 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/08/02 19:43:45
-
-	Version 1.0.3
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#41 edit
-
-Change 1240 by gibbs@aslan on 2002/08/02 17:47:26
-
-	aic79xx.c:
-		Force scb to be NULL if we have not been fully identified
-		in ahd_handle_protocol_violation().
-	
-		Use MSG_ABORT_TASK for invalid reselections as per the
-		SPI4 spec.
-	
-		Push the waiting for the bus transceivers to setting into
-		ahc_chip_init().  This makes the wait occur for bus reset
-		operations too.  Perform this wait prior to setting up
-		any of our iocell workarounds just in case the chip clobbers
-		them when the bus settles.
-	
-		Don't rely on the chip remaining paused while we wait for
-		the bus reset line to fall.  We simply perform most of
-		the reconfiguration of the chip prior to starting to poll
-		for the reset line to fall.
-	
-		Fix a bug in ahd_reset_poll() in the case of the reset
-		line not falling.  We would not exit the function to wait
-		again for the reset line to fall.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#90 edit
-
-Change 1228 by gibbs@overdrive on 2002/07/31 16:33:59
-
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-	aic7xxx_osm.c:
-	aic7xxx_osm.h:
-	cam.h:
-		Emulate CAM_REQUEUE_REQ by returning check condition
-		status with the ABORTED COMMAND sense key.  This works
-		even if we happen to be requesting an error recovery
-		command to be unconditionally requeued.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#46 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#40 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#114 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#86 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#12 edit
-
-Change 1227 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/07/31 12:12:00
-
-	version 1.0.2
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#39 edit
-
-Change 1226 by gibbs@overdrive on 2002/07/30 17:12:07
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#19 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#20 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#13 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#14 edit
-
-Change 1225 by gibbs@aslan on 2002/07/30 17:10:40
-
-	aic79xx.c:
-		When a selection timout occurs, we need not play with
-		ENBUSFREE.  The busfree interrupt is a pulse so simply
-		clearing that interrupt source is sufficient.
-	
-		Fixup some curly braces.
-	
-		LASTPHASE -> PREVPHASE.  LASTPHASE is a register
-		in scratch ram and not the bit in the PERRDIAG register
-		that indicates if the error has occurred before the
-		current phase.
-	
-		When setting the SCSI reset line, clear ENSELO and
-		ENARBO just in case they are set.  We don't want the
-		chip to decide it need to perform a select out as
-		soon as the reset is over.
-	
-		Add a line of '='s prior to dumping card state.  It
-		makes traces easier to follow.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#89 edit
-
-Change 1224 by gibbs@aslan on 2002/07/29 17:06:54
-
-	aic79xx.c:
-		When auto-sense fails due to non-0 scsi status,
-		we still need to release the selection queue.
-		Rearrange the code so that we do this step prior
-		to checking to see if this was an auto-sense
-		command.
-	
-	aic79xx.seq:
-		Be more careful about detection of protocol violations
-		flagged on command complete messages.  The command complete
-		is valid even if the CDB was never fully sent if the
-		target has given us non-zero status.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#88 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#46 edit
-
-Change 1223 by gibbs@aslan on 2002/07/29 12:00:22
-
-	aic79xx.c:
-		Move handler for protocol violations to its own funciton.
-		Make another attempt to handle protocol violations that
-		occur before we have a fully identified connection.
-	
-		Add ahd_print_devinfo() to simplify diagnostics for
-		scenarios without a fully identified connection.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#87 edit
-
-Change 1221 by gibbs@overdrive on 2002/07/26 13:54:57
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		When we get a QUEUE_FULL with only the transaction
-		returning QUEUE FULL outstanding, tell Linux that
-		the transaction received BUSY status.  Linux doesn't
-		understand how to deal with QUEUE FULL correctly in
-		this situation and will leave the device frozen forever.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#45 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#113 edit
-
-Change 1217 by gibbs@overdrive on 2002/07/25 13:35:10
-
-	aic7xxx_osm.c:
-		Rely on ahc_pause_and_flushwork() instead of rolling our own.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#112 edit
-
-Change 1216 by gibbs@aslan on 2002/07/25 13:34:21
-
-	aic7770.c:
-		Remove an unused variable.
-	
-	aic7xxx.c:
-		Mask qoutfifonext in printf to avoid promotion
-		issues when printing its value.
-	
-		When we experience a dual edge error, send an
-		initiator detected error message regardless of
-		data direction.  This is an error we can detect
-		either way.
-	
-		Cast the return from malloc.
-	
-		Use the SCSI offset as an indication that we have
-		a sync negotiation setup, not the period.
-	
-		In ahc_fetch_devinfo(), test for a few more bits
-		in SEQ_FLAGS to determine if we are acting as a
-		target that has been selected.  Depending on how
-		far we are along in the transaction one or all
-		of them may be set.
-	
-		Align our S/G data structures on an 8byte boundary.
-		This already was occuring by luck, but using the
-		correct parameter to bus_dma_tag_create formalizes
-		this requirement.
-	
-		Guard against pending (re)selections in
-		ahc_pause_and_flushwork().
-	
-		If SEARCH_REMOVE removes an SCB from an untagged queue,
-		clear its SCB_UNTAGGEDQ flag.
-	
-		When enabling a lun for target mode on a controller without
-		MULTARGID support, complain when an attempt is made to
-		enable another ID.
-	
-	aic7xxx.h:
-		Remove external declaration of the syncrate table.  It
-		is no longer accessed directly by the OSM.
-	
-	aic7xxx.reg:
-		Add a definition for SXFRCTL2.  This is just to serve
-		as documentation since we don't currently use this
-		register.
-	
-		Alias MWI_RESIDUAL with TARG_IMMEDIATE_SCB.  This new
-		field is used for a more robust immediate target mode
-		SCB delivery scheme.
-	
-	aic7xxx.seq:
-		Adapt to TARG_IMMEDIATE_SCB scheme.
-	
-		Correct a problem with immediate target mode SCBs on
-		controllers without a command channel.  We neglected
-		to CLRCHN before continuing the connection.
-	
-		Grammer nits.
-	
-	aic7xxx_pci.c:
-		Remove an unused variables.
-	
-		Simplify the code to read the SCB2 data.
-	
-		When checking termination on 785X cards, force
-		the wide termination to be off since these chips
-		do not support wide SCSI.
-	
-	aic7xxx_osm.c:
-		Use offset not period for sync rate negotiation decissions.
-	
-		Adapt to TARG_IMMDEDIATE_SCB scheme.
-	
-		Properly cast our softc in ahc_poll().
-	
-		Remove test for P_BUSFREE when trying to determine if
-		an active SCB is valid.  The SCB may be valid long
-		before we see the first phase.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#23 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#71 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#46 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#31 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#46 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#48 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.c#8 edit
-
-Change 1209 by gibbs@overdrive on 2002/07/24 16:53:31
-
-	aic79xx_osm.c:
-		Remove one last multi-line string constant.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#44 edit
-
-Change 1208 by scottl@scottl-hobbiton-mod_devel_aic7xxx on 2002/07/24 16:00:02
-
-	Fix compiliation errors
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#111 edit
-
-Change 1207 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/07/24 15:57:30
-
-	remove hard printf's
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#38 edit
-
-Change 1206 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/07/24 14:17:12
-
-	Driver is now at version 1.0.1
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#38 edit
-
-Change 1205 by gibbs@overdrive on 2002/07/24 14:09:02
-
-	aic79xx_osm.c:
-		Allow MODULE_LICENSE to work on 7.2AS.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#43 edit
-
-Change 1203 by scottl@scottl-linux-ia64 on 2002/07/23 11:18:20
-
-	Clear any bogus bus reset flags while the transceivers are settling
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#86 edit
-
-Change 1202 by scottl@scottl-linux-ia64 on 2002/07/22 19:10:49
-
-	Move the debugging printf in ahd_alloc to the end, avoiding a junk
-	pointer reference.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#85 edit
-
-Change 1201 by gibbs@aslan on 2002/07/22 17:53:37
-
-	aic7xxx_inline.h:
-		If chip interrupts are disabled, just return from our
-		interupt handler.  In these cases, the interrupts are
-		likely disabled because we don't want any entry into
-		our interrupt handler, even those caused by a shared
-		interrupt handler.
-	
-	aic7770.c:
-	aic7xxx_pci.c:
-	aic7xxx_osm.c:
-		Allow the OSM to decide when to initially enable interrups.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#22 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#36 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#47 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.c#7 edit
-
-Change 1200 by gibbs@overdrive on 2002/07/22 17:51:33
-
-	aic7xxx_osm.c:
-		Allow the OSM to decide when to initially enable
-		interrupts.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#110 edit
-
-Change 1199 by gibbs@overdrive on 2002/07/22 17:46:04
-
-	aic79xx_osm.c:
-		Add a missing \n"
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#42 edit
-
-Change 1198 by gibbs@aslan on 2002/07/22 17:40:37
-
-	aic79xx_inline.h
-		If interrupts are not enabled, just return
-		from the interrupt handler.  Interrupts are
-		usually disabled on the chip when we *don't*
-		want our interrupt handler entered which can
-		happen if the interrupt is shared.
-	
-	aic79xx_pci.c:
-	aic79xx_osm.c:
-		Let the OSM decide when to initially enable interrupts.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#32 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#37 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#18 edit
-
-Change 1197 by gibbs@overdrive on 2002/07/22 17:38:44
-
-	aic79xx_osm.c:
-		Use explicit newlines in multi-line string constants to
-		quiet GCC.
-	
-		Let the OSM enable interrupts once it is ready to
-		receive them.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#41 edit
-
-Change 1196 by gibbs@aslan on 2002/07/22 16:39:46
-
-	aic79xx.c:
-		Don't mask off the OVERRUN bit in sstat0 since
-		we do enable it.
-	
-		Assert that we are in a know mode other than MODE_CFG
-		when calling clear_intstat.
-	
-		To simplify logic, set the collision index in all
-		SCBs of a collision chain.
-	
-		AHD_BUILD_SCB_COL_IDX -> AHD_GET_SCB_COL_IDX
-	
-		CLRSCSIINT immediately after clearing any NTRAMPERRs
-		that occur during ahd_chip_init().
-	
-	aic79xx.h:
-	aic79xx_inline.h:
-		Move COL_IDX macros to aic79xx.h.
-	
-		Optimize collision chain head table for multiple
-		targets, not multiple luns.  The chain heads should
-		fit in 1 or 2 cache lines instead of an almost guaranteed
-		1 per target.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#84 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#51 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#31 edit
-
-Change 1195 by gibbs@overdrive on 2002/07/22 11:00:46
-
-	aicasm_gram.y:
-		Remove an extranious break;
-	
-		The syntax for a C label is: identifier ':' statement
-		label: } is not valid syntax even though GCC has allowed
-		it for years.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#16 edit
-
-Change 1194 by gibbs@overdrive on 2002/07/22 10:57:44
-
-	aic7xxx_osm.c:
-		Quiet GCC 3.X warnings by using explicit newlines in
-		long string constants.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#109 edit
-
-Change 1192 by gibbs@overdrive on 2002/07/19 19:51:02
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#18 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#19 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#12 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#13 edit
-
-Change 1191 by gibbs@overdrive on 2002/07/19 19:50:13
-
-	aic79xx_osm.c:
-		Remove references to the untagged queues.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#40 edit
-
-Change 1190 by gibbs@aslan on 2002/07/19 19:48:44
-
-	aic79xx.c:
-		Remove untagged queue support code.
-	
-		Set SCB_ACTIVE when it is allocated rather than
-		let the OSM set it some time later.  This closes
-		a race condition with collision list code that looks
-		for the active flag.
-	
-	aic79xx.h:
-		Move untagged queue cleanup.
-	
-	aic79xx.seq:
-		Remove the last reference to the SCB_NONPACKET_TAG
-		field.  This field will be removed shortly.
-	
-	aic79xx_osm.c:
-		Remove untagged queue support code.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#83 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#50 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#45 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#17 edit
-
-Change 1189 by gibbs@aslan on 2002/07/19 19:18:20
-
-	aic79xx.c:
-		Pause the sequencer prior to updating the negotiation
-		tables if "paused" is false.
-	
-		Add the collision scb to the collision list, not
-		the just allocated scb, in ahd_get_scb().
-	
-		Use the correct collision index when adding a just freed
-		scb back into a collision list.
-	
-	aic79xx.seq:
-		Simplify the mesgin_identify path now that we will
-		never have full disconnection lists.  This also removes
-		a bug where we could select the wrong SCB as the
-		valid SCB for the connection.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#82 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#44 edit
-
-Change 1187 by gibbs@overdrive on 2002/07/19 17:27:05
-
-	aic79xx_osm.c:
-		Correct typo: simple_strltoul -> simple_strtoul.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#39 edit
-
-Change 1186 by gibbs@overdrive on 2002/07/19 17:19:45
-
-	Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#17 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#18 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#11 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#12 edit
-
-Change 1185 by gibbs@overdrive on 2002/07/19 17:19:24
-
-	aic7xxx.seq:
-		Revert attempt to improve stuck PCI retry workaround
-		code.  This was only generated as a test and should
-		never have been committed in the first place.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#45 edit
-
-Change 1184 by gibbs@overdrive on 2002/07/19 17:14:13
-
-	aic79xx_osm.c:
-		Get a collision index prior to getting an SCB to use.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#38 edit
-
-Change 1183 by gibbs@aslan on 2002/07/19 17:04:52
-
-	aic79xx.c:
-		Add string for the aic7901A.
-	
-		Implement new SCB free list management so that
-		all 512 scbs can be used in non-packetized
-		environments.
-	
-		Implement new command completion mechanism that
-		uses a toggling bit 15 to indicate that a new
-		entry has arrived.  This avoids the kludgy writes
-		to the qoutfifo that may not work on processors
-		with certain types of cache retirement policies.
-	
-		Print out data structure sizes if AHD_DEBUG and
-		AHD_SHOW_MEMORY.
-	
-		Allocate the "sentinal" hardware SCB used for
-		queuing commands to the card separately so
-		that one of the 512 valid SCBs is not consumed
-		for this function.
-	
-		Add a space so we report "Wide Channel" instead of
-		"WideChannel".
-	
-		Cleanup allocation of the shared data area so that
-		the qoutfifo is always first.
-	
-		Add a fix for the RevA packetized Lun bug.  The driver
-		will now setup a full 8byte lun in the previously
-		"spare" portion of the SCB and the SCB transfer size
-		is incremented if the bug is present.  This required a
-		change in the layout of the disconnected SCB table to
-		make room for the larger lun field.
-	
-	aic79xx.h:
-		Add constants for the new qoutfifo scheme.
-	
-		Bump AHD_MAX_QUEUE up to 512 now that we have removed
-		all of the issues that previously restricted it to
-		a much lower value.
-	
-		Add a chip entry for the 7901A.
-	
-		Add the pkt_long_lun field to the hardware scb.
-	
-		SCB and ahc_softc updates for our new free scb
-		management algorithm.
-	
-		Stop inlining ahd_get_scb() and ahd_free_scb().
-		The get routine also take a collision index so
-		as t make an optimum choice in which free SCB to
-		pick.
-	
-	aic79xx.reg:
-		Add QOUTFIFO_ENTRY_VALID_TAG which is or'd into the
-		top byte of each completed SCB's tag id to effect
-		the new completion scheme.
-	
-		Define the SCB_PKT_LUN field and new SCB transfer
-		sizes required to use this field..
-	
-	aic79xx.seq:
-		Implement the new command completion scheme.
-	
-		Effect disconnected SCB table format change.
-	
-	aic79xx_inline.h:
-		When queuing a packetized SCB, update pkt_long_lun
-		in case we need it for the PKT_LUN workaround.
-	
-		Uninline ahd_get_scb() && ahd_free_scb().
-	
-		Adjust for the change from storing an SCB to an HSCB
-		as the next "SCB" in the softc.
-	
-		Update for changes in the command completion scheme.
-	
-	aic79xx_pci.c:
-		Fix a few issues with detecting the 7901A.
-	
-	aic79xx_osm.c:
-		Determine the type of transaction prior and the
-		necessary collision index prior to allocating
-		an SCB.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#81 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#49 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#35 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#43 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#30 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#36 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#16 edit
-
-Change 1182 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/07/19 16:34:50
-
-	Add the global_tag_depth variable to the aic79xx driver
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#37 edit
-
-Change 1181 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/07/19 13:45:22
-
-	Update PCI tables for the 29320 and 7901 variants.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#48 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#35 edit
-
-Change 1180 by gibbs@aslan on 2002/07/18 17:08:50
-
-	aic79xx_pci.c:
-		Remove A3 support.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#34 edit
-
-Change 1179 by scottl@scottl-hobbiton-mod_devel_aic7xxx on 2002/07/18 15:46:45
-
-	Version 6.2.9:
-		Add new command-line argument global_tag_depth:<int>, which
-		allows you to set the tag depth for every target on every
-		channel.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#108 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#85 edit
-
-Change 1172 by gibbs@overdrive on 2002/06/12 12:32:49
-
-	aic7xxx_osm.c:
-		Define use MODULE_LICENSE should it be defined instead
-		of testing against a specific kernel version.  This
-		should allow 7.2AS driver diskettes to work.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#107 edit
-
-Change 1171 by gibbs@overdrive on 2002/06/06 17:40:00
-
-	aic79xx_osm.h:
-		Try two.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#37 edit
-
-Change 1170 by gibbs@overdrive on 2002/06/06 17:38:12
-
-	aic79xx_osm.h:
-		Convert to using AHD_DEBUG_OPTS.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#36 edit
-
-Change 1166 by gibbs@aslan on 2002/06/06 10:18:11
-
-	Cleanup AHD_DEBUG.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#80 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#47 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#29 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#33 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#14 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.h#8 edit
-
-Change 1164 by gibbs@aslan on 2002/06/06 10:05:23
-
-	aicasm_symbol.c:
-		Remove another multi-line string literal.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#15 edit
-
-Change 1163 by gibbs@aslan on 2002/06/05 16:49:30
-
-	aicasm.c:
-		Remove wrapping strings.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#17 edit
-
-Change 1159 by gibbs@bitkeeper-linux-2.4 on 2002/05/30 23:23:01
-
-	Config.in:
-	Makefile:
-		Cleanup our config data and makefiles.
-
-Affected files ...
-
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Config.in#6 edit
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Makefile#4 edit
-
-Change 1157 by gibbs@overdrive on 2002/05/30 22:15:02
-
-	aic79xx_osm.h:
-		Bump to version 1.0.0.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#35 edit
-
-Change 1156 by gibbs@overdrive on 2002/05/30 22:14:09
-
-	aic79xx_inline.h:
-		Rearrange code to setup hscb->dataptr so our operations
-		are not truncated to 32bits.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#28 edit
-
-Change 1154 by gibbs@aslan on 2002/05/30 21:53:39
-
-	aic79xx_inline.h:
-		Include the top 7 bits of address when setting up
-		hscb->dataptr for the 39BIT addressing mode.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#27 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#44 edit
-
-Change 1153 by gibbs@aslan on 2002/05/30 20:09:22
-
-	aic79xx.h:
-		union -> struct for the cdb_plus_sense structure.
-		This was missed in the re-arrangement of the hscb
-		declaration.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#46 edit
-
-Change 1151 by gibbs@overdrive on 2002/05/30 18:24:34
-
-	aic79xx_reg.h:
-	aic79xx_seq.h:
-		Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#16 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#17 edit
-
-Change 1150 by gibbs@aslan on 2002/05/30 14:26:20
-
-	aic79xx_inline.h:
-		aic79xx_inline.h:
-			Break dataptr into u_int sized chucks for
-			printing to avoid compiler errors.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#26 edit
-
-Change 1149 by gibbs@aslan on 2002/05/30 14:25:13
-
-	aic79xx.c:
-		Panic if our hardware scb definition is not 64 bytes.
-		Hopefully this will catch agressive compiler padding
-		in the future.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#79 edit
-
-Change 1145 by gibbs@overdrive on 2002/05/30 13:51:24
-
-	aic79xx_osm.c:
-		Upate for change in hardware SCB definition.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#36 edit
-
-Change 1144 by gibbs@aslan on 2002/05/30 13:50:02
-
-	aic79xx.c:
-	aic79xx.h:
-	aic79xx_inline.h:
-	aic79xx_osm.c:
-		Rearrange hardware SCB definition to avoid
-		64bit alignment/packing problems on native
-		64bit platforms.  Everything was aligned
-		correctly, but the compiler was not smart
-		enough to see this with how the structures
-		were previously defined.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#78 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#45 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#25 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#12 edit
-
-Change 1143 by gibbs@aslan on 2002/05/29 20:55:06
-
-	aic79xx.c:
-	aic79xx.h:
-	aic79xx_pci.c:
-	aic7xxx.c:
-		Convert a few straglers to inttypes.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#77 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#44 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#32 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#70 edit
-
-Change 1141 by gibbs@overdrive on 2002/05/29 20:27:14
-
-	aic79xx_osm.c:
-		Bring back an "int i;" that was removed to fix a
-		compile warning.  It is used in debug code, so move
-		it to where it is used.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#35 edit
-
-Change 1139 by gibbs@overdrive on 2002/05/29 20:23:18
-
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-	aic79xx_osm_pci.c:
-	aic7xxx_osm.c:
-	aic7xxx_osm.h:
-	aic7xxx_osm_pci.c:
-		Bring back the hack to force consistent memory to
-		be below 4GB.  The IA64 platform only enforces this
-		if your PCI device's dma mask is set to 4GB.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#34 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#34 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#11 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#106 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#84 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#36 edit
-
-Change 1138 by gibbs@overdrive on 2002/05/28 14:19:38
-
-	aic79xx_osm.c:
-		And another.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#33 edit
-
-Change 1137 by gibbs@overdrive on 2002/05/28 14:17:46
-
-	aic79xx_osm.c:
-		Kill a few compile warnings.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#32 edit
-
-Change 1135 by gibbs@aslan on 2002/05/28 13:35:41
-
-	aic79xx.c:
-	aic79xx.h:
-		Enable ahd_fini_scbdata().
-	
-		Change some #if 0's to AHD_DEBUG logs.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#76 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#43 edit
-
-Change 1133 by gibbs@overdrive on 2002/05/28 12:58:11
-
-	aic79xx_osm.c:
-		Clean up some 'XXX' and #if 0 stuff.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#31 edit
-
-Change 1132 by gibbs@overdrive on 2002/05/28 12:51:44
-
-	aic79xx_osm_pci.c:
-		More typos.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#10 edit
-
-Change 1130 by gibbs@overdrive on 2002/05/28 12:45:53
-
-	aic7xxx_osm_pci.c:
-		Remove stray '{'
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#35 edit
-
-Change 1129 by gibbs@overdrive on 2002/05/28 12:43:47
-
-	aic79xx_osm_pci.c:
-	aic7xxx_osm_pci.c:
-		Restore inadvertantly removed #endif.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#9 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#34 edit
-
-Change 1128 by gibbs@overdrive on 2002/05/28 12:39:12
-
-	aic7xxx_osm.c:
-		Remove one more stray use of hw_dma_mask.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#105 edit
-
-Change 1127 by gibbs@overdrive on 2002/05/28 12:37:22
-
-	aic7xxx_osm.c:
-	aic7xxx_osm.h:
-	aic7xxx_osm_pci.c:
-		Don't bother messing with the dma mask during
-		alloc consistent calls.  Linux guarantees that
-		the mappings will be below 4GB.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#104 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#83 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#33 edit
-
-Change 1126 by gibbs@overdrive on 2002/05/28 12:32:23
-
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-	aic79xx_osm_pci.c:
-		Hook up 64BIT S/G support for Linux.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#30 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#33 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#8 edit
-
-Change 1125 by gibbs@aslan on 2002/05/24 17:11:19
-
-	aic79xx.h:
-		Pad ahd_dma64_seg to 16 bytes so we can still use
-		the ODD_SEG bit in the SG_CACHE.  Otherwise we'd
-		be able to shrink the SG element down to 12 bytes.
-	
-	aic79xx.seq:
-		Complete 64bit S/G data address support and inline
-		sg advance.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#42 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#42 edit
-
-Change 1121 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/05/24 14:01:42
-
-	Beta 6
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#32 edit
-
-Change 1120 by gibbs@aslan on 2002/05/24 13:58:41
-
-	aic79xx.c:
-		Fix some big endian bugs.
-	
-		Set SPLTSTADIS in PCIXCTL so we don't issue a target
-		abort when we abort an SG element fetch.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#75 edit
-
-Change 1117 by gibbs@overdrive on 2002/05/23 16:44:08
-
-	aic79xx_osm.h:
-		Bump version number to 0.5.0.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#31 edit
-
-Change 1115 by gibbs@overdrive on 2002/05/23 16:41:47
-
-	aic79xx_osm.h:
-		Add PCIX configuration space definitions.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#30 edit
-
-Change 1114 by gibbs@aslan on 2002/05/23 16:39:32
-
-	aic79xx_pci.c:
-		First shot at PCI-X error reporting.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#31 edit
-
-Change 1113 by gibbs@aslan on 2002/05/23 16:36:13
-
-	aic79xx_inline.h:
-		We always need to run the qoutfifo even if only
-		doing target mode.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#24 edit
-
-Change 1112 by gibbs@aslan on 2002/05/22 13:38:33
-
-	aic7xxx_pci.c:
-		Allow autoterm if we have SCB based config data.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#46 edit
-
-Change 1110 by gibbs@overdrive on 2002/05/22 11:41:08
-
-	aic7xxx_reg.h:
-	aic7xxx_seq.h:
-		Regenerate firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#10 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#11 edit
-
-Change 1109 by gibbs@aslan on 2002/05/22 11:40:28
-
-	aic7xxx.c:
-		Remove some unecessary ahc_flush_device_writes().
-	
-	aic7xxx.reg:
-		Remove redundant definition for SOFTCMDEN.
-	
-	aic7xxx_pci.c:
-		Only attempt auto-term if we have seeprom (or like)
-		data.
-	
-		For SPIOCAP based controllers, be sure that external
-		board control logic is enabled for termination control.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#69 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#30 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#45 edit
-
-Change 1108 by gibbs@aslan on 2002/05/21 16:51:16
-
-	aic79xx_pci.c:
-		SRAM_BASE -> SCB_BASE for reading SCB configuration
-		options.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#30 edit
-
-Change 1106 by gibbs@overdrive on 2002/05/21 15:03:07
-
-	Regenerate Linux aic79xx firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#15 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#16 edit
-
-Change 1105 by gibbs@overdrive on 2002/05/21 15:01:39
-
-	aic79xx_osm.c:
-		AHC -> AHD.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#29 edit
-
-Change 1103 by gibbs@overdrive on 2002/05/21 14:57:59
-
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-		Add queue full and busy status timer to the aic79xx driver.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#28 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#29 edit
-
-Change 1102 by gibbs@overdrive on 2002/05/21 14:48:16
-
-	aic7xxx_osm.c:
-		Fix a few more compile errors.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#103 edit
-
-Change 1101 by gibbs@overdrive on 2002/05/21 14:45:36
-
-	aic7xxx_osm.c:
-		Really get the right timer.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#102 edit
-
-Change 1100 by gibbs@overdrive on 2002/05/21 14:39:27
-
-	aic7xxx_osm.c:
-		Use the correct timer for busy and queue full handling.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#101 edit
-
-Change 1099 by gibbs@overdrive on 2002/05/21 14:36:05
-
-	aic7xxx_osm.h:
-	aic7xxx_osm.c:
-		Perform a 500ms delay for single command queue full status
-		and busy status since Linux does not delay in this case.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#100 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#82 edit
-
-Change 1098 by gibbs@aslan on 2002/05/21 13:37:36
-
-	aic79xx.c:
-	aic79xx.reg:
-	aic79xx.seq:
-		Switch over to a more generic "protocol violation"
-		handler.  Use this to now catch cases where a
-		disconnect or command complete message is not
-		valid.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#74 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#34 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#41 edit
-
-Change 1091 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/05/17 14:35:15
-
-	Put a blank line before the Serial EEPROM text
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#7 edit
-
-Change 1090 by gibbs@overdrive on 2002/05/17 14:19:14
-
-	aic79xx_osm.h:
-		Bump to Beta 4.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#28 edit
-
-Change 1089 by gibbs@overdrive on 2002/05/17 14:18:47
-
-	aic79xx_seq.h:
-	aic79xx_reg.h:
-		Regenerate firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#14 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#15 edit
-
-Change 1088 by gibbs@aslan on 2002/05/17 14:16:58
-
-	aic79xx.c:
-	aic79xx.reg:
-	aic79xx.seq:
-	aic79xx_osm.c:
-		IDENTIFY_SEEN -> NOT_IDENTIFIED.
-	
-		Add NO_CDB_SENT flag to SEQ_FLAGS.  Use this
-		to protect against DATA phases prior to having
-		a completed cdb transfer.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#73 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#33 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#40 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#11 edit
-
-Change 1087 by gibbs@aslan on 2002/05/17 13:32:27
-
-	aic79xx.c:
-	aic79xx.h:
-	aic79xx.reg:
-	aic79xx_pci.c:
-		Add Compaq special write bias and slewrate.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#72 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#41 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#32 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#29 edit
-
-Change 1086 by gibbs@overdrive on 2002/05/17 12:30:27
-
-	aic79xx_proc.c:
-		Adapt to ahd interface changes for seeprom routines.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#6 edit
-
-Change 1085 by gibbs@overdrive on 2002/05/17 12:28:21
-
-	aic79xx_reg.h:
-	aic79xx_seq.h:
-		Regenerate Linux firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#13 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#14 edit
-
-Change 1083 by gibbs@overdrive on 2002/05/17 12:25:01
-
-	aic7xxx_proc.c:
-		Add a prototype.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#19 edit
-
-Change 1082 by gibbs@overdrive on 2002/05/17 12:24:49
-
-	aic79xx_proc.c:
-		Add write seeprom support.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#5 edit
-
-Change 1081 by gibbs@aslan on 2002/05/17 12:22:15
-
-	aic79xx.c:
-	aic79xx.h:
-	aic79xx.reg:
-	aic79xx_pci.c:
-		Add logic for writing to serial eeproms.
-	
-		Move all flexport logic into the core.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#71 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#40 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#31 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#28 edit
-
-Change 1080 by gibbs@aslan on 2002/05/17 11:43:50
-
-	aic79xx.c:
-	aic79xx.h:
-	aic79xx_pci.c:
-		Switch over to using a buffer to store seeprom contents.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#70 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#39 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#27 edit
-
-Change 1078 by gibbs@overdrive on 2002/05/17 11:31:05
-
-	aic79xx_proc.c:
-		Protect the aic79xx proc code with the ahd_list_lock.
-	
-	aic7xxx_proc.c:
-		Release the ahc_list_lock when errors are encountered.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#18 edit
-
-Change 1077 by gibbs@overdrive on 2002/05/17 11:16:59
-
-	aic79xx_osm.c:
-		':' -> ';'
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#27 edit
-
-Change 1076 by gibbs@overdrive on 2002/05/17 11:14:48
-
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-		Kill a few stray ahcs.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#26 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#27 edit
-
-Change 1074 by gibbs@overdrive on 2002/05/17 11:08:38
-
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-	aic79xx_osm_pci.c:
-		Linux implementation of the ahd_list_lock.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#25 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#26 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#7 edit
-
-Change 1073 by gibbs@aslan on 2002/05/17 10:57:35
-
-	Implement and use the ahd_list_lock.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#69 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#26 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#10 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.h#6 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.c#6 edit
-
-Change 1071 by gibbs@overdrive on 2002/05/17 10:23:20
-
-	aic7xxx_reg.h:
-	aic7xxx_seq.h:
-		Regenerate firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#9 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#10 edit
-
-Change 1070 by gibbs@overdrive on 2002/05/17 10:22:28
-
-	aic7xxx.seq:
-		Defer clearing SELDO until we have set IDENTIFY_SEEN.
-		This closes another race in the abort code.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#43 edit
-
-Change 1069 by gibbs@overdrive on 2002/05/17 10:21:50
-
-	aic7xxx_osm.c:
-		Treat IDENTIFY_SEEN flag as an indication that we
-		are still on the bus but still waiting for the first
-		REQ.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#99 edit
-
-Change 1068 by gibbs@overdrive on 2002/05/17 09:42:25
-
-	aic7xxx_osm.c:
-	aic7xxx_osm_pci.c:
-		Guard the two avenues for detach with the ahc_list_lock.
-	
-		Disable card interrupts prior to attempting detach.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#98 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#32 edit
-
-Change 1067 by gibbs@aslan on 2002/05/17 09:36:18
-
-	aic7770.c:
-	aic7xxx_pci.c:
-		Guarantee that the ahc_list_lock is not required
-		across the calls to the different config calls by
-		only putting the softc into the list if the config
-		is successful.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#21 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#44 edit
-
-Change 1066 by gibbs@aslan on 2002/05/17 09:30:44
-
-	aic7770.c:
-	aic7xxx.c:
-	aic7xxx_pci.c:
-	aic7xxx_osm.c:
-		Make sure that the ahc_list_lock is always aquired
-		ahead of the ahc_lock to prevent lock order reversals.
-	
-		Protect insertions of the ahc_softc into the ahc_list
-		with the ahc_list_lock.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#20 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#68 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#43 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.c#5 edit
-
-Change 1064 by gibbs@overdrive on 2002/05/16 22:36:00
-
-	aic7xxx_osm.c:
-		Don't register our reboot notifier twice.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#97 edit
-
-Change 1062 by gibbs@aslan on 2002/05/16 17:36:58
-
-	aic79xx.c:
-		Set HOST_MSG in the command complete with no status
-		case so that when we go to message out, the sequencer
-		will notify the host.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#68 edit
-
-Change 1061 by gibbs@overdrive on 2002/05/16 14:55:36
-
-	aic7xxx.c:
-		Freeze the untagged queues from within
-		ahc_search_untaggd_queues() in addition to
-		ahc_search_qinfifo().  There are other callers
-		to ahc_search_untagged_queues().
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#67 edit
-
-Change 1059 by gibbs@overdrive on 2002/05/16 14:18:12
-
-	aic7xxx_osm.h:
-		Bump version number to 6.2.8.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#81 edit
-
-Change 1058 by gibbs@overdrive on 2002/05/16 14:17:45
-
-	aic7xxx_reg.h:
-	aic7xxx_seq.h:
-		Regenerate firmware for Linux.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#8 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#9 edit
-
-Change 1057 by gibbs@overdrive on 2002/05/16 14:16:41
-
-	aic7xxx_proc.c:
-		Perform a read after the write to the serial eeprom
-		to refresh our eeprom buffer.  This allows the user
-		to verify that the write was good.
-	
-		Only acquire and release the seeprom if we are not
-		a VLB card.
-	
-		Be less strick in allowing writes.  We want the user to
-		be able to overwrite an EEPROM that was previously corrupted.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#17 edit
-
-Change 1056 by gibbs@overdrive on 2002/05/16 14:13:32
-
-	aic7xxx_pci.c:
-		Set seep_config to NULL after freeing the seep buffer.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#42 edit
-
-Change 1055 by gibbs@aslan on 2002/05/16 13:59:01
-
-	aic7770.c:
-	aic7xxx.reg:
-		Add support for configuration extended translation
-		on the 274X.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#19 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#29 edit
-
-Change 1054 by gibbs@aslan on 2002/05/16 12:57:59
-
-	aic7xxx.h:
-	aic7xxx_pci.c:
-		Record if the BIOS config left over in SCB2 is used.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#45 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#41 edit
-
-Change 1053 by gibbs@aslan on 2002/05/16 12:57:24
-
-	aic79xx.h:
-		Reduce AHD_MAX_QUEUE to 255 until support for using
-		all SCBs is added.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#38 edit
-
-Change 1052 by gibbs@overdrive on 2002/05/16 11:23:12
-
-	aic79xx_reg.h:
-	aic79xx_seq.h:
-		Regenerate firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#12 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#13 edit
-
-Change 1051 by gibbs@aslan on 2002/05/16 11:06:00
-
-	aic79xx.c:
-		Correct some #if AHD_TARGET_MODE code.
-	
-	aic79xx.seq:
-		If we do not find a matching SCB when snooping
-		the bus, don't "double ack" the last byte.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#67 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#39 edit
-
-Change 1050 by gibbs@aslan on 2002/05/16 10:55:25
-
-	aic7xxx.c:
-	aic7xxx.h:
-	aic7xxx_pci.c:
-		Record if we are in large SCB mode and use this
-		to fully initialize all SCBs so that reads in
-		our debuging routines don't cause inadvertent
-		parity errors.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#66 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#44 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#40 edit
-
-Change 1049 by gibbs@aslan on 2002/05/16 10:41:35
-
-	aic7xxx.c:
-		Flush device writes after doing any CLRREQINITs.
-	
-		Protect ahc frees via the list lock.
-	
-	aic7xxx_osm.h:
-		FreeBSD implementation of the list lock.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#65 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.h#5 edit
-
-Change 1048 by gibbs@overdrive on 2002/05/16 10:29:21
-
-	aic7xxx_osm.c:
-		Set "paused" from within the "get the controller in
-		a consistent state" loop in ahc_queue_recovery_cmd().
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#96 edit
-
-Change 1046 by gibbs@overdrive on 2002/05/15 17:53:13
-
-	aic7xxx_reg.h:
-	aic7xxx_seq.h:
-		Regenerate firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#8 edit
-
-Change 1045 by gibbs@aslan on 2002/05/15 17:51:20
-
-	aic7xxx.seq:
-		Only clear SELDO after we have removed the
-		active SCB from the waiting list.  This allows
-		the host to use this as a confirmation that
-		the WAITING_SCB list is free of a just selected
-		SCB.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#42 edit
-
-Change 1044 by gibbs@overdrive on 2002/05/15 17:48:42
-
-	aic7xxx_osm.c:
-	aic7xxx_osm.h:
-		Add ahd_list_lock implementation for Linux.
-	
-		Protect against a pending selection in our recovery
-		queuing routine.
-	
-	aic7xxx_proc.c:
-		Use the buffer in the softc for seeprom access.  Add
-		preliminary write support for VLB cards.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#95 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#80 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#16 edit
-
-Change 1043 by gibbs@overdrive on 2002/05/15 17:07:06
-
-	aic7xxx.c:
-		Clear out SCB_SCSIID and SCB_LUN when setting up
-		the SCB free list.  We don't want a parity error
-		if we dump these out in ahc_dump_card_state().
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#64 edit
-
-Change 1042 by gibbs@aslan on 2002/05/15 15:39:00
-
-	aic7770.c:
-		Seeprom config is now a pointer.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#18 edit
-
-Change 1040 by gibbs@aslan on 2002/05/15 14:47:38
-
-	aic7770.c:
-	aic7xxx.c:
-	aic7xxx.h:
-	aic7xxx_pci.c:
-		Store seeprom information in a buffer hung
-		off the softc.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#17 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#63 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#43 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#39 edit
-
-Change 1039 by gibbs@overdrive on 2002/05/15 13:05:07
-
-	Merge latest aic79xx driver into linux-aic79xx-2.4.0.
-
-Affected files ...
-
-... //depot/linux-aic79xx-2.4.0/Makefile#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/ide/cmd640.c#3 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/Makefile#2 edit
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Config.in#5 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Makefile#3 edit
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx.h#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx.reg#3 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx.seq#3 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_core.c#3 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_host.h#3 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_inline.h#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_osm.c#3 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_osm.h#4 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#3 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_pci.c#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_proc.c#3 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_reg.h#4 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_seq.h#4 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx.h#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx.reg#4 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx.seq#4 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_93cx6.c#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_93cx6.h#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_core.c#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_host.h#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_osm.c#4 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_osm.h#3 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_pci.c#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_proc.c#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_reg.h#4 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_seq.h#4 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/Makefile#3 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm.c#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm.h#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/scsi_iu.h#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sd.c#3 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sr.c#3 integrate
-
-Change 1038 by gibbs@overdrive on 2002/05/15 12:50:49
-
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-		Next pass at timer support in the Linux OSM.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#24 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#25 edit
-
-Change 1037 by gibbs@overdrive on 2002/05/15 12:48:28
-
-	aic79xx.c:
-		Move two variables into #ifdef AHD_TARGET_ROLE.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#66 edit
-
-Change 1036 by gibbs@overdrive on 2002/05/14 17:16:57
-
-	Regenerate firmware.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#11 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#12 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#6 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#7 edit
-
-Change 1035 by gibbs@overdrive on 2002/05/14 17:15:44
-
-	aic79xx_osm.c:
-		Register our reboot notifier on the first allocation
-		of a platform softc rather than in our module parameter
-		parsing routine.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#23 edit
-
-Change 1034 by gibbs@overdrive on 2002/05/14 17:08:01
-
-	aic79xx_osm.h:
-		First cut at ahd timer facility for linux.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#24 edit
-
-Change 1033 by gibbs@aslan on 2002/05/14 15:54:32
-
-	aic79xx.c:
-	aic79xx.h:
-	aic79xx.seq:
-	aic79xx_osm.h:
-		Poll for SCSI bus reset going away from a timer
-		context rather than deferring the re-enabling
-		of the SCSIRSTI interrupt to the sequencer.  We
-		have to catch *every* bus reset due to the reset
-		behavior of the negotiation table.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#65 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#37 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#38 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.h#5 edit
-
-Change 1032 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/05/13 17:21:47
-
-	Regenerate firmware
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#10 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#11 edit
-
-Change 1031 by gibbs@overdrive on 2002/05/13 17:14:19
-
-	aic79xx_osm.h
-		Bump version to 0.3.0.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#23 edit
-
-Change 1030 by gibbs@aslan on 2002/05/13 17:11:08
-
-	aic79xx.c:
-	aic79xx.seq:
-		Have the sequencer re-enable incoming scsi reset
-		interrupts if, prior to starting an outgoing selection,
-		this interrupt is disabled.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#64 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#37 edit
-
-Change 1029 by gibbs@aslan on 2002/05/13 16:47:29
-
-	aic79xx.c:
-		Handle non-packetized phase unexpected busfree
-		events via the non-packetized handler regardless
-		of the packetized negotiation agreement in effect.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#63 edit
-
-Change 1028 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/05/11 22:55:03
-
-	Bump the version to 0.2.1.  We missed 0.2.0, and the driver is
-	about to be re-released to address yet another script bug.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#22 edit
-
-Change 1026 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/05/10 22:38:10
-
-	Regenerate firmware
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#9 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#10 edit
-
-Change 1024 by gibbs@aslan on 2002/05/10 20:19:25
-
-	aic79xx.c:
-		Add an error handler for receiving a command complete
-		message without having received status.  We will attempt
-		to abort the command.
-	
-		Enable the OVERRUN interrup and add a handler for it.
-	
-		Include lun information when compiling devinfo for the
-		unexpected bus free handler.
-	
-		Mask off the correct number of length bits when printing
-		S/G elements.
-	
-		Always update the neg table when setting bus width.
-	
-		Don't bother clearing the last three bytes of the annex
-		table on every update of the neg table.  These are cleared
-		explicitly on chip reset and will, in the B, contain training
-		info.
-	
-		Reset the chip on third party resets.  It is hoped that this
-		is the cause of some of the host basher issues related to
-		transferring into and out of emulation mode.
-	
-		Factor out more S/G printing code.
-	
-	aic79xx.reg:
-		Add a new sequencer interrupt code for a command complete
-		message with no status phase.
-	
-	aic79xx.seq:
-		Add checking for whether status has been delivered or not
-		in the command complete handler.
-	
-		Correct a test for a necessary bitbucket prior to having
-		the host reinitialize our data pointers.
-	
-	aic79xx_osm.h:
-		Change the AHD_DEBUG value for FreeBSD to 0x3FF.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#62 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#30 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#36 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.h#4 edit
-
-Change 1018 by gibbs@bitkeeper-linux-2.4 on 2002/05/08 17:21:24
-
-	aic7xxx_osm.c:
-		Replace SEARCH_REMOVE with SEARCH_COMPLETE in the search
-		of the untagged queue.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#94 edit
-
-Change 1017 by gibbs@overdrive on 2002/05/07 17:45:57
-
-	aic7xxx_osm.c:
-		Remove entries from the untagged queue prior to
-		doing a more general abort in ahd_linux_queue_recovery_cmd().
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#93 edit
-
-Change 1016 by gibbs@aslan on 2002/05/07 17:34:02
-
-	aic7xxx.c:
-	aic7xxx.h:
-		Break out the search for entries in the untagged
-		queue into its own routine.  Allow the user to
-		search based on io_ctxt too.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#62 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#42 edit
-
-Change 1015 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/05/07 14:54:52
-
-	Beta 1
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#21 edit
-
-Change 1014 by gibbs@aslan on 2002/05/07 14:53:39
-
-	aic79xx.h:
-		Limit max queue to 256 until nonpacketized tag
-		management is added to the driver.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#36 edit
-
-Change 1013 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/05/07 14:26:20
-
-	Add semicolon, initialize a variable before use.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#22 edit
-
-Change 1012 by gibbs@overdrive on 2002/05/07 14:25:46
-
-	aic79xx.h:
-		Change ahd_debug to be a uint32_t.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#35 edit
-
-Change 1011 by gibbs@overdrive on 2002/05/07 14:01:41
-
-	aic79xx.c:
-		Make ahd_debug a uint32_t.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#61 edit
-
-Change 1010 by gibbs@overdrive on 2002/05/07 13:59:31
-
-	aic79xx_osm.c:
-		Ignore short inquiry information for devices that
-		are already configured and seem to allow spi3/4
-		ppr options.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#21 edit
-
-Change 1009 by gibbs@aslan on 2002/05/07 13:07:06
-
-	aic79xx.c:
-		Expand on our unexpected busfree handling.
-		We now have a better chance of getting the
-		packetized vs. non-packetized status correct.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#60 edit
-
-Change 1008 by gibbs@aslan on 2002/05/07 11:22:51
-
-	aic79xx.h:
-		Add a debug option for QFull messages.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#34 edit
-
-Change 1007 by gibbs@overdrive on 2002/05/07 11:22:04
-
-	aic79xx_osm.c:
-		Add a loging option for displaying Queue Full info.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#20 edit
-
-Change 1005 by gibbs@aslan on 2002/05/06 17:20:00
-
-	aic79xx.c:
-		Complete port of the ignore wide residue and
-		data pointers reinitialization routines.
-	
-		Create ahd_dump_sglist() and use it to factor out
-		some code.
-	
-		Use SCB_GET_TAG to access hscb->tag.  This fixes
-		the first of many big endian issues in the driver.
-	
-		In the busfree handler, busfree time is valid even
-		for non-packetized phases.  We now assume that a
-		packetized phase is active if lastphase is P_BUSFREE.
-	
-		If a parity error occurred in the current phase,
-		ack the current byte so long as it is not currently
-		a data phase.
-	
-		Print out the number of SCBs aborted during
-		non-packetized busfree handling.
-	
-	aic79xx.h:
-		Add definition for SCB_GET_TAG.
-	
-		Add a new debug entry for AHD_SHOW_QUEUE.
-	
-		Add prototype for ahd_dump_sglist.
-	
-	aic79xx.seq:
-		In our restore data pointers handler, release
-		and reacquire our FIFO to flush out any state
-		info before a possible return to data phase.
-	
-		When coming back to the data phase handler after
-		having already handled at least one data phase,
-		only bother with the PDATA_REINIT sequencer
-		interrupt if we think more data needs to be sent.
-	
-	aic79xx_inline.h:
-		More SCB_GET_TAG() cleanup.
-	
-		Add SHOW queue code.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#59 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#33 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#35 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#23 edit
-
-Change 1004 by gibbs@aslan on 2002/05/06 17:07:11
-
-	Sync FreeBSD Ids.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#61 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#41 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#28 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#41 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#15 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.h#10 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#35 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#38 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#16 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#10 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#15 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#9 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_gram.y#3 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_scan.l#3 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#11 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#14 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#11 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/ahc_eisa.c#5 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/ahc_pci.c#5 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#9 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.c#4 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.h#4 edit
-
-Change 1002 by gibbs@overdrive on 2002/05/02 19:05:23
-
-	aic79xx_osm.c:
-	aic7xxx_osm.c:
-		Release the io_request lock in our detect routines
-		to avoid deadlock with other portions of the system
-		(possibly PCI) that may try to acquire a spin lock.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#19 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#92 edit
-
-Change 1001 by gibbs@overdrive on 2002/05/02 17:24:12
-
-	aic79xx_osm.c:
-		Put sense printing behind AHD_DEBUG.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#18 edit
-
-Change 1000 by gibbs@aslan on 2002/05/02 17:22:05
-
-	aic79xx.c:
-		Put even more messages behind AHD_DEBUG type stuff.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#58 edit
-
-Change 999 by gibbs@overdrive on 2002/05/02 16:59:43
-
-	aic79xx_osm.h:
-		Bump version to Alpha 8.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#20 edit
-
-Change 998 by gibbs@overdrive on 2002/05/02 16:59:16
-
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-		Add options for enabling debugging code.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#17 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#19 edit
-
-Change 997 by gibbs@overdrive on 2002/05/02 16:58:22
-
-	Config.in:
-		Add compile time options to control AHD_DEBUG.
-
-Affected files ...
-
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Config.in#4 edit
-
-Change 996 by gibbs@aslan on 2002/05/02 16:42:23
-
-	aic79xx.c:
-		Put sense and S/G mapping printfs under AHD_DEBUG.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#57 edit
-
-Change 995 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/05/02 15:37:38
-
-	Remove HD_DEBUG block that doesn't compile on Linux and doesn't
-	make much sense anyways.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#56 edit
-
-Change 994 by gibbs@overdrive on 2002/05/02 15:34:00
-
-	scsi_iu.h:
-		Pull in the latest from FreeBSD.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/scsi_iu.h#3 edit
-
-Change 993 by gibbs@overdrive on 2002/05/02 15:19:13
-
-	aic79xx_reg.h:
-	aic79xx_seq.h:
-	aic7xxx_reg.h:
-	aic7xxx_seq.h:
-		Regenerate firmware for Linux.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#8 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#9 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#5 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#6 edit
-
-Change 992 by gibbs@aslan on 2002/05/02 15:03:26
-
-	aic79xx.c:
-		Save and restore modes in ahd_clear_fifo.
-		Also reset our long jump address.
-	
-		At the beginning of every message loop,
-		reset LQIPHASE_OUTPKT via LQIRETRY if
-		this condition is set.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#55 edit
-
-Change 991 by scottl@scottl-hobbiton-mod_devel_aic79xx on 2002/05/02 12:55:04
-
-	Document the read streaming config switch
-
-Affected files ...
-
-... //depot/linux-aic79xx-2.4.0/Documentation/Configure.help#4 edit
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Config.in#3 edit
-
-Change 990 by gibbs@overdrive on 2002/05/01 22:03:06
-
-	aic79xx_osm.c:
-		First pass at read stream user tunables.  Still
-		needs an update to the config file.
-	
-		Bump limited tag count to 64.  Maxtor drives
-		still have issues with higher tag counts.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#16 edit
-
-Change 989 by gibbs@aslan on 2002/05/01 21:29:56
-
-	aic79xx.seq:
-		Restore an END_CRITICAL that was lost in the last
-		revision.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#34 edit
-
-Change 988 by gibbs@overdrive on 2002/05/01 21:23:18
-
-	aic79xx.seq:
-		Remove workarounds that only apply to chips <= A3.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#33 edit
-
-Change 987 by gibbs@aslan on 2002/05/01 21:19:06
-
-	aic79xx.c:
-		Split DFF reseting out of ahd_restart() and into
-		the routine ahd_clear_fifo().  This allows us to
-		safely restart the sequencer even if a FIFO has
-		been allocated to a new transaction.
-	
-		Add ahd_clear_fifo() calls as appropriate.
-	
-		Don't set PERRORDIS in SEQCTL0.
-	
-		Clean out sequencer interrupt codes that
-		are no longer in use.
-	
-		Add a handler for the ENTERING_NONPACK sequencer
-		interrupt.  This is used to handle the message
-		phases usually related to CRC errors in packetized
-		connections.
-	
-		Clean up saved mode handling.  The driver now
-		keeps the mode state as of when the interrupt
-		handler was entered in the softc as a separate
-		variable.  ahd_unpause() will now restore these
-		values whenever it is called.  This allows us to
-		remove several layers of saves and restores of
-		the mode register.
-	
-		Ensure we are in the SCSI mode when cleaning SCSI
-		interrupts.  Some of these clear bits are only
-		available in that mode.
-	
-		Port a few more non-pack sequencer interrupt code
-		handlers.
-	
-		Remove a few non-pack sequencer interrupt code
-		handlers that don't apply in a non-SCB paging
-		world.
-	
-		Complete framework for handling CRC errors.
-	
-		In our busfree handler, clear whichever fifo
-		was active at the time of the busfree.
-	
-		Only force a renegotiation for busfrees in a
-		non-packetized connection.
-	
-		In ahd_clear_critical_sections(), turn off all
-		of the interrupt enables that might prevent stepping.
-		Make sure that we unpause the sequencer in its
-		original mode during the stepping process.
-	
-		Rely on ATNO instead of ATNI.
-	
-		Handle "expected" busfrees after delivering an
-		INITIATOR_DET_ERROR message.
-	
-		Remove pausing code in the ahd_alloc_scbs() since
-		we no longer touch the hardware in this routine.
-	
-		Add additional AHD_DEBUG logging.
-	
-		Correct ahd_index_busy_tcl.  The target mask used
-		to set the SCBPTR was not correct.  This broke
-		non-packetized operations.
-	
-		Add code to print out the value of the packetized
-		failures field in status packets should it be set.
-	
-		Have ahd_dump_card_state() report the sequencer's
-		saved mode, not the current mode.
-	
-	aic79xx.h:
-		Add message handler flags for packetized CRC error
-		handling.
-	
-		Add fields for storing the sequencer's mode pointer
-		as found before setting any modes in host code.
-	
-		Add additional AHD_DEBUG values.
-	
-	aic79xx.reg:
-		Clean up SEQINTCODEs.
-	
-		Fix typo in BUSFREE_DFF0: O -> 0
-	
-	aic79xx.seq:
-		Remove a redundant test for SELDO.
-	
-		Workaround missing NONPACKREQ cases by looking
-		for ATNO and a message phase.
-	
-		Move the clearing of SELDO to outside of our
-		select_out handler's critical section.  This
-		ensures that we don't clear this status while
-		stepping through a critical section.
-	
-		Remove a jmp to await_busfree by moving the
-		await busfree handler.
-	
-		Clear the LONGJMP_ADDR prior to entering the
-		NONPACK handler.
-	
-	aic79xx_inline.h:
-		Revamp mode pointer routines to allow automatic
-		restoration of the sequencer's mode pointer when
-		the sequencer is unpaused.
-	
-		Add debug logging for all mode pointer accesses.
-	aic79xx_pci.c:
-		Correct the logging of PCI target errors.
-	
-	aic79xx_osm.c:
-		Add DDB hooks for looking at AHD registers.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#54 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#32 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#29 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#32 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#22 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#25 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#8 edit
-
-Change 986 by gibbs@aslan on 2002/05/01 20:51:55
-
-	aic7xxx.c:
-		Force renegotiation if we have an unexpected
-		busfree with a target just in case the busfree
-		is due to a negotiation mismatch.
-	
-		If the target goes on to a message that should
-		be handled by the sequencer during a host message
-		loop, terminate our message loop.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#60 edit
-
-Change 980 by gibbs@overdrive on 2002/04/25 12:54:54
-
-	aic79xx_osm.c:
-		If a device does not support information units as
-		per its inquiry data, don't attempt to set IUs or
-		IU related bits in our PPR requests.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#15 edit
-
-Change 979 by gibbs@aslan on 2002/04/25 11:32:11
-
-	aic79xx.c:
-		Force renegotiation on a non-packetized busfree.
-	
-		Commonize some devinfo setup in the non-packetized
-		busfree handler.
-	
-		Modify ahd_fetch_devinfo to pull IOWNID and TOWNID
-		from mode 3.  These registers are not valid in
-		modes 0 and 1.
-	
-		Add support for terminating an initiator message
-		loop early.  This is used to return to sequencer
-		based processing for those messages that the
-		sequencer usually handles.
-	
-		When parsing configuration parameters, manually
-		disable IU negotiation if the disconnect privledge
-		is disabled.
-	
-		Print out IOWNID, TOWNID and SCSISEQ1 in
-		ahd_dump_card_state.
-	
-	aic79xx_osm.c:
-		Disable IU_REQs if disconnects are disabled.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#53 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#7 edit
-
-Change 977 by gibbs@aslan on 2002/04/24 14:54:33
-
-	aicasm/aicasm.c:
-		Style nit.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#15 edit
-
-Change 976 by gibbs@aslan on 2002/04/24 12:43:24
-
-	aic79xx_inline.h:
-		Don't attempt to run the TQINFIFO if we are
-		out of ATIOs with which to service it.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#21 edit
-
-Change 975 by gibbs@aslan on 2002/04/24 12:42:39
-
-	ahc_eisa.c:
-	ahc_pci.c:
-		Remove DEVINTERFACE stuff that crept in from
-		my private trees.
-	
-	aic7xxx_inline.h:
-		Correct a big endian issue with large (> 12 byte)
-		cdb support.
-	
-	aic7xxx_osm.c:
-		Correct another big endian bug having to do with
-		sense data copying.
-	
-		And another big endian bug in the initialization
-		of SCBs that do not transfer data.
-	
-	aic7xxx_osm.h:
-		Enable byte swapping macros for FreeBSD.	
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#34 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/ahc_eisa.c#4 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/ahc_pci.c#3 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.c#3 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.h#3 edit
-
-Change 974 by gibbs@aslan on 2002/04/23 11:14:43
-
-	aic7xxx.c:
-		When clearing interrupts, perform a few
-		ahc_flush_device_writes() calls to ensure
-		status bits are cleared before any dependent
-		interrupt status bits.
-	
-		Add a comment about proper cleanup of the tqinfifo
-		under target mode.  Special care has to be taken
-		if we are a twin channel controller.
-	
-		Clean up the bus reset logic as it pertains to
-		target mode.  We still need a timer to wait for
-		the bus reset to fall so as to be completely immune
-		from "bus reset storms".
-	
-		Add a printf indicating that all ATIO resources
-		have been exhausted if this condition occurs and
-		we are running in bootverbose mode.
-	
-	aic7xxx.seq:
-		Properly set the synchronous transfer settings upon
-		resumption of a transaction with the disconnect privledge
-		disabled in target mode.  These connections were always
-		run in async mode irrespective of the negotiated transfer
-		rate.
-	
-	aic7xxx_inline.h:
-		Only attempt to run the TQINFIFO if we have ATIOs available
-		to service any entries that are found.
-	
-	aic7xxx_osm.c:
-		Put target mode diagnostics for transactions without the
-		disconnect privledge under bootverbose.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#59 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#40 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#33 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic7xxx_osm.c#2 edit
-
-Change 969 by gibbs@overdrive on 2002/04/22 16:46:42
-
-	aic7xxx_osm.h:
-		Bump Linux driver to 6.2.7 for chip reset delay.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#79 edit
-
-Change 967 by scottl@scottl-hobbiton-mod_devel1 on 2002/04/22 11:50:17
-
-	Note Alpha 7
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#18 edit
-
-Change 966 by gibbs@overdrive on 2002/04/22 11:46:47
-
-	aic79xx_reg.h:
-	aic79xx_seq.h:
-		Regenerate firmware for Linux.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#8 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#5 edit
-
-Change 965 by gibbs@aslan on 2002/04/22 11:45:24
-
-	aic79xx.c:
-		Simplify LQO busfree handling.  We now rely on
-		critical sections in the sequencer to make sure
-		that the sequencer is outside of the SELDO handler.
-		This allows us to clean up after the busfree with
-		one interrupt instead of two.
-	
-		Don't muck with the ENBUSFREE bit.  The set of the
-		BUSFREE interrupt is a pulse, so simply clearing
-		the BUSFREE status is enough to kill the interrupt.
-		This allows busfree protection for any packetized
-		connections that might be in progress during the
-		BUSFREE handler.
-	
-	aic79xx.h:
-		Fix duplicate entries in AHD_BUG definitions.
-	
-	aic79xx.reg:
-		Kill the LQOBUSFREE_TRAP sequencer interrupt.
-		It is no longer needed.
-	
-	aic79xx.seq:
-		Add critical sections to protect against jumping
-		to the SELDO handler at the same time the kernel
-		clears SELDO.
-	
-		If an LQOBUSFREE is detected in our SELDO handler,
-		jmp back to the idle loop so that we exit the
-		critical section and the kernel can handle the
-		error.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#52 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#31 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#28 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#31 edit
-
-Change 964 by gibbs@overdrive on 2002/04/22 00:00:09
-
-	aic79xx_reg.h:
-	aic79xx_seq.h:
-		Regenerate firmware for Linux.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#7 edit
-
-Change 963 by gibbs@aslan on 2002/04/21 23:58:57
-
-	aic79xx.seq:
-		Or in HDMAEN along with PRELOADEN just in
-		case HDMAENACK is not true at the time we
-		load a segment.  This avoids accidentally
-		shutting off host transfers.  This seems
-		to avoid the IBM drive issue and doesn't
-		require extra instructions or busy loops.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#30 edit
-
-Change 962 by gibbs@overdrive on 2002/04/21 23:24:21
-
-	aic79xx.c:
-		occured -> occurred.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#51 edit
-
-Change 961 by gibbs@overdrive on 2002/04/21 22:19:31
-
-	aic79xx_reg.h:
-	aic79xx_seq.h:
-		Regenerate to latest.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#6 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#6 edit
-
-Change 960 by gibbs@aslan on 2002/04/21 19:49:06
-
-	aic79xx_pci.c:
-		Update PCI bus modes to better reflect reality.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#24 edit
-
-Change 959 by gibbs@overdrive on 2002/04/21 18:44:49
-
-	aic79xx.seq:
-		Do not clear ENSELO if there is a pending SELDO
-		already.  We have not yet seen the SELDO, and
-		we rely on ENSELO set/clear sematics to distinguish
-		between packetized and non-packetized selections.
-	
-		or in IRET rather then use mvi in case some of
-		the bits in SEQINTCTL matter during interrupt
-		return.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#29 edit
-
-Change 958 by gibbs@overdrive on 2002/04/21 17:26:16
-
-	scsi_iu.h:
-		Correct off by 1 error.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/scsi_iu.h#2 edit
-
-Change 957 by scottl@scottl-hobbiton-mod_devel1 on 2002/04/21 00:23:33
-
-	Indicate Alpha 6
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#17 edit
-
-Change 956 by gibbs@overdrive on 2002/04/20 23:36:53
-
-	aic79xx_inline.h:
-		In ahd_lookup_scb(), guard against tag values
-		larger than AHD_SCB_MAX.  Our array of indexes
-		in only that large.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#20 edit
-
-Change 955 by gibbs@overdrive on 2002/04/20 23:28:30
-
-	aic79xx.c:
-		Fix logic bug in ahd_abort_scbs().
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#50 edit
-
-Change 954 by gibbs@overdrive on 2002/04/20 23:27:01
-
-	aic79xx.c:
-		Add missing '}'.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#49 edit
-
-Change 953 by gibbs@overdrive on 2002/04/20 23:25:00
-
-	aic79xx.c:
-		Limit abort processing of the busy targets table
-		to LUNS that are addressable when not packetized.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#48 edit
-
-Change 951 by scottl@scottl-hobbiton-mod_devel1 on 2002/04/20 21:16:27
-
-	Add definition for PCIM_SERRESPEN
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#16 edit
-
-Change 950 by gibbs@overdrive on 2002/04/20 21:06:07
-
-	aic79xx_osm.c:
-		Remove call to ahd_search_disc_list() which is no
-		longer required.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#14 edit
-
-Change 949 by gibbs@overdrive on 2002/04/20 21:04:55
-
-	aic79xx_reg.h:
-	aic79xx_seq.h:
-		Regenerate firmware for Linux releases.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#5 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#5 edit
-
-Change 948 by gibbs@aslan on 2002/04/20 21:03:26
-
-	aic79xx.c:
-		Remove disconnected list handling code as this
-		product does not use this algorithm.
-	
-		Add a routine to determine if we are currently
-		in a connection that has a packetized agreement.
-	
-		Add a routine to switch to the currently active
-		FIFO's mode.
-	
-		Modify unexpected busfree handling for outgoing
-		packets.  LQOBUSFREE is now a pollable status
-		rather than an interrupt.  When the unexpected
-		busfree interrupt occurs, we simply clear it
-		if LQOBUSFREE is set.  The sequencer will
-		eventually handle the SELDO and issue a sequencer
-		interrupt to the host.  The host then cleans up
-		the execution queue and restarts the sequencer.
-		This avoids the problem of determining just where
-		the sequencer is executing at the time of the
-		BUSFREE since the sequencer can drift into the
-		SELDO handler while the BUSFREE interrupt is working
-		to pause it.
-	
-		Finish the port of the busy target table routines.
-		This are used during error recovery.
-	
-		Start documenting our strategies for handling
-		CRC errors.  The code for this is only partially
-		completed.
-	
-		Tighten up the host message loop.  We now have
-		the sequencer perform the actual reads and writes
-		to drive our ACK, to reduce the possibility of the
-		sequencer missing a short lived phase.
-	
-		Print out the HADDR and HCNT for both FIFOs
-		in ahd_dump_card_state().
-	
-	aic79xx.h:
-		Add better documentation for the TCL format.
-	
-		Add a macro for building a TCL from target,
-		channel and lun, rather than SCSIID and lun.
-	
-		Add a bug entry for the issue on the A about
-		the packetized status bit being flakey.
-	
-		Add an SCB flag for recording transmission
-		errors.  This flag should save us if the
-		target does not properly return status
-		in response to our initiator detected
-		error message.
-	
-	aic79xx.reg:
-		Add a new sequencer interrupt for the busfree trap.
-	
-		Add bit definition for LQIPHASE_OUTPKT.
-	
-		Target message loop definitions.
-	
-	aic79xx.seq:
-		Use ENSELO auto-clearing as the key to determining
-		if the connection is packetized or not.
-	
-		Add support for handling unexpected busfree
-		events in outgoing command packets.
-	
-		If we have already allocated a FIFO when entering
-		the command phase, this must be a retry.  Free
-		the FIFO and reallocate it to make sure no
-		state from the previous transfer prevents the
-		retry from occurring properly.
-	
-		Host message loop changes.
-	
-		Add a possible workaround for hardware failing
-		to record the write to HDMAEN.  We simply loop
-		setting this bit until the hardware finally
-		acknowledges that it is set.  The seems to
-		only be required on SCSI writes to IBM Daytona
-		drives.  More investigation is needed.
-	
-	aic79xx_osm.c:
-		Update for changes in host message loop
-		handling.
-	
-		Remove call to ahd_search_disc_list() that
-		is nolonger required.
-	
-	aic79xx_pci.c:
-		Add in new bug definitions.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#47 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#30 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#27 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#28 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#23 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#6 edit
-
-Change 935 by gibbs@aslan on 2002/04/17 10:28:58
-
-	aic79xx.c:
-		Perform a 1000us delay after asserting CHIPRST
-		and prior to touching an card registers.  The
-		delay is not exact due to PCI write buffering
-		semantics, but it should still be sufficient to
-		avoid touching chip registers prior to the chip
-		becoming ready for such accesses.
-	
-		Modify ahd_chip_init() to leave the chip in a
-		paused state in AHD_MODE_SCSI.
-	
-		Modify ahd_loadseq() to leave the sequencer paused.
-		Code that follows such a call must call ahd_restart().
-	
-		Perform a chip reset on every outgoing bus reset
-		on rev A hardware.
-	
-	aic79xx.h:
-		Add AHD_SCSIRST_BUG.
-	
-	aic79xx_inline.h:
-		Don't reset the channel just prior to panicing due
-		to a mode assertion.  This could cause an infinite
-		recursion loop if the mode assertion is in
-		ahd_reset_channel or something it calls.
-	
-	aic79xx_pci.c:
-		Add in scsi bus reset requires chiprst bug to ahd->bugs.
-	
-	aic7xxx.c:
-		Perform a 1000us delay after asserting CHIPRST
-		and prior to touching an card registers.  The
-		delay is not exact due to PCI write buffering
-		semantics, but it should still be sufficient to
-		avoid touching chip registers prior to the chip
-		becoming ready for such accesses.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#46 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#29 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#19 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#22 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#58 edit
-
-Change 931 by gibbs@aslan on 2002/04/16 19:19:23
-
-	aic79xx.c:
-		Break out post CHIPRST initialization from ahc_init()
-		so that we can reset the chip for workarounds.
-	
-	aic79xx.h:
-		AHD_PCIX_RST_BUG -> AHD_PCIX_CHIPRST_BUG.
-	
-	aic79xx.reg:
-		Move CMDSIZE_TABLE to the end of our current scratch
-		ram definitions and initialize it in ahd_chip_init().
-	
-	aic79xx_pci.c:
-		Pull some PCI initialization code that needs to be
-		performed after every CHIPRST into aic79xx.c:ahd_chip_init().
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#45 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#28 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#26 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#21 edit
-
-Change 930 by gibbs@overdrive on 2002/04/15 19:22:04
-
-	aic79xx_osm.h:
-		Turn on all debugging code.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#15 edit
-
-Change 929 by scottl@scottl-hobbiton-linux on 2002/04/15 15:45:29
-
-	Bump the driver version to ALPHA 5
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#14 edit
-
-Change 912 by gibbs@aslan on 2002/04/15 13:30:23
-
-	aic79xx.c:
-		Style fix.
-	
-		Move chip bug bitmap setup into the "chip personality"
-		handlers.
-	
-		Include a bus description in ahd_controller_info().
-	
-	aic79xx.h:
-		Add a mask for bug workarounds that can be disabled
-		if we are not in PCI-X mode.
-	
-		Add bus_description to our softc.
-	
-	aic79xx_pci.c:
-		Initialize ahd->bus_description.
-	
-		Disable PCI-X specitific workarounds when operating
-		in PCI mode.
-	
-		Remove a few workarounds if we are an A4 chip.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#44 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#27 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#20 edit
-
-Change 905 by gibbs@overdrive on 2002/04/11 22:00:57
-
-	aic7xxx_osm.h:
-		Bump to version 6.2.6.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#78 edit
-
-Change 902 by scottl@scottl-hobbiton-mod_devel1 on 2002/04/10 23:30:00
-
-	aic79xx.c:
-		Dump our card state should we encounter an unhandled
-		SCSIINT.  Make the panic message for this case more
-		explicit too.
-	
-		Add a diagnostic for a new PPR Negotiation that should
-		end in a Busfree.  This is the case of a pre-existing
-		IU_REQ agreement at the time of a Negotiation.
-	
-		Dump the card state when we encounter an unexpected busfree.
-	
-		Always refresh the neg-table when calling ahd_set_syncrate()
-		to handle the case of the sequencer setting the ENATNO bit
-		for a MK_MESSAGE request.  We will always renegotiate in that
-		case if this is a packetized request.
-	
-		Correct the logic for setting MSG_FLAG_EXPECT_PPR_BUSFREE.
-		This should be set in the case of a pre-existing IU_REQ
-		agreement as well as if the IU_REQ agreement has changed.
-	
-		Kill a redundant call to ahd_update_neg_table.
-	
-		When dumping card state, also dump platform card state.
-	
-	aic79xx_osm.c:
-		user uint16_t rather than uint8_t for the array of user
-		settable tag limits.  We will eventually allow 512 as
-		the max.
-	
-		Properly propogate sense data in status packets back
-		to the user.
-	
-		Dump card state in the abort and target reset handlers.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#43 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#13 edit
-
-Change 899 by scottl@scottl-hobbiton-linux on 2002/04/09 16:25:34
-
-	Remove seeprom_erase
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#14 integrate
-
-Change 895 by gibbs@overdrive on 2002/04/09 15:17:06
-
-	aic79xx_host.h:
-	aic79xx_osm.c:
-	aic7xxx_host.h:
-	aic7xxx_osm.c:
-		Move max_sectors initialization back into osm.c so
-		that it can be conditionalized on Linux kernel verison.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_host.h#6 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#12 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#9 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#91 edit
-
-Change 894 by scottl@scottl-hobbiton-linux on 2002/04/09 15:16:00
-
-	Add support for reading and writing the SEEPROM through the
-	/proc interface.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#40 integrate
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#13 integrate
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.h#9 integrate
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#37 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#15 integrate
-
-Change 891 by gibbs@overdrive on 2002/04/09 13:35:39
-
-	aic79xx_seq.h:
-	aic79xx_reg.h:
-	aic7xxx_seq.h:
-	aic7xxx_reg.h:
-		Start generating firmware at the toplevel only.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#4 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#4 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#4 edit
-
-Change 886 by gibbs@overdrive on 2002/04/07 23:42:22
-
-	aic79xx.c:
-		Kill debugger calls that are unsupported by Linux.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#42 edit
-
-Change 884 by gibbs@overdrive on 2002/04/07 21:46:23
-
-	aicasm/Makefile:
-		Reverse integration.
-		Kill .NOTPARALLEL.  Use flex's -o.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/Makefile#12 integrate
-
-Change 883 by gibbs@aslan on 2002/04/07 21:40:53
-
-	aic79xx.c:
-		When handling the "expected" unexpected busfree
-		after a negotiation, freeze the scb and the device
-		queue so that ordering is preserved.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#41 edit
-
-Change 882 by gibbs@aslan on 2002/04/07 21:21:53
-
-	aic79xx.c:
-	aic79xx.h:
-	aic79xx.seq:
-		Add a workaround for the outstanding split bug.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#40 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#26 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#27 edit
-
-Change 881 by gibbs@overdrive on 2002/04/07 21:10:53
-
-	aic79xx.c:
-	aic7xxx.c:
-		Kill return argument.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#39 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#57 edit
-
-Change 880 by gibbs@overdrive on 2002/04/07 21:09:54
-
-	aic79xx.h:
-	aic7xxx.h:
-		Kill return argument.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#25 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#39 edit
-
-Change 879 by gibbs@overdrive on 2002/04/07 21:06:29
-
-	aic79xx.c:
-	aic79xx.h:
-	aic7xxx.c:
-	aic7xxx.h:
-		Add a routine to verify that a softc is still
-		on our list and configured.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#38 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#24 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#56 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#38 edit
-
-Change 878 by gibbs@overdrive on 2002/04/07 21:04:35
-
-	aic79xx_host.h:
-	aic7xxx_host.h:
-		Add a missing comma.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_host.h#5 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#8 edit
-
-Change 875 by gibbs@overdrive on 2002/04/07 18:16:42
-
-	aic79xx_host.h:
-	aic7xxx_host.h:
-	aic79xx_osm.c
-	aic7xxx_osm.c
-		Set "max_sectors" in our host template so that the Linux
-		SCSI layer doesn't foolishly limit our I/O size.
-	
-		Set a few additional static fields into the template
-		initialization macro.
-	
-	aic7xxx_osm_pci.c:
-	aic79xx_osm_pci.c:
-		Use ah[dc]_find_softc rather than do a brute force lookup
-		in multiple places.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_host.h#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#11 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#6 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#90 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#31 edit
-
-Change 873 by gibbs@aslan on 2002/04/05 12:29:11
-
-	aic79xx.c:
-		Handle a few more sequencer interrupts.
-	
-		Monitor sstat3 during SCSIINT handling.
-	
-		Remove a duplicate comment.
-	
-		Enable checking of negotiation table and output
-		sync FIFO parity errors.
-	
-		When traversing the execution queue, only complain
-		of list corruption after itterating over max SCB
-		entries.  Since elements can be queued outside of
-		the per-target lists, the num target limit coult
-		unintentionally fire.
-	
-		Correct a bug in the stitching of the TID lists in
-		the execution queue.  We could lose a whole TID
-		list in certain scenarios.
-	
-		When handling status errors, save and restore the
-		current mode as well as clear any critical sections
-		in the firmware.  We might otherwise corrupt sequencer
-		state.
-	
-		Add some more information to the ahd_dump_card_state()
-		output.
-	
-		Add a routine to dump out the state of all SCBs.  This
-		might be useful from the debugger.
-	
-	aic79xx.h:
-		Prototype ahd_dump_scbs().
-	
-	aic79xx.seq:
-		Stop using MK_MESSAGE as a flag for "dead" SCBs.
-		We should come up with another mechanism, but this
-		might confuse the cleanup of the execution queue
-		for SCBs that selected out with atn asserted.
-	
-		Use HDMAEN as a definitive test to see if a
-		saveptr interrupt is for a snapshot or not.
-	
-	aic79xx_pci.c:
-		Add a comma to the table of pci_status_strigs, so we
-		don't attempt to printf garbage.  Oops.
-	
-		Clear latched pci status at the end of our PCI error
-		handler so that the pci error interrupt is de-asserted.
-		More logic is needed here to handle PCI-X errors.
-	
-	aic7xxx.c:
-		If we have an overrun on an auto-request sense, report
-		autosense fail, not data-run-error.
-	
-		Use AHC_NUM_TARGETS rather than a hard coded 16.
-	
-		Fix a typo.
-	
-	aic7xxx.reg:
-		Add a comment to the DIRECTION bit so I can stop
-		looking it up its polarity in the data book all the time.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#37 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#23 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#25 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#26 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#19 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#55 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#27 edit
-
-Change 840 by gibbs@overdrive on 2002/03/26 23:33:12
-
-	p4 integrate -r -b redhat-aic7xxx-2.4.7_10_i386.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#26 integrate
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#39 integrate
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#36 integrate
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#14 integrate
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#9 integrate
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#14 integrate
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#8 integrate
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_gram.y#2 integrate
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_scan.l#2 integrate
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#10 integrate
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#13 integrate
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#10 integrate
-
-Change 839 by gibbs@overdrive on 2002/03/26 23:32:40
-
-	Integrate -r -b redhat-aic7xxx-2.4.7_10_i386
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#89 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#14 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#3 branch
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#3 branch
-
-Change 813 by gibbs@overdrive on 2002/03/13 20:18:34
-
-	aic79xx_osm.h:
-		Bump version number to 0.0.4 for Alpha 4 release.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#13 edit
-
-Change 800 by gibbs@overdrive on 2002/03/13 14:56:13
-
-	aic79xx.c:
-		Remove TRACEPOINT6 code which is no longer used.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#36 edit
-
-Change 795 by gibbs@overdrive on 2002/03/13 14:39:50
-
-	aic79xx_osm.h:
-		Add an implementation for scsi_4btoul().
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#12 edit
-
-Change 791 by gibbs@aslan on 2002/03/13 14:02:50
-
-	aic79xx.c:
-		Reset the bus if we encounter an overrun on a
-		status packet.
-	
-		Implement the AHD_CLRLQO_ATUTOCLR_BUG workaround.
-		We just need to manually clear the CLRLQO registers
-		when we use them.
-	
-		Roll LQISTAT1 handling into the
-		ahd_handle_transmission_errror(), handler.
-	
-		Don't qualify the BUSFREE status with ENBUSFREE.  The
-		chip may well have moved on to an handled another
-		transaction on the bus, so we simply cannot rely on
-		ENBUSFREE giving us an acuate sense of whether this
-		is a true BUSFREE interrupt.  Right now we defer
-		looking at BUSFREE interrupts until last in the hope
-		that we'll ignore spurious values of this bit by handling
-		the conditions we are sure of first.
-	
-		In handling busfree conditions allow the handler for that
-		condition to either unpause the sequencer or to force a
-		sequencer reset.
-	
-		Don't rely on the PACKETIZED status bit.  It corresponds
-		to the *last* connection on the bus, not the current one.
-		Instead rely on LQISTAT1 giving us acurate information
-		about transmission errors that correspond to packetized
-		transfers.
-	
-		Handle unexpected busfrees that indicate the target
-		saw a bad CRC in one of our outgoing LQs.
-	
-		Add optional debugging information for kernel handled
-		message phases.
-	
-		Fix a spelling error.
-	
-		Add loging for QAS messages that occur when they shouldn't.
-		We will reject the message which should force a busfree.
-	
-		Add more bug entries.
-	
-		When cleaning up entries from the waiting for selection
-		queue, handle MK_MESSAGE SCBs specially as they are not
-		now placed into the per-target-id queues.
-	
-		Add more logging for sense packets.
-	
-		Link completed SCBs using a different set of link
-		pointers.  This allows us to put the SCBs on the
-		complete queue without fear of corrupting the waiting
-		for selection queue if we have yet to see a pending
-		SELDO.
-	
-		Log the contents of the SCSIPHASE register in
-		ahd_dump_card_state().
-	
-	aic79xx.h:
-		Add more bug entries.
-	
-		Add a debugging flag for printing information during
-		kernel handled message phases.
-	
-	aic79xx.reg:
-		LQOBUSFREE1 -> LQOBUSFREE
-		LQOPHACHG1  -> LQOPHACHGINPKT
-	
-		CLRLQOBUSFREE1 -> CLRLQOBUSFREE
-		CLRLQOPHACH1   -> CLRLQOPHCHGINPKT
-	
-		ENLQOBUSFREE1 -> ENLQOBUSFREE
-		ENLQOPHACHG1 -> ENLQOPHACHGINPKT
-	
-		LQOPHACHG0 -> LQOPHACHGOUTPKT
-	
-		Add SCB_NEXT_COMPLETE link in the CDB pad
-		area.
-	
-	aic79xx.seq:
-		Queue incoming MK_MESSAGE SCBs separately so as
-		to ensure we see the MK_MESSAGE bit on the outgoing
-		selection that will send this SCB.
-	
-		Convert all complete queue operations to use the
-		SCB_NEXT_COMPLETE link.
-	
-		Start adding more critical section wrappers.  This
-		work still needs to be augmented and reviewed.
-	
-		When selecting out with a SCB that has MK_MESSAGE
-		set, don't bother clearing NEGPPROPTS.  We now
-		look for the MK_MESSAGE flag in our SELDO handler
-		and can thus determine that this is actually a
-		"nonpackreq" selection.
-	
-		Add in the workaround for AHD_AUTOFLUSH_BUG.
-	
-		Correctly set the transfer size for status packets
-		so we don't think we've had an overrun.
-	
-		Enhance, I hope, the workaround for the PCIX arbiter
-		hang.  We also now install the hang detection for
-		legacy.
-	
-	aic79xx_pci.c:
-		Take a first shot at handling PCI/PCI-X errors.  More
-		work is required here.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#35 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#22 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#24 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#25 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#18 edit
-
-Change 779 by gibbs@overdrive on 2002/03/11 17:55:24
-
-	aic79xx_osm.c:
-		Disable ABORT and BDR attempts until error recovery
-		is better fleshed out.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#10 edit
-
-Change 778 by gibbs@overdrive on 2002/03/11 17:55:02
-
-	aic79xx_osm.h:
-		Remove EISA/VL defines that don't apply to the
-		hardware supported by this driver.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#11 edit
-
-Change 767 by gibbs@aslan on 2002/03/06 15:10:06
-
-	aic79xx_pci.c:
-		Add a #define for the A4 revision number.
-	
-		Add a placeholder for the B0 revision number.
-	
-		Disable pending PCI REQ assertion on anything
-		younger than the B0.  It doesn't work if both
-		channels are active.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#17 edit
-
-Change 765 by gibbs@overdrive on 2002/03/04 21:59:30
-
-	aic79xx_osm.h:
-		Bump version number to 0.0.3.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#10 edit
-
-Change 764 by gibbs@overdrive on 2002/03/04 21:59:14
-
-	Handle integrate -r from redhat-aic79xx-2.4.7_10_i386
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_host.h#3 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#5 integrate
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#3 integrate
-
-Change 761 by gibbs@overdrive on 2002/03/04 21:49:07
-
-	aic79xx.c:
-		Remove critical section clearing printfs.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#34 edit
-
-Change 759 by gibbs@moria on 2002/03/04 21:36:11
-
-	aic79xx.c:
-		In ahd_devlimited_syncrate(), treat the precomp enable
-		bit specially.  This is bit should be acted on regardless
-		of our goal for having the target precomp for us.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#33 edit
-
-Change 755 by gibbs@aslan on 2002/03/04 12:59:48
-
-	aic79xx_pci.c:
-		Only attach to A3 or newer H2A2 parts.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#16 edit
-
-Change 754 by gibbs@aslan on 2002/03/04 10:43:45
-
-	aic79xx.c:
-		Convert ahd_assert_atn to an inline.
-	
-		Add a comment indicating that blindly clearing out the
-		DMA channels in ahd_restart() is probably a bad thing.
-		Perhaps the best place to do this is in ahd_abort_scbs()
-		which should be able to match the SCB owning the FIFO
-		with the SCB pattern to kill off, but that is not completely
-		clear yet.
-	
-		Add the beginnings of an "illegal non-packetized phase"
-		handler.  This interrupt will be invoked should a target,
-		with whom we've negotiated packetized, take us to a non-pkt
-		and non-message phase.  The only situation we currently
-		handle is the case of a target taking us to the command
-		phase on the first REQ of what should be a packetized
-		connection.  Our response to that condition is:
-			o Downgrade our current negotiation to async/narrow.
-			o Embed a TUR into the SCB to replace whatever,
-			  possibly media altering, command was originally
-			  in the SCB.
-			o Clear any tag information in the SCB and set
-			  MK_MESSAGE.
-			o Set MSG_OUT to HOST_MSG, SAVED_SCSIID to the
-			  scb's SCSIID, and SAVED_LUN to 0 (no identify
-			  message, so target believes lun is 0).
-			o Clear the packetized flag in the SCB and set
-			  SCB_ABORT and SCB_CMDPHASE_ABORT.
-			o assert ATN.
-			o Prepare the transaction to complete with
-			  CAM_REQUEUE_REQ.
-			o When the Abort completes, we only abort the
-			  SCB that encountered the error.  This behavior
-			  and the actual error code we return should be
-			  reviewed.
-	
-		Convert some manual traversals of the phase table to calls
-		to ahd_lookup_phase_entry().
-	
-		Port the MKMSG_FAILED sequencer interrupt handler.
-	
-		If busfreetime is non-zero, but we were performing nonpackreq
-		recovery, use the ahd_handle-nonpkt_busfree() handler.
-	
-		Handle the case of a new PPR negotiation to a target that
-		we have already negotiated packetized to.  We should get
-		a busfree in this case.  The remainder of the handling of
-		this situation is in the sequencer.
-	
-		Correct a bug in the critical section stepping code.  We
-		were in the wrong register window when trying to clear
-		SIMODE0.
-	
-		If we are currently packetized with a target, the only
-		valid messages we can send at the beginning of the connection
-		are PPR or TUR.  Therefore, supress the identify messages.
-	
-		Create a msg_flags field in ahd_softc.  This replaces
-		msg_expect_ppr_busfree since we need to also record
-		whether the state of IU_REQ changed.
-	
-		Fix a grammer bug.
-	
-		Clear all message flags in the SCB during a request sense
-		that only intends to renegotiate with the device.
-	
-		Kill a debugging printf.
-	
-		Display the contents of SIMODE1, OPTIONMODE and MAXCMDCNT
-		during ahd_dump_card_state().
-	
-	aic79xx.h:
-		Make AHD_SENSE_BUFSIZE a sequencer visible value.
-	
-		Redefine our Hardware SCB format so we can embed a
-		sense address in the case of cdbs <= 12 bytes or using
-		a pointer.
-	
-		Add the SCB_CMDPHASE_ABORT flag.
-	
-		Add ahd_msg_flags.
-	
-	aic79xx.reg:
-		Document the DIRECTION bit in DFCNTRL.
-	
-		Redefine our Hardware SCB format so we can embed a
-		sense address in the case of cdbs <= 12 bytes or using
-		a pointer.
-	
-		Make AHD_SENSE_BUFSIZE a sequencer visible value.
-	aic79xx.seq:
-		When we are about to select a device and the first SCB
-		has MK_MESSAGE set, make sure to enable ENAUTOATNO.
-	
-		Treat LQOPHACHG1 as an unexpected_nonpkt_phase.
-	
-		Make the PCI-X workaround for the hung arbiter even
-		more selective in the legacy case.  We only need to
-		check for the hang condition if we are disconnecting
-		in the middle of a transfer.
-	
-		Enhance a comment about BITBUCKET handling in the
-		non-pack case.
-	
-		Correct a lable jump that should have been changed in
-		the last commit to this file.  The previous lable has
-		been removed.
-	
-		Add support for handling a status packet without host
-		intervention if the sense address is embedded in the
-		SCB.
-	
-	aic79xx_inline.h:
-		Embed the sense address in the SCB if there is room. 
-	
-	aic79xx_pci.c:
-		Be more careful about endianess when printing out
-		serial eeprom contents.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#32 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#21 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#23 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#24 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#18 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#15 edit
-
-Change 697 by gibbs@overdrive on 2002/02/26 17:49:44
-
-	aic79xx.c:
-	aic79xx.h:
-	aic79xx.reg:
-	aic79xx.seq:
-	aic79xx_pci.c:
-		Integrate changes from redhat-aic7xxx-2.4.7_10_i386
-		back into the core files.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#31 integrate
-... //depot/aic7xxx/aic7xxx/aic79xx.h#20 integrate
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#22 integrate
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#23 integrate
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#14 integrate
-
-Change 673 by gibbs@overdrive on 2002/02/11 16:36:16
-
-	aic79xx_osm.h:
-		Bump driver version to 0.0.2.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#9 edit
-
-Change 671 by gibbs@overdrive on 2002/02/11 16:28:09
-
-	aic7xxx_pci.c:
-		Pretend that there are no cables if we have
-		an illegal cable configuration.  This may fix
-		problems on certain HP Kayak systems.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#35 edit
-
-Change 668 by gibbs@overdrive on 2002/02/11 15:13:10
-
-	aic79xx.reg:
-	aic79xx.seq:
-		Convert to text+ko
-	
-	aic79xx_pci.c:
-		Avoid endian issues when dumping the seeprom.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#21 integrate
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#22 integrate
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#13 edit
-
-Change 667 by gibbs@aslan on 2002/02/11 15:09:27
-
-	aic79xx.c:
-		Add additional bug entries for Rev A errata.
-	
-		Don't attempt to perform current sensing on a
-		board unless we know that it is supported.  Doing
-		current sensing when it is not support messes up
-		our external termination.
-	
-		Leave the force U160 stuff in place, but allow
-		U320 transfers now.
-	
-		Don't attempt QAS or read streaming on A2 hardware.
-	
-	aic79xx.h:
-		Add more bug entries.
-	
-	aic79xx.seq:
-		Add comment about why we have to check SEDO when
-		ENSELO is clear but prior to starting a new selection.
-	
-		Add critical sections around some of the places they
-		are needed.
-	
-		Add a first cut workaround for one of the PCI-X bugs.
-		This particular bug is fixed in A3.
-	
-		Conditionalize the last bit of the CURRSCB workaround.
-	
-		Set the SCB_DMA flag when we initiate an SCB dma.  This
-		is the beginning of work to handle cancled DMAs from
-		the qinfifo.
-	
-	aic79xx_pci.c:
-		Only do current sensing if the card supports it.
-	
-		Truely initialize termctl if auto-term sensing fails.
-	
-		Set the low primary termination prior to setting any
-		external termination.  This mirrors what CHIM does.
-	
-		Add a mode assert to ahd_write_flexport.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#30 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#19 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#21 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#12 edit
-
-Change 663 by gibbs@overdrive on 2002/02/11 13:13:52
-
-	aic7xxx_osm.h:
-		Bump Linux aic7xxx driver version number to 6.2.5.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#77 edit
-
-Change 661 by gibbs@overdrive on 2002/02/11 13:11:36
-
-	aicasm/Makfile:
-		Bring .NOTPARALLEL change into the top level.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/Makefile#11 integrate
-
-Change 657 by scottl@scottl-linux on 2002/02/06 19:17:16
-
-	Serialize Makefiles.  Use CONFIG_AIC79XX_BUILD_FIRMWARE flag.
-
-Affected files ...
-
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Makefile#2 edit
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/Makefile#2 edit
-
-Change 650 by gibbs@overdrive on 2002/01/28 17:35:10
-
-	aic79xx_osm.c:
-		Limit tag depth to 16 under Linux to avoid QUEUE_FULL
-		issues with Maxtor drives.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#9 edit
-
-Change 648 by gibbs@overdrive on 2002/01/28 17:29:46
-
-	aic79xx.c:
-		Correct typo.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#29 edit
-
-Change 647 by gibbs@overdrive on 2002/01/28 17:22:18
-
-	aic79xx.c:
-		Move more diagnostic printfs under AHD_DEBUG.
-	
-		Force 160 as the maximum sync speed until 320
-		issues are ironed out.
-	
-	aic79xx_pci.c:
-		Kill some diagnostic printfs.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#28 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#11 edit
-
-Change 646 by gibbs@overdrive on 2002/01/28 17:18:52
-
-	aic79xx_osm.h:
-		Bump Linux version number to for 0.0.1 release.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#8 edit
-
-Change 644 by gibbs@overdrive on 2002/01/28 16:43:03
-
-	aic79xx_osm.c:
-		Remove reference to ahc->seltime_b.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#8 edit
-
-Change 643 by gibbs@aslan on 2002/01/28 15:18:56
-
-	aic79xx.c:
-	aic79xx.h:
-	aic79xx.reg:
-	aic79xx.seq:
-	aic79xx_inline.h:
-	aic79xx_pci.c:
-		First pass at NONPACKREQ and CRC error handling.
-	
-		Turn on digital filtering and some additional IOCELL
-		workarounds.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#27 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#18 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#20 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#20 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#17 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#10 edit
-
-Change 640 by gibbs@aslan on 2002/01/27 14:15:43
-
-	aic79xx.c:
-	aic79xx.h:
-	aic79xx.reg:
-		Correct the selection timeout period on Rev A
-		parts where it is twice as long as the set value.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#26 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#17 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#19 edit
-
-Change 639 by gibbs@aslan on 2002/01/26 19:39:29
-
-	aic79xx.c:
-		Remove debugging printfs and place others inside
-		AHD_DEBUG statements.
-	aic79xx.h:
-	aic79xx_pci.c:
-		Complete support for termination current sensing.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#25 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#16 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#9 edit
-
-Change 637 by gibbs@overdrive on 2002/01/25 14:07:51
-
-	Firmware is generated in the leaf branch nodes.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#3 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#3 delete
-
-Change 626 by gibbs@overdrive on 2002/01/25 12:55:44
-
-	Remove extra blank line.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#76 edit
-
-Change 623 by gibbs@overdrive on 2002/01/25 12:48:59
-
-	Add text+ko and finish cleanup of no_probe.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_host.h#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#2 edit
-
-Change 621 by gibbs@overdrive on 2002/01/25 12:39:17
-
-	aic79xx_osm.h:
-	aic7xxx_osm.h:
-		linux/malloc.h has been deprecated in 2.4.15.  Use
-		linux/slab.h instead which has been available since 2.4.0.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#6 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#75 edit
-
-Change 615 by gibbs@overdrive on 2002/01/24 17:27:58
-
-	aic79xx_osm.c:
-		Lose references to EISA and VLB inherited from
-		aic7xxx driver.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#6 edit
-
-Change 608 by gibbs@overdrive on 2002/01/24 13:32:31
-
-	To keep IDs coherent, we'll generate these in each branch we
-	ship to customers.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#2 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#2 delete
-
-Change 603 by gibbs@overdrive on 2002/01/24 13:00:46
-
-	Add assembled aic79xx firmware to revision control.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_reg.h#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_seq.h#1 add
-
-Change 601 by gibbs@overdrive on 2002/01/24 12:57:18
-
-	Add assembled firmware to revision control.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_reg.h#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_seq.h#1 add
-
-Change 587 by gibbs@overdrive on 2002/01/23 14:36:02
-
-	aic7xxx_osm.c:
-		Integrate PROBE_VL config changes back into Linux
-		driver mainline.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#88 integrate
-
-Change 580 by gibbs@overdrive on 2002/01/22 22:13:15
-
-	Integrate from linux-aic7xxx-2.4.0 -> linux-aic79xx-2.4.0
-
-Affected files ...
-
-... //depot/linux-aic79xx-2.4.0/drivers/ide/cmd640.c#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Config.in#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7770_osm.c#2 integrate
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_osm.c#2 integrate
-
-Change 578 by gibbs@overdrive on 2002/01/22 21:48:24
-
-	aic7xxx_osm.c:
-		Protect against config not defining CONFIG_AIC7XXX_PROBE_EISA_VL
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#87 edit
-
-Change 576 by gibbs@overdrive on 2002/01/22 21:42:02
-
-	aic7770_osm.c:
-		Don't refer to aic7xxx_no_probe.  The check for
-		whether to perform EISA/VL probes was made prior
-		to the call to the EISA/VL probe.
-	
-	aic7xxx_osm.c:
-		Add a configuration option for EISA/VL probing.
-		It will default to off to avoid clobbering PCI
-		devices that frequest those I/O ranges.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#11 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#86 edit
-
-Change 575 by gibbs@overdrive on 2002/01/22 21:34:25
-
-	aic7xxx_osm.c:
-		Default to not scanning for EISA/VL adapters.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#85 edit
-
-Change 569 by gibbs@aslan on 2002/01/22 13:56:22
-
-	aic79xx.c:
-		Clean up warnings related to currently disabled code.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#24 edit
-
-Change 568 by gibbs@overdrive on 2002/01/22 13:49:27
-
-	aic79xx_osm.h:
-		Include scsi_iu.h.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#5 edit
-
-Change 567 by gibbs@aslan on 2002/01/22 13:46:00
-
-	aic79xx.c:
-		Remove call to Debugger() which is not supported
-		under Linux.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#23 edit
-
-Change 566 by gibbs@overdrive on 2002/01/22 13:43:07
-
-	Initial aic79xx port to 2.4.0.
-
-Affected files ...
-
-... //depot/linux-aic79xx-2.4.0/COPYING#1 branch
-... //depot/linux-aic79xx-2.4.0/CREDITS#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/00-INDEX#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/BUG-HUNTING#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/Changes#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/CodingStyle#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/Configure.help#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DMA-mapping.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DocBook/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DocBook/kernel-api.tmpl#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DocBook/kernel-hacking.tmpl#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DocBook/kernel-locking.tmpl#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DocBook/mcabook.tmpl#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DocBook/mousedrivers.tmpl#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DocBook/parport-multi.fig#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DocBook/parport-share.fig#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DocBook/parport-structure.fig#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DocBook/parportbook.tmpl#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DocBook/sis900.tmpl#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DocBook/via-audio.tmpl#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DocBook/videobook.tmpl#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DocBook/wanbook.tmpl#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/DocBook/z8530book.tmpl#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/IO-mapping.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/IRQ-affinity.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/LVM-HOWTO#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/README.DAC960#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/README.moxa#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/SubmittingDrivers#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/SubmittingPatches#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/VGA-softcursor.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/Netwinder#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/README#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/SA1100/Assabet#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/SA1100/Brutus#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/SA1100/CERF#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/SA1100/GraphicsClient#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/SA1100/Itsy#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/SA1100/LART#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/SA1100/PLEB#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/SA1100/Pangolin#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/SA1100/Tifon#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/SA1100/Victor#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/SA1100/empeg#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/SA1100/nanoEngine#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/SA1100/serial_UART#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/Setup#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/empeg/README#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/empeg/ir.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/empeg/mkdevs#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/nwfpe/NOTES#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/nwfpe/README#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/nwfpe/README.FPE#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/arm/nwfpe/TODO#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/binfmt_misc.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cachetlb.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cciss.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cdrom/00-INDEX#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cdrom/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cdrom/aztcd#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cdrom/cdrom-standard.tex#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cdrom/cdu31a#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cdrom/cm206#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cdrom/gscd#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cdrom/ide-cd#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cdrom/isp16#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cdrom/mcd#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cdrom/mcdx#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cdrom/optcd#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cdrom/sbpcd#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cdrom/sjcd#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cdrom/sonycd535#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/computone.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/cpqarray.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/devices.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/digiboard.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/digiepca.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/dnotify.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/exception.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/fb/00-INDEX#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/fb/aty128fb.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/fb/clgenfb.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/fb/framebuffer.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/fb/internals.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/fb/matroxfb.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/fb/modedb.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/fb/sa1100fb.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/fb/tgafb.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/fb/vesafb.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/00-INDEX#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/Locking#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/adfs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/affs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/bfs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/coda.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/cramfs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/devfs/ChangeLog#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/devfs/README#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/devfs/ToDo#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/devfs/boot-options#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/devfs/rc.devfs#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/ext2.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/fat_cvf.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/hpfs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/isofs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/ncpfs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/ntfs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/proc.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/romfs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/smbfs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/sysv-fs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/udf.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/ufs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/umsdos.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/vfat.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/filesystems/vfs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/floppy.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/ftape.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/hayes-esp.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/highuid.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/i2c/dev-interface#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/i2c/functionality#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/i2c/i2c-protocol#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/i2c/proc-interface#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/i2c/smbus-protocol#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/i2c/summary#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/i2c/ten-bit-addresses#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/i2c/writing-clients#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/i386/IO-APIC.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/i386/boot.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/i386/zero-page.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/ia64/README#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/ia64/efirtc.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/ide.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/initrd.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/ioctl-number.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isapnp.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/00-INDEX#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/CREDITS#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/HiSax.cert#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/INTERFACE#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/INTERFACE.fax#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.FAQ#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.HiSax#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.act2000#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.audio#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.avmb1#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.concap#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.diversion#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.eicon#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.fax#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.hfc-pci#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.hysdn#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.icn#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.pcbit#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.sc#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.syncppp#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/README.x25#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/isdn/syncPPP.FAQ#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/java.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/joystick-api.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/joystick-parport.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/joystick.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/kbuild/00-INDEX#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/kbuild/bug-list.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/kbuild/commands.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/kbuild/config-language.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/kbuild/makefiles.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/kernel-doc-nano-HOWTO.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/kernel-docs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/kernel-parameters.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/kmod.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/locks.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/logo.gif#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/logo.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/m68k/00-INDEX#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/m68k/README.buddha#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/m68k/kernel-options.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/magic-number.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/mandatory.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/mca.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/md.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/memory.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/mkdev.cciss#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/mkdev.ida#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/modules.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/moxa-smartio#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/mtrr.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/nbd.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/00-INDEX#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/3c505.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/6pack.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/8139too.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/Configurable#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/DLINK.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/PLIP.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/README.sb1000#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/alias.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/arcnet-hardware.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/arcnet.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/atm.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/ax25.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/baycom.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/bridge.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/comx.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/cops.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/cs89x0.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/de4x5.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/decnet.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/depca.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/dgrs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/dmfe.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/eql.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/ethertap.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/ewrk3.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/filter.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/fore200e.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/framerelay.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/ip-sysctl.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/ip_dynaddr.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/ipddp.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/iphase.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/irda.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/lapb-module.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/ltpc.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/multicast.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/ncsa-telnet#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/net-modules.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/netdevices.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/olympic.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/policy-routing.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/pt.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/ray_cs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/routing.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/shaper.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/sis900.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/sk98lin.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/skfp.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/smc9.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/smctr.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/soundmodem.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/tcp.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/tlan.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/tms380tr.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/tulip.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/tuntap.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/vortex.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/wan-router.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/wanpipe.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/wavelan.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/x25-iface.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/x25.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/networking/z8530drv.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/nfsroot.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/nmi_watchdog.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/oops-tracing.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/paride.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/parisc/00-INDEX#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/parisc/IODC.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/parisc/debugging#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/parisc/mm#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/parisc/registers#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/parport-lowlevel.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/parport.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/pci.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/pcwd-watchdog.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/pm.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/powerpc/00-INDEX#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/powerpc/SBC8260_memory_mapping.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/powerpc/ppc_htab.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/powerpc/smp.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/powerpc/sound.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/powerpc/zImage_layout.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/ramdisk.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/riscom8.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/rtc.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/s390/DASD#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/s390/cds.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/scsi-generic.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/scsi.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/serial-console.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sgi-visws.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/smart-config.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/smp.tex#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/smp.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/AD1816#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/ALS#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/AWE32#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/AudioExcelDSP16#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/CMI8330#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/CMI8338#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/CS4232#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/ChangeLog.awe#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/ChangeLog.multisound#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/ESS#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/ESS1868#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/INSTALL.awe#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/Introduction#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/MAD16#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/Maestro#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/MultiSound#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/NEWS#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/NM256#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/OPL3#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/OPL3-SA#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/OPL3-SA2#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/Opti#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/PAS16#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/PCM1-pro#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/PSS#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/PSS-updates#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/README.OSS#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/README.awe#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/README.modules#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/README.ymfsb#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/SoundPro#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/Soundblaster#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/Tropez+#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/VIA-chipset#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/VIBRA16#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/Wavefront#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/es1370#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/es1371#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/mwave#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/solo1#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/sonicvibes#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/ultrasound#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/via82cxxx.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sound/vwsnd#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sparc/sbus_drivers.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/specialix.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/spinlocks.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/stallion.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/svga.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sx.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sysctl/README#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sysctl/fs.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sysctl/kernel.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sysctl/sunrpc.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sysctl/vm.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/sysrq.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/telephony/ixj.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/unicode.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/CREDITS#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/URB.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/acm.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/bluetooth.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/dc2xx.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/error-codes.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/hotplug.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/ibmcam.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/input.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/ohci.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/ov511.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/proc_usb_info.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/rio.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/scanner-hp-sane.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/scanner.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/uhci.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/usb-help.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/usb/usb-serial.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/API.html#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/CQcam.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/README.buz#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/README.cpia#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/bttv/CARDLIST#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/bttv/CONTRIBUTORS#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/bttv/ICs#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/bttv/Insmod-options#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/bttv/MAKEDEV#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/bttv/Modules.conf#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/bttv/PROBLEMS#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/bttv/README#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/bttv/README.WINVIEW#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/bttv/Sound-FAQ#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/bttv/Specs#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/bttv/THANKS#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/radiotrack.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/video4linux/zr36120.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/vm/balance#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/vm/locking#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/vm/numa#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/watchdog.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/xterm-linux.xpm#1 branch
-... //depot/linux-aic79xx-2.4.0/Documentation/zorro.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/MAINTAINERS#1 branch
-... //depot/linux-aic79xx-2.4.0/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/README#1 branch
-... //depot/linux-aic79xx-2.4.0/REPORTING-BUGS#1 branch
-... //depot/linux-aic79xx-2.4.0/Rules.make#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/boot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/boot/bootloader.lds#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/boot/bootp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/boot/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/boot/main.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/boot/tools/mkbb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/boot/tools/objstrip.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/alpha_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/check_asm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/console.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/core_apecs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/core_cia.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/core_irongate.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/core_lca.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/core_mcpcia.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/core_polaris.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/core_t2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/core_titan.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/core_tsunami.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/core_wildfire.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/entry.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/es1888.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/irq_alpha.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/irq_i8259.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/irq_impl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/irq_pyxis.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/irq_smp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/irq_srm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/machvec_impl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/ns87312.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/osf_sys.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/pci_impl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/pci_iommu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/process.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/proto.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/ptrace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/semaphore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/smc37c669.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/smc37c93x.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/smp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_alcor.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_cabriolet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_dp264.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_eb64p.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_eiger.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_jensen.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_miata.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_mikasa.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_nautilus.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_noritake.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_rawhide.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_ruffian.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_rx164.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_sable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_sio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_sx164.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_takara.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_titan.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/sys_wildfire.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/kernel/traps.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/callback_srm.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/checksum.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/clear_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/copy_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/csum_ipv6_magic.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/csum_partial_copy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/divide.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev6-clear_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev6-copy_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev6-csum_ipv6_magic.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev6-divide.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev6-memchr.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev6-memcpy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev6-memset.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev6-strncpy_from_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev6-stxcpy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev6-stxncpy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev67-strcat.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev67-strchr.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev67-strlen.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev67-strlen_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev67-strncat.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/ev67-strrchr.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/fpreg.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/io.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/memchr.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/memcpy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/memmove.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/memset.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/srm_printk.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/srm_puts.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/stackcheck.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/stackkill.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/stacktrace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/strcasecmp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/strcat.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/strchr.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/strcpy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/strlen.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/strlen_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/strncat.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/strncpy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/strncpy_from_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/strrchr.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/stxcpy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/lib/stxncpy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/math-emu/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/math-emu/math.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/math-emu/qrnnd.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/math-emu/sfp-util.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/mm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/mm/extable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/mm/fault.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/mm/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/alpha/vmlinux.lds.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/bootp/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/bootp/bootp.lds#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/bootp/init.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/compressed/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/compressed/Makefile.debug#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/compressed/head-ftvpci.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/compressed/head-l7200.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/compressed/head-netwinder.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/compressed/head-sa1100.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/compressed/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/compressed/hw-bse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/compressed/ll_char_wr.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/compressed/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/compressed/setup-sa1100.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/compressed/vmlinux.lds.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/boot/install.sh#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/a5k#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/assabet#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/brutus#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/cerf#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/clps7500#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/ebsa110#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/empeg#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/footbridge#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/graphicsclient#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/integrator#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/lart#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/lusl7200#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/neponset#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/pangolin#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/rpc#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/shark#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/sherman#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/def-configs/victor#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/arch.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/armksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/arthur.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/bios32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/calls.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/debug-armo.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/debug-armv.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/dec21285.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/dma-arc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/dma-footbridge.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/dma-isa.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/dma-rpc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/ecard.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/entry-armo.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/entry-armv.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/entry-common.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/fiq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/ftv-pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/head-armo.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/head-armv.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/init_task.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/isa.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/leds-ebsa110.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/leds-ftvpci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/oldlatches.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/plx90x0.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/process.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/ptrace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/semaphore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/sys_arm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/time-acorn.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/traps.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/kernel/via82c505.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/backtrace.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/changebit.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/clearbit.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/copy_page.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/csumipv6.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/csumpartial.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/csumpartialcopy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/csumpartialcopyuser.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/delay.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/ecard.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/extractconstants.pl#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/findbit.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/floppydma.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/getconsdata.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/io-acorn.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/io-pcio.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/io-readsb.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/io-readsl.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/io-readsw-armv3.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/io-readsw-armv4.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/io-shark.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/io-writesb.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/io-writesl.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/io-writesw-armv3.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/io-writesw-armv4.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/io.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/memchr.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/memcpy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/memset.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/memzero.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/setbit.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/strchr.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/strncpy_from_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/strnlen_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/strrchr.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/testchangebit.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/testclearbit.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/testsetbit.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/uaccess-armo.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/lib/uaccess.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-footbridge/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-footbridge/arch.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-footbridge/cats-hw.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-footbridge/cats-pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-footbridge/ebsa285-leds.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-footbridge/ebsa285-pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-footbridge/netwinder-hw.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-footbridge/netwinder-leds.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-footbridge/netwinder-pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-footbridge/personal-pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-sa1100/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-sa1100/arch.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-sa1100/hw.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-sa1100/leds.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-shark/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-shark/arch.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-shark/dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-shark/mm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mach-shark/pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/consistent.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/extable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/fault-armo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/fault-armv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/fault-common.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/ioremap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/mm-armo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/mm-armv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/mm-clps7500.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/mm-ebsa110.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/mm-footbridge.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/mm-l7200.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/mm-nexuspci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/mm-rpc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/mm-sa1100.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/mm-tbox.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/proc-arm2,3.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/proc-arm6,7.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/proc-arm720.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/proc-arm920.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/proc-sa110.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/proc-syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/mm/small_page.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/ARM-gcc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/ChangeLog#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/config.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/double_cpdo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/entry.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/entry26.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/extended_cpdo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/fpa11.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/fpa11.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/fpa11.inl#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/fpa11_cpdo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/fpa11_cpdt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/fpa11_cprt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/fpmodule.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/fpmodule.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/fpmodule.inl#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/fpopcode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/fpopcode.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/fpsr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/milieu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/single_cpdo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/softfloat-macros#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/softfloat-specialize#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/softfloat.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/nwfpe/softfloat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/tools/gen-mach-types#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/tools/mach-types#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/vmlinux-armo.lds.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/arm/vmlinux-armv.lds.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/boot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/boot/bootsect.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/boot/compressed/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/boot/compressed/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/boot/compressed/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/boot/install.sh#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/boot/setup.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/boot/tools/build.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/boot/video.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/apic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/apm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/bluesmoke.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/cpuid.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/dmi_scan.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/entry.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/i386_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/i387.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/i8259.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/init_task.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/io_apic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/ioport.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/ldt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/mca.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/microcode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/mpparse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/msr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/mtrr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/pci-dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/pci-i386.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/pci-i386.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/pci-irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/pci-pc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/pci-visws.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/process.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/ptrace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/semaphore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/smp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/smpboot.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/sys_i386.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/trampoline.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/traps.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/visws_apic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/kernel/vm86.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/lib/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/lib/checksum.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/lib/dec_and_lock.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/lib/delay.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/lib/getuser.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/lib/iodebug.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/lib/memcpy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/lib/mmx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/lib/old-checksum.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/lib/putuser.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/lib/usercopy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/README#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/control_w.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/div_Xsig.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/div_small.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/errors.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/exception.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/fpu_arith.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/fpu_asm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/fpu_aux.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/fpu_emu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/fpu_entry.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/fpu_etc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/fpu_proto.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/fpu_system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/fpu_tags.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/fpu_trig.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/get_address.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/load_store.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/mul_Xsig.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/poly.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/poly_2xm1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/poly_atan.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/poly_l2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/poly_sin.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/poly_tan.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/polynom_Xsig.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/reg_add_sub.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/reg_compare.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/reg_constant.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/reg_constant.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/reg_convert.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/reg_divide.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/reg_ld_str.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/reg_mul.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/reg_norm.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/reg_round.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/reg_u_add.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/reg_u_div.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/reg_u_mul.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/reg_u_sub.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/round_Xsig.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/shr_Xsig.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/status_w.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/version.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/wm_shrx.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/math-emu/wm_sqrt.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/mm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/mm/extable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/mm/fault.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/mm/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/mm/ioremap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/i386/vmlinux.lds#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/boot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/boot/bootloader.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/boot/bootloader.lds#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/dig/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/dig/machvec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/dig/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/hp/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/hp/hpsim_console.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/hp/hpsim_irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/hp/hpsim_machvec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/hp/hpsim_setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/hp/hpsim_ssc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/ia32/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/ia32/binfmt_elf32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/ia32/ia32_entry.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/ia32/ia32_ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/ia32/ia32_signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/ia32/ia32_support.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/ia32/ia32_traps.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/ia32/sys_ia32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/acpi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/brl_emu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/efi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/efi_stub.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/entry.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/entry.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/fw-emu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/gate.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/ia64_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/init_task.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/iosapic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/irq_ia64.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/irq_sapic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/ivt.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/machvec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/mca.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/mca_asm.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/minstate.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/pal.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/palinfo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/perfmon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/process.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/ptrace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/sal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/semaphore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/smp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/smpboot.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/sys_ia64.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/traps.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/unaligned.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/unwind.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/unwind_decoder.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/kernel/unwind_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/checksum.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/clear_page.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/clear_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/copy_page.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/copy_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/csum_partial_copy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/do_csum.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/flush.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/idiv32.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/idiv64.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/io.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/memcpy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/memset.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/strlen.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/strlen_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/strncpy_from_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/strnlen_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/lib/swiotlb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/mm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/mm/extable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/mm/fault.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/mm/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/mm/tlb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/fprom/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/fprom/README#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/fprom/fpmem.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/fprom/fpmem.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/fprom/fprom.lds#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/fprom/fpromasm.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/fprom/fw-emu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/fprom/main.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/fprom/runsim#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/alenlist.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/cdl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/devsupport.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/eeprom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/hcl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/hcl_util.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/hubdev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/hubspc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/invent.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/io.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/ip37.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/klconflib.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/klgraph.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/klgraph_hack.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/l1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/l1_command.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/labelcl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/mem_refcnt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/ml_SN_init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/ml_SN_intr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/ml_iograph.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/module.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/pci_bus_cvlink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/pci_dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/pcibr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/pciio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/sgi_if.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/sgi_io_init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/sgi_io_sim.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/stubs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/xbow.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/xswitch.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/io/xtalk.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/sn1/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/sn1/discontig.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/sn1/iomv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/sn1/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/sn1/llsc4.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/sn1/llsc4.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/sn1/machvec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/sn1/mm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/sn1/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/sn1/smp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/sn1/sn1_asm.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/sn1/synergy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/sn/tools/make_textsym#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/tools/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/tools/print_offsets.awk#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/tools/print_offsets.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ia64/vmlinux.lds.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/amiga/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/amiga/amiga_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/amiga/amiints.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/amiga/amisound.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/amiga/chipram.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/amiga/cia.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/amiga/config.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/amiga/pcmcia.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/apollo/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/apollo/config.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/apollo/dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/apollo/dn_debug.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/apollo/dn_ints.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/atari/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/atari/ataints.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/atari/atakeyb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/atari/atari_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/atari/atasound.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/atari/atasound.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/atari/config.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/atari/debug.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/atari/hades-pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/atari/joystick.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/atari/stdma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/atari/stram.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/atari/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/bvme6000/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/bvme6000/bvmeints.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/bvme6000/config.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/bvme6000/rtc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/README#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/bindec.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/binstr.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/bugfix.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/decbin.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/do_func.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/fpsp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/gen_except.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/get_op.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/kernel_ex.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/res_func.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/round.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/sacos.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/sasin.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/satan.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/satanh.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/scale.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/scosh.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/setox.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/sgetem.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/sint.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/skeleton.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/slog2.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/slogn.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/smovecr.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/srem_mod.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/ssin.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/ssinh.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/stan.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/stanh.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/sto_res.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/stwotox.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/tbldo.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/util.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/x_bsun.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/x_fline.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/x_operr.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/x_ovfl.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/x_snan.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/x_store.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/x_unfl.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/x_unimp.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/fpsp040/x_unsupp.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/hp300/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/hp300/README.hp300#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/hp300/config.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/hp300/hil.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/hp300/hp300map.map#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/hp300/ints.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/hp300/ints.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/hp300/ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/hp300/reboot.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/hp300/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/hp300/time.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/CHANGES#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/MISC#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/README#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/TEST.DOC#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/fplsp.doc#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/fplsp.sa#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/fpsp.doc#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/fpsp.sa#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/fskeleton.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/ftest.sa#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/ilsp.doc#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/ilsp.sa#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/iskeleton.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/isp.doc#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/isp.sa#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/itest.sa#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/os.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/pfpsp.sa#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/src/README-SRC#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/src/fplsp.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/src/fpsp.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/src/ftest.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/src/ilsp.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/src/isp.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/src/itest.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/ifpsp060/src/pfpsp.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/bios32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/entry.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/ints.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/m68k_defs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/m68k_defs.head#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/m68k_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/process.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/ptrace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/semaphore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/sun3-head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/sys_m68k.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/kernel/traps.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/lib/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/lib/ashldi3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/lib/ashrdi3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/lib/checksum.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/lib/lshrdi3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/lib/memcmp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/lib/memcpy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/lib/memset.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/lib/muldi3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/lib/semaphore.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mac/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mac/baboon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mac/bootparse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mac/config.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mac/debug.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mac/iop.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mac/mac_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mac/mac_penguin.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mac/macboing.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mac/macints.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mac/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mac/oss.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mac/psc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mac/via.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/math-emu/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/math-emu/fp_arith.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/math-emu/fp_arith.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/math-emu/fp_cond.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/math-emu/fp_decode.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/math-emu/fp_emu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/math-emu/fp_entry.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/math-emu/fp_log.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/math-emu/fp_move.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/math-emu/fp_movem.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/math-emu/fp_scan.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/math-emu/fp_trig.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/math-emu/fp_trig.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/math-emu/fp_util.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/math-emu/multi_arith.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mm/extable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mm/fault.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mm/hwtest.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mm/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mm/kmap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mm/memory.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mm/motorola.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mm/sun3mmu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mvme147/147ints.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mvme147/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mvme147/config.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mvme16x/16xints.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mvme16x/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mvme16x/config.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mvme16x/mvme16x_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/mvme16x/rtc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/q40/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/q40/README#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/q40/config.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/q40/q40ints.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3/config.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3/dvma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3/idprom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3/intersil.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3/leds.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3/mmu_emu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3/prom/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3/prom/console.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3/prom/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3/prom/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3/prom/printf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3/sbus.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3/sun3_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3/sun3ints.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3x/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3x/config.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3x/dvma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3x/sbus.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3x/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/sun3x/time.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/tools/amiga/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/tools/amiga/dmesg.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/vmlinux-sun3.lds#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/m68k/vmlinux.lds#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/.gdbinit#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/algor/README#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/arc/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/arc/cmdline.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/arc/console.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/arc/env.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/arc/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/arc/identify.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/arc/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/arc/memory.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/arc/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/arc/printf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/arc/salone.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/arc/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/arc/tree.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/baget/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/baget/baget.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/baget/bagetIRQ.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/baget/balo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/baget/balo_supp.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/baget/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/baget/ld.script.balo#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/baget/print.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/baget/prom/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/baget/prom/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/baget/reset.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/baget/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/baget/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/baget/vacserial.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/baget/wbflush.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/boot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/boot/addinitrd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/boot/ecoff.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/boot/elf2ecoff.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/boot/mkboot.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/cobalt/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/cobalt/cobaltscc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/cobalt/diagdefs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/cobalt/hw-access.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/cobalt/int-handler.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/cobalt/pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/cobalt/reset.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/cobalt/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/cobalt/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/cobalt/via.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/cobalt/z8530.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/ddb5074/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/ddb5074/int-handler.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/ddb5074/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/ddb5074/nile4.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/ddb5074/pci-dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/ddb5074/pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/ddb5074/prom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/ddb5074/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/ddb5074/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/boot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/boot/decstation.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/boot/ld.ecoff#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/int-handler.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/prom/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/prom/cmdline.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/prom/dectypes.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/prom/identify.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/prom/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/prom/locore.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/prom/memory.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/prom/prom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/promcon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/reset.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/rtc-dec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/serial.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/dec/wbflush.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/defconfig-cobalt#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/defconfig-decstation#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/defconfig-ip22#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/defconfig-orion#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/defconfig-rm200#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/jazz/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/jazz/floppy-jazz.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/jazz/int-handler.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/jazz/io.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/jazz/jazzdma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/jazz/kbd-jazz.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/jazz/reset.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/jazz/rtc-jazz.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/jazz/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/branch.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/entry.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/fpe.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/gdb-low.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/gdb-stub.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/init_task.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/ioport.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/ipc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/irix5sys.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/irixelf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/irixinv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/irixioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/irixsig.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/mips_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/process.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/ptrace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/r2300_fpu.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/r2300_misc.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/r2300_switch.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/r4k_fpu.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/r4k_misc.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/r4k_switch.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/r6000_fpu.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/reset.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/scall_o32.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/semaphore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/softfp.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/syscall.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/syscalls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/sysirix.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/sysmips.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/traps.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/unaligned.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/kernel/vm86.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/ld.script.big#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/ld.script.little#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/csum_partial.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/csum_partial_copy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/dump_tlb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/floppy-no.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/floppy-std.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/ide-no.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/ide-std.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/kbd-no.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/kbd-std.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/memcpy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/memset.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/r3k_dump_tlb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/rtc-no.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/rtc-std.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/strlen_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/strncpy_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/strnlen_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/tinycon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/lib/watch.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/mm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/mm/andes.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/mm/extable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/mm/fault.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/mm/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/mm/loadmmu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/mm/r2300.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/mm/r4xx0.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/mm/umap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/orion/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/orion/int-handler.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/orion/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/orion/ld.script.orion#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/orion/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/orion/no_initrd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/orion/piggyback.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/orion/promcon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/orion/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sgi/kernel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sgi/kernel/indyIRQ.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sgi/kernel/indy_hpc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sgi/kernel/indy_int.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sgi/kernel/indy_mc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sgi/kernel/indy_rtc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sgi/kernel/indy_sc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sgi/kernel/indy_timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sgi/kernel/promcon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sgi/kernel/reset.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sgi/kernel/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sgi/kernel/system.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sgi/kernel/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sni/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sni/dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sni/int-handler.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sni/io.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sni/pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sni/pcimt_scache.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sni/reset.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/sni/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/tools/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips/tools/offset.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/arc/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/arc/cmdline.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/arc/console.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/arc/env.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/arc/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/arc/identify.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/arc/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/arc/memory.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/arc/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/arc/printf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/arc/salone.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/arc/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/arc/tree.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/boot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/defconfig-ip22#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/defconfig-ip27#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/binfmt_elf32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/branch.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/entry.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/init_task.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/ioctl32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/linux32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/mips64_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/process.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/ptrace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/r4k_cache.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/r4k_fpu.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/r4k_genex.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/r4k_switch.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/r4k_tlb.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/r4k_tlb_debug.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/r4k_tlb_glue.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/scall_64.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/scall_o32.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/semaphore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/signal32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/smp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/softfp.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/syscall.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/traps.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/kernel/unaligned.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/ld.script.elf32.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/ld.script.elf64#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/csum_partial.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/csum_partial_copy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/dump_tlb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/floppy-no.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/floppy-std.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/ide-no.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/ide-std.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/kbd-no.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/kbd-std.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/memcpy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/memset.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/rtc-no.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/rtc-std.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/strlen_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/strncpy_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/strnlen_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/lib/watch.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/mm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/mm/andes.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/mm/extable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/mm/fault.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/mm/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/mm/loadmmu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/mm/r4xx0.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/mm/umap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip22/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip22/ip22-berr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip22/ip22-hpc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip22/ip22-int.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip22/ip22-irq.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip22/ip22-mc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip22/ip22-reset.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip22/ip22-rtc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip22/ip22-sc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip22/ip22-setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip22/ip22-timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip22/system.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip22/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/TODO#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/ip27-berr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/ip27-console.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/ip27-init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/ip27-irq-glue.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/ip27-irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/ip27-klconfig.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/ip27-klnuma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/ip27-memory.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/ip27-nmi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/ip27-pci-dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/ip27-pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/ip27-reset.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/ip27-rtc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/ip27-setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/sgi-ip27/ip27-timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/tools/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/mips64/tools/offset.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/hpux/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/hpux/entry_hpux.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/hpux/fs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/hpux/gate.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/hpux/ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/hpux/sys_hpux.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/hpux/wrappers.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/cache.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/ccio-dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/ccio-rm-dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/drivers.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/entry.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/hardware.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/hpmc.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/init_task.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/inventory.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/iosapic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/iosapic_private.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/keyboard.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/lasimap.map#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/lba_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/led.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/pa7300lc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/parisc_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/pci-dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/pdc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/pdc_cons.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/process.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/ptrace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/real1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/real2.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/sba_iommu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/semaphore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/sys_parisc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/syscall.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/kernel/traps.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/lib/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/lib/bitops.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/lib/checksum.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/lib/lusercopy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/mm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/mm/extable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/mm/fault.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/mm/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/mm/kmap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/mm/pa11.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/mm/pa20.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/tools/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/tools/offset.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/parisc/vmlinux.lds#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/8260_io/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/8260_io/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/8260_io/commproc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/8260_io/enet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/8260_io/fcc_enet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/8260_io/uart.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/8xx_io/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/8xx_io/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/8xx_io/commproc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/8xx_io/commproc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/8xx_io/enet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/8xx_io/fec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/8xx_io/uart.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/amiga/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/amiga/amiga_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/amiga/amiints.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/amiga/amisound.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/amiga/bootinfo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/amiga/chipram.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/amiga/cia.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/amiga/config.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/amiga/ints.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/amiga/pcmcia.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/amiga/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/boot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/boot/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/boot/iso_font.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/boot/kbd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/boot/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/boot/mkprep.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/boot/ns16550.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/boot/ns16550.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/boot/of1275.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/boot/of1275.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/boot/offset#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/boot/size#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/boot/vreset.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/chrpboot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/chrpboot/addnote.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/chrpboot/crt0.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/chrpboot/main.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/chrpboot/misc.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/chrpboot/mknote.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/chrpboot/no_initrd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/chrpboot/piggyback.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/chrpboot/start.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/chrpmain.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/coffcrt0.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/coffmain.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/crt0.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/dummy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/hack-coff.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/ld.script#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/main.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/misc.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/mknote.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/no_initrd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/nonstdio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/piggyback.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/rs6000.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/start.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/string.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/zlib.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/coffboot/zlib.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/configs/apus_defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/configs/bseip_defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/configs/common_defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/configs/est8260_defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/configs/gemini_defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/configs/mbx_defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/configs/oak_defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/configs/rpxcllf_defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/configs/rpxlite_defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/configs/walnut_defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/align.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/apus_setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/bitops.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/checks.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/chrp_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/chrp_setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/chrp_time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/entry.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/feature.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/find_name.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/galaxy_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/gemini_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/gemini_prom.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/gemini_setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/hashtable.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/head_4xx.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/head_8xx.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/i8259.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/i8259.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/idle.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/indirect_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/local_irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/m8260_setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/m8xx_setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/misc.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/mk_defs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/mol.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/oak_setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/oak_setup.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/open_pic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/open_pic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/pci-dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/pmac_backlight.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/pmac_nvram.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/pmac_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/pmac_pic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/pmac_pic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/pmac_setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/pmac_time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/ppc-stub.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/ppc4xx_pic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/ppc4xx_pic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/ppc8260_pic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/ppc8260_pic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/ppc8xx_pic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/ppc8xx_pic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/ppc_asm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/ppc_asm.tmpl#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/ppc_defs.head#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/ppc_htab.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/ppc_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/prep_nvram.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/prep_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/prep_setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/prep_time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/process.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/prom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/ptrace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/qspan_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/residual.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/semaphore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/sleep.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/smp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/softemu8xx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/syscalls.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/traps.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/walnut_setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/walnut_setup.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/xics.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/kernel/xics.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/lib/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/lib/checksum.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/lib/locks.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/lib/strcase.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/lib/string.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/double.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fabs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fadd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fadds.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fcmpo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fcmpu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fctiw.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fctiwz.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fdiv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fdivs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fmadd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fmadds.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fmr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fmsub.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fmsubs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fmul.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fmuls.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fnabs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fneg.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fnmadd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fnmadds.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fnmsub.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fnmsubs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fres.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/frsp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/frsqrte.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fsel.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fsqrt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fsqrts.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fsub.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/fsubs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/lfd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/lfs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/math.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/mcrfs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/mffs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/mtfsb0.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/mtfsb1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/mtfsf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/mtfsfi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/op-1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/op-2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/op-4.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/op-common.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/sfp-machine.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/single.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/soft-fp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/stfd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/stfiwx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/stfs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/types.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/math-emu/udivmodti4.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mbxboot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mbxboot/embed_config.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mbxboot/gzimage.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mbxboot/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mbxboot/head_8260.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mbxboot/iic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mbxboot/m8260_tty.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mbxboot/m8xx_tty.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mbxboot/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mbxboot/offset#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mbxboot/pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mbxboot/qspan_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mbxboot/rdimage.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mbxboot/size#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mbxboot/vmlinux.lds#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mm/4xx_tlb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mm/4xx_tlb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mm/extable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mm/fault.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mm/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mm/mem_pieces.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/mm/mem_pieces.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/treeboot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/treeboot/crt0.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/treeboot/elf.pl#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/treeboot/irSect.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/treeboot/irSect.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/treeboot/ld.script#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/treeboot/main.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/treeboot/misc.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/treeboot/mkevimg#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/treeboot/mkirimg#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/vmlinux.lds#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/xmon/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/xmon/adb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/xmon/ansidecl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/xmon/nonstdio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/xmon/ppc-dis.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/xmon/ppc-opc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/xmon/ppc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/xmon/privinst.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/xmon/setjmp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/xmon/start.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/xmon/start_8xx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/xmon/subr_prf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/ppc/xmon/xmon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/boot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/boot/ipldump.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/boot/ipleckd.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/boot/iplfba.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/bitmap.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/cpcmd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/cpcmd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/ebcdic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/entry.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/floatlib.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/gdb-stub.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/ieee.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/init_task.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/irqextras390.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/lowcore.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/mathemu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/process.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/ptrace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/reipl.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/s390_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/s390dyn.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/s390fpu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/s390io.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/s390mach.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/semaphore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/smp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/sys_s390.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/kernel/traps.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/lib/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/lib/checksum.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/lib/delay.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/lib/memset.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/lib/strcmp.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/lib/strncpy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/mm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/mm/extable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/mm/fault.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/mm/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/mm/ioremap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/tools/dasdfmt/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/tools/dasdfmt/dasdfmt.8#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/tools/dasdfmt/dasdfmt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/tools/silo/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/tools/silo/cfg.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/tools/silo/cfg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/tools/silo/silo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/tools/silo/silo.conf#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/s390/vmlinux.lds#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/boot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/boot/compressed/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/boot/compressed/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/boot/compressed/install.sh#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/boot/compressed/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/cf-enabler.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/entry.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/fpu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/init_task.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/io.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/io_generic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/io_hd64461.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/io_se.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/io_unknown.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/irq_imask.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/irq_ipr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/led_se.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/mach_hp600.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/mach_se.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/mach_unknown.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/pci-sh.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/process.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/ptrace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/rtc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/semaphore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/setup_cqreek.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/setup_hd64461.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/setup_od.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/setup_se.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/sh_bios.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/sh_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/sys_sh.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/kernel/traps.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/lib/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/lib/checksum.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/lib/delay.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/lib/memchr.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/lib/memcpy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/lib/memmove.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/lib/memset.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/lib/old-checksum.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/lib/strcasecmp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/mm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/mm/cache.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/mm/extable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/mm/fault.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/mm/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/mm/ioremap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sh/vmlinux.lds.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/boot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/boot/btfixupprep.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/boot/piggyback.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/auxio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/check_asm.sh#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/cpu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/devices.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/ebus.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/entry.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/errtbls.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/etrap.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/idprom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/init_task.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/ioport.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/muldiv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/pcic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/process.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/ptrace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/rtrap.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/sclow.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/semaphore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/smp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/sparc-stub.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/sparc_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/sun4c_irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/sun4d_irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/sun4d_smp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/sun4m_irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/sun4m_smp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/sun4setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/sunos_asm.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/sunos_ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/sys_solaris.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/sys_sparc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/sys_sunos.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/systbls.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/tadpole.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/tick14.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/trampoline.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/traps.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/unaligned.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/windows.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/wof.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/kernel/wuf.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/COPYING.LIB#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/ashldi3.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/ashrdi3.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/atomic.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/bitops.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/blockops.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/checksum.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/copy_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/debuglocks.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/divdi3.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/locks.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/lshrdi3.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/memcmp.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/memcpy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/memscan.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/memset.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/mul.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/muldi3.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/rem.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/rwsem.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/sdiv.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/strlen.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/strlen_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/strncmp.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/strncpy_from_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/udiv.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/udivdi3.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/umul.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/lib/urem.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/math-emu/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/math-emu/ashldi3.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/math-emu/math.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/math-emu/sfp-util.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/btfixup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/extable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/fault.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/generic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/hypersparc.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/io-unit.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/iommu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/loadmmu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/nosrmmu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/nosun4c.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/srmmu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/sun4c.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/swift.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/tsunami.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/mm/viking.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/prom/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/prom/bootstr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/prom/console.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/prom/devmap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/prom/devops.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/prom/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/prom/memory.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/prom/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/prom/mp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/prom/palloc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/prom/printf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/prom/ranges.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/prom/segment.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/prom/sun4prom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/prom/tree.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc/vmlinux.lds#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/boot/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/boot/piggyback.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/defconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/auxio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/binfmt_aout32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/binfmt_elf32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/central.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/check_asm.sh#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/cpu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/devices.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/dtlb_backend.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/dtlb_base.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/dtlb_prot.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/ebus.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/entry.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/etrap.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/head.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/idprom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/init_task.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/ioctl32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/iommu_common.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/iommu_common.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/itlb_base.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/pci_common.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/pci_impl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/pci_iommu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/pci_psycho.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/pci_sabre.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/power.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/process.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/ptrace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/rtrap.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/sbus.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/semaphore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/signal32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/smp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/sparc64_ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/starfire.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/sunos_ioctl32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/sys32.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/sys_sparc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/sys_sparc32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/sys_sunos32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/systbls.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/trampoline.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/traps.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/ttable.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/unaligned.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/kernel/winfixup.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/PeeCeeI.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/U3copy_from_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/U3copy_in_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/U3copy_to_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/U3memcpy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/VIS.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/VISbzero.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/VIScopy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/VIScsum.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/VIScsumcopy.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/VIScsumcopyusr.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/VISmemset.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/VISsave.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/atomic.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/bitops.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/blockops.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/checksum.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/debuglocks.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/dec_and_lock.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/memcmp.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/memscan.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/rwlock.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/strlen.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/strlen_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/strncmp.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/lib/strncpy_from_user.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/math-emu/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/math-emu/math.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/math-emu/sfp-util.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/mm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/mm/extable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/mm/fault.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/mm/generic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/mm/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/mm/modutil.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/mm/ultra.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/prom/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/prom/bootstr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/prom/console.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/prom/devops.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/prom/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/prom/map.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/prom/memory.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/prom/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/prom/p1275.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/prom/printf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/prom/tree.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/solaris/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/solaris/conv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/solaris/entry64.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/solaris/fs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/solaris/ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/solaris/ipc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/solaris/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/solaris/signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/solaris/signal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/solaris/socket.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/solaris/socksys.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/solaris/socksys.h#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/solaris/systbl.S#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/solaris/timod.c#1 branch
-... //depot/linux-aic79xx-2.4.0/arch/sparc64/vmlinux.lds#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/README#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/block/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/block/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/block/fd1772.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/block/fd1772dma.S#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/block/mfm.S#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/block/mfmhd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/char/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/char/defkeymap-acorn.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/char/i2c.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/char/keyb_arc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/char/keyb_ps2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/char/mouse_rpc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/char/pcf8583.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/char/pcf8583.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/char/serial-atomwide.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/char/serial-card.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/char/serial-dualsp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/net/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/net/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/net/ether1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/net/ether1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/net/ether3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/net/ether3.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/net/etherh.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/acornscsi-io.S#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/acornscsi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/acornscsi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/arxescsi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/arxescsi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/cumana_1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/cumana_1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/cumana_2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/cumana_2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/ecoscsi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/ecoscsi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/eesox.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/eesox.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/fas216.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/fas216.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/msgqueue.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/msgqueue.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/oak.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/oak.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/powertec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/powertec.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/queue.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acorn/scsi/queue.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/cmbatt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/common/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/common/cmalloc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/common/cmclib.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/common/cmcopy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/common/cmdebug.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/common/cmdelete.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/common/cmeval.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/common/cmglobal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/common/cminit.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/common/cmobject.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/common/cmutils.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/common/cmxface.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/cpu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/dispatcher/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/dispatcher/dsfield.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/dispatcher/dsmethod.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/dispatcher/dsmthdat.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/dispatcher/dsobject.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/dispatcher/dsopcode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/dispatcher/dsutils.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/dispatcher/dswexec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/dispatcher/dswload.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/dispatcher/dswscope.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/dispatcher/dswstate.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/driver.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/driver.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/ec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/ec.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/events/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/events/evevent.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/events/evmisc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/events/evregion.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/events/evrgnini.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/events/evsci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/events/evxface.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/events/evxfevnt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/events/evxfregn.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/hardware/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/hardware/hwacpi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/hardware/hwcpu32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/hardware/hwgpe.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/hardware/hwregs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/hardware/hwxface.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/accommon.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acconfig.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acdebug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acdispat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acenv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acevents.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acexcep.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acgcc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acglobal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/achware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acinterp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/aclinux.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/aclocal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acmacros.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acnamesp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acobject.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acoutput.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acparser.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acpi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acpiosxf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acpixf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/acresrc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/actables.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/actbl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/actbl1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/actbl2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/actbl71.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/actypes.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/include/amlcode.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amconfig.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amcreate.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amdyadic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amfield.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amfldio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/ammisc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/ammonad.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amnames.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amprep.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amregion.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amresnte.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amresolv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amresop.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amstore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amstoren.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amstorob.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amsystem.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amutils.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/interpreter/amxface.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/namespace/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/namespace/nsaccess.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/namespace/nsalloc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/namespace/nseval.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/namespace/nsinit.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/namespace/nsload.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/namespace/nsnames.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/namespace/nsobject.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/namespace/nssearch.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/namespace/nsutils.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/namespace/nswalk.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/namespace/nsxfname.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/namespace/nsxfobj.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/os.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/parser/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/parser/psargs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/parser/psopcode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/parser/psparse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/parser/psscope.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/parser/pstree.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/parser/psutils.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/parser/pswalk.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/parser/psxface.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/power.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/resources/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/resources/rsaddr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/resources/rscalc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/resources/rscreate.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/resources/rsdump.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/resources/rsio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/resources/rsirq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/resources/rslist.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/resources/rsmemory.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/resources/rsmisc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/resources/rsutils.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/resources/rsxface.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/sys.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/table.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/tables/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/tables/tbconvrt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/tables/tbget.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/tables/tbinstal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/tables/tbutils.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/tables/tbxface.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/acpi/tables/tbxfroot.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/ambassador.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/ambassador.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/atmdev_init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/atmsar11.data#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/atmsar11.regions#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/atmsar11.start#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/atmtcp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/eni.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/eni.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/firestream.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/firestream.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/fore200e.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/fore200e.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/fore200e_firmware_copyright#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/fore200e_mkfirm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/horizon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/horizon.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/idt77105.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/idt77105.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/iphase.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/iphase.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/midway.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/nicstar.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/nicstar.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/nicstarmac.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/nicstarmac.copyright#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/nicstarmac.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/pca200e.data#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/pca200e_ecd.data#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/sba200e_ecd.data#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/suni.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/suni.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/tonga.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/uPD98401.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/uPD98402.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/uPD98402.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/zatm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/zatm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/atm/zeprom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/DAC960.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/DAC960.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/acsi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/acsi_slm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/amiflop.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/ataflop.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/blkpg.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/cciss.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/cciss.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/cciss_cmd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/cpqarray.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/cpqarray.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/elevator.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/floppy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/genhd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/ida_cmd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/ida_ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/ll_rw_blk.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/loop.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/nbd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/aten.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/bpck.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/comm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/dstr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/epat.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/epia.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/fit2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/fit3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/friq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/frpw.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/jumbo#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/kbic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/ktti.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/mkd#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/on20.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/on26.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/paride.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/paride.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/pcd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/pd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/pf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/pg.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/pseudo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/pt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/paride/setup.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/ps2esdi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/rd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/smart1,2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/swim3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/swim_iop.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/xd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/xd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/block/z2ram.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/aztcd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/aztcd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/cdrom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/cdu31a.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/cdu31a.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/cm206.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/cm206.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/gscd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/gscd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/isp16.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/isp16.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/mcd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/mcd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/mcdx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/mcdx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/optcd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/optcd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/sbpcd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/sbpcd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/sbpcd2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/sbpcd3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/sbpcd4.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/sjcd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/sjcd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/sonycd535.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/cdrom/sonycd535.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ChangeLog#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/README.computone#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/README.cycladesZ#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/README.cyclomY#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/README.epca#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/README.scc#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/acquirewdt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/adbmouse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/agp/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/agp/agp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/agp/agpgart_be.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/agp/agpgart_fe.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/amigamouse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/amikeyb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/amiserial.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/applicom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/applicom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/atarimouse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/atixlmouse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/busmouse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/busmouse.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/cd1865.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/conmakehash.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/console.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/console_macros.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/consolemap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/cp437.uni#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/cyclades.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/defkeymap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/defkeymap.map#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/digi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/digi1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/digiFep1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/digiPCI.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/digi_bios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/digi_fep.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/dn_keyb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/README.drm#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/agpsupport.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/auth.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/bufs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/context.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/ctxbitmap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/drawable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/drm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/drmP.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/ffb_context.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/ffb_drv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/ffb_drv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/fops.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/gamma_dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/gamma_drv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/gamma_drv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/i810_bufs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/i810_context.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/i810_dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/i810_drm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/i810_drv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/i810_drv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/lists.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/lock.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/memory.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/mga_bufs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/mga_context.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/mga_dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/mga_drm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/mga_drv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/mga_drv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/mga_state.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/r128_bufs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/r128_cce.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/r128_context.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/r128_drm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/r128_drv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/r128_drv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/r128_state.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/tdfx_context.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/tdfx_drv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/tdfx_drv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/drm/vm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ds1620.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/dsp56k.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/dtlk.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/dz.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/dz.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/efirtc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/epca.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/epca.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/epcaconfig.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/esp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/fep.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/README.PCI#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/RELEASE-NOTES#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/compressor/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/compressor/lzrw3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/compressor/lzrw3.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/compressor/zftape-compress.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/compressor/zftape-compress.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/fc-10.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/fc-10.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/fdc-io.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/fdc-io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/fdc-isr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/fdc-isr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-bsm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-bsm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-buffer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-buffer.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-calibr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-calibr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-ctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-ctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-ecc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-ecc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-format.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-format.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-init.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-io.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-proc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-read.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-read.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-rw.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-rw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-tracing.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-tracing.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-write.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape-write.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/lowlevel/ftape_syms.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-buffers.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-buffers.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-ctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-ctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-eof.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-eof.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-init.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-read.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-read.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-rw.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-rw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-vtbl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-vtbl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-write.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape-write.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ftape/zftape/zftape_syms.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/generic_serial.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/h8.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/h8.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/hp600_keyb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/i810-tco.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/i810-tco.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/i810_rng.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/fip_firm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/i2cmd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/i2cmd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/i2ellis.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/i2ellis.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/i2hw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/i2lib.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/i2lib.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/i2os.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/i2pack.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/ip2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/ip2ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/ip2mkdev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/ip2stat.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/ip2trace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/ip2trace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2/ip2types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ip2main.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/isicom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/istallion.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/a3d.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/adi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/amijoy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/analog.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/cobra.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/db9.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/gamecon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/gameport.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/gf2k.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/grip.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/iforce.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/interact.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/lightning.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/magellan.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/ns558.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/pcigame.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/serio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/serport.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/sidewinder.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/spaceball.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/spaceorb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/tmdc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/turbografx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/joystick/warrior.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/keyboard.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/logibusmouse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/lp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/mem.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/mixcomwd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/moxa.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/msbusmouse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/mxser.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/n_hdlc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/n_r3964.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/n_tty.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/nvram.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/nwbutton.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/nwbutton.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/nwflash.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/pc110pad.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/pc110pad.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/pc_keyb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/pcmcia/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/pcmcia/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/pcmcia/serial_cb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/pcmcia/serial_cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/pcwd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/pcxx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/pcxx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/ppdev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/pty.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/q40_keyb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/qpmouse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/random.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/raw.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/board.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/bootpkt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/brates.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/cdproto.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/chan.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/cirrus.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/cmd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/cmdblk.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/cmdpkt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/control.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/daemon.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/data.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/debug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/defaults.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/eisa.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/enable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/error.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/errors.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/formpkt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/func.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/host.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/hosthw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/link.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/linux_compat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/list.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/lrt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/ltt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/lttwake.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/map.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/mca.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/mesg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/parmmap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/phb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/pkt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/poll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/port.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/proto.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/protsts.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/qbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/rio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/rio_linux.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/rio_linux.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/rioboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/rioboot.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/riocmd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/rioctrl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/riodrvr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/rioinfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/rioinit.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/riointr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/rioioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/riolocks.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/rioparam.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/riopcicopy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/rioroute.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/riospace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/riotable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/riotime.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/riotty.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/riotypes.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/riowinif.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/riscos.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/rom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/route.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/rtahw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/rup.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/rupstat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/sam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/selftest.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/space.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/sysmap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/timeouts.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/top.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/typdef.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rio/unixrup.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/riscom8.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/riscom8.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/riscom8_reg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rocket.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rocket_int.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rsf16fmi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/rtc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/sbc60xxwdt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/scan_keyb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/scan_keyb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/scc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/selection.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/serial.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/serial167.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/serial_21285.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/serial_amba.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/sh-sci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/sh-sci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/softdog.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/specialix.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/specialix_io8.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/stallion.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/sx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/sx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/sxboards.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/sxwindow.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/synclink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/sysrq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/toshiba.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/tpqic02.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/tty_io.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/tty_ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/vc_screen.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/vino.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/vme_scc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/vt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/wd501p.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/wdt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/wdt285.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/wdt977.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/char/wdt_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/dio/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/dio/dio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/fc4/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/fc4/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/fc4/fc-al.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/fc4/fc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/fc4/fc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/fc4/fc_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/fc4/fcp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/fc4/fcp_impl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/fc4/soc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/fc4/soc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/fc4/socal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/fc4/socal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2c/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2c/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2c/i2c-algo-bit.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2c/i2c-algo-pcf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2c/i2c-core.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2c/i2c-dev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2c/i2c-elektor.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2c/i2c-elv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2c/i2c-pcf8584.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2c/i2c-philips-par.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2c/i2c-velleman.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2o/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2o/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2o/README#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2o/README.ioctl#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2o/i2o_block.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2o/i2o_config.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2o/i2o_core.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2o/i2o_lan.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2o/i2o_lan.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2o/i2o_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2o/i2o_proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2o/i2o_scsi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/i2o/i2o_scsi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/aec62xx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ali14xx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/alim15x3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/amd7409.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/buddha.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/cmd640.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/cmd64x.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/cs5530.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/cy82c693.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/dtc2278.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/falconide.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/gayle.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/hd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/hpt34x.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/hpt366.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ht6560b.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/icside.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide-cd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide-cd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide-cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide-disk.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide-dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide-features.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide-floppy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide-geometry.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide-pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide-pmac.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide-pnp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide-probe.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide-proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide-tape.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ide_modes.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/macide.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/ns87415.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/opti621.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/osb4.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/pdc202xx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/pdc4030.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/pdc4030.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/piix.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/q40ide.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/qd6580.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/rapide.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/rz1000.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/sis5513.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/sl82c105.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/slc90e66.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/trm290.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/umc8672.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ide/via82cxxx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/aic5800.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/aic5800.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/csr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/csr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/guid.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/guid.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/highlevel.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/highlevel.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/hosts.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/hosts.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/ieee1394.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/ieee1394_core.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/ieee1394_core.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/ieee1394_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/ieee1394_transactions.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/ieee1394_transactions.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/ieee1394_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/ohci1394.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/ohci1394.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/pcilynx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/pcilynx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/raw1394.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/raw1394.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/video1394.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/ieee1394/video1394.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/input/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/input/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/input/evdev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/input/input.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/input/joydev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/input/keybdev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/input/mousedev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/act2000/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/act2000/act2000.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/act2000/act2000_isa.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/act2000/act2000_isa.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/act2000/capi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/act2000/capi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/act2000/module.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/avm_cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/avmcard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/b1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/b1dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/b1isa.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/b1pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/b1pcmcia.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/c4.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/capi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/capicmd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/capidev.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/capidrv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/capidrv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/capifs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/capifs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/capilli.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/capiutil.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/capiutil.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/kcapi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/t1isa.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/avmb1/t1pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/divert/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/divert/divert_init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/divert/divert_procfs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/divert/isdn_divert.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/divert/isdn_divert.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/Divas_mod.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/adapter.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/bri.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/common.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/constant.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/divalog.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/divas.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/dsp_defs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/dspdids.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/eicon.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/eicon_dsp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/eicon_idi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/eicon_idi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/eicon_io.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/eicon_isa.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/eicon_isa.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/eicon_mod.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/eicon_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/eicon_pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/fcheck.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/fourbri.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/fpga.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/idi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/idi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/kprintf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/lincfg.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/linchr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/linio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/linsys.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/log.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/md5sums.asc#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/pc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/pc_maint.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/pr_pc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/pri.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/sys.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/uxio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/eicon/xlog.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/amd7930.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/arcofi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/arcofi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/asuscom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/avm_a1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/avm_a1p.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/avm_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/bkm_a4t.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/bkm_a8.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/bkm_ax.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/callc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/cert.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/config.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/diva.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/elsa.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/elsa_ser.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/fsm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/gazel.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/hfc_2bds0.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/hfc_2bds0.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/hfc_2bs0.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/hfc_2bs0.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/hfc_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/hfc_pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/hfc_sx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/hfc_sx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/hfcscard.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/hisax.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/hscx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/hscx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/hscx_irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/icc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/icc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/ipac.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/isac.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/isac.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/isar.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/isar.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/isdnl1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/isdnl1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/isdnl2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/isdnl2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/isdnl3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/isdnl3.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/isurf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/ix1_micro.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/jade.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/jade.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/jade_irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/l3_1tr6.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/l3_1tr6.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/l3dss1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/l3dss1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/l3ni1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/l3ni1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/lmgr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/md5sums.asc#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/mic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/netjet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/netjet.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/niccy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/nj_s.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/nj_u.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/q931.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/rawhdlc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/rawhdlc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/s0box.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/saphir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/sedlbauer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/sportster.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/tei.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/teleint.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/teles0.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/teles3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/telespci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/w6692.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hisax/w6692.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hysdn/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hysdn/boardergo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hysdn/boardergo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hysdn/hycapi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hysdn/hysdn_boot.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hysdn/hysdn_defs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hysdn/hysdn_init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hysdn/hysdn_net.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hysdn/hysdn_pof.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hysdn/hysdn_procconf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hysdn/hysdn_procfs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hysdn/hysdn_proclog.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hysdn/hysdn_sched.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/hysdn/ince1pc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/icn/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/icn/icn.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/icn/icn.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_audio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_audio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_bsdcomp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_cards.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_cards.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_common.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_common.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_concap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_concap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_net.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_net.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_ppp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_ppp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_tty.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_tty.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_ttyfax.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_ttyfax.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_v110.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_v110.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_x25iface.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdn_x25iface.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdnloop/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdnloop/isdnloop.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/isdnloop/isdnloop.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/pcbit/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/pcbit/callbacks.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/pcbit/callbacks.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/pcbit/capi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/pcbit/capi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/pcbit/drv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/pcbit/edss1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/pcbit/edss1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/pcbit/layer2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/pcbit/layer2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/pcbit/module.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/pcbit/pcbit.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/card.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/command.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/debug.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/debug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/event.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/hardware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/includes.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/interrupt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/message.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/message.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/packet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/scioc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/shmem.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/isdn/sc/timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/adb-iop.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/adb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/adbhid.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/mac_hid.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/mac_keyb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/macio-adb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/mackeymap.map#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/macserial.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/macserial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/mediabay.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/nvram.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/rtc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/via-cuda.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/via-macii.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/via-maciisi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/via-pmu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/macintosh/via-pmu68k.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/md/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/md/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/md/linear.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/md/lvm-snap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/md/lvm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/md/md.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/md/raid0.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/md/raid1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/md/raid5.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/md/xor.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/radio/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/radio/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/radio/radio-aimslab.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/radio/radio-aztech.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/radio/radio-cadet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/radio/radio-gemtek.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/radio/radio-maestro.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/radio/radio-miropcm20.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/radio/radio-rtrack2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/radio/radio-sf16fmi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/radio/radio-terratec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/radio/radio-trust.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/radio/radio-typhoon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/radio/radio-zoltrix.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/audiochip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/bt848.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/bttv-cards.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/bttv-driver.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/bttv-if.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/bttv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/bttvp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/buz.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/buz.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/bw-qcam.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/bw-qcam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/c-qcam.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/cpia.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/cpia.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/cpia_pp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/cpia_usb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/cs8420.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/i2c-old.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/i2c-parport.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/ibmmpeg2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/id.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/msp3400.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/planb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/planb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/pms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/saa5249.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/saa7110.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/saa7111.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/saa7121.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/saa7146.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/saa7146reg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/saa7185.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/saa7196.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/stradis.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/tda7432.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/tda9875.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/tuner-3036.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/tuner.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/tuner.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/tvaudio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/tvaudio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/tvmixer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/videodev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/vino.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/zr36057.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/zr36060.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/zr36120.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/zr36120.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/zr36120_i2c.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/zr36120_mem.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/media/video/zr36120_mem.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/misc/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/misc/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/cfi_cmdset_0001.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/cfi_cmdset_0002.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/cfi_probe.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/doc1000.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/doc2000.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/doc2001.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/docecc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/docprobe.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/ftl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/jedec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/map_ram.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/map_rom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/mapped.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/mixmem.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/mtdblock.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/mtdchar.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/mtdcore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/mtdpart.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/mtdram.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/nftl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/nftlmount.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/nora.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/octagon-5066.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/physmap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/pmc551.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/pnc2000.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/rpxlite.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/slram.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/mtd/vmax301.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/3c501.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/3c503.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/3c503.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/3c505.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/3c505.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/3c507.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/3c509.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/3c515.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/3c523.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/3c523.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/3c527.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/3c527.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/3c59x.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/7990.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/7990.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/8139too.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/82596.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/8390.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/8390.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/LICENSE.SRC#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/Space.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/a2065.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/a2065.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ac3200.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/acenic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/acenic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/acenic_firmware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/aironet4500.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/aironet4500_card.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/aironet4500_core.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/aironet4500_proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/aironet4500_rid.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/am79c961a.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/am79c961a.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/apne.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/appletalk/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/appletalk/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/appletalk/cops.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/appletalk/cops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/appletalk/cops_ffdrv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/appletalk/cops_ltdrv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/appletalk/ipddp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/appletalk/ipddp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/appletalk/ltpc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/appletalk/ltpc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/arcnet/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/arcnet/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/arcnet/arc-rawmode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/arcnet/arc-rimi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/arcnet/arcnet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/arcnet/com20020-isa.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/arcnet/com20020-pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/arcnet/com20020.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/arcnet/com90io.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/arcnet/com90xx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/arcnet/rfc1051.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/arcnet/rfc1201.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ariadne.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ariadne.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ariadne2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/arlan-proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/arlan.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/arlan.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/at1700.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/atari_bionet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/atari_pamsnet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/atarilance.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/atp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/atp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/auto_irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/bagetlance.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/bmac.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/bmac.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/bonding.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/bsd_comp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/cs89x0.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/cs89x0.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/daynaport.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/de4x5.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/de4x5.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/de600.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/de620.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/de620.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/declance.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/defxx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/defxx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/depca.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/depca.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/dgrs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/dgrs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/dgrs_asstruct.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/dgrs_bcomm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/dgrs_es4h.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/dgrs_ether.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/dgrs_firmware.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/dgrs_i82596.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/dgrs_plx9060.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/dmfe.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/dummy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/e2100.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/eepro.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/eepro100.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/eexpress.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/eexpress.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/epic100.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/eql.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/es3210.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/eth16i.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ethertap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ewrk3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ewrk3.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/fc/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/fc/iph5526.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/fc/iph5526_ip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/fc/iph5526_novram.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/fc/iph5526_scsi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/fc/tach.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/fc/tach_structs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/fmv18x.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/gmac.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/gmac.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamachi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/6pack.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/baycom_epp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/baycom_par.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/baycom_ser_fdx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/baycom_ser_hdx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/bpqether.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/dmascc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/hdlcdrv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/mkiss.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/mkiss.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/scc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/soundmodem/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/soundmodem/gentbl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/soundmodem/sm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/soundmodem/sm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/soundmodem/sm_afsk1200.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/soundmodem/sm_afsk2400_7.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/soundmodem/sm_afsk2400_8.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/soundmodem/sm_afsk2666.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/soundmodem/sm_fsk9600.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/soundmodem/sm_hapn4800.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/soundmodem/sm_psk4800.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/soundmodem/sm_sbc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/soundmodem/sm_wss.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/soundmodem/smdma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/yam.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/yam1200.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/yam9600.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hamradio/z8530.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hp-plus.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hp100.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hp100.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hplance.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hplance.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hydra.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/hydra.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/i82586.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ibmlana.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ibmlana.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ioc3-eth.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/irda/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/irda/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/irda/actisys.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/irda/esi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/irda/girbil.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/irda/irport.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/irda/irtty.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/irda/litelink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/irda/nsc-ircc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/irda/old_belkin.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/irda/smc-ircc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/irda/tekram.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/irda/toshoboe.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/irda/w83977af_ir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/isa-skeleton.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/jazzsonic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/lance.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/lasi_82596.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/lne390.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/loopback.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/mac89x0.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/mace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/mace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/macmace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/macsonic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/mvme147.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/myri_code.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/myri_sbus.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/myri_sbus.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/natsemi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ncr885_debug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ncr885e.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ncr885e.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ne.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ne2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ne2k-pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ne3210.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/net_init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ni5010.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ni5010.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ni52.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ni52.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ni65.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ni65.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/oaknet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/3c574_cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/3c589_cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/aironet4500_cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/com20020_cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/fmvj18x_cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/i82593.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/ibmtr_cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/netwave_cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/nmclan_cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/ositech.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/pcnet_cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/ray_cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/ray_cs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/rayctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/smc91c92_cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/wavelan.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/wavelan_cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/wavelan_cs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/xirc2ps_cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcmcia/xircom_tulip_cb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pcnet32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/plip.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ppp_async.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ppp_deflate.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ppp_generic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ppp_synctty.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pppoe.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/pppox.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ptifddi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ptifddi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/ptifddi_asm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/rcif.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/rclanmtl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/rclanmtl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/rcpci45.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/rrunner.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/rrunner.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/rtl8129.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sb1000.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/seeq8005.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/seeq8005.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/setup.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sgiseeq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sgiseeq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/shaper.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sis900.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sis900.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/lm80.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skaddr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skcsum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skdebug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skdrv1st.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skdrv2nd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skerror.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skgedrv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skgehw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skgehwt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skgei2c.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skgeinit.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skgepnm2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skgepnmi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skgesirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/ski2c.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skqueue.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skrlmt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/sktimer.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/sktypes.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/skvpd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/h/xmac_ii.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/skaddr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/skcsum.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/skge.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/skgehwt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/skgeinit.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/skgepnmi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/skgesirq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/ski2c.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/sklm80.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/skqueue.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/skrlmt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/sktimer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/skvpd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk98lin/skxmac2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk_g16.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk_g16.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk_mca.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sk_mca.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/can.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/cfm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/drvfbi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/ecm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/ess.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/fplustm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/cmtdef.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/fddi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/fddimib.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/fplustm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/hwmtm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/lnkstat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/mbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/osdef1st.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/sba.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/sba_def.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/skfbi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/skfbiinc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/smc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/smt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/smt_p.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/smtstate.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/supern_2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/targethw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/targetos.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/h/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/hwmtm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/hwt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/lnkstat.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/pcmplc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/pmf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/queue.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/rmt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/skfddi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/smt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/smtdef.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/smtinit.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/smtparse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/smttimer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/skfp/srf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/slhc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/slip.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/slip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/smc-mca.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/smc-mca.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/smc-ultra.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/smc-ultra32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/smc9194.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/smc9194.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sonic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sonic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/starfire.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/stnic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/strip.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sun3lance.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sunbmac.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sunbmac.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sundance.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sunhme.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sunhme.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sunlance.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sunqe.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/sunqe.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tlan.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tlan.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/abyss.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/abyss.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/ibmtr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/ibmtr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/lanstreamer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/lanstreamer.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/madgemc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/madgemc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/olympic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/olympic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/smctr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/smctr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/smctr_firmware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/tms380tr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/tms380tr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/tms380tr_microcode.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tokenring/tmspci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tulip/21142.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tulip/ChangeLog#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tulip/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tulip/eeprom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tulip/interrupt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tulip/media.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tulip/pnic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tulip/timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tulip/tulip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tulip/tulip_core.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/tun.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/via-rhine.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/comx-hw-comx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/comx-hw-locomx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/comx-hw-mixcom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/comx-proto-fr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/comx-proto-lapb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/comx-proto-ppp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/comx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/comx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/comxhw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/cosa.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/cosa.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/cycx_drv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/cycx_main.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/cycx_x25.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/dlci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/hostess_sv11.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/hscx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/lapbether.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/lmc/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/lmc/lmc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/lmc/lmc_debug.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/lmc/lmc_debug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/lmc/lmc_ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/lmc/lmc_main.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/lmc/lmc_media.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/lmc/lmc_media.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/lmc/lmc_prot.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/lmc/lmc_proto.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/lmc/lmc_proto.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/lmc/lmc_proto_raw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/lmc/lmc_var.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/lmc/lmc_ver.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/mixcom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/sbni.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/sbni.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/sdla.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/sdla_chdlc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/sdla_fr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/sdla_ppp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/sdla_x25.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/sdladrv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/sdlamain.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/sealevel.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/syncppp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/syncppp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/x25_asy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/x25_asy.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/z85230.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wan/z85230.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wavelan.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wavelan.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wavelan.p.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/wd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/winbond-840.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/yellowfin.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/zlib.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/zlib.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/net/znet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/nubus/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/nubus/nubus.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/nubus/nubus_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/nubus/proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/BUGS-parport#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/ChangeLog#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/TODO-parport#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/daisy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/ieee1284.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/ieee1284_ops.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/multiface.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/parport_amiga.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/parport_arc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/parport_atari.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/parport_gsc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/parport_mfc3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/parport_pc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/parport_sunbpp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/probe.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/procfs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/parport/share.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pci/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pci/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pci/compat.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pci/gen-devlist.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pci/names.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pci/pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pci/pci.ids#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pci/proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pci/quirks.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pci/setup-bus.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pci/setup-irq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pci/setup-res.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pci/syscall.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/bulkmem.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/cardbus.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/cb_enabler.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/cirrus.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/cistpl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/cs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/cs_internal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/ds.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/i82365.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/i82365.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/o2micro.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/old-yenta.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/pci_socket.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/pci_socket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/ricoh.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/rsrc_mgr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/rsrc_mgr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/smc34c90.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/tcic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/tcic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/ti113x.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/topic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/vg468.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/yenta.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pcmcia/yenta.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pnp/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pnp/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pnp/isapnp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pnp/isapnp_proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/pnp/quirks.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/block/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/block/dasd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/block/dasd_ccwstuff.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/block/dasd_ccwstuff.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/block/dasd_eckd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/block/dasd_erp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/block/dasd_erp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/block/dasd_mdsk.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/block/dasd_proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/block/dasd_profile.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/block/dasd_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/block/mdisk.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/block/mdisk.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/char/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/char/con3215.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/char/hwc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/char/hwc_con.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/char/hwc_rw.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/char/hwc_rw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/char/hwc_tty.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/misc/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/misc/chandev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/net/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/net/ctc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/net/iucv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/s390/net/iucv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/audio/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/audio/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/audio/amd7930.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/audio/amd7930.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/audio/audio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/audio/cs4215.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/audio/cs4231.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/audio/cs4231.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/audio/dbri.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/audio/dbri.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/audio/dmy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/audio/dummy.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/aurora.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/aurora.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/bpp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/cd180.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/display7seg.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/envctrl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/flash.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/jsflash.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/openprom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/pcikbd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/pcikbd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/rtc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/sab82532.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/su.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/sunkbd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/sunkbd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/sunkbdmap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/sunkeymap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/sunkeymap.map#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/sunmouse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/sunmouse.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/sunserial.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/sunserial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/uctrl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/vfc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/vfc_dev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/vfc_i2c.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/vfc_i2c.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/zs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/char/zs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/dvma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sbus/sbus.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/3w-xxxx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/3w-xxxx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/53c7,8xx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/53c7,8xx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/53c7,8xx.scr#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/53c7xx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/53c7xx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/53c7xx.scr#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/53c8xx_d.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/53c8xx_u.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/AM53C974.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/AM53C974.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/BusLogic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/BusLogic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ChangeLog#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ChangeLog.ips#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ChangeLog.ncr53c8xx#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ChangeLog.serverraid#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ChangeLog.sym53c8xx#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/FlashPoint.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/LICENSE.FlashPoint#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/NCR5380.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/NCR5380.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/NCR53C9x.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/NCR53C9x.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/NCR53c406a.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/NCR53c406a.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.AM53C974#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.BusLogic#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.FlashPoint#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.Mylex#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.aha152x#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.dtc3x80#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.g_NCR5380#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.ibmmca#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.in2000#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.ncr53c7xx#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.ncr53c8xx#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.osst#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.ppa#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.qlogicfas#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.qlogicisp#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.st#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/README.tmscsim#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/a2091.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/a2091.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/a3000.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/a3000.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/advansys.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/advansys.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aha152x.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aha152x.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aha1542.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aha1542.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aha1740.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aha1740.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7770.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7770_osm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx.reg#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx.seq#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_core.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_host.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_inline.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_osm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_osm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic79xx_proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx.reg#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx.seq#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_93cx6.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_93cx6.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_core.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_host.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_inline.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_osm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_osm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_pci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aic7xxx_proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/cam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/queue.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/scsi_iu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx/scsi_message.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx_old.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx_old/README.aic7xxx#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx_old/aic7xxx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx_old/aic7xxx.reg#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx_old/aic7xxx.seq#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx_old/aic7xxx_proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx_old/aic7xxx_reg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx_old/aic7xxx_seq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx_old/scsi_message.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/aic7xxx_old/sequencer.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/amiga7xx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/amiga7xx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/atari_NCR5380.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/atari_dma_emul.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/atari_scsi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/atari_scsi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/atp870u.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/atp870u.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/blz1230.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/blz1230.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/blz2060.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/blz2060.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/bvme6000.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/bvme6000.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/constants.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/constants.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/cpqfc.Readme#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/cpqfcTS.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/cpqfcTSchip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/cpqfcTScontrol.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/cpqfcTSi2c.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/cpqfcTSinit.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/cpqfcTSioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/cpqfcTSstructs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/cpqfcTStrigger.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/cpqfcTSworker.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/cpqioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/cyberstorm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/cyberstorm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/cyberstormII.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/cyberstormII.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/dc390.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/dec_esp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/dec_esp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/dmx3191d.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/dmx3191d.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/dtc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/dtc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/eata.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/eata.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/eata_dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/eata_dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/eata_dma_proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/eata_dma_proc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/eata_generic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/eata_pio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/eata_pio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/eata_pio_proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/esp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/esp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/fastlane.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/fastlane.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/fcal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/fcal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/fd_mcs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/fd_mcs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/fdomain.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/fdomain.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/g_NCR5380.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/g_NCR5380.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/gdth.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/gdth.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/gdth_ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/gdth_proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/gdth_proc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/gvp11.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/gvp11.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/hosts.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/hosts.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/i60uscsi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/i60uscsi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/i91uscsi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/i91uscsi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ibmmca.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ibmmca.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ide-scsi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ide-scsi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/imm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/imm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/in2000.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/in2000.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ini9100u.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ini9100u.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/inia100.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/inia100.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ips.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ips.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/jazz_esp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/jazz_esp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/mac53c94.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/mac53c94.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/mac_NCR5380.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/mac_esp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/mac_esp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/mac_scsi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/mac_scsi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/mca_53c9x.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/mca_53c9x.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/megaraid.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/megaraid.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/mesh.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/mesh.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/mvme147.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/mvme147.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/mvme16x.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/mvme16x.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ncr53c8xx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ncr53c8xx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/oktagon_esp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/oktagon_esp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/oktagon_io.S#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/osst.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/osst.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/osst_detect.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/osst_options.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/pas16.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/pas16.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/pci2000.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/pci2000.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/pci2220i.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/pci2220i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/pcmcia/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/pcmcia/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/pcmcia/aha152x_stub.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/pcmcia/fdomain_stub.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/pcmcia/qlogic_stub.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/pluto.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/pluto.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ppa.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ppa.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/psi240i.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/psi240i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/psi_chip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/psi_dale.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/psi_roy.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ql12160_fw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ql1280_fw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/qla1280.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/qla1280.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/qlogicfas.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/qlogicfas.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/qlogicfc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/qlogicfc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/qlogicfc_asm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/qlogicisp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/qlogicisp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/qlogicisp_asm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/qlogicpti.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/qlogicpti.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/qlogicpti_asm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/script_asm.pl#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi_debug.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi_debug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi_dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi_error.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi_ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi_lib.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi_merge.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi_module.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi_obsolete.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi_obsolete.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi_proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi_queue.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi_scan.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsi_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsicam.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/scsiiom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/seagate.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/seagate.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sg.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sgiwd93.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sgiwd93.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sim710.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sim710.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sim710.scr#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sim710_d.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sim710_u.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sr_ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sr_vendor.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/st.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/st.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/st_options.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sun3_NCR5380.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sun3_scsi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sun3_scsi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sun3x_esp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sun3x_esp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sym53c416.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sym53c416.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sym53c8xx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sym53c8xx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sym53c8xx_comm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/sym53c8xx_defs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/t128.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/t128.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/tmscsim.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/tmscsim.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/u14-34f.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/u14-34f.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ultrastor.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/ultrastor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/wd33c93.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/wd33c93.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/wd7000.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/scsi/wd7000.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/ds1286.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/gconsole.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/graphics.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/graphics.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/graphics_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/linux_logo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/newport.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/rrm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/sgicons.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/sgiserial.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/sgiserial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/shmiq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/streamable.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/usema.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sgi/char/usema.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/.indent.pro#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/.version#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/724hwmcode.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/CHANGELOG#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/COPYING#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/Hwmcode.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/README.FIRST#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/ac97.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/ac97.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/ac97_codec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/aci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/ad1816.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/ad1848.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/ad1848.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/ad1848_mixer.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/adlib_card.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/aedsp16.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/audio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/audio_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/awe_hw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/awe_wave.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/awe_wave.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/bin2hex.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/cmpci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/coproc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/cs4232.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/cs4232.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/cs4281.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/cs4281_hwdefs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/cs461x.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/cs461x_image.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/cs46xx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/dev_table.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/dev_table.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/dm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/dmabuf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/dmasound/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/dmasound/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/dmasound/awacs_defs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/dmasound/dmasound.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/dmasound/dmasound_atari.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/dmasound/dmasound_awacs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/dmasound/dmasound_core.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/dmasound/dmasound_paula.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/dmasound/dmasound_q40.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/8010.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/audio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/audio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/cardmi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/cardmi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/cardmo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/cardmo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/cardwi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/cardwi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/cardwo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/cardwo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/ecard.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/ecard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/efxmgr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/emu_wrapper.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/emuadxmg.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/hwaccess.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/hwaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/icardmid.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/icardwav.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/irqmgr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/irqmgr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/main.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/midi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/midi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/mixer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/recmgr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/recmgr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/timer.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/voicemgr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/emu10k1/voicemgr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/es1370.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/es1371.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/esssolo1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/gus.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/gus_card.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/gus_hw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/gus_linearvol.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/gus_midi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/gus_vol.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/gus_wave.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/hex2hex.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/i810_audio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/ics2101.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/iwmem.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/mad16.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/maestro.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/maestro.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/maestro_tables.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/maui.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/midi_ctrl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/midi_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/midi_synth.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/midi_synth.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/midibuf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/miroaci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/mpu401.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/mpu401.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/msnd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/msnd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/msnd_classic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/msnd_classic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/msnd_pinnacle.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/msnd_pinnacle.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/nm256.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/nm256_audio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/nm256_coeff.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/opl3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/opl3.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/opl3_hw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/opl3sa.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/opl3sa2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/os.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/pas2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/pas2_card.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/pas2_midi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/pas2_mixer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/pas2_pcm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/pss.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sb_audio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sb_card.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sb_common.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sb_ess.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sb_ess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sb_midi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sb_mixer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sb_mixer.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sequencer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sequencer_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sgalaxy.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/skeleton.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sonicvibes.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sound_calls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sound_config.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sound_core.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sound_firmware.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sound_firmware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sound_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sound_timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/soundcard.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/soundvers.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sscape.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/sys_timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/trident.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/trident.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/trix.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/tuning.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/uart401.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/uart6850.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/ulaw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/v_midi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/v_midi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/via82cxxx_audio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/vidc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/vidc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/vidc_fill.S#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/vwsnd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/waveartist.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/waveartist.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/wavfront.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/wf_midi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/ymf_sb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/ymfpci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/ymfpci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/ymfpci_image.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/yss225.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/sound/yss225.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/tc/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/tc/tc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/tc/tcsyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/tc/zs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/tc/zs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/telephony/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/telephony/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/telephony/ixj.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/telephony/ixj.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/telephony/phonedev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/acm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/audio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/audio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/bluetooth.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/dabfirmware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/dabusb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/dabusb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/dc2xx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/devices.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/devio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/drivers.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/dsbr100.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/hid-debug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/hid.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/hid.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/hub.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/hub.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/ibmcam.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/ibmcam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/mdc800.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/microtek.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/microtek.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/net1080.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/ov511.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/ov511.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/pegasus.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/pegasus.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/plusb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/printer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/rio500.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/rio500_usb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/scanner.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/scanner.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/Makefile-keyspan_pda_fw#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/belkin_sa.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/belkin_sa.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/digi_acceleport.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/empeg.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/ezusb_convert.pl#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/ftdi_sio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/ftdi_sio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/keyspan.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/keyspan.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/keyspan_pda.S#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/keyspan_pda.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/keyspan_pda_fw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/keyspan_usa18x_fw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/keyspan_usa19_fw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/keyspan_usa19w_fw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/keyspan_usa26msg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/keyspan_usa28_fw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/keyspan_usa28msg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/keyspan_usa28x_fw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/keyspan_usa49msg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/keyspan_usa49w_fw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/mct_u232.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/mct_u232.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/omninet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/usb-serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/usbserial.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/visor.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/visor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/whiteheat.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/whiteheat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/serial/whiteheat_fw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/debug.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/debug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/dpcm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/dpcm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/freecom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/freecom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/initializers.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/initializers.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/protocol.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/protocol.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/scsiglue.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/scsiglue.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/sddr09.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/sddr09.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/shuttle_usbat.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/shuttle_usbat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/transport.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/transport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/usb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/storage/usb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/uhci-debug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/uhci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/uhci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/usb-debug.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/usb-ohci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/usb-ohci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/usb-uhci-debug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/usb-uhci.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/usb-uhci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/usb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/usbkbd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/usbmouse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/uss720.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/usb/wacom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/S3triofb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/acornfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/acornfb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/amifb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/atafb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/aty.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/aty128.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/aty128fb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/atyfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/bwtwofb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/cgfourteenfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/cgsixfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/cgthreefb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/chipsfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/clgenfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/clgenfb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/controlfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/controlfb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/creatorfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/cvisionppc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/cyber2000fb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/cyber2000fb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/cyberfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/cyberfb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/dn_accel.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/dn_cfb4.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/dn_cfb8.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/dnfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/dummycon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcmap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-afb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-cfb16.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-cfb2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-cfb24.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-cfb32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-cfb4.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-cfb8.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-hga.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-ilbm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-iplan2p2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-iplan2p4.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-iplan2p8.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-mac.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-mfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-sti.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-vga-planes.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon-vga.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbcon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbgen.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbmem.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fbmon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fm2fb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/font_6x11.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/font_8x16.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/font_8x8.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/font_acorn_8x8.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/font_pearl_8x8.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/font_sun12x22.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/font_sun8x16.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/fonts.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/g364fb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/hgafb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/hitfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/hpfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/iga.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/igafb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/imsttfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/leofb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/macfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/macmodes.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/i2c-matroxfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_DAC1064.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_DAC1064.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_Ti3026.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_Ti3026.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_accel.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_accel.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_base.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_base.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_crtc2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_crtc2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_g450.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_g450.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_maven.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_maven.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/matrox/matroxfb_misc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/mdacon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/modedb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/newport_con.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/offb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/p9100.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/p9100fb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/platinumfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/platinumfb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/pm2fb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/pm2fb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/prom.uni#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/promcon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/q40fb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/retz3fb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/retz3fb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/riva/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/riva/fbdev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/riva/nv4ref.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/riva/nvreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/riva/riva_hw.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/riva/riva_hw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/riva/riva_tbl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sa1100fb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sbusfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sgivwfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sgivwfb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sis/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sis/initdef.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sis/sis.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sis/sis_300.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sis/sis_300.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sis/sis_301.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sis/sis_301.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sis/sis_main.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/skeletonfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sti-bmode.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sti.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sticon-bmode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sticon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sticore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/stifb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/sun3fb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/tcxfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/tdfxfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/tgafb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/tgafb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/valkyriefb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/valkyriefb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/vesafb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/vfb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/vga.h#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/vga16fb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/vgacon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/video/virgefb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/zorro/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/zorro/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/zorro/gen-devlist.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/zorro/names.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/zorro/proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/zorro/zorro.c#1 branch
-... //depot/linux-aic79xx-2.4.0/drivers/zorro/zorro.ids#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ChangeLog#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/adfs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/adfs/adfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/adfs/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/adfs/dir_f.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/adfs/dir_f.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/adfs/dir_fplus.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/adfs/dir_fplus.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/adfs/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/adfs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/adfs/map.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/adfs/super.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/affs/Changes#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/affs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/affs/amigaffs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/affs/bitmap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/affs/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/affs/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/affs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/affs/namei.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/affs/super.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/affs/symlink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/attr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs/autofs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs/dirhash.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs/root.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs/symlink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs/waitq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs4/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs4/autofs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs4/expire.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs4/init.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs4/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs4/root.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs4/symlink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/autofs4/waitq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/bad_inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/bfs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/bfs/bfs_defs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/bfs/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/bfs/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/bfs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/binfmt_aout.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/binfmt_elf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/binfmt_em86.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/binfmt_misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/binfmt_script.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/block_dev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/buffer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/coda/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/coda/cache.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/coda/cnode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/coda/coda_linux.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/coda/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/coda/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/coda/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/coda/pioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/coda/psdev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/coda/symlink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/coda/sysctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/coda/upcall.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/README#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/cramfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/adler32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/infblock.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/infblock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/infcodes.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/infcodes.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/inffast.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/inffast.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/inffixed.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/inflate.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/inftrees.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/inftrees.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/infutil.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/infutil.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/uncompr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/zconf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/zlib.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inflate/zutil.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/cramfs/uncompress.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/dcache.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/devfs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/devfs/base.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/devfs/util.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/devices.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/devpts/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/devpts/devpts_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/devpts/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/devpts/root.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/dnotify.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/dquot.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/efs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/efs/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/efs/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/efs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/efs/namei.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/efs/super.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/efs/symlink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/exec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ext2/CHANGES#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ext2/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ext2/acl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ext2/balloc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ext2/bitmap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ext2/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ext2/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ext2/fsync.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ext2/ialloc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ext2/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ext2/ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ext2/namei.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ext2/super.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ext2/symlink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/fat/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/fat/buffer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/fat/cache.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/fat/cvf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/fat/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/fat/fatfs_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/fat/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/fat/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/fat/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/fat/msbuffer.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/fat/tables.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/fat/tables.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/fcntl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/fifo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/file_table.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/filesystems.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/COPYING#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/ChangeLog#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/FAQ.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/HFS.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/INSTALL.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/TODO#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/balloc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/bdelete.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/bfind.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/bins_del.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/binsert.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/bitmap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/bitops.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/bnode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/brec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/btree.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/catalog.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/dir_cap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/dir_dbl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/dir_nat.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/extent.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/file_cap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/file_hdr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/hfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/hfs_btree.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/mdb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/part_tbl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/string.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/super.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/sysdep.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/trans.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hfs/version.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/alloc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/anode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/buffer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/dentry.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/dnode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/ea.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/hpfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/hpfs_fn.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/map.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/name.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/namei.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/hpfs/super.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/iobuf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/isofs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/isofs/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/isofs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/isofs/joliet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/isofs/namei.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/isofs/rock.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/isofs/rock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/isofs/util.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/jffs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/jffs/inode-v23.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/jffs/intrep.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/jffs/intrep.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/jffs/jffs_fm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/jffs/jffs_fm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/lockd/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/lockd/clntlock.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/lockd/clntproc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/lockd/host.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/lockd/lockd_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/lockd/mon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/lockd/svc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/lockd/svc4proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/lockd/svclock.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/lockd/svcproc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/lockd/svcshare.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/lockd/svcsubs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/lockd/xdr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/lockd/xdr4.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/locks.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/minix/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/minix/bitmap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/minix/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/minix/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/minix/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/minix/itree_common.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/minix/itree_v1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/minix/itree_v2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/minix/namei.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/msdos/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/msdos/msdosfs_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/msdos/namei.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/namei.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ncpfs/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ncpfs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ncpfs/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ncpfs/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ncpfs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ncpfs/ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ncpfs/mmap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ncpfs/ncplib_kernel.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ncpfs/ncplib_kernel.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ncpfs/ncpsign_kernel.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ncpfs/ncpsign_kernel.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ncpfs/sock.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ncpfs/symlink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfs/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfs/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfs/flushd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfs/mount_clnt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfs/nfs2xdr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfs/nfs3proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfs/nfs3xdr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfs/nfsroot.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfs/proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfs/read.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfs/symlink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfs/unlink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfs/write.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfsd/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfsd/auth.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfsd/export.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfsd/lockd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfsd/nfs3proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfsd/nfs3xdr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfsd/nfscache.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfsd/nfsctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfsd/nfsfh.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfsd/nfsproc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfsd/nfssvc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfsd/nfsxdr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfsd/stats.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nfsd/vfs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_base.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_big5.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp437.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp737.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp775.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp850.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp852.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp855.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp857.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp860.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp861.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp862.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp863.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp864.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp865.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp866.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp869.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp874.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp932.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp936.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp949.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_cp950.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_euc-jp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_euc-kr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_gb2312.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_iso8859-1.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_iso8859-14.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_iso8859-15.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_iso8859-2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_iso8859-3.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_iso8859-4.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_iso8859-5.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_iso8859-6.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_iso8859-7.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_iso8859-8.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_iso8859-9.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_koi8-r.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_sjis.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/nls/nls_utf8.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/noquot.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/attr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/attr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/dir.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/fs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/inode.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/macros.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/ntfsendian.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/ntfstypes.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/struct.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/super.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/super.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/support.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/support.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/sysctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/sysctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/util.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ntfs/util.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/open.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/openpromfs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/openpromfs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/acorn.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/acorn.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/amiga.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/amiga.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/atari.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/atari.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/check.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/check.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/ibm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/ibm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/mac.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/mac.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/msdos.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/msdos.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/osf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/osf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/sgi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/sgi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/sun.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/sun.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/ultrix.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/partitions/ultrix.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/pipe.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/proc/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/proc/array.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/proc/base.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/proc/generic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/proc/inode-alloc.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/proc/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/proc/kcore.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/proc/kmsg.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/proc/proc_devtree.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/proc/proc_misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/proc/proc_tty.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/proc/procfs_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/proc/root.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/qnx4/BUGS#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/qnx4/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/qnx4/README#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/qnx4/TODO#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/qnx4/bitmap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/qnx4/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/qnx4/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/qnx4/fsync.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/qnx4/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/qnx4/namei.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/qnx4/truncate.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ramfs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ramfs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/read_write.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/readdir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/romfs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/romfs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/select.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/smbfs/ChangeLog#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/smbfs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/smbfs/cache.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/smbfs/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/smbfs/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/smbfs/getopt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/smbfs/getopt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/smbfs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/smbfs/ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/smbfs/proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/smbfs/smb_debug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/smbfs/sock.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/stat.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/super.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/sysv/CHANGES#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/sysv/INTRO#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/sysv/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/sysv/balloc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/sysv/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/sysv/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/sysv/fsync.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/sysv/ialloc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/sysv/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/sysv/namei.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/sysv/truncate.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/balloc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/crc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/directory.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/fsync.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/ialloc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/lowlevel.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/namei.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/partition.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/super.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/symlink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/truncate.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/udf_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/udf_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/udfdecl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/udfend.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/udftime.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/udf/unicode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ufs/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ufs/balloc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ufs/cylinder.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ufs/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ufs/file.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ufs/ialloc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ufs/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ufs/namei.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ufs/super.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ufs/swab.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ufs/symlink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ufs/truncate.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ufs/util.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/ufs/util.h#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/umsdos/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/umsdos/README-WIP.txt#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/umsdos/dir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/umsdos/emd.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/umsdos/inode.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/umsdos/ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/umsdos/mangle.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/umsdos/namei.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/umsdos/notes#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/umsdos/rdir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/umsdos/specs#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/vfat/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/vfat/namei.c#1 branch
-... //depot/linux-aic79xx-2.4.0/fs/vfat/vfatfs_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/a.out.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/asm_offsets.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/atomic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/bitops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/bugs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/byteorder.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/checksum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/compiler.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/console.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/core_apecs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/core_cia.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/core_irongate.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/core_lca.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/core_mcpcia.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/core_polaris.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/core_t2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/core_titan.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/core_tsunami.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/core_wildfire.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/current.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/delay.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/div64.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/errno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/fcntl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/floppy.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/fpu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/gentrap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/hardirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/hdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/hw_irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/hwrpb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/init.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/ioctls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/ipcbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/jensen.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/linux_logo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/machvec.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/mc146818rtc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/md.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/mman.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/mmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/mmu_context.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/module.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/msgbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/namei.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/pal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/parport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/pgalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/poll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/posix_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/reg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/resource.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/scatterlist.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/segment.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/semaphore.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/sembuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/sfp-machine.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/shmbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/sigcontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/siginfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/signal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/smp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/smplock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/socket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/sockios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/softirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/spinlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/stat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/statfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/string.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/sysinfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/termbits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/termios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/uaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/ucontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/unaligned.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/unistd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/user.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/vga.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-alpha/xor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/a.out.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-arc/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-arc/hardware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-arc/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-arc/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-arc/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-arc/irqs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-arc/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-arc/memory.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-arc/oldlatches.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-arc/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-arc/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-arc/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-arc/time.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-arc/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-arc/uncompress.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/acornfb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/hardware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/irqs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/memory.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/time.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/uncompress.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-cl7500/vmalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa110/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa110/hardware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa110/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa110/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa110/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa110/irqs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa110/memory.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa110/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa110/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa110/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa110/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa110/time.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa110/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa110/uncompress.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa110/vmalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa285/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa285/hardware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa285/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa285/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa285/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa285/irqs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa285/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa285/memory.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa285/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa285/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa285/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa285/time.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa285/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa285/uncompress.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-ebsa285/vmalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-l7200/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-l7200/hardware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-l7200/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-l7200/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-l7200/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-l7200/irqs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-l7200/memory.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-l7200/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-l7200/serial_l7200.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-l7200/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-l7200/time.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-l7200/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-l7200/uncompress.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-l7200/vmalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-nexuspci/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-nexuspci/hardware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-nexuspci/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-nexuspci/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-nexuspci/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-nexuspci/irqs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-nexuspci/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-nexuspci/memory.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-nexuspci/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-nexuspci/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-nexuspci/time.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-nexuspci/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-nexuspci/uncompress.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-nexuspci/vmalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/acornfb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/hardware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/irqs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/memory.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/time.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/uncompress.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-rpc/vmalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/SA-1100.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/SA-1101.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/SA-1111.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/assabet.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/bitfield.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/bitsy.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/cerf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/hardware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/irqs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/memory.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/mmzone.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/serial_reg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/thinclient.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/time.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/uncompress.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-sa1100/vmalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-shark/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-shark/hardware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-shark/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-shark/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-shark/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-shark/irqs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-shark/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-shark/memory.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-shark/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-shark/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-shark/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-shark/time.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-shark/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-shark/uncompress.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-shark/vmalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-tbox/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-tbox/hardware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-tbox/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-tbox/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-tbox/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-tbox/irqs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-tbox/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-tbox/memory.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-tbox/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-tbox/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-tbox/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-tbox/time.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-tbox/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-tbox/uncompress.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/arch-tbox/vmalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/assembler.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/atomic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/bitops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/bugs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/byteorder.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/checksum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/cpu-multi26.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/cpu-multi32.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/cpu-single.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/current.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/delay.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/div64.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/ecard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/errno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/fcntl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/fiq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/floppy.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/hardirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/hardware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/hardware/dec21285.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/hardware/ioc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/hardware/iomd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/hardware/memc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/hardware/pci_v3.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/hardware/serial_amba.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/hdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/ioctls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/ipc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/ipcbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/leds.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/limits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/linux_logo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/mach/arch.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/mach/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/mach/map.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/mach/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/mc146818rtc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/memory.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/mman.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/mmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/mmu_context.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/mmzone.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/module.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/msgbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/namei.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/nwflash.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/parport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/pgalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/poll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/posix_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armo/assembler.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armo/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armo/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armo/locks.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armo/page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armo/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armo/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armo/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armo/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armo/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armo/uaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armo/uncompress.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armv/assembler.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armv/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armv/domain.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armv/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armv/locks.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armv/page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armv/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armv/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armv/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armv/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armv/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armv/uaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-armv/uncompress.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/proc-fns.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/procinfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/resource.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/scatterlist.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/segment.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/semaphore-helper.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/semaphore.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/sembuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/setup.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/shmbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/sigcontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/siginfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/signal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/smp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/smplock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/socket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/sockios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/softirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/spinlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/stat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/statfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/string.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/termbits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/termios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/therm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/uaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/ucontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/unaligned.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/unistd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/user.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/vga.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/vt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-arm/xor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-generic/bitops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-generic/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-generic/smplock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-generic/unaligned.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-generic/xor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/a.out.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/apic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/apicdef.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/atomic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/bitops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/boot.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/bugs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/byteorder.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/checksum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/cobalt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/cpufeature.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/current.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/debugreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/delay.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/desc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/div64.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/e820.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/errno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/fcntl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/fixmap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/floppy.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/hardirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/hdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/highmem.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/hw_irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/i387.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/init.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/io_apic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/ioctls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/ipc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/ipcbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/kmap_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/ldt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/linux_logo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/lithium.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/locks.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/math_emu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/mc146818rtc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/mca_dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/mman.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/mmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/mmu_context.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/mmx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/module.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/mpspec.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/msgbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/msr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/mtrr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/namei.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/parport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/pgalloc-2level.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/pgalloc-3level.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/pgalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/pgtable-2level.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/pgtable-3level.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/poll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/posix_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/resource.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/rwlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/scatterlist.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/segment.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/semaphore.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/sembuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/setup.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/shmbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/sigcontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/siginfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/signal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/smp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/smplock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/socket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/sockios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/softirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/spinlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/stat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/statfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/string-486.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/string.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/termbits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/termios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/uaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/ucontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/unaligned.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/unistd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/user.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/vga.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/vm86.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-i386/xor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/a.out.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/acpi-ext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/acpikcfg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/asmmacro.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/atomic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/bitops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/break.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/bugs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/byteorder.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/checksum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/current.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/delay.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/div64.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/efi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/errno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/fcntl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/fpswa.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/fpu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/hardirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/hdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/hw_irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/ia32.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/ioctls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/iosapic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/ipc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/ipcbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/linux_logo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/machvec.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/machvec_dig.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/machvec_hpsim.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/machvec_init.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/machvec_sn1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/mca.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/mca_asm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/mman.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/mmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/mmu_context.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/module.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/msgbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/namei.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/offsets.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/pal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/parport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/pgalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/poll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/posix_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/ptrace_offsets.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/resource.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/rse.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/scatterlist.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/segment.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/semaphore.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sembuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/shmbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sigcontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/siginfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/signal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/smp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/smplock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/addrs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/agent.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/alenlist.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/arc/hinv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/arc/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/arch.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/cdl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/clksupport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/cmn_err.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/dmamap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/driver.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/eeprom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/gda.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/hack.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/hcl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/hcl_util.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/hubspc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/hwcntrs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/intr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/intr_public.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/invent.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/iobus.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/ioc3.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/ioerror.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/ioerror_handling.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/iograph.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/klconfig.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/kldir.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/ksys/elsc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/ksys/i2c.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/ksys/l1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/labelcl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/mem_refcnt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/mmzone.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/mmzone_default.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/mmzone_sn1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/module.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/nic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/nodemask.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/nodepda.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/pci/bridge.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/pci/pci_bus_cvlink.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/pci/pci_defs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/pci/pcibr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/pci/pcibr_private.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/pci/pciio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/pci/pciio_private.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/pio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/prio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/router.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sgi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/slotnum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/addrs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/arch.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/bedrock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/hubdev.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/hubio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/hubio_next.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/hublb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/hublb_next.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/hubmd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/hubmd_next.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/hubni.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/hubni_next.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/hubpi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/hubpi_next.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/hubxb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/hubxb_next.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/ip27config.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/kldir.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/leds.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/promlog.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/router.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/slotnum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/sn1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/uart16550.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn1/war.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn_cpuid.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn_fru.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/sn_private.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/synergy.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/systeminfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/vector.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/war.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/xtalk/xbow.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/xtalk/xbow_info.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/xtalk/xswitch.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/xtalk/xtalk.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/xtalk/xtalk_private.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/xtalk/xtalkaddrs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sn/xtalk/xwidget.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/socket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/sockios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/softirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/spinlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/stat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/statfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/string.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/termbits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/termios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/uaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/unaligned.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/unistd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/unwind.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/user.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/vga.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ia64/xor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/a.out.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/adb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/adb_iop.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/adb_mouse.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/amigahw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/amigaints.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/amigayle.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/amipcmcia.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/apollodma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/apollohw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/atafd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/atafdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/atari_SCCserial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/atari_SLM.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/atari_acsi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/atari_joystick.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/atari_stdma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/atari_stram.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/atarihw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/atariints.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/atarikb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/atomic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/bitops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/blinken.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/bootinfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/bugs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/bvme6000hw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/byteorder.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/cachectl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/checksum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/contregs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/current.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/delay.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/div64.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/dsp56k.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/dvma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/entry.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/errno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/fbio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/fcntl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/floppy.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/fpu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/hardirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/hdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/hwtest.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/idprom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/init.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/intersil.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/ioctls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/ipc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/ipcbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/kbio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/linux_logo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/mac_asc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/mac_baboon.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/mac_iop.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/mac_mouse.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/mac_oss.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/mac_psc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/mac_via.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/machdep.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/machines.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/machw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/macintosh.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/macints.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/math-emu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/md.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/mman.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/mmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/mmu_context.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/module.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/motorola_pgalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/motorola_pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/movs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/msgbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/mvme147hw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/mvme16xhw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/namei.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/openprom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/oplib.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/page_offset.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/parport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/pgalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/poll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/posix_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/q40_keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/q40_master.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/q40ints.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/resource.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/sbus.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/scatterlist.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/segment.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/semaphore-helper.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/semaphore.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/sembuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/setup.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/shm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/shmbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/sigcontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/siginfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/signal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/smplock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/socket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/sockios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/softirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/spinlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/stat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/statfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/string.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/sun3-head.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/sun3_pgalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/sun3_pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/sun3ints.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/sun3mmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/sun3x.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/swim_iop.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/termbits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/termios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/traps.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/uaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/ucontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/unaligned.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/unistd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/user.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/virtconvert.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/vuid_event.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-m68k/xor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/a.out.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/addrspace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/arc/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/asm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/asmmacro.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/atomic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/baget/baget.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/baget/vac.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/baget/vic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/bcache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/bitops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/bootinfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/branch.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/bugs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/byteorder.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/cachectl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/cacheops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/checksum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/cpu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/current.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/ddb5074.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/dec/interrupts.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/dec/ioasic_addrs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/dec/ioasic_ints.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/dec/kn01.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/dec/kn02.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/dec/kn02xa.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/dec/kn03.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/dec/machtype.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/dec/tc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/dec/tcinfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/dec/tcmodule.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/delay.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/div64.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/ds1286.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/errno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/fcntl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/floppy.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/fp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/fpregdef.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/gdb-stub.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/gfx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/hardirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/hdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/hw_irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/init.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/inst.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/inventory.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/ioctls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/ipc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/ipcbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/isadep.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/jazz.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/jazzdma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/linux_logo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/mc146818rtc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/mipsprom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/mipsregs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/mman.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/mmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/mmu_context.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/module.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/msgbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/namei.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/ng1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/ng1hw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/nile4.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/orion.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/paccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/parport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/pgalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/poll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/posix_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/prctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/r4kcache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/reboot.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/reg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/regdef.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/resource.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/rrm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/scatterlist.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/segment.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/semaphore-helper.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/semaphore.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/sembuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/sfp-machine.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/sgi/sgi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/sgi/sgihpc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/sgi/sgimc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/sgi/sgint23.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/sgialib.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/sgiarcs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/sgidefs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/shmbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/shmiq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/sigcontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/siginfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/signal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/smp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/smplock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/sni.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/socket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/sockios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/softirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/spinlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/stackframe.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/stat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/statfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/string.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/sysmips.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/termbits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/termios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/uaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/ucontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/umap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/unaligned.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/unistd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/user.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/usioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/vga.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/watch.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/wbflush.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips/xor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/a.out.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/addrspace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/arc/hinv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/arc/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/asm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/asmmacro.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/atomic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/bcache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/bitops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/bootinfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/branch.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/bugs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/byteorder.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/cachectl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/checksum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/cpu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/current.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/delay.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/div64.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/ds1286.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/errno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/fcntl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/floppy.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/fpregdef.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/gfx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/hardirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/hdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/hw_irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/init.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/inst.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/ioctls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/ipc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/ipcbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/linux_logo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/m48t35.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/mc146818rtc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/mipsregs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/mman.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/mmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/mmu_context.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/mmzone.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/module.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/msgbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/namei.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/ng1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/paccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/parport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/pci/bridge.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/pgalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/poll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/posix_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/r10kcache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/r10kcacheops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/r4kcache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/r4kcacheops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/reg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/regdef.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/resource.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/riscos-syscall.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/scatterlist.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/segment.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/semaphore-helper.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/semaphore.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sembuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sfp-machine.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sgi/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sgi/sgi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sgi/sgihpc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sgi/sgimc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sgi/sgint23.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sgialib.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sgiarcs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sgidefs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/shmbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/shmiq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sigcontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/siginfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/signal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/smp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/smplock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/addrs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/agent.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/arch.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/gda.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/intr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/intr_public.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/ioc3.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/klconfig.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/kldir.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/klkernvars.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/launch.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/mapped_kernel.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/nmi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/sn0/addrs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/sn0/arch.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/sn0/hub.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/sn0/hubio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/sn0/hubmd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/sn0/hubni.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/sn0/hubpi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/sn0/ip27.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/sn0/sn0_fru.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/sn_private.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sn/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/socket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sockios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/softirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/spinlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/stackframe.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/stat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/statfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/string.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/sysmips.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/termbits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/termios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/uaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/ucontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/unaligned.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/unistd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/user.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/usioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/watch.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/xor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/xtalk/xtalk.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-mips64/xtalk/xwidget.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/a.out.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/asmregs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/assembly.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/atomic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/bitops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/bootdata.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/bugs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/byteorder.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/checksum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/current.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/delay.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/div64.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/errno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/fcntl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/fixmap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/gsc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/hardirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/hardware.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/hdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/hil.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/hw_irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/ioctls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/iosapic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/ipcbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/led.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/linux_logo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/machdep.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/mc146818rtc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/md.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/mman.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/mmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/mmu_context.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/msgbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/namei.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/parport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/parport_gsc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/pdc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/pdcpat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/pgalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/poll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/posix_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/psw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/real.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/resource.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/runway.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/scatterlist.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/segment.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/semaphore-helper.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/semaphore.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/sembuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/setup.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/shmbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/sigcontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/siginfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/signal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/smp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/smplock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/socket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/sockios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/softirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/som.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/spinlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/stat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/statfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/string.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/termbits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/termios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/traps.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/uaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/ucontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/unaligned.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/unistd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-parisc/user.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/8xx_immap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/a.out.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/amigahw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/amigaints.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/amigappc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/amigayle.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/amipcmcia.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/atomic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/backlight.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/bitops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/board.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/bootinfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/bootx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/bseip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/bugs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/byteorder.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/checksum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/cpm_8260.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/current.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/dbdma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/delay.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/div64.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/errno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/est8260.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/fads.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/fcntl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/feature.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/floppy.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/gemini.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/gemini_serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/gg2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/hardirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/hdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/heathrow.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/highmem.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/hw_irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/hydra.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/immap_8260.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/init.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/ioctls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/ipc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/ipcbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/keylargo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/kgdb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/kmap_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/linux_logo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/m48t35.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/machdep.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/mbx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/mc146818rtc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/md.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/mediabay.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/mk48t59.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/mman.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/mmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/mmu_context.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/module.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/mpc8260.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/mpc8xx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/msgbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/namei.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/nvram.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/oak.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/ohare.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/pci-bridge.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/pgalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/pnp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/poll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/posix_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/prep_nvram.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/prom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/raven.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/residual.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/resource.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/rpxclassic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/rpxlite.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/scatterlist.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/segment.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/semaphore-helper.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/semaphore.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/sembuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/setup.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/shmbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/sigcontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/siginfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/signal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/smp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/smplock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/socket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/sockios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/softirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/spinlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/stat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/statfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/string.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/termbits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/termios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/time.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/tqm860.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/tqm8xxL.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/traps.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/uaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/ucontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/unaligned.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/uninorth.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/unistd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/user.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/vc_ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/vga.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/walnut.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-ppc/xor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/a.out.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/atomic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/bitops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/bugs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/byteorder.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/chandev.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/checksum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/current.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/delay.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/div64.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/ebcdic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/errno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/fcntl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/gdb-stub.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/hardirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/hdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/init.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/ioctls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/ipc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/ipcbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/irqextras390.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/lowcore.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/major.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/mathemu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/misc390.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/mman.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/mmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/mmu_context.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/module.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/msgbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/namei.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/pgalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/poll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/posix_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/queue.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/resource.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/s390-gdbregs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/s390-regs-common.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/s390dyn.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/s390io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/s390mach.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/segment.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/semaphore-helper.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/semaphore.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/sembuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/setup.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/shmbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/sigcontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/siginfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/signal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/sigp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/smp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/smplock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/socket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/sockios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/softirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/spinlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/stat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/statfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/string.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/termbits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/termios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/uaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/ucontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/unaligned.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/unistd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/user.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-s390/xor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/a.out.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/addrspace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/atomic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/bitops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/bugs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/byteorder.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/checksum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/current.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/delay.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/div64.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/errno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/fcntl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/hardirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/hd64461.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/hdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/hitachi_se.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/hw_irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/init.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/io_generic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/io_hd64461.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/io_od.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/io_se.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/io_unknown.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/ioctls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/ipc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/ipcbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/linux_logo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/machvec.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/machvec_init.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/mman.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/mmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/mmu_context.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/module.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/msgbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/namei.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/pgalloc-2level.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/pgalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/pgtable-2level.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/poll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/posix_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/resource.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/rtc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/scatterlist.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/semaphore-helper.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/semaphore.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/sembuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/sh_bios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/shmbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/sigcontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/siginfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/signal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/smc37c93x.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/smp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/smplock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/socket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/sockios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/softirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/spinlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/stat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/statfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/string.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/termbits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/termios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/uaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/ucontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/unaligned.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/unistd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/user.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sh/xor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/a.out.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/asi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/asmmacro.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/atomic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/audioio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/auxio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/bitops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/bpp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/bsderrno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/btfixup.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/bugs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/byteorder.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/checksum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/clock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/contregs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/cprefix.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/current.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/cypress.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/delay.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/div64.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/ebus.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/ecc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/eeprom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/errno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/fbio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/fcntl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/floppy.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/hardirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/hdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/head.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/highmem.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/idprom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/init.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/io-unit.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/ioctls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/iommu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/ipc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/ipcbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/jsflash.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/kbio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/kdebug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/kgdb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/kmap_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/linux_logo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/machines.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/mbus.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/mc146818rtc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/memreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/mman.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/mmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/mmu_context.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/module.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/mostek.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/mpmbox.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/msgbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/msi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/mxcc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/namei.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/obio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/openprom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/openpromio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/oplib.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/pbm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/pcic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/pconf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/perfctr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/pgalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/pgtsrmmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/pgtsun4.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/pgtsun4c.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/poll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/posix_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/psr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/reg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/resource.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/ross.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/rtc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/sbi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/sbus.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/scatterlist.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/segment.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/semaphore.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/sembuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/sfp-machine.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/shmbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/sigcontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/siginfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/signal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/smp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/smplock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/smpprim.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/socket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/sockios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/softirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/solerrno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/spinlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/stat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/statfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/string.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/sun4paddr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/sun4prom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/sunbpp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/svr4.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/swift.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/sysen.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/termbits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/termios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/timer.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/traps.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/tsunami.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/turbosparc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/uaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/ultra.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/unaligned.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/unistd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/user.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/vac-ops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/vaddrs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/vfc_ioctls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/viking.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/vuid_event.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/winmacro.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc/xor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/a.out.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/apb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/asi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/atomic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/audioio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/auxio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/bitops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/bpp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/bsderrno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/bugs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/byteorder.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/checksum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/current.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/delay.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/display7seg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/div64.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/dma.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/ebus.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/envctrl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/errno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/fbio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/fcntl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/fhc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/floppy.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/fpumacro.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/hardirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/hdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/head.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/idprom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/init.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/io.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/ioctls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/iommu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/ipc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/ipcbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/kbio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/kdebug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/linux_logo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/lsu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/mc146818rtc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/mman.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/mmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/mmu_context.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/module.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/mostek.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/msgbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/namei.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/ns87303.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/openprom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/openpromio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/oplib.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/parport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/pbm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/pconf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/perfctr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/pgalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/pgtable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/poll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/posix_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/processor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/psrcompat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/pstate.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/reg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/resource.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/rtc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/sab82532.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/sbus.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/scatterlist.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/segment.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/semaphore-helper.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/semaphore.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/sembuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/sfp-machine.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/shmbuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/shmparam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/sigcontext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/siginfo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/signal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/smp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/smplock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/socket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/sockios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/softirq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/solerrno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/spinlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/spitfire.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/starfire.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/stat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/statfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/string.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/sunbpp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/svr4.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/system.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/termbits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/termios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/timer.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/ttable.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/uaccess.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/uctx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/unaligned.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/unistd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/upa.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/user.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/utrap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/vaddrs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/vga.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/visasm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/vuid_event.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/asm-sparc64/xor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/802_11.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/a.out.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ac97_codec.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/acct.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/acpi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/adb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/adb_mouse.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/adfs_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/adfs_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/adfs_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/affs_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/affs_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/affs_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/affs_hardblocks.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/agp_backend.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/agpgart.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/amifd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/amifdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/amigaffs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/apm_bios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/arcdevice.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atalk.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atari_rootsec.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atm_eni.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atm_idt77105.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atm_nicstar.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atm_suni.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atm_tcp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atm_zatm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atmapi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atmarp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atmclip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atmdev.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atmioc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atmlec.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atmmpc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atmsap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/atmsvc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/auto_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/auto_fs4.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/awe_voice.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ax25.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/b1lli.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/b1pcmcia.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/baycom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/bfs_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/bfs_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/bfs_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/binfmts.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/bitops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/blk.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/blkdev.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/blkpg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/bootmem.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/bpqether.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/brlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/byteorder/big_endian.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/byteorder/generic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/byteorder/little_endian.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/byteorder/pdp_endian.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/byteorder/swab.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/byteorder/swabb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/capability.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/capi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/cciss_ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/cd1400.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/cdk.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/cdrom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/circ_buf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/coda.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/coda_cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/coda_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/coda_linux.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/coda_proc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/coda_psdev.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/coff.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/com20020.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/compatmac.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/comstats.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/concap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/config.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/console.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/console_struct.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/consolemap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ctype.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/cuda.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/cyclades.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/cyclomx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/cycx_cfm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/cycx_drv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/cycx_x25.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/dasd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/dcache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/delay.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/devfs_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/devfs_fs_kernel.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/devpts_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/dio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/dirent.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/divert.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/dn.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/dnotify.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/dtlk.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/efs_dir.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/efs_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/efs_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/efs_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/efs_vh.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/elevator.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/elf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/elfcore.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/errno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/errqueue.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/etherdevice.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ethtool.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ext2_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ext2_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ext2_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/fat_cvf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/fb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/fcdevice.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/fcntl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/fd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/fd1772.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/fddidevice.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/fdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/file.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/filter.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/fs_struct.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ftape-header-segment.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ftape-vendors.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ftape.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/gameport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/generic_serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/genhd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ghash.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/hayesesp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/hdlcdrv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/hdreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/hdsmart.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/hfs_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/hfs_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/hfs_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/hfs_sysdep.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/highmem.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/highuid.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/hippidevice.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/hpfs_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/hpfs_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/hpfs_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/hysdn_if.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/i2c-algo-bit.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/i2c-algo-pcf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/i2c-dev.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/i2c-elektor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/i2c-id.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/i2c-old.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/i2c.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/i2o-dev.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/i2o.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ibmtr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/icmp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/icmpv6.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ide.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_arcnet.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_arp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_bonding.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_bridge.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_cablemodem.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_ec.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_eql.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_ether.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_fc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_fddi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_frad.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_hippi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_ltalk.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_packet.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_plip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_ppp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_pppox.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_pppvar.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_shaper.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_slip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_strip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_tr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_tun.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/if_tunnel.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/igmp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/in.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/in6.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/in_route.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/in_systm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/inet.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/inetdevice.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/init.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/input.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/interrupt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/iobuf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ioport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ipc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ipsec.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ipv6.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ipv6_route.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ipx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/irda.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/irq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/irq_cpustat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/isapnp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/isdn.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/isdn_divertif.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/isdn_lzscomp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/isdn_ppp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/isdnif.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/isicom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/iso_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/iso_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/iso_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/istallion.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ixjuser.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/jffs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/joystick.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/kbd_diacr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/kbd_kern.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/kbd_ll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/kd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/kdev_t.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/kernel.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/kernel_stat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/kernelcapi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/keyboard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/kmod.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/lapb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/limits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/linkage.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/linux_logo.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/list.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/lockd/bind.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/lockd/debug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/lockd/lockd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/lockd/nlm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/lockd/share.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/lockd/sm_inter.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/lockd/xdr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/lockd/xdr4.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/locks.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/logibusmouse.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/loop.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/lp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/lvm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/major.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/malloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/matroxfb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mc146818rtc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mc6821.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mca.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/minix_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/minix_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/minix_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/miscdevice.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mman.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mmzone.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/modsetver.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/module.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mount.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mpp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mroute.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/msdos_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/msdos_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/msdos_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/msg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtd/cfi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtd/compatmac.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtd/doc2000.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtd/flashchip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtd/ftl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtd/iflash.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtd/jedec.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtd/map.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtd/mapped.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtd/mtd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtd/nand.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtd/nand_ids.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtd/nftl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtd/partitions.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtd/pmc551.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/mtio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/n_r3964.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nbd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ncp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ncp_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ncp_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ncp_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ncp_mount.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ncp_no.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/net.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netbeui.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netdevice.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ddp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_decnet.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/compat_firewall.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ip_conntrack.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ip_conntrack_core.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ip_conntrack_ftp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ip_conntrack_helper.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ip_conntrack_protocol.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ip_conntrack_tcp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ip_conntrack_tuple.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ip_nat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ip_nat_core.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ip_nat_ftp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ip_nat_helper.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ip_nat_protocol.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ip_nat_rule.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ip_queue.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ip_tables.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ipchains_core.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ipfwadm_core.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ipt_LOG.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ipt_MARK.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ipt_REJECT.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ipt_TOS.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ipt_limit.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ipt_mac.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ipt_mark.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ipt_multiport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ipt_owner.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ipt_state.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/ipt_tos.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/listhelp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv4/lockhelp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv6.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv6/ip6_tables.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv6/ip6t_LOG.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv6/ip6t_MARK.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv6/ip6t_REJECT.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv6/ip6t_limit.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv6/ip6t_mac.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv6/ip6t_mark.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv6/ip6t_multiport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipv6/ip6t_owner.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_ipx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netfilter_x25.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netlink.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/netrom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfs2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfs3.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfs_flushd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfs_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfs_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfs_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfs_mount.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfs_page.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfs_xdr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfsd/auth.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfsd/cache.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfsd/const.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfsd/debug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfsd/export.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfsd/interface.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfsd/nfsd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfsd/nfsfh.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfsd/stats.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfsd/syscall.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfsd/xdr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfsd/xdr3.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nfsiod.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/notifier.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ntfs_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ntfs_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ntfs_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nubus.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/nvram.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/openpic.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/openprom_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/pagemap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/parport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/parport_pc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/pc_keyb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/pci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/pci_ids.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/personality.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/pg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/phonedev.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/pipe_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/pkt_cls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/pkt_sched.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/pm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/pmu.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/poll.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/posix_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ppdev.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ppp-comp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ppp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ppp_channel.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ppp_defs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/prctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/proc_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/proc_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ps2esdi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ptrace.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/qic117.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/qnx4_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/qnx4_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/qnx4_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/qnxtypes.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/quota.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/quotaops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/raid/linear.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/raid/md.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/raid/md_compatible.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/raid/md_k.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/raid/md_p.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/raid/md_u.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/raid/raid0.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/raid/raid1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/raid/raid5.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/raid/xor.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/random.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/raw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/reboot.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/resource.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/rocket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/romfs_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/romfs_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/romfs_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/rose.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/route.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/rpcsock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/rtc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/rtnetlink.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sc26198.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/scc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sched.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sdla.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sdla_chdlc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sdla_fr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sdla_ppp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sdla_x25.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sdladrv.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sdlapci.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sdlasfm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/securebits.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/selection.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sem.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/serial.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/serial167.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/serialP.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/serial_reg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/serio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/shm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/shmem_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/signal.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sisfb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/skbuff.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/slab.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/smb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/smb_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/smb_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/smb_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/smb_mount.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/smbno.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/smp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/smp_lock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/socket.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sockios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sonet.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sound.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/soundcard.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/soundmodem.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/spinlock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/stallion.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/stat.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/stddef.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/string.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sunrpc/auth.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sunrpc/clnt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sunrpc/debug.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sunrpc/msg_prot.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sunrpc/sched.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sunrpc/stats.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sunrpc/svc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sunrpc/svcauth.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sunrpc/svcsock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sunrpc/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sunrpc/xdr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sunrpc/xprt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/swap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/swapctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/synclink.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sys.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sysctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sysrq.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sysv_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sysv_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/sysv_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/tcp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/telephony.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/termios.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/threads.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/time.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/timer.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/times.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/timex.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/toshiba.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/tpqic02.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/tqueue.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/trdevice.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/tty.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/tty_driver.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/tty_flip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/tty_ldisc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/udf_167.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/udf_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/udf_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/udf_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/udf_udf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/udp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ufs_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ufs_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ufs_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/uio.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/ultrasound.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/umsdos_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/umsdos_fs.p#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/umsdos_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/un.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/unistd.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/usb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/usbdev_fs_i.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/usbdev_fs_sb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/usbdevice_fs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/user.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/utime.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/uts.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/utsname.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/vfs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/video_decoder.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/video_encoder.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/videodev.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/videotext.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/vmalloc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/vt.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/vt_buffer.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/vt_kern.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/wait.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/wanpipe.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/wanrouter.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/watchdog.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/wavefront.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/wireless.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/wrapper.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/x25.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/yam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/zftape.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/zorro.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/linux/zorro_ids.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/math-emu/double.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/math-emu/extended.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/math-emu/op-1.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/math-emu/op-2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/math-emu/op-4.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/math-emu/op-8.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/math-emu/op-common.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/math-emu/quad.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/math-emu/single.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/math-emu/soft-fp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/addrconf.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/af_unix.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/arp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/atmclip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/ax25.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/checksum.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/datalink.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/dn.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/dn_dev.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/dn_fib.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/dn_neigh.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/dn_nsp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/dn_route.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/dsfield.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/dst.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/flow.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/icmp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/if_inet6.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/inet_common.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/inet_ecn.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/inetpeer.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/ip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/ip6_fib.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/ip6_fw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/ip6_route.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/ip_fib.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/ipconfig.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/ipip.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/ipv6.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/ipx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/crc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/discovery.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/ircomm_core.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/ircomm_event.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/ircomm_lmp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/ircomm_param.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/ircomm_ttp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/ircomm_tty.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/ircomm_tty_attach.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irda.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irda_device.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irdacall.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/iriap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/iriap_event.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irias_object.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irlan_client.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irlan_common.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irlan_eth.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irlan_event.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irlan_filter.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irlan_provider.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irlap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irlap_comp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irlap_event.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irlap_frame.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irlmp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irlmp_event.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irlmp_frame.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irmod.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irqueue.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irttp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/irtty.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/nsc-ircc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/parameters.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/qos.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/smc-ircc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/timer.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/toshoboe.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/w83977af.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/w83977af_ir.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/irda/wrapper.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/lapb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/llc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/llc_frame.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/llc_name.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/llc_state.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/ndisc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/neighbour.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/netrom.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/p8022.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/pkt_cls.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/pkt_sched.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/profile.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/protocol.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/psnap.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/raw.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/rawv6.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/rose.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/route.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/scm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/slhc_vj.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/snmp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/sock.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/spx.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/tcp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/tcp_ecn.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/transp_v6.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/udp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/net/x25.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/pcmcia/bulkmem.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/pcmcia/bus_ops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/pcmcia/ciscode.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/pcmcia/cisreg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/pcmcia/cistpl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/pcmcia/cs.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/pcmcia/cs_types.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/pcmcia/driver_ops.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/pcmcia/ds.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/pcmcia/ftl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/pcmcia/mem_op.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/pcmcia/memory.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/pcmcia/ss.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/pcmcia/version.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/scsi/scsi.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/scsi/scsi_ioctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/scsi/scsicam.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/scsi/sg.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-afb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-cfb16.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-cfb2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-cfb24.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-cfb32.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-cfb4.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-cfb8.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-hga.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-ilbm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-iplan2p2.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-iplan2p4.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-iplan2p8.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-mac.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-mfb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-vga-planes.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon-vga.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/fbcon.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/font.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/macmodes.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/newport.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/s3blit.h#1 branch
-... //depot/linux-aic79xx-2.4.0/include/video/sbusfb.h#1 branch
-... //depot/linux-aic79xx-2.4.0/init/main.c#1 branch
-... //depot/linux-aic79xx-2.4.0/init/version.c#1 branch
-... //depot/linux-aic79xx-2.4.0/ipc/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/ipc/msg.c#1 branch
-... //depot/linux-aic79xx-2.4.0/ipc/sem.c#1 branch
-... //depot/linux-aic79xx-2.4.0/ipc/shm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/ipc/util.c#1 branch
-... //depot/linux-aic79xx-2.4.0/ipc/util.h#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/acct.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/capability.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/context.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/dma.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/exec_domain.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/exit.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/fork.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/info.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/itimer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/kmod.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/ksyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/module.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/panic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/pm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/printk.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/ptrace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/resource.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/sched.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/signal.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/softirq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/sys.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/sysctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/uid16.c#1 branch
-... //depot/linux-aic79xx-2.4.0/kernel/user.c#1 branch
-... //depot/linux-aic79xx-2.4.0/lib/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/lib/brlock.c#1 branch
-... //depot/linux-aic79xx-2.4.0/lib/cmdline.c#1 branch
-... //depot/linux-aic79xx-2.4.0/lib/ctype.c#1 branch
-... //depot/linux-aic79xx-2.4.0/lib/dec_and_lock.c#1 branch
-... //depot/linux-aic79xx-2.4.0/lib/errno.c#1 branch
-... //depot/linux-aic79xx-2.4.0/lib/inflate.c#1 branch
-... //depot/linux-aic79xx-2.4.0/lib/string.c#1 branch
-... //depot/linux-aic79xx-2.4.0/lib/vsprintf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/bootmem.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/filemap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/highmem.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/memory.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/mlock.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/mmap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/mmap_avl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/mprotect.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/mremap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/numa.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/oom_kill.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/page_alloc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/page_io.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/shmem.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/slab.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/swap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/swap_state.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/swapfile.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/vmalloc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/mm/vmscan.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/TODO#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/cl2llc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/cl2llc.pre#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/fc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/fddi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/hippi.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/llc_macinit.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/llc_sendpdu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/llc_utility.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/p8022.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/p8023.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/pseudo/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/pseudo/actionnm.awk#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/pseudo/actionnm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/pseudo/compile.awk#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/pseudo/opcd2num.sed#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/pseudo/opcodes#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/pseudo/opcodesnm.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/pseudo/pseudocode#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/pseudo/pseudocode.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/psnap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/sysctl_net_802.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/tr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/transit/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/transit/compile.awk#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/transit/pdutr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/transit/pdutr.pre#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/transit/timertr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/802/transit/timertr.pre#1 branch
-... //depot/linux-aic79xx-2.4.0/net/Changes#1 branch
-... //depot/linux-aic79xx-2.4.0/net/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/net/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/README#1 branch
-... //depot/linux-aic79xx-2.4.0/net/TUNABLE#1 branch
-... //depot/linux-aic79xx-2.4.0/net/appletalk/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/appletalk/aarp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/appletalk/ddp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/appletalk/sysctl_net_atalk.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/addr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/addr.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/atm_misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/clip.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/common.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/common.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/ipcommon.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/ipcommon.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/lec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/lec.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/lec_arpc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/mpc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/mpc.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/mpoa_caches.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/mpoa_caches.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/mpoa_proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/protocols.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/pvc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/raw.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/resources.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/resources.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/signaling.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/signaling.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/atm/svc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/af_ax25.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_addr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_dev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_ds_in.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_ds_subr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_ds_timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_iface.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_in.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_ip.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_out.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_route.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_std_in.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_std_subr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_std_timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_subr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/ax25_uid.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ax25/sysctl_net_ax25.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/br.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/br_device.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/br_fdb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/br_forward.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/br_if.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/br_input.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/br_ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/br_notify.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/br_private.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/br_private_stp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/br_private_timer.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/br_stp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/br_stp_bpdu.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/br_stp_if.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/bridge/br_stp_timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/datagram.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/dev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/dev_mcast.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/dst.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/dv.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/filter.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/iovec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/neighbour.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/netfilter.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/profile.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/rtnetlink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/scm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/skbuff.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/sock.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/sysctl_net_core.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/core/utils.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/decnet/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/net/decnet/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/decnet/README#1 branch
-... //depot/linux-aic79xx-2.4.0/net/decnet/TODO#1 branch
-... //depot/linux-aic79xx-2.4.0/net/decnet/af_decnet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/decnet/dn_dev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/decnet/dn_fib.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/decnet/dn_neigh.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/decnet/dn_nsp_in.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/decnet/dn_nsp_out.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/decnet/dn_route.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/decnet/dn_rules.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/decnet/dn_table.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/decnet/dn_timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/decnet/sysctl_net_decnet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/econet/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/econet/af_econet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/econet/sysctl_net_ec.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ethernet/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ethernet/eth.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ethernet/pe2.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ethernet/sysctl_net_ether.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/af_inet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/arp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/devinet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/fib_frontend.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/fib_hash.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/fib_rules.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/fib_semantics.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/icmp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/igmp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/inetpeer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/ip_forward.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/ip_fragment.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/ip_gre.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/ip_input.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/ip_nat_dumb.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/ip_options.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/ip_output.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/ip_sockglue.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/ipconfig.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/ipip.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/ipmr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_conntrack_core.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_conntrack_ftp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_conntrack_proto_generic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_conntrack_proto_icmp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_conntrack_proto_tcp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_conntrack_proto_udp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_conntrack_standalone.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_fw_compat.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_fw_compat_masq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_fw_compat_redir.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_nat_core.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_nat_ftp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_nat_proto_icmp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_nat_proto_tcp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_nat_proto_udp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_nat_proto_unknown.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_nat_rule.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_nat_standalone.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_queue.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ip_tables.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipchains_core.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipfwadm_core.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipt_LOG.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipt_MARK.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipt_MASQUERADE.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipt_MIRROR.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipt_REDIRECT.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipt_REJECT.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipt_TOS.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipt_limit.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipt_mac.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipt_mark.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipt_multiport.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipt_owner.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipt_state.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipt_tos.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/ipt_unclean.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/iptable_filter.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/netfilter/iptable_mangle.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/protocol.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/raw.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/route.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/syncookies.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/sysctl_net_ipv4.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/tcp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/tcp_input.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/tcp_ipv4.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/tcp_minisocks.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/tcp_output.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/tcp_timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/udp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv4/utils.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/README#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/addrconf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/af_inet6.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/datagram.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/exthdrs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/icmp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/ip6_fib.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/ip6_flowlabel.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/ip6_fw.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/ip6_input.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/ip6_output.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/ipv6_sockglue.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/mcast.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/ndisc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/netfilter/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/netfilter/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/netfilter/ip6_tables.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/netfilter/ip6t_MARK.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/netfilter/ip6t_limit.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/netfilter/ip6t_mac.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/netfilter/ip6t_mark.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/netfilter/ip6t_multiport.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/netfilter/ip6table_filter.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/proc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/protocol.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/raw.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/reassembly.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/route.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/sit.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/sysctl_net_ipv6.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/tcp_ipv6.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipv6/udp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipx/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipx/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipx/af_ipx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipx/af_spx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/ipx/sysctl_net_ipx.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/af_irda.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/compressors/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/compressors/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/compressors/irda_deflate.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/crc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/discovery.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/ircomm/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/ircomm/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/ircomm/ircomm_core.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/ircomm/ircomm_event.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/ircomm/ircomm_lmp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/ircomm/ircomm_param.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/ircomm/ircomm_ttp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/ircomm/ircomm_tty.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/ircomm/ircomm_tty_attach.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/ircomm/ircomm_tty_ioctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irda_device.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/iriap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/iriap_event.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irias_object.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlan/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlan/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlan/irlan_client.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlan/irlan_client_event.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlan/irlan_common.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlan/irlan_eth.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlan/irlan_event.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlan/irlan_filter.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlan/irlan_provider.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlan/irlan_provider_event.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlap.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlap_comp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlap_event.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlap_frame.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlmp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlmp_event.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irlmp_frame.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irnet/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irnet/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irnet/irnet.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irnet/irnet_irda.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irnet/irnet_irda.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irnet/irnet_ppp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irnet/irnet_ppp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irproc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irqueue.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irsyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irsysctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/irttp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/parameters.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/qos.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/irda/wrapper.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/README#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/accept.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/datasending.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/logging.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/main.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/make_times_h.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/misc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/prototypes.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/rfc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/rfc_time.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/security.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/security.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/sockets.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/structure.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/sysctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/sysctl.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/userspace.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/khttpd/waitheaders.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/lapb/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/lapb/lapb_iface.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/lapb/lapb_in.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/lapb/lapb_out.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/lapb/lapb_subr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/lapb/lapb_timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/netlink/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/netlink/af_netlink.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/netlink/netlink_dev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/netrom/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/netrom/af_netrom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/netrom/nr_dev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/netrom/nr_in.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/netrom/nr_loopback.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/netrom/nr_out.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/netrom/nr_route.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/netrom/nr_subr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/netrom/nr_timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/netrom/sysctl_net_netrom.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/netsyms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/packet/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/packet/af_packet.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/rose/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/rose/af_rose.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/rose/rose_dev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/rose/rose_in.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/rose/rose_link.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/rose/rose_loopback.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/rose/rose_out.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/rose/rose_route.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/rose/rose_subr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/rose/rose_timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/rose/sysctl_net_rose.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/Config.in#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/cls_api.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/cls_fw.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/cls_route.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/cls_rsvp.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/cls_rsvp.h#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/cls_rsvp6.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/cls_tcindex.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/cls_u32.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/estimator.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/police.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/sch_api.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/sch_atm.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/sch_cbq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/sch_csz.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/sch_dsmark.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/sch_fifo.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/sch_generic.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/sch_gred.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/sch_ingress.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/sch_prio.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/sch_red.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/sch_sfq.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/sch_tbf.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sched/sch_teql.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/socket.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/auth.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/auth_null.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/auth_unix.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/clnt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/pmap_clnt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/sched.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/stats.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/sunrpc_syms.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/svc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/svcauth.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/svcauth_des.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/svcsock.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/sysctl.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/xdr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sunrpc/xprt.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/sysctl_net.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/unix/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/unix/af_unix.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/unix/garbage.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/unix/sysctl_net_unix.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/wanrouter/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/wanrouter/patchlevel#1 branch
-... //depot/linux-aic79xx-2.4.0/net/wanrouter/wanmain.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/wanrouter/wanproc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/x25/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/net/x25/af_x25.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/x25/sysctl_net_x25.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/x25/x25_dev.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/x25/x25_facilities.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/x25/x25_in.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/x25/x25_link.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/x25/x25_out.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/x25/x25_route.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/x25/x25_subr.c#1 branch
-... //depot/linux-aic79xx-2.4.0/net/x25/x25_timer.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/Configure#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/MAKEDEV.ide#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/Menuconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/README.Menuconfig#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/checkconfig.pl#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/checkhelp.pl#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/checkincludes.pl#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/cramfs/GNUmakefile#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/cramfs/mkcramfs.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/docgen#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/docproc.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/gen-all-syms#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/header.tk#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/kernel-doc#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/ksymoops/README#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/lxdialog/BIG.FAT.WARNING#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/lxdialog/Makefile#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/lxdialog/checklist.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/lxdialog/colors.h#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/lxdialog/dialog.h#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/lxdialog/inputbox.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/lxdialog/lxdialog.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/lxdialog/menubox.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/lxdialog/msgbox.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/lxdialog/textbox.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/lxdialog/util.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/lxdialog/yesno.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/makelst#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/mkdep.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/patch-kernel#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/pathdown.sh#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/split-include.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/tail.tk#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/tkcond.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/tkgen.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/tkparse.c#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/tkparse.h#1 branch
-... //depot/linux-aic79xx-2.4.0/scripts/ver_linux#1 branch
-
-Change 563 by gibbs@aslan on 2002/01/22 11:00:23
-
-	aic79xx.c:
-		Add initial AHD_PKT_BITBUCKET_BUG and overrun handling.
-		In the cases where the hardware will allow such a
-		situation, we will transfer data into on overrun
-		buffer in host memory to simulate a bitbucket.
-	
-	aic79xx.h:
-		AHD_PKT_BITBUCKET_BUG definition.
-	
-	aic79xx.reg:
-		Add per-mode location for saving the accumulator during
-		interrupt handlers.
-	
-		Add bits describing an overrun condition.
-	
-		Add a downloadable constant for defining the 
-		overrun buffer location.
-	
-	aic79xx.seq:
-		Turn freeze_queue into a subroutine and have it
-		save and restore the accumulator around using it.
-	
-		Add preliminary support for handling overruns.
-	
-	aicasm/aicasm.c:
-		Formatting nits.
-	
-	aicasm/aicasm_gram.y:
-	aicasm/aicasm_symbol.h:
-		Allow constants to be larger than 8bits.  The sequencer
-		will still complain if an expression doesn't manipulate
-		the constant into a form that fits in 8bits during an
-		assignment.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#22 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#15 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#18 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#19 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#13 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#13 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#9 edit
-
-Change 554 by gibbs@overdrive on 2002/01/22 00:14:54
-
-	scsi_iu.h:
-		Add a header file describing datastructures of
-		SCSI Information Units.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/scsi_iu.h#1 add
-
-Change 552 by gibbs@overdrive on 2002/01/21 23:50:24
-
-	aic7xxx_osm.c:
-		block_size() is only available in very recent
-		kernels.  Use 1024 for anything earlier than 2.4.17.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#84 edit
-
-Change 529 by gibbs@overdrive on 2002/01/21 14:19:18
-
-	aic7xxx_host.h:
-		Correct idempotency ifdefs.
-	
-	aic7xxx_osm.c:
-		Use "block_size" rather than a hard coded 1024 to
-		access the underlying device in search of an fdisk table.
-	
-	aic7xxx_osm.c:
-		Protect code unreferenced if MMAPIO is flase.
-	
-		Use pci_set_drvdata(), rather than touching the
-		PCI device structure manually.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#6 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#83 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#30 edit
-
-Change 504 by gibbs@aslan on 2002/01/15 13:23:22
-
-	aic79xx.c:
-		Set SAVED_SCSIID and SAVED_LUN to invalid values
-		everytime we restart the sequencer.
-	
-		Panic() after dumping card state should we complete
-		an SCB twice.  This will be removed prior to release.
-	
-		Add panics after most calls to ahd_dump_card_state().
-		This guarantees that we can capture any diagnostic
-		output.
-	
-		Implement status packet fetching.  In the future we
-		may embed the sense data location into the SCB so
-		a sequencer interrupt is not necessary, but for now
-		we let the kernel fill in the sense address.
-	
-		Add sequencer interrupt codes for failures of diagnostics
-		performed by the sequencer.
-	
-		Properly set the bug variable to include all bugs we
-		have workarounds for.
-	
-		Add support for using the abort feature (once it works)
-		to catch references by a target to tag identifiers that
-		are not allocated.
-	
-		Protect the routines parsing the execution list from
-		infinite transaction loops.
-	
-		Enahance ahd_dump_card_state to include more information.
-	
-	aic79xx.h:
-		Move derivative register access routines to aic79xx_inline.h.
-		Using inline functions allows type promotion which aids in
-		gracefully handling quads.
-	
-	aic79xx.reg:
-		Add additional sequencer interrupt codes.
-	
-		Fix a typo in the definition of LQIABORT.
-	
-		Define the sequencer stack size.
-	
-	aic79xx.seq:
-		Revert to non-inlined version of load_first_seg.  The
-		bug that this "worked around" has been addressed.
-	
-		Use calls to setjmp in our interrupt handler rather than
-		manually setting the longjmp address.
-	
-	aic79xx_inline.h:
-		Add routines for syncing sense buffers.
-	
-		Add inline versions of the derivative register
-		access methods (inw, inq, etc.).
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#21 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#14 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#17 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#18 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#16 edit
-
-Change 503 by gibbs@aslan on 2002/01/13 20:57:51
-
-	Packetized checkpoint.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#17 edit
-
-Change 495 by gibbs@aslan on 2002/01/09 09:29:03
-
-	aic7xxx.c:
-		Set both SAVED_LUN and SAVED_SCSIID to impossible values
-		in ahc_restart().  We can't trust these fields until the
-		sequencer trusts them again and since we didn't initialize
-		them explicitly during startup, a rogue interrupt could
-		have caused us to access them, generating a parity error.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#54 edit
-
-Change 493 by gibbs@aslan on 2002/01/08 12:39:10
-
-	Setup task attributes (tag type) for packetized transactions.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#15 edit
-
-Change 492 by gibbs@aslan on 2002/01/08 11:20:40
-
-	aic79xx.c:
-		Add additional trace sequencer interrupt codes.
-	
-		Make a fist pass at handling unexpected bus frees.  We
-		now expect a busfree at the end of any PPR negotiation
-		that results in a change in the IU_REQ agreement.
-	
-		Don't set PACED transfers for async speeds.  This bug
-		didn't seem to upset the chip, but who knows.
-	
-		Fix a bug in initialization of the per-device annex
-		data.  Start at the PRECOMP column and allow
-		auto-increment to do the rest.
-	
-		Enable IU/QAS/RD_STRM/WR_FLOW negotiation.
-	
-		Enable searching through the pending list for SCBs to
-		abort in ahd_abort_scbs().
-	
-		Print out FIFO status in ahd_dump_card_state().
-	
-	aic79xx.reg:
-		Add more debugging SEQINTCODEs.
-	
-		Add definitions for the BUSFREETIME status bits.
-	
-		Correct definition of the PRECOMP annex column.
-	
-		Add FETCH_INPROG to SG_STATE for workaround of
-		SG_CACHE_AVAIL coming true soon than expected.
-	
-		Change DRAINING_SCB to LONGJMP_SCB as the SCBID
-		is now set for many different longjmp routines.
-	
-	aic79xx.seq:
-		Add code to drain the good status fifo.
-	
-		Service longjmp routines in order to clear FIFOs
-		for a non-packetized transaction.
-	
-		Complete the workaround for Razor #494.
-	
-		SG_CACHE_AVAIL will come true in the other FIFO as
-		soon as the FIFO using the SG_CACHE has provided
-		enough segments to satify it's transfer or has seen
-		saveptrs status.  Use FETCH_INPROG state to guard against
-		this early switch confusing the other FIFO into believing
-		it has valid SG data.
-	
-		Clear SG_FULL_RESID from both the SCB_SGPTR and the
-		RESIDUAL_SGPTR by clearing the flag in SCB_SGPTR prior
-		to the copy to the residual field.
-	
-		Update the calc_resid subroutine to include the setting
-		of the residual datacnt.
-	
-		Remove the monitor_drain handler.  We rely on the data
-		FIFO's high priority to handle this case.
-	
-		Only defer completions if a longjmp routine for the
-		SCB of interrest is still active.  This simplifies
-		the check_fifo routine.
-	
-		Inline the good_status_IU handler to lose a stack level.
-	
-	aic79xx_inline.h:
-		Clear the task_management field if we are packetized.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#20 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#13 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#16 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#16 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#14 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#53 edit
-
-Change 485 by gibbs@overdrive on 2001/12/17 23:07:26
-
-	aic79xx_osm.c:
-		Correct typos and style nits.
-	
-		Properly track the transfer length in
-		scb->platform_data->xfer_len.  We failed to
-		update this variable during the conversion to
-		use the Core ahd_sg_setup() routine.
-	
-		Increment cur_seg instead of using the first
-		segment for every segment in the transfer.
-	
-		Remove target_offset.  Since single function
-		twin chips don't exist in the 79XX class, target_offset
-		and target are synonymous.
-	
-		If we don't have a "linux target" structure for for
-		a device pertaining to an async event, don't service
-		the event.
-	
-	aic79xx_osm_pci.c:
-		Linux counts every 4 bytes of config space as a bar
-		regardless of whether the BAR is 64bit or not.  Update
-		use of pci_resource_start() to reflect this strange
-		method of indexing.
-	
-		Correct check of retrieved ioport bases.  base and
-		base2 are pointers.
-	
-		Correct think-o in mapping regsiters.  We only want to
-		attempt IO space if maddr is NULL indicating that
-		memory mapped space is not available.
-	
-	aic7xxx_osm.c:
-		Style nit.
-	
-		If we don't have a "linux target" structure for for
-		a device pertaining to an async event, don't service
-		the event.
-	
-	aic7xxx_osm_pci.c:
-		Correct check of retrieved ioport base.
-		base is a pointer.
-	
-		Correct think-o in mapping regsiters.  We only want to
-		attempt IO space if maddr is NULL indicating that
-		memory mapped space is not available.
-	
-	aicasm/Makefile:
-		yacc in some distributions does not support the -o
-		output option.  Modify the Makefile to avoid using
-		this feature.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#5 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#3 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#82 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#29 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/Makefile#10 edit
-
-Change 484 by gibbs@overdrive on 2001/12/17 21:32:02
-
-	Disable information unit transfers for now.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#19 edit
-
-Change 483 by gibbs@overdrive on 2001/12/17 15:23:19
-
-	aic79xx_osm.c:
-		Remove vestigial call to aic7770_linux_probe().  This driver
-		does not support that chip.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#4 edit
-
-Change 482 by gibbs@overdrive on 2001/12/17 13:43:35
-
-	Include SPI4 PPR options.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/scsi_message.h#4 edit
-
-Change 481 by gibbs@overdrive on 2001/12/17 13:43:25
-
-	Set SCB_PACKETIZED on all packetized SCBs.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#3 edit
-
-Change 480 by gibbs@overdrive on 2001/12/17 13:43:06
-
-	Prepare for release 0.0.0 of the aic79xx driver.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#4 edit
-
-Change 479 by gibbs@aslan on 2001/12/17 13:27:15
-
-	aic79xx.c:
-	aic79xx.seq:
-		Initialize SG_STATE to 0 for sanity on card initialization
-		and anytime a new transfer is started where additional
-		segments are not needed.
-	
-	aic79xx.reg:
-		SG_SENSE is no longer needed.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#18 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#15 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#15 edit
-
-Change 478 by gibbs@overdrive on 2001/12/17 11:44:16
-
-	aic7xxx.h:
-		Remove alternate bus space tag handles.  We don't bother
-		holding the unused regions any more.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#37 edit
-
-Change 477 by gibbs@aslan on 2001/12/17 11:43:03
-
-	aic79xx.c:
-		Break out the computation of "post patch" sequencer
-		addresses so we can use it to compute the location
-		of the sequencer's interrupt handler.
-	
-		Start the process of marking Rev A bugs with the
-		AHD_SENT_SCB_UPDATE_BUG.
-	
-		Expand PPR option rules to include all supported
-		options.
-	
-		Correct the setting of precompensation values to
-		reflect fixes in the A2.
-	
-		Begin the process of handling PPR negotiations that
-		end in a bus free due to a change in IU_REQ.
-	
-		Enhance DFF mode specific initialization to include
-		the LongJmp address and the interrupts we want enabled.
-	
-		We must be in the SCSI mode to initialize the
-		negotiation table.
-	
-		Enable write flow control, read streaming and
-		information units if the SEEPROM tells us to enable
-		packetized.
-	
-	aic79xx.h:
-		Add AHD_SENT_SCB_UPDATE_BUG definition.
-	
-		Add SCB flags indicating packetized transaction and
-		a PPR that should result in a busfree.
-	
-	aic79xx.reg:
-		Add additional sequencer interrupt codes for packetized
-		failure modes.
-	
-		Allow the STACK and LASTSCB to be written two.  The
-		STACK needs to be written for longjump operations.
-		LASTSCB needs to be written for the AHD_SENT_SCB_UPDATE_BUG.
-	
-		Add PRECOMP constants.
-	
-		Move DATA_COUNT_ODD to per-mode scratch.
-	
-		Add STATUS_RCVD field to SCB_CONTROL.
-	
-		A status code of STATUS_PKT_SENSE indicates sense
-		data was recieved for this packetized transaction.
-	
-		Set the high bit of LONGJMP_ADDR to indicate that
-		it is no longer valid.
-	
-	aic79xx.seq:
-		Add setjmp/longjmp support.
-	
-		Implement AHD_SENT_SCB_UPDATE_BUG workaround.
-	
-		Break out first segment load, SCB completion,
-		residual calculation and save pointers so they
-		can be used for packetized operations.
-	
-		Make a first cut at sequencer interrupt services
-		for packetized operations.
-	
-	aic79xx_inline.h:
-	aic79xx_osm.c:
-		Use an SCB flag to indicate that a transaction is
-		packetized freeing up a bit in SCB_CONTROL for
-		STATUS_RCVD.
-	
-	aic79xx_pci.c:
-		Add compaq IDs.
-	
-	aicasm/aicasm_gram.y:
-	aicasm/aicasm_scan.l:
-	aicasm/aicasm_symbol.c:
-	aicasm/aicasm_symbol.h:
-		Add the ability to export a sequencer label to
-		the host driver.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#17 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#12 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#14 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#14 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#13 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#8 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#12 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#9 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#12 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#8 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#3 edit
-
-Change 475 by gibbs@overdrive on 2001/12/13 14:45:21
-
-	aic79xx_osm.h:
-		Put definition of KERNEL_VERSION into a more
-		appropriate place.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#3 edit
-
-Change 474 by gibbs@overdrive on 2001/12/13 14:43:24
-
-	Makefile:
-		Delete common makefile.  Each version of Linux is
-		so different that having one Makefile isn't practical.
-		Our build process has not referenced this version for
-		some time.
-	
-	aic7770_osm.c:
-		Pass port information into aic7770_config rather than
-		using a back door through the bus tag and handle to
-		get it.  This allows us to properly clean up mappings
-		should our attach fail.
-	
-		Port is now passed into aic7770_map_registers.
-	
-		Don't set platform data irq field until allocation is
-		successful.  This avoids freeing attempting to free
-		an IRQ we don't own during teardown of a failed attach.
-	
-	aic79xx_osm.c:
-		Clean up unmapping of SCB data.  In the single buffer case,
-		we now store the bus address for the buffer in the SCB
-		platform data so we don't need to recreate it from the
-		S/G list.  The S/G list may be changed by and auto request
-		sense operation, so it cannot be trusted.
-	
-		Formatting nits.
-	
-		Allow DT transfers to devices that only claim SCSI_2 if they
-		have the DT_REQ bit set in thier inquiry data.  This fixes
-		slow transfers on certain IBM drivers.
-	
-	aic79xx_osm.h:
-		Add powerof2 #define.
-	
-		Add buf_busaddr into the SCB platform data.
-	
-	aic79xx_osm_pci.c:
-		Correct comments to reflect reality.
-	
-	aic7xxx_osm.c:
-		Only define modversion info in this file.  This should fix
-		builds on 2.2.X kernels.
-	
-		Clean up unmapping of SCB data.  In the single buffer case,
-		we now store the bus address for the buffer in the SCB
-		platform data so we don't need to recreate it from the
-		S/G list.  The S/G list may be changed by and auto request
-		sense operation, so it cannot be trusted.
-	
-		Initialize platform IRQ field to unallocated value so we
-		don't inadvertantly free an IRQ we don't own in ahc_free().
-	
-		Use AHC_NUM_LUNS rather than hard coded value.
-	
-		Properly initialize sg_count prior to mapping any segments.
-	
-		Allow DT transfers to devices that only claim SCSI_2 if they
-		have the DT_REQ bit set in thier inquiry data.  This fixes
-		slow transfers on certain IBM drivers.
-	
-	aic7xxx_osm.h:
-		Add tasklet include and adjust for movement of files.	
-	
-		Add buf_busaddr to scb_platform_data.
-	
-		Add define for AHC_LINUX_NOIRQ.
-	
-		Adjust for new prototype for aic7770_map_registers.
-	
-	aic7xxx_osm_pci.c:
-		Properly release memory regions if we fail to ioremap them.
-		In general clean up how we allocate memory regions.
-	
-		Don't set platform data irq field until allocation is
-		successful.  This avoids freeing attempting to free
-		an IRQ we don't own during teardown of a failed attach.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/Makefile#9 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#10 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#81 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#74 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#28 edit
-
-Change 473 by gibbs@aslan on 2001/12/07 17:48:46
-
-	aic79xx.c:
-		Initialize new SG_STATE, per DFF, scratch ram variable.
-	
-		Display SG_STATE information when dumping card state
-		while in a DFF mode.
-	
-	aic79xx.reg:
-		Add SG_STATE and SAVED_MODE scratch ram variables.
-	
-	aic79xx.seq:
-		Move the return label to a location where there is
-		already a solicatry return instruction.
-	
-		Add code to service FIFOS for packetized transactions
-		to the main idle loop.
-	
-		We can't rely on ARRDONE after ARREN is disabled.  The
-		chip clears that bit at the same time ARREN is cleared.
-		Remove a comment about an optimization we could perform
-		if ARRDONE stayed set.
-	
-		Add a comment explaining why we must disable interrupts
-		when setting the mode pointer register.
-	
-		Have allocate FIFO service FIFOs so it can free them
-		up.  We still require both FIFOs to be free for a
-		non-packetized request.
-	
-		Optimize the delivery of an unpacketized cdb.  If we
-		are using SCB internal storage, we can bypass the
-		SG FIFO and set SHCNT directly.  This shaves ~12 clocks
-		of the start of the cdb transfer.
-	
-		Start using CLRCHN instead of RSTCHN.  There is still
-		more optimization that can occur in the non-packetized
-		path in terms of deferring DFIFO teardown.
-	
-		Modify data_group_idle_loop to service the other FIFO
-		as well as perform SCB prefetch/completion type
-		activities.
-	
-		Use SG_STATE to track S/G prefetch and FIFO servicing
-		requirements.
-	
-		Clear SG_STATE when the last segment is loaded or we
-		have completed this data group transfer (last segment
-		done or phasechange).
-	
-		If we go into an overrun condition, release the FIFO
-		by performing a reset channel if a FIFO is still
-		allocated.
-	
-		Change ultra2 -> data_group in all labels.
-	
-		Rely exclusively on SCSIEN going away to signal end
-		of a data transfer.  SCSIEN transitions on last segment
-		done, so testing for it in the loop too is superfluous.
-	
-	aic79xx_inline.h:
-		Add a better comment for why we read from the MODE_PTR
-		register after every SCB ram read.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#16 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#13 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#13 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#12 edit
-
-Change 470 by gibbs@aslan on 2001/12/04 17:09:19
-
-	aic79xx.seq:
-		Convert ccsg idle loop into a proceedure so it can
-		be used in places other than the main idle loop.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#12 edit
-
-Change 469 by gibbs@aslan on 2001/12/02 14:30:08
-
-	aic79xx.c:
-		Add a trace point for printing out saved pointer and residual
-		data from an SCB.
-	
-		Remove a hardware workaround that is no longer needed for
-		H2A2 and beyond.
-	
-		Quite some diagnostic code.
-	
-		Trim our downloaded constants down to only those needed.
-	
-		Add a #error if the number of downloaded constants grows
-		or shrinks from the number we currently initialize.
-	
-		Perform more robust calculations to determine the constants
-		used for S/G element prefetch.
-	
-	aic79xx.reg:
-		Add the saved/residual tracepoint to SEQINTCODE.
-	
-		Trim unused downloaded constants.
-	
-	aic79xx.seq:
-		Make use of SG_PREFETCH_CNT_LIMIT constant in handling
-		S/G fetch.  This ensures that a complete segment is
-		still left in the buffer prior to attempting to use it.
-	
-		Assume the kernel will start the DMA after a PDATA_REINIT
-		call.
-	
-		Correct some comments.
-	
-		Don't clear the data channel after a data group phase.
-		Defer this to await busfree.  This guarantees that SHADDR
-		is still valid should a saved data pointers occur.
-	
-	aic79xx_inline.h:
-		Add "ahd_inl_scbram()".
-	
-	aic79xx_osm.c:
-		Correct another case where we were still using an
-		ahd_syncrate.
-	
-	aicasm/aicasm_gram.y:
-		Don't complain about an immediate aliasing the accumulator
-		if the immediate is a downloaded constant.
-	
-	aicasm/aicasm_symbol.c:
-		Output a #define for the number of downloaded constants
-		the sequencer program is expecting.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#15 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#12 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#11 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#11 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#11 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#11 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.c#2 edit
-
-Change 468 by gibbs@overdrive on 2001/11/28 15:47:30
-
-	aic79xx_host.h:
-	aic79xx_osm.c:
-	aic79xx_osm.h:
-	aic79xx_osm_pci.c:
-	aic79xx_proc.c:
-		First cut at Linux U320 OSM layer.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_host.h#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#1 add
-
-Change 467 by gibbs@aslan on 2001/11/28 15:45:19
-
-	aic79xx_pci.c:
-		Correct include location under Linux.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#7 edit
-
-Change 466 by gibbs@aslan on 2001/11/28 15:43:12
-
-	aic79xx.c:
-	aic79xx.reg:
-		Linux's kernel ffs() implementation doesn't handle
-		constants properly on x86.  Compensate by using
-		a constant for the bit offset as well.  Grrrr!
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#14 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#11 edit
-
-Change 465 by gibbs@aslan on 2001/11/28 14:55:16
-
-	aic79xx.c:
-		Remove debugging printfs.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#13 edit
-
-Change 464 by gibbs@aslan on 2001/11/28 14:46:07
-
-	aic79xx.c:
-		Remove Debugger() statements that Linux doesn't understand.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#12 edit
-
-Change 463 by gibbs@overdrive on 2001/11/28 14:43:42
-
-	aic79xx_inline.h:
-		Avoid code bloat by only including 64bit S/G format
-		code if sizeof(bus_addr_t) > 4.  The compiler should
-		optimize out this code if this check against a constant
-		fails.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#10 edit
-
-Change 462 by gibbs@aslan on 2001/11/28 14:41:51
-
-	aic79xx.h:
-	aic79xx_pci.c:
-		Put PCI BAR offsets into a header where
-		all OSMs can see them.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#11 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#6 edit
-
-Change 461 by gibbs@aslan on 2001/11/27 17:52:25
-
-	aic79xx.h:
-		Pull ahd_inw/l/q and ahd_outw/l/q into Core header file.
-	
-	aic79xx_osm.h:
-		Mask off top port bit when doing I/O.
-	
-	ahd_pci.c:
-		Map a subregion for bshs[1], offset by 256 bytes, when we are
-		doing memory mapped I/O.  This compensates for the masking
-		of the port performed above.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#10 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/ahd_pci.c#2 edit
-... //depot/aic7xxx/freebsd/dev/aic7xxx/aic79xx_osm.h#2 edit
-
-Change 459 by gibbs@overdrive on 2001/11/27 13:32:05
-
-	Enable ID expansion.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#11 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#9 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#10 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#10 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#9 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#5 edit
-
-Change 458 by gibbs@overdrive on 2001/11/27 13:29:05
-
-	Allow FreeBSD and Linux to fully share core files.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#16 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.c#10 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#52 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#36 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#12 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#34 edit
-
-Change 454 by gibbs@overdrive on 2001/11/25 17:22:22
-
-	Complete the update of the assembler.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_gram.y#1 add
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_scan.l#1 add
-
-Change 453 by gibbs@overdrive on 2001/11/25 15:46:40
-
-	aic7xxx_osm.c:
-		Add a function to pull out user tag depth information.
-		Use it to limit the per-device tag depth.  The kernel
-		will never send us more commands than this limit anyway
-		since we honor this limit in select queue depths, but
-		this will make the information in /proc jibe with the
-		users settings and prevent some confusion.
-	
-		On kernels that support them (>= 2.4.0), use a tasklet
-		to flush any queued commands pent up in our per-device
-		queues
-	
-		Use an inline function, ahc_linux_next_device_to_run(),
-		to factor out some common code.
-	
-	aic7xxx_osm.h:
-		Add structures for our tasklet to the linux platform
-		softc.
-	
-	aicasm/Makefile:
-		Update for second parser/scanner in the assembler.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#80 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#73 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/Makefile#9 edit
-
-Change 452 by gibbs@overdrive on 2001/11/25 15:32:58
-
-	aic7770.c:
-		Disable chip interrupts early in chip attach.
-		We poke a few registers on the chip prior to
-		resetting it so this narrows the window where
-		an unexpected interrupt could hang us.
-	
-	               Convert all exported symbols to use an "ahc"
-		prefix to avoid conflicts with other drivers.
-	
-		Use a common SEEPROM checksum.
-	
-	aic7xxx.c:
-		Clear any pending message state in ahc_restart();
-	
-		Pass the ahc softc to ahc_update_residual.
-		ahc_update_residual calls ahc_calc_residual which
-		requires the softc to print path information if
-		debugging is enabled.
-	
-		Don't bother clearing message state just prior
-		to calling ahc_restart();
-	
-		Always perform a bus read prior to waiting in
-		a delay loop waiting for a bus write to take
-		effect.  This ensures that the first time
-		through the loop the delay occurs after the
-		write has taken effect.
-	
-		Style cleanup.
-	
-		Remove some initialization code left over from
-		a previous way of probing SCBs.
-	
-		Always clear parity error status after reading
-		any SCB or scratch locations that might be
-		uninitialized.  The debugging code that dumps
-		scratch ram contents could trigger such an
-		event.
-	
-		Initialize any scratch ram locations that might
-		be read (by our interrupt handler most likely)
-		prior to being initialized by our first transaction.
-		SAVED_SCSIID falls into this category, but there
-		may be others.
-	
-		Remove some unecessary code.  In this case, the
-		varaible "next" was initialized unecessarily which
-		could hide "use before initialization" bugs.
-	
-		Add some more information to ahc_dump_card_state();
-	
-	aic7xxx.h:
-		Update ahc_update_residual() declaration.
-	
-		Move AHC_DEBUG definitions to this header.
-	
-	aic7xxx.reg:
-	aic7xxx.seq:
-		Update for changes in the assembler.
-	
-	aic7xxx_93cx6.c:
-	aic7xxx_93cx6.h:
-		Prefix exported symbols with "ahc".
-	
-	aic7xxx_inline.h:
-		Update ahc_update_residual() definition.
-	
-		Target mode command completions come in through
-		the qinfifo, so we must read it even if we are
-		only executing the target role.
-	
-		Change to power state D0 prior to mapping our
-		registers.  BARs are usually cleared by a power
-		state change.
-	
-		Disable chip interrupts early in chip attach.
-		We poke a few registers on the chip prior to
-		resetting it so this narrows the window where
-		an unexpected interrupt could hang us.
-	
-		Use symbols prefixed by "ahc".
-	
-		Clear any parity errors that might occur while
-		trying to pull uninitialized SCB2 information.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#15 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#51 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#35 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#25 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#38 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#11 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.h#8 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#32 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#33 edit
-
-Change 451 by gibbs@overdrive on 2001/11/25 15:05:14
-
-	Teach the assembler about simple 'C' macros.
-	
-	Add a second parser/scanner to handle macro expansions.
-	
-	The arguments to patch functions are now specified in the
-	source file rather than be hard coded.
-	
-	Use the "driver neutral" "aic_patch_#_func() to denote the
-	static functions used to patch sequencer code.
-	
-	staticize all generated code to avoid conflicts when mutliple
-	drivers are compiled together.
-	
-	Teach the driver about register window modes.  Have the assembler
-	complain if a register is accessed in a window that is not supported
-	by the register.
-	
-	Allow '<<' and '>>' expressions.  They are evaluated during assembly.
-	
-	Complain if an expression used as an "immediate or the accumulator"
-	argument evaluates to 0.  0 is an alias for the accumulator in these
-	instruction formats and referencing the accumulator in these
-	situations is likely not the desired effect.
-	
-	BUGS: Line numbers get screwed up on program listing when macros are
-	      used.  The assembler should output the expanded code into the
-	      listing file so line numbers and instruction lines make sense.
-	      Line numbers in error messages may also be wrong for macros,
-	      but I haven't verified this.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#12 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#8 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#10 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#8 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#10 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#7 edit
-
-Change 448 by gibbs@aslan on 2001/11/19 21:22:51
-
-	Checkpoint.  Tagged queuing now works.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#9 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#8 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#9 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#9 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#8 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#4 edit
-
-Change 447 by gibbs@aslan on 2001/11/17 21:06:51
-
-	Checkpoint: U160 now operational.
-	
-	Deal with the NEG table.  And NEG table bugs.
-	
-	Implement IOCELL workarounds.
-	
-	Deal with missing DIS_MSGIN_DUAL in OPTIONMODE register.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#8 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#7 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#8 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#8 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#7 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#3 edit
-
-Change 445 by gibbs@aslan on 2001/11/14 16:49:32
-
-	Checkpoint.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#7 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#6 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#7 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#7 edit
-
-Change 444 by gibbs@aslan on 2001/11/13 21:49:20
-
-	Checkpoint.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#6 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#5 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#6 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#6 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#6 edit
-
-Change 442 by gibbs@aslan on 2001/11/13 14:07:10
-
-	Checkpoint.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#5 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#4 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#5 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#5 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#5 edit
-
-Change 440 by gibbs@aslan on 2001/11/08 21:14:12
-
-	Checkpoint.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#4 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.h#3 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#4 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#4 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#4 edit
-
-Change 439 by gibbs@aslan on 2001/11/07 18:54:07
-
-	Checkpoint.  Selection Timeout path now operates.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#3 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#3 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#3 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#3 edit
-
-Change 438 by gibbs@aslan on 2001/11/07 17:28:10
-
-	Checkpoint.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#2 edit
-
-Change 437 by gibbs@aslan on 2001/11/07 15:41:15
-
-	Checkpoint.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.h#2 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#2 edit
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#2 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#2 edit
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#2 edit
-
-Change 435 by gibbs@aslan on 2001/10/25 13:28:33
-
-	Initial 790X Core driver import.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic79xx.c#1 add
-... //depot/aic7xxx/aic7xxx/aic79xx.h#1 add
-... //depot/aic7xxx/aic7xxx/aic79xx.reg#1 add
-... //depot/aic7xxx/aic7xxx/aic79xx.seq#1 add
-... //depot/aic7xxx/aic7xxx/aic79xx_inline.h#1 add
-... //depot/aic7xxx/aic7xxx/aic79xx_pci.c#1 add
-
-Change 421 by gibbs@overdrive on 2001/10/11 15:33:59
-
-	Bump version to 6.2.4.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#72 edit
-
-Change 420 by gibbs@overdrive on 2001/10/11 15:33:30
-
-	aic7xxx_osm.c:
-		Move the include of linux/module.h to our osm header file.
-	
-		Add a MODULE_LICENSE entry.
-	
-		Don't forget to include the high address bits in
-		calls to pci_unmap_single().
-	
-		Fix a typo in a comment.
-	
-		Use hex instead of decimal when reporting return codes
-		to our exception handling routines.
-	
-	aic7xxx_osm.h:
-		Include, unconditionally, linux/module.h.
-	
-	aic7xxx_osm_pci.c:
-		Add a MODULE_DEVICE_TABLE entry for our PCI ids.
-	
-		Formatting cleanup.
-	
-		Use a simpler way of expressing "all bits set in something
-		the size of a bus_addr_t" without getting compiler warnings
-		on some platforms.
-	
-		Kill an unused variable.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#79 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#71 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#27 edit
-
-Change 419 by gibbs@overdrive on 2001/10/11 15:21:15
-
-	aic7xxx.c:
-		Force renegotatiation of transfer parameters on the
-		next command to a device after a selection timeout or
-		a parity error.
-	
-		Fix a typo in a comment.
-	
-		Put SCBs that aren't in the scbindex table and not already
-		in the free list, back into the free list.  This can happen
-		in certain "SCB queued twice for abort processing" cases.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#50 edit
-
-Change 408 by gibbs@overdrive on 2001/09/13 17:49:29
-
-	Still part of the 6.2.3 release...
-	
-	aic7xxx.c:
-		Export ahc_abort_scbs() for use by OSMs.
-	
-		In ahc_abort_scbs(), only remove entries from
-		the busy target table that match the abort
-		criteria.  In the past, we might take out any
-		entry for a particular target.
-	
-		In ahc_abort_scbs() only search the disconnected
-		list and busy target table if the role is not
-		ROLE_TARGET.
-	
-	aic7xxx.h:
-		Export ahc_abort_scbs() for use by OSMs.
-	
-	aic7xxx.reg:
-		Add a definition for the SCSI offset count in
-		SSTAT3 for U2+ adapters.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#49 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#34 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#24 edit
-
-Change 391 by gibbs@overdrive on 2001/09/12 13:14:51
-
-	Update version for 6.2.3 driver release.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#70 edit
-
-Change 390 by gibbs@overdrive on 2001/09/12 13:14:00
-
-	Update copyright to reflect new binary distribution disclaimer
-	       clause (if you choose BSD license terms) and Adaptec copyright.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#9 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#5 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#78 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#69 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#26 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#13 edit
-
-Change 389 by gibbs@overdrive on 2001/09/12 13:07:18
-
-	Update copyright to reflect new binary distribution disclaimer
-	clause and Adaptec copyright.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#14 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#48 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#33 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#23 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#37 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#10 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.h#7 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#31 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#32 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#11 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#7 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#9 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#7 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#7 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#9 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#6 edit
-
-Change 387 by gibbs@overdrive on 2001/09/11 15:31:45
-
-	aic7xxx_inline.h:
-		Remove spurious '{' that only came into effect if
-		target mode was compiled in.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#30 edit
-
-Change 386 by gibbs@overdrive on 2001/09/11 14:19:51
-
-	aic7xxx_osm.c:
-		Only run our shutdown hook for the SYS_DOWN and
-		SYS_HALT events.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#77 edit
-
-Change 385 by gibbs@overdrive on 2001/09/11 14:18:38
-
-	aic7xxx.h:
-		Add residual information to struct target_data to
-		allow residual information to be handled in the
-		same way as for the initiator role.  Prior to this
-		fix, the status byte field was overwritten when the
-		residual count was saved to the SCB assuming the
-		residual was non-zero.
-	
-	aic7xxx.reg:
-		Adjust for change in SCB layout for target mode.
-	
-	aic7xxx.seq:
-		Adjust for change in SCB layout for target mode.
-	
-		Send an ignore wide residue message if we are acting
-		as a target in wide mode and complete a data-in phase
-		with an odd data count.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#32 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#22 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#36 edit
-
-Change 382 by gibbs@overdrive on 2001/09/10 17:31:46
-
-	aic7xxx_osm.c:
-		Initialize our host template's "max_lun" field.  This may
-		correct an issue with probing big, multi-lun, devices in
-		Linux post 2.4.3.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#76 edit
-
-Change 381 by gibbs@overdrive on 2001/09/10 16:29:53
-
-	aic7xxx.c:
-	aic7xxx.h:
-		Add a new constant, AHC_SCB_MAX_ALLOC, which indicates
-		how many of the AHC_SCB_MAX scbs available on the card
-		we can actually allocate.  This can be at most
-		AHC_MAX_QUEUE+1.  The FreeBSD OSM, by virtue of CAM, already
-		enforced this limit.  This change ensures that all OSMs
-		are restricted to this limit.
-	
-	aic7xxx_inline.h:
-		If CMDCMPLT is active in intstat, check all completion queues.
-		This corrects a race condition when target mode is enabled
-		that could allow us to miss running a queue that just received
-		a new command.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#47 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#31 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#29 edit
-
-Change 357 by gibbs@overdrive on 2001/09/06 13:25:10
-
-	aic7xxx_osm.h:
-		Add constants related to the "periodic_otag" feature.
-	
-		Increase the ordered tag threshold to 500 commands.
-	
-		Issue an mb() even when using PIO to talk to the card.
-		This may be necessary on platforms other than intel.
-	
-		Bump driver version to 6.2.2.
-	
-	aic7xxx_osm.c:
-		Remove comments/globals referencing unused driver options.
-	
-		Hook up the following driver options:
-			no_probe	Disable EISA/VLB controller probing
-			no_reset	Supress initial bus resets
-			extended	Enable extended geometry on
-					all controllers
-			periodic_otag	Send an ordered tagged transaction
-					periodically to prevent tag starvation.
-					This may be required by some older disk
-					drives/RAID arrays. 
-			reverse_scan	Sort PCI devices highest Bus/Slot to
-					lowest 
-	
-		Don't attempt to set the PCI dma mask if we're an EISA/VLB
-		controller.
-	
-		Dump controller state on any abort/bdr instead of only when
-		the user has turned on the "verbose" option.  This should
-		facilitate the generation of user bug reports.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#75 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#68 edit
-
-Change 356 by gibbs@overdrive on 2001/09/06 13:16:05
-
-	Only trust sub-device information on Adaptec cards.  It seems
-	that many motherboard implementations do not follow the Adaptec
-	sub-device id spec.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#31 edit
-
-Change 340 by gibbs@overdrive on 2001/08/24 11:24:25
-
-	aic7xxx_osm.c:
-		Remove a no-longer relevant comment.
-	
-		Add information about our module parameters that
-		can be displayed by modinfo.
-	
-		Use the channel letter, rather than the number, as
-		we do in all other displays of this information.
-	
-		Never attempt PPR messages on a device that claims
-		to be SCSI2.  Jaz drives hang, rather than reject
-		the message, and sending these messages to SCSI2
-		devices is just too dangerous.
-	
-		Whitespace cleanup.
-	
-	aic7xxx_osm.h:
-		Include endian information for use by aicasm_insformat.h.
-	
-	aic7xxx_osm_pci.c:
-		Always reserve both our memory and I/O port range to guard
-		against other devices attaching to these same addresses.
-		We still only use one of the two regions for accessing the
-		card.
-	
-	aicasm/Makefile:
-		Add explicit dependencies on y.tab.h so it is rebuilt
-		prior to any files, even generated ones, that need it.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#74 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#67 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#25 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/Makefile#8 edit
-
-Change 339 by gibbs@overdrive on 2001/08/24 11:17:35
-
-	aic7xxx.c:
-		Re-intialize LASTPHASE everytime we restart the sequencer.
-		This should make the value of LASTPHASE fully deterministic.
-	
-		Correct target mode handling of Abort and Abort Tag messages.
-		The sequencer now sets TARGET_MSG_PENDING whenever it runs
-		into an unexpected message while parsing "ident" messages
-		during a selection.  We have to clear this flag whenever we
-		stop processing messages.  We also need to restart the sequencer
-		for any abort message so that we return to busfree.
-	
-		Send the tag number along with the abort tag message immediate
-		notification message.
-	
-		The construct "foo(i++, i++, i++);" is not guaranteed to
-		give "expected" results by the C standard.  Change some
-		diagnostic code to avoid this.
-	
-		Correctly set ahc->unpause to include the IRQMS bit on
-		non-PCI platforms.
-	
-	aic7xxx.reg:
-		Add TARGET_MSG_PENDING bit to the SEQ_FLAGS2 register.
-	
-	aic7xxx.seq:
-		During identify message processing, setup SAVED_LUN.  We
-		may need it to handle certain types of messages.
-	
-		Handle unexpected messages that have already been REQ'ed
-		as well as those that have not been REQ'ed but should be
-		handled due to ATNI being active.
-	
-		Postpone the "queue full" determination until we are about
-		to transition to command phase.  This should give the
-		initiator the ability to abort transactions even if our
-		queue would otherwise be full.
-	
-	aic7xxx_pci.c:
-		Take another stab at validating the 9005 subdevice information
-		prior to using it.  We now ensure that the device type stated
-		in the device field is compatible with the one expressed in
-		the subdevice field.  This should allow the latest report
-		of a "missing channel" to be probed again.
-	
-	aicasm/aicasm.c
-		Pull the platform endian file for userland operations from
-		here, so that the insformat header, which is shared with the
-		kernel, never gets the wrong file.  The kernel driver will
-		deal with getting the correct endian values in its platform
-		specific file.
-	
-	aicasm/aicasm_insformat.h:
-		String #include of endian header files.  This is now handled
-		by the client of this file.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#46 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#21 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#35 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#30 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#10 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#6 edit
-
-Change 330 by gibbs@overdrive on 2001/08/16 15:16:36
-
-	"GNU Public License" -> "GNU General Public License"
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#8 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#73 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#66 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#24 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#12 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#11 edit
-
-Change 329 by gibbs@overdrive on 2001/08/16 15:12:51
-
-	"Gnu Public License" -> "Gnu General Public License"
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#13 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#45 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#30 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#20 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#34 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#9 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.h#6 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#28 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#29 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#9 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#6 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#8 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#5 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#6 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#8 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#5 edit
-
-Change 323 by gibbs@overdrive on 2001/08/05 15:00:59
-
-	aic7xxx_linxu.c:
-	aic7xxx_osm_pci.c:
-		pci_set_dma_mask() became available in 2.4.3, not 2.4.0.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#72 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#23 edit
-
-Change 322 by gibbs@overdrive on 2001/08/05 14:58:46
-
-	aic7xxx.c:
-		Correct an off by one in our critical section handling.
-		SEQADDR always reads the next instruction to execute,
-		so we must subtract one from its value before making
-		comparisons with entries in the critical section table.
-	
-		Kill a "too verbose" bootverbose printf.
-	
-		Print a few additional registers whenever we dump
-		card state.
-	
-		Show the SCB_CONTROL and SCB_TAG values for all pending
-		SCBs in card SCB ram when dumping card state.
-	
-	aic7xxx.seq:
-		Fix a bug introduced while optimizing the SDPTR path.
-		We would ack the SDPTR message twice on Ultra2 or better
-		chips if it occurred after all data had been transferred
-		for a transaction.
-	
-		Change our workaround for the PCI2.1 retry bug on some
-		chips.  Although the previous workaround was logically
-		correct, its faster method of draining the FIFO seemed
-		to occassionally confuse the FIFO state.  We now drain
-		the FIFO at half the speed which avoids the problem.
-	
-	aic7xxx_pci.c:
-		Chips with the PCI 2.1 retry bug can't handle a 16byte
-		cachesize.  If the cachesize is set to 16bytes, drop
-		it to 0.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#44 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#33 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#28 edit
-
-Change 317 by gibbs@overdrive on 2001/07/18 16:19:54
-
-	Bump version to 6.2.0 Release.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#65 edit
-
-Change 314 by gibbs@overdrive on 2001/07/18 14:17:17
-
-	Remove a stray '{' after a #endif.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#27 edit
-
-Change 311 by gibbs@overdrive on 2001/07/18 14:14:39
-
-	Only set AHC_RUN_TQINFIFO if we are performing the target role.
-	Otherwise there is no guarantee that the tqinfifo is even allocated.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#26 edit
-
-Change 309 by gibbs@overdrive on 2001/07/17 18:10:35
-
-	aic7xxx_osm.h:
-		Add definition for BUS_SPACE_MAXADDR_32BIT.  This
-		is now used in our bus_dma_tag_create() operations.
-	
-		Remove a spurious return(0) I mistakenly added when
-		"fixing" compiler warnings for NOTREACHED code.
-	
-	aic7xxx_osm_pci.c:
-		Quite a compiler warning for code that cannot be reached
-		unless sizeof(dma_addr_t) > 4.  We now mask our 39bit
-		mask with a mask based on the size of dma_addr_t so
-		we cannot have an overflowing assignment the compiler
-		will complain about.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#64 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#22 edit
-
-Change 308 by gibbs@overdrive on 2001/07/17 18:06:31
-
-	aic7xxx.c:
-		Enforce a 4GB boundary on all DMA transactions.  Due
-		to 32bit DAC restrictions, 64bit addressed operations
-		cannot cross a 4GB boundary.  This is enforced manually
-		in the Linux driver as bus tag boundaries are not honored,
-		but for FreeBSD, the tags are used by the OS dma map
-		routines to enforce the limits.
-	
-		Bus resets (initiated or incoming) clear the ENSELI bit
-		in the SCSISEQ register.  For this reason, we cannot
-		defer the re-enabling of bus reset interrupts in target
-		mode - select-ins might get disabled and we'd never
-		know.
-	
-	aic7xxx.seq:
-		Remove sequencer code to re-enable bus reset interrupts
-		when we are selected as a target.
-	
-	aic7xxx_inline.h:
-		Correct calls to ahc_dmamap_sync.  In Linux these are
-		no-ops, so the fact that we didn't reference our maps
-		correctly didn't show up.
-	
-	aicasm/aicasm.c:
-	aicasm/aicasm_symbol.c:
-		Use queue macros instead of groveling through queue
-		data structures manually.
-	
-		Fix a few style bugs.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#43 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#32 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#25 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#8 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#7 edit
-
-Change 307 by gibbs@overdrive on 2001/07/16 17:31:46
-
-	aic7xxx.c:
-		style(9) fix.
-	
-	aic7xxx.seq:
-		Correct high address support for non-Ultra2 chips.
-	
-		Bring back a fix for flaky external SRAM support
-		on the aic7895.
-	
-	aic7xxx_inline.h:
-		In ahc_update_residual(), don't bother setting
-		a 0 length residual.  The residual is cleared
-		prior to starting the command.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#42 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#31 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#24 edit
-
-Change 306 by gibbs@overdrive on 2001/07/16 17:26:24
-
-	aic7xxx_osm.c:
-		Clean out PCMCIA defines.  This driver does not
-		require any special compile environment to serve
-		cardbus cards.
-	
-		Clear residual data prior to starting a new SCB.
-		The calculate residual code now only sets residual
-		information should a residual exist.
-	
-		Remove a redundant assignment to platform_data->xfer_len.
-		Our map_seg routine already updates this field.
-	
-		Manually set the DRIVER_SENSE bit in the result word
-		of commands that have had auto-sense.
-	
-	aic7xxx_osm.h:
-		Kill silly compiler warnings for no return with value
-		from functions that panic.
-	
-	aic7xxx_osm_pci.c:
-		Use more formal "ULL" designation on some constants.
-	
-	cam.h:
-		Remove unused, at least in Linux, definition of
-		CAM_SIM_QUEUED.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#71 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#63 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#21 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#10 edit
-
-Change 303 by gibbs@overdrive on 2001/07/11 17:51:28
-
-	Bump version to 6.2.0-BETA1.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#62 edit
-
-Change 302 by gibbs@overdrive on 2001/07/11 17:47:06
-
-	Remove another diagnostic printf.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#20 edit
-
-Change 301 by gibbs@overdrive on 2001/07/11 17:35:55
-
-	Place a diagnostic behind bootverbose.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#27 edit
-
-Change 300 by gibbs@overdrive on 2001/07/11 17:35:34
-
-	Add VERSION statements.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#19 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#30 edit
-
-Change 299 by gibbs@overdrive on 2001/07/11 17:34:54
-
-	Remove debugging printfs.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#70 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#19 edit
-
-Change 297 by gibbs@overdrive on 2001/07/10 18:23:07
-
-	Add support for the "VERSION" keyword.
-	
-	Print out all version information in generated files.
-	
-	Fix a bug in the handling of "include" statements.
-	For some reason this didn't show up until the version
-	changes were added.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#7 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#5 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#7 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#5 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#6 edit
-
-Change 295 by gibbs@overdrive on 2001/07/10 15:27:47
-
-	aic7xxx_osm.c:
-		Don't panic if the system decides to have us select
-		the queue depth for a non-existant device.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#69 edit
-
-Change 293 by gibbs@overdrive on 2001/07/10 14:23:44
-
-	aic7xxx_osm.c:
-		Properly ignore inquiry responses for VPD data or where
-		the amount of data that is actually transferred is not
-		enough for us to pull transfer negotiation information.
-	
-		Add synchronization of datastructures we share with
-		the hardware.
-	
-		Add a per-segment mapping helper function that deals
-		with 39bit addressing issues and complete 39bit
-		support.
-	
-		Fool the OS into always allocating our shared device/kernel
-		memory below the 4GB mark by changing our dma mask on
-		the fly.
-	
-		Add a method for determining the amount of memory in
-		the system.
-	
-		Run devices in a Round Robin fashion to ensure fairness.
-	
-		Correct code that handles temporary SCB resource shortages.
-	
-		Don't report bus resets until we have successfully registered
-		our host structure.
-	
-	aic7xxx_osm.h:
-		Add synchronization primatives.
-	
-		Add definition for the inquiry command for use in
-		our filtering function.
-	
-		Use system defined mb() macro rather than rolling our
-		own.  Allow memory mapped I/O on the ia64.
-	
-	aic7xxx_osm_pci.c:
-		Enable 39Bit addressing if the system supports large
-		addresses on the platform and we have more than 2GB
-		of memory installed.  Some systems move memory to
-		after the 4GB mark, reserving the 2-4GB range for
-		device memory mapping.
-	
-		Clean up a compile error when memory mapped I/O is
-		not enabled.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#68 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#61 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#18 edit
-
-Change 291 by gibbs@overdrive on 2001/07/10 13:43:58
-
-	aic7770.c:
-		Set fields directly in the softc rather than indirect
-		through the probe config structure.
-	
-	aic7xxx.c:
-		Add synchronization calls for data structures in 
-		system memory that are shared between the kernel
-		driver and the controller.
-	
-		Several corrections to 39bit address support:
-			o 39bit support is a flag not a feature
-			  in the ahc softc.
-	
-			o Perform endian conversions for high
-			  address bits.
-	
-		Prevent PPR messages from being issued when acting
-		as a target.
-	
-		Add diagnostics in ahc_search_qinfifo() for tracking
-		down qinfifo corruption issues.
-	
-	aic7xxx.h:
-		Store a pointer to the sg_map_node in the scb to
-		allow scatter gather lists to be synced.
-	
-	aic7xxx.seq:
-		39bit support is a flag not a feature in the ahc softc.
-	
-	aic7xxx_inline.h:
-		Add inlines to facilitate synchronization operations.
-	
-		Synchronize SCBs anytime we perform a lookup from
-		SCB ID to pending SCB and prior to queuing SCBs to
-		the adapter.
-	
-		Synchronize the first qoutfifo and tqinfifo when
-		checking for newly completed transactions.
-	
-		Fix several bugs in the spurious interrupt handling
-		in our interrupt handler.  Hopefully this will stop
-		the reports of spurious PCI errors.
-	
-	aic7xxx_pci.c:
-		Add pci 64bit bus status bit definition for the
-		DEVCONFIG register.
-	
-		Be even more careful in checking that a 9005 subdevice
-		ID is valid prior to processing it.  This should prevent
-		us from dropping the second channel on some MB controllers.
-	
-		Set fields directly in the softc rather than indirect
-		through the probe config structure.
-	
-		Set the DAC enable bit when in 39bit addressing mode.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#12 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#41 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#29 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#29 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#23 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#26 edit
-
-Change 277 by gibbs@overdrive on 2001/06/18 14:52:58
-
-	Switch to round-robin scheduling of devices to ensure fairness
-	during resource contention.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#67 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#60 edit
-
-Change 276 by gibbs@overdrive on 2001/06/18 14:47:51
-
-	aic7xxx.c:
-		Spelling fixes.
-	
-		Handling data pointers reinitialization requests
-		from the sequencer.  This only occurs should the
-		target take us into the data phase twice with
-		an interviening non-data phase.
-	
-		On a data overrun, clear the channel of all preloaded
-		S/G segments if we are an Ultra2 controller.  This
-		error path does not go through the normal dma shutdown
-		path, so we have to clear the S/G fifo while the kernel
-		is recording the overrun event.
-	
-		Clear AHC_ULTRA rather than deal with the AHC_ULTRA_DISABLED
-		flag.
-	
-		Fixup a few cases where we were not properly byte swapping
-		S/G element data in the ignore wide residue handler.   Update
-		this routine for 39bit addressing support.  Remove the
-		reload of the explicit HADDR registers.  We now do this at
-		the time we re-enter the dataphase, which, in 90% of the
-		cases, will never happen.
-	
-		Add the ahc_reinitialize_dataptrs() routine.  This is called
-		to fixup the dma engine's data pointers should we re-enter
-		a data phase with some interveining phase.  This used to
-		be handled in the sequencer, but is so rare (i.e. almost
-		never happens), that there is little reason to waste
-		sequencer space on it.
-	
-	aic7xxx.h:
-		Remove AHC_ULTRA_DISABLED ahc_flag.
-	
-		Add AHC_39BIT_ADRESSING ahc_flag.
-	
-	aic7xxx.reg:
-		Add the DSCOMMAND1 register which holds the high
-		address load select bits.
-	
-		Add the PDATA_REINIT sequencer interrupt code.
-		This is hit should we re-enter a data phase and
-		need help from the kernel to restore the data ptrs.
-	
-		Remove the RESIDUAL sequencer interrupt code.
-		It has not been used for some time.
-	
-	aic7xxx.seq:
-		Spelling fixes.
-	
-		Streamline the ULTRA2 idle loop.  The HADDR register
-		is not directly shaddowed, so we can read the contents
-		placed there by the bmov out of CCSGRAM.
-	
-		Remove data_phase_reinit.  This is now handled by a
-		sequencer interrupt request to the kernel.
-	
-		Remove the assert method.  We now do the test inline
-		which saves two instructions per call.
-	
-		Add 39bit addressing support.
-	
-		Add shortcuts for updating our residual pointers and
-		handling SDPTR messages when we are at the end of
-		a transfer.
-	
-	aic7xxx_inline.h:
-		Change the way that unsolicited interrupts are counted.
-		We now only increment and/or test the unsolicited interrupt
-		count if we see that we don't have any conventional
-		interrupts pending.  More importantly, everytime we do
-		unsolicited interrupt processing, we clear the count.
-		This prevents us from constantly performing unsolicited
-		interrupt handling.
-	
-	aic7xxx_pci.c:
-		Set CLRPARERR in CLRINT for all PCI error status.  The
-		manuals are not sufficiently clear on which status code
-		cause parity errors to be set, so we play it safe.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#40 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#28 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#18 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#28 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#8 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#22 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#25 edit
-
-Change 207 by gibbs@overdrive on 2001/05/01 16:18:08
-
-	Bump driver version to 6.1.13.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#59 edit
-
-Change 206 by gibbs@overdrive on 2001/05/01 16:16:11
-
-	aic7xxx.seq:
-		For chips without S/G pipelining, we can only ack the
-		SDPTR message after SHADDR has been saved.  On these
-		chips, SHADDR increments with every bus transaction,
-		even PIO.  This corrects a data corruption bug in the
-		last version of the sequencer for non-ULTRA2 chips.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#27 edit
-
-Change 205 by gibbs@overdrive on 2001/05/01 15:04:36
-
-	aic7xxx_osm.c:
-		Add support for the 2.4.4 scsi_set_pci_device API.
-	
-	aic7xxx_osm.h:
-		Move the conditional declaration of KERNEL_VERSION to
-		the top of aic7xxx_osm.h so it is defined before
-		its first usage.
-	
-		Remove late conditional include of linux/version.h.  We
-		already include it unconditionally at the top of this file.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#66 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#58 edit
-
-Change 203 by gibbs@overdrive on 2001/05/01 13:07:13
-
-	Makefile:
-		Add the current directory to the include path.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/Makefile#7 edit
-
-Change 202 by gibbs@overdrive on 2001/05/01 13:02:15
-
-	aic7xxx_osm.c:
-		Don't unregister from the reboot notification chain
-		from within our handler.  The routine that calls down
-		the chain does not guard against removals.
-	
-		Create a simq_freeze method as a compliment to the
-		simq_release method.  This method assumes that the
-		ahc lock is held prior to call.  The release method
-		requires a lock as it is only called from a timeout
-		handler.  The release method now guards (other than
-		for a small race that cannot be avoided without a
-		mid-layer change) unblocking and blocking multiple times.
-		Blocking is either on or off; the mid-layer does not
-		have semaphore type semantics for this feature.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#65 edit
-
-Change 196 by gibbs@overdrive on 2001/04/27 14:24:13
-
-	Bump version number to 6.1.12 for next release.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#57 edit
-
-Change 195 by gibbs@overdrive on 2001/04/27 14:23:37
-
-	aic7xxx_osm.c:
-		current -> curr
-	
-		Implement a kludge to deal with inquiry requests that
-		are not large enough for us to pull the spi3 bits.
-		In this case, we assume that a device that tells us
-		they can provide inquiry data that spans the SPI3
-		bits can handle a PPR request.  If the inquiry
-		request has sufficient buffer space to cover these
-		bits, we check them to see if any ppr options are
-		available.  This corrects the drop to async narrow
-		for U160 devices during a cdrecord bus scan.
-	
-	aic7xxx_osm.h:
-		Remove the kludge to undefine "current".  We've renamed
-		any effected fields in the driver to avoid a conflict.
-	
-		dma_addr_t appeared in 2.2.18, not 2.2.17.
-	
-	aic7xxx_proc.c:
-		current -> curr
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#64 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#56 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#11 edit
-
-Change 194 by gibbs@overdrive on 2001/04/27 14:19:04
-
-	aic7xxx.c:
-		current->curr to avoid Linux's use of current as a
-		#define for the current task on some architectures.
-	
-		Add a helper function, ahc_assert_atn(), for use in
-		message phases we handle manually.  This hides the fact
-		that U160 chips with the expected phase matching disabled
-		need to have SCSISIGO updated differently.
-	
-		if (ahc_check_residual(scb) != 0)
-			ahc_calc_residual(scb);
-		else
-			ahc_set_residual(scb, 0);
-	
-		becomes:
-	
-		ahc_update_residual(scb);
-	
-		Modify scsi parity error (or CRC error) handling to
-		reflect expected phase being disabled on U160 chips.
-	
-		Move SELTO handling above BUSFREE handling so we can
-		use the new busfree interrupt behavior on U160 chips.
-	
-		Correct a long standing but latent bug in
-		ahc_find_syncrate().  We could choose a DT only
-		rate even though DT transfers were disabled.
-	
-		When displaing controller characteristics, include the
-		speed of the chip.  This way we can modify the transfer
-		speed based on optional features that are enabled/disabled
-		in a particular application.
-	
-	aic7xxx.h:
-		The real 7850 does not support Ultra modes, but there are
-		several cards that use the generic 7850 PCI ID even though
-		they are using an Ultra capable chip (7859/7860).  We start
-		out with the AHC_ULTRA feature set and then check the
-		DEVSTATUS register to determine if the capability is really
-		present.
-	
-		current -> curr
-	
-		ahc_calc_residual() is no longer static allowing it to
-		be called from ahc_update_residual() in aic7xxx_inline.h.
-	
-	aic7xxx.reg:
-		Add a combined DATA_PHASE mask to the SCSIPHASE register
-		definition to simplify some sequencer code.
-	
-	aic7xxx.seq:
-		Take advantage of some performance features available only
-		on the U160 chips.  The auto-ack feature allows us to ack
-		data-in phases up to the data-fifo size while the sequencer
-		is still setting up the DMA engine.  This greatly reduces
-		read transfer latency and simplifies testing for transfer
-		complete (check SCSIEN only).  We also disable the expected
-		phase feature, and enable the new bus free interrupt behavior,
-		to avoid a few instructions.
-	
-		Re-arrange the Ultra2+ data phase handling to allow us to
-		do more work in parallel with the data fifo flushing on a
-		read.
-	
-		On an SDTR, ack the message immediately so the target can
-		prepare the next phase or message byte in parallel with 
-		our work to honor the message.
-	
-	aic7xxx_inline.h:
-		ahc_update_residual() now looks at the residual valid
-		flag in an endian safe way.  This fixes a residual bug
-		on the PPC.
-	
-	aic7xxx_pci.c:
-		Correct a few product strings.
-	
-		Enable several U160 performance enhancing features.
-	
-		Modify Ultra capability determination so we will enable
-		Ultra speeds on devices with a 7850 PCI id that happen
-		to really be 7859 or 7860s.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#39 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#27 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#17 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#26 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#21 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#24 edit
-
-Change 189 by gibbs@overdrive on 2001/04/09 14:52:16
-
-	Bump version number to 6.1.11 for latest release.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#55 edit
-
-Change 188 by gibbs@overdrive on 2001/04/06 16:38:18
-
-	aic7xxx.c:
-		In ahc_build_transfer_msg() filter the period and
-		ppr_options prior to deciding whether a PPR message
-		is required.  ppr_options may be forced to zero
-		which will affect our decision.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#38 edit
-
-Change 187 by gibbs@overdrive on 2001/04/06 15:54:25
-
-	aic7xxx_osm.c:
-		Don't try negotiations that require PPR messages
-		if bus reset is enabled.  We'll wait until we
-		successfully retrieve Inquiry data so we can make
-		an informed decision.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#63 edit
-
-Change 186 by gibbs@overdrive on 2001/04/05 16:29:33
-
-	aic7xxx_osm.h:
-		Bump version number to 6.1.10.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#54 edit
-
-Change 185 by gibbs@overdrive on 2001/04/05 16:29:00
-
-	aic7xxx_osm.c
-		Use scsi_(un)block_requests() to effect a freeze of the
-		entire controller queue.  Scsi_unblock_requests() has been
-		modified to actually run any stalled queues in the 2.4.X
-		kernel sources.  For 2.2.X, scsi_(un)block_requests() was
-		implemented.  Since we now rely on this functionality,
-		only patch updates to the driver will be provided from
-		here on out.
-	
-		With this change, our bus settle delay can be of any
-		length and still avoid triggering command timeouts from
-		the midlayer.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#62 edit
-
-Change 182 by gibbs@overdrive on 2001/04/04 16:32:27
-
-	Bump version number to 6.1.9 for latest release.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#53 edit
-
-Change 181 by gibbs@overdrive on 2001/04/04 16:31:50
-
-	aic7xxx_osm.c:
-		Correct a bug in ahc_done() that prevented us from running
-		the in-core device queue anytime the physical device was
-		idle.  This caused problems anytime the driver received
-		more than one transaction for a device that does not
-		support tagged transactions.  Unless another transaction
-		was queued to us to kick the queue, the transaction would
-		never get run.  Zip drives are the most commonly found
-		device that was affected by this bug.
-	
-		CONFIG_AIC7XXX_RESET_DELAY -> CONFIG_AIC7XXX_RESET_DELAY_MS
-		Too many people have stale settings under the old config
-		option name for us to use it with a different meaning.
-		The setting is now in milli-seconds to allow more granular
-		control so stale values resulted in an extremely short bus
-		settle delay.
-	
-		Add a shutdown hook that resets all of the controllers
-		to a safe state.
-	
-		Update for changes in the way negotiation prameters are
-		communicated with the Core.
-	
-		Correct a function name in a printf.
-	
-		tmode_tstate -> ahc_tmode_tstate.
-	
-	aic7xxx_proc.c:
-		tmode_tstate -> ahc_tmode_tstate.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#61 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#10 edit
-
-Change 180 by gibbs@overdrive on 2001/04/04 16:22:29
-
-	aic7770.c:
-		Register our interrupt driver prior to enabling our
-		Bus drivers.  This is just added paranoia.
-	
-	aic7xxx.c:
-		Namespace cleanup continues:
-			tmode_tstate -> ahc_tmode_tstate
-			tmode_lstate -> ahc_tmode_lstate
-	
-		Clean up the check condition path by branching early rather
-		than indenting a giant block of code.
-	
-		Add support for target mode initiated sync negotiation.
-		The code has been tested by forcing the feature on for
-		all devices, but for the moment is left inaccesible until
-		a decent mechanism for controlling the behavior is complete.
-		Implementing this feature required the removal of the
-		old "target message request" mechanism.  The old method
-		required setting one of the 16 bit fields to initiate
-		negotiation with a particular target.  This had the nice
-		feature of being easy to change the request and have it
-		effect the next command.  We now set the MK_MESSAGE bit
-		on any new command when negotiation is required.  When
-		the negotiation is successful, we walk through and clean
-		up the bit on any pending commands.  We have to walk
-		the commands to reset the SCSI syncrate values already,
-		so no additional work is required.  The only drawback of
-		this approach is that the negotiation is deferred until
-		the next command is queued to the controller.  On the plus
-		side, we regain two bytes of sequencer scratch ram and 6
-		sequencer instructions.
-	
-		When cleaning up a target mode instance, never remove the
-		"master" target mode state object.  The master contains
-		all of the saved SEEPROM settings that control things like
-		transfer negotiations.  This data will be cloned as the
-		defaults if a target mode instance is re-instantiated.
-	
-		Correct a bug in ahc_set_width().  We neglected to update
-		the pending scbs to reflect the new parameters.  Since
-		wide negotiation is almost always followed by sync
-		negotiation it is doubtful that this had any real
-		effect.
-	
-		When in the target role, don't complain about
-		"Target Initiated" negotiation requests when an initiator
-		negotiates with us.
-	
-		Pull all info that used to be in ahc_timeout for the FreeBSD
-		OSM into ahc_dump_card_state().  This info should be printed
-		out on all platforms.
-	
-	aic7xxx.h:
-		Add the SCB_AUTO_NEGOITATE scb flag.  This allows us to
-		discern the reason the MK_MESSAGE flag is set in the hscb
-		control byte.  We only want to clear MK_MESSAGE in
-		ahc_update_pending_scbs() if the MK_MESSAGE was set due
-		to an auto transfer negotiation.
-	
-		Add the auto_negotiate bitfield for each tstate so that
-		behavior can be controlled for each of our enabled SCSI
-		IDs.
-	
-		Use a bus interrupt handler vector in our softc rather
-		than hard coding the PCI interrupt handler.  This makes
-		it easier to build the different bus attachments to
-		the aic7xxx driver as modules.
-	
-		Update seeprom definitions for the latest formats.
-	
-	aic7xxx.reg:
-		Remove the TARGET_MSG_REQUEST definition for sequencer ram.
-	
-	aic7xxx.seq:
-		Fix a few target mode bugs:
-	
-		o If MK_MESSAGE is set in an SCB, transition to
-		  message in phase and notify the kernel so that
-		  message delivery can occur.  This is currently
-		  only used for target mode initiated transfer
-		  negotiation.
-	
-		o Allow a continue target I/O to compile without
-		  executing a status phase or disconnecting.  If
-		  we have not been granted the disconnect privledge
-		  but this transfer is larger than MAXPHYS, it may
-		  take several CTIOs to get the job done.
-	
-		Remove the tests of the TARGET_MSG_REQUEST field
-		in scratch ram.
-	
-	aic7xxx_inline.h:
-		Use ahc->bus_intr rather than ahc_pci_intr.
-	
-	aic7xxx_pci.c:
-		Move a comment to the correct location.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#11 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#37 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#26 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#16 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#25 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#20 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#23 edit
-
-Change 172 by gibbs@overdrive on 2001/03/22 17:47:51
-
-	Bump version to 6.1.8.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#52 edit
-
-Change 169 by gibbs@overdrive on 2001/03/22 15:56:41
-
-	aic7xxx_osm.c:
-	aic7xxx_osm.h:
-		Add support for switching to from full to basic
-		command queuing.  Flags in the ahc_linux_device
-		structure indicate what kind of queuing to perform.
-	
-		In the past, we issued an ordered tag every 250
-		transactions.  We now issue an ordered tag every
-		250 transactions issued without the device queue
-		going empty.
-	
-	aic7xxx_proc.c:
-		Use an unsigned long for total number of commands
-		sent to a device.  %q and %lld don't seem to work
-		under Linux or I'd have used a quad.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#60 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#51 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#9 edit
-
-Change 167 by gibbs@overdrive on 2001/03/22 15:45:33
-
-	aic7770.c:
-	aic7xxx_pci.c:
-		Don't map our interrupt until after we are fully setup to
-		handle interrupts.  Our interrupt line may be shared so
-		an interrupt could occur at any time.
-	
-	aic7xxx.h:
-	aic7xxx.c:
-		Add support for switching from fully blown tagged queing
-		to just using simple queue tags should the device reject
-		an ordered tag.
-	
-		Remove per-target "current" disconnect and tag queuing
-		enable flags.  These should be per-device and are not
-		referenced internally be the driver, so we let the OSM
-		track this state if it needs to.
-	
-		Use SCSI-3 message terminology.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#10 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#36 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#25 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#22 edit
-
-Change 165 by gibbs@overdrive on 2001/03/19 17:58:07
-
-	aic7770.c:
-		ahc_reset() leaves the card in a paused state.
-		Re-arrange the code so we reset the chip earlier
-		so we can avoid a manual pause during setup.
-	
-		Setup the controller without enabling card interrupts.
-	
-	aic7xxx.c:
-		Fix a bug in ahc_lookup_phase_entry().  We never traversed
-		past the first entry.  This routine is only used in
-		diagnostics so this had only a limited effect.
-	
-		Start out life with card interrupts disabled.  The bus
-		code will enable the interrupts once setup is complete
-		and our handler is in place.
-	
-		Initialize our softc unit to -1 so that code such as
-		ahc_linux_next_unit() can traverse the list looking for
-		coliding unit numbers without tripping over entries that
-		have not yet had their unit number set.
-	
-		Enhance ahc_dump_card_state().  OSMs should be able to
-		rely on this to dump any controller specific data of
-		interest.  Most of the additional registers printed
-		used to be printed in the FreeBSD timeout handler.
-	
-		Add a function pointer in our softc for a bus specific
-		interrupt handler.  This removes some dependencies on
-		the PCI code so that bus attachments can be compiled
-		as modules separate from the core.
-	
-	aic7xxx.reg:
-		Use the naming for bit 5 of DFSTATUS in the data book,
-		FIFOQWDEMP.
-	
-	aic7xxx.seq:
-		In our idle loop, use an or instruction to set PRELOADEN
-		rather than rewriting the contents of DMAPARAMS to
-		DFCNTRL.  The later may re-enable the DMA engine if
-		the idle loop is called to complete the preload of at
-		least one segment when a target disconnects on an S/G
-		segment boundary but before we have completed fetching
-		the next segment.  This correts a hang, usually in
-		message out phase, when this situation occurs.  This
-		bug has been here for a long time, so the situation
-		is rare, but not impossible to reproduce.
-	
-		Wait for at least 8 bytes in the FIFO before testing to
-		see if the DMA fetch of an SCB has stalled.  The old
-		code used FIFOEMP, which goes false on a single byte.
-		Since we drain the FIFO 8 bytes at a time, using FIFOQWDEMP
-		is safer.
-	
-		If a device happens to be exceptionally slow in asserting
-		HDONE, our workaround for a stalled SCB dma can be triggered.
-		Make this situation non-fatal by terminating our FIFO
-		emptying should we complete the transfer.
-	
-	aic7xxx_inline.h:
-		ahc_pci_intr() -> ahc->bus_intr()
-	
-	aic7xxx_pci.c:
-		Setup ahc->bus_intr().
-	
-		Enable board interrupts at the appropriate time.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#9 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#35 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#24 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#15 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#24 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#19 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#21 edit
-
-Change 164 by gibbs@overdrive on 2001/03/19 17:44:04
-
-	aic7xxx_osm.c:
-		Format to 80 columns.
-	
-		Break after finding a matching entry in the token
-		table during aic7xxx_setup.
-	
-		print the correct name of a function in a diagnostic.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#59 edit
-
-Change 163 by gibbs@overdrive on 2001/03/10 23:51:53
-
-	Bump version to 6.1.7.  The too leanient interpretation
-	of the seeprom signature could result in improper
-	termination settings on some MBs, and this is a big
-	enough bug to warant a new release.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#50 edit
-
-Change 162 by gibbs@overdrive on 2001/03/10 23:50:09
-
-	Handle cross builds.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/Makefile#6 edit
-
-Change 161 by gibbs@overdrive on 2001/03/10 23:41:16
-
-	We now generate a header file for the db include
-	under linux to handle the build on more distribution
-	types.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#5 edit
-
-Change 160 by gibbs@overdrive on 2001/03/10 23:40:38
-
-	aic7xxx.h:
-		Add a definition for the 3.X BIOS signature.
-	
-	aic7xxx_inline.h:
-		We must setup queuestat before processing
-		command complete interrupts in case target
-		mode is enabled.
-	
-	aic7xxx_pci.c:
-		Be more selective in the BIOS signatures we
-		support.  Some seeproms have a signature of
-		0xFFFF, so testing greater than 0x250 resulted
-		in false positives.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#23 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#18 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#20 edit
-
-Change 159 by gibbs@overdrive on 2001/03/09 18:37:25
-
-	To be compatible with older kernels, our setup routine
-	must be called aic7xxx_setup().
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#58 edit
-
-Change 158 by gibbs@overdrive on 2001/03/09 18:00:41
-
-	Play some games so we have a better chance of actually
-	building on more systems.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/Makefile#5 edit
-
-Change 157 by gibbs@overdrive on 2001/03/09 17:04:49
-
-	aic7770_osm.c:
-	aic7xxx_osm.h:
-		Adjust aic7770_map_int() to not rely on a passed in "shared"
-		argument.  We can now look at ahc->flags to see whether the
-		interrupt source is edge or level.
-	
-	aic7xxx_osm.c:
-		Only adjust our goal negotiation settings if the device
-		is actually present.  This prevents a disconnected lun
-		that does not claim to support negotiations from messing
-		up the settings for a successfully probed lun whose inquiry
-		data properly reflects the abilities of the device.
-	
-		Set the device structure as releasable should the inquiry
-		come back with anything other than lun connected.  We
-		should also do this if the device goes away as evidenced
-		by a selection timeout, but as we can't know if this
-		condition is persistant and there is no guarantee that
-		the mid-layer will reissue the inquiry command we use
-		to validate the device, I've simply added a comment
-		this effect.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#57 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#49 edit
-
-Change 156 by gibbs@overdrive on 2001/03/09 16:58:41
-
-	Adjust our interrupt handler so it will work in the edge
-	interrupt case.  We must process all interrupt sources
-	when the interrupt fires or risk not ever getting an
-	interrupt from them.  This involves marking the fact
-	that we are relying on an edge interrupt in ahc->flags
-	and checking for this condition in addition to the
-	AHC_ALL_INTERRUPTS flag.
-	
-	This will make it into the 6.1.6 Linux driver release.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#8 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#22 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#17 edit
-
-Change 155 by gibbs@overdrive on 2001/03/08 17:00:32
-
-	Bump version number for new release.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#48 edit
-
-Change 154 by gibbs@overdrive on 2001/03/08 16:59:57
-
-	Convert to ahc_* and ahc_linux_* function names.
-	
-	aic7770_osm.c:
-		Drop the SA_INTERRUPT flag.  According to Linus,
-		it should not be set.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#6 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#3 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#56 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#47 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#17 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#8 edit
-
-Change 153 by gibbs@overdrive on 2001/03/08 16:58:20
-
-	Cleanup exported symbol names.  We now use ahc_* exclusively
-	to reduce the chance of conflicts with other modules.
-	
-	Staticize symbols that should have always been static.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#34 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#21 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#16 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#19 edit
-
-Change 152 by gibbs@overdrive on 2001/03/07 18:54:38
-
-	aic7xxx_osm.c:
-		Correct our softc comparison routine so that, regardless
-		of which function is seen first, the primary channel of
-		a multi-function chip is probed first.
-	
-		Note that the host structure only records a single scsi
-		ID.  This means that multi-channel controllers, such as
-		the 2742T, cannot inform the SCSI layer of the IDs used
-		by channels other than the first.
-	
-		There is also no way to communicate the probe order of
-		channels on a multi-channel adapter.  We could swap the
-		channels internally, but that would probably be more
-		confusing than just not supporting the option.
-	
-		Add a crude hack to make modunload/modload cycles work
-		now that we are using the new PCI methods.  We must
-		detach our driver from each PCI device referenced by
-		a call to our release method.  The PCI code doesn't have
-		a method to do this, so we muck with the pci_dev ourselves.
-	
-		Deregister our PCI driver when aic7xxx_release releases
-		the last host instance.
-	
-		Fix a bug in the inquiry sniffing code.  It was possible
-		to set our period to a non-zero value even though the
-		offset was zero.  This might have confused some async
-		devices.
-	
-	aic7xxx_osm.h:
-		ahc_power_state_change() is now an OSM routine.
-	
-	aic7xxx_osm_pci.c
-		Make our pci_driver non-static so that aic7xxx_osm.c
-		can reference it during module unload.
-	
-		Add an implementation to change the power state for
-		kernel versions that don't have a PCI method to do
-		this.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#55 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#46 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#16 edit
-
-Change 151 by gibbs@overdrive on 2001/03/07 18:45:53
-
-	aic7770.c:
-		Store a 2 bit channel number in ahc->flags.
-	
-	aic7xxx.c:
-		AHC_SUPPORT_PCI has never been defined.  Use
-		AHC_PCI_CONFIG instead.
-	
-		Modify multi-function option merging to work
-		regardless of the order the functions are presented
-		to the driver.
-	
-		Adjust for the primary channel being a 2 bit integer
-		rather than a flag for 'B' channel being the primary.
-	
-	aic7xxx.h:
-		Adjust for the primary channel being represented as
-		a 2 bit integer in the flags member of the ahc softc.
-	
-		Cleanup the flags definitions so that comment blocks are
-		not cramped.
-	
-		Update seeprom definitions to correctly reflect the fact
-		that the primary channel is represented as a 2 bit
-		integer.
-	
-	aic7xxx.reg:
-		Add DFCACHETH to the definition of DFSTATUS for
-		completness sake.
-	
-	aic7xxx.seq:
-		On some chips, at least the aic7856, the transition from
-		MREQPEND to HDONE can take a full 4 clock cycles.  Test
-		HDONE one more time to avoid this race.  We only want our
-		FIFO hung recovery code to execute when the engine is
-		really hung.
-	
-	aic7xxx_pci.c:
-		Move the powerstate manipulation code into the OSM.  Several
-		OSes now provide this functionality natively.
-	
-		Take another shot at using the data stored in scratch ram
-		if the SCB2 signature is correct and no SEEPROM data is
-		available.  In the past this failed if external SCB ram
-		was configured because the memory port was locked.  We
-		now release the memory port prior to testing the values
-		in SCB2 and re-acquire it prior to doing termination control.
-	
-		Adjust for new 2 bit primary channel setting.
-	
-		Trust the STPWLEVEL setting on any BIOS v 2.5X and above.
-		3.X bioses have started to ship.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#7 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#33 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#20 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#14 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#23 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#18 edit
-
-Change 150 by gibbs@overdrive on 2001/02/28 17:44:09
-
-	aic7xxx_osm.c:
-		Fix the setup for the selection timeout setting.
-	
-		During exception processing dump the card state if
-		we are in verbose mode.
-	
-		Keep "driver_template" static so as not to conflict
-		with other files in the system.  Instead, export a
-		pointer to the driver template with a more unique
-		symbol name.
-	
-	aic7xxx.h:
-		Export our pointer to the driver template.
-	
-		Bump driver version number to 6.1.5.
-	
-	aic7xxx_osm_pci.c:
-		Use the newly exported pointer to the driver template.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#54 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#45 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#15 edit
-
-Change 149 by gibbs@overdrive on 2001/02/28 17:36:26
-
-	aic7xxx.c:
-		Take advantage of a new flag managed by the sequencer
-		that indicates if an SCB fetch is in progress.  If so,
-		the currently selected SCB needs to be returned to the
-		free list to prevent an SCB leak.  This leak is a rarity
-		and would only occur if a bus reset or timeout resulting
-		in a bus reset occurred in the middle of an SCB fetch.
-	
-		Don't attempt to perform ULTRA transfers on ultra capable
-		adapters missing the external precision resistor required
-		for ultra speeds.  I've never encountered an adapter
-		configured this way, but better safe than sorry.
-	
-	aic7xxx.h:
-		Add AHC_ULTRA_DIASABLED softc flag to denote controllers
-		missing the external precision resistor.
-	
-	aic7xxx.reg:
-		Add SEQ_FLAGS2 which currently only contains the SCB_DMA
-		(SCB DMA in progress) flag.
-	
-	aic7xxx.seq:
-		Manage the SCB_DMA flag of SEQ_FLAGS2.
-	
-		More carefully shutdown the S/G dma engine in
-		all cases by using a subroutine.  Supposedly not
-		doing this can cause an arbiter hang on some ULTRA2
-		chips.
-	
-		Formatting cleanup.
-	
-	aic7xxx_pci.c:
-		Configure any 785X ID in the same fashion and assume
-		that any device with a rev id of 1 or higher has the
-		PCI 2.1 retry bug.  It seems that at least some revisions
-		of the 7856 have this bug.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#32 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#19 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#13 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#22 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#17 edit
-
-Change 148 by gibbs@overdrive on 2001/02/27 17:39:56
-
-	Correct a problem when one lun has a disconnected untagged
-	transaction and another lun has disconnected tagged transactions.
-	Just because an entry is found in the untagged table doesn't
-	mean that it will match.  If the match on the lun fails, cleanup
-	the SCB (return it to the disconnected list or free it), and snoop
-	for a tag message.  Before this change, we reported an unsolicited
-	reselection.  This bug was introduced about a month ago during an
-	overly aggressive optimization pass on the reselection code.
-	
-	When cleaning up an SCB, we can't just blindly free the SCB.  In
-	the paging case, if the SCB came off of the disconnected list, its
-	state may never have been updated in host memory.  So, check the
-	disconnected bit in SCB_CONTROL and return the SCB to the disconnected
-	list if appropriate.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#21 edit
-
-Change 147 by gibbs@overdrive on 2001/02/26 17:05:34
-
-	Handle the case of 5MHz user sync rate set as "0" instead of 0x1c
-	in scratch ram.
-	
-	If we lookup a period of 0 in our table (async), clear the scsi offset.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#31 edit
-
-Change 146 by gibbs@overdrive on 2001/02/21 20:48:22
-
-	Put our exception handling semaphore into the softc rather
-	than as a global.  I don't know what I was thinking when
-	I wrote this code, but having two different controllers sleeping
-	on the same mutex for error recovery is a recipe for disaster.
-	
-	Implement a controller global queue freeze function.  We use this
-	feature to handle the initial reset bus settle delay.  The queue
-	is unfrozen by a timer so all bus settle delays occur in parallel
-	and without stopping other kernel tasks from running.  My only
-	remaining concern is that the specification of too long of a
-	reset delay might trigger a mid-layer timeout.  The default
-	under linux is 5 seconds which is substantially less than the
-	timeouts used during probe.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#53 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#44 edit
-
-Change 145 by gibbs@overdrive on 2001/02/21 13:26:52
-
-	Bump version for 6.1.3 release.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#43 edit
-
-Change 144 by gibbs@overdrive on 2001/02/21 13:26:21
-
-	Properly use the target offset rather than the target id
-	for choosing the correct untagged Q to manipulate.  This
-	should correct problems with the 2742T.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#52 edit
-
-Change 143 by gibbs@overdrive on 2001/02/21 13:25:10
-
-	Identify adapters in ARO mode as such.
-	
-	Ensure that not only the subvendor ID is correct (9005)
-	but also that the controller type field is valid before
-	looking at other information in the subdevice id.  Intel
-	seems to have decided that their subdevice id of 8086
-	is more appropriate than Adaptec's sanctioned scheme.
-	
-	Add an exclusion entry for SISL (AAC on MB based adapters).
-	Adapters in SISL mode are owned by the RAID controller, so
-	even if a driver for the RAID controller is not present,
-	it isn't safe for us to touch them.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#16 edit
-
-Change 142 by gibbs@overdrive on 2001/02/21 13:21:47
-
-	Use the target offset rather than the target Id to reference
-	the untagged SCB array.  The offset and id are identical save
-	in the twin channel case.  This should correct several issues
-	with the 2742T.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#30 edit
-
-Change 141 by gibbs@overdrive on 2001/02/21 13:21:00
-
-	Correct an issue with the aic7770 in twin channel mode.
-	We could continually attempt to start a selection even
-	though a selection was already occurring on one channel.
-	This might have the side effect of hanging our selection
-	or causing us to select the wrong device.
-	
-	While here, create a separate polling loop for when we
-	have already started a selection.  This should reduce
-	the latency of our response to a (re)selection.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#20 edit
-
-Change 140 by gibbs@overdrive on 2001/02/17 14:44:19
-
-	Bump version number to 6.1.2.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#42 edit
-
-Change 139 by gibbs@overdrive on 2001/02/16 16:15:57
-
-	Don't require iospace or mem space to be enabled in order to
-	attach to a PCI device.  We only require that one of the mapping
-	registers is properly setup.
-	
-	This fix allows us to run on a G3 PowerMac.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#14 edit
-
-Change 138 by gibbs@overdrive on 2001/02/15 10:43:52
-
-	Use dma_addr_t as the Linux equivalent to bus_addr_t.  uint32_t
-	works for only some platforms.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#41 edit
-
-Change 137 by gibbs@overdrive on 2001/02/15 10:42:44
-
-	Set the goal and user settings for sync and wide negotiation
-	prior to setting the current.  This makes it easier for some
-	code in the Linux OSM to know when is an oportune time to
-	display a user message about transfer negotiation status.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#29 edit
-
-Change 136 by gibbs@overdrive on 2001/02/09 20:09:59
-
-	On second thought, don't test for ATN just before a
-	command complete message is processed.  We probably
-	want to test for SCSIPERR, but this needs more thought.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#19 edit
-
-Change 135 by gibbs@overdrive on 2001/02/09 20:06:02
-
-	aic7xxx.c:
-		Style nits.
-	
-		Make sure that our selection hardware is disabled
-		as soon as possible after detecting a busfree and
-		even go so far as to disable the selection hardware
-		in advance of an event that will cause a busfree
-		(ABORT or BUS DEVICE RESET message).  The concern
-		is that the selection hardware will select a target
-		for which, after processing the bus free, there
-		will be no commands pending.  The sequencer idle
-		loop will re-enable the selection should still be
-		necessary.
-	
-		In ahc_handle_scsiint(), clear SSTAT0 events several
-		PCI transactions (most notably reads) prior to clearing
-		SCSIINT.  The newer chips seem to take a bit of time
-		see the change which can make the clearing of SCSIINT
-		ineffective.
-	
-		Don't bother panicing at the end of ahc_handle_scsiint().
-		Getting to the final else just means we lost the race
-		with clearing SCSIINT.
-	
-		In ahc_free(), handle case 0.  This can happen when we fail
-		the attach for RAID devices.  While I'm here, also kill
-		the parent dma tag.
-	
-		In ahc_match_scb(), consider initiator ccbs to be any
-		that are not from the target mode group.  This fixes
-		a bug where an external reset CCB was not getting cleaned
-		up by the reset code.
-	
-		Don't bother freezing a ccb in any of our "abort" routines
-		when the status is set to CAM_REQ_CMP.
-	
-	aic7xxx.reg:
-		Reserve space for a completion queue.  This will be used
-		to enhance performance in the near future.
-	
-		Remove an optimization for the 7890 autoflush bug that
-		turned out to allow, in rare cases, some data to get
-		lost.
-	
-		Even though we need a critical section to fully close
-		the command complete loophole, test for ATN anyway in
-		the command complete handler.  Its better than nothing.
-	
-		Implement a simpler, faster, fix for the PCI_2_1 retry
-		bug that hangs the sequencer on an SCB dma.
-	
-	aic7xxx_pci.c
-		Use the correct mask for checking the generic aic7892
-		entry.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#28 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#12 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#18 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#15 edit
-
-Change 134 by gibbs@overdrive on 2001/02/09 19:29:14
-
-	aic7xxx_osm.c:
-		Pull the host_no out of the host structure rather
-		than storing a copy of the field in our own platform
-		softc.
-	
-		Use the host_no rather than our unit nuber for any
-		"scsi%d" type printfs.  In this case, the result is
-		a corrected printf for tagged queue depth.
-	
-		Anytime we run the complete queue, we must clear it.
-		We missed the clearing part when running the device
-		queue after queuing a new command.
-	
-		Use the same format for reporting transfer rates as the
-		/proc code.  Only print transfer info if no further
-		negotiations are pending and the value is different from
-		the last one reported.
-	
-		Correctly format a printf used during error recovery.
-	
-		Don't forget to set the result before returning from
-		one case in ahc_queue_recovery_scb.
-	
-		Fix inverted test for the non-paging case.  The result of
-		this bug was that we would set the MK_MESSAGE bit in an
-		SCB unrelated to the SCB we were trying to abort.
-	
-		Add a missing add_timer() call.  It's hard to timeout
-		on a recovery action when no timer is running.  This
-		also explains why I had to invert the test of the status
-		returned by del_timer() in the past.  We always thought
-		the timer had expired because it was no longer active.
-	
-		Don't forget to run the device queue after error recovery
-		is complete.  We don't want to leave any stray commands
-		stuck in our queues.
-	
-	aic7xxx_osm.h
-		Bump version for next release.
-	
-		Add a "last_tinfo" field to the ahc_linux_target to track
-		what negotiation settings have been announced.
-	
-		Kill unneeded host_no field in the platform softc.
-	
-		Bring the info_str structure into this header file so
-		we can export ahc_format_transinfo() outside of the
-		/proc code.
-	
-	aic7xxx_proc.c:
-		Export ahc_format_transinfo().
-	
-		Use the host_no in the host structure rather than
-		removed field in the platform softc.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#51 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#40 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#7 edit
-
-Change 133 by gibbs@overdrive on 2001/01/28 15:49:09
-
-	aic7770_osm.c:
-		Convert to "aic7xxx_osm.h".
-	
-		On newer kernels, check the return of request_region.
-	
-	aic7xxx_osm.c:
-		Cleanup comment blocks for consistent style.
-	
-		Convert to "aic7xxx_osm.h".
-	
-		Add support for attachment of devices found after
-		the initial probe during "aic7xxx_detect".  We do
-		this by setting a global, aic7xxx_detect_complete,
-		which tells the pci probe code to do its own registration
-		call if initial detection has already occurred.  This way,
-		we maintain the "sane ordering" of devices that the
-		old driver had for statically configured devices.
-	
-		Split out the host registration code into its own function
-		so that hot-plug devices can call this code after
-		aic7xxx_detect has already completed.
-	
-		Use request/release_mem_region on 2.4.0 or higher kernels.
-	
-		Restore SCBPTR after setting up an abort for a
-		disconnected SCB.  The sequencer will become confused
-		if this is not done.
-	
-		Always look for the SCB that timedout first and result to
-		a more generic search only if that fails.  The timedout SCB
-		is more likely to be the one on the bus.
-	
-		Don't bother to drop and reaquire our mutex at the tail
-		of the recovery handler unless we are going to sleep.
-	
-	aic7xxx_osm.h:
-		Comment cleanup.
-	
-		Export our SCSI host template so the hot-plug PCI stuff
-		can use it.
-	
-		Bump revision to 6.1.0... our first release.
-	
-	aic7xxx_osm_pci.c:
-		Add support for new PCI probe mechanism in 2.4.0 while
-		maintaining compatibility with older kernels.
-	
-	aic7xxx_proc.c:
-		Fix several bugs in Gerard's proc code.  We would never
-		properly deal with reads at offsets other than 0.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#5 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#50 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#39 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#13 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#6 edit
-
-Change 132 by gibbs@overdrive on 2001/01/28 15:32:59
-
-	aic7770.c:
-	aic7xxx.c:
-	aic7xxx_93cx6.c:
-		Convert to "aic7xxx_osm.h" setup rather than ifdef hell.
-	
-	aic7xxx_pci.c:
-		Document the layout of the DEVID for cards with the 9005
-		Adaptec vendor ID.  Use a more generic mask for the generic
-		9005 product tests.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#6 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#27 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#7 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#14 edit
-
-Change 131 by gibbs@overdrive on 2001/01/23 15:29:46
-
-	When flipping the first entry in the qinfifo with the
-	"next queued SCB", we must also inform the card of this
-	change.  Otherwise the sequencer will traverse a corrupt
-	list of SCBS.  The side effects of this problem were unknown
-	SCBs completing in the qoutfifo or worse yet, panics due
-	to sequencer interrupts that referenced what, to the kernel,
-	were invalid SCB ids.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#26 edit
-
-Change 130 by gibbs@overdrive on 2001/01/22 17:44:12
-
-	Update copyrights.
-	
-	aic7xxx.seq:
-		Handle busfree early in selection correctly.  We
-		must clear ENSELO so that we will make future attempts
-		at selection.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#5 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#25 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#18 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#11 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#17 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#6 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#15 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#13 edit
-
-Change 129 by gibbs@overdrive on 2001/01/22 17:03:07
-
-	Bump revision level.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#38 edit
-
-Change 128 by gibbs@overdrive on 2001/01/19 16:09:10
-
-	Bump version number.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#37 edit
-
-Change 127 by gibbs@overdrive on 2001/01/19 15:57:40
-
-	It's Adaptec Inc., not just Adaptec.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#2 edit
-
-Change 126 by gibbs@overdrive on 2001/01/19 15:57:16
-
-	Correct a typo.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#4 edit
-
-Change 125 by gibbs@overdrive on 2001/01/19 10:35:11
-
-	aic7xxx.c:
-		Remove aic7895 stack corruption work-around.
-		This seems to only apply if you are mucking
-		with the stack register to effect a "long-jump".
-		We don't do this and don't plan to either.
-	
-		Add additional diagnostic output for when things
-		go wrong.
-	
-		AHC_SCB_BTT is set in the flags area of the softc,
-		not features.
-	
-		Don't loop forever if the INTSTAT register gets
-		locked up when flushing work.  This can happen if
-		we are a removable device (register goes away) or
-		the card dies.
-	
-	aic7xxx.h:
-		Add a removable feature designation to ahc_features.
-		This is currently only used for the apa1480 and the 29160C.
-	
-	aic7xxx.reg:
-		Don't use the sequencer intcode 0xF0.  It makes it possible
-		for the kernel to see INTSTAT as 0xFF and believe a hot-eject
-		has occurred.
-	
-		Align the busy target table on a 16byte boundary.  This
-		appears to correct a sequencer execution issue for the
-		7895.
-	
-	aic7xxx.seq:
-		Don't bother performing a "diagnostic" sequencer interupt
-		should an abort collision occur.
-	
-		Have the bus-free after selection code apply to
-		reselections too.
-	
-		Always follow the clearing of SELDI with a jmp instruction.
-		This corrects a sequencer execution issue on the 7895.
-	
-		In the target mode command loop, don't bother re-enabling
-		SPIOEN for each byte.  It only needs to be enabled once.
-	
-		Fix AHC_SCB_BTT tests to test the correct field in the softc.
-	
-		Correctly clean up resources should an incoming reselection
-		reference a transaction we don't believe is pending.  Add
-		some additional sequencer diagnostics for the SCB_BTT case
-		too.
-	
-	aic7xxx_inline.h:
-		Fix AHC_SCB_BTT tests to test the correct field in the softc.
-	
-		Only believe a hot eject to have occurred if the device
-		is removable.
-	
-	aic7xxx_pci.c:
-		Set the removable feature for the apa1480 and 29160C.
-	
-		Don't print information about high byte termination on
-		narrow adapters.
-	
-		Use a pci bus read instead of a questionable read for
-		safety when manipulating external termination logic.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#24 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#17 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#10 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#16 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#14 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#12 edit
-
-Change 124 by gibbs@overdrive on 2001/01/15 05:12:30
-
-	aic7770_osm.c:
-		Whitespace cleanup.
-	
-		Don't reference a NULL pointer.
-	
-	aic7xxx_osm.c:
-		Honor kernel configuration settings for bus
-		settle delay and max tagged commands.
-	
-		Correct accuracy of tagged command setup comments.
-	
-		Limit linux to 253 total commands due to command
-		complete FIFO cleanup restrictions.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#3 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#49 edit
-
-Change 123 by gibbs@overdrive on 2001/01/12 09:08:27
-
-	aic7770.c:
-		Add softcs for new EISA instances into the global list
-		of aic7xxx controllers as they are found.  Leaving the
-		softcs out of the list prevented these controller instances
-		from being attached.
-	
-	aic7xxx.c:
-		Remove code that corrected for a state that cannot occur.
-		The sequencer now increments its position in the qinfifo
-		only once it has successfully DMAed the SCB from that queue
-		position down to the controller.  In the past the sequencer
-		incremented before attempting the DMA.
-	
-		To ensure that the sequencer always notices an abort
-		collision, swap the first entry in the qinfifo with
-		the held, next to dma, hscb only after we have completed
-		our pass through the array.  In the past, we did this
-		before clearing out the queue, and this did not provide
-		the same guarantee since the queue could be cleared leaving
-		the next pointer to be the same as it was originally.
-	
-		Print out the next queued SCB as seen by both the kernel
-		and the sequencer in ahc_dump_card_state().
-	
-	aic7xxx.h:
-		Introduce a new constant, AHC_MAX_QUEUE.  This is now set
-		to 253 to make sure that our 32bit writes to clear the
-		qoutfifo can never clobber a valid entry in the queue.
-		All OSMs should use this new define to throttle their
-		controller wide queue depth.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#4 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#23 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#16 edit
-
-Change 122 by gibbs@overdrive on 2001/01/08 11:32:55
-
-	Kill old insqueue interface.  It will not be used by the
-	aic7xxx driver.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/queue.h#4 edit
-
-Change 121 by gibbs@overdrive on 2001/01/08 11:30:36
-
-	Reduce the university's copyright per Kirk.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/queue.h#3 edit
-
-Change 120 by gibbs@overdrive on 2001/01/08 11:27:30
-
-	Bump version number for next release.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#36 edit
-
-Change 119 by gibbs@overdrive on 2001/01/08 11:20:17
-
-	Turn on ID expansion.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#3 edit
-
-Change 118 by gibbs@overdrive on 2001/01/08 08:10:19
-
-	aic7xxx_osm.c:
-		Honor selection timeout settings set by the user.
-	
-		Style cleanup of initial setup routine.
-	
-		Use sense buffer access inlines.
-	
-		Check for critical underflow only if there are no
-		other errors reported at the time the command is ahc_done()'d.
-		In the past, we might have marked the command as critically
-		failed before retrieving sense.  Sense data should take
-		priority.
-	
-	aic7xxx_osm.h:
-		Second part of underflow cleanup.  Just store the residual
-		in ahc_set_residual().  Leave policy decision to ahc_done().
-	
-	aic7xxx_proc.c:
-		Add per-device statistics to proc output.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#48 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#35 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#5 edit
-
-Change 117 by gibbs@overdrive on 2001/01/08 08:03:54
-
-	aic7xxx.c:
-		Use inline accessors to get to the sense buffer associated
-		with a particular auto-sense transaction.  This buffer is
-		now indexed by scb offset, not hscb offset, so any qinfifo
-		manipulations will not effect the buffer referenced.
-	
-		Honor the selection timeout setting in ahc_softc.  The
-		OSM is responsible for setting this to any non-default
-		value.
-	
-		Modify our suspend and resume routines to take into account
-		twin channel adapters.
-	
-	aic7xxx.h:
-		Add fields for twin channel suspend state storage and
-		selection timeout timer to ahc_softc.
-	
-	aic7xxx_inline.h:
-		Inline accessors for sense buffer bus address and buffer.
-	
-	aic7xxx_pci.c:
-		Correct subdevice id data extraction routines to work
-		correctly on motherboard devices.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#22 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#15 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#13 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#11 edit
-
-Change 116 by gibbs@overdrive on 2000/12/21 09:22:20
-
-	Makefile:
-		Generate module in SCSI directory so it can be
-		named just like its predecessor.
-	
-	aic7xxx_osm.c:
-		Fix semaphore declarations for newer kernels.
-	
-		Use new ahc_* byte order functions.
-	
-		Cleanup some unused code.
-	
-		Implement platform_flush_work.
-	
-	aic7xxx_osm.hosts.h:
-		Split out our host template definition so we don't
-		muck up the namespace when our template is included
-		in hosts.c
-	
-	aic7xxx_inline.h:
-		Define ahc_endian functions.
-	
-		Bump version number.
-	
-	aic7xxx_proc.c:
-		First stab at /proc support.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/Makefile#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#47 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#34 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#4 edit
-
-Change 115 by gibbs@overdrive on 2000/12/21 08:59:37
-
-	Add untested support for big endian machines.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#21 edit
-
-Change 114 by gibbs@overdrive on 2000/12/13 08:00:07
-
-	Bring in the optimized interrupts handler.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#12 edit
-
-Change 113 by gibbs@overdrive on 2000/12/13 07:57:15
-
-	aic7xxx_osm.c:
-		Use a semaphore and a timer to cause our exception
-		handler to sleep while recovery actions are in progress.
-	
-		Mark the correct recovery type in the SCB instead of
-		always marking DEVICE_RESET.
-	
-	aic7xxx_osm.h:
-		We are now at 6.0.6 BETA.
-	
-		Use a simple "do/while" construct to serve as a
-		memory barier on ia32.  lock instructions are
-		expensive and all we need is something to prevent
-		the compiler from reordering our store order.
-	
-	aic7xxx_pci.c:
-		Turn off either I/O or Mem access depending on which
-		mapping type is not in use.  This prevents our EISA
-		probe from kicking one of our cards.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#46 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#33 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#12 edit
-
-Change 112 by gibbs@overdrive on 2000/12/13 07:39:03
-
-	Complete preliminary resume support.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#20 edit
-
-Change 111 by gibbs@overdrive on 2000/12/12 12:09:54
-
-	aic7xxx.c:
-		During initialization, be sure to initialize all scratch
-		ram locations before they are read to avoid parity errors.
-		In this case, we use a new function, ahc_unbusy_tcl() to
-		initialize the scratch ram busy target table.
-	
-		Replace instances of ahc_index_busy_tcl() used to unbusy
-		a tcl without looking at the old value with ahc_unbusy_tcl().
-	
-		Modify ahc_sent_msg so that it can find single byte messages.
-		ahc_sent_msg is now used to determine if a transfer negotiation
-		attempt resulted in a bus free.
-	
-		Be more careful in filtering out only the SCSI interrupts
-		of interest in ahc_handle_scsiint.
-	
-		Rearrange interrupt clearing code to ensure that at least
-		one PCI transaction occurrs after hitting CLRSINT1 and
-		writting to CLRINT.  CLRSINT1 writes take a bit to
-		take effect, and the re-arrangement provides sufficient
-		delay to ensure the write to CLRINT is effective.
-	
-		export ahc-update_target_msg_request for use by OSM code.
-	
-		If a target does not respond to our ATN request, clear
-		it once we move to a non-message phase.  This avoids
-		sending a MSG_NOOP in some later message out phase.
-	
-		Use max lun and max target constants instead of
-		hard-coded values.
-	
-		Use softc storage built into our device_t under FreeBSD.
-	
-		Fix a bug in ahc_free() that caused us to delete
-		resources that were not allocated.
-	
-		Clean up any tstate/lstate info in ahc_free().
-	
-		Clear the powerdown state in ahc_reset() so that
-		registers can be accessed.
-	
-		Add a preliminary function for pausing the chip and
-		processing any posted work.
-	
-		Add a preliminary suspend and resume functions.
-	
-	aic7xxx.h:
-		Limit the number of supported luns to 64.  We don't
-		support information unit transfers, so this is the
-		maximum that makes sense for these chips.
-	
-		Add a new flag AHC_ALL_INTERRUPTS that forces the
-		processing of all interrupt state in a single invokation
-		of ahc_intr().  When the flag is not set, we use the
-		lazy interrupt handling scheme.
-	
-		Add data structures to store controller state while
-		we are suspended.
-	
-		Use constants instead of hard coded values where appropriate.
-	
-		Correct some harmless "unsigned/signed" conflicts.
-	
-	aic7xxx.seq:
-		Only perform the SCSIBUSL fix on ULTRA2 or newer controllers.
-		Older controllers seem to be confused by this.
-	
-		In target mode, ignore PHASEMIS during data phases.
-		This bit seems to be flakey on U160 controllers acting
-		in target mode.
-	
-	aic7xxx_pci.c:
-		Add support for the 29160C CPCI adapter.
-	
-		Add definitions for subvendor ID information
-		available for devices with the "9005" vendor id.
-		We currently use this information to determine
-		if a multi-function device doesn't have the second
-		channel hooked up on a board.
-	
-		Add rudimentary power mode code so we can put the
-		controller into the D0 state.
-	
-		Only capture "left over BIOS state" if the POWRDN
-		setting is not set in HCNTRL.
-	
-		In target mode, don't bother sending incremental
-		CRC data.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#19 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#14 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#15 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#10 edit
-
-Change 110 by gibbs@overdrive on 2000/12/01 09:43:59
-
-	When bus resets are disabled, call update_target_msgreq after
-	setting initial transfer settings so that negotiation takes place
-	on the first command to the target.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#45 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#32 edit
-
-Change 109 by gibbs@overdrive on 2000/11/10 09:37:15
-
-	Add IOMODE support.
-	
-	Remove recurring interrupts during scsi bus resets by
-	disabling scsi bus reset notifications until we start
-	sending or receiving transactions again.
-	
-	Issue a missed busfree sequencer interrupt instead of
-	overloading bad phase.  The code was getting confused
-	before because last phase was not set in all cases
-	to distinguish the two cases.
-	
-	Don't assume the SCB tag is valid unless SEEN_IDENTIFY
-	is set in SEQ_FLAGS during timeout handling.
-	
-	Add critical sections to protect the sequencer from list
-	corruption during timeout handling.
-	
-	Sync with FreeBSD IDs.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#18 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#13 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#9 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#14 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#5 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.h#5 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#11 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#9 edit
-
-Change 108 by gibbs@overdrive on 2000/11/10 09:33:33
-
-	Bump version for next release.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#31 edit
-
-Change 107 by gibbs@overdrive on 2000/11/06 09:36:35
-
-	The core driver takes care to clean up any doubly queued SCBs
-	now, so don't call ahc_search_qinfifo from ahc_done().
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#44 edit
-
-Change 106 by gibbs@overdrive on 2000/11/06 09:35:50
-
-	Fix 8bit math errors when tweaking the qinfifo.
-	
-	Don't allow ahc_search_qinfifo to be called recursively.
-	
-	Use a subroutine to make sure we don't coast into any
-	important sequencer instructions when issuing a pausing
-	interrupt.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#17 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#8 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#13 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#10 edit
-
-Change 105 by gibbs@overdrive on 2000/11/01 12:01:08
-
-	Linux EISA support, support for 2.4.X kernels, and updates to
-	match changes in the core aic7xxx code.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/Makefile#6 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#43 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#30 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#11 edit
-
-Change 104 by gibbs@overdrive on 2000/11/01 11:59:42
-
-	Too many changes to mention.  Lots of bug fixes.  Filtering of
-	incoming transfer negotiation messages based on user settings,
-	bmov instruction for all moves, additional debugging code, etc.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#2 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#16 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#12 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#7 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#12 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#9 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#8 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#6 edit
-
-Change 103 by gibbs@overdrive on 2000/10/13 10:01:42
-
-	aic7xxx.c:
-		Limit our sync period correctly based on tinfo data.
-		We now send a period of 0 if we want async.
-	
-		Fix problem with DMA'ed CDBs.  The pointer to the
-		physical cdb was not being setup properly during
-		the HSCB swap.  We now compute this value in
-		ahc_setup_scb().
-	
-	aic7xxx.seq:
-		Make sure that DFON stays on in SXFRCTL0.
-	
-		Fix DMA'ed cdbs for adapters without a command channel.
-		The length in HCNT was not properly set.
-	
-		Clear STCNT on U2 controllers when we exit command
-		phase.  This is an attempt to clear the preload circuit.
-		It is not yet clear that this works.
-	
-	aic7xxx_inline.h:
-		Copy the whole 64 bytes of the hscb when queuing it.
-		If we need to recalculate the cdb physical pointer for
-		a large cdb, do so at this time as well.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#15 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#11 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#11 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#8 edit
-
-Change 102 by gibbs@overdrive on 2000/10/12 11:12:41
-
-	Make the no_reset option work and also honor the seeprom/nvram
-	reset options at boot time.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#42 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#29 edit
-
-Change 101 by gibbs@overdrive on 2000/10/12 10:00:34
-
-	Update for changes in aic7xxx core files: UNTAGGED_Q flag,
-	ahc_validate*() now take a tinfo.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#41 edit
-
-Change 100 by gibbs@overdrive on 2000/10/12 09:59:11
-
-	Limit transfer settings to that of our goal at all times.  This
-	ensures that a target initiated sync/wide negotiation never goes
-	above the limits specified by the user.
-	
-	When switching to non-tagged queuing, be sure to set the
-	SCB_UNTAGGEDQ flag when inserting the SCB onto the untagged q.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#14 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#10 edit
-
-Change 99 by gibbs@overdrive on 2000/10/09 11:21:46
-
-	Remove AIC7XXX_STRICT_PCI_SETUP.  We don't currently honor it
-	and don't have a reason to honor it in the future.
-	
-	Handle temporary resource shortages such as an attempt to allocate
-	additional SCBs failing.
-	
-	Complete the first pass at Linux error recovery code.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#40 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#28 edit
-
-Change 98 by gibbs@overdrive on 2000/10/09 11:17:46
-
-	Export ahc_match_scb() to OSMs.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#13 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#9 edit
-
-Change 97 by gibbs@overdrive on 2000/10/09 07:49:38
-
-	aic7xxx.c:
-		export ahc_qinfifo_requeue and a new routine
-		ahc_qinfifo_count for use by OSM error recovery
-		routines.
-	
-		Resync the tqinfifo position during every restart of
-		the sequencer.  In the past, we would do this only
-		for bus resets but there are other situations where
-		restarting the sequencer might cause a discrepency.
-	
-		Print the scb's path information before running an
-		abort command that will include that scb.  There is
-		no guarantee that the path information will be valid
-		after an SCB is freed.
-	
-		In ahc_clear_critical_sections(), disable all SCSIINT
-		interrupt sources and clear SCSIINT.  SCSIINT is a pausing
-		interrupt and the sequencer will not step if it is paused
-		by an interrupt condition.  Any SCSIINT sourc that is
-		active prior to or becomes active during the stepping 
-		process will cause SCSIINT to be re-asserted when we
-		re-enable these interrupt sources at the tail of
-		ahc_clear_critical_sections().
-	
-		Send the correct async notifications for BDR and bus reset.
-	
-		Fix an error in ahc_search_qinfifo() that would update
-		QINFIFO at the wrong time.
-	
-		In ahc_loadseq, properly calculate the critical section
-		regions for the current firmware load.  The old code was
-		confused if a critical sections boundary occurred on
-		an instruction not downloaded to the chip.
-	
-	aic7xxx.h:
-		Remove an unused SCB_FLAG.
-	
-		Export ahc_qinfifo_requeue() and ahc_qinfifo_count().
-	
-	aic7xxx.seq:
-		The MK_MESSAGE flag is cleared by the kernel.  Don't
-		bother duplicating that effort in the sequencer.
-	
-	aic7xxx_pci.c:
-		7880's prior to rev B have the MWI boundary bug.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#12 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#8 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#10 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#7 edit
-
-Change 96 by gibbs@overdrive on 2000/10/06 06:40:57
-
-	Convert to keeping a queue of Scsi_Cmnd structures instead of SCBs.
-	This will allow us to queue domain validation and other requests
-	internally to the driver without fear of an SCB shortage related
-	deadlock.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#39 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#27 edit
-
-Change 95 by gibbs@overdrive on 2000/10/06 06:39:42
-
-	Simplify ahc_update_pending_syncrates().
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#11 edit
-
-Change 94 by gibbs@overdrive on 2000/10/06 06:19:23
-
-	Update FreeBSD ids.
-	
-	Move verbose logging of negotiation into the *construct* methods
-	so that logging occurs in all cases.
-	
-	Correct ahc_search_qinfifo to properly deal with an SCB out of
-	the qinfifo but mid-dma in the SEARCH_REMOVE case.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#10 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#7 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#6 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#9 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#4 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.h#4 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#7 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#6 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#6 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#4 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#5 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#4 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#4 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#4 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#4 edit
-
-Change 93 by gibbs@overdrive on 2000/10/03 11:11:11
-
-	Fix non-module build on 2.2.14.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#38 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#26 edit
-
-Change 92 by gibbs@overdrive on 2000/10/03 11:10:45
-
-	aic7xxx.c:
-		panic with a reasonable message if we do not have a valid
-		SCB when handling a HOST_MSG_LOOP event.
-	
-		Clear any critical sections when a bus reset or any unexpected
-		SCSI event occurs.
-	
-		Fix an off by one in testing whether we are inside a
-		critical section.
-	
-		Set the step bit in the correct register.
-	
-		Also check whether the PPR options have changed when
-		deciding to update our syncrate.
-	
-		Add some bootverbose logging about transfer negotiations.
-	
-		If we are going to reject a PPR, explicitly set all options
-		to async/narrow.  It may be that only one of the many options
-		was filtered to an unacceptable value.
-	
-		Have the ahc_search_qinfifo routing properly handle the
-		case where an SCB has left the qinfifo but has not yet
-		been added to the waiting list.
-	
-	aic7xxx.seq:
-		Correct critical sections for input queue handling.
-	
-		Fix a bug in input queue handling that caused us to
-		smash the next scb to download value as we were putting
-		the new SCB onto the waiting list.
-	
-		If the qinfifo changes to not include the just DMAed
-		SCB, throw it away... it has been aborted by the kernel.
-	
-	aic7xxx_inline.h:
-		Simplify a statement.  No fucntional change.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#9 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#8 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#6 edit
-
-Change 91 by gibbs@overdrive on 2000/09/28 10:59:15
-
-	Limit prefetch to a PCI cacheline amount instead of pulling
-	a full (and expensive) 128 bytes.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#8 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#5 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#7 edit
-
-Change 90 by gibbs@overdrive on 2000/09/28 10:31:17
-
-	Make sure we tell the OS that we can only take 254 or
-	AHC_SCB_MAX - 1 requests at a time due to the new QINFIFO
-	scheme.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#37 edit
-
-Change 89 by gibbs@overdrive on 2000/09/28 10:30:48
-
-	Correct ahc_search_qinfifo by reading and resetting the
-	SNSCB_QOFF register.  A read of this register increments it,
-	requiring the reset.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#7 edit
-
-Change 88 by gibbs@overdrive on 2000/09/28 09:24:14
-
-	Use an array of scb pointers to map from HSCB tag to
-	SCB.
-	
-	Take a first shot at correcting ahc_search_qinfifo for the
-	new qinfifo mechanism.  We don't currently handle the case
-	of an SCB in transit to the card after it has been removed
-	from the QINFIFO.
-	
-	There still appears to be a problem with the QINFIFO handling
-	that I have yet to address.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#6 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#6 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#6 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#5 edit
-
-Change 87 by gibbs@overdrive on 2000/09/27 09:03:56
-
-	Put the Linux aic7770 support into its final location.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#1 branch
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_eisa.c#3 delete
-
-Change 86 by gibbs@overdrive on 2000/09/27 09:03:16
-
-	Implement new, single DMA, strategy for getting commands to
-	the controller.
-	
-	Still need to implement qinfifo cleanup routine.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#5 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#5 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#4 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#5 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#4 edit
-
-Change 85 by gibbs@overdrive on 2000/09/27 09:02:01
-
-	Clean up code formating so extraineous commas are not
-	generated.
-	
-	Output a constant indicating the size of the critical
-	section table.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#5 edit
-
-Change 84 by gibbs@overdrive on 2000/09/27 08:58:38
-
-	Switch to only allowing 254 commands outstanding in preparation
-	for new input queue handling.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#36 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#25 edit
-
-Change 83 by gibbs@overdrive on 2000/09/25 08:40:23
-
-	aic7xxx_osm.c:
-		Correct a KERNEL_VERSION test.
-	
-		Reset the bus only after we've finished setting
-		up the controller fully.
-	
-		Update for new ahc_send_async() API.
-	
-		Only attempt to report bus resets if the kernel
-		we're building for supports it.
-	
-	aic7xxx_osm.h:
-		Bump driver version in preparation for next release.
-	
-		Fix compilation on older kernels.  The Scsi_Cmnd is now
-		available through the scb->io_ctx.
-	
-		Update for new ahc_send_async() API.
-	
-	aic7xxx_osm_pci.c:
-		Correctly handle the I/O mapped case.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#35 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#24 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#10 edit
-
-Change 82 by gibbs@overdrive on 2000/09/25 08:35:25
-
-	Rely on CACHETHEN bug entries to limit its use.  Otherwise,
-	default to turning it on.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#5 edit
-
-Change 81 by gibbs@overdrive on 2000/09/22 07:55:30
-
-	aic7xxx.c:
-		Clear scsi interrupts via the CLRINT register if we
-		see a spurios SCSI interrupt.
-	
-		Modify the ahc_send_async interface so that the client
-		can directly specify which devices (through the use of
-		wildcards) are affected.
-	
-		When sending a PPR message we need to filter the syncrate
-		we attempt to negotiate with the target just as when using
-		the older SDTR message.  Combine these two cases so we can
-		share the code that does this.
-	
-		Correct a panic message.
-	
-		Handle a MSG_MESSAGE_REJ for a PPR request.  Simplify the
-		ahc_handle_msg_reject routine by calling
-		ahc_build_transfer_msg in cases where further negotiation
-		is required rather than doing this manually.
-	
-		In ahc_controller_info(), don't bother updating len and
-		buf for the last sprintf since no-one will look at them
-		again.
-	
-	aic7xxx.h:
-		Increase the size of both msgout_buf and msgin_buf[].
-		The PPR message is 8 bytes in length and we might
-		(on some platforms) combine the PPR with inquiry and
-		tag data.  We now allocate 12 bytes in each.
-	
-	aic7xxx.seq:
-		Use quoted includes in the sequencer file and make up
-		for the lack of path information in some OS dependent
-		manner (sys/conf/files for FreeBSD, placement of files
-		in Linux).  The assembler doesn't understand #ifdef
-		directives and this allows the files to be completely
-		shared between platforms.
-	
-		Remove an unnecessary nop instruction.
-	
-	aic7xxx_pci.c:
-		In ahc_pci_intr(), look at the error register to
-		determine whether a PCI error has occurred before
-		rushing into a configuration cycle to read the error.
-		Configuration cycles are more expensive than a single
-		memory read transaction and we may end up thinking
-		we have a PCI interrupt waiting just because we share
-		an IRQ with other devices.
-	
-		unpause the sequencer after clearing any PCI status.
-		For some errors (such as received Master Abort), the
-		error had nothing to do with this controller, but the
-		chip was automatically paused.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#4 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#4 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#4 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#4 edit
-
-Change 80 by gibbs@overdrive on 2000/09/19 09:20:44
-
-	Add ahc_send_async() for Linux and have it report bus resets.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#34 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#23 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#9 edit
-
-Change 79 by gibbs@overdrive on 2000/09/19 09:06:42
-
-	include inttypes.h.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#4 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#4 edit
-
-Change 78 by gibbs@overdrive on 2000/09/19 08:43:13
-
-	Bring back the Linux Makefile for the assembler.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/Makefile#4 add
-
-Change 77 by gibbs@overdrive on 2000/09/19 08:15:07
-
-	Bring in latest FreeBSD port changes.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7770.c#1 add
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#3 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#3 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#3 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#3 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#3 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.h#3 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#3 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#3 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#3 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#3 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#3 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#3 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#3 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#3 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#3 edit
-
-Change 76 by gibbs@overdrive on 2000/09/19 07:24:37
-
-	Make sure these all have RCS ID expansion enabled.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#2 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#2 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#2 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#2 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#2 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.h#2 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#2 edit
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#2 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#2 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#2 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#2 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#2 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#2 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#2 edit
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#2 edit
-
-Change 75 by gibbs@overdrive on 2000/09/19 07:21:44
-
-	Move core files to core location in the repository.
-
-Affected files ...
-
-... //depot/aic7xxx/aic7xxx/aic7xxx.c#1 branch
-... //depot/aic7xxx/aic7xxx/aic7xxx.h#1 branch
-... //depot/aic7xxx/aic7xxx/aic7xxx.reg#1 branch
-... //depot/aic7xxx/aic7xxx/aic7xxx.seq#1 branch
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#1 branch
-... //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.h#1 branch
-... //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#1 branch
-... //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#1 branch
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#1 branch
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#1 branch
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#1 branch
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#1 branch
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#1 branch
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#1 branch
-... //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#1 branch
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#25 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.h#12 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.reg#5 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.seq#12 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_93cx6.c#4 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_93cx6.h#3 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_eisa.c#3 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_inline.h#10 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_pci.c#7 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/Makefile#3 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm.c#5 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm.h#4 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y#7 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h#2 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l#5 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c#3 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h#4 delete
-
-Change 74 by gibbs@overdrive on 2000/09/12 11:57:59
-
-	Cleanup and changes to support FreeBSD
-	
-	aic7xxx.c:
-		FreeBSD includes.  FreeBSD uses -nostdinc so
-		we must explicitly state the path to any referenced
-		files.
-	
-		staticize
-	
-		Inline ahc_intr().  It is only referenced once by
-		the OSM.
-	
-		Call ahc_notify_xfer_settings_change() in all locations
-		where settings change.
-	
-		Simplify ahc_platform_set_tags.  Don't bother calling
-		it if the tags setting has not changed.
-	
-		Don't leak ahc->name() in ahc_free().
-	
-		Add functions used only for target mode.
-	
-		pci_softc -> dev_softc.
-	
-		Move FreeBSD specific calls into aic7xxx_freebsd.c.
-	
-		Add marker to cleanup tstate info in ahc_free().
-	
-		Bring back SEARCH_REMOVE to ahc_search_qinfifo().
-		The FreeBSD error recovery code uses it.
-	
-	aic7xxx.h:
-		Add the io_ctx field into the scb.  This represents a
-		pointer to the ccb or Scsi_Cmnd or whatever a platform
-		uses to keep track of the OSes io context.  This is
-		faster and simpler than rooting around in the scb_platform
-		data object.
-	
-		Bring back in more target mode stuff.
-	
-		ahc_pci_softc_t -> ahc_dev_softc_t.
-	
-		inline ahc_intr.
-	
-		export functions referenced by FreeBSD's error recovery code.
-	
-	aic7xxx_93cx6.c:
-		FreeBSD inludes.
-	
-	aic7xxx_inline.h:
-		Inline ahc_intr.
-	
-	aic7xxx_osm.c:
-		Cleanup unused and #if 0'd code.
-	
-		platform_data->cmd -> io_ctx.
-	
-		ahc->pci_softc -> ahc->dev_softc.
-	
-		Cleanup unused (or should have been unused) fields
-		in ahc_platform_softc.
-	
-		ahc_platform_set_tags() simplification.  Changed argument
-		goes away and the function is only called when the
-		tags setting changes.
-	
-	aic7xxx_osm.h:
-		Cleanup unused and #if 0'd code.
-	
-		Add ahc_insb() for use by ahc_dump_seq().
-	
-		pci_softc -> dev_softc.
-	
-		platform_data->cmd -> io_ctx.
-	
-	aic7xxx_osm_pci.c:
-		pci_softc -> dev_softc.
-	
-	aic7xxx_pci.c:
-		FreeBSD includes
-	
-		pci_softc -> dev_softc.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#24 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.h#11 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_93cx6.c#3 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_inline.h#9 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#33 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#22 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#9 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_pci.c#6 edit
-
-Change 72 by gibbs@overdrive on 2000/09/07 10:47:56
-
-	aic7xxx.c:
-		TAILQ_FOREACH is not safe to use when the list you
-		are traversing is modified in the body of the loop.
-		Manually traverse the list instead.
-	
-	aic7xxx_osm.h:
-	aic7xxx_osm.c:
-		Avoid re-entry issues during abort processing by
-		deferring the run of any device queues until after
-		ahc_intr() has completed.  Just as in the case of
-		running the complete queue, the device queues will
-		need to be run from any abort processing performed
-		outside the interrupt handler as well.
-	
-		Bump our version number in preparation for another release.
-	
-	cam.h:
-		Make get and set transaction status work the same way as
-		in FreeBSD.  Notably, mask with CAM_STATUS_MASK.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#23 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#32 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#21 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#8 edit
-
-Change 68 by gibbs@overdrive on 2000/09/06 10:25:15
-
-	aic7xxx.c:
-		Start the port back to FreeBSD....
-			o Include FreeBSD header on FreeBSD
-	
-			o ahc_freeze_ccb -> ahc_freeze_scb() and unifdef.
-	
-			o Change XXX to __FreeBSD__ on sections of code
-			  we still need additional special accessors for.
-	
-			o Bring in the rest of the target mode code.
-	
-		Move the pci_softc from platform_data into its own
-		field in ahc_softc.  This makes it less cumbersome
-		to perform PCI operations.		
-	
-		Add a routine, ahc_dump_card_state,  that dumps the
-		state of all of our queues.  This can be called when
-		something unexpected occurs to aid in debugging problems.
-		It is currently only called when we see an inactive
-		SCB come through ahc_done().
-	
-	aic7xxx.h:
-		struct ahc_pci_softc -> ahc_pci_softc_t.
-		On both Linux and FreeBSD, the pci_softc need only
-		be a pointer to the platform provided PCI instance
-		object, so we let the OSM define this type to be
-		whatever is convenient.
-	
-		Add bug definition for SCB corruption on upload
-		with aic7899s on 66MHz PCI.
-	
-		Use bus space tag/handle pair for accessing the
-		card on all platforms.  This removes an extra
-		pointer dereference and matches what FreeBSD
-		has been doing for some time.
-	
-		Move the platform_softc lower in the ahc_softc.
-		Since it no-longer includes the fields required
-		to access card registers, it is accessed less often
-		than the fields that now appear before it.
-	
-	aic7xxx.seq:
-		Implement a workaround for the 66MHz PCI SCB upload
-		corruption problem.  By transferring first from the
-		SCB into SCBRAM and then performing the DMA, we
-		avoid the corruption.
-	
-	aic7xxx_osm.c:
-		ahc_pci_softc_t fallout.
-	
-		bus space fallout.
-	
-		Implement the platform dependant portions of
-		ahc_dump_card_state().
-	
-		Fix a nasty bug in ahc_run_device_queue().  We
-		cannot send any SCB that does not have CAM_SIM_QUEUED
-		set to the card or it will get sent twice.  Once
-		by the queue run routine and again by aic7xxx_queue().
-	
-	aic7xxx_osm.h:
-		Implement bus space fields for PIO/MEMIO.
-	
-		struct ahc_pci_softc -> ahc_pci_softc_t
-	
-		Implement ahc_freeze_scb() which is a no-op on Linux.
-	
-	aic7xxx_osm_pci.c:
-		ahc_pci_softc_t fallout.
-	
-		bus space fallout.
-	
-	aic7xxx_pci.c:
-		ahc_pci_softc_t fallout.
-	
-	aicasm_symbol.c:
-		Pick up the correct db header on non-linux platforms.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#21 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.h#10 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.seq#11 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#31 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#20 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#8 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_pci.c#5 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c#2 edit
-
-Change 64 by gibbs@overdrive on 2000/09/02 12:46:16
-
-	aic7xxx.c:
-		Add a chip name for the aic7895 Rev C.  We differentiate
-		between the C and all other revs, so it is best to report
-		explicitly to the user when we find this chip.
-	
-		Export ahc_print_scb();
-	
-		In restart_sequencer() do all of the things that the
-		sequencer used to do at startup.  This shaves quite
-		a few instructions and there is no reason to "optimize"
-		these steps as they happen very rarely.
-	
-		Add some useful TRACEPOINT code.
-	
-		Use SCB_BASE instead of SCB_CONTROL to reference the
-		start of SCB ram.  SCB_CONTROL is no longer the first
-		element in the SCB and this show why using a variable
-		location instead of a fixed constant is unwise.
-	
-		Explictily export controller information
-		(width, scsiid, number of SCBS, etc) via
-		ahc_controller_info() instead of spraying this
-		data out from all through ahc_init().  This
-		allows OSMs to display the data in any way
-		they see fit.
-	
-		Correct some SCB_BTT bugs.
-	
-		Size the downloaded constants table correctly.
-	
-	aic7xxx.h:
-		Give the aic7895C isn't own chip identifier.
-	
-		Note which controllers have the AUTOPAUSE feature.
-	
-		Add a bug entry for controllers that fail to handle
-		residual transfers after a PCI MWI transaction correctly.
-	
-		Move the status packet up to the top of the SCB in
-		preparation for shortening the number of bytes uploaded
-		during check condition and other errors.
-	
-		Store in our softc information about the pci cacheline size.
-	
-	aic7xxx.reg:
-		Move the SCB status packet up to the top of the SCB.
-	
-		Add a different download size for external SCB memory.
-		This appears to avoid a download corruption problem.
-	
-		Add the MWI_RESIDUAL field for the MWI sequencer workaround.
-	
-		Add a downloaded constants describing the PCI cachline size.
-	
-	aic7xxx.seq:
-		Move reset code into kernel space.
-	
-		Add MWI bug workaround.  Essentially we save off the
-		portion of the current S/G segment that goes beyond the
-		last cacheline and transfer this separately.
-	
-		Use SCB_BASE instead of SCB_CONTROL for referencing the
-		start of SCB space.
-	
-		Add a workaround for transferring an embedded CDB from
-		external scratch ram on the aic7895.  We must wait to
-		enable the DMA engine until after we have filled the
-		FIFO.
-	
-		Fix index_busy_target in the SCB_BTT case.
-	
-		Factor out some more code that is not needed when
-		we don't page SCBs.
-	
-		Replace explicit test against aic7895 in command channel
-		code with != ULTRA2.  This gives the same effect and
-		doesn't require us to also check to see if this is an aic7895C.
-	
-		If we have large external SCBs, download 48 bytes of
-		SCB instead of 32.  This appears to avoid an SCB
-		corruption problem.
-	
-		Solidify the PCI 2.1 retry problem on SCB dma operations
-		bug.  We now wait until we are sure the chip is hung
-		before touching the FIFO.  The old system seemed to
-		sometimes pull out data too soon or corrupt the
-		data.
-	
-	aic7xxx_inline.h:
-		Only explicitly pause the sequencer on command enqueue
-		operations if the chip does not have the auto-pause
-		feature or the queue registers feature.
-	
-	aic7xxx_osm.c:
-		Fix the number of trasactions we report as supporting
-		to the mid layer.  Also fix our max opening count.
-		It was possible to overrun the FIFOs if we were using
-		the SCB busy target table.
-	
-		Provide more controller information through aic7xxx_info()
-		via the ahc_controller_info() routine.
-	
-	aic7xxx_osm.h:
-		More "number of transactions" cleanups.
-	
-		Our per-device active and openings count must be
-		signed so we can properly reduce our opening count
-		when downgrading from tagged to untagged.
-	
-		Add a bit definition for the memory write and invalidate
-		enable PCI space bit.
-	
-		Provide more information to the user on underflow conditions.
-	
-	aic7xxx_pci.c:
-		Clean up the way that large SCBs are enabled.  This is
-		now only done in the ahc_probe_extscbs() routine.
-	
-		Fetch PCI cache line size information and put it in the
-		softc.
-	
-		Correct the seletion of large SCBs for Ultra2+ controllers
-		in the SCB config routine.
-	
-		If external SCBs are not present, run through the SCB
-		config routine with the default settings.  This avoids
-		having to put code to attain the defaults somewhere
-		else.
-	
-		Correct SCB_BTT feature enable logic.  We must have
-		external 64byte SCBs for this to work.
-	
-		If bootverbose, mention whether large SCBs are being
-		used.
-	
-		SCB_CONTROL->SCB_BASE.
-	
-		Output the Sequencer program address if we get a PCI
-		error.  Useful in debugging.
-	
-		Note which controllers require MWI workarounds.
-	
-		Differentiate even more between the aic7895 and aic7895C.
-		Add code to deal the the spurious DAC cycle problem,
-		but don't enable it just yet.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#20 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.h#9 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.reg#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.seq#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_inline.h#8 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#30 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#19 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_pci.c#4 edit
-
-Change 62 by gibbs@overdrive on 2000/08/29 05:51:37
-
-	Move to just a single driver version stored in aic7xxx_osm.h.
-	Cleanup information printed out at driver load time.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#29 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#18 edit
-
-Change 61 by gibbs@overdrive on 2000/08/29 05:46:33
-
-	aic7xxx.seq:
-		Be a little more careful in how we empty the FIFO
-		on PCI 2.1 compliant aic78XX chips.  After pulling
-		out 8 bytes, wait for the FIFO to get some data
-		before testing to see if we are hung.
-	
-	aic7xxx_osm.c:
-		Fix the abort collision case in the device queue by
-		setting CAM_SIM_QUEUED only once aic7xxx_queue() has
-		released ownership of the SCB.  The old code was somewhat
-		confused in how it flagged transactions as still being
-		owned by aic7xxx_queue().
-	
-		Revert ahc_queue_busy_scb() and instead implement a
-		roll_back function ahc_free_busy_scb().  This makes
-		it much clearer who is aborting which scbs and how.
-		This required implementing ahc_unmap_scb() for use
-		by both ahc_done() and ahc_free_busy_scb().
-	
-		Correct ahc_platform_abort_scbs to abort the correct
-		device.  It was not checking wide/twin controller
-		properties and also suffered from a cut 'n paste error
-		that corrupted how the luns to traverse were determined.
-	
-	aic7xxx_osm.h:
-		Only return the low byte of the transaction status to
-		the rest of the world, but allow the high byte to be
-		set.  This simplifies handling of the CAM_SIM_QUEUED
-		flag.
-	
-	cam.h:
-		Add the CAM_SIM_QUEUED flag.  This flag is only used
-		in the device busy queue and indicates that the transaction
-		in the queue is no longer being operated on by aic7xxx_queue().
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.seq#6 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#28 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#17 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#7 edit
-
-Change 60 by gibbs@overdrive on 2000/08/24 12:12:57
-
-	Turn on ktext expansion for all files.
-	
-	Add $Id$ where appropriate.
-	
-	Add PCI 2.1 Retry bug workaround.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#19 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.h#8 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.seq#5 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_93cx6.c#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_93cx6.h#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_eisa.c#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_inline.h#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#27 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#16 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_eisa.c#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_pci.c#3 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#3 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/Makefile#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#6 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/queue.h#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/scsi_message.h#3 edit
-
-Change 59 by gibbs@overdrive on 2000/08/22 08:26:27
-
-	Change the name of our controller to scsi%d once we know the host
-	number.  Until that time, use a bus specific name.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#18 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.h#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#26 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#6 edit
-
-Change 58 by gibbs@overdrive on 2000/08/22 07:29:04
-
-	Remove old, #ifdef'd out, abort/reset implementations.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#25 edit
-
-Change 57 by gibbs@overdrive on 2000/08/22 07:20:46
-
-	Remove debugging printfs.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#5 edit
-
-Change 56 by gibbs@overdrive on 2000/08/22 06:53:44
-
-	aic7xxx.c:
-		For no, leave all locking to OSM layer.
-	
-	aic7xxx_osm.c:
-		Correct Adaptec copyright.
-	
-		Conditionalize inclusion of linux/init.h
-	
-		Add proc_dir_entry for older kernels.
-	
-		Don't declare static, entry points that may be
-		called externally in a static kernel linkage
-		configuration.
-	
-		Fixup abort processing for entries in the dev
-		queue.  We first bring these transactions up
-		to a state where ahc_done() will work on them,
-		and then call ahc_done().  This ensures that
-		all mapped memory for the transaction, etc. is
-		released.
-	
-		Becareful not to overwrite the sense data buffer
-		in Scsi_Cmnd's.
-	
-		Guard against null host structures in aic7xxx_release.
-	
-	aic7xxx_osm.h:
-		Remove bogus status checking in ahc_set_transaction_status().
-	
-	aic7xxx_osm_pci.c:
-		Use pci_find_class() to enumerate PCI devices.  This should
-		work acceptably in all kernel versions we support.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#17 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#24 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#15 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#4 edit
-
-Change 54 by gibbs@overdrive on 2000/08/21 12:30:49
-
-	When aborting commands in our per-device queues, queue them
-	to the complete queue, thus avoiding the dead-lock of a direct
-	completion.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#23 edit
-
-Change 53 by gibbs@overdrive on 2000/08/21 09:50:38
-
-	Use DID_BUS_BUSY for CAM_REQUEUE_REQ.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#22 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#5 edit
-
-Change 52 by gibbs@overdrive on 2000/08/21 09:37:53
-
-	Implement aic7xxx_biosparam, finish tagged queuing implementation,
-	and complete the port to 2.2.14.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#21 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#14 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#3 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#4 edit
-
-Change 51 by gibbs@overdrive on 2000/08/12 10:40:14
-
-	aic7xxx.c:
-		Add a platform callback to notify the system when
-		tag settings change.  We use this to freeze the
-		device queue until all oustanding transaction complete
-		when the tag type changes.
-	
-	aic7xxx_osm.c:
-		Add support for releasing the queue when the active
-		count goes to 0 for a particular device.
-	
-		Implement ahc_platform_set_tags() which will freeze
-		the queue when tag types change.
-	
-		In ahc_filter_cmd(), enable tags if the device supports them.
-	
-	aic7xxx_osm.h:
-		Prototype for ahc_platform_set_tags().
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#16 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#20 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#13 edit
-
-Change 50 by gibbs@overdrive on 2000/08/12 10:10:26
-
-	Kill a diagnostic printf.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#19 edit
-
-Change 49 by gibbs@overdrive on 2000/08/12 10:06:51
-
-	Switch to queing SCBs not Linux scsi commands in our busy
-	queues.  This avoids a locking and latency issues when we
-	have to run the queues from interrupt context.
-	
-	Run the busyq at the end of ahc_done.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#18 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#12 edit
-
-Change 48 by gibbs@overdrive on 2000/08/12 09:25:34
-
-	aic7xxx.c:
-		Add a platform callbacks for aborting transactions
-		sitting in OSM queues.
-	
-	aic7xxx_inline.h:
-		Don't lock in ahc_get_scb.  Let the OSM do this
-		as it may need to lock other data structures (using
-		the same lock) around the time it aquires the SCB.
-	
-	aic7xxx_osm.c:
-		Implement Linux version of the transaction abort
-		callbacks.
-	
-		Modify ahc_get_device() to only allocate device
-		entries if asked.  This allows this routine to
-		be used to see if a device exists at that location.
-	
-		Modify aic7xxx_queue() so that incoming commands
-		are placed into the device busy queue and that
-		transactions are only run if the device has
-		openings available and is not frozen.
-	
-		Check to see if a command has been aborted after
-		re-acquiring the ahc lock at the tail end of
-		aic7xxx_queue().
-	
-		Modify ahc_alloc_device() to initialize the openings
-		and maxtags fields.
-	
-	aic7xxx_osm.h:
-		Add Adaptec Copyright.
-	
-		Add device fields required to handle tagged queuing.
-	
-		Add function prototypes for ahc_platform abort routines.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#15 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_inline.h#6 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#17 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#11 edit
-
-Change 47 by gibbs@overdrive on 2000/08/12 07:00:10
-
-	Swith to using a union in ahc_cmd so we can avoid excessive
-	casting.
-	
-	Sort entries as they are inserted onto the completeq so that
-	transaction ordering for retried transactions is maintained.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#16 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#10 edit
-
-Change 46 by gibbs@overdrive on 2000/08/12 06:25:07
-
-	aic7xxx.c:
-		Remove some debugging printfs.
-	
-		Correctly deal with TWIN channel adapters when
-		dealing with the busy target table or busy target
-		queues.
-	
-	aic7xxx_osm.c:
-		Correct memset call in ahc_alloc_device() to
-		zero the correct nuber of bytes.
-	
-	aic7xxx_osm_pci.c:
-		Remove some debugging printfs.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#14 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#15 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#2 edit
-
-Change 45 by gibbs@overdrive on 2000/08/11 09:20:01
-
-	Set scb->platform_data->dev in aic7xxx_queue().
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#14 edit
-
-Change 44 by gibbs@overdrive on 2000/08/11 08:47:10
-
-	Correct addressing for per-device data-structures for
-	twin channel devices.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#13 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#9 edit
-
-Change 43 by gibbs@overdrive on 2000/08/11 08:40:12
-
-	aic7xxx.c:
-		Remove the "SEARCH_REMOVE" case from ahc_search_action.
-		It is never used and it would be hard to create sane
-		semantics for its use.
-	
-		scbp->scb to match most of the rest of the driver.
-	
-		In ahc_search_qinfifo(), handle the untagged queues
-		as well.  To the rest of the system, these are just
-		another part of the input fifo.
-	
-	aic7xxx_osm.c:
-		Add Adaptec Inc. copyright.
-	
-		Add a mechanism for allocating and freeing a per-device
-		data-structure for queue and other management.  The
-		data structure is persistent so long as commands for
-		that device are outstanding and/or we've seen a proper
-		inquiry response from that device that makes us believe
-		there is a persistent device at that location (target/lun).
-	
-	aic7xxx_osm.h:
-		Per-device data structure definitions.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#13 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#12 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#8 edit
-
-Change 42 by gibbs@overdrive on 2000/08/11 04:43:03
-
-	Initialize the completeq with STAILQ_INIT now that it is an
-	STAILQ.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#11 edit
-
-Change 41 by gibbs@overdrive on 2000/08/11 04:37:07
-
-	Use a shaddow structure of scsi_cmnd so we can name fields
-	"reserved" for HBA use however we wish.  This lets us use
-	the queue macros for queuing these structures.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#10 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#7 edit
-
-Change 37 by gibbs@overdrive on 2000/08/10 08:07:55
-
-	aic7xxx.c:
-	aic7xxx.h:
-		Move more function declarations to global scope.
-	
-	aic7xxx_osm.c:
-		Implement a mechanism to sniff completed commands
-		that complete with good status.  We use this to
-		sniff completed inquiry responses for targets to
-		determine there transfer capabilities.
-	
-	aic7xxx_osm.h:
-		Add a definition for the inquiry response format
-		for use by our transaction sniffer.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#9 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.h#5 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#9 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#6 edit
-
-Change 36 by gibbs@overdrive on 2000/08/10 06:34:34
-
-	Spaces to tabs.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#8 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#8 edit
-
-Change 35 by gibbs@overdrive on 2000/08/10 05:33:22
-
-	aic7xxx.c:
-		Add ahc_busy_tcl().  This routine is used to add
-		an SCBID to the busy target's table.  Right now this
-		is only used when transitioning a transaction from
-		tagged to untagged when a tag message is rejected.
-	
-		Move some function prototypes to aic7xxx.h for use
-		by other modules.
-	
-		Re-enable code that sets transaction status now that
-		we have an OSM method for doing this.
-	
-		Kill some debugging printfs.
-	
-	aic7xxx.h:
-		Added function prototypes for methods in aic7xxx.c
-	
-	aic7xxx.seq:
-		For added safety, when handling a data overrun,
-		clear STCNT before going into bit-bucket mode.
-		clearing STCNT should ensure that the data channel
-		will not resume a previous transfer setup via
-		PRELOADEN.
-	
-	aic7xxx_inline.h:
-		The controller lock is always held when a transaction is
-		freed.  Don't bother re-acquiring it is ahc_free_scb().
-	
-		Kill more diagnostic printfs.
-	
-	aic7xxx_osm.c:
-		Inline completion queue routines.
-	
-		Reset the bus on startup for now.  Later we will honor
-		non-volatile card setting and if no reset is requested,
-		we will negotiate on the first transaction.
-	
-		Store a pointer to a scsi command's scb in the host_scribble
-		area while the command is outstanding.  This allows us
-		to get back to the SCB from within the abort/reset routines.
-	
-		Check cmd->use_sg consistently.  Even if only one SG is
-		provided, we must still treat the request_buffer pointer
-		as a pointer to a list of SG structures, not a contiguous
-		buffer.
-	
-		Fixup some bugs in how were were initializing SCBs in the
-		aic7xxx_queue routine.
-	
-		Keep track of pending SCBs in the pending_scb list.  The
-		core routines in aic7xxx.c expect to find pending SCBS
-		here.
-	
-		Properly remove untagged transactions from the untagged
-		queue when they complete.
-	
-		Set transaction status to DID_OK (CAM_REQ_CMP) if, at
-		ahc_done time, the status is still CAM_REQ_INPROG.
-	
-		Add some diagnostic code to the abort routine so we
-		can determine why the mid-layer decided an abort was
-		necessary.
-	
-	aic7xxx_osm.h:
-		Make the ahc_done_lock a no-op on systems that use
-		interrupt blocking for locks.  The softc lock is always
-		while the done lock is held, so no additional protection
-		is required.
-	
-		Add accessers for both the transaction and scsi status
-		fields.  These are used by core code.
-	
-	cam.h:
-		Switch CAM_SEL_TIMEOUT from "DID_TIME_OUT" to
-		"DID_NO_CONNECT".  This seems more correct based
-		on a quick look at scsi_error.c of the mid-layer.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.h#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.seq#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_inline.h#5 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#7 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#5 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#3 edit
-
-Change 32 by gibbs@overdrive on 2000/08/09 07:31:45
-
-	aic7xxx.c:
-		Remove duplicate OSM function ahc_scb_set_residual().
-		We already had ahc_set_residual().
-	
-		Use platform independent method for storing retrieved
-		sense data.
-	
-	aic7xxx_osm.c:
-		Add a deferred completion queue.  The queue is filled
-		by ahc_done() and run from either our interrupt handler,
-		or error recovery routines after all commands are queued
-		for completion.
-	
-		Keep track of the size of our transfer.  This is later
-		used in residual handling.
-	
-		Implement basic ahc_done() routine.  This will need to
-		be enhanced to deal with things like queue full.
-	
-	aic7xxx_osm.h:
-		Implement the completeq.  Due to the nature of the
-		scsi_cmnd structure, we cannot use a <sys/queue.h>
-		style queue for this, so create a simple LIFO.
-	
-		Flesh out the inline accessors to OSM dependent
-		per transaction data fields.
-	
-	cam.h:
-		Map CAM status to Linux SCSI status codes.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#6 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#2 edit
-
-Change 31 by gibbs@overdrive on 2000/08/08 13:11:38
-
-	Debug adapter queue command path.  We can now queue a command,
-	have the sequencer complete it, and route the compelted
-	command to ahc_done().
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#3 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_inline.h#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#5 edit
-
-Change 30 by gibbs@overdrive on 2000/08/08 10:01:08
-
-	First pass at the aic7xxx_queue routine.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#4 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#3 edit
-
-Change 29 by gibbs@overdrive on 2000/08/08 07:41:45
-
-	Missed in prior checkin.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_inline.h#3 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_pci.c#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#2 edit
-
-Change 27 by gibbs@overdrive on 2000/08/08 07:10:41
-
-	Add definitions to properly lock the system when returning
-	commands back to the OS.
-	
-	Hook up our interrupt handler.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.c#2 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#3 edit
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#2 edit
-
-Change 26 by gibbs@overdrive on 2000/08/08 05:59:33
-
-	Get us to the point where we can successfully register
-	PCI adapters.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#2 edit
-
-Change 25 by gibbs@overdrive on 2000/08/08 05:58:36
-
-	More infrastructure - mostly from FreeBSD.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_93cx6.h#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_eisa.c#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_eisa.c#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/queue.h#1 add
-
-Change 19 by gibbs@overdrive on 2000/07/28 03:12:09
-
-	Move into our sub-directory.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#1 branch
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx_proc.c#4 delete
-
-Change 18 by gibbs@overdrive on 2000/07/27 12:00:48
-
-	Use the old Linux driver as the foundation for the Linux
-	specific core file.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#1 branch
-
-Change 7 by gibbs@overdrive on 2000/07/13 07:09:24
-
-	Latest SCSI message file from FreeBSD.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/scsi_message.h#2 edit
-
-Change 5 by gibbs@overdrive on 2000/07/13 07:07:29
-
-	Move the assembler to its own subdirectory.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/Makefile#3 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm.c#2 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm.h#2 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/Makefile#1 branch
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm.c#1 branch
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm.h#1 branch
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y#1 branch
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h#1 branch
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l#1 branch
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c#1 branch
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h#1 branch
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm_gram.y#2 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm_insformat.h#3 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm_scan.l#2 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm_symbol.c#3 delete
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aicasm_symbol.h#2 delete
-
-Change 1 by gibbs@overdrive on 2000/07/12 11:01:33
-
-	Initial import of Doug Ledford's aic7xxx driver v5.2.0.
-
-Affected files ...
-
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx.c#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx.h#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.reg#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx.seq#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/scsi_message.h#1 add
-... //depot/aic7xxx/linux/drivers/scsi/aic7xxx/sequencer.h#1 add
-
diff -urNp linux-5720/drivers/scsi/aic79xx/Config.in linux-5730/drivers/scsi/aic79xx/Config.in
--- linux-5720/drivers/scsi/aic79xx/Config.in
+++ linux-5730/drivers/scsi/aic79xx/Config.in
@@ -1,17 +0,0 @@
-dep_tristate 'Adaptec AIC79xx support' CONFIG_SCSI_AIC79XX $CONFIG_SCSI
-if [ "$CONFIG_SCSI_AIC79XX" != "n" ]; then
-   int  '  Maximum number of TCQ commands per device' \
-	CONFIG_AIC79XX_CMDS_PER_DEVICE 32
-   int  '  Initial bus reset delay in milli-seconds' \
-	CONFIG_AIC79XX_RESET_DELAY_MS 15000
-   bool  '  Build Adapter Firmware with Kernel Build' \
-	CONFIG_AIC79XX_BUILD_FIRMWARE
-   bool  '  Enable Read Streaming for All Targets' \
-	CONFIG_AIC79XX_ENABLE_RD_STRM
-   bool  '  Compile in Debugging Code' \
-	CONFIG_AIC79XX_DEBUG_ENABLE
-   int  '  Debug code enable mask (16384 for all debugging)' \
-	CONFIG_AIC79XX_DEBUG_MASK 0
-   bool  '  Decode registers during diagnostics' \
-	CONFIG_AIC79XX_REG_PRETTY_PRINT
-fi
diff -urNp linux-5720/drivers/scsi/aic79xx/Makefile linux-5730/drivers/scsi/aic79xx/Makefile
--- linux-5720/drivers/scsi/aic79xx/Makefile
+++ linux-5730/drivers/scsi/aic79xx/Makefile
@@ -1,50 +0,0 @@
-#
-# drivers/scsi/aic79xx/Makefile
-#
-# Makefile for the Linux aic79xx SCSI driver.
-#
-
-O_TARGET := aic79xx_drv.o
-
-list-multi	:= aic79xx.o
-
-obj-$(CONFIG_SCSI_AIC79XX)	+= aic79xx.o
-
-EXTRA_CFLAGS += -I..
-#EXTRA_CFLAGS += -g
-
-# Platform Specific U320 Files
-obj-aic79xx = aic79xx_osm.o aic79xx_proc.o aic79xx_osm_pci.o
-# Core Files
-obj-aic79xx += aic79xx_core.o aic79xx_pci.o
-ifeq ($(CONFIG_AIC79XX_REG_PRETTY_PRINT),y)
-obj-aic79xx += aic79xx_reg_print.o
-endif
-
-# Override our module desitnation
-MOD_DESTDIR = $(shell cd .. && $(CONFIG_SHELL) $(TOPDIR)/scripts/pathdown.sh)
-
-include $(TOPDIR)/Rules.make
-
-aic79xx_core.o: aic79xx_seq.h
-$(obj-aic79xx): aic79xx_reg.h
-aic79xx.o: aic79xx_seq.h aic79xx_reg.h $(obj-aic79xx)
-	$(LD) $(LD_RFLAG) -r -o $@ $(obj-aic79xx)
-
-ifeq ($(CONFIG_AIC79XX_BUILD_FIRMWARE),y)
-aic79xx_gen = aic79xx_seq.h aic79xx_reg.h
-ifeq ($(CONFIG_AIC79XX_REG_PRETTY_PRINT),y)
-aic79xx_gen += aic79xx_reg_print.c
-aic79xx_asm_cmd = aicasm/aicasm -I. -r aic79xx_reg.h		\
-		 -p aic79xx_reg_print.c -i aic79xx_osm.h	\
-		 -o aic79xx_seq.h aic79xx.seq
-else
-aic79xx_asm_cmd = aicasm/aicasm -I. -r aic79xx_reg.h \
-		 -o aic79xx_seq.h aic79xx.seq
-endif
-$(aic79xx_gen): aic79xx.seq aic79xx.reg aicasm/aicasm
-	$(aic79xx_asm_cmd)
-endif
-
-aicasm/aicasm: aicasm/*.[chyl]
-	$(MAKE) -C aicasm
diff -urNp linux-5720/drivers/scsi/aic79xx/aic79xx.h linux-5730/drivers/scsi/aic79xx/aic79xx.h
--- linux-5720/drivers/scsi/aic79xx/aic79xx.h
+++ linux-5730/drivers/scsi/aic79xx/aic79xx.h
@@ -1,1480 +0,0 @@
-/*
- * Core definitions and data structures shareable across OS platforms.
- *
- * Copyright (c) 1994-2002 Justin T. Gibbs.
- * Copyright (c) 2000-2002 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.h#78 $
- *
- * $FreeBSD$
- */
-
-#ifndef _AIC79XX_H_
-#define _AIC79XX_H_
-
-/* Register Definitions */
-#include "aic79xx_reg.h"
-
-/************************* Forward Declarations *******************************/
-struct ahd_platform_data;
-struct scb_platform_data;
-
-/****************************** Useful Macros *********************************/
-#ifndef MAX
-#define MAX(a,b) (((a) > (b)) ? (a) : (b))
-#endif
-
-#ifndef MIN
-#define MIN(a,b) (((a) < (b)) ? (a) : (b))
-#endif
-
-#ifndef TRUE
-#define TRUE 1
-#endif
-#ifndef FALSE
-#define FALSE 0
-#endif
-
-#define NUM_ELEMENTS(array) (sizeof(array) / sizeof(*array))
-
-#define ALL_CHANNELS '\0'
-#define ALL_TARGETS_MASK 0xFFFF
-#define INITIATOR_WILDCARD	(~0)
-#define	SCB_LIST_NULL		0xFF00
-#define	SCB_LIST_NULL_LE	(ahd_htole16(SCB_LIST_NULL))
-#define QOUTFIFO_ENTRY_VALID 0x8000
-#define QOUTFIFO_ENTRY_VALID_LE (ahd_htole16(0x8000))
-#define SCBID_IS_NULL(scbid) (((scbid) & 0xFF00 ) == SCB_LIST_NULL)
-
-#define SCSIID_TARGET(ahd, scsiid)	\
-	(((scsiid) & TID) >> TID_SHIFT)
-#define SCSIID_OUR_ID(scsiid)		\
-	((scsiid) & OID)
-#define SCSIID_CHANNEL(ahd, scsiid) ('A')
-#define	SCB_IS_SCSIBUS_B(ahd, scb) (0)
-#define	SCB_GET_OUR_ID(scb) \
-	SCSIID_OUR_ID((scb)->hscb->scsiid)
-#define	SCB_GET_TARGET(ahd, scb) \
-	SCSIID_TARGET((ahd), (scb)->hscb->scsiid)
-#define	SCB_GET_CHANNEL(ahd, scb) \
-	SCSIID_CHANNEL(ahd, (scb)->hscb->scsiid)
-#define	SCB_GET_LUN(scb) \
-	((scb)->hscb->lun)
-#define SCB_GET_TARGET_OFFSET(ahd, scb)	\
-	SCB_GET_TARGET(ahd, scb)
-#define SCB_GET_TARGET_MASK(ahd, scb) \
-	(0x01 << (SCB_GET_TARGET_OFFSET(ahd, scb)))
-#ifdef AHD_DEBUG
-#define SCB_IS_SILENT(scb)					\
-	((ahd_debug & AHD_SHOW_MASKED_ERRORS) == 0		\
-      && (((scb)->flags & SCB_SILENT) != 0))
-#else
-#define SCB_IS_SILENT(scb)					\
-	(((scb)->flags & SCB_SILENT) != 0)
-#endif
-/*
- * TCLs have the following format: TTTTLLLLLLLL
- */
-#define TCL_TARGET_OFFSET(tcl) \
-	((((tcl) >> 4) & TID) >> 4)
-#define TCL_LUN(tcl) \
-	(tcl & (AHD_NUM_LUNS - 1))
-#define BUILD_TCL(scsiid, lun) \
-	((lun) | (((scsiid) & TID) << 4))
-#define BUILD_TCL_RAW(target, channel, lun) \
-	((lun) | ((target) << 8))
-
-#define SCB_GET_TAG(scb) \
-	ahd_le16toh(scb->hscb->tag)
-
-#ifndef	AHD_TARGET_MODE
-#undef	AHD_TMODE_ENABLE
-#define	AHD_TMODE_ENABLE 0
-#endif
-
-#define AHD_BUILD_COL_IDX(target, lun)				\
-	(((lun) << 4) | target)
-
-#define AHD_GET_SCB_COL_IDX(ahd, scb)				\
-	((SCB_GET_LUN(scb) << 4) | SCB_GET_TARGET(ahd, scb))
-
-#define AHD_SET_SCB_COL_IDX(scb, col_idx)				\
-do {									\
-	(scb)->hscb->scsiid = ((col_idx) << TID_SHIFT) & TID;		\
-	(scb)->hscb->lun = ((col_idx) >> 4) & (AHD_NUM_LUNS_NONPKT-1);	\
-} while (0)
-
-#define AHD_COPY_SCB_COL_IDX(dst, src)				\
-do {								\
-	dst->hscb->scsiid = src->hscb->scsiid;			\
-	dst->hscb->lun = src->hscb->lun;			\
-} while (0)
-
-#define	AHD_NEVER_COL_IDX 0xFFFF
-
-/**************************** Driver Constants ********************************/
-/*
- * The maximum number of supported targets.
- */
-#define AHD_NUM_TARGETS 16
-
-/*
- * The maximum number of supported luns.
- * The identify message only supports 64 luns in non-packetized transfers.
- * You can have 2^64 luns when information unit transfers are enabled,
- * but until we see a need to support that many, we support 256.
- */
-#define AHD_NUM_LUNS_NONPKT 64
-#define AHD_NUM_LUNS 256
-
-/*
- * The maximum transfer per S/G segment.
- */
-#define AHD_MAXTRANSFER_SIZE	 0x00ffffff	/* limited by 24bit counter */
-
-/*
- * The maximum amount of SCB storage in hardware on a controller.
- * This value represents an upper bound.  Due to software design,
- * we may not be able to use this number.
- */
-#define AHD_SCB_MAX	512
-
-/*
- * The maximum number of concurrent transactions supported per driver instance.
- * Sequencer Control Blocks (SCBs) store per-transaction information.
- */
-#define AHD_MAX_QUEUE	AHD_SCB_MAX
-
-/*
- * Define the size of our QIN and QOUT FIFOs.  They must be a power of 2
- * in size and accomodate as many transactions as can be queued concurrently.
- */
-#define	AHD_QIN_SIZE	AHD_MAX_QUEUE
-#define	AHD_QOUT_SIZE	AHD_MAX_QUEUE
-
-#define AHD_QIN_WRAP(x) ((x) & (AHD_QIN_SIZE-1))
-/*
- * The maximum amount of SCB storage we allocate in host memory.
- */
-#define AHD_SCB_MAX_ALLOC AHD_MAX_QUEUE
-
-/*
- * Ring Buffer of incoming target commands.
- * We allocate 256 to simplify the logic in the sequencer
- * by using the natural wrap point of an 8bit counter.
- */
-#define AHD_TMODE_CMDS	256
-
-/* Reset line assertion time in us */
-#define AHD_BUSRESET_DELAY	25
-
-/******************* Chip Characteristics/Operating Settings  *****************/
-/*
- * Chip Type
- * The chip order is from least sophisticated to most sophisticated.
- */
-typedef enum {
-	AHD_NONE	= 0x0000,
-	AHD_CHIPID_MASK	= 0x00FF,
-	AHD_AIC7901	= 0x0001,
-	AHD_AIC7902	= 0x0002,
-	AHD_AIC7901A	= 0x0003,
-	AHD_PCI		= 0x0100,	/* Bus type PCI */
-	AHD_PCIX	= 0x0200,	/* Bus type PCIX */
-	AHD_BUS_MASK	= 0x0F00
-} ahd_chip;
-
-/*
- * Features available in each chip type.
- */
-typedef enum {
-	AHD_FENONE		= 0x00000,
-	AHD_WIDE  		= 0x00001,/* Wide Channel */
-	AHD_MULTI_FUNC		= 0x00100,/* Multi-Function/Channel Device */
-	AHD_TARGETMODE		= 0x01000,/* Has tested target mode support */
-	AHD_MULTIROLE		= 0x02000,/* Space for two roles at a time */
-	AHD_RTI			= 0x04000,/* Retained Training Support */
-	AHD_NEW_IOCELL_OPTS	= 0x08000,/* More Signal knobs in the IOCELL */
-	AHD_NEW_DFCNTRL_OPTS	= 0x10000,/* SCSIENWRDIS bit */
-	AHD_REMOVABLE		= 0x00000,/* Hot-Swap supported - None so far*/
-	AHD_AIC7901_FE		= AHD_FENONE,
-	AHD_AIC7902_FE		= AHD_MULTI_FUNC
-} ahd_feature;
-
-/*
- * Bugs in the silicon that we work around in software.
- */
-typedef enum {
-	AHD_BUGNONE		= 0x0000,
-	/*
-	 * Rev A hardware fails to update LAST/CURR/NEXTSCB
-	 * correctly in certain packetized selection cases.
-	 */
-	AHD_SENT_SCB_UPDATE_BUG	= 0x0001,
-	/* The wrong SCB is accessed to check the abort pending bit. */
-	AHD_ABORT_LQI_BUG	= 0x0002,
-	/* Packetized bitbucket crosses packet boundaries. */
-	AHD_PKT_BITBUCKET_BUG	= 0x0004,
-	/* The selection timer runs twice as long as its setting. */
-	AHD_LONG_SETIMO_BUG	= 0x0008,
-	/* The Non-LQ CRC error status is delayed until phase change. */
-	AHD_NLQICRC_DELAYED_BUG	= 0x0010,
-	/* The chip must be reset for all outgoing bus resets.  */
-	AHD_SCSIRST_BUG		= 0x0020,
-	/* Some PCIX fields must be saved and restored across chip reset. */
-	AHD_PCIX_CHIPRST_BUG	= 0x0040,
-	/* MMAPIO is not functional in PCI-X mode.  */
-	AHD_PCIX_MMAPIO_BUG	= 0x0080,
-	/* Bug workarounds that can be disabled on non-PCIX busses. */
-	AHD_PCIX_BUG_MASK	= AHD_PCIX_CHIPRST_BUG
-				| AHD_PCIX_MMAPIO_BUG,
-	/*
-	 * LQOSTOP0 status set even for forced selections with ATN
-	 * to perform non-packetized message delivery.
-	 */
-	AHD_LQO_ATNO_BUG	= 0x0100,
-	/* FIFO auto-flush does not always trigger.  */
-	AHD_AUTOFLUSH_BUG	= 0x0200,
-	/* The CLRLQO registers are not self-clearing. */
-	AHD_CLRLQO_AUTOCLR_BUG	= 0x0400,
-	/* The PACKETIZED status bit refers to the previous connection. */
-	AHD_PKTIZED_STATUS_BUG  = 0x0800,
-	/* "Short Luns" are not placed into outgoing LQ packets correctly. */
-	AHD_PKT_LUN_BUG		= 0x1000,
-	/*
-	 * Only the FIFO allocated to the non-packetized connection may
-	 * be in use during a non-packetzied connection.
-	 */
-	AHD_NONPACKFIFO_BUG	= 0x2000,
-	/*
-	 * Writing to a DFF SCBPTR register may fail if concurent with
-	 * a hardware write to the other DFF SCBPTR register.  This is
-	 * not currently a concern in our sequencer since all chips with
-	 * this bug have the AHD_NONPACKFIFO_BUG and all writes of concern
-	 * occur in non-packetized connections.
-	 */
-	AHD_MDFF_WSCBPTR_BUG	= 0x4000,
-	/* SGHADDR updates are slow. */
-	AHD_REG_SLOW_SETTLE_BUG	= 0x8000,
-	/*
-	 * Changing the MODE_PTR coincident with an interrupt that
-	 * switches to a different mode will cause the interrupt to
-	 * be in the mode written outside of interrupt context.
-	 */
-	AHD_SET_MODE_BUG	= 0x10000,
-	/* Non-packetized busfree revision does not work. */
-	AHD_BUSFREEREV_BUG	= 0x20000,
-	/*
-	 * Paced transfers are indicated with a non-standard PPR
-	 * option bit in the neg table, 160MHz is indicated by
-	 * sync factor 0x7, and the offset if off by a factor of 2.
-	 */
-	AHD_PACED_NEGTABLE_BUG	= 0x40000,
-	/* LQOOVERRUN false positives. */
-	AHD_LQOOVERRUN_BUG	= 0x80000,
-	/*
-	 * Controller write to INTSTAT will lose to a host
-	 * write to CLRINT.
-	 */
-	AHD_INTCOLLISION_BUG	= 0x100000
-} ahd_bug;
-
-/*
- * Configuration specific settings.
- * The driver determines these settings by probing the
- * chip/controller's configuration.
- */
-typedef enum {
-	AHD_FNONE	      = 0x00000,
-	AHD_PRIMARY_CHANNEL   = 0x00003,/*
-					 * The channel that should
-					 * be probed first.
-					 */
-	AHD_USEDEFAULTS	      = 0x00004,/*
-					 * For cards without an seeprom
-					 * or a BIOS to initialize the chip's
-					 * SRAM, we use the default target
-					 * settings.
-					 */
-	AHD_SEQUENCER_DEBUG   = 0x00008,
-	AHD_RESET_BUS_A	      = 0x00010,
-	AHD_EXTENDED_TRANS_A  = 0x00020,
-	AHD_TERM_ENB_A	      = 0x00040,
-	AHD_SPCHK_ENB_A	      = 0x00080,
-	AHD_STPWLEVEL_A	      = 0x00100,
-	AHD_INITIATORROLE     = 0x00200,/*
-					 * Allow initiator operations on
-					 * this controller.
-					 */
-	AHD_TARGETROLE	      = 0x00400,/*
-					 * Allow target operations on this
-					 * controller.
-					 */
-	AHD_RESOURCE_SHORTAGE = 0x00800,
-	AHD_TQINFIFO_BLOCKED  = 0x01000,/* Blocked waiting for ATIOs */
-	AHD_INT50_SPEEDFLEX   = 0x02000,/*
-					 * Internal 50pin connector
-					 * sits behind an aic3860
-					 */
-	AHD_BIOS_ENABLED      = 0x04000,
-	AHD_ALL_INTERRUPTS    = 0x08000,
-	AHD_39BIT_ADDRESSING  = 0x10000,/* Use 39 bit addressing scheme. */
-	AHD_64BIT_ADDRESSING  = 0x20000,/* Use 64 bit addressing scheme. */
-	AHD_CURRENT_SENSING   = 0x40000,
-	AHD_SCB_CONFIG_USED   = 0x80000,/* No SEEPROM but SCB had info. */
-	AHD_HP_BOARD	      = 0x100000,
-	AHD_RESET_POLL_ACTIVE = 0x200000,
-	AHD_UPDATE_PEND_CMDS  = 0x400000,
-	AHD_RUNNING_QOUTFIFO  = 0x800000
-} ahd_flag;
-
-/************************* Hardware  SCB Definition ***************************/
-
-/*
- * The driver keeps up to MAX_SCB scb structures per card in memory.  The SCB
- * consists of a "hardware SCB" mirroring the fields availible on the card
- * and additional information the kernel stores for each transaction.
- *
- * To minimize space utilization, a portion of the hardware scb stores
- * different data during different portions of a SCSI transaction.
- * As initialized by the host driver for the initiator role, this area
- * contains the SCSI cdb (or a pointer to the  cdb) to be executed.  After
- * the cdb has been presented to the target, this area serves to store
- * residual transfer information and the SCSI status byte.
- * For the target role, the contents of this area do not change, but
- * still serve a different purpose than for the initiator role.  See
- * struct target_data for details.
- */
-
-/*
- * Status information embedded in the shared poriton of
- * an SCB after passing the cdb to the target.  The kernel
- * driver will only read this data for transactions that
- * complete abnormally.
- */
-struct initiator_status {
-	uint32_t residual_datacnt;	/* Residual in the current S/G seg */
-	uint32_t residual_sgptr;	/* The next S/G for this transfer */
-	uint8_t	 scsi_status;		/* Standard SCSI status byte */
-};
-
-struct target_status {
-	uint32_t residual_datacnt;	/* Residual in the current S/G seg */
-	uint32_t residual_sgptr;	/* The next S/G for this transfer */
-	uint8_t  scsi_status;		/* SCSI status to give to initiator */
-	uint8_t  target_phases;		/* Bitmap of phases to execute */
-	uint8_t  data_phase;		/* Data-In or Data-Out */
-	uint8_t  initiator_tag;		/* Initiator's transaction tag */
-};
-
-/*
- * Initiator mode SCB shared data area.
- * If the embedded CDB is 12 bytes or less, we embed
- * the sense buffer address in the SCB.  This allows
- * us to retrieve sense information without interupting
- * the host in packetized mode.
- */
-typedef uint32_t sense_addr_t;
-#define MAX_CDB_LEN 16
-#define MAX_CDB_LEN_WITH_SENSE_ADDR (MAX_CDB_LEN - sizeof(sense_addr_t))
-union initiator_data {
-	uint64_t cdbptr;
-	uint8_t	 cdb[MAX_CDB_LEN];
-	struct {
-		uint8_t	 cdb[MAX_CDB_LEN_WITH_SENSE_ADDR];
-		sense_addr_t sense_addr;
-	} cdb_plus_saddr;
-};
-
-/*
- * Target mode version of the shared data SCB segment.
- */
-struct target_data {
-	uint32_t spare[2];	
-	uint8_t  scsi_status;		/* SCSI status to give to initiator */
-	uint8_t  target_phases;		/* Bitmap of phases to execute */
-	uint8_t  data_phase;		/* Data-In or Data-Out */
-	uint8_t  initiator_tag;		/* Initiator's transaction tag */
-};
-
-struct hardware_scb {
-/*0*/	union {
-		union	initiator_data idata;
-		struct	target_data tdata;
-		struct	initiator_status istatus;
-		struct	target_status tstatus;
-	} shared_data;
-/*
- * A word about residuals.
- * The scb is presented to the sequencer with the dataptr and datacnt
- * fields initialized to the contents of the first S/G element to
- * transfer.  The sgptr field is initialized to the bus address for
- * the S/G element that follows the first in the in core S/G array
- * or'ed with the SG_FULL_RESID flag.  Sgptr may point to an invalid
- * S/G entry for this transfer (single S/G element transfer with the
- * first elements address and length preloaded in the dataptr/datacnt
- * fields).  If no transfer is to occur, sgptr is set to SG_LIST_NULL.
- * The SG_FULL_RESID flag ensures that the residual will be correctly
- * noted even if no data transfers occur.  Once the data phase is entered,
- * the residual sgptr and datacnt are loaded from the sgptr and the
- * datacnt fields.  After each S/G element's dataptr and length are
- * loaded into the hardware, the residual sgptr is advanced.  After
- * each S/G element is expired, its datacnt field is checked to see
- * if the LAST_SEG flag is set.  If so, SG_LIST_NULL is set in the
- * residual sg ptr and the transfer is considered complete.  If the
- * sequencer determines that there is a residual in the tranfer, or
- * there is non-zero status, it will set the SG_STATUS_VALID flag in
- * sgptr and dma the scb back into host memory.  To sumarize:
- *
- * Sequencer:
- *	o A residual has occurred if SG_FULL_RESID is set in sgptr,
- *	  or residual_sgptr does not have SG_LIST_NULL set.
- *
- *	o We are transfering the last segment if residual_datacnt has
- *	  the SG_LAST_SEG flag set.
- *
- * Host:
- *	o A residual can only have occurred if a completed scb has the
- *	  SG_STATUS_VALID flag set.  Inspection of the SCSI status field,
- *	  the residual_datacnt, and the residual_sgptr field will tell
- *	  for sure.
- *
- *	o residual_sgptr and sgptr refer to the "next" sg entry
- *	  and so may point beyond the last valid sg entry for the
- *	  transfer.
- */ 
-#define SG_PTR_MASK	0xFFFFFFF8
-/*16*/	uint16_t tag;
-/*18*/	uint8_t  cdb_len;
-/*19*/	uint8_t  task_management;
-/*20*/	uint32_t next_hscb_busaddr;
-/*24*/	uint64_t dataptr;
-/*32*/	uint32_t datacnt;	/* Byte 3 is spare. */
-/*36*/	uint32_t sgptr;
-/*40*/	uint8_t  control;	/* See SCB_CONTROL in aic79xx.reg for details */
-/*41*/	uint8_t	 scsiid;	/*
-				 * Selection out Id
-				 * Our Id (bits 0-3) Their ID (bits 4-7)
-				 */
-/*42*/	uint8_t  lun;
-/*43*/	uint8_t  task_attribute;
-/*44*/	uint32_t hscb_busaddr;
-/******* Long lun field only downloaded for full 8 byte lun support *******/
-/*48*/  uint8_t	 pkt_long_lun[8];
-/******* Fields below are not Downloaded (Sequencer may use for scratch) ******/
-/*56*/  uint8_t	 spare[8];
-};
-
-/************************ Kernel SCB Definitions ******************************/
-/*
- * Some fields of the SCB are OS dependent.  Here we collect the
- * definitions for elements that all OS platforms need to include
- * in there SCB definition.
- */
-
-/*
- * Definition of a scatter/gather element as transfered to the controller.
- * The aic7xxx chips only support a 24bit length.  We use the top byte of
- * the length to store additional address bits and a flag to indicate
- * that a given segment terminates the transfer.  This gives us an
- * addressable range of 512GB on machines with 64bit PCI or with chips
- * that can support dual address cycles on 32bit PCI busses.
- */
-struct ahd_dma_seg {
-	uint32_t	addr;
-	uint32_t	len;
-#define	AHD_DMA_LAST_SEG	0x80000000
-#define	AHD_SG_HIGH_ADDR_MASK	0x7F000000
-#define	AHD_SG_LEN_MASK		0x00FFFFFF
-};
-
-struct ahd_dma64_seg {
-	uint64_t	addr;
-	uint32_t	len;
-	uint32_t	pad;
-};
-
-struct map_node {
-	bus_dmamap_t		 dmamap;
-	bus_addr_t		 physaddr;
-	uint8_t			*vaddr;
-	SLIST_ENTRY(map_node)	 links;
-};
-
-/*
- * The current state of this SCB.
- */
-typedef enum {
-	SCB_FLAG_NONE		= 0x00000,
-	SCB_TRANSMISSION_ERROR	= 0x00001,/*
-					   * We detected a parity or CRC
-					   * error that has effected the
-					   * payload of the command.  This
-					   * flag is checked when normal
-					   * status is returned to catch
-					   * the case of a target not
-					   * responding to our attempt
-					   * to report the error.
-					   */
-	SCB_OTHERTCL_TIMEOUT	= 0x00002,/*
-					   * Another device was active
-					   * during the first timeout for
-					   * this SCB so we gave ourselves
-					   * an additional timeout period
-					   * in case it was hogging the
-					   * bus.
-				           */
-	SCB_DEVICE_RESET	= 0x00004,
-	SCB_SENSE		= 0x00008,
-	SCB_CDB32_PTR		= 0x00010,
-	SCB_RECOVERY_SCB	= 0x00020,
-	SCB_AUTO_NEGOTIATE	= 0x00040,/* Negotiate to achieve goal. */
-	SCB_NEGOTIATE		= 0x00080,/* Negotiation forced for command. */
-	SCB_ABORT		= 0x00100,
-	SCB_ACTIVE		= 0x00200,
-	SCB_TARGET_IMMEDIATE	= 0x00400,
-	SCB_PACKETIZED		= 0x00800,
-	SCB_EXPECT_PPR_BUSFREE	= 0x01000,
-	SCB_PKT_SENSE		= 0x02000,
-	SCB_CMDPHASE_ABORT	= 0x04000,
-	SCB_ON_COL_LIST		= 0x08000,
-	SCB_SILENT		= 0x10000 /*
-					   * Be quiet about transmission type
-					   * errors.  They are expected and we
-					   * don't want to upset the user.  This
-					   * flag is typically used during DV.
-					   */
-} scb_flag;
-
-struct scb {
-	struct	hardware_scb	 *hscb;
-	union {
-		SLIST_ENTRY(scb)  sle;
-		LIST_ENTRY(scb)	  le;
-		TAILQ_ENTRY(scb)  tqe;
-	} links;
-	union {
-		SLIST_ENTRY(scb)  sle;
-		LIST_ENTRY(scb)	  le;
-		TAILQ_ENTRY(scb)  tqe;
-	} links2;
-#define pending_links links2.le
-#define collision_links links2.le
-	struct scb		 *col_scb;
-	ahd_io_ctx_t		  io_ctx;
-	struct ahd_softc	 *ahd_softc;
-	scb_flag		  flags;
-#ifndef __linux__
-	bus_dmamap_t		  dmamap;
-#endif
-	struct scb_platform_data *platform_data;
-	struct map_node	 	 *hscb_map;
-	struct map_node	 	 *sg_map;
-	struct map_node	 	 *sense_map;
-	void			 *sg_list;
-	uint8_t			 *sense_data;
-	bus_addr_t		  sg_list_busaddr;
-	bus_addr_t		  sense_busaddr;
-	u_int			  sg_count;/* How full ahd_dma_seg is */
-#define	AHD_MAX_LQ_CRC_ERRORS 5
-	u_int			  crc_retry_count;
-};
-
-TAILQ_HEAD(scb_tailq, scb);
-LIST_HEAD(scb_list, scb);
-
-struct scb_data {
-	/*
-	 * TAILQ of lists of free SCBs grouped by device
-	 * collision domains.
-	 */
-	struct scb_tailq free_scbs;
-
-	/*
-	 * Per-device lists of SCBs whose tag ID would collide
-	 * with an already active tag on the device.
-	 */
-	struct scb_list free_scb_lists[AHD_NUM_TARGETS * AHD_NUM_LUNS_NONPKT];
-
-	/*
-	 * SCBs that will not collide with any active device.
-	 */
-	struct scb_list any_dev_free_scb_list;
-
-	/*
-	 * Mapping from tag to SCB.
-	 */
-	struct	scb *scbindex[AHD_SCB_MAX];
-
-	/*
-	 * "Bus" addresses of our data structures.
-	 */
-	bus_dma_tag_t	 hscb_dmat;	/* dmat for our hardware SCB array */
-	bus_dma_tag_t	 sg_dmat;	/* dmat for our sg segments */
-	bus_dma_tag_t	 sense_dmat;	/* dmat for our sense buffers */
-	SLIST_HEAD(, map_node) hscb_maps;
-	SLIST_HEAD(, map_node) sg_maps;
-	SLIST_HEAD(, map_node) sense_maps;
-	int		 scbs_left;	/* unallocated scbs in head map_node */
-	int		 sgs_left;	/* unallocated sgs in head map_node */
-	int		 sense_left;	/* unallocated sense in head map_node */
-	uint16_t	 numscbs;
-	uint16_t	 maxhscbs;	/* Number of SCBs on the card */
-	uint8_t		 init_level;	/*
-					 * How far we've initialized
-					 * this structure.
-					 */
-};
-
-/************************ Target Mode Definitions *****************************/
-
-/*
- * Connection desciptor for select-in requests in target mode.
- */
-struct target_cmd {
-	uint8_t scsiid;		/* Our ID and the initiator's ID */
-	uint8_t identify;	/* Identify message */
-	uint8_t bytes[22];	/* 
-				 * Bytes contains any additional message
-				 * bytes terminated by 0xFF.  The remainder
-				 * is the cdb to execute.
-				 */
-	uint8_t cmd_valid;	/*
-				 * When a command is complete, the firmware
-				 * will set cmd_valid to all bits set.
-				 * After the host has seen the command,
-				 * the bits are cleared.  This allows us
-				 * to just peek at host memory to determine
-				 * if more work is complete. cmd_valid is on
-				 * an 8 byte boundary to simplify setting
-				 * it on aic7880 hardware which only has
-				 * limited direct access to the DMA FIFO.
-				 */
-	uint8_t pad[7];
-};
-
-/*
- * Number of events we can buffer up if we run out
- * of immediate notify ccbs.
- */
-#define AHD_TMODE_EVENT_BUFFER_SIZE 8
-struct ahd_tmode_event {
-	uint8_t initiator_id;
-	uint8_t event_type;	/* MSG type or EVENT_TYPE_BUS_RESET */
-#define	EVENT_TYPE_BUS_RESET 0xFF
-	uint8_t event_arg;
-};
-
-/*
- * Per enabled lun target mode state.
- * As this state is directly influenced by the host OS'es target mode
- * environment, we let the OS module define it.  Forward declare the
- * structure here so we can store arrays of them, etc. in OS neutral
- * data structures.
- */
-#ifdef AHD_TARGET_MODE 
-struct ahd_tmode_lstate {
-	struct cam_path *path;
-	struct ccb_hdr_slist accept_tios;
-	struct ccb_hdr_slist immed_notifies;
-	struct ahd_tmode_event event_buffer[AHD_TMODE_EVENT_BUFFER_SIZE];
-	uint8_t event_r_idx;
-	uint8_t event_w_idx;
-};
-#else
-struct ahd_tmode_lstate;
-#endif
-
-/******************** Transfer Negotiation Datastructures *********************/
-#define AHD_TRANS_CUR		0x01	/* Modify current neogtiation status */
-#define AHD_TRANS_ACTIVE	0x03	/* Assume this target is on the bus */
-#define AHD_TRANS_GOAL		0x04	/* Modify negotiation goal */
-#define AHD_TRANS_USER		0x08	/* Modify user negotiation settings */
-#define AHD_PERIOD_10MHz	0x19
-
-#define AHD_WIDTH_UNKNOWN	0xFF
-#define AHD_PERIOD_UNKNOWN	0xFF
-#define AHD_OFFSET_UNKNOWN	0x0
-#define AHD_PPR_OPTS_UNKNOWN	0xFF
-
-/*
- * Transfer Negotiation Information.
- */
-struct ahd_transinfo {
-	uint8_t protocol_version;	/* SCSI Revision level */
-	uint8_t transport_version;	/* SPI Revision level */
-	uint8_t width;			/* Bus width */
-	uint8_t period;			/* Sync rate factor */
-	uint8_t offset;			/* Sync offset */
-	uint8_t ppr_options;		/* Parallel Protocol Request options */
-};
-
-/*
- * Per-initiator current, goal and user transfer negotiation information. */
-struct ahd_initiator_tinfo {
-	struct ahd_transinfo curr;
-	struct ahd_transinfo goal;
-	struct ahd_transinfo user;
-};
-
-/*
- * Per enabled target ID state.
- * Pointers to lun target state as well as sync/wide negotiation information
- * for each initiator<->target mapping.  For the initiator role we pretend
- * that we are the target and the targets are the initiators since the
- * negotiation is the same regardless of role.
- */
-struct ahd_tmode_tstate {
-	struct ahd_tmode_lstate*	enabled_luns[AHD_NUM_LUNS];
-	struct ahd_initiator_tinfo	transinfo[AHD_NUM_TARGETS];
-
-	/*
-	 * Per initiator state bitmasks.
-	 */
-	uint16_t	 auto_negotiate;/* Auto Negotiation Required */
-	uint16_t	 discenable;	/* Disconnection allowed  */
-	uint16_t	 tagenable;	/* Tagged Queuing allowed */
-};
-
-/*
- * Points of interest along the negotiated transfer scale.
- */
-#define AHD_SYNCRATE_160	0x8
-#define AHD_SYNCRATE_PACED	0x8
-#define AHD_SYNCRATE_DT		0x9
-#define AHD_SYNCRATE_ULTRA2	0xa
-#define AHD_SYNCRATE_ULTRA	0xc
-#define AHD_SYNCRATE_FAST	0x19
-#define AHD_SYNCRATE_MIN_DT	AHD_SYNCRATE_FAST
-#define AHD_SYNCRATE_SYNC	0x32
-#define AHD_SYNCRATE_MIN	0x60
-#define	AHD_SYNCRATE_ASYNC	0xFF
-#define AHD_SYNCRATE_MAX	AHD_SYNCRATE_160
-
-/* Safe and valid period for async negotiations. */
-#define	AHD_ASYNC_XFER_PERIOD	0x44
-
-/*
- * In RevA, the synctable uses a 120MHz rate for the period
- * factor 8 and 160MHz for the period factor 7.  The 120MHz
- * rate never made it into the official SCSI spec, so we must
- * compensate when setting the negotiation table for Rev A
- * parts.
- */
-#define AHD_SYNCRATE_REVA_120	0x8
-#define AHD_SYNCRATE_REVA_160	0x7
-
-/***************************** Lookup Tables **********************************/
-/*
- * Phase -> name and message out response
- * to parity errors in each phase table. 
- */
-struct ahd_phase_table_entry {
-        uint8_t phase;
-        uint8_t mesg_out; /* Message response to parity errors */
-	char *phasemsg;
-};
-
-/************************** Serial EEPROM Format ******************************/
-
-struct seeprom_config {
-/*
- * Per SCSI ID Configuration Flags
- */
-	uint16_t device_flags[16];	/* words 0-15 */
-#define		CFXFER		0x003F	/* synchronous transfer rate */
-#define			CFXFER_ASYNC	0x3F
-#define		CFQAS		0x0040	/* Negotiate QAS */
-#define		CFPACKETIZED	0x0080	/* Negotiate Packetized Transfers */
-#define		CFSTART		0x0100	/* send start unit SCSI command */
-#define		CFINCBIOS	0x0200	/* include in BIOS scan */
-#define		CFDISC		0x0400	/* enable disconnection */
-#define		CFMULTILUNDEV	0x0800	/* Probe multiple luns in BIOS scan */
-#define		CFWIDEB		0x1000	/* wide bus device */
-#define		CFHOSTMANAGED	0x8000	/* Managed by a RAID controller */
-
-/*
- * BIOS Control Bits
- */
-	uint16_t bios_control;		/* word 16 */
-#define		CFSUPREM	0x0001	/* support all removeable drives */
-#define		CFSUPREMB	0x0002	/* support removeable boot drives */
-#define		CFBIOSSTATE	0x000C	/* BIOS Action State */
-#define		    CFBS_DISABLED	0x00
-#define		    CFBS_ENABLED	0x04
-#define		    CFBS_DISABLED_SCAN	0x08
-#define		CFENABLEDV	0x0010	/* Perform Domain Validation */
-#define		CFCTRL_A	0x0020	/* BIOS displays Ctrl-A message */	
-#define		CFSPARITY	0x0040	/* SCSI parity */
-#define		CFEXTEND	0x0080	/* extended translation enabled */
-#define		CFBOOTCD	0x0100  /* Support Bootable CD-ROM */
-#define		CFMSG_LEVEL	0x0600	/* BIOS Message Level */
-#define			CFMSG_VERBOSE	0x0000
-#define			CFMSG_SILENT	0x0200
-#define			CFMSG_DIAG	0x0400
-#define		CFRESETB	0x0800	/* reset SCSI bus at boot */
-/*		UNUSED		0xf000	*/
-
-/*
- * Host Adapter Control Bits
- */
-	uint16_t adapter_control;	/* word 17 */	
-#define		CFAUTOTERM	0x0001	/* Perform Auto termination */
-#define		CFSTERM		0x0002	/* SCSI low byte termination */
-#define		CFWSTERM	0x0004	/* SCSI high byte termination */
-#define		CFSEAUTOTERM	0x0008	/* Ultra2 Perform secondary Auto Term*/
-#define		CFSELOWTERM	0x0010	/* Ultra2 secondary low term */
-#define		CFSEHIGHTERM	0x0020	/* Ultra2 secondary high term */
-#define		CFSTPWLEVEL	0x0040	/* Termination level control */
-#define		CFBIOSAUTOTERM	0x0080	/* Perform Auto termination */
-#define		CFTERM_MENU	0x0100	/* BIOS displays termination menu */	
-#define		CFCLUSTERENB	0x8000	/* Cluster Enable */
-
-/*
- * Bus Release Time, Host Adapter ID
- */
-	uint16_t brtime_id;		/* word 18 */
-#define		CFSCSIID	0x000f	/* host adapter SCSI ID */
-/*		UNUSED		0x00f0	*/
-#define		CFBRTIME	0xff00	/* bus release time/PCI Latency Time */
-
-/*
- * Maximum targets
- */
-	uint16_t max_targets;		/* word 19 */	
-#define		CFMAXTARG	0x00ff	/* maximum targets */
-#define		CFBOOTLUN	0x0f00	/* Lun to boot from */
-#define		CFBOOTID	0xf000	/* Target to boot from */
-	uint16_t res_1[10];		/* words 20-29 */
-	uint16_t signature;		/* BIOS Signature */
-#define		CFSIGNATURE	0x400
-	uint16_t checksum;		/* word 31 */
-};
-
-/****************************** Flexport Logic ********************************/
-#define FLXADDR_TERMCTL			0x0
-#define		FLX_TERMCTL_ENSECHIGH	0x8
-#define		FLX_TERMCTL_ENSECLOW	0x4
-#define		FLX_TERMCTL_ENPRIHIGH	0x2
-#define		FLX_TERMCTL_ENPRILOW	0x1
-#define FLXADDR_ROMSTAT_CURSENSECTL	0x1
-#define		FLX_ROMSTAT_SEECFG	0xF0
-#define		FLX_ROMSTAT_EECFG	0x0F
-#define		FLX_ROMSTAT_SEE_93C66	0x00
-#define		FLX_ROMSTAT_SEE_NONE	0xF0
-#define		FLX_ROMSTAT_EE_512x8	0x0
-#define		FLX_ROMSTAT_EE_1MBx8	0x1
-#define		FLX_ROMSTAT_EE_2MBx8	0x2
-#define		FLX_ROMSTAT_EE_4MBx8	0x3
-#define		FLX_ROMSTAT_EE_16MBx8	0x4
-#define 		CURSENSE_ENB	0x1
-#define	FLXADDR_FLEXSTAT		0x2
-#define		FLX_FSTAT_BUSY		0x1
-#define FLXADDR_CURRENT_STAT		0x4
-#define		FLX_CSTAT_SEC_HIGH	0xC0
-#define		FLX_CSTAT_SEC_LOW	0x30
-#define		FLX_CSTAT_PRI_HIGH	0x0C
-#define		FLX_CSTAT_PRI_LOW	0x03
-#define		FLX_CSTAT_MASK		0x03
-#define		FLX_CSTAT_SHIFT		2
-#define		FLX_CSTAT_OKAY		0x0
-#define		FLX_CSTAT_OVER		0x1
-#define		FLX_CSTAT_UNDER		0x2
-#define		FLX_CSTAT_INVALID	0x3
-
-int		ahd_read_seeprom(struct ahd_softc *ahd, uint16_t *buf,
-				 u_int start_addr, u_int count);
-
-int		ahd_write_seeprom(struct ahd_softc *ahd, uint16_t *buf,
-				  u_int start_addr, u_int count);
-int		ahd_wait_seeprom(struct ahd_softc *ahd);
-int		ahd_verify_cksum(struct seeprom_config *sc);
-int		ahd_acquire_seeprom(struct ahd_softc *ahd);
-void		ahd_release_seeprom(struct ahd_softc *ahd);
-
-/****************************  Message Buffer *********************************/
-typedef enum {
-	MSG_FLAG_NONE			= 0x00,
-	MSG_FLAG_EXPECT_PPR_BUSFREE	= 0x01,
-	MSG_FLAG_IU_REQ_CHANGED		= 0x02,
-	MSG_FLAG_EXPECT_IDE_BUSFREE	= 0x04,
-	MSG_FLAG_EXPECT_QASREJ_BUSFREE	= 0x08,
-	MSG_FLAG_PACKETIZED		= 0x10
-} ahd_msg_flags;
-
-typedef enum {
-	MSG_TYPE_NONE			= 0x00,
-	MSG_TYPE_INITIATOR_MSGOUT	= 0x01,
-	MSG_TYPE_INITIATOR_MSGIN	= 0x02,
-	MSG_TYPE_TARGET_MSGOUT		= 0x03,
-	MSG_TYPE_TARGET_MSGIN		= 0x04
-} ahd_msg_type;
-
-typedef enum {
-	MSGLOOP_IN_PROG,
-	MSGLOOP_MSGCOMPLETE,
-	MSGLOOP_TERMINATED
-} msg_loop_stat;
-
-/*********************** Software Configuration Structure *********************/
-struct ahd_suspend_channel_state {
-	uint8_t	scsiseq;
-	uint8_t	sxfrctl0;
-	uint8_t	sxfrctl1;
-	uint8_t	simode0;
-	uint8_t	simode1;
-	uint8_t	seltimer;
-	uint8_t	seqctl;
-};
-
-struct ahd_suspend_state {
-	struct	ahd_suspend_channel_state channel[2];
-	uint8_t	optionmode;
-	uint8_t	dscommand0;
-	uint8_t	dspcistatus;
-	/* hsmailbox */
-	uint8_t	crccontrol1;
-	uint8_t	scbbaddr;
-	/* Host and sequencer SCB counts */
-	uint8_t	dff_thrsh;
-	uint8_t	*scratch_ram;
-	uint8_t	*btt;
-};
-
-typedef void (*ahd_bus_intr_t)(struct ahd_softc *);
-
-typedef enum {
-	AHD_MODE_DFF0,
-	AHD_MODE_DFF1,
-	AHD_MODE_CCHAN,
-	AHD_MODE_SCSI,
-	AHD_MODE_CFG,
-	AHD_MODE_UNKNOWN
-} ahd_mode;
-
-#define AHD_MK_MSK(x) (0x01 << (x))
-#define AHD_MODE_DFF0_MSK	AHD_MK_MSK(AHD_MODE_DFF0)
-#define AHD_MODE_DFF1_MSK	AHD_MK_MSK(AHD_MODE_DFF1)
-#define AHD_MODE_CCHAN_MSK	AHD_MK_MSK(AHD_MODE_CCHAN)
-#define AHD_MODE_SCSI_MSK	AHD_MK_MSK(AHD_MODE_SCSI)
-#define AHD_MODE_CFG_MSK	AHD_MK_MSK(AHD_MODE_CFG)
-#define AHD_MODE_UNKNOWN_MSK	AHD_MK_MSK(AHD_MODE_UNKNOWN)
-#define AHD_MODE_ANY_MSK (~0)
-
-typedef uint8_t ahd_mode_state;
-
-typedef void ahd_callback_t (void *);
-
-struct ahd_softc {
-	bus_space_tag_t           tags[2];
-	bus_space_handle_t        bshs[2];
-#ifndef __linux__
-	bus_dma_tag_t		  buffer_dmat;   /* dmat for buffer I/O */
-#endif
-	struct scb_data		  scb_data;
-
-	struct hardware_scb	 *next_queued_hscb;
-
-	/*
-	 * SCBs that have been sent to the controller
-	 */
-	LIST_HEAD(, scb)	  pending_scbs;
-
-	/*
-	 * Current register window mode information.
-	 */
-	ahd_mode		  dst_mode;
-	ahd_mode		  src_mode;
-
-	/*
-	 * Saved register window mode information
-	 * used for restore on next unpause.
-	 */
-	ahd_mode		  saved_dst_mode;
-	ahd_mode		  saved_src_mode;
-
-	/*
-	 * Platform specific data.
-	 */
-	struct ahd_platform_data *platform_data;
-
-	/*
-	 * Platform specific device information.
-	 */
-	ahd_dev_softc_t		  dev_softc;
-
-	/*
-	 * Bus specific device information.
-	 */
-	ahd_bus_intr_t		  bus_intr;
-
-	/*
-	 * Target mode related state kept on a per enabled lun basis.
-	 * Targets that are not enabled will have null entries.
-	 * As an initiator, we keep one target entry for our initiator
-	 * ID to store our sync/wide transfer settings.
-	 */
-	struct ahd_tmode_tstate  *enabled_targets[AHD_NUM_TARGETS];
-
-	/*
-	 * The black hole device responsible for handling requests for
-	 * disabled luns on enabled targets.
-	 */
-	struct ahd_tmode_lstate  *black_hole;
-
-	/*
-	 * Device instance currently on the bus awaiting a continue TIO
-	 * for a command that was not given the disconnect priveledge.
-	 */
-	struct ahd_tmode_lstate  *pending_device;
-
-	/*
-	 * Timer handles for timer driven callbacks.
-	 */
-	ahd_timer_t		  reset_timer;
-	ahd_timer_t		  stat_timer;
-
-	/*
-	 * Statistics.
-	 */
-#define	AHD_STAT_UPDATE_US	250000 /* 250ms */
-#define	AHD_STAT_BUCKETS	4
-	u_int			  cmdcmplt_bucket;
-	uint32_t		  cmdcmplt_counts[AHD_STAT_BUCKETS];
-	uint32_t		  cmdcmplt_total;
-
-	/*
-	 * Card characteristics
-	 */
-	ahd_chip		  chip;
-	ahd_feature		  features;
-	ahd_bug			  bugs;
-	ahd_flag		  flags;
-	struct seeprom_config	 *seep_config;
-
-	/* Values to store in the SEQCTL register for pause and unpause */
-	uint8_t			  unpause;
-	uint8_t			  pause;
-
-	/* Command Queues */
-	uint16_t		  qoutfifonext;
-	uint16_t		  qoutfifonext_valid_tag;
-	uint16_t		  qinfifonext;
-	uint16_t		  qinfifo[AHD_SCB_MAX];
-	uint16_t		 *qoutfifo;
-
-	/* Critical Section Data */
-	struct cs		 *critical_sections;
-	u_int			  num_critical_sections;
-
-	/* Buffer for handling packetized bitbucket. */
-	uint8_t			 *overrun_buf;
-
-	/* Links for chaining softcs */
-	TAILQ_ENTRY(ahd_softc)	  links;
-
-	/* Channel Names ('A', 'B', etc.) */
-	char			  channel;
-
-	/* Initiator Bus ID */
-	uint8_t			  our_id;
-
-	/*
-	 * Target incoming command FIFO.
-	 */
-	struct target_cmd	 *targetcmds;
-	uint8_t			  tqinfifonext;
-
-	/*
-	 * Cached verson of the hs_mailbox so we can avoid
-	 * pausing the sequencer during mailbox updates.
-	 */
-	uint8_t			  hs_mailbox;
-
-	/*
-	 * Incoming and outgoing message handling.
-	 */
-	uint8_t			  send_msg_perror;
-	ahd_msg_flags		  msg_flags;
-	ahd_msg_type		  msg_type;
-	uint8_t			  msgout_buf[12];/* Message we are sending */
-	uint8_t			  msgin_buf[12];/* Message we are receiving */
-	u_int			  msgout_len;	/* Length of message to send */
-	u_int			  msgout_index;	/* Current index in msgout */
-	u_int			  msgin_index;	/* Current index in msgin */
-
-	/*
-	 * Mapping information for data structures shared
-	 * between the sequencer and kernel.
-	 */
-	bus_dma_tag_t		  parent_dmat;
-	bus_dma_tag_t		  shared_data_dmat;
-	bus_dmamap_t		  shared_data_dmamap;
-	bus_addr_t		  shared_data_busaddr;
-
-	/* Information saved through suspend/resume cycles */
-	struct ahd_suspend_state  suspend_state;
-
-	/* Number of enabled target mode device on this card */
-	u_int			  enabled_luns;
-
-	/* Initialization level of this data structure */
-	u_int			  init_level;
-
-	/* PCI cacheline size. */
-	u_int			  pci_cachesize;
-
-	/* IO Cell Parameters */
-	uint8_t			  iocell_opts[AHD_NUM_PER_DEV_ANNEXCOLS];
-
-	u_int			  stack_size;
-	uint16_t		 *saved_stack;
-
-	/* Per-Unit descriptive information */
-	const char		 *description;
-	const char		 *bus_description;
-	char			 *name;
-	int			  unit;
-
-	/* Selection Timer settings */
-	int			  seltime;
-
-	/*
-	 * Interrupt coalessing settings.
-	 */
-#define	AHD_INT_COALESSING_TIMER_DEFAULT		250 /*us*/
-#define	AHD_INT_COALESSING_MAXCMDS_DEFAULT		10
-#define	AHD_INT_COALESSING_MAXCMDS_MAX			127
-#define	AHD_INT_COALESSING_MINCMDS_DEFAULT		5
-#define	AHD_INT_COALESSING_MINCMDS_MAX			127
-#define	AHD_INT_COALESSING_THRESHOLD_DEFAULT		2000
-#define	AHD_INT_COALESSING_STOP_THRESHOLD_DEFAULT	1000
-	u_int			  int_coalessing_timer;
-	u_int			  int_coalessing_maxcmds;
-	u_int			  int_coalessing_mincmds;
-	u_int			  int_coalessing_threshold;
-	u_int			  int_coalessing_stop_threshold;
-
-	uint16_t	 	  user_discenable;/* Disconnection allowed  */
-	uint16_t		  user_tagenable;/* Tagged Queuing allowed */
-};
-
-TAILQ_HEAD(ahd_softc_tailq, ahd_softc);
-extern struct ahd_softc_tailq ahd_tailq;
-
-/*************************** IO Cell Configuration ****************************/
-#define	AHD_PRECOMP_SLEW_INDEX						\
-    (AHD_ANNEXCOL_PRECOMP_SLEW - AHD_ANNEXCOL_PER_DEV0)
-
-#define	AHD_AMPLITUDE_INDEX						\
-    (AHD_ANNEXCOL_AMPLITUDE - AHD_ANNEXCOL_PER_DEV0)
-
-#define AHD_SET_SLEWRATE(ahd, new_slew)					\
-do {									\
-    (ahd)->iocell_opts[AHD_PRECOMP_SLEW_INDEX] &= ~AHD_SLEWRATE_MASK;	\
-    (ahd)->iocell_opts[AHD_PRECOMP_SLEW_INDEX] |=			\
-	(((new_slew) << AHD_SLEWRATE_SHIFT) & AHD_SLEWRATE_MASK);	\
-} while (0)
-
-#define AHD_SET_PRECOMP(ahd, new_pcomp)					\
-do {									\
-    (ahd)->iocell_opts[AHD_PRECOMP_SLEW_INDEX] &= ~AHD_PRECOMP_MASK;	\
-    (ahd)->iocell_opts[AHD_PRECOMP_SLEW_INDEX] |=			\
-	(((new_pcomp) << AHD_PRECOMP_SHIFT) & AHD_PRECOMP_MASK);	\
-} while (0)
-
-#define AHD_SET_AMPLITUDE(ahd, new_amp)					\
-do {									\
-    (ahd)->iocell_opts[AHD_AMPLITUDE_INDEX] &= ~AHD_AMPLITUDE_MASK;	\
-    (ahd)->iocell_opts[AHD_AMPLITUDE_INDEX] |=				\
-	(((new_amp) << AHD_AMPLITUDE_SHIFT) & AHD_AMPLITUDE_MASK);	\
-} while (0)
-
-/************************ Active Device Information ***************************/
-typedef enum {
-	ROLE_UNKNOWN,
-	ROLE_INITIATOR,
-	ROLE_TARGET
-} role_t;
-
-struct ahd_devinfo {
-	int	 our_scsiid;
-	int	 target_offset;
-	uint16_t target_mask;
-	u_int	 target;
-	u_int	 lun;
-	char	 channel;
-	role_t	 role;		/*
-				 * Only guaranteed to be correct if not
-				 * in the busfree state.
-				 */
-};
-
-/****************************** PCI Structures ********************************/
-#define AHD_PCI_IOADDR0	PCIR_MAPS	/* I/O BAR*/
-#define AHD_PCI_MEMADDR	(PCIR_MAPS + 4)	/* Memory BAR */
-#define AHD_PCI_IOADDR1	(PCIR_MAPS + 12)/* Second I/O BAR */
-
-typedef int (ahd_device_setup_t)(struct ahd_softc *);
-
-struct ahd_pci_identity {
-	uint64_t		 full_id;
-	uint64_t		 id_mask;
-	char			*name;
-	ahd_device_setup_t	*setup;
-};
-extern struct ahd_pci_identity ahd_pci_ident_table [];
-extern const u_int ahd_num_pci_devs;
-
-/***************************** VL/EISA Declarations ***************************/
-struct aic7770_identity {
-	uint32_t		 full_id;
-	uint32_t		 id_mask;
-	char			*name;
-	ahd_device_setup_t	*setup;
-};
-extern struct aic7770_identity aic7770_ident_table [];
-extern const int ahd_num_aic7770_devs;
-
-#define AHD_EISA_SLOT_OFFSET	0xc00
-#define AHD_EISA_IOSIZE		0x100
-
-/*************************** Function Declarations ****************************/
-/******************************************************************************/
-void			ahd_reset_cmds_pending(struct ahd_softc *ahd);
-u_int			ahd_find_busy_tcl(struct ahd_softc *ahd, u_int tcl);
-void			ahd_busy_tcl(struct ahd_softc *ahd,
-				     u_int tcl, u_int busyid);
-static __inline void	ahd_unbusy_tcl(struct ahd_softc *ahd, u_int tcl);
-static __inline void
-ahd_unbusy_tcl(struct ahd_softc *ahd, u_int tcl)
-{
-	ahd_busy_tcl(ahd, tcl, SCB_LIST_NULL);
-}
-
-/***************************** PCI Front End *********************************/
-struct	ahd_pci_identity *ahd_find_pci_device(ahd_dev_softc_t);
-int			  ahd_pci_config(struct ahd_softc *,
-					 struct ahd_pci_identity *);
-int	ahd_pci_test_register_access(struct ahd_softc *);
-
-/************************** SCB and SCB queue management **********************/
-int		ahd_probe_scbs(struct ahd_softc *);
-void		ahd_qinfifo_requeue_tail(struct ahd_softc *ahd,
-					 struct scb *scb);
-int		ahd_match_scb(struct ahd_softc *ahd, struct scb *scb,
-			      int target, char channel, int lun,
-			      u_int tag, role_t role);
-
-/****************************** Initialization ********************************/
-struct ahd_softc	*ahd_alloc(void *platform_arg, char *name);
-int			 ahd_softc_init(struct ahd_softc *);
-void			 ahd_controller_info(struct ahd_softc *ahd, char *buf);
-int			 ahd_init(struct ahd_softc *ahd);
-int			 ahd_default_config(struct ahd_softc *ahd);
-int			 ahd_parse_cfgdata(struct ahd_softc *ahd,
-					   struct seeprom_config *sc);
-void			 ahd_intr_enable(struct ahd_softc *ahd, int enable);
-void			 ahd_update_coalessing_values(struct ahd_softc *ahd,
-						      u_int timer,
-						      u_int maxcmds,
-						      u_int mincmds);
-void			 ahd_enable_coalessing(struct ahd_softc *ahd,
-					       int enable);
-void			 ahd_pause_and_flushwork(struct ahd_softc *ahd);
-int			 ahd_suspend(struct ahd_softc *ahd); 
-int			 ahd_resume(struct ahd_softc *ahd);
-void			 ahd_softc_insert(struct ahd_softc *);
-struct ahd_softc	*ahd_find_softc(struct ahd_softc *ahd);
-void			 ahd_set_unit(struct ahd_softc *, int);
-void			 ahd_set_name(struct ahd_softc *, char *);
-struct scb		*ahd_get_scb(struct ahd_softc *ahd, u_int col_idx);
-void			 ahd_free_scb(struct ahd_softc *ahd, struct scb *scb);
-void			 ahd_alloc_scbs(struct ahd_softc *ahd);
-void			 ahd_free(struct ahd_softc *ahd);
-int			 ahd_reset(struct ahd_softc *ahd);
-void			 ahd_shutdown(void *arg);
-int			ahd_write_flexport(struct ahd_softc *ahd,
-					   u_int addr, u_int value);
-int			ahd_read_flexport(struct ahd_softc *ahd, u_int addr,
-					  uint8_t *value);
-int			ahd_wait_flexport(struct ahd_softc *ahd);
-
-/*************************** Interrupt Services *******************************/
-void			ahd_pci_intr(struct ahd_softc *ahd);
-void			ahd_clear_intstat(struct ahd_softc *ahd);
-void			ahd_flush_qoutfifo(struct ahd_softc *ahd);
-void			ahd_run_qoutfifo(struct ahd_softc *ahd);
-#ifdef AHD_TARGET_MODE
-void			ahd_run_tqinfifo(struct ahd_softc *ahd, int paused);
-#endif
-void			ahd_handle_hwerrint(struct ahd_softc *ahd);
-void			ahd_handle_seqint(struct ahd_softc *ahd, u_int intstat);
-void			ahd_handle_scsiint(struct ahd_softc *ahd,
-					   u_int intstat);
-void			ahd_clear_critical_section(struct ahd_softc *ahd);
-
-/***************************** Error Recovery *********************************/
-typedef enum {
-	SEARCH_COMPLETE,
-	SEARCH_COUNT,
-	SEARCH_REMOVE,
-	SEARCH_PRINT
-} ahd_search_action;
-int			ahd_search_qinfifo(struct ahd_softc *ahd, int target,
-					   char channel, int lun, u_int tag,
-					   role_t role, uint32_t status,
-					   ahd_search_action action);
-int			ahd_search_disc_list(struct ahd_softc *ahd, int target,
-					     char channel, int lun, u_int tag,
-					     int stop_on_first, int remove,
-					     int save_state);
-void			ahd_freeze_devq(struct ahd_softc *ahd, struct scb *scb);
-int			ahd_reset_channel(struct ahd_softc *ahd, char channel,
-					  int initiate_reset);
-int			ahd_abort_scbs(struct ahd_softc *ahd, int target,
-				       char channel, int lun, u_int tag,
-				       role_t role, uint32_t status);
-void			ahd_restart(struct ahd_softc *ahd);
-void			ahd_clear_fifo(struct ahd_softc *ahd, u_int fifo);
-void			ahd_handle_scb_status(struct ahd_softc *ahd,
-					      struct scb *scb);
-void			ahd_handle_scsi_status(struct ahd_softc *ahd,
-					       struct scb *scb);
-void			ahd_calc_residual(struct ahd_softc *ahd,
-					  struct scb *scb);
-/*************************** Utility Functions ********************************/
-struct ahd_phase_table_entry*
-			ahd_lookup_phase_entry(int phase);
-void			ahd_compile_devinfo(struct ahd_devinfo *devinfo,
-					    u_int our_id, u_int target,
-					    u_int lun, char channel,
-					    role_t role);
-/************************** Transfer Negotiation ******************************/
-void			ahd_find_syncrate(struct ahd_softc *ahd, u_int *period,
-					  u_int *ppr_options, u_int maxsync);
-void			ahd_validate_offset(struct ahd_softc *ahd,
-					    struct ahd_initiator_tinfo *tinfo,
-					    u_int period, u_int *offset,
-					    int wide, role_t role);
-void			ahd_validate_width(struct ahd_softc *ahd,
-					   struct ahd_initiator_tinfo *tinfo,
-					   u_int *bus_width,
-					   role_t role);
-/*
- * Negotiation types.  These are used to qualify if we should renegotiate
- * even if our goal and current transport parameters are identical.
- */
-typedef enum {
-	AHD_NEG_TO_GOAL,	/* Renegotiate only if goal and curr differ. */
-	AHD_NEG_IF_NON_ASYNC,	/* Renegotiate so long as goal is non-async. */
-	AHD_NEG_ALWAYS		/* Renegotiat even if goal is async. */
-} ahd_neg_type;
-int			ahd_update_neg_request(struct ahd_softc*,
-					       struct ahd_devinfo*,
-					       struct ahd_tmode_tstate*,
-					       struct ahd_initiator_tinfo*,
-					       ahd_neg_type);
-void			ahd_set_width(struct ahd_softc *ahd,
-				      struct ahd_devinfo *devinfo,
-				      u_int width, u_int type, int paused);
-void			ahd_set_syncrate(struct ahd_softc *ahd,
-					 struct ahd_devinfo *devinfo,
-					 u_int period, u_int offset,
-					 u_int ppr_options,
-					 u_int type, int paused);
-typedef enum {
-	AHD_QUEUE_NONE,
-	AHD_QUEUE_BASIC,
-	AHD_QUEUE_TAGGED
-} ahd_queue_alg;
-
-void			ahd_set_tags(struct ahd_softc *ahd,
-				     struct ahd_devinfo *devinfo,
-				     ahd_queue_alg alg);
-
-/**************************** Target Mode *************************************/
-#ifdef AHD_TARGET_MODE
-void		ahd_send_lstate_events(struct ahd_softc *,
-				       struct ahd_tmode_lstate *);
-void		ahd_handle_en_lun(struct ahd_softc *ahd,
-				  struct cam_sim *sim, union ccb *ccb);
-cam_status	ahd_find_tmode_devs(struct ahd_softc *ahd,
-				    struct cam_sim *sim, union ccb *ccb,
-				    struct ahd_tmode_tstate **tstate,
-				    struct ahd_tmode_lstate **lstate,
-				    int notfound_failure);
-#ifndef AHD_TMODE_ENABLE
-#define AHD_TMODE_ENABLE 0
-#endif
-#endif
-/******************************* Debug ***************************************/
-#ifdef AHD_DEBUG
-extern uint32_t ahd_debug;
-#define AHD_SHOW_MISC		0x00001
-#define AHD_SHOW_SENSE		0x00002
-#define AHD_SHOW_RECOVERY	0x00004
-#define AHD_DUMP_SEEPROM	0x00008
-#define AHD_SHOW_TERMCTL	0x00010
-#define AHD_SHOW_MEMORY		0x00020
-#define AHD_SHOW_MESSAGES	0x00040
-#define AHD_SHOW_MODEPTR	0x00080
-#define AHD_SHOW_SELTO		0x00100
-#define AHD_SHOW_FIFOS		0x00200
-#define AHD_SHOW_QFULL		0x00400
-#define	AHD_SHOW_DV		0x00800
-#define AHD_SHOW_MASKED_ERRORS	0x01000
-#define AHD_SHOW_QUEUE		0x02000
-#define AHD_SHOW_TQIN		0x04000
-#define AHD_SHOW_SG		0x08000
-#define AHD_SHOW_INT_COALESSING	0x10000
-#define AHD_DEBUG_SEQUENCER	0x20000
-#endif
-void			ahd_print_scb(struct scb *scb);
-void			ahd_print_devinfo(struct ahd_softc *ahd,
-					  struct ahd_devinfo *devinfo);
-void			ahd_dump_sglist(struct scb *scb);
-void			ahd_dump_all_cards_state(void);
-void			ahd_dump_card_state(struct ahd_softc *ahd);
-int			ahd_print_register(ahd_reg_parse_entry_t *table,
-					   u_int num_entries,
-					   const char *name,
-					   u_int address,
-					   u_int value,
-					   u_int *cur_column,
-					   u_int wrap_point);
-void			ahd_dump_scbs(struct ahd_softc *ahd);
-#endif /* _AIC79XX_H_ */
diff -urNp linux-5720/drivers/scsi/aic79xx/aic79xx.reg linux-5730/drivers/scsi/aic79xx/aic79xx.reg
--- linux-5720/drivers/scsi/aic79xx/aic79xx.reg
+++ linux-5730/drivers/scsi/aic79xx/aic79xx.reg
@@ -1,3950 +0,0 @@
-/*
- * Aic79xx register and scratch ram definitions.
- *
- * Copyright (c) 1994-2001 Justin T. Gibbs.
- * Copyright (c) 2000-2002 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $FreeBSD$
- */
-VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#60 $"
-
-/*
- * This file is processed by the aic7xxx_asm utility for use in assembling
- * firmware for the aic79xx family of SCSI host adapters as well as to generate
- * a C header file for use in the kernel portion of the Aic79xx driver.
- */
-
-/* Register window Modes */
-#define M_DFF0		0
-#define M_DFF1		1
-#define M_CCHAN		2
-#define M_SCSI		3
-#define M_CFG		4
-#define M_DST_SHIFT	4
-
-#define MK_MODE(src, dst) ((src) | ((dst) << M_DST_SHIFT))
-#define SET_MODE(src, dst)						\
-	SET_SRC_MODE	src;						\
-	SET_DST_MODE	dst;						\
-	if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {			\
-		mvi	MK_MODE(src, dst) call set_mode_work_around;	\
-	} else {							\
-		mvi	MODE_PTR, MK_MODE(src, dst);			\
-	}
-
-#define TOGGLE_DFF_MODE							\
-	if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {			\
-		call	toggle_dff_mode_work_around;			\
-	} else {							\
-		xor	MODE_PTR, MK_MODE(M_DFF1, M_DFF1);		\
-	}
-	
-#define RESTORE_MODE(mode)						\
-	if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {			\
-		mov	mode call set_mode_work_around;			\
-	} else {							\
-		mov	MODE_PTR, mode;					\
-	}
-
-#define SET_SEQINTCODE(code)						\
-	if ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {			\
-		mvi	code call set_seqint_work_around;		\
-	} else {							\
-		mvi	SEQINTCODE, code;				\
-	}
-
-/*
- * Mode Pointer
- * Controls which of the 5, 512byte, address spaces should be used
- * as the source and destination of any register accesses in our
- * register window.
- */
-register MODE_PTR {
-	address			0x000
-	access_mode	RW
-	field	DST_MODE	0x70
-	field	SRC_MODE	0x07
-	mode_pointer
-}
-
-const SRC_MODE_SHIFT	0
-const DST_MODE_SHIFT	4
-
-/*
- * Host Interrupt Status
- */
-register INTSTAT {
-	address			0x001
-	access_mode	RW
-	field	HWERRINT	0x80
-	field	BRKADRINT	0x40
-	field	SWTMINT		0x20
-	field	PCIINT		0x10
-	field	SCSIINT		0x08
-	field	SEQINT		0x04
-	field	CMDCMPLT	0x02
-	field	SPLTINT		0x01
-	mask	INT_PEND 0xFF
-}
-
-/*
- * Sequencer Interrupt Code
- */
-register SEQINTCODE {
-	address			0x002
-	access_mode	RW
-	field {
-		NO_SEQINT,			/* No seqint pending. */
-		BAD_PHASE,			/* unknown scsi bus phase */
-		SEND_REJECT,			/* sending a message reject */
-		PROTO_VIOLATION, 		/* Protocol Violation */
-		NO_MATCH,			/* no cmd match for reconnect */
-		IGN_WIDE_RES,			/* Complex IGN Wide Res Msg */
-		PDATA_REINIT,			/*
-						 * Returned to data phase
-						 * that requires data
-						 * transfer pointers to be
-						 * recalculated from the
-						 * transfer residual.
-						 */
-		HOST_MSG_LOOP,			/*
-						 * The bus is ready for the
-						 * host to perform another
-						 * message transaction.  This
-						 * mechanism is used for things
-						 * like sync/wide negotiation
-						 * that require a kernel based
-						 * message state engine.
-						 */
-		BAD_STATUS,			/* Bad status from target */
-		DATA_OVERRUN,			/*
-						 * Target attempted to write
-						 * beyond the bounds of its
-						 * command.
-						 */
-		MKMSG_FAILED,			/*
-						 * Target completed command
-						 * without honoring our ATN
-						 * request to issue a message. 
-						 */
-		MISSED_BUSFREE,			/*
-						 * The sequencer never saw
-						 * the bus go free after
-						 * either a command complete
-						 * or disconnect message.
-						 */
-		DUMP_CARD_STATE,
-		ILLEGAL_PHASE,
-		INVALID_SEQINT,
-		CFG4ISTAT_INTR,
-		STATUS_OVERRUN,
-		CFG4OVERRUN,
-		ENTERING_NONPACK,
-		TASKMGMT_FUNC_COMPLETE,		/*
-						 * Task management function
-						 * request completed with
-						 * an expected busfree.
-						 */
-		TASKMGMT_CMD_CMPLT_OKAY,	/*
-						 * A command with a non-zero
-						 * task management function
-						 * has completed via the normal
-						 * command completion method
-						 * for commands with a zero
-						 * task management function.
-						 * This happens when an attempt
-						 * to abort a command loses
-						 * the race for the command to
-						 * complete normally.
-						 */
-		TRACEPOINT0,
-		TRACEPOINT1,
-		TRACEPOINT2,
-		TRACEPOINT3,
-		SAW_HWERR
-	}
-}
-
-/*
- * Clear Host Interrupt
- */
-register CLRINT {
-	address			0x003
-	access_mode	WO
-	field	CLRHWERRINT	0x80 /* Rev B or greater */
-	field	CLRBRKADRINT	0x40
-	field	CLRSWTMINT	0x20
-	field	CLRPCIINT	0x10
-	field	CLRSCSIINT	0x08
-	field	CLRSEQINT	0x04
-	field	CLRCMDINT	0x02
-	field	CLRSPLTINT	0x01
-}
-
-/*
- * Error Register
- */
-register ERROR {
-	address			0x004
-	access_mode	RO
-	field	CIOPARERR	0x80
-	field	CIOACCESFAIL	0x40 /* Rev B or greater */
-	field	MPARERR		0x20
-	field	DPARERR		0x10
-	field	SQPARERR	0x08
-	field	ILLOPCODE	0x04
-	field	DSCTMOUT	0x02
-}
-
-/*
- * Clear Error
- */
-register CLRERR {
-	address			0x004
-	access_mode 	WO
-	field	CLRCIOPARERR	0x80
-	field	CLRCIOACCESFAIL	0x40 /* Rev B or greater */
-	field	CLRMPARERR	0x20
-	field	CLRDPARERR	0x10
-	field	CLRSQPARERR	0x08
-	field	CLRILLOPCODE	0x04
-	field	CLRDSCTMOUT	0x02
-}
-
-/*
- * Host Control Register
- * Overall host control of the device.
- */
-register HCNTRL {
-	address			0x005
-	access_mode	RW
-	field	SEQ_RESET	0x80 /* Rev B or greater */
-	field	POWRDN		0x40
-	field	SWINT		0x10
-	field	SWTIMER_START_B	0x08 /* Rev B or greater */
-	field	PAUSE		0x04
-	field	INTEN		0x02
-	field	CHIPRST		0x01
-	field	CHIPRSTACK	0x01
-}
-
-/*
- * Host New SCB Queue Offset
- */
-register HNSCB_QOFF {
-	address			0x006
-	access_mode	RW
-	size		2
-}
-
-/*
- * Host Empty SCB Queue Offset
- */
-register HESCB_QOFF {
-	address			0x008
-	access_mode	RW
-}
-
-/*
- * Host Mailbox
- */
-register HS_MAILBOX {
-	address			0x00B
-	access_mode	RW
-	mask	HOST_TQINPOS	0x80	/* Boundary at either 0 or 128 */
-	mask	ENINT_COALESS	0x40	/* Perform interrupt coalessing */
-}
-
-/*
- * Sequencer Interupt Status
- */
-register SEQINTSTAT {
-	address			0x00C
-	access_mode	RO
-	field	SEQ_SWTMRTO	0x10
-	field	SEQ_SEQINT	0x08
-	field	SEQ_SCSIINT	0x04
-	field	SEQ_PCIINT	0x02
-	field	SEQ_SPLTINT	0x01
-}
-
-/*
- * Clear SEQ Interrupt
- */
-register CLRSEQINTSTAT {
-	address			0x00C
-	access_mode	WO
-	field	CLRSEQ_SWTMRTO	0x10
-	field	CLRSEQ_SEQINT	0x08
-	field	CLRSEQ_SCSIINT	0x04
-	field	CLRSEQ_PCIINT	0x02
-	field	CLRSEQ_SPLTINT	0x01
-}
-
-/*
- * Software Timer
- */
-register SWTIMER {
-	address			0x00E
-	access_mode	RW
-	size		2
-}
-
-/*
- * SEQ New SCB Queue Offset
- */
-register SNSCB_QOFF {
-	address			0x010
-	access_mode	RW
-	size		2
-	modes		M_CCHAN
-}
-
-/*
- * SEQ Empty SCB Queue Offset
- */
-register SESCB_QOFF {
-	address			0x012
-	access_mode	RW
-	modes		M_CCHAN
-}
-
-/*
- * SEQ Done SCB Queue Offset
- */
-register SDSCB_QOFF {
-	address			0x014
-	access_mode	RW
-	modes		M_CCHAN
-	size		2
-}
-
-/*
- * Queue Offset Control & Status
- */
-register QOFF_CTLSTA {
-	address			0x016
-	access_mode	RW
-	modes		M_CCHAN
-	field	EMPTY_SCB_AVAIL	0x80
-	field	NEW_SCB_AVAIL	0x40
-	field	SDSCB_ROLLOVR	0x20
-	field	HS_MAILBOX_ACT	0x10
-	field	SCB_QSIZE	0x0F {
-		SCB_QSIZE_4,
-		SCB_QSIZE_8,
-		SCB_QSIZE_16,
-		SCB_QSIZE_32,
-		SCB_QSIZE_64,
-		SCB_QSIZE_128,
-		SCB_QSIZE_256,
-		SCB_QSIZE_512,
-		SCB_QSIZE_1024,
-		SCB_QSIZE_2048,
-		SCB_QSIZE_4096,
-		SCB_QSIZE_8192,
-		SCB_QSIZE_16384
-	}
-}
-
-/*
- * Interrupt Control
- */
-register INTCTL {
-	address			0x018
-	access_mode	RW
-	field	SWTMINTMASK	0x80
-	field	SWTMINTEN	0x40
-	field	SWTIMER_START	0x20
-	field	AUTOCLRCMDINT	0x10
-	field	PCIINTEN	0x08
-	field	SCSIINTEN	0x04
-	field	SEQINTEN	0x02
-	field	SPLTINTEN	0x01
-}
-
-/*
- * Data FIFO Control
- */
-register DFCNTRL {
-	address			0x019
-	access_mode	RW
-	modes		M_DFF0, M_DFF1
-	field	PRELOADEN	0x80
-	field	SCSIENWRDIS	0x40	/* Rev B only. */
-	field	SCSIEN		0x20
-	field	SCSIENACK	0x20
-	field	HDMAEN		0x08
-	field	HDMAENACK	0x08
-	field	DIRECTION	0x04
-	field	DIRECTIONACK	0x04
-	field	FIFOFLUSH	0x02
-	field	FIFOFLUSHACK	0x02
-	field	DIRECTIONEN	0x01
-}
-
-/*
- * Device Space Command 0
- */
-register DSCOMMAND0 {
-	address			0x019
-	access_mode	RW
-	modes		M_CFG
-	field	CACHETHEN	0x80	/* Cache Threshold enable */
-	field	DPARCKEN	0x40	/* Data Parity Check Enable */
-	field	MPARCKEN	0x20	/* Memory Parity Check Enable */
-	field	EXTREQLCK	0x10	/* External Request Lock */
-	field	DISABLE_TWATE	0x02	/* Rev B or greater */
-	field	CIOPARCKEN	0x01	/* Internal bus parity error enable */
-}
-
-/*
- * Data FIFO Status
- */
-register DFSTATUS {
-	address			0x01A
-	access_mode	RO
-	modes		M_DFF0, M_DFF1
-	field	PRELOAD_AVAIL		0x80
-	field	PKT_PRELOAD_AVAIL	0x40
-	field	MREQPEND		0x10
-	field	HDONE			0x08
-	field	DFTHRESH		0x04
-	field	FIFOFULL		0x02
-	field	FIFOEMP			0x01
-}
-
-/*
- * S/G Cache Pointer
- */
-register SG_CACHE_PRE {
-	address			0x01B
-	access_mode	WO
-	modes		M_DFF0, M_DFF1
-	field	SG_ADDR_MASK	0xf8
-	field	ODD_SEG		0x04
-	field	LAST_SEG	0x02
-}
-
-register SG_CACHE_SHADOW {
-	address			0x01B
-	access_mode	RO
-	modes		M_DFF0, M_DFF1
-	field	SG_ADDR_MASK	0xf8
-	field	ODD_SEG		0x04
-	field	LAST_SEG	0x02
-	field	LAST_SEG_DONE	0x01
-}
-
-/*
- * Arbiter Control
- */
-register ARBCTL {
-	address			0x01B
-	access_mode	RW
-	modes		M_CFG
-	field	RESET_HARB	0x80
-	field	RETRY_SWEN	0x08
-	field	USE_TIME	0x07
-}
-
-/*
- * Data Channel Host Address
- */
-register HADDR {
-	address			0x070
-	access_mode	RW
-	size		8
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * Host Overlay DMA Address
- */
-register HODMAADR {
-	address			0x070
-	access_mode	RW
-	size		8
-	modes		M_SCSI
-}
-
-/*
- * PCI PLL Delay.
- */
-register PLLDELAY {
-	address			0x070
-	access_mode	RW
-	size		1
-	modes		M_CFG
-	field	SPLIT_DROP_REQ	0x80
-}
-
-/*
- * Data Channel Host Count
- */
-register HCNT {
-	address			0x078
-	access_mode	RW
-	size		3
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * Host Overlay DMA Count
- */
-register HODMACNT {
-	address			0x078
-	access_mode	RW
-	size		2
-	modes		M_SCSI
-}
-
-/*
- * Host Overlay DMA Enable
- */
-register HODMAEN {
-	address			0x07A
-	access_mode	RW
-	modes		M_SCSI
-}
-
-/*
- * Scatter/Gather Host Address
- */
-register SGHADDR {
-	address			0x07C
-	access_mode	RW
-	size		8
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * SCB Host Address
- */
-register SCBHADDR {
-	address			0x07C
-	access_mode	RW
-	size		8
-	modes		M_CCHAN
-}
-
-/*
- * Scatter/Gather Host Count
- */
-register SGHCNT {
-	address			0x084
-	access_mode	RW
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * SCB Host Count
- */
-register SCBHCNT {
-	address			0x084
-	access_mode	RW
-	modes		M_CCHAN
-}
-
-/*
- * Data FIFO Threshold
- */
-register DFF_THRSH {
-	address			0x088
-	access_mode	RW
-	modes		M_CFG
-	field	WR_DFTHRSH	0x70 {
-		WR_DFTHRSH_MIN,
-		WR_DFTHRSH_25,
-		WR_DFTHRSH_50,
-		WR_DFTHRSH_63,
-		WR_DFTHRSH_75,
-		WR_DFTHRSH_85,
-		WR_DFTHRSH_90,
-		WR_DFTHRSH_MAX
-	}
-	field	RD_DFTHRSH	0x07 {
-		RD_DFTHRSH_MIN,
-		RD_DFTHRSH_25,
-		RD_DFTHRSH_50,
-		RD_DFTHRSH_63,
-		RD_DFTHRSH_75,
-		RD_DFTHRSH_85,
-		RD_DFTHRSH_90,
-		RD_DFTHRSH_MAX
-	}
-}
-
-/*
- * ROM Address
- */
-register ROMADDR {
-	address			0x08A
-	access_mode	RW
-	size		3
-}
-
-/*
- * ROM Control
- */
-register ROMCNTRL {
-	address			0x08D
-	access_mode	RW
-	field	ROMOP		0xE0
-	field	ROMSPD		0x18
-	field	REPEAT		0x02
-	field	RDY		0x01
-}
-
-/*
- * ROM Data
- */
-register ROMDATA {
-	address			0x08E
-	access_mode	RW
-}
-
-/*
- * Data Channel Receive Message 0
- */
-register DCHRXMSG0 {
-	address			0x090
-	access_mode	RO
-	modes		M_DFF0, M_DFF1
-	field		CDNUM	0xF8
-	field		CFNUM	0x07
-}
-
-/*
- * CMC Recieve Message 0
- */
-register CMCRXMSG0 {
-	address			0x090
-	access_mode	RO
-	modes		M_CCHAN
-	field		CDNUM	0xF8
-	field		CFNUM	0x07
-}
-
-/*
- * Overlay Recieve Message 0
- */
-register OVLYRXMSG0 {
-	address			0x090
-	access_mode	RO
-	modes		M_SCSI
-	field		CDNUM	0xF8
-	field		CFNUM	0x07
-}
-
-/*
- * Relaxed Order Enable
- */
-register ROENABLE {
-	address			0x090
-	access_mode	RW
-	modes		M_CFG
-	field	MSIROEN		0x20
-	field	OVLYROEN	0x10
-	field	CMCROEN		0x08
-	field	SGROEN		0x04
-	field	DCH1ROEN	0x02
-	field	DCH0ROEN	0x01
-}
-
-/*
- * Data Channel Receive Message 1
- */
-register DCHRXMSG1 {
-	address			0x091
-	access_mode	RO
-	modes		M_DFF0, M_DFF1
-	field	CBNUM		0xFF
-}
-
-/*
- * CMC Recieve Message 1
- */
-register CMCRXMSG1 {
-	address			0x091
-	access_mode	RO
-	modes		M_CCHAN
-	field	CBNUM		0xFF
-}
-
-/*
- * Overlay Recieve Message 1
- */
-register OVLYRXMSG1 {
-	address			0x091
-	access_mode	RO
-	modes		M_SCSI
-	field	CBNUM		0xFF
-}
-
-/*
- * No Snoop Enable
- */
-register NSENABLE {
-	address			0x091
-	access_mode	RW
-	modes		M_CFG
-	field	MSINSEN		0x20
-	field	OVLYNSEN	0x10
-	field	CMCNSEN		0x08
-	field	SGNSEN		0x04
-	field	DCH1NSEN	0x02
-	field	DCH0NSEN	0x01
-}
-
-/*
- * Data Channel Receive Message 2
- */
-register DCHRXMSG2 {
-	address			0x092
-	access_mode	RO
-	modes		M_DFF0, M_DFF1
-	field	MINDEX		0xFF
-}
-
-/*
- * CMC Recieve Message 2
- */
-register CMCRXMSG2 {
-	address			0x092
-	access_mode	RO
-	modes		M_CCHAN
-	field	MINDEX		0xFF
-}
-
-/*
- * Overlay Recieve Message 2
- */
-register OVLYRXMSG2 {
-	address			0x092
-	access_mode	RO
-	modes		M_SCSI
-	field	MINDEX		0xFF
-}
-
-/*
- * Outstanding Split Transactions
- */
-register OST {
-	address			0x092
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Data Channel Receive Message 3
- */
-register DCHRXMSG3 {
-	address			0x093
-	access_mode	RO
-	modes		M_DFF0, M_DFF1
-	field	MCLASS		0x0F
-}
-
-/*
- * CMC Recieve Message 3
- */
-register CMCRXMSG3 {
-	address			0x093
-	access_mode	RO
-	modes		M_CCHAN
-	field	MCLASS		0x0F
-}
-
-/*
- * Overlay Recieve Message 3
- */
-register OVLYRXMSG3 {
-	address			0x093
-	access_mode	RO
-	modes		M_SCSI
-	field	MCLASS		0x0F
-}
-
-/*
- * PCI-X Control
- */
-register PCIXCTL {
-	address			0x093
-	access_mode	RW
-	modes		M_CFG
-	field	SERRPULSE	0x80
-	field	UNEXPSCIEN	0x20
-	field	SPLTSMADIS	0x10
-	field	SPLTSTADIS	0x08
-	field	SRSPDPEEN	0x04
-	field	TSCSERREN	0x02
-	field	CMPABCDIS	0x01
-}
-
-/*
- * CMC Sequencer Byte Count
- */
-register CMCSEQBCNT {
-	address			0x094
-	access_mode	RO
-	modes		M_CCHAN
-}
-
-/*
- * Overlay Sequencer Byte Count
- */
-register OVLYSEQBCNT {
-	address			0x094
-	access_mode	RO
-	modes		M_SCSI
-}
-
-/*
- * Data Channel Sequencer Byte Count
- */
-register DCHSEQBCNT {
-	address			0x094
-	access_mode	RO
-	size		2
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * Data Channel Split Status 0
- */
-register DCHSPLTSTAT0 {
-	address			0x096
-	access_mode	RW
-	modes		M_DFF0, M_DFF1
-	field	STAETERM	0x80
-	field	SCBCERR		0x40
-	field	SCADERR		0x20
-	field	SCDATBUCKET	0x10
-	field	CNTNOTCMPLT	0x08
-	field	RXOVRUN		0x04
-	field	RXSCEMSG	0x02
-	field	RXSPLTRSP	0x01
-}
-
-/*
- * CMC Split Status 0
- */
-register CMCSPLTSTAT0 {
-	address			0x096
-	access_mode	RW
-	modes		M_CCHAN
-	field	STAETERM	0x80
-	field	SCBCERR		0x40
-	field	SCADERR		0x20
-	field	SCDATBUCKET	0x10
-	field	CNTNOTCMPLT	0x08
-	field	RXOVRUN		0x04
-	field	RXSCEMSG	0x02
-	field	RXSPLTRSP	0x01
-}
-
-/*
- * Overlay Split Status 0
- */
-register OVLYSPLTSTAT0 {
-	address			0x096
-	access_mode	RW
-	modes		M_SCSI
-	field	STAETERM	0x80
-	field	SCBCERR		0x40
-	field	SCADERR		0x20
-	field	SCDATBUCKET	0x10
-	field	CNTNOTCMPLT	0x08
-	field	RXOVRUN		0x04
-	field	RXSCEMSG	0x02
-	field	RXSPLTRSP	0x01
-}
-
-/*
- * Data Channel Split Status 1
- */
-register DCHSPLTSTAT1 {
-	address			0x097
-	access_mode	RW
-	modes		M_DFF0, M_DFF1
-	field	RXDATABUCKET	0x01
-}
-
-/*
- * CMC Split Status 1
- */
-register CMCSPLTSTAT1 {
-	address			0x097
-	access_mode	RW
-	modes		M_CCHAN
-	field	RXDATABUCKET	0x01
-}
-
-/*
- * Overlay Split Status 1
- */
-register OVLYSPLTSTAT1 {
-	address			0x097
-	access_mode	RW
-	modes		M_SCSI
-	field	RXDATABUCKET	0x01
-}
-
-/*
- * S/G Receive Message 0
- */
-register SGRXMSG0 {
-	address			0x098
-	access_mode	RO
-	modes		M_DFF0, M_DFF1
-	field		CDNUM	0xF8
-	field		CFNUM	0x07
-}
-
-/*
- * S/G Receive Message 1
- */
-register SGRXMSG1 {
-	address			0x099
-	access_mode	RO
-	modes		M_DFF0, M_DFF1
-	field	CBNUM		0xFF
-}
-
-/*
- * S/G Receive Message 2
- */
-register SGRXMSG2 {
-	address			0x09A
-	access_mode	RO
-	modes		M_DFF0, M_DFF1
-	field	MINDEX		0xFF
-}
-
-/*
- * S/G Receive Message 3
- */
-register SGRXMSG3 {
-	address			0x09B
-	access_mode	RO
-	modes		M_DFF0, M_DFF1
-	field	MCLASS		0x0F
-}
-
-/*
- * Slave Split Out Address 0
- */
-register SLVSPLTOUTADR0 {
-	address			0x098
-	access_mode	RO
-	modes		M_SCSI
-	field	LOWER_ADDR	0x7F
-}
-
-/*
- * Slave Split Out Address 1
- */
-register SLVSPLTOUTADR1 {
-	address			0x099
-	access_mode	RO
-	modes		M_SCSI
-	field	REQ_DNUM	0xF8
-	field	REQ_FNUM	0x07
-}
-
-/*
- * Slave Split Out Address 2
- */
-register SLVSPLTOUTADR2 {
-	address			0x09A
-	access_mode	RO
-	modes		M_SCSI
-	field	REQ_BNUM	0xFF
-}
-
-/*
- * Slave Split Out Address 3
- */
-register SLVSPLTOUTADR3 {
-	address			0x09B
-	access_mode	RO
-	modes		M_SCSI
-	field	RLXORD		020
-	field	TAG_NUM		0x1F
-}
-
-/*
- * SG Sequencer Byte Count
- */
-register SGSEQBCNT {
-	address			0x09C
-	access_mode	RO
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * Slave Split Out Attribute 0
- */
-register SLVSPLTOUTATTR0 {
-	address			0x09C
-	access_mode	RO
-	modes		M_SCSI
-	field	LOWER_BCNT	0xFF
-}
-
-/*
- * Slave Split Out Attribute 1
- */
-register SLVSPLTOUTATTR1 {
-	address			0x09D
-	access_mode	RO
-	modes		M_SCSI
-	field	CMPLT_DNUM	0xF8
-	field	CMPLT_FNUM	0x07
-}
-
-/*
- * Slave Split Out Attribute 2
- */
-register SLVSPLTOUTATTR2 {
-	address			0x09E
-	access_mode	RO
-	size		2
-	modes		M_SCSI
-	field	CMPLT_BNUM	0xFF
-}
-/*
- * S/G Split Status 0
- */
-register SGSPLTSTAT0 {
-	address			0x09E
-	access_mode	RW
-	modes		M_DFF0, M_DFF1
-	field	STAETERM	0x80
-	field	SCBCERR		0x40
-	field	SCADERR		0x20
-	field	SCDATBUCKET	0x10
-	field	CNTNOTCMPLT	0x08
-	field	RXOVRUN		0x04
-	field	RXSCEMSG	0x02
-	field	RXSPLTRSP	0x01
-}
-
-/*
- * S/G Split Status 1
- */
-register SGSPLTSTAT1 {
-	address			0x09F
-	access_mode	RW
-	modes		M_DFF0, M_DFF1
-	field	RXDATABUCKET	0x01
-}
-
-/*
- * Special Function
- */
-register SFUNCT {
-	address			0x09f
-	access_mode	RW
-	modes		M_CFG
-	field	TEST_GROUP	0xF0
-	field	TEST_NUM	0x0F
-}
-
-/*
- * Data FIFO 0 PCI Status 
- */
-register DF0PCISTAT {
-	address			0x0A0
-	access_mode	RW
-	modes		M_CFG
-	field	DPE		0x80
-	field	SSE		0x40
-	field	RMA		0x20
-	field	RTA		0x10
-	field	SCAAPERR	0x08
-	field	RDPERR		0x04
-	field	TWATERR		0x02
-	field	DPR		0x01
-}
-
-/*
- * Data FIFO 1 PCI Status 
- */
-register DF1PCISTAT {
-	address			0x0A1
-	access_mode	RW
-	modes		M_CFG
-	field	DPE		0x80
-	field	SSE		0x40
-	field	RMA		0x20
-	field	RTA		0x10
-	field	SCAAPERR	0x08
-	field	RDPERR		0x04
-	field	TWATERR		0x02
-	field	DPR		0x01
-}
-
-/*
- * S/G PCI Status 
- */
-register SGPCISTAT {
-	address			0x0A2
-	access_mode	RW
-	modes		M_CFG
-	field	DPE		0x80
-	field	SSE		0x40
-	field	RMA		0x20
-	field	RTA		0x10
-	field	SCAAPERR	0x08
-	field	RDPERR		0x04
-	field	DPR		0x01
-}
-
-/*
- * CMC PCI Status 
- */
-register CMCPCISTAT {
-	address			0x0A3
-	access_mode	RW
-	modes		M_CFG
-	field	DPE		0x80
-	field	SSE		0x40
-	field	RMA		0x20
-	field	RTA		0x10
-	field	SCAAPERR	0x08
-	field	RDPERR		0x04
-	field	TWATERR		0x02
-	field	DPR		0x01
-}
-
-/*
- * Overlay PCI Status 
- */
-register OVLYPCISTAT {
-	address			0x0A4
-	access_mode	RW
-	modes		M_CFG
-	field	DPE		0x80
-	field	SSE		0x40
-	field	RMA		0x20
-	field	RTA		0x10
-	field	SCAAPERR	0x08
-	field	RDPERR		0x04
-	field	DPR		0x01
-}
-
-/*
- * PCI Status for MSI Master DMA Transfer
- */
-register MSIPCISTAT {
-	address			0x0A6
-	access_mode	RW
-	modes		M_CFG
-	field	SSE		0x40
-	field	RMA		0x20
-	field	RTA		0x10
-	field	CLRPENDMSI	0x08
-	field	TWATERR		0x02
-	field	DPR		0x01
-}
-
-/*
- * PCI Status for Target
- */
-register TARGPCISTAT {
-	address			0x0A7
-	access_mode	RW
-	modes		M_CFG
-	field	DPE		0x80
-	field	SSE		0x40
-	field	STA		0x08
-	field	TWATERR		0x02
-}
-
-/*
- * LQ Packet In
- * The last LQ Packet recieved
- */
-register LQIN {
-	address			0x020
-	access_mode	RW
-	size		20
-	modes		M_DFF0, M_DFF1, M_SCSI
-}
-
-/*
- * SCB Type Pointer
- * SCB offset for Target Mode SCB type information
- */
-register TYPEPTR {
-	address			0x020
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Queue Tag Pointer
- * SCB offset to the Two Byte tag identifier used for target mode.
- */
-register TAGPTR {
-	address			0x021
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Logical Unit Number Pointer
- * SCB offset to the LSB (little endian) of the lun field.
- */
-register LUNPTR {
-	address			0x022
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Data Length Pointer
- * SCB offset for the 4 byte data length field in target mode.
- */
-register DATALENPTR {
-	address			0x023
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Status Length Pointer
- * SCB offset to the two byte status field in target SCBs.
- */
-register STATLENPTR {
-	address			0x024
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Command Length Pointer
- * Scb offset for the CDB length field in initiator SCBs.
- */
-register CMDLENPTR {
-	address			0x025
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Task Attribute Pointer
- * Scb offset for the byte field specifying the attribute byte
- * to be used in command packets.
- */ 
-register ATTRPTR {
-	address			0x026
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Task Management Flags Pointer
- * Scb offset for the byte field specifying the attribute flags
- * byte to be used in command packets.
- */ 
-register FLAGPTR {
-	address			0x027
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Command Pointer
- * Scb offset for the first byte in the CDB for initiator SCBs.
- */
-register CMDPTR {
-	address			0x028
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Queue Next Pointer
- * Scb offset for the 2 byte "next scb link".
- */
-register QNEXTPTR {
-	address			0x029
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * SCSI ID Pointer
- * Scb offset to the value to place in the SCSIID register
- * during target mode connections.
- */
-register IDPTR {
-	address			0x02A
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Command Aborted Byte Pointer
- * Offset to the SCB flags field that includes the
- * "SCB aborted" status bit.
- */
-register ABRTBYTEPTR {
-	address			0x02B
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Command Aborted Bit Pointer
- * Bit offset in the SCB flags field for "SCB aborted" status.
- */
-register ABRTBITPTR {
-	address			0x02C
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Rev B or greater.
- */
-register MAXCMDBYTES {
-	address			0x02D
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Rev B or greater.
- */
-register MAXCMD2RCV {
-	address			0x02E
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Rev B or greater.
- */
-register SHORTTHRESH {
-	address			0x02F
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Logical Unit Number Length
- * The length, in bytes, of the SCB lun field.
- */
-register LUNLEN {
-	address			0x030
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * CDB Limit
- * The size, in bytes, of the embedded CDB field in initator SCBs.
- */
-register CDBLIMIT {
-	address			0x031
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Maximum Commands
- * The maximum number of commands to issue during a
- * single packetized connection.
- */
-register MAXCMD {
-	address			0x032
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * Maximum Command Counter
- * The number of commands already sent during this connection
- */
-register MAXCMDCNT {
-	address			0x033
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * LQ Packet Reserved Bytes
- * The bytes to be sent in the currently reserved fileds
- * of all LQ packets.
- */
-register LQRSVD01 {
-	address			0x034
-	access_mode	RW
-	modes		M_SCSI
-}
-register LQRSVD16 {
-	address			0x035
-	access_mode	RW
-	modes		M_SCSI
-}
-register LQRSVD17 {
-	address			0x036
-	access_mode	RW
-	modes		M_SCSI
-}
-
-/*
- * Command Reserved 0
- * The byte to be sent for the reserved byte 0 of
- * outgoing command packets.
- */
-register CMDRSVD0 {
-	address			0x037
-	access_mode	RW
-	modes		M_CFG
-}
-
-/*
- * LQ Manager Control 0
- */
-register LQCTL0 {
-	address			0x038
-	access_mode	RW
-	modes		M_CFG
-	field	LQITARGCLT	0xC0
-	field	LQIINITGCLT	0x30
-	field	LQ0TARGCLT	0x0C
-	field	LQ0INITGCLT	0x03
-}
-
-/*
- * LQ Manager Control 1
- */
-register LQCTL1 {
-	address			0x038
-	access_mode	RW
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	PCI2PCI		0x04
-	field	SINGLECMD	0x02
-	field	ABORTPENDING	0x01
-}
-
-/*
- * LQ Manager Control 2
- */
-register LQCTL2 {
-	address			0x039
-	access_mode	RW
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	LQIRETRY	0x80
-	field	LQICONTINUE	0x40
-	field	LQITOIDLE	0x20
-	field	LQIPAUSE	0x10
-	field	LQORETRY	0x08
-	field	LQOCONTINUE	0x04
-	field	LQOTOIDLE	0x02
-	field	LQOPAUSE	0x01
-}
-
-/*
- * SCSI RAM BIST0
- */
-register SCSBIST0 {
-	address			0x039
-	access_mode	RW
-	modes		M_CFG
-	field	GSBISTERR	0x40
-	field	GSBISTDONE	0x20
-	field	GSBISTRUN	0x10
-	field	OSBISTERR	0x04
-	field	OSBISTDONE	0x02
-	field	OSBISTRUN	0x01
-}
-
-/*
- * SCSI Sequence Control0
- */
-register SCSISEQ0 {
-	address			0x03A
-	access_mode	RW
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	TEMODEO		0x80
-	field	ENSELO		0x40
-	field	ENARBO		0x20
-	field	FORCEBUSFREE	0x10
-	field	SCSIRSTO	0x01
-}
-
-/*
- * SCSI RAM BIST 1
- */
-register SCSBIST1 {
-	address			0x03A
-	access_mode	RW
-	modes		M_CFG
-	field	NTBISTERR	0x04
-	field	NTBISTDONE	0x02
-	field	NTBISTRUN	0x01
-}
-
-/*
- * SCSI Sequence Control 1
- */
-register SCSISEQ1 {
-	address			0x03B
-	access_mode	RW
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	MANUALCTL	0x40
-	field	ENSELI		0x20
-	field	ENRSELI		0x10
-	field	MANUALP		0x0C
-	field	ENAUTOATNP	0x02
-	field	ALTSTIM		0x01
-}
-
-/*
- * SCSI Transfer Control 0
- */
-register SXFRCTL0 {
-	address			0x03C
-	access_mode	RW
-	modes		M_SCSI
-	field	DFON		0x80
-	field	DFPEXP		0x40
-	field	BIOSCANCELEN	0x10
-	field	SPIOEN		0x08
-}
-
-/*
- * SCSI Transfer Control 1
- */
-register SXFRCTL1 {
-	address			0x03D
-	access_mode	RW
-	modes		M_SCSI
-	field	BITBUCKET	0x80
-	field	ENSACHK		0x40
-	field	ENSPCHK		0x20
-	field	STIMESEL	0x18
-	field	ENSTIMER	0x04
-	field	ACTNEGEN	0x02
-	field	STPWEN		0x01
-}
-
-/*
- * SCSI Transfer Control 2
- */
-register SXFRCTL2 {
-	address			0x03E
-	access_mode	RW
-	modes		M_SCSI
-	field	AUTORSTDIS	0x10
-	field	CMDDMAEN	0x08
-	field	ASU		0x07
-}
-
-/*
- * SCSI Bus Initiator IDs
- * Bitmask of observed initiators on the bus.
- */
-register BUSINITID {
-	address			0x03C
-	access_mode	RW
-	modes		M_CFG
-	size		2
-}
-
-/*
- * Data Length Counters
- * Packet byte counter.
- */
-register DLCOUNT {
-	address			0x03C
-	access_mode	RW
-	modes		M_DFF0, M_DFF1
-	size		3
-}
-
-/*
- * Data FIFO Status
- */
-register DFFSTAT {
-	address			0x03F
-	access_mode	RW
-	modes		M_SCSI
-	field	FIFO1FREE	0x20
-	field	FIFO0FREE	0x10
-	/*
-	 * On the B, this enum only works
-	 * in the read direction.  For writes,
-	 * you must use the B version of the
-	 * CURRFIFO_0 definition which is defined
-	 * as a constant outside of this register
-	 * definition to avoid confusing the
-	 * register pretty printing code.
-	 */
-	enum	CURRFIFO	0x03 {
-		CURRFIFO_0,
-		CURRFIFO_1,
-		CURRFIFO_NONE	0x3
-	}
-}
-
-const B_CURRFIFO_0 0x2
-
-/*
- * SCSI Bus Target IDs
- * Bitmask of observed targets on the bus.
- */
-register BUSTARGID {
-	address			0x03E
-	access_mode	RW
-	modes		M_CFG
-	size		2
-}
-
-/*
- * SCSI Control Signal Out
- */
-register SCSISIGO {
-	address			0x040
-	access_mode	RW
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	CDO		0x80
-	field	IOO		0x40
-	field	MSGO		0x20
-	field	ATNO		0x10
-	field	SELO		0x08
-	field	BSYO		0x04
-	field	REQO		0x02
-	field	ACKO		0x01
-/*
- * Possible phases to write into SCSISIG0
- */
-	enum	PHASE_MASK  CDO|IOO|MSGO {
-		P_DATAOUT	0x0,
-		P_DATAIN	IOO,
-		P_DATAOUT_DT	P_DATAOUT|MSGO,
-		P_DATAIN_DT	P_DATAIN|MSGO,
-		P_COMMAND	CDO,
-		P_MESGOUT	CDO|MSGO,
-		P_STATUS	CDO|IOO,
-		P_MESGIN	CDO|IOO|MSGO
-	}
-}
-
-register SCSISIGI {
-	address			0x041
-	access_mode	RO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	CDI		0x80
-	field	IOI		0x40
-	field	MSGI		0x20
-	field	ATNI		0x10
-	field	SELI		0x08
-	field	BSYI		0x04
-	field	REQI		0x02
-	field	ACKI		0x01
-/*
- * Possible phases in SCSISIGI
- */
-	enum	PHASE_MASK  CDO|IOO|MSGO {
-		P_DATAOUT	0x0,
-		P_DATAIN	IOO,
-		P_DATAOUT_DT	P_DATAOUT|MSGO,
-		P_DATAIN_DT	P_DATAIN|MSGO,
-		P_COMMAND	CDO,
-		P_MESGOUT	CDO|MSGO,
-		P_STATUS	CDO|IOO,
-		P_MESGIN	CDO|IOO|MSGO
-	}
-}
-
-/*
- * Multiple Target IDs
- * Bitmask of ids to respond as a target.
- */
-register MULTARGID {
-	address			0x040
-	access_mode	RW
-	modes		M_CFG
-	size		2
-}
-
-/*
- * SCSI Phase
- */
-register SCSIPHASE {
-	address			0x042
-	access_mode	RO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	STATUS_PHASE	0x20
-	field	COMMAND_PHASE	0x10
-	field	MSG_IN_PHASE	0x08
-	field	MSG_OUT_PHASE	0x04
-	field	DATA_PHASE_MASK	0x03 {
-		DATA_OUT_PHASE	0x01,
-		DATA_IN_PHASE	0x02
-	}
-}
-
-/*
- * SCSI Data 0 Image
- */
-register SCSIDAT0_IMG {
-	address			0x043
-	access_mode	RW
-	modes		M_DFF0, M_DFF1, M_SCSI
-}
-
-/*
- * SCSI Latched Data
- */
-register SCSIDAT {
-	address			0x044
-	access_mode	RW
-	modes		M_DFF0, M_DFF1, M_SCSI
-	size		2
-}
-
-/*
- * SCSI Data Bus
- */
-register SCSIBUS {
-	address			0x046
-	access_mode	RW
-	modes		M_DFF0, M_DFF1, M_SCSI
-	size		2
-}
-
-/*
- * Target ID In
- */
-register TARGIDIN {
-	address			0x048
-	access_mode	RO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	CLKOUT		0x80
-	field	TARGID		0x0F
-}
-
-/*
- * Selection/Reselection ID
- * Upper four bits are the device id.  The ONEBIT is set when the re/selecting
- * device did not set its own ID.
- */
-register SELID {
-	address			0x049
-	access_mode	RW
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	SELID_MASK	0xf0
-	field	ONEBIT		0x08
-}
-
-/*
- * SCSI Block Control
- * Controls Bus type and channel selection.  SELWIDE allows for the
- * coexistence of 8bit and 16bit devices on a wide bus.
- */
-register SBLKCTL {
-	address			0x04A
-	access_mode	RW
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	DIAGLEDEN	0x80
-	field	DIAGLEDON	0x40
-	field	ENAB40		0x08	/* LVD transceiver active */
-	field	ENAB20		0x04	/* SE/HVD transceiver active */
-	field	SELWIDE		0x02
-}
-
-/*
- * Option Mode
- */
-register OPTIONMODE {
-	address			0x04A
-	access_mode	RW
-	modes		M_CFG
-	field	BIOSCANCTL		0x80
-	field	AUTOACKEN		0x40
-	field	BIASCANCTL		0x20
-	field	BUSFREEREV		0x10
-	field	ENDGFORMCHK		0x04
-	field	AUTO_MSGOUT_DE		0x02
-	mask	OPTIONMODE_DEFAULTS	AUTO_MSGOUT_DE
-}
-
-/*
- * SCSI Status 0
- */
-register SSTAT0	{
-	address			0x04B
-	access_mode	RO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	TARGET		0x80	/* Board acting as target */
-	field	SELDO		0x40	/* Selection Done */
-	field	SELDI		0x20	/* Board has been selected */
-	field	SELINGO		0x10	/* Selection In Progress */
-	field	IOERR		0x08	/* LVD Tranceiver mode changed */
-	field	OVERRUN		0x04	/* SCSI Offset overrun detected */
-	field	SPIORDY		0x02	/* SCSI PIO Ready */
-	field	ARBDO		0x01	/* Arbitration Done Out */
-}
-
-/*
- * Clear SCSI Interrupt 0
- * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT0.
- */
-register CLRSINT0 {
-	address			0x04B
-	access_mode	WO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	CLRSELDO	0x40
-	field	CLRSELDI	0x20
-	field	CLRSELINGO	0x10
-	field	CLRIOERR	0x08
-	field	CLROVERRUN	0x04
-	field	CLRSPIORDY	0x02
-	field	CLRARBDO	0x01
-}
-
-/*
- * SCSI Interrupt Mode 0
- * Setting any bit will enable the corresponding function
- * in SIMODE0 to interrupt via the IRQ pin.
- */
-register SIMODE0 {
-	address			0x04B
-	access_mode	RW
-	modes		M_CFG
-	field	ENSELDO		0x40
-	field	ENSELDI		0x20
-	field	ENSELINGO	0x10
-	field	ENIOERR		0x08
-	field	ENOVERRUN	0x04
-	field	ENSPIORDY	0x02
-	field	ENARBDO		0x01
-}
-
-/*
- * SCSI Status 1
- */
-register SSTAT1 {
-	address			0x04C
-	access_mode	RO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	SELTO		0x80
-	field	ATNTARG 	0x40
-	field	SCSIRSTI	0x20
-	field	PHASEMIS	0x10
-	field	BUSFREE		0x08
-	field	SCSIPERR	0x04
-	field	STRB2FAST	0x02
-	field	REQINIT		0x01
-}
-
-/*
- * Clear SCSI Interrupt 1
- * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT1.
- */
-register CLRSINT1 {
-	address			0x04C
-	access_mode	WO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	CLRSELTIMEO	0x80
-	field	CLRATNO		0x40
-	field	CLRSCSIRSTI	0x20
-	field	CLRBUSFREE	0x08
-	field	CLRSCSIPERR	0x04
-	field	CLRSTRB2FAST	0x02
-	field	CLRREQINIT	0x01
-}
-
-/*
- * SCSI Status 2
- */
-register SSTAT2 {
-	address			0x04d
-	access_mode	RO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	BUSFREETIME	0xc0 {
-		BUSFREE_LQO	0x40,
-		BUSFREE_DFF0	0x80,
-		BUSFREE_DFF1	0xC0
-	}
-	field	NONPACKREQ	0x20
-	field	EXP_ACTIVE	0x10	/* SCSI Expander Active */
-	field	BSYX		0x08	/* Busy Expander */
-	field	WIDE_RES	0x04	/* Modes 0 and 1 only */
-	field	SDONE		0x02	/* Modes 0 and 1 only */
-	field	DMADONE		0x01	/* Modes 0 and 1 only */
-}
-
-/*
- * Clear SCSI Interrupt 2
- */
-register CLRSINT2 {
-	address			0x04D
-	access_mode	WO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	CLRNONPACKREQ	0x20
-	field	CLRWIDE_RES	0x04	/* Modes 0 and 1 only */
-	field	CLRSDONE	0x02	/* Modes 0 and 1 only */
-	field	CLRDMADONE	0x01	/* Modes 0 and 1 only */
-}
-
-/*
- * SCSI Interrupt Mode 2
- */
-register SIMODE2 {
-	address			0x04D
-	access_mode	RW
-	modes		M_CFG
-	field	ENWIDE_RES	0x04
-	field	ENSDONE		0x02
-	field	ENDMADONE	0x01
-}
-
-/*
- * Physical Error Diagnosis
- */
-register PERRDIAG {
-	address			0x04E
-	access_mode	RO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	HIZERO		0x80
-	field	HIPERR		0x40
-	field	PREVPHASE	0x20
-	field	PARITYERR	0x10
-	field	AIPERR		0x08
-	field	CRCERR		0x04
-	field	DGFORMERR	0x02
-	field	DTERR		0x01
-}
-
-/*
- * LQI Manager Current State
- */
-register LQISTATE {
-	address			0x04E
-	access_mode	RO
-	modes		M_CFG
-}
-
-/*
- * SCSI Offset Count
- */
-register SOFFCNT {
-	address			0x04F
-	access_mode	RO
-	modes		M_DFF0, M_DFF1, M_SCSI
-}
-
-/*
- * LQO Manager Current State
- */
-register LQOSTATE {
-	address			0x04F
-	access_mode	RO
-	modes		M_CFG
-}
-
-/*
- * LQI Manager Status
- */
-register LQISTAT0 {
-	address			0x050
-	access_mode	RO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	LQIATNQAS	0x20
-	field	LQICRCT1	0x10
-	field	LQICRCT2	0x08
-	field	LQIBADLQT	0x04
-	field	LQIATNLQ	0x02
-	field	LQIATNCMD	0x01
-}
-
-/*
- * Clear LQI Interrupts 0
- */
-register CLRLQIINT0 {
-	address			0x050
-	access_mode	WO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	CLRLQIATNQAS	0x20
-	field	CLRLQICRCT1	0x10
-	field	CLRLQICRCT2	0x08
-	field	CLRLQIBADLQT	0x04
-	field	CLRLQIATNLQ	0x02
-	field	CLRLQIATNCMD	0x01
-}
-
-/*
- * LQI Manager Interrupt Mode 0
- */
-register LQIMODE0 {
-	address			0x050
-	access_mode	RW
-	modes		M_CFG
-	field	ENLQIATNQASK	0x20
-	field	ENLQICRCT1	0x10
-	field	ENLQICRCT2	0x08
-	field	ENLQIBADLQT	0x04
-	field	ENLQIATNLQ	0x02
-	field	ENLQIATNCMD	0x01
-}
-
-/*
- * LQI Manager Status 1
- */
-register LQISTAT1 {
-	address			0x051
-	access_mode	RO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	LQIPHASE_LQ	0x80
-	field	LQIPHASE_NLQ	0x40
-	field	LQIABORT	0x20
-	field	LQICRCI_LQ	0x10
-	field	LQICRCI_NLQ	0x08
-	field	LQIBADLQI	0x04
-	field	LQIOVERI_LQ	0x02
-	field	LQIOVERI_NLQ	0x01
-}
-
-/*
- * Clear LQI Manager Interrupts1
- */
-register CLRLQIINT1 {
-	address			0x051
-	access_mode	WO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	CLRLQIPHASE_LQ	0x80
-	field	CLRLQIPHASE_NLQ	0x40
-	field	CLRLIQABORT	0x20
-	field	CLRLQICRCI_LQ	0x10
-	field	CLRLQICRCI_NLQ	0x08
-	field	CLRLQIBADLQI	0x04
-	field	CLRLQIOVERI_LQ	0x02
-	field	CLRLQIOVERI_NLQ	0x01
-}
-
-/*
- * LQI Manager Interrupt Mode 1
- */
-register LQIMODE1 {
-	address			0x051
-	access_mode	RW
-	modes		M_CFG
-	field	ENLQIPHASE_LQ	0x80
-	field	ENLQIPHASE_NLQ	0x40
-	field	ENLIQABORT	0x20
-	field	ENLQICRCI_LQ	0x10
-	field	ENLQICRCI_NLQ	0x08
-	field	ENLQIBADLQI	0x04
-	field	ENLQIOVERI_LQ	0x02
-	field	ENLQIOVERI_NLQ	0x01
-}
-
-/*
- * LQI Manager Status 2
- */
-register LQISTAT2 {
-	address			0x052
-	access_mode	RO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	PACKETIZED	0x80
-	field	LQIPHASE_OUTPKT	0x40
-	field	LQIWORKONLQ	0x20
-	field	LQIWAITFIFO	0x10
-	field	LQISTOPPKT	0x08
-	field	LQISTOPLQ	0x04
-	field	LQISTOPCMD	0x02
-	field	LQIGSAVAIL	0x01
-}
-
-/*
- * SCSI Status 3
- */
-register SSTAT3 {
-	address			0x053
-	access_mode	RO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	NTRAMPERR	0x02
-	field	OSRAMPERR	0x01
-}
-
-/*
- * Clear SCSI Status 3
- */
-register CLRSINT3 {
-	address			0x053
-	access_mode	WO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	CLRNTRAMPERR	0x02
-	field	CLROSRAMPERR	0x01
-}
-
-/*
- * SCSI Interrupt Mode 3
- */
-register SIMODE3 {
-	address			0x053
-	access_mode	RW
-	modes		M_CFG
-	field	ENNTRAMPERR	0x02
-	field	ENOSRAMPERR	0x01
-}
-
-/*
- * LQO Manager Status 0
- */
-register LQOSTAT0 {
-	address			0x054
-	access_mode	RO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	LQOTARGSCBPERR	0x10
-	field	LQOSTOPT2	0x08
-	field	LQOATNLQ	0x04
-	field	LQOATNPKT	0x02
-	field	LQOTCRC		0x01
-}
-
-/*
- * Clear LQO Manager interrupt 0
- */
-register CLRLQOINT0 {
-	address			0x054
-	access_mode	WO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	CLRLQOTARGSCBPERR	0x10
-	field	CLRLQOSTOPT2		0x08
-	field	CLRLQOATNLQ		0x04
-	field	CLRLQOATNPKT		0x02
-	field	CLRLQOTCRC		0x01
-}
-
-/*
- * LQO Manager Interrupt Mode 0
- */
-register LQOMODE0 {
-	address			0x054
-	access_mode	RW
-	modes		M_CFG
-	field	ENLQOTARGSCBPERR	0x10
-	field	ENLQOSTOPT2		0x08
-	field	ENLQOATNLQ		0x04
-	field	ENLQOATNPKT		0x02
-	field	ENLQOTCRC		0x01
-}
-
-/*
- * LQO Manager Status 1
- */
-register LQOSTAT1 {
-	address			0x055
-	access_mode	RO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	LQOINITSCBPERR	0x10
-	field	LQOSTOPI2	0x08
-	field	LQOBADQAS	0x04
-	field	LQOBUSFREE	0x02
-	field	LQOPHACHGINPKT	0x01
-}
-
-/*
- * Clear LOQ Interrupt 1
- */
-register CLRLQOINT1 {
-	address			0x055
-	access_mode	WO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	CLRLQOINITSCBPERR	0x10
-	field	CLRLQOSTOPI2		0x08
-	field	CLRLQOBADQAS		0x04
-	field	CLRLQOBUSFREE		0x02
-	field	CLRLQOPHACHGINPKT	0x01
-}
-
-/*
- * LQO Manager Interrupt Mode 1
- */
-register LQOMODE1 {
-	address			0x055
-	access_mode	RW
-	modes		M_CFG
-	field	ENLQOINITSCBPERR	0x10
-	field	ENLQOSTOPI2		0x08
-	field	ENLQOBADQAS		0x04
-	field	ENLQOBUSFREE		0x02
-	field	ENLQOPHACHGINPKT	0x01
-}
-
-/*
- * LQO Manager Status 2
- */
-register LQOSTAT2 {
-	address			0x056
-	access_mode	RO
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	LQOPKT		0xE0
-	field	LQOWAITFIFO	0x10
-	field	LQOPHACHGOUTPKT	0x02	/* outside of packet boundaries. */
-	field	LQOSTOP0	0x01	/* Stopped after sending all packets */
-}
-
-/*
- * Output Synchronizer Space Count
- */
-register OS_SPACE_CNT {
-	address			0x056
-	access_mode	RO
-	modes		M_CFG
-}
-
-/*
- * SCSI Interrupt Mode 1
- * Setting any bit will enable the corresponding function
- * in SIMODE1 to interrupt via the IRQ pin.
- */
-register SIMODE1 {
-	address			0x057
-	access_mode	RW
-	modes		M_DFF0, M_DFF1, M_SCSI
-	field	ENSELTIMO	0x80
-	field	ENATNTARG	0x40
-	field	ENSCSIRST	0x20
-	field	ENPHASEMIS	0x10
-	field	ENBUSFREE	0x08
-	field	ENSCSIPERR	0x04
-	field	ENSTRB2FAST	0x02
-	field	ENREQINIT	0x01
-}
-
-/*
- * Good Status FIFO
- */
-register GSFIFO {
-	address			0x058
-	access_mode	RO
-	size		2
-	modes		M_DFF0, M_DFF1, M_SCSI
-}
-
-/*
- * Data FIFO SCSI Transfer Control
- */
-register DFFSXFRCTL {
-	address			0x05A
-	access_mode	RW
-	modes		M_DFF0, M_DFF1
-	field	DFFBITBUCKET	0x08
-	field	CLRSHCNT	0x04
-	field	CLRCHN		0x02
-	field	RSTCHN		0x01
-}
-
-/*
- * Next SCSI Control Block
- */
-register NEXTSCB {
-	address			0x05A
-	access_mode	RW
-	size		2
-	modes		M_SCSI
-}
-
-/* Rev B only. */
-register LQOSCSCTL {
-	address			0x05A
-	access_mode	RW
-	size		1
-	modes		M_CFG
-	field		LQOH2A_VERSION	0x80
-	field		LQONOCHKOVER	0x01
-}
-
-/*
- * SEQ Interrupts
- */
-register SEQINTSRC {
-	address			0x05B
-	access_mode	RO
-	modes		M_DFF0, M_DFF1
-	field	CTXTDONE	0x40
-	field	SAVEPTRS	0x20
-	field	CFG4DATA	0x10
-	field	CFG4ISTAT	0x08
-	field	CFG4TSTAT	0x04
-	field	CFG4ICMD	0x02
-	field	CFG4TCMD	0x01
-}
-
-/*
- * Clear Arp Interrupts
- */
-register CLRSEQINTSRC {
-	address			0x05B
-	access_mode	WO
-	modes		M_DFF0, M_DFF1
-	field	CLRCTXTDONE	0x40
-	field	CLRSAVEPTRS	0x20
-	field	CLRCFG4DATA	0x10
-	field	CLRCFG4ISTAT	0x08
-	field	CLRCFG4TSTAT	0x04
-	field	CLRCFG4ICMD	0x02
-	field	CLRCFG4TCMD	0x01
-}
-
-/*
- * SEQ Interrupt Enabled (Shared)
- */
-register SEQIMODE {
-	address			0x05C
-	access_mode	RW
-	modes		M_DFF0, M_DFF1
-	field	ENCTXTDONE	0x40
-	field	ENSAVEPTRS	0x20
-	field	ENCFG4DATA	0x10
-	field	ENCFG4ISTAT	0x08
-	field	ENCFG4TSTAT	0x04
-	field	ENCFG4ICMD	0x02
-	field	ENCFG4TCMD	0x01
-}
-
-/*
- * Current SCSI Control Block
- */
-register CURRSCB {
-	address			0x05C
-	access_mode	RW
-	size		2
-	modes		M_SCSI
-}
-
-/*
- * Data FIFO Status
- */
-register MDFFSTAT {
-	address			0x05D
-	access_mode	RO
-	modes		M_DFF0, M_DFF1
-	field	SHCNTNEGATIVE	0x40 /* Rev B or higher */
-	field	SHCNTMINUS1	0x20 /* Rev B or higher */
-	field	LASTSDONE	0x10
-	field	SHVALID		0x08
-	field	DLZERO		0x04 /* FIFO data ends on packet boundary. */
-	field	DATAINFIFO	0x02
-	field	FIFOFREE	0x01
-}
-
-/*
- * CRC Control
- */
-register CRCCONTROL {
-	address			0x05d
-	access_mode	RW
-	modes		M_CFG
-	field	CRCVALCHKEN		0x40
-}
-
-/*
- * SCSI Test Control
- */
-register SCSITEST {
-	address			0x05E
-	access_mode	RW
-	modes		M_CFG
-	field	CNTRTEST	0x08
-	field	SEL_TXPLL_DEBUG	0x04
-}
-
-/*
- * Data FIFO Queue Tag
- */
-register DFFTAG {
-	address			0x05E
-	access_mode	RW
-	size		2
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * Last SCSI Control Block
- */
-register LASTSCB {
-	address			0x05E
-	access_mode	RW
-	size		2
-	modes		M_SCSI
-}
-
-/*
- * SCSI I/O Cell Power-down Control
- */
-register IOPDNCTL {
-	address			0x05F
-	access_mode	RW
-	modes		M_CFG
-	field	DISABLE_OE	0x80
-	field	PDN_IDIST	0x04
-	field	PDN_DIFFSENSE	0x01
-}
-
-/*
- * Shaddow Host Address.
- */
-register SHADDR {
-	address			0x060
-	access_mode	RO
-	size		8
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * Data Group CRC Interval.
- */
-register DGRPCRCI {
-	address			0x060
-	access_mode	RW
-	size		2
-	modes		M_CFG
-}
-
-/*
- * Data Transfer Negotiation Address
- */
-register NEGOADDR {
-	address			0x060
-	access_mode	RW
-	modes		M_SCSI
-}
-
-/*
- * Data Transfer Negotiation Data - Period Byte
- */
-register NEGPERIOD {
-	address			0x061
-	access_mode	RW
-	modes		M_SCSI
-}
-
-/*
- * Packetized CRC Interval
- */
-register PACKCRCI {
-	address			0x062
-	access_mode	RW
-	size		2
-	modes		M_CFG
-}
-
-/*
- * Data Transfer Negotiation Data - Offset Byte
- */
-register NEGOFFSET {
-	address			0x062
-	access_mode	RW
-	modes		M_SCSI
-}
-
-/*
- * Data Transfer Negotiation Data - PPR Options
- */
-register NEGPPROPTS {
-	address			0x063
-	access_mode	RW
-	modes		M_SCSI
-	field	PPROPT_PACE	0x08
-	field	PPROPT_QAS	0x04
-	field	PPROPT_DT	0x02
-	field	PPROPT_IUT	0x01
-}
-
-/*
- * Data Transfer Negotiation Data -  Connection Options
- */
-register NEGCONOPTS {
-	address			0x064
-	access_mode	RW
-	modes		M_SCSI
-	field	ENSNAPSHOT	0x40
-	field	RTI_WRTDIS	0x20
-	field	RTI_OVRDTRN	0x10
-	field	ENSLOWCRC	0x08
-	field	ENAUTOATNI	0x04
-	field	ENAUTOATNO	0x02
-	field	WIDEXFER	0x01
-}
-
-/*
- * Negotiation Table Annex Column Index.
- */
-register ANNEXCOL {
-	address			0x065
-	access_mode	RW
-	modes		M_SCSI
-}
-
-register SCSCHKN {
-	address			0x066
-	access_mode	RW
-	modes		M_CFG
-	field	STSELSKIDDIS	0x40
-	field	CURRFIFODEF	0x20
-	field	WIDERESEN	0x10
-	field	SDONEMSKDIS	0x08
-	field	DFFACTCLR	0x04
-	field	SHVALIDSTDIS	0x02
-	field	LSTSGCLRDIS	0x01
-}
-
-const AHD_ANNEXCOL_PER_DEV0	4
-const AHD_NUM_PER_DEV_ANNEXCOLS	4
-const AHD_ANNEXCOL_PRECOMP_SLEW	4
-const	AHD_PRECOMP_MASK	0x07
-const	AHD_PRECOMP_SHIFT	0
-const	AHD_PRECOMP_CUTBACK_17	0x04
-const	AHD_PRECOMP_CUTBACK_29	0x06
-const	AHD_PRECOMP_CUTBACK_37	0x07
-const	AHD_SLEWRATE_MASK	0x78
-const	AHD_SLEWRATE_SHIFT	3
-/*
- * Rev A has only a single bit of slew adjustment.
- * Rev B has 4 bits.
- */
-const	AHD_SLEWRATE_DEF_REVA	0x01
-const	AHD_SLEWRATE_DEF_REVB	0x08
-
-/* Rev A does not have any amplitude setting. */
-const AHD_ANNEXCOL_AMPLITUDE	6
-const	AHD_AMPLITUDE_MASK	0x7
-const	AHD_AMPLITUDE_SHIFT	0
-const	AHD_AMPLITUDE_DEF	0x7
-
-/*
- * Negotiation Table Annex Data Port.
- */
-register ANNEXDAT {
-	address			0x066
-	access_mode	RW
-	modes		M_SCSI
-}
-
-/*
- * Initiator's Own Id.
- * The SCSI ID to use for Selection Out and seen during a reselection..
- */
-register IOWNID {
-	address			0x067
-	access_mode	RW
-	modes		M_SCSI
-}
-
-/*
- * 960MHz Phase-Locked Loop Control 0
- */
-register PLL960CTL0 {
-	address			0x068
-	access_mode	RW
-	modes		M_CFG
-	field	PLL_VCOSEL	0x80
-	field	PLL_PWDN	0x40
-	field	PLL_NS		0x30
-	field	PLL_ENLUD	0x08
-	field	PLL_ENLPF	0x04
-	field	PLL_DLPF	0x02
-	field	PLL_ENFBM	0x01
-}
-
-/*
- * Target Own Id
- */
-register TOWNID {
-	address			0x069
-	access_mode	RW
-	modes		M_SCSI
-}
-
-/*
- * 960MHz Phase-Locked Loop Control 1
- */
-register PLL960CTL1 {
-	address			0x069
-	access_mode	RW
-	modes		M_CFG
-	field	PLL_CNTEN	0x80
-	field	PLL_CNTCLR	0x40
-	field	PLL_RST		0x01
-}
-
-/*
- * Expander Signature
- */
-register XSIG {
-	address			0x06A
-	access_mode	RW
-	modes		M_SCSI
-}
-
-/*
- * Shadow Byte Count
- */
-register SHCNT {
-	address			0x068
-	access_mode	RW
-	size		3
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * Selection Out ID
- */
-register SELOID {
-	address			0x06B
-	access_mode	RW
-	modes		M_SCSI
-}
-
-/*
- * 960-MHz Phase-Locked Loop Test Count
- */
-register PLL960CNT0 {
-	address			0x06A
-	access_mode	RO
-	size		2
-	modes		M_CFG
-}
-
-/*
- * 400-MHz Phase-Locked Loop Control 0
- */
-register PLL400CTL0 {
-	address			0x06C
-	access_mode	RW
-	modes		M_CFG
-	field	PLL_VCOSEL	0x80
-	field	PLL_PWDN	0x40
-	field	PLL_NS		0x30
-	field	PLL_ENLUD	0x08
-	field	PLL_ENLPF	0x04
-	field	PLL_DLPF	0x02
-	field	PLL_ENFBM	0x01
-}
-
-/*
- * Arbitration Fairness
- */
-register FAIRNESS {
-	address			0x06C
-	access_mode	RW
-	size		2
-	modes		M_SCSI
-}
-
-/*
- * 400-MHz Phase-Locked Loop Control 1
- */
-register PLL400CTL1 {
-	address			0x06D
-	access_mode	RW
-	modes		M_CFG
-	field	PLL_CNTEN	0x80
-	field	PLL_CNTCLR	0x40
-	field	PLL_RST		0x01
-}
-
-/*
- * Arbitration Unfairness
- */
-register UNFAIRNESS {
-	address			0x06E
-	access_mode	RW
-	size		2
-	modes		M_SCSI
-}
-
-/*
- * 400-MHz Phase-Locked Loop Test Count
- */
-register PLL400CNT0 {
-	address			0x06E
-	access_mode	RO
-	size		2
-	modes		M_CFG
-}
-
-/*
- * SCB Page Pointer
- */
-register SCBPTR {
-	address			0x0A8
-	access_mode	RW
-	size		2
-	modes		M_DFF0, M_DFF1, M_CCHAN, M_SCSI
-}
-
-/*
- * CMC SCB Array Count
- * Number of bytes to transfer between CMC SCB memory and SCBRAM.
- * Transfers must be 8byte aligned and sized.
- */
-register CCSCBACNT {
-	address			0x0AB
-	access_mode	RW
-	modes		M_CCHAN
-}
-
-/*
- * SCB Autopointer
- * SCB-Next Address Snooping logic.  When an SCB is transferred to
- * the card, the next SCB address to be used by the CMC array can
- * be autoloaded from that transfer.
- */
-register SCBAUTOPTR {
-	address			0x0AB
-	access_mode	RW
-	modes		M_CFG
-	field	AUSCBPTR_EN	0x80
-	field	SCBPTR_ADDR	0x38
-	field	SCBPTR_OFF	0x07
-}
-
-/*
- * CMC SG Ram Address Pointer
- */
-register CCSGADDR {
-	address			0x0AC
-	access_mode	RW
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * CMC SCB RAM Address Pointer
- */
-register CCSCBADDR {
-	address			0x0AC
-	access_mode	RW
-	modes		M_CCHAN
-}
-
-/*
- * CMC SCB Ram Back-up Address Pointer
- * Indicates the true stop location of transfers halted prior
- * to SCBHCNT going to 0.
- */
-register CCSCBADR_BK {
-	address			0x0AC
-	access_mode	RO
-	modes		M_CFG
-}
-
-/*
- * CMC SG Control
- */
-register CCSGCTL {
-	address			0x0AD
-	access_mode	RW
-	modes		M_DFF0, M_DFF1
-	field	CCSGDONE	0x80
-	field	SG_CACHE_AVAIL	0x10
-	field	CCSGENACK	0x08
-	mask	CCSGEN		0x0C
-	field	SG_FETCH_REQ	0x02
-	field	CCSGRESET	0x01
-}
-
-/*
- * CMD SCB Control
- */
-register CCSCBCTL {
-	address			0x0AD
-	access_mode	RW
-	modes		M_CCHAN
-	field	CCSCBDONE	0x80
-	field	ARRDONE		0x40
-	field	CCARREN		0x10
-	field	CCSCBEN		0x08
-	field	CCSCBDIR	0x04
-	field	CCSCBRESET	0x01
-}
-
-/*
- * CMC Ram BIST
- */
-register CMC_RAMBIST {
-	address			0x0AD
-	access_mode	RW
-	modes		M_CFG
-	field	SG_ELEMENT_SIZE		0x80
-	field	SCBRAMBIST_FAIL		0x40
-	field	SG_BIST_FAIL		0x20
-	field	SG_BIST_EN		0x10
-	field	CMC_BUFFER_BIST_FAIL	0x02
-	field	CMC_BUFFER_BIST_EN	0x01
-}
-
-/*
- * CMC SG RAM Data Port
- */
-register CCSGRAM {
-	address			0x0B0
-	access_mode	RW
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * CMC SCB RAM Data Port
- */
-register CCSCBRAM {
-	address			0x0B0
-	access_mode	RW
-	modes		M_CCHAN
-}
-
-/*
- * Flex DMA Address.
- */
-register FLEXADR {
-	address			0x0B0
-	access_mode	RW
-	size		3
-	modes		M_SCSI
-}
-
-/*
- * Flex DMA Byte Count
- */
-register FLEXCNT {
-	address			0x0B3
-	access_mode	RW
-	size		2
-	modes		M_SCSI
-}
-
-/*
- * Flex DMA Status
- */
-register FLEXDMASTAT {
-	address			0x0B5
-	access_mode	RW
-	modes		M_SCSI
-	field	FLEXDMAERR	0x02
-	field	FLEXDMADONE	0x01
-}
-
-/*
- * Flex DMA Data Port
- */
-register FLEXDATA {
-	address			0x0B6
-	access_mode	RW
-	modes		M_SCSI
-}
-
-/*
- * Board Data
- */
-register BRDDAT {
-	address			0x0B8
-	access_mode	RW
-	modes		M_SCSI
-}
-
-/*
- * Board Control
- */
-register BRDCTL {
-	address			0x0B9
-	access_mode	RW
-	modes		M_SCSI
-	field	FLXARBACK	0x80
-	field	FLXARBREQ	0x40
-	field	BRDADDR		0x38
-	field	BRDEN		0x04
-	field	BRDRW		0x02
-	field	BRDSTB		0x01
-}
-
-/*
- * Serial EEPROM Address
- */
-register SEEADR {
-	address			0x0BA
-	access_mode	RW
-	modes		M_SCSI
-}
-
-/*
- * Serial EEPROM Data
- */
-register SEEDAT {
-	address			0x0BC
-	access_mode	RW
-	size		2
-	modes		M_SCSI
-}
-
-/*
- * Serial EEPROM Status
- */
-register SEESTAT {
-	address			0x0BE
-	access_mode	RO
-	modes		M_SCSI
-	field	INIT_DONE	0x80
-	field	SEEOPCODE	0x70
-	field	LDALTID_L	0x08
-	field	SEEARBACK	0x04
-	field	SEEBUSY		0x02
-	field	SEESTART	0x01
-}
-
-/*
- * Serial EEPROM Control
- */
-register SEECTL {
-	address			0x0BE
-	access_mode	RW
-	modes		M_SCSI
-	field	SEEOPCODE	0x70 {
-		SEEOP_ERASE	0x70,
-		SEEOP_READ	0x60,
-		SEEOP_WRITE	0x50,
-	/*
-	 * The following four commands use special
-	 * addresses for differentiation.
-	 */
-		SEEOP_ERAL	0x40
-	}
-	mask	SEEOP_EWEN	0x40
-	mask	SEEOP_WALL	0x40
-	mask	SEEOP_EWDS	0x40
-	field	SEERST		0x02
-	field	SEESTART	0x01
-}
-
-const SEEOP_ERAL_ADDR	0x80
-const SEEOP_EWEN_ADDR	0xC0
-const SEEOP_WRAL_ADDR	0x40
-const SEEOP_EWDS_ADDR	0x00
-
-/*
- * SCB Counter
- */
-register SCBCNT {
-	address			0x0BF
-	access_mode	RW
-	modes		M_SCSI
-}
-
-/*
- * Data FIFO Write Address
- * Pointer to the next QWD location to be written to the data FIFO.
- */
-register DFWADDR {
-	address			0x0C0
-	access_mode	RW
-	size		2
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * DSP Filter Control
- */
-register DSPFLTRCTL {
-	address			0x0C0
-	access_mode	RW
-	modes		M_CFG
-	field	FLTRDISABLE	0x20
-	field	EDGESENSE	0x10
-	field	DSPFCNTSEL	0x0F
-}
-
-/*
- * DSP Data Channel Control
- */
-register DSPDATACTL {
-	address			0x0C1
-	access_mode	RW
-	modes		M_CFG
-	field	BYPASSENAB	0x80
-	field	DESQDIS		0x10
-	field	RCVROFFSTDIS	0x04
-	field	XMITOFFSTDIS	0x02
-}
-
-/*
- * Data FIFO Read Address
- * Pointer to the next QWD location to be read from the data FIFO.
- */
-register DFRADDR {
-	address			0x0C2
-	access_mode	RW
-	size		2
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * DSP REQ Control
- */
-register DSPREQCTL {
-	address			0x0C2
-	access_mode	RW
-	modes		M_CFG
-	field	MANREQCTL	0xC0
-	field	MANREQDLY	0x3F
-}
-
-/*
- * DSP ACK Control
- */
-register DSPACKCTL {
-	address			0x0C3
-	access_mode	RW
-	modes		M_CFG
-	field	MANACKCTL	0xC0
-	field	MANACKDLY	0x3F
-}
-
-/*
- * Data FIFO Data
- * Read/Write byte port into the data FIFO.  The read and write
- * FIFO pointers increment with each read and write respectively
- * to this port.
- */
-register DFDAT {
-	address			0x0C4
-	access_mode	RW
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * DSP Channel Select
- */
-register DSPSELECT {
-	address			0x0C4
-	access_mode	RW
-	modes		M_CFG
-	field	AUTOINCEN	0x80
-	field	DSPSEL		0x1F
-}
-
-const NUMDSPS 0x14
-
-/*
- * Write Bias Control
- */
-register WRTBIASCTL {
-	address			0x0C5
-	access_mode	WO
-	modes		M_CFG
-	field	AUTOXBCDIS	0x80
-	field	XMITMANVAL	0x3F
-}
-
-/*
- * Currently the WRTBIASCTL is the same as the default.
- */
-const WRTBIASCTL_HP_DEFAULT 0x0
-
-/*
- * Receiver Bias Control
- */
-register RCVRBIOSCTL {
-	address			0x0C6
-	access_mode	WO
-	modes		M_CFG
-	field	AUTORBCDIS	0x80
-	field	RCVRMANVAL	0x3F
-}
-
-/*
- * Write Bias Calculator
- */
-register WRTBIASCALC {
-	address			0x0C7
-	access_mode	RO
-	modes		M_CFG
-}
-
-/*
- * Data FIFO Pointers
- * Contains the byte offset from DFWADDR and DWRADDR to the current
- * FIFO write/read locations.
- */
-register DFPTRS {
-	address			0x0C8
-	access_mode	RW
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * Receiver Bias Calculator
- */
-register RCVRBIASCALC {
-	address			0x0C8
-	access_mode	RO
-	modes		M_CFG
-}
-
-/*
- * Data FIFO Backup Read Pointer
- * Contains the data FIFO address to be restored if the last
- * data accessed from the data FIFO was not transferred successfully.
- */
-register DFBKPTR {
-	address			0x0C9
-	access_mode	RW
-	size		2
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * Skew Calculator
- */
-register SKEWCALC {
-	address			0x0C9
-	access_mode	RO
-	modes		M_CFG
-}
-
-/*
- * Data FIFO Debug Control
- */
-register DFDBCTL {
-	address				0x0CB
-	access_mode	RW
-	modes		M_DFF0, M_DFF1
-	field	DFF_CIO_WR_RDY		0x20
-	field	DFF_CIO_RD_RDY		0x10
-	field	DFF_DIR_ERR		0x08
-	field	DFF_RAMBIST_FAIL	0x04
-	field	DFF_RAMBIST_DONE	0x02
-	field	DFF_RAMBIST_EN		0x01
-}
-
-/*
- * Data FIFO Space Count
- * Number of FIFO locations that are free.
- */
-register DFSCNT {
-	address			0x0CC
-	access_mode	RO
-	size		2
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * Data FIFO Byte Count
- * Number of filled FIFO locations.
- */
-register DFBCNT {
-	address			0x0CE
-	access_mode	RO
-	size		2
-	modes		M_DFF0, M_DFF1
-}
-
-/*
- * Sequencer Program Overlay Address.
- * Low address must be written prior to high address.
- */
-register OVLYADDR {
-	address			0x0D4
-	modes		M_SCSI
-	size		2
-	access_mode	RW
-}
-
-/*
- * Sequencer Control 0
- * Error detection mode, speed configuration,
- * single step, breakpoints and program load.
- */
-register SEQCTL0 {
-	address			0x0D6
-	access_mode RW
-	field	PERRORDIS	0x80
-	field	PAUSEDIS	0x40
-	field	FAILDIS		0x20
-	field	FASTMODE	0x10
-	field	BRKADRINTEN	0x08
-	field	STEP		0x04
-	field	SEQRESET	0x02
-	field	LOADRAM		0x01
-}
-
-/*
- * Sequencer Control 1
- * Instruction RAM Diagnostics
- */
-register SEQCTL1 {
-	address			0x0D7
-	access_mode RW
-	field	OVRLAY_DATA_CHK	0x08
-	field	RAMBIST_DONE	0x04
-	field	RAMBIST_FAIL	0x02
-	field	RAMBIST_EN	0x01
-}
-
-/*
- * Sequencer Flags
- * Zero and Carry state of the ALU.
- */
-register FLAGS {
-	address			0x0D8
-	access_mode RO
-	field	ZERO		0x02
-	field	CARRY		0x01
-}
-
-/*
- * Sequencer Interrupt Control
- */ 
-register SEQINTCTL {
-	address			0x0D9
-	access_mode RW
-	field	INTVEC1DSL	0x80
-	field	INT1_CONTEXT	0x20
-	field	SCS_SEQ_INT1M1	0x10
-	field	SCS_SEQ_INT1M0	0x08
-	field	INTMASK2	0x04
-	field	INTMASK1	0x02
-	field	IRET		0x01
-}
-
-/*
- * Sequencer RAM Data Port
- * Single byte window into the Sequencer Instruction Ram area starting
- * at the address specified by OVLYADDR.  To write a full instruction word,
- * simply write four bytes in succession.  OVLYADDR will increment after the
- * most significant instrution byte (the byte with the parity bit) is written.
- */
-register SEQRAM {
-	address			0x0DA
-	access_mode RW
-}
-
-/*
- * Sequencer Program Counter
- * Low byte must be written prior to high byte.
- */
-register PRGMCNT {
-	address			0x0DE
-	access_mode	RW
-	size		2
-}
-
-/*
- * Accumulator
- */
-register ACCUM {
-	address			0x0E0
-	access_mode RW
-	accumulator
-}
-
-/*
- * Source Index Register
- * Incrementing index for reads of SINDIR and the destination (low byte only)
- * for any immediate operands passed in jmp, jc, jnc, call instructions.
- * Example:
- *		mvi	0xFF	call some_routine;
- *
- *  Will set SINDEX[0] to 0xFF and call the routine "some_routine.
- */
-register SINDEX	{
-	address			0x0E2
-	access_mode	RW
-	size		2
-	sindex
-}
-
-/*
- * Destination Index Register
- * Incrementing index for writes to DINDIR.  Can be used as a scratch register.
- */
-register DINDEX {
-	address			0x0E4
-	access_mode	RW
-	size		2
-}
-
-/*
- * Break Address
- * Sequencer instruction breakpoint address address.
- */
-register BRKADDR0 {
-	address			0x0E6
-	access_mode	RW
-}
-
-register BRKADDR1 {
-	address			0x0E6
-	access_mode	RW
-	field	BRKDIS		0x80	/* Disable Breakpoint */
-}
-
-/*
- * All Ones
- * All reads to this register return the value 0xFF.
- */
-register ALLONES {
-	address			0x0E8
-	access_mode RO
-	allones
-}
-
-/*
- * All Zeros
- * All reads to this register return the value 0.
- */
-register ALLZEROS {
-	address			0x0EA
-	access_mode RO
-	allzeros
-}
-
-/*
- * No Destination
- * Writes to this register have no effect.
- */
-register NONE {
-	address			0x0EA
-	access_mode WO
-	none
-}
-
-/*
- * Source Index Indirect
- * Reading this register is equivalent to reading (register_base + SINDEX) and
- * incrementing SINDEX by 1.
- */
-register SINDIR	{
-	address			0x0EC
-	access_mode RO
-}
-
-/*
- * Destination Index Indirect
- * Writing this register is equivalent to writing to (register_base + DINDEX)
- * and incrementing DINDEX by 1.
- */
-register DINDIR	 {
-	address			0x0ED
-	access_mode WO
-}
-
-/*
- * Function One
- * 2's complement to bit value conversion.  Write the 2's complement value
- * (0-7 only) to the top nibble and retrieve the bit indexed by that value
- * on the next read of this register. 
- * Example:
- *	Write	0x60
- *	Read	0x40
- */
-register FUNCTION1 {
-	address			0x0F0
-	access_mode RW
-}
-
-/*
- * Stack
- * Window into the stack.  Each stack location is 10 bits wide reported
- * low byte followed by high byte.  There are 8 stack locations.
- */
-register STACK {
-	address			0x0F2
-	access_mode RW
-}
-
-/*
- * Interrupt Vector 1 Address
- * Interrupt branch address for SCS SEQ_INT1 mode 0 and 1 interrupts.
- */
-register INTVEC1_ADDR {
-	address			0x0F4
-	access_mode	RW
-	size		2
-	modes		M_CFG
-}
-
-/*
- * Current Address
- * Address of the SEQRAM instruction currently executing instruction.
- */
-register CURADDR {
-	address			0x0F4
-	access_mode	RW
-	size		2
-	modes		M_SCSI
-}
-
-/*
- * Interrupt Vector 2 Address
- * Interrupt branch address for HST_SEQ_INT2 interrupts.
- */
-register INTVEC2_ADDR {
-	address			0x0F6
-	access_mode	RW
-	size		2
-	modes		M_CFG
-}
-
-/*
- * Last Address
- * Address of the SEQRAM instruction executed prior to the current instruction.
- */
-register LASTADDR {
-	address			0x0F6
-	access_mode	RW
-	size		2
-	modes		M_SCSI
-}
-
-register AHD_PCI_CONFIG_BASE {
-	address			0x100
-	access_mode	RW
-	size		256
-	modes		M_CFG
-}
-
-/* ---------------------- Scratch RAM Offsets ------------------------- */
-scratch_ram {
-	/* Mode Specific */
-	address			0x0A0
-	size	8
-	modes	0, 1, 2, 3
-	REG0 {
-		size		2
-	}
-	REG1 {
-		size		2
-	}
-	REG_ISR {
-		size		2
-	}
-	SG_STATE {
-		size		1
-		field	SEGS_AVAIL	0x01
-		field	LOADING_NEEDED	0x02
-		field	FETCH_INPROG	0x04
-	}
-	/*
-	 * Track whether the transfer byte count for
-	 * the current data phase is odd.
-	 */
-	DATA_COUNT_ODD {
-		size		1
-	}
-}
-
-scratch_ram {
-	/* Mode Specific */
-	address			0x0F8
-	size	8
-	modes	0, 1, 2, 3
-	LONGJMP_ADDR {
-		size		2
-	}
-	LONGJMP_SCB {
-		size		2
-	}
-	ACCUM_SAVE {
-		size		1
-	}
-}
-
-
-scratch_ram {
-	address			0x100
-	size	128
-	modes	0, 1, 2, 3
-	/*
-	 * Per "other-id" execution queues.  We use an array of
-	 * tail pointers into lists of SCBs sorted by "other-id".
-	 * The execution head pointer threads the head SCBs for
-	 * each list.
-	 */
-	WAITING_SCB_TAILS {
-		size		32
-	}
-	WAITING_TID_HEAD {
-		size		2
-	}
-	WAITING_TID_TAIL {
-		size		2
-	}
-	/*
-	 * SCBID of the next SCB in the new SCB queue.
-	 */
-	NEXT_QUEUED_SCB_ADDR {
-		size		4
-	}
-	/*
-	 * head of list of SCBs that have
-	 * completed but have not been
-	 * put into the qoutfifo.
-	 */
-	COMPLETE_SCB_HEAD {
-		size		2
-	}
-	/*
-	 * The list of completed SCBs in
-	 * the active DMA.
-	 */
-	COMPLETE_SCB_DMAINPROG_HEAD {
-		size		2
-	}
-	/*
-	 * head of list of SCBs that have
-	 * completed but need to be uploaded
-	 * to the host prior to being completed.
-	 */
-	COMPLETE_DMA_SCB_HEAD {
-		size		2
-	}
-	/* Counting semaphore to prevent new select-outs */
-	QFREEZE_COUNT {
-		size		2
-	}
-	/*
-	 * Mode to restore on legacy idle loop exit.
-	 */
-	SAVED_MODE {
-		size		1
-	}
-	/*
-	 * Single byte buffer used to designate the type or message
-	 * to send to a target.
-	 */
-	MSG_OUT {
-		size		1
-	}
-	/* Parameters for DMA Logic */
-	DMAPARAMS {
-		size		1
-		field	PRELOADEN	0x80
-		field	WIDEODD		0x40
-		field	SCSIEN		0x20
-		field	SDMAEN		0x10
-		field	SDMAENACK	0x10
-		field	HDMAEN		0x08
-		field	HDMAENACK	0x08
-		field	DIRECTION	0x04	/* Set indicates PCI->SCSI */
-		field	FIFOFLUSH	0x02
-		field	FIFORESET	0x01
-	}
-	SEQ_FLAGS {
-		size		1
-		field	NOT_IDENTIFIED		0x80
-		field	NO_CDB_SENT		0x40
-		field	TARGET_CMD_IS_TAGGED	0x40
-		field	DPHASE			0x20
-		/* Target flags */
-		field	TARG_CMD_PENDING	0x10
-		field	CMDPHASE_PENDING	0x08
-		field	DPHASE_PENDING		0x04
-		field	SPHASE_PENDING		0x02
-		field	NO_DISCONNECT		0x01
-	}
-	/*
-	 * Temporary storage for the
-	 * target/channel/lun of a
-	 * reconnecting target
-	 */
-	SAVED_SCSIID {
-		size		1
-	}
-	SAVED_LUN {
-		size		1
-	}
-	/*
-	 * The last bus phase as seen by the sequencer. 
-	 */
-	LASTPHASE {
-		size		1
-		field	CDI		0x80
-		field	IOI		0x40
-		field	MSGI		0x20
-		field	P_BUSFREE	0x01
-		enum	PHASE_MASK  CDO|IOO|MSGO {
-			P_DATAOUT	0x0,
-			P_DATAIN	IOO,
-			P_DATAOUT_DT	P_DATAOUT|MSGO,
-			P_DATAIN_DT	P_DATAIN|MSGO,
-			P_COMMAND	CDO,
-			P_MESGOUT	CDO|MSGO,
-			P_STATUS	CDO|IOO,
-			P_MESGIN	CDO|IOO|MSGO
-		}
-	}
-	/*
-	 * Value to "or" into the SCBPTR[1] value to
-	 * indicate that an entry in the QINFIFO is valid.
-	 */
-	QOUTFIFO_ENTRY_VALID_TAG {
-		size		1
-	}
-	/*
-	 * Base address of our shared data with the kernel driver in host
-	 * memory.  This includes the qoutfifo and target mode
-	 * incoming command queue.
-	 */
-	SHARED_DATA_ADDR {
-		size		4
-	}
-	/*
-	 * Pointer to location in host memory for next
-	 * position in the qoutfifo.
-	 */
-	QOUTFIFO_NEXT_ADDR {
-		size		4
-	}
-	/*
-	 * Kernel and sequencer offsets into the queue of
-	 * incoming target mode command descriptors.  The
-	 * queue is full when the KERNEL_TQINPOS == TQINPOS.
-	 */
-	KERNEL_TQINPOS {
-		size		1
-	}
-	TQINPOS {                
-		size		1
-	}
-	ARG_1 {
-		size		1
-		mask	SEND_MSG		0x80
-		mask	SEND_SENSE		0x40
-		mask	SEND_REJ		0x20
-		mask	MSGOUT_PHASEMIS		0x10
-		mask	EXIT_MSG_LOOP		0x08
-		mask	CONT_MSG_LOOP_WRITE	0x04
-		mask	CONT_MSG_LOOP_READ	0x03
-		mask	CONT_MSG_LOOP_TARG	0x02
-		alias	RETURN_1
-	}
-	ARG_2 {
-		size		1
-		alias	RETURN_2
-	}
-
-	/*
-	 * Snapshot of MSG_OUT taken after each message is sent.
-	 */
-	LAST_MSG {
-		size		1
-	}
-
-	/*
-	 * Sequences the kernel driver has okayed for us.  This allows
-	 * the driver to do things like prevent initiator or target
-	 * operations.
-	 */
-	SCSISEQ_TEMPLATE {
-		size		1
-		field	MANUALCTL	0x40
-		field	ENSELI		0x20
-		field	ENRSELI		0x10
-		field	MANUALP		0x0C
-		field	ENAUTOATNP	0x02
-		field	ALTSTIM		0x01
-	}
-
-	/*
-	 * The initiator specified tag for this target mode transaction.
-	 */
-	INITIATOR_TAG {
-		size		1
-	}
-
-	SEQ_FLAGS2 {
-		size		1
-		field	TARGET_MSG_PENDING	  0x02
-		field	SELECTOUT_QFROZEN	  0x04
-	}
-
-	ALLOCFIFO_SCBPTR {
-		size		2
-	}
-
-	/*
-	 * The maximum amount of time to wait, when interrupt coalessing
-	 * is enabled, before issueing a CMDCMPLT interrupt for a completed
-	 * command.
-	 */
-	INT_COALESSING_TIMER {
-		size		2
-	}
-
-	/*
-	 * The maximum number of commands to coaless into a single interrupt.
-	 * Actually the 2's complement of that value to simplify sequencer
-	 * code.
-	 */
-	INT_COALESSING_MAXCMDS {
-		size		1
-	}
-
-	/*
-	 * The minimum number of commands still outstanding required
-	 * to continue coalessing (2's compliment of value).
-	 */
-	INT_COALESSING_MINCMDS {
-		size		1
-	}
-
-	/*
-	 * Number of commands "in-flight".
-	 */
-	CMDS_PENDING {
-		size		2
-	}
-
-	/*
-	 * The count of commands that have been coalessed.
-	 */
-	INT_COALESSING_CMDCOUNT {
-		size		1
-	}
-
-	/*
-	 * Since the HS_MAIBOX is self clearing, copy its contents to
-	 * this position in scratch ram every time it changes.
-	 */
-	LOCAL_HS_MAILBOX {
-		size		1
-	}
-	/*
-	 * Target-mode CDB type to CDB length table used
-	 * in non-packetized operation.
-	 */
-	CMDSIZE_TABLE {
-		size		8
-	}
-}
-
-/************************* Hardware SCB Definition ****************************/
-scb {
-	address			0x180
-	size	64
-	modes	0, 1, 2, 3
-	SCB_RESIDUAL_DATACNT {
-		size	4
-		alias	SCB_CDB_STORE
-	}
-	SCB_RESIDUAL_SGPTR {
-		size	4
-		alias	SCB_CDB_PTR
-		field	SG_ADDR_MASK		0xf8	/* In the last byte */
-		field	SG_OVERRUN_RESID	0x02	/* In the first byte */
-		field	SG_LIST_NULL		0x01	/* In the first byte */
-	}
-	SCB_SCSI_STATUS {
-		size	1
-	}
-	SCB_TARGET_PHASES {
-		size	1
-	}
-	SCB_TARGET_DATA_DIR {
-		size	1
-	}
-	SCB_TARGET_ITAG {
-		size	1
-	}
-	SCB_SENSE_BUSADDR {
-		/*
-		 * Only valid if CDB length is less than 13 bytes or
-		 * we are using a CDB pointer.  Otherwise contains
-		 * the last 4 bytes of embedded cdb information.
-		 */
-		size	4
-		alias	SCB_NEXT_COMPLETE
-	}
-	SCB_TAG {
-		size	2
-	}
-	SCB_CDB_LEN {
-		size	1
-		field	SCB_CDB_LEN_PTR	0x80	/* CDB in host memory */
-	}
-	SCB_TASK_MANAGEMENT {
-		size	1
-	}
-	SCB_NEXT {
-		alias	SCB_NEXT_SCB_BUSADDR
-		size	2
-	}
-	SCB_NEXT2 {
-		size	2
-	}
-	SCB_DATAPTR {
-		size	8
-	}
-	SCB_DATACNT {
-		/*
-		 * The last byte is really the high address bits for
-		 * the data address.
-		 */
-		size	4
-		field	SG_LAST_SEG		0x80	/* In the fourth byte */
-		field	SG_HIGH_ADDR_BITS	0x7F	/* In the fourth byte */
-	}
-	SCB_SGPTR {
-		size	4
-		field	SG_STATUS_VALID	0x04	/* In the first byte */
-		field	SG_FULL_RESID	0x02	/* In the first byte */
-		field	SG_LIST_NULL	0x01	/* In the first byte */
-	}
-	SCB_CONTROL {
-		size	1
-		field	TARGET_SCB	0x80
-		field	DISCENB		0x40
-		field	TAG_ENB		0x20
-		field	MK_MESSAGE	0x10
-		field	STATUS_RCVD	0x08
-		field	DISCONNECTED	0x04
-		field	SCB_TAG_TYPE	0x03
-	}
-	SCB_SCSIID {
-		size	1
-		field	TID	0xF0
-		field	OID	0x0F
-	}
-	SCB_LUN {
-		size	1
-		field	LID				0xff
-	}
-	SCB_TASK_ATTRIBUTE {
-		size	1
-	}
-	SCB_BUSADDR {
-		size	4
-	}
-	SCB_SPARE {
-		size	8
-		alias	SCB_PKT_LUN
-	}
-	SCB_DISCONNECTED_LISTS {
-		size	8
-	}
-}
-
-/*********************************** Constants ********************************/
-const MK_MESSAGE_BIT_OFFSET	4
-const TID_SHIFT		4
-const TARGET_CMD_CMPLT	0xfe
-const INVALID_ADDR	0x80
-#define SCB_LIST_NULL	0xff
-#define QOUTFIFO_ENTRY_VALID_TOGGLE	0x80
-
-const CCSGADDR_MAX	0x80
-const CCSCBADDR_MAX	0x80
-const CCSGRAM_MAXSEGS	16
-
-/* Selection Timeout Timer Constants */
-const STIMESEL_SHIFT	3
-const STIMESEL_MIN	0x18
-const STIMESEL_BUG_ADJ	0x8
-
-/* WDTR Message values */
-const BUS_8_BIT			0x00
-const BUS_16_BIT		0x01
-const BUS_32_BIT		0x02
-
-/* Offset maximums */
-const MAX_OFFSET		0xfe
-const MAX_OFFSET_PACED		0xfe
-const MAX_OFFSET_PACED_BUG	0x7f
-/*
- * Some 160 devices incorrectly accept 0xfe as a
- * sync offset, but will overrun this value.  Limit
- * to 0x7f for speed lower than U320 which will
- * avoid the persistent sync offset overruns.
- */
-const MAX_OFFSET_NON_PACED	0x7f
-const HOST_MSG			0xff
-
-/*
- * The size of our sense buffers.
- * Sense buffer mapping can be handled in either of two ways.
- * The first is to allocate a dmamap for each transaction.
- * Depending on the architecture, dmamaps can be costly. The
- * alternative is to statically map the buffers in much the same
- * way we handle our scatter gather lists.  The driver implements
- * the later.
- */
-const AHD_SENSE_BUFSIZE		256
-
-/* Target mode command processing constants */
-const CMD_GROUP_CODE_SHIFT	0x05
-
-const STATUS_BUSY		0x08
-const STATUS_QUEUE_FULL		0x28
-const STATUS_PKT_SENSE		0xFF
-const TARGET_DATA_IN		1
-
-const SCB_TRANSFER_SIZE_FULL_LUN	56
-const SCB_TRANSFER_SIZE_1BYTE_LUN	48
-/* PKT_OVERRUN_BUFSIZE must be a multiple of 256 less than 64K */
-const PKT_OVERRUN_BUFSIZE	512
-
-/*
- * Timer parameters.
- */
-const AHD_TIMER_US_PER_TICK	25
-const AHD_TIMER_MAX_TICKS	0xFFFF
-const AHD_TIMER_MAX_US		(AHD_TIMER_MAX_TICKS * AHD_TIMER_US_PER_TICK)
-
-/*
- * Downloaded (kernel inserted) constants
- */
-const SG_PREFETCH_CNT download
-const SG_PREFETCH_CNT_LIMIT download
-const SG_PREFETCH_ALIGN_MASK download
-const SG_PREFETCH_ADDR_MASK download
-const SG_SIZEOF download
-const PKT_OVERRUN_BUFOFFSET download
-const SCB_TRANSFER_SIZE	download
-
-/*
- * BIOS SCB offsets
- */
-const NVRAM_SCB_OFFSET	0x2C
diff -urNp linux-5720/drivers/scsi/aic79xx/aic79xx.seq linux-5730/drivers/scsi/aic79xx/aic79xx.seq
--- linux-5720/drivers/scsi/aic79xx/aic79xx.seq
+++ linux-5730/drivers/scsi/aic79xx/aic79xx.seq
@@ -1,1889 +0,0 @@
-/*
- * Adaptec U320 device driver firmware for Linux and FreeBSD.
- *
- * Copyright (c) 1994-2001 Justin T. Gibbs.
- * Copyright (c) 2000-2002 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $FreeBSD$
- */
-
-VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#78 $"
-PATCH_ARG_LIST = "struct ahd_softc *ahd"
-PREFIX = "ahd_"
-
-#include "aic79xx.reg"
-#include "scsi_message.h"
-
-restart:
-if ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {
-	test	SEQINTCODE, 0xFF jz idle_loop;
-	SET_SEQINTCODE(NO_SEQINT)
-}
-
-idle_loop:
-
-	if ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {
-		/*
-		 * Convert ERROR status into a sequencer
-		 * interrupt to handle the case of an
-		 * interrupt collision on the hardware
-		 * setting of HWERR.
-		 */
-		test	ERROR, 0xFF jz no_error_set;
-		SET_SEQINTCODE(SAW_HWERR)
-no_error_set:
-	}
-	SET_MODE(M_SCSI, M_SCSI)
-	test	SCSISEQ0, ENSELO|ENARBO jnz idle_loop_checkbus;
-	test	SEQ_FLAGS2, SELECTOUT_QFROZEN jnz idle_loop_checkbus;
-	cmp	WAITING_TID_HEAD[1], SCB_LIST_NULL je idle_loop_checkbus;
-	/*
-	 * ENSELO is cleared by a SELDO, so we must test for SELDO
-	 * one last time.
-	 */
-BEGIN_CRITICAL;
-	test	SSTAT0, SELDO jnz select_out;
-END_CRITICAL;
-	call	start_selection;
-idle_loop_checkbus:
-BEGIN_CRITICAL;
-	test	SSTAT0, SELDO jnz select_out;
-END_CRITICAL;
-	test	SSTAT0, SELDI jnz select_in;
-	test	SCSIPHASE, ~DATA_PHASE_MASK jz idle_loop_check_nonpackreq;
-	test	SCSISIGO, ATNO jz idle_loop_check_nonpackreq;
-	call	unexpected_nonpkt_phase_find_ctxt;
-idle_loop_check_nonpackreq:
-	test	SSTAT2, NONPACKREQ jz . + 2;
-	call	unexpected_nonpkt_phase_find_ctxt;
-	call	idle_loop_gsfifo_in_scsi_mode;
-	call	idle_loop_service_fifos;
-	call	idle_loop_cchan;
-	jmp	idle_loop;
-
-BEGIN_CRITICAL;
-idle_loop_gsfifo:
-	SET_MODE(M_SCSI, M_SCSI)
-idle_loop_gsfifo_in_scsi_mode:
-	test	LQISTAT2, LQIGSAVAIL jz return;
-	/*
-	 * We have received good status for this transaction.  There may
-	 * still be data in our FIFOs draining to the host.  Setup
-	 * monitoring of the draining process or complete the SCB.
-	 */
-good_status_IU_done:
-	bmov	SCBPTR, GSFIFO, 2;
-	clr	SCB_SCSI_STATUS;
-	/*
-	 * If a command completed before an attempted task management
-	 * function completed, notify the host after disabling any
-	 * pending select-outs.
-	 */
-	test	SCB_TASK_MANAGEMENT, 0xFF jz gsfifo_complete_normally;
-	test	SSTAT0, SELDO|SELINGO jnz . + 2;
-	and	SCSISEQ0, ~ENSELO;
-	SET_SEQINTCODE(TASKMGMT_CMD_CMPLT_OKAY)
-gsfifo_complete_normally:
-	or	SCB_CONTROL, STATUS_RCVD;
-
-	/*
-	 * Since this status did not consume a FIFO, we have to
-	 * be a bit more dilligent in how we check for FIFOs pertaining
-	 * to this transaction.  There are three states that a FIFO still
-	 * transferring data may be in.
-	 *
-	 * 1) Configured and draining to the host, with a pending CLRCHN.
-	 * 2) Configured and draining to the host, no pending CLRCHN.
-	 * 3) Pending cfg4data, fifo not empty.
-	 *
-	 * Cases 1 and 2 can be detected by noticing that a longjmp is
-	 * active for the FIFO and LONGJMP_SCB matches our SCB.  In this
-	 * case, we allow the routine servicing the FIFO to complete the SCB.
-	 * 
-	 * Case 3 implies either a pending or yet to occur save data
-	 * pointers for this same context in the other FIFO.  So, if
-	 * we detect case 2, we will properly defer the post of the SCB
-	 * and achieve the desired result.  The pending cfg4data will
-	 * notice that status has been received and complete the SCB.
-	 */
-	test	SCB_SGPTR, SG_LIST_NULL jz good_status_check_fifos;
-	/*
-	 * All segments have been loaded (or no data transfer), so
-	 * it is safe to complete the command.  Since this was a
-	 * cheap command to check for completion, loop to see if
-	 * more entries can be removed from the GSFIFO.
-	 */
-	call	complete;
-END_CRITICAL;
-	jmp	idle_loop_gsfifo_in_scsi_mode;
-BEGIN_CRITICAL;
-good_status_check_fifos:
-	clc;
-	bmov	ARG_1, SCBPTR, 2;
-	SET_MODE(M_DFF0, M_DFF0)
-	call	check_fifo;
-	jc	return;
-	SET_MODE(M_DFF1, M_DFF1)
-	call	check_fifo;
-	jc	return;
-	SET_MODE(M_SCSI, M_SCSI)
-	jmp	queue_scb_completion;
-END_CRITICAL;
-
-idle_loop_service_fifos:
-	SET_MODE(M_DFF0, M_DFF0)
-	test	LONGJMP_ADDR[1], INVALID_ADDR jnz idle_loop_next_fifo;
-	call	longjmp;
-idle_loop_next_fifo:
-	SET_MODE(M_DFF1, M_DFF1)
-	test	LONGJMP_ADDR[1], INVALID_ADDR jz longjmp;
-	ret;
-
-idle_loop_cchan:
-	SET_MODE(M_CCHAN, M_CCHAN)
-	test	QOFF_CTLSTA, HS_MAILBOX_ACT jz	hs_mailbox_empty;
-	mov	LOCAL_HS_MAILBOX, HS_MAILBOX;
-	or	QOFF_CTLSTA, HS_MAILBOX_ACT;
-hs_mailbox_empty:
-BEGIN_CRITICAL;
-	test	CCSCBCTL, CCARREN|CCSCBEN jz scbdma_idle;
-	test	CCSCBCTL, CCSCBDIR jnz fetch_new_scb_inprog;
-	test	CCSCBCTL, CCSCBDONE jz return;
-END_CRITICAL;
-	/* FALLTHROUGH */
-scbdma_tohost_done:
-	test	CCSCBCTL, CCARREN jz fill_qoutfifo_dmadone;
-	/*
-	 * A complete SCB upload requires no intervention.
-	 * The SCB is already on the COMPLETE_SCB list
-	 * and its completion notification will now be
-	 * handled just like any other SCB.
-	 */
-	and	CCSCBCTL, ~(CCARREN|CCSCBEN) ret;
-fill_qoutfifo_dmadone:
-	and	CCSCBCTL, ~(CCARREN|CCSCBEN);
-	call	qoutfifo_updated;
-	mvi	COMPLETE_SCB_DMAINPROG_HEAD[1], SCB_LIST_NULL;
-	bmov	QOUTFIFO_NEXT_ADDR, SCBHADDR, 4;
-	test	QOFF_CTLSTA, SDSCB_ROLLOVR jz return;
-	bmov	QOUTFIFO_NEXT_ADDR, SHARED_DATA_ADDR, 4;
-	xor	QOUTFIFO_ENTRY_VALID_TAG, QOUTFIFO_ENTRY_VALID_TOGGLE ret;
-
-qoutfifo_updated:
-	/*
-	 * If there are more commands waiting to be dma'ed
-	 * to the host, always coaless.  Otherwise honor the
-	 * host's wishes.
-	 */
-	cmp	COMPLETE_DMA_SCB_HEAD[1], SCB_LIST_NULL jne coaless_by_count;
-	cmp	COMPLETE_SCB_HEAD[1], SCB_LIST_NULL jne coaless_by_count;
-	test	LOCAL_HS_MAILBOX, ENINT_COALESS jz issue_cmdcmplt;
-
-	/*
-	 * If we have relatively few commands outstanding, don't
-	 * bother waiting for another command to complete.
-	 */
-	test	CMDS_PENDING[1], 0xFF jnz coaless_by_count;
-	/* Add -1 so that jnc means <= not just < */
-	add	A, -1, INT_COALESSING_MINCMDS;
-	add	NONE, A, CMDS_PENDING;
-	jnc	issue_cmdcmplt;
-	
-	/*
-	 * If coalessing, only coaless up to the limit
-	 * provided by the host driver.
-	 */
-coaless_by_count:
-	mov	A, INT_COALESSING_MAXCMDS;
-	add	NONE, A, INT_COALESSING_CMDCOUNT;
-	jc	issue_cmdcmplt;
-	/*
-	 * If the timer is not currently active,
-	 * fire it up.
-	 */
-	test	INTCTL, SWTMINTMASK jz return;
-	bmov	SWTIMER, INT_COALESSING_TIMER, 2;
-	mvi	CLRSEQINTSTAT, CLRSEQ_SWTMRTO;
-	or	INTCTL, SWTMINTEN|SWTIMER_START;
-	and	INTCTL, ~SWTMINTMASK ret;
-
-issue_cmdcmplt:
-	mvi	INTSTAT, CMDCMPLT;
-	clr	INT_COALESSING_CMDCOUNT;
-	or	INTCTL, SWTMINTMASK ret;
-
-BEGIN_CRITICAL;
-fetch_new_scb_inprog:
-	test	CCSCBCTL, ARRDONE jz return;
-fetch_new_scb_done:
-	and	CCSCBCTL, ~(CCARREN|CCSCBEN);
-	bmov	REG0, SCBPTR, 2;
-	clr	A;
-	add	CMDS_PENDING, 1;
-	adc	CMDS_PENDING[1], A;
-	/* Update the next SCB address to download. */
-	bmov	NEXT_QUEUED_SCB_ADDR, SCB_NEXT_SCB_BUSADDR, 4;
-	mvi	SCB_NEXT[1], SCB_LIST_NULL;
-	mvi	SCB_NEXT2[1], SCB_LIST_NULL;
-	/* Increment our position in the QINFIFO. */
-	mov	NONE, SNSCB_QOFF;
-	/*
-	 * SCBs that want to send messages are always
-	 * queued independently.  This ensures that they
-	 * are at the head of the SCB list to select out
-	 * to a target and we will see the MK_MESSAGE flag.
-	 */
-	test	SCB_CONTROL, MK_MESSAGE jnz first_new_target_scb;
-	shr	SINDEX, 3, SCB_SCSIID;
-	and	SINDEX, ~0x1;
-	mvi	SINDEX[1], (WAITING_SCB_TAILS >> 8);
-	bmov	DINDEX, SINDEX, 2;
-	bmov	SCBPTR, SINDIR, 2;
-	bmov	DINDIR, REG0, 2;
-	cmp	SCBPTR[1], SCB_LIST_NULL je first_new_target_scb;
-	bmov	SCB_NEXT, REG0, 2 ret;
-first_new_target_scb:
-	cmp	WAITING_TID_HEAD[1], SCB_LIST_NULL je first_new_scb;
-	bmov	SCBPTR, WAITING_TID_TAIL, 2;
-	bmov	SCB_NEXT2, REG0, 2;
-	bmov	WAITING_TID_TAIL, REG0, 2 ret;
-first_new_scb:
-	bmov	WAITING_TID_HEAD, REG0, 2;
-	bmov	WAITING_TID_TAIL, REG0, 2 ret;
-END_CRITICAL;
-
-scbdma_idle:
-	/*
-	 * Give precedence to downloading new SCBs to execute
-	 * unless select-outs are currently frozen.
-	 */
-	test	SEQ_FLAGS2, SELECTOUT_QFROZEN jnz . + 2;
-BEGIN_CRITICAL;
-	test	QOFF_CTLSTA, NEW_SCB_AVAIL jnz fetch_new_scb;
-	cmp	COMPLETE_DMA_SCB_HEAD[1], SCB_LIST_NULL jne dma_complete_scb;
-	cmp	COMPLETE_SCB_HEAD[1], SCB_LIST_NULL je return;
-	/* FALLTHROUGH */
-fill_qoutfifo:
-	/*
-	 * Keep track of the SCBs we are dmaing just
-	 * in case the DMA fails or is aborted.
-	 */
-	mov	A, QOUTFIFO_ENTRY_VALID_TAG;
-	bmov	COMPLETE_SCB_DMAINPROG_HEAD, COMPLETE_SCB_HEAD, 2;
-	mvi	CCSCBCTL, CCSCBRESET;
-	bmov	SCBHADDR, QOUTFIFO_NEXT_ADDR, 4;
-	bmov	SCBPTR, COMPLETE_SCB_HEAD, 2;
-fill_qoutfifo_loop:
-	mov	CCSCBRAM, SCBPTR;
-	or	CCSCBRAM, A, SCBPTR[1];
-	mov	NONE, SDSCB_QOFF;
-	inc	INT_COALESSING_CMDCOUNT;
-	add	CMDS_PENDING, -1;
-	adc	CMDS_PENDING[1], -1;
-	cmp	SCB_NEXT_COMPLETE[1], SCB_LIST_NULL je fill_qoutfifo_done;
-	cmp	CCSCBADDR, CCSCBADDR_MAX je fill_qoutfifo_done;
-	test	QOFF_CTLSTA, SDSCB_ROLLOVR jnz fill_qoutfifo_done;
-	bmov	SCBPTR, SCB_NEXT_COMPLETE, 2;
-	jmp	fill_qoutfifo_loop;
-fill_qoutfifo_done:
-	mov	SCBHCNT, CCSCBADDR;
-	mvi	CCSCBCTL, CCSCBEN|CCSCBRESET;
-	bmov	COMPLETE_SCB_HEAD, SCB_NEXT_COMPLETE, 2;
-	mvi	SCB_NEXT_COMPLETE[1], SCB_LIST_NULL ret;
-
-fetch_new_scb:
-	bmov	SCBHADDR, NEXT_QUEUED_SCB_ADDR, 4;
-	mvi	CCARREN|CCSCBEN|CCSCBDIR|CCSCBRESET jmp dma_scb;
-dma_complete_scb:
-	bmov	SCBPTR, COMPLETE_DMA_SCB_HEAD, 2;
-	bmov	SCBHADDR, SCB_BUSADDR, 4;
-	mvi	CCARREN|CCSCBEN|CCSCBRESET call dma_scb;
-	/*
-	 * Now that we've started the DMA, push us onto
-	 * the normal completion queue to have our SCBID
-	 * posted to the kernel.
-	 */
-	bmov	COMPLETE_DMA_SCB_HEAD, SCB_NEXT_COMPLETE, 2;
-	bmov	SCB_NEXT_COMPLETE, COMPLETE_SCB_HEAD, 2;
-	bmov	COMPLETE_SCB_HEAD, SCBPTR, 2 ret;
-END_CRITICAL;
-
-/*
- * Either post or fetch an SCB from host memory.  The caller
- * is responsible for polling for transfer completion.
- *
- * Prerequisits: Mode == M_CCHAN
- *		 SINDEX contains CCSCBCTL flags
- *		 SCBHADDR set to Host SCB address
- *		 SCBPTR set to SCB src location on "push" operations
- */
-SET_SRC_MODE	M_CCHAN;
-SET_DST_MODE	M_CCHAN;
-dma_scb:
-	mvi	SCBHCNT, SCB_TRANSFER_SIZE;
-	mov	CCSCBCTL, SINDEX ret;
-
-BEGIN_CRITICAL;
-setjmp_setscb:
-	bmov	LONGJMP_SCB, SCBPTR, 2;
-setjmp:
-	bmov	LONGJMP_ADDR, STACK, 2 ret;
-setjmp_inline:
-	bmov	LONGJMP_ADDR, STACK, 2;
-longjmp:
-	bmov	STACK, LONGJMP_ADDR, 2 ret;
-END_CRITICAL;
-
-/*************************** Chip Bug Work Arounds ****************************/
-/*
- * Must disable interrupts when setting the mode pointer
- * register as an interrupt occurring mid update will
- * fail to store the new mode value for restoration on
- * an iret.
- */
-if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {
-set_mode_work_around:
-	mvi	SEQINTCTL, INTVEC1DSL;
-	mov	MODE_PTR, SINDEX;
-	clr	SEQINTCTL ret;
-
-toggle_dff_mode_work_around:
-	mvi	SEQINTCTL, INTVEC1DSL;
-	xor	MODE_PTR, MK_MODE(M_DFF1, M_DFF1);
-	clr	SEQINTCTL ret;
-}
-
-
-if ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {
-set_seqint_work_around:
-	mov	SEQINTCODE, SINDEX;
-	mvi	SEQINTCODE, NO_SEQINT ret;
-}
-
-/************************ Packetized LongJmp Routines *************************/
-SET_SRC_MODE	M_SCSI;
-SET_DST_MODE	M_SCSI;
-start_selection:
-BEGIN_CRITICAL;
-	if ((ahd->bugs & AHD_SENT_SCB_UPDATE_BUG) != 0) {
-		/*
-		 * Razor #494
-		 * Rev A hardware fails to update LAST/CURR/NEXTSCB
-		 * correctly after a packetized selection in several
-		 * situations:
-		 *
-		 * 1) If only one command existed in the queue, the
-		 *    LAST/CURR/NEXTSCB are unchanged.
-		 *
-		 * 2) In a non QAS, protocol allowed phase change,
-		 *    the queue is shifted 1 too far.  LASTSCB is
-		 *    the last SCB that was correctly processed.
-		 * 
-		 * 3) In the QAS case, if the full list of commands
-		 *    was successfully sent, NEXTSCB is NULL and neither
-		 *    CURRSCB nor LASTSCB can be trusted.  We must
-		 *    manually walk the list counting MAXCMDCNT elements
-		 *    to find the last SCB that was sent correctly.
-		 *
-		 * To simplify the workaround for this bug in SELDO
-		 * handling, we initialize LASTSCB prior to enabling
-		 * selection so we can rely on it even for case #1 above.
-		 */
-		bmov	LASTSCB, WAITING_TID_HEAD, 2;
-	}
-	bmov	CURRSCB, WAITING_TID_HEAD, 2;
-	bmov	SCBPTR, WAITING_TID_HEAD, 2;
-	shr	SELOID, 4, SCB_SCSIID;
-	/*
-	 * If we want to send a message to the device, ensure
-	 * we are selecting with atn irregardless of our packetized
-	 * agreement.  Since SPI4 only allows target reset or PPR
-	 * messages if this is a packetized connection, the change
-	 * to our negotiation table entry for this selection will
-	 * be cleared when the message is acted on.
-	 */
-	test	SCB_CONTROL, MK_MESSAGE jz . + 3;
-	mov	NEGOADDR, SELOID;
-	or	NEGCONOPTS, ENAUTOATNO;
-	or	SCSISEQ0, ENSELO ret;
-END_CRITICAL;
-
-/*
- * Allocate a FIFO for a non-packetized transaction.
- * In RevA hardware, both FIFOs must be free before we
- * can allocate a FIFO for a non-packetized transaction.
- */
-allocate_fifo_loop:
-	/*
-	 * Do whatever work is required to free a FIFO.
-	 */
-	call	idle_loop_service_fifos;
-	SET_MODE(M_SCSI, M_SCSI)
-allocate_fifo:
-	if ((ahd->bugs & AHD_NONPACKFIFO_BUG) != 0) {
-		and	A, FIFO0FREE|FIFO1FREE, DFFSTAT;
-		cmp	A, FIFO0FREE|FIFO1FREE jne allocate_fifo_loop;
-	} else {
-		test	DFFSTAT, FIFO1FREE jnz allocate_fifo1;
-		test	DFFSTAT, FIFO0FREE jz allocate_fifo_loop;
-		mvi	DFFSTAT, B_CURRFIFO_0;
-		SET_MODE(M_DFF0, M_DFF0)
-		bmov	SCBPTR, ALLOCFIFO_SCBPTR, 2 ret;
-	}
-SET_SRC_MODE	M_SCSI;
-SET_DST_MODE	M_SCSI;
-allocate_fifo1:
-	mvi	DFFSTAT, CURRFIFO_1;
-	SET_MODE(M_DFF1, M_DFF1)
-	bmov	SCBPTR, ALLOCFIFO_SCBPTR, 2 ret;
-
-/*
- * We have been reselected as an initiator
- * or selected as a target.
- */
-SET_SRC_MODE	M_SCSI;
-SET_DST_MODE	M_SCSI;
-select_in:
-	if ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0) {
-		/*
-		 * This exposes a window whereby a
-		 * busfree just after a selection will
-		 * be missed, but there is no other safe
-		 * way to enable busfree detection if
-		 * the busfreerev function is broken.
-		 */
-		mvi	CLRSINT1,CLRBUSFREE;
-		or	SIMODE1, ENBUSFREE;
-	}
-	or	SXFRCTL0, SPIOEN;
-	and	SAVED_SCSIID, SELID_MASK, SELID;
-	and	A, OID, IOWNID;
-	or	SAVED_SCSIID, A;
-	mvi	CLRSINT0, CLRSELDI;
-	jmp	ITloop;
-
-/*
- * We have successfully selected out.
- *
- * Clear SELDO.
- * Dequeue all SCBs sent from the waiting queue
- * Requeue all SCBs *not* sent to the tail of the waiting queue
- * Take Razor #494 into account for above.
- *
- * In Packetized Mode:
- *	Return to the idle loop.  Our interrupt handler will take
- *	care of any incoming L_Qs.
- *
- * In Non-Packetize Mode:
- *	Continue to our normal state machine.
- */
-SET_SRC_MODE	M_SCSI;
-SET_DST_MODE	M_SCSI;
-select_out:
-BEGIN_CRITICAL;
-	/* Clear out all SCBs that have been successfully sent. */
-	if ((ahd->bugs & AHD_SENT_SCB_UPDATE_BUG) != 0) {
-		/*
-		 * For packetized, the LQO manager clears ENSELO on
-		 * the assertion of SELDO.  If we are non-packetized,
-		 * LASTSCB and CURRSCB are acuate.
-		 */
-		test	SCSISEQ0, ENSELO jnz use_lastscb;
-
-		/*
-		 * The update is correct for LQOSTAT1 errors.  All
-		 * but LQOBUSFREE are handled by kernel interrupts.
-		 * If we see LQOBUSFREE, return to the idle loop.
-		 * Once we are out of the select_out critical section,
-		 * the kernel will cleanup the LQOBUSFREE and we will
-		 * eventually restart the selection if appropriate.
-		 */
-		test	LQOSTAT1, LQOBUSFREE jnz idle_loop;
-
-		/*
-		 * On a phase change oustside of packet boundaries,
-		 * LASTSCB points to the currently active SCB context
-		 * on the bus.
-		 */
-		test	LQOSTAT2, LQOPHACHGOUTPKT jnz use_lastscb;
-
-		/*
-		 * If the hardware has traversed the whole list, NEXTSCB
-		 * will be NULL, CURRSCB and LASTSCB cannot be trusted,
-		 * but MAXCMDCNT is accurate.  If we stop part way through
-		 * the list or only had one command to issue, NEXTSCB[1] is
-		 * not NULL and LASTSCB is the last command to go out.
-		 */
-		cmp	NEXTSCB[1], SCB_LIST_NULL jne use_lastscb;
-
-		/*
-		 * Brute force walk.
-		 */
-		bmov	SCBPTR, WAITING_TID_HEAD, 2;
-		mvi	SEQINTCTL, INTVEC1DSL;
-		mvi	MODE_PTR, MK_MODE(M_CFG, M_CFG);
-		mov	A, MAXCMDCNT;
-		mvi	MODE_PTR, MK_MODE(M_SCSI, M_SCSI);
-		clr	SEQINTCTL;
-find_lastscb_loop:
-		dec	A;
-		test	A, 0xFF jz found_last_sent_scb;
-		bmov	SCBPTR, SCB_NEXT, 2;
-		jmp	find_lastscb_loop;
-use_lastscb:
-		bmov	SCBPTR, LASTSCB, 2;
-found_last_sent_scb:
-		bmov	CURRSCB, SCBPTR, 2;
-curscb_ww_done:
-	} else {
-		/*
-		 * Untested - Verify with Rev B.
-		 */
-		bmov	SCBPTR, CURRSCB, 2;
-	}
-
-	/*
-	 * Requeue any SCBs not sent, to the tail of the waiting Q.
-	 */
-	cmp	SCB_NEXT[1], SCB_LIST_NULL je select_out_list_done;
-
-	/*
-	 * We know that neither the per-TID list nor the list of
-	 * TIDs is empty.  Use this knowledge to our advantage.
-	 */
-	bmov	REG0, SCB_NEXT, 2;
-	bmov	SCBPTR, WAITING_TID_TAIL, 2;
-	bmov	SCB_NEXT2, REG0, 2;
-	bmov	WAITING_TID_TAIL, REG0, 2;
-	jmp	select_out_inc_tid_q;
-
-select_out_list_done:
-	/*
-	 * The whole list made it.  Just clear our TID's tail pointer
-	 * unless we were queued independently due to our need to
-	 * send a message.
-	 */
-	test	SCB_CONTROL, MK_MESSAGE jnz select_out_inc_tid_q;
-	shr	DINDEX, 3, SCB_SCSIID;
-	or	DINDEX, 1;	/* Want only the second byte */
-	mvi	DINDEX[1], ((WAITING_SCB_TAILS) >> 8);
-	mvi	DINDIR, SCB_LIST_NULL;
-select_out_inc_tid_q:
-	bmov	SCBPTR, WAITING_TID_HEAD, 2;
-	bmov	WAITING_TID_HEAD, SCB_NEXT2, 2;
-	cmp	WAITING_TID_HEAD[1], SCB_LIST_NULL jne . + 2;
-	mvi	WAITING_TID_TAIL[1], SCB_LIST_NULL;
-	bmov	SCBPTR, CURRSCB, 2;
-	mvi	CLRSINT0, CLRSELDO;
-	test	LQOSTAT2, LQOPHACHGOUTPKT jnz unexpected_nonpkt_phase;
-	test	LQOSTAT1, LQOPHACHGINPKT jnz unexpected_nonpkt_phase;
-
-	/*
-	 * If this is a packetized connection, return to our
-	 * idle_loop and let our interrupt handler deal with
-	 * any connection setup/teardown issues.  The only
-	 * exceptions are the case of MK_MESSAGE and task management
-	 * SCBs.
-	 */
-	if ((ahd->bugs & AHD_LQO_ATNO_BUG) != 0) {
-		/*
-		 * In the A, the LQO manager transitions to LQOSTOP0 even if
-		 * we have selected out with ATN asserted and the target
-		 * REQs in a non-packet phase.
-		 */
-		test 	SCB_CONTROL, MK_MESSAGE jz select_out_no_message;
-		test	SCSISIGO, ATNO jnz select_out_non_packetized;
-select_out_no_message:
-	}
-	test	LQOSTAT2, LQOSTOP0 jz select_out_non_packetized;
-	test	SCB_TASK_MANAGEMENT, 0xFF jz idle_loop;
-	SET_SEQINTCODE(TASKMGMT_FUNC_COMPLETE)
-	jmp	idle_loop;
-
-select_out_non_packetized:
-	/* Non packetized request. */
-	and     SCSISEQ0, ~ENSELO;
-	if ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0) {
-		/*
-		 * This exposes a window whereby a
-		 * busfree just after a selection will
-		 * be missed, but there is no other safe
-		 * way to enable busfree detection if
-		 * the busfreerev function is broken.
-		 */
-		mvi	CLRSINT1,CLRBUSFREE;
-		or	SIMODE1, ENBUSFREE;
-	}
-	mov	SAVED_SCSIID, SCB_SCSIID;
-	mov	SAVED_LUN, SCB_LUN;
-	mvi	SEQ_FLAGS, NO_CDB_SENT;
-END_CRITICAL;
-	or	SXFRCTL0, SPIOEN;
-
-	/*
-	 * As soon as we get a successful selection, the target
-	 * should go into the message out phase since we have ATN
-	 * asserted.
-	 */
-	mvi	MSG_OUT, MSG_IDENTIFYFLAG;
-
-	/*
-	 * Main loop for information transfer phases.  Wait for the
-	 * target to assert REQ before checking MSG, C/D and I/O for
-	 * the bus phase.
-	 */
-mesgin_phasemis:
-ITloop:
-	call	phase_lock;
-
-	mov	A, LASTPHASE;
-
-	test	A, ~P_DATAIN_DT	jz p_data;
-	cmp	A,P_COMMAND	je p_command;
-	cmp	A,P_MESGOUT	je p_mesgout;
-	cmp	A,P_STATUS	je p_status;
-	cmp	A,P_MESGIN	je p_mesgin;
-
-	SET_SEQINTCODE(BAD_PHASE)
-	jmp	ITloop;			/* Try reading the bus again. */
-
-/*
- * Command phase.  Set up the DMA registers and let 'er rip.
- */
-p_command:
-	test	SEQ_FLAGS, NOT_IDENTIFIED jz p_command_okay;
-	SET_SEQINTCODE(PROTO_VIOLATION)
-p_command_okay:
-	test	MODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1))
-		jnz p_command_allocate_fifo;
-	/*
-	 * Command retry.  Free our current FIFO and
-	 * re-allocate a FIFO so transfer state is
-	 * reset.
-	 */
-SET_SRC_MODE	M_DFF1;
-SET_DST_MODE	M_DFF1;
-	mvi	DFFSXFRCTL, RSTCHN|CLRSHCNT;
-	SET_MODE(M_SCSI, M_SCSI)
-p_command_allocate_fifo:
-	bmov	ALLOCFIFO_SCBPTR, SCBPTR, 2;
-	call	allocate_fifo;
-SET_SRC_MODE	M_DFF1;
-SET_DST_MODE	M_DFF1;
-	add	NONE, -17, SCB_CDB_LEN;
-	jnc	p_command_embedded;
-p_command_from_host:
-	bmov	HADDR[0], SCB_CDB_PTR, 11;
-	mvi	SG_CACHE_PRE, LAST_SEG;
-	mvi	DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN);
-	jmp	p_command_xfer;
-p_command_embedded:
-	bmov	SHCNT[0], SCB_CDB_LEN,  1;
-	bmov	DFDAT, SCB_CDB_STORE, 16; 
-	mvi	DFCNTRL, SCSIEN;
-p_command_xfer:
-	and	SEQ_FLAGS, ~NO_CDB_SENT;
-	test	DFCNTRL, SCSIEN jnz .;
-	/*
-	 * DMA Channel automatically disabled.
-	 * Don't allow a data phase if the command
-	 * was not fully transferred.
-	 */
-	test	SSTAT2, SDONE jnz ITloop;
-	or	SEQ_FLAGS, NO_CDB_SENT;
-	jmp	ITloop;
-
-
-/*
- * Status phase.  Wait for the data byte to appear, then read it
- * and store it into the SCB.
- */
-SET_SRC_MODE	M_SCSI;
-SET_DST_MODE	M_SCSI;
-p_status:
-	test	SEQ_FLAGS,NOT_IDENTIFIED jnz mesgin_proto_violation;
-p_status_okay:
-	mov	SCB_SCSI_STATUS, SCSIDAT;
-	or	SCB_CONTROL, STATUS_RCVD;
-	jmp	ITloop;
-
-/*
- * Message out phase.  If MSG_OUT is MSG_IDENTIFYFLAG, build a full
- * indentify message sequence and send it to the target.  The host may
- * override this behavior by setting the MK_MESSAGE bit in the SCB
- * control byte.  This will cause us to interrupt the host and allow
- * it to handle the message phase completely on its own.  If the bit
- * associated with this target is set, we will also interrupt the host,
- * thereby allowing it to send a message on the next selection regardless
- * of the transaction being sent.
- * 
- * If MSG_OUT is == HOST_MSG, also interrupt the host and take a message.
- * This is done to allow the host to send messages outside of an identify
- * sequence while protecting the seqencer from testing the MK_MESSAGE bit
- * on an SCB that might not be for the current nexus. (For example, a
- * BDR message in responce to a bad reselection would leave us pointed to
- * an SCB that doesn't have anything to do with the current target).
- *
- * Otherwise, treat MSG_OUT as a 1 byte message to send (abort, abort tag,
- * bus device reset).
- *
- * When there are no messages to send, MSG_OUT should be set to MSG_NOOP,
- * in case the target decides to put us in this phase for some strange
- * reason.
- */
-p_mesgout_retry:
-	/* Turn on ATN for the retry */
-	mvi	SCSISIGO, ATNO;
-p_mesgout:
-	mov	SINDEX, MSG_OUT;
-	cmp	SINDEX, MSG_IDENTIFYFLAG jne p_mesgout_from_host;
-	test	SCB_CONTROL,MK_MESSAGE	jnz host_message_loop;
-p_mesgout_identify:
-	or	SINDEX, MSG_IDENTIFYFLAG|DISCENB, SCB_LUN;
-	test	SCB_CONTROL, DISCENB jnz . + 2;
-	and	SINDEX, ~DISCENB;
-/*
- * Send a tag message if TAG_ENB is set in the SCB control block.
- * Use SCB_NONPACKET_TAG as the tag value.
- */
-p_mesgout_tag:
-	test	SCB_CONTROL,TAG_ENB jz  p_mesgout_onebyte;
-	mov	SCSIDAT, SINDEX;	/* Send the identify message */
-	call	phase_lock;
-	cmp	LASTPHASE, P_MESGOUT	jne p_mesgout_done;
-	and	SCSIDAT,TAG_ENB|SCB_TAG_TYPE,SCB_CONTROL;
-	call	phase_lock;
-	cmp	LASTPHASE, P_MESGOUT	jne p_mesgout_done;
-	mov	SCBPTR jmp p_mesgout_onebyte;
-/*
- * Interrupt the driver, and allow it to handle this message
- * phase and any required retries.
- */
-p_mesgout_from_host:
-	cmp	SINDEX, HOST_MSG	jne p_mesgout_onebyte;
-	jmp	host_message_loop;
-
-p_mesgout_onebyte:
-	mvi	CLRSINT1, CLRATNO;
-	mov	SCSIDAT, SINDEX;
-
-/*
- * If the next bus phase after ATN drops is message out, it means
- * that the target is requesting that the last message(s) be resent.
- */
-	call	phase_lock;
-	cmp	LASTPHASE, P_MESGOUT	je p_mesgout_retry;
-
-p_mesgout_done:
-	mvi	CLRSINT1,CLRATNO;	/* Be sure to turn ATNO off */
-	mov	LAST_MSG, MSG_OUT;
-	mvi	MSG_OUT, MSG_NOOP;	/* No message left */
-	jmp	ITloop;
-
-/*
- * Message in phase.  Bytes are read using Automatic PIO mode.
- */
-p_mesgin:
-	/* read the 1st message byte */
-	mvi	ACCUM		call inb_first;
-
-	test	A,MSG_IDENTIFYFLAG	jnz mesgin_identify;
-	cmp	A,MSG_DISCONNECT	je mesgin_disconnect;
-	cmp	A,MSG_SAVEDATAPOINTER	je mesgin_sdptrs;
-	cmp	ALLZEROS,A		je mesgin_complete;
-	cmp	A,MSG_RESTOREPOINTERS	je mesgin_rdptrs;
-	cmp	A,MSG_IGN_WIDE_RESIDUE	je mesgin_ign_wide_residue;
-	cmp	A,MSG_NOOP		je mesgin_done;
-
-/*
- * Pushed message loop to allow the kernel to
- * run it's own message state engine.  To avoid an
- * extra nop instruction after signaling the kernel,
- * we perform the phase_lock before checking to see
- * if we should exit the loop and skip the phase_lock
- * in the ITloop.  Performing back to back phase_locks
- * shouldn't hurt, but why do it twice...
- */
-host_message_loop:
-	call	phase_lock;	/* Benign the first time through. */
-	SET_SEQINTCODE(HOST_MSG_LOOP)
-	cmp	RETURN_1, EXIT_MSG_LOOP	je ITloop;
-	cmp	RETURN_1, CONT_MSG_LOOP_WRITE	jne . + 3;
-	mov	SCSIDAT, RETURN_2;
-	jmp	host_message_loop;
-	/* Must be CONT_MSG_LOOP_READ */
-	mov	NONE, SCSIDAT;	/* ACK Byte */
-	jmp	host_message_loop;
-
-mesgin_ign_wide_residue:
-	mov	SAVED_MODE, MODE_PTR;
-	SET_MODE(M_SCSI, M_SCSI)
-	shr	NEGOADDR, 4, SAVED_SCSIID;
-	mov	A, NEGCONOPTS;
-	RESTORE_MODE(SAVED_MODE)
-	test	A, WIDEXFER jz mesgin_reject;
-	/* Pull the residue byte */
-	mvi	REG0	call inb_next;
-	cmp	REG0, 0x01 jne mesgin_reject;
-	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 2;
-	test	DATA_COUNT_ODD, 0x1	jz mesgin_done;
-	jmp	mesgin_done;
-
-mesgin_proto_violation:
-	SET_SEQINTCODE(PROTO_VIOLATION)
-	jmp	mesgin_done;
-mesgin_reject:
-	mvi	MSG_MESSAGE_REJECT	call mk_mesg;
-mesgin_done:
-	mov	NONE,SCSIDAT;		/*dummy read from latch to ACK*/
-	jmp	ITloop;
-
-#define INDEX_DISC_LIST(scsiid, lun)					\
-	and	A, 0xC0, scsiid;					\
-	or	SCBPTR, A, lun;						\
-	clr	SCBPTR[1];						\
-	and	SINDEX, 0x30, scsiid;					\
-	shr	SINDEX, 3;	/* Multiply by 2 */			\
-	add	SINDEX, (SCB_DISCONNECTED_LISTS & 0xFF);		\
-	mvi	SINDEX[1], ((SCB_DISCONNECTED_LISTS >> 8) & 0xFF)
-
-mesgin_identify:
-	/*
-	 * Determine whether a target is using tagged or non-tagged
-	 * transactions by first looking at the transaction stored in
-	 * the per-device, disconnected array.  If there is no untagged
-	 * transaction for this target, this must be a tagged transaction.
-	 */
-	and	SAVED_LUN, MSG_IDENTIFY_LUNMASK, A;
-	INDEX_DISC_LIST(SAVED_SCSIID, SAVED_LUN);
-	bmov	DINDEX, SINDEX, 2;
-	bmov	REG0, SINDIR, 2;
-	cmp	REG0[1], SCB_LIST_NULL je snoop_tag;
-	/* Untagged.  Clear the busy table entry and setup the SCB. */
-	bmov	DINDIR, ALLONES, 2;
-	bmov	SCBPTR, REG0, 2;
-	jmp	setup_SCB;
-
-/*
- * Here we "snoop" the bus looking for a SIMPLE QUEUE TAG message.
- * If we get one, we use the tag returned to find the proper
- * SCB.  After receiving the tag, look for the SCB at SCB locations tag and
- * tag + 256.
- */
-snoop_tag:
-	if ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {
-		or	SEQ_FLAGS, 0x80;
-	}
-	mov	NONE, SCSIDAT;		/* ACK Identify MSG */
-	call	phase_lock;
-	if ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {
-		or	SEQ_FLAGS, 0x1;
-	}
-	cmp	LASTPHASE, P_MESGIN	jne not_found_ITloop;
-	if ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {
-		or	SEQ_FLAGS, 0x2;
-	}
-	cmp	SCSIBUS, MSG_SIMPLE_Q_TAG jne not_found;
-get_tag:
-	clr	SCBPTR[1];
-	mvi	SCBPTR	call inb_next;	/* tag value */
-verify_scb:
-	test	SCB_CONTROL,DISCONNECTED jz verify_other_scb;
-	mov	A, SAVED_SCSIID;
-	cmp	SCB_SCSIID, A jne verify_other_scb;
-	mov	A, SAVED_LUN;
-	cmp	SCB_LUN, A je setup_SCB_disconnected;
-verify_other_scb:
-	xor	SCBPTR[1], 1;
-	test	SCBPTR[1], 0xFF jnz verify_scb;
-	jmp	not_found;
-
-/*
- * Ensure that the SCB the tag points to is for
- * an SCB transaction to the reconnecting target.
- */
-setup_SCB:
-	if ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {
-		or	SEQ_FLAGS, 0x10;
-	}
-	test	SCB_CONTROL,DISCONNECTED jz not_found;
-setup_SCB_disconnected:
-	and	SCB_CONTROL,~DISCONNECTED;
-	clr	SEQ_FLAGS;	/* make note of IDENTIFY */
-	test	SCB_SGPTR, SG_LIST_NULL jnz . + 3;
-	bmov	ALLOCFIFO_SCBPTR, SCBPTR, 2;
-	call	allocate_fifo;
-	/* See if the host wants to send a message upon reconnection */
-	test	SCB_CONTROL, MK_MESSAGE jz mesgin_done;
-	mvi	HOST_MSG	call mk_mesg;
-	jmp	mesgin_done;
-
-not_found:
-	SET_SEQINTCODE(NO_MATCH)
-	jmp	mesgin_done;
-
-not_found_ITloop:
-	SET_SEQINTCODE(NO_MATCH)
-	jmp	ITloop;
-
-/*
- * We received a "command complete" message.  Put the SCB on the complete
- * queue and trigger a completion interrupt via the idle loop.  Before doing
- * so, check to see if there
- * is a residual or the status byte is something other than STATUS_GOOD (0).
- * In either of these conditions, we upload the SCB back to the host so it can
- * process this information.  In the case of a non zero status byte, we 
- * additionally interrupt the kernel driver synchronously, allowing it to
- * decide if sense should be retrieved.  If the kernel driver wishes to request
- * sense, it will fill the kernel SCB with a request sense command, requeue
- * it to the QINFIFO and tell us not to post to the QOUTFIFO by setting 
- * RETURN_1 to SEND_SENSE.
- */
-mesgin_complete:
-
-	/*
-	 * If ATN is raised, we still want to give the target a message.
-	 * Perhaps there was a parity error on this last message byte.
-	 * Either way, the target should take us to message out phase
-	 * and then attempt to complete the command again.  We should use a
-	 * critical section here to guard against a timeout triggering
-	 * for this command and setting ATN while we are still processing
-	 * the completion.
-	test	SCSISIGI, ATNI jnz mesgin_done;
-	 */
-
-	/*
-	 * If we are identified and have successfully sent the CDB,
-	 * any status will do.  Optimize this fast path.
-	 */
-	test	SCB_CONTROL, STATUS_RCVD jz mesgin_proto_violation;
-	test	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT jz complete_accepted;
-
-	/*
-	 * If the target never sent an identify message but instead went
-	 * to mesgin to give an invalid message, let the host abort us.
-	 */
-	test	SEQ_FLAGS, NOT_IDENTIFIED jnz mesgin_proto_violation;
-
-	/*
-	 * If we recevied good status but never successfully sent the
-	 * cdb, abort the command.
-	 */
-	test	SCB_SCSI_STATUS,0xff	jnz complete_accepted;
-	test	SEQ_FLAGS, NO_CDB_SENT jnz mesgin_proto_violation;
-complete_accepted:
-
-	/*
-	 * See if we attempted to deliver a message but the target ingnored us.
-	 */
-	test	SCB_CONTROL, MK_MESSAGE jz complete_nomsg;
-	SET_SEQINTCODE(MKMSG_FAILED)
-complete_nomsg:
-	call	queue_scb_completion;
-	jmp	await_busfree;
-
-freeze_queue:
-	/* Cancel any pending select-out. */
-	test	SSTAT0, SELDO|SELINGO jnz . + 2;
-	and	SCSISEQ0, ~ENSELO;
-	mov	ACCUM_SAVE, A;
-	clr	A;
-	add	QFREEZE_COUNT, 1;
-	adc	QFREEZE_COUNT[1], A;
-	or	SEQ_FLAGS2, SELECTOUT_QFROZEN;
-	mov	A, ACCUM_SAVE ret;
-
-queue_arg1_scb_completion:
-	SET_MODE(M_SCSI, M_SCSI)
-	bmov	SCBPTR, ARG_1, 2;
-queue_scb_completion:
-	if ((ahd->bugs & AHD_ABORT_LQI_BUG) == 0) {
-		/*
-		 * Set MK_MESSAGE to trigger an abort should this SCB
-		 * be referenced by a target even though it is not currently
-		 * active.
-		 */
-		or	SCB_CONTROL, MK_MESSAGE;
-	}
-	test	SCB_SCSI_STATUS,0xff	jnz bad_status;
-	/*
-	 * Check for residuals
-	 */
-	test	SCB_SGPTR, SG_LIST_NULL jnz complete;	/* No xfer */
-	test	SCB_SGPTR, SG_FULL_RESID jnz upload_scb;/* Never xfered */
-	test	SCB_RESIDUAL_SGPTR, SG_LIST_NULL jz upload_scb;
-complete:
-	bmov	SCB_NEXT_COMPLETE, COMPLETE_SCB_HEAD, 2;
-	bmov	COMPLETE_SCB_HEAD, SCBPTR, 2 ret;
-bad_status:
-	cmp	SCB_SCSI_STATUS, STATUS_PKT_SENSE je upload_scb;
-	call	freeze_queue;
-upload_scb:
-	bmov	SCB_NEXT_COMPLETE, COMPLETE_DMA_SCB_HEAD, 2;
-	bmov	COMPLETE_DMA_SCB_HEAD, SCBPTR, 2;
-	or	SCB_SGPTR, SG_STATUS_VALID ret;
-
-/*
- * Is it a disconnect message?  Set a flag in the SCB to remind us
- * and await the bus going free.  If this is an untagged transaction
- * store the SCB id for it in our untagged target table for lookup on
- * a reselction.
- */
-mesgin_disconnect:
-	/*
-	 * If ATN is raised, we still want to give the target a message.
-	 * Perhaps there was a parity error on this last message byte
-	 * or we want to abort this command.  Either way, the target
-	 * should take us to message out phase and then attempt to
-	 * disconnect again.
-	 * XXX - Wait for more testing.
-	test	SCSISIGI, ATNI jnz mesgin_done;
-	 */
-	test	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT
-		jnz mesgin_proto_violation;
-	or	SCB_CONTROL,DISCONNECTED;
-	test	SCB_CONTROL, TAG_ENB jnz await_busfree;
-queue_disc_scb:
-	bmov	REG0, SCBPTR, 2;
-	INDEX_DISC_LIST(SAVED_SCSIID, SAVED_LUN);
-	bmov	DINDEX, SINDEX, 2;
-	bmov	DINDIR, REG0, 2;
-	bmov	SCBPTR, REG0, 2;
-	/* FALLTHROUGH */
-await_busfree:
-	and	SIMODE1, ~ENBUSFREE;
-	if ((ahd->bugs & AHD_BUSFREEREV_BUG) == 0) {
-		/*
-		 * In the BUSFREEREV_BUG case, the
-		 * busfree status was cleared at the
-		 * beginning of the connection.
-		 */
-		mvi	CLRSINT1,CLRBUSFREE;
-	}
-	mov	NONE, SCSIDAT;		/* Ack the last byte */
-	test	MODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1))
-		jnz await_busfree_not_m_dff;
-SET_SRC_MODE	M_DFF1;
-SET_DST_MODE	M_DFF1;
-await_busfree_clrchn:
-	mvi	DFFSXFRCTL, CLRCHN;
-await_busfree_not_m_dff:
-	call	clear_target_state;
-	test	SSTAT1,REQINIT|BUSFREE	jz .;
-	test	SSTAT1, BUSFREE jnz idle_loop;
-	SET_SEQINTCODE(MISSED_BUSFREE)
-
-
-/*
- * Save data pointers message:
- * Copying RAM values back to SCB, for Save Data Pointers message, but
- * only if we've actually been into a data phase to change them.  This
- * protects against bogus data in scratch ram and the residual counts
- * since they are only initialized when we go into data_in or data_out.
- * Ack the message as soon as possible.
- */
-SET_SRC_MODE	M_DFF1;
-SET_DST_MODE	M_DFF1;
-mesgin_sdptrs:
-	mov	NONE,SCSIDAT;		/*dummy read from latch to ACK*/
-	test	SEQ_FLAGS, DPHASE	jz ITloop;
-	call	save_pointers;
-	jmp	ITloop;
-
-save_pointers:
-	/*
-	 * If we are asked to save our position at the end of the
-	 * transfer, just mark us at the end rather than perform a
-	 * full save.
-	 */
-	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz save_pointers_full;
-	or	SCB_SGPTR, SG_LIST_NULL ret;
-
-save_pointers_full:
-	/*
-	 * The SCB_DATAPTR becomes the current SHADDR.
-	 * All other information comes directly from our residual
-	 * state.
-	 */
-	bmov	SCB_DATAPTR, SHADDR, 8;
-	bmov	SCB_DATACNT, SCB_RESIDUAL_DATACNT, 8 ret;
-
-/*
- * Restore pointers message?  Data pointers are recopied from the
- * SCB anytime we enter a data phase for the first time, so all
- * we need to do is clear the DPHASE flag and let the data phase
- * code do the rest.  We also reset/reallocate the FIFO to make
- * sure we have a clean start for the next data or command phase.
- */
-mesgin_rdptrs:
-	and	SEQ_FLAGS, ~DPHASE;
-	test	MODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1)) jnz msgin_rdptrs_get_fifo;
-	mvi	DFFSXFRCTL, RSTCHN|CLRSHCNT;
-	SET_MODE(M_SCSI, M_SCSI)
-msgin_rdptrs_get_fifo:
-	call	allocate_fifo;
-	jmp	mesgin_done;
-
-clear_target_state:
-	mvi	LASTPHASE, P_BUSFREE;
-	/* clear target specific flags */
-	mvi	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT ret;
-
-phase_lock:     
-	test	SCSIPHASE, 0xFF jz .;
-	test	SSTAT1, SCSIPERR jnz phase_lock;
-phase_lock_latch_phase:
-	and	LASTPHASE, PHASE_MASK, SCSISIGI ret;
-
-/*
- * Functions to read data in Automatic PIO mode.
- *
- * An ACK is not sent on input from the target until SCSIDATL is read from.
- * So we wait until SCSIDATL is latched (the usual way), then read the data
- * byte directly off the bus using SCSIBUSL.  When we have pulled the ATN
- * line, or we just want to acknowledge the byte, then we do a dummy read
- * from SCISDATL.  The SCSI spec guarantees that the target will hold the
- * data byte on the bus until we send our ACK.
- *
- * The assumption here is that these are called in a particular sequence,
- * and that REQ is already set when inb_first is called.  inb_{first,next}
- * use the same calling convention as inb.
- */
-inb_next:
-	mov	NONE,SCSIDAT;		/*dummy read from latch to ACK*/
-inb_next_wait:
-	/*
-	 * If there is a parity error, wait for the kernel to
-	 * see the interrupt and prepare our message response
-	 * before continuing.
-	 */
-	test	SCSIPHASE, 0xFF jz .;
-	test	SSTAT1, SCSIPERR jnz inb_next_wait;
-inb_next_check_phase:
-	and	LASTPHASE, PHASE_MASK, SCSISIGI;
-	cmp	LASTPHASE, P_MESGIN jne mesgin_phasemis;
-inb_first:
-	clr	DINDEX[1];
-	mov	DINDEX,SINDEX;
-	mov	DINDIR,SCSIBUS	ret;		/*read byte directly from bus*/
-inb_last:
-	mov	NONE,SCSIDAT ret;		/*dummy read from latch to ACK*/
-
-mk_mesg:
-	mvi	SCSISIGO, ATNO;
-	mov	MSG_OUT,SINDEX ret;
-
-SET_SRC_MODE	M_DFF1;
-SET_DST_MODE	M_DFF1;
-disable_ccsgen:
-	test	SG_STATE, FETCH_INPROG jz disable_ccsgen_fetch_done;
-	clr	CCSGCTL;
-disable_ccsgen_fetch_done:
-	clr	SG_STATE ret;
-
-service_fifo:
-	/*
-	 * Do we have any prefetch left???
-	 */
-	test	SG_STATE, SEGS_AVAIL jnz idle_sg_avail;
-
-	/*
-	 * Can this FIFO have access to the S/G cache yet?
-	 */
-	test	CCSGCTL, SG_CACHE_AVAIL jz return;
-
-	/* Did we just finish fetching segs? */
-	test	CCSGCTL, CCSGDONE jnz idle_sgfetch_complete;
-
-	/* Are we actively fetching segments? */
-	test	CCSGCTL, CCSGENACK jnz return;
-
-	/*
-	 * We fetch a "cacheline aligned" and sized amount of data
-	 * so we don't end up referencing a non-existant page.
-	 * Cacheline aligned is in quotes because the kernel will
-	 * set the prefetch amount to a reasonable level if the
-	 * cacheline size is unknown.
-	 */
-	bmov	SGHADDR, SCB_RESIDUAL_SGPTR, 4;
-	mvi	SGHCNT, SG_PREFETCH_CNT;
-	if ((ahd->bugs & AHD_REG_SLOW_SETTLE_BUG) != 0) {
-		/*
-		 * Need two instruction between "touches" of SGHADDR.
-		 */
-		nop;
-	}
-	and	SGHADDR[0], SG_PREFETCH_ALIGN_MASK, SCB_RESIDUAL_SGPTR;
-	mvi	CCSGCTL, CCSGEN|SG_CACHE_AVAIL|CCSGRESET;
-	or	SG_STATE, FETCH_INPROG ret;
-idle_sgfetch_complete:
-	/*
-	 * Guard against SG_CACHE_AVAIL activating during sg fetch
-	 * request in the other FIFO.
-	 */
-	test	SG_STATE, FETCH_INPROG jz return;
-	clr	CCSGCTL;
-	and	CCSGADDR, SG_PREFETCH_ADDR_MASK, SCB_RESIDUAL_SGPTR;
-	mvi	SG_STATE, SEGS_AVAIL|LOADING_NEEDED;
-idle_sg_avail:
-	/* Does the hardware have space for another SG entry? */
-	test	DFSTATUS, PRELOAD_AVAIL jz return;
-	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
-		bmov	HADDR, CCSGRAM, 8;
-	} else {
-		bmov 	HADDR, CCSGRAM, 4;
-	}
-	bmov	HCNT, CCSGRAM, 3;
-	test	HCNT[0], 0x1 jz . + 2;
-	xor	DATA_COUNT_ODD, 0x1;
-	bmov	SCB_RESIDUAL_DATACNT[3], CCSGRAM, 1;
-	if ((ahd->flags & AHD_39BIT_ADDRESSING) != 0) {
-		and	HADDR[4], SG_HIGH_ADDR_BITS, SCB_RESIDUAL_DATACNT[3];
-	}
-	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
-		/* Skip 4 bytes of pad. */
-		add	CCSGADDR, 4;
-	}
-sg_advance:
-	clr	A;			/* add sizeof(struct scatter) */
-	add	SCB_RESIDUAL_SGPTR[0],SG_SIZEOF;
-	adc	SCB_RESIDUAL_SGPTR[1],A;
-	adc	SCB_RESIDUAL_SGPTR[2],A;
-	adc	SCB_RESIDUAL_SGPTR[3],A;
-	mov	SINDEX, SCB_RESIDUAL_SGPTR[0];
-	test	DATA_COUNT_ODD, 0x1 jz . + 2;
-	or	SINDEX, ODD_SEG;
-	test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 3;
-	or	SINDEX, LAST_SEG;
-	clr	SG_STATE;
-	mov	SG_CACHE_PRE, SINDEX;
-	/*
-	 * Load the segment.  Or in HDMAEN here too
-	 * just in case HDMAENACK has not come true
-	 * by the time this segment is loaded.  If
-	 * HDMAENACK is not true, this or will disable
-	 * HDMAEN mid-transfer.  We do not want to simply
-	 * mvi our original settings as SCSIEN automatically
-	 * de-asserts and we don't want to accidentally
-	 * re-enable it.
-	 */
-	if ((ahd->features & AHD_NEW_DFCNTRL_OPTS) != 0) {
-		/*
-		 * Use SCSIENWRDIS so that SCSIEN is never
-		 * modified by this operation.
-		 */
-		or	DFCNTRL, PRELOADEN|SCSIENWRDIS|HDMAEN;
-	} else {
-		or	DFCNTRL, PRELOADEN|HDMAEN;
-	}
-	/*
-	 * Do we have another segment in the cache?
-	 */
-	add	NONE, SG_PREFETCH_CNT_LIMIT, CCSGADDR;
-	jnc	return;
-	and	SG_STATE, ~SEGS_AVAIL ret;
-
-/*
- * Initialize the DMA address and counter from the SCB.
- */
-load_first_seg:
-	bmov	HADDR, SCB_DATAPTR, 11;
-	and	DATA_COUNT_ODD, 0x1, SCB_DATACNT[0];
-	and	REG_ISR, ~SG_FULL_RESID, SCB_SGPTR[0];
-	test	SCB_DATACNT[3], SG_LAST_SEG jz . + 2;
-	or	REG_ISR, LAST_SEG;
-	test	DATA_COUNT_ODD, 0x1 jz . + 2;
-	or	REG_ISR, ODD_SEG;
-	mov	SG_CACHE_PRE, REG_ISR;
-	mvi	DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN);
-	/*
-	 * Since we've are entering a data phase, we will
-	 * rely on the SCB_RESID* fields.  Initialize the
-	 * residual and clear the full residual flag.
-	 */
-	and	SCB_SGPTR[0], ~SG_FULL_RESID;
-	bmov	SCB_RESIDUAL_DATACNT[3], SCB_DATACNT[3], 5;
-	/* If we need more S/G elements, tell the idle loop */
-	test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jnz . + 2;
-	mvi	SG_STATE, LOADING_NEEDED ret;
-	clr	SG_STATE ret;
-
-p_data_handle_xfer:
-	call	setjmp_setscb;
-	test	SG_STATE, LOADING_NEEDED jnz service_fifo;
-p_data_clear_handler:
-	or	LONGJMP_ADDR[1], INVALID_ADDR ret;
-
-p_data:
-	test	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT	jz p_data_allowed;
-	SET_SEQINTCODE(PROTO_VIOLATION)
-p_data_allowed:
- 
-	test	SEQ_FLAGS, DPHASE	jz data_phase_initialize;
-
-	/*
-	 * If we re-enter the data phase after going through another
-	 * phase, our transfer location has almost certainly been
-	 * corrupted by the interveining, non-data, transfers.  Ask
-	 * the host driver to fix us up based on the transfer residual
-	 * unless we already know that we should be bitbucketing.
-	 */
-	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jnz p_data_bitbucket;
-	SET_SEQINTCODE(PDATA_REINIT)
-	jmp	data_phase_inbounds;
-
-p_data_bitbucket:
-	/*
-	 * Turn on `Bit Bucket' mode, wait until the target takes
-	 * us to another phase, and then notify the host.
-	 */
-	mov	SAVED_MODE, MODE_PTR;
-	test	MODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1))
-		jnz bitbucket_not_m_dff;
-	/*
-	 * Ensure that any FIFO contents are cleared out and the
-	 * FIFO free'd prior to starting the BITBUCKET.  BITBUCKET
-	 * doesn't discard data already in the FIFO.
-	 */
-	mvi	DFFSXFRCTL, RSTCHN|CLRSHCNT;
-	SET_MODE(M_SCSI, M_SCSI)
-bitbucket_not_m_dff:
-	or	SXFRCTL1,BITBUCKET;
-	/* Wait for non-data phase. */
-	test	SCSIPHASE, ~DATA_PHASE_MASK jz .;
-	and	SXFRCTL1, ~BITBUCKET;
-	RESTORE_MODE(SAVED_MODE)
-SET_SRC_MODE	M_DFF1;
-SET_DST_MODE	M_DFF1;
-	SET_SEQINTCODE(DATA_OVERRUN)
-	jmp	ITloop;
-
-data_phase_initialize:
-	test	SCB_SGPTR[0], SG_LIST_NULL jnz p_data_bitbucket;
-	call	load_first_seg;
-data_phase_inbounds:
-	/* We have seen a data phase at least once. */
-	or	SEQ_FLAGS, DPHASE;
-	mov	SAVED_MODE, MODE_PTR;
-	test	SG_STATE, LOADING_NEEDED jz data_group_dma_loop;
-	call	p_data_handle_xfer;
-data_group_dma_loop:
-	/*
-	 * The transfer is complete if either the last segment
-	 * completes or the target changes phase.  Both conditions
-	 * will clear SCSIEN.
-	 */
-	call	idle_loop_service_fifos;
-	call	idle_loop_cchan;
-	call	idle_loop_gsfifo;
-	RESTORE_MODE(SAVED_MODE)
-	test	DFCNTRL, SCSIEN jnz data_group_dma_loop;
-
-data_group_dmafinish:
-	/*
-	 * The transfer has terminated either due to a phase
-	 * change, and/or the completion of the last segment.
-	 * We have two goals here.  Do as much other work
-	 * as possible while the data fifo drains on a read
-	 * and respond as quickly as possible to the standard
-	 * messages (save data pointers/disconnect and command
-	 * complete) that usually follow a data phase.
-	 */
-	call	calc_residual;
-
-	/*
-	 * Go ahead and shut down the DMA engine now.
-	 */
-	test	DFCNTRL, DIRECTION jnz data_phase_finish;
-data_group_fifoflush:
-	if ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0) {
-		or	DFCNTRL, FIFOFLUSH;
-	}
-	/*
-	 * We have enabled the auto-ack feature.  This means
-	 * that the controller may have already transferred
-	 * some overrun bytes into the data FIFO and acked them
-	 * on the bus.  The only way to detect this situation is
-	 * to wait for LAST_SEG_DONE to come true on a completed
-	 * transfer and then test to see if the data FIFO is
-	 * non-empty.  We know there is more data yet to transfer
-	 * if SG_LIST_NULL is not yet set, thus there cannot be
-	 * an overrun.
-	 */
-	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz data_phase_finish;
-	test	SG_CACHE_SHADOW, LAST_SEG_DONE jz .;
-	test	DFSTATUS, FIFOEMP jnz data_phase_finish;
-	/* Overrun */
-	jmp	p_data;
-data_phase_finish:
-	/*
-	 * If the target has left us in data phase, loop through
-	 * the dma code again.  We will only loop if there is a
-	 * data overrun.  
-	 */
-	if ((ahd->flags & AHD_TARGETROLE) != 0) {
-		test	SSTAT0, TARGET jnz data_phase_done;
-	}
-	if ((ahd->flags & AHD_INITIATORROLE) != 0) {
-		test	SSTAT1, REQINIT jz .;
-		test	SCSIPHASE, DATA_PHASE_MASK jnz p_data;
-	}
-
-data_phase_done:
-	/* Kill off any pending prefetch */
-	call	disable_ccsgen;
-	or 	LONGJMP_ADDR[1], INVALID_ADDR;
-
-	if ((ahd->flags & AHD_TARGETROLE) != 0) {
-		test	SEQ_FLAGS, DPHASE_PENDING jz ITloop;
-		/*
-		and	SEQ_FLAGS, ~DPHASE_PENDING;
-		 * For data-in phases, wait for any pending acks from the
-		 * initiator before changing phase.  We only need to
-		 * send Ignore Wide Residue messages for data-in phases.
-		test	DFCNTRL, DIRECTION jz target_ITloop;
-		test	SSTAT1, REQINIT	jnz .;
-		test	DATA_COUNT_ODD, 0x1 jz target_ITloop;
-		SET_MODE(M_SCSI, M_SCSI)
-		test	NEGCONOPTS, WIDEXFER jz target_ITloop;
-		 */
-		/*
-		 * Issue an Ignore Wide Residue Message.
-		mvi	P_MESGIN|BSYO call change_phase;
-		mvi	MSG_IGN_WIDE_RESIDUE call target_outb;
-		mvi	1 call target_outb;
-		jmp	target_ITloop;
-		 */
-	} else {
-		jmp	ITloop;
-	}
-
-/*
- * We assume that, even though data may still be
- * transferring to the host, that the SCSI side of
- * the DMA engine is now in a static state.  This
- * allows us to update our notion of where we are
- * in this transfer.
- *
- * If, by chance, we stopped before being able
- * to fetch additional segments for this transfer,
- * yet the last S/G was completely exhausted,
- * call our idle loop until it is able to load
- * another segment.  This will allow us to immediately
- * pickup on the next segment on the next data phase.
- *
- * If we happened to stop on the last segment, then
- * our residual information is still correct from
- * the idle loop and there is no need to perform
- * any fixups.
- */
-calc_residual:
-	test	SG_CACHE_SHADOW, LAST_SEG jz residual_before_last_seg;
-	/* Record if we've consumed all S/G entries */
-	test	MDFFSTAT, SHVALID	jz . + 2;
-	bmov	SCB_RESIDUAL_DATACNT, SHCNT, 3 ret;
-	or	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL ret;
-residual_before_last_seg:
-	test    MDFFSTAT, SHVALID	jnz sgptr_fixup;
-	/*
-	 * Can never happen from an interrupt as the packetized
-	 * hardware will only interrupt us once SHVALID or
-	 * LAST_SEG_DONE.
-	 */
-	call	idle_loop_service_fifos;
-	RESTORE_MODE(SAVED_MODE)
-	jmp	calc_residual;
-
-sgptr_fixup:
-	/*
-	 * Fixup the residual next S/G pointer.  The S/G preload
-	 * feature of the chip allows us to load two elements
-	 * in addition to the currently active element.  We
-	 * store the bottom byte of the next S/G pointer in
-	 * the SG_CACHE_PTR register so we can restore the
-	 * correct value when the DMA completes.  If the next
-	 * sg ptr value has advanced to the point where higher
-	 * bytes in the address have been affected, fix them
-	 * too.
-	 */
-	test	SG_CACHE_SHADOW, 0x80 jz sgptr_fixup_done;
-	test	SCB_RESIDUAL_SGPTR[0], 0x80 jnz sgptr_fixup_done;
-	add	SCB_RESIDUAL_SGPTR[1], -1;
-	adc	SCB_RESIDUAL_SGPTR[2], -1; 
-	adc	SCB_RESIDUAL_SGPTR[3], -1;
-sgptr_fixup_done:
-	and	SCB_RESIDUAL_SGPTR[0], SG_ADDR_MASK, SG_CACHE_SHADOW;
-	clr	DATA_COUNT_ODD;
-	test	SG_CACHE_SHADOW, ODD_SEG jz . + 2;
-	or	DATA_COUNT_ODD, 0x1;
-	clr	SCB_RESIDUAL_DATACNT[3]; /* We are not the last seg */
-	bmov	SCB_RESIDUAL_DATACNT, SHCNT, 3 ret;
-
-export timer_isr:
-	call	issue_cmdcmplt;
-	mvi	CLRSEQINTSTAT, CLRSEQ_SWTMRTO;
-	if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {
-		/*
-		 * In H2A4, the mode pointer is not saved
-		 * for intvec2, but is restored on iret.
-		 * This can lead to the restoration of a
-		 * bogus mode ptr.  Manually clear the
-		 * intmask bits and do a normal return
-		 * to compensate.
-		 */
-		and	SEQINTCTL, ~(INTMASK2|INTMASK1) ret;
-	} else {
-		or	SEQINTCTL, IRET ret;
-	}
-
-export seq_isr:
-	nop;	/* Jumps in the first ISR instruction fail on Rev A. */
-	test	SEQINTSRC, CFG4DATA	jnz cfg4data_intr;
-	test	SEQINTSRC, CFG4ISTAT	jnz cfg4istat_intr;
-	test	SEQINTSRC, SAVEPTRS	jnz saveptr_intr;
-	test	SEQINTSRC, CFG4ICMD	jnz cfg4icmd_intr;
-	SET_SEQINTCODE(INVALID_SEQINT)
-
-/*
- * There are two types of save pointers interrupts:
- * The first is a snapshot save pointers where the current FIFO is not
- * active and contains a snapshot of the current poniter information.
- * This happens between packets in a stream for a single L_Q.  Since we
- * are not performing a pointer save, we can safely clear the channel
- * so it can be used for other transactions.
- *
- * The second case is a save pointers on an active FIFO which occurs
- * if the target changes to a new L_Q or busfrees/QAS' and the transfer
- * has a residual.  This should occur coincident with a ctxtdone.  We
- * disable the interrupt and allow our active routine to handle the
- * save.
- */
-saveptr_intr:
-	test	DFCNTRL, HDMAENACK jz snapshot_saveptr;
-	and	SEQIMODE, ~ENSAVEPTRS;
-	or	SEQINTCTL, IRET ret;
-snapshot_saveptr:
-	mvi	DFFSXFRCTL, CLRCHN;
-	or	SEQINTCTL, IRET ret;
-
-cfg4data_intr:
-	test	SCB_SGPTR[0], SG_LIST_NULL jnz pkt_handle_overrun;
-	call	load_first_seg;
-	call	pkt_handle_xfer;
-	or	SEQINTCTL, IRET ret;
-
-cfg4istat_intr:
-	call	freeze_queue;
-	add	NONE, -13, SCB_CDB_LEN;
-	jnc	cfg4istat_have_sense_addr;
-	test	SCB_CDB_LEN, SCB_CDB_LEN_PTR jnz cfg4istat_have_sense_addr;
-	/*
-	 * Host sets up address/count and enables transfer.
-	 */
-	SET_SEQINTCODE(CFG4ISTAT_INTR)
-	jmp	cfg4istat_setup_handler;
-cfg4istat_have_sense_addr:
-	bmov	HADDR, SCB_SENSE_BUSADDR, 4;
-	mvi	HCNT[1], (AHD_SENSE_BUFSIZE >> 8);
-	mvi	SG_CACHE_PRE, LAST_SEG;
-	mvi	DFCNTRL, PRELOADEN|SCSIEN|HDMAEN;
-cfg4istat_setup_handler:
-	/*
-	 * Status pkt is transferring to host.
-	 * Wait in idle loop for transfer to complete.
-	 * If a command completed before an attempted
-	 * task management function completed, notify the host.
-	 */
-	test	SCB_TASK_MANAGEMENT, 0xFF jz cfg4istat_no_taskmgmt_func;
-	SET_SEQINTCODE(TASKMGMT_CMD_CMPLT_OKAY)
-cfg4istat_no_taskmgmt_func:
-	call	pkt_handle_status;
-	or	SEQINTCTL, IRET ret;
-
-/*
- * See if the target has gone on in this context creating an
- * overrun condition.  For the write case, the hardware cannot
- * ack bytes until data are provided.  So, if the target begins
- * another  packet without changing contexts, implying we are
- * not sitting on a packet boundary, we are in an overrun
- * situation.  For the read case, the hardware will continue to
- * ack bytes into the FIFO, and may even ack the last overrun packet
- * into the FIFO.   If the FIFO should become non-empty, we are in
- * a read overrun case.
- */
-#define check_overrun							\
-	/* Not on a packet boundary. */					\
-	test 	MDFFSTAT, DLZERO jz pkt_handle_overrun;			\
-	test	DFSTATUS, FIFOEMP jz pkt_handle_overrun
-
-pkt_handle_xfer:
-	bmov	LONGJMP_SCB, SCBPTR, 2;
-	test	SG_STATE, LOADING_NEEDED jz pkt_last_seg;
-	call	setjmp;
-	test	SEQINTSRC, SAVEPTRS jnz pkt_saveptrs;
-	test	SCSIPHASE, ~DATA_PHASE_MASK jz . + 2;
-	test	SCSISIGO, ATNO jnz . + 2;
-	test	SSTAT2, NONPACKREQ jz pkt_service_fifo;
-	/*
-	 * Defer handling of this NONPACKREQ until we
-	 * can be sure it pertains to this FIFO.  SAVEPTRS
-	 * will not be asserted if the NONPACKREQ is for us,
-	 * so we must simulate it if shaddow is valid.  If
-	 * shaddow is not valid, keep running this FIFO until we
-	 * have satisfied the transfer by loading segments and
-	 * waiting for either shaddow valid or last_seg_done.
-	 */
-	test	MDFFSTAT, SHVALID jnz pkt_saveptrs;
-pkt_service_fifo:
-	test	SG_STATE, LOADING_NEEDED jnz service_fifo;
-pkt_last_seg:
-	call	setjmp;
-	test	SEQINTSRC, SAVEPTRS jnz pkt_saveptrs;
-	test	SG_CACHE_SHADOW, LAST_SEG_DONE jnz last_pkt_done;
-	test	SCSIPHASE, ~DATA_PHASE_MASK jz . + 2;
-	test	SCSISIGO, ATNO jnz . + 2;
-	test	SSTAT2, NONPACKREQ jz return;
-	test	MDFFSTAT, SHVALID jz return;
-	/* FALLTHROUGH */
-
-/*
- * Either a SAVEPTRS interrupt condition is pending for this FIFO
- * or we have a pending nonpackreq for this FIFO.  We differentiate
- * between the two by capturing the state of the SAVEPTRS interrupt
- * prior to clearing this status and executing the common code for
- * these two cases.
- */
-pkt_saveptrs:
-BEGIN_CRITICAL;
-	if ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0) {
-		or	DFCNTRL, FIFOFLUSH;
-	}
-	mov	REG0, SEQINTSRC;
-	call	calc_residual;
-	call	save_pointers;
-	mvi	CLRSEQINTSRC, CLRSAVEPTRS;
-	call	disable_ccsgen;
-	or	SEQIMODE, ENSAVEPTRS;
-	test	DFCNTRL, DIRECTION jnz pkt_saveptrs_check_status;
-	test	DFSTATUS, FIFOEMP jnz pkt_saveptrs_check_status;
-	/*
-	 * Keep a handler around for this FIFO until it drains
-	 * to the host to guarantee that we don't complete the
-	 * command to the host before the data arrives.
-	 */
-pkt_saveptrs_wait_fifoemp:
-	call	setjmp;
-	test	DFSTATUS, FIFOEMP jz return;
-pkt_saveptrs_check_status:
-	or	LONGJMP_ADDR[1], INVALID_ADDR;
-	test	REG0, SAVEPTRS jz unexpected_nonpkt_phase;
-	test	SCB_CONTROL, STATUS_RCVD jz pkt_saveptrs_clrchn;
-	jmp	last_pkt_complete;
-pkt_saveptrs_clrchn:
-	mvi	DFFSXFRCTL, CLRCHN ret;
-END_CRITICAL;
-
-last_pkt_done:
-BEGIN_CRITICAL;
-	if ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0) {
-		or	DFCNTRL, FIFOFLUSH;
-	}
-	test	SCB_CONTROL, STATUS_RCVD jz wait_pkt_end;
-	check_overrun;
-	or	SCB_SGPTR, SG_LIST_NULL;
-	/*
-	 * It is safe to skip the other FIFO check since
-	 * we defer CLRCHN on SAVEPTRS until all data in
-	 * the FIFO are seen by the host and a CFG4DATA
-	 * in this FIFO for the same context is held off
-	 * by hardware.
-	 */
-last_pkt_queue_scb:
-	or	LONGJMP_ADDR[1], INVALID_ADDR;
-	bmov	ARG_1, SCBPTR, 2;
-	mvi	DFFSXFRCTL, CLRCHN;
-	jmp	queue_arg1_scb_completion;
-
-last_pkt_complete:
-	bmov	ARG_1, SCBPTR, 2;
-	mvi	DFFSXFRCTL, CLRCHN;
-check_other_fifo:
-	clc;
-	TOGGLE_DFF_MODE
-	call	check_fifo;
-	jnc	queue_arg1_scb_completion;
-return:
-	ret;
-
-wait_pkt_end:
-	call	setjmp;
-END_CRITICAL;
-wait_pkt_end_loop:
-	test	SEQINTSRC, CTXTDONE jnz pkt_end;
-	check_overrun;
-	test	SSTAT2, NONPACKREQ jz return;
-	test	SEQINTSRC, CTXTDONE jz unexpected_nonpkt_phase;
-pkt_end:
-BEGIN_CRITICAL;
-	check_overrun;
-	or	LONGJMP_ADDR[1], INVALID_ADDR;
-	or	SCB_SGPTR, SG_LIST_NULL;
-	test	SCB_CONTROL, STATUS_RCVD jnz last_pkt_complete;
-	mvi	DFFSXFRCTL, CLRCHN ret;
-END_CRITICAL;
-
-check_status_overrun:
-	test	SHCNT[2], 0xFF jz status_IU_done;
-	SET_SEQINTCODE(STATUS_OVERRUN)
-	jmp	status_IU_done;
-pkt_handle_status:
-	call	setjmp_setscb;
-	test	MDFFSTAT, LASTSDONE jnz check_status_overrun;
-	test	SEQINTSRC, CTXTDONE jz return;
-status_IU_done:
-BEGIN_CRITICAL;
-	if ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0) {
-		or	DFCNTRL, FIFOFLUSH;
-	}
-	or	LONGJMP_ADDR[1], INVALID_ADDR;
-	mvi	SCB_SCSI_STATUS, STATUS_PKT_SENSE;
-	or	SCB_CONTROL, STATUS_RCVD;
-	jmp	last_pkt_complete;
-END_CRITICAL;
-
-SET_SRC_MODE	M_DFF0;
-SET_DST_MODE	M_DFF0;
-BEGIN_CRITICAL;
-check_fifo:
-	test	LONGJMP_ADDR[1], INVALID_ADDR jnz return;
-	mov	A, ARG_2;
-	cmp	LONGJMP_SCB[1], A	jne return;
-	mov	A, ARG_1;
-	cmp	LONGJMP_SCB[0], A	jne return;
-	stc	ret;
-END_CRITICAL;
-
-/*
- * Nonpackreq is a polled status.  It can come true in three situations:
- * we have received an L_Q, we have sent one or more L_Qs, or there is no
- * L_Q context associated with this REQ (REQ occurs immediately after a
- * (re)selection).  Routines that know that the context responsible for this
- * nonpackreq call directly into unexpected_nonpkt_phase.  In the case of the
- * top level idle loop, we exhaust all active contexts prior to determining that
- * we simply do not have the full I_T_L_Q for this phase.
- */
-unexpected_nonpkt_phase_find_ctxt:
-	/*
-	 * This nonpackreq is most likely associated with one of the tags
-	 * in a FIFO or an outgoing LQ.  Only treat it as an I_T only
-	 * nonpackreq if we've cleared out the FIFOs and handled any
-	 * pending SELDO.
-	 */
-SET_SRC_MODE	M_SCSI;
-SET_DST_MODE	M_SCSI;
-	and	A, FIFO1FREE|FIFO0FREE, DFFSTAT;
-	cmp	A, FIFO1FREE|FIFO0FREE jne return;
-	test	SSTAT0, SELDO jnz return;
-	mvi	SCBPTR[1], SCB_LIST_NULL;
-unexpected_nonpkt_phase:
-	test	MODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1)) jnz . + 3;
-SET_SRC_MODE	M_DFF0;
-SET_DST_MODE	M_DFF0;
-	or	LONGJMP_ADDR[1], INVALID_ADDR;
-	mvi	DFFSXFRCTL, CLRCHN;
-	mvi	CLRSINT2, CLRNONPACKREQ;
-	test	SCSIPHASE, ~(MSG_IN_PHASE|MSG_OUT_PHASE) jnz illegal_phase;
-	SET_SEQINTCODE(ENTERING_NONPACK)
-	jmp	ITloop;
-
-illegal_phase:
-	SET_SEQINTCODE(ILLEGAL_PHASE)
-	jmp	ITloop;
-
-/*
- * We have entered an overrun situation.  If we have working
- * BITBUCKET, flip that on and let the hardware eat any overrun
- * data.  Otherwise use an overrun buffer in the host to simulate
- * BITBUCKET.
- */
-pkt_handle_overrun:
-	SET_SEQINTCODE(CFG4OVERRUN)
-	call	freeze_queue;
-	if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) == 0) {
-		or	DFFSXFRCTL, DFFBITBUCKET;
-SET_SRC_MODE	M_DFF1;
-SET_DST_MODE	M_DFF1;
-	} else {
-		call	load_overrun_buf;
-		mvi	DFCNTRL, (HDMAEN|SCSIEN|PRELOADEN);
-	}
-	call	setjmp;
-	if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0) {
-		test	DFSTATUS, PRELOAD_AVAIL jz overrun_load_done;
-		call	load_overrun_buf;
-		or	DFCNTRL, PRELOADEN;
-overrun_load_done:
-		test	SEQINTSRC, CTXTDONE jnz pkt_overrun_end;
-	} else {
-		test	DFFSXFRCTL, DFFBITBUCKET jz pkt_overrun_end;
-	}
-	test	SSTAT2, NONPACKREQ jz return;
-pkt_overrun_end:
-	or	SCB_RESIDUAL_SGPTR, SG_OVERRUN_RESID;
-	test	SEQINTSRC, CTXTDONE jz unexpected_nonpkt_phase;
-	test	SCB_CONTROL, STATUS_RCVD jnz last_pkt_queue_scb;
-	mvi	DFFSXFRCTL, CLRCHN ret;
-
-if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0) {
-load_overrun_buf:
-	/*
-	 * Load a dummy segment if preload space is available.
-	 */
-	mov 	HADDR[0], SHARED_DATA_ADDR;
-	add	HADDR[1], PKT_OVERRUN_BUFOFFSET, SHARED_DATA_ADDR[1];
-	mov	ACCUM_SAVE, A;
-	clr	A;
-	adc	HADDR[2], A, SHARED_DATA_ADDR[2];
-	adc	HADDR[3], A, SHARED_DATA_ADDR[3];
-	mov	A, ACCUM_SAVE;
-	bmov	HADDR[4], ALLZEROS, 4;
-	/* PKT_OVERRUN_BUFSIZE is a multiple of 256 */
-	clr	HCNT[0];
-	mvi	HCNT[1], ((PKT_OVERRUN_BUFSIZE >> 8) & 0xFF);
-	clr	HCNT[2] ret;
-}
-
-cfg4icmd_intr:
diff -urNp linux-5720/drivers/scsi/aic79xx/aic79xx_core.c linux-5730/drivers/scsi/aic79xx/aic79xx_core.c
--- linux-5720/drivers/scsi/aic79xx/aic79xx_core.c
+++ linux-5730/drivers/scsi/aic79xx/aic79xx_core.c
@@ -1,9505 +0,0 @@
-/*
- * Core routines and tables shareable across OS platforms.
- *
- * Copyright (c) 1994-2002 Justin T. Gibbs.
- * Copyright (c) 2000-2003 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.c#156 $
- *
- * $FreeBSD$
- */
-
-#ifdef __linux__
-#include "aic79xx_osm.h"
-#include "aic79xx_inline.h"
-#include "aicasm/aicasm_insformat.h"
-#else
-#include <dev/aic7xxx/aic79xx_osm.h>
-#include <dev/aic7xxx/aic79xx_inline.h>
-#include <dev/aic7xxx/aicasm/aicasm_insformat.h>
-#endif
-
-/******************************** Globals *************************************/
-struct ahd_softc_tailq ahd_tailq = TAILQ_HEAD_INITIALIZER(ahd_tailq);
-
-/***************************** Lookup Tables **********************************/
-char *ahd_chip_names[] =
-{
-	"NONE",
-	"aic7901",
-	"aic7902",
-	"aic7901A"
-};
-static const u_int num_chip_names = NUM_ELEMENTS(ahd_chip_names);
-
-/*
- * Hardware error codes.
- */
-struct ahd_hard_error_entry {
-        uint8_t errno;
-	char *errmesg;
-};
-
-static struct ahd_hard_error_entry ahd_hard_errors[] = {
-	{ DSCTMOUT,	"Discard Timer has timed out" },
-	{ ILLOPCODE,	"Illegal Opcode in sequencer program" },
-	{ SQPARERR,	"Sequencer Parity Error" },
-	{ DPARERR,	"Data-path Parity Error" },
-	{ MPARERR,	"Scratch or SCB Memory Parity Error" },
-	{ CIOPARERR,	"CIOBUS Parity Error" },
-};
-static const u_int num_errors = NUM_ELEMENTS(ahd_hard_errors);
-
-static struct ahd_phase_table_entry ahd_phase_table[] =
-{
-	{ P_DATAOUT,	MSG_NOOP,		"in Data-out phase"	},
-	{ P_DATAIN,	MSG_INITIATOR_DET_ERR,	"in Data-in phase"	},
-	{ P_DATAOUT_DT,	MSG_NOOP,		"in DT Data-out phase"	},
-	{ P_DATAIN_DT,	MSG_INITIATOR_DET_ERR,	"in DT Data-in phase"	},
-	{ P_COMMAND,	MSG_NOOP,		"in Command phase"	},
-	{ P_MESGOUT,	MSG_NOOP,		"in Message-out phase"	},
-	{ P_STATUS,	MSG_INITIATOR_DET_ERR,	"in Status phase"	},
-	{ P_MESGIN,	MSG_PARITY_ERROR,	"in Message-in phase"	},
-	{ P_BUSFREE,	MSG_NOOP,		"while idle"		},
-	{ 0,		MSG_NOOP,		"in unknown phase"	}
-};
-
-/*
- * In most cases we only wish to itterate over real phases, so
- * exclude the last element from the count.
- */
-static const u_int num_phases = NUM_ELEMENTS(ahd_phase_table) - 1;
-
-/* Our Sequencer Program */
-#include "aic79xx_seq.h"
-
-/**************************** Function Declarations ***************************/
-static void		ahd_handle_transmission_error(struct ahd_softc *ahd);
-static void		ahd_handle_lqiphase_error(struct ahd_softc *ahd,
-						  u_int lqistat1);
-static int		ahd_handle_pkt_busfree(struct ahd_softc *ahd,
-					       u_int busfreetime);
-static int		ahd_handle_nonpkt_busfree(struct ahd_softc *ahd);
-static void		ahd_handle_proto_violation(struct ahd_softc *ahd);
-static void		ahd_force_renegotiation(struct ahd_softc *ahd,
-						struct ahd_devinfo *devinfo);
-
-static struct ahd_tmode_tstate*
-			ahd_alloc_tstate(struct ahd_softc *ahd,
-					 u_int scsi_id, char channel);
-#ifdef AHD_TARGET_MODE
-static void		ahd_free_tstate(struct ahd_softc *ahd,
-					u_int scsi_id, char channel, int force);
-#endif
-static void		ahd_devlimited_syncrate(struct ahd_softc *ahd,
-					        struct ahd_initiator_tinfo *,
-						u_int *period,
-						u_int *ppr_options,
-						role_t role);
-static void		ahd_update_neg_table(struct ahd_softc *ahd,
-					     struct ahd_devinfo *devinfo,
-					     struct ahd_transinfo *tinfo);
-static void		ahd_update_pending_scbs(struct ahd_softc *ahd);
-static void		ahd_fetch_devinfo(struct ahd_softc *ahd,
-					  struct ahd_devinfo *devinfo);
-static void		ahd_scb_devinfo(struct ahd_softc *ahd,
-					struct ahd_devinfo *devinfo,
-					struct scb *scb);
-static void		ahd_setup_initiator_msgout(struct ahd_softc *ahd,
-						   struct ahd_devinfo *devinfo,
-						   struct scb *scb);
-static void		ahd_build_transfer_msg(struct ahd_softc *ahd,
-					       struct ahd_devinfo *devinfo);
-static void		ahd_construct_sdtr(struct ahd_softc *ahd,
-					   struct ahd_devinfo *devinfo,
-					   u_int period, u_int offset);
-static void		ahd_construct_wdtr(struct ahd_softc *ahd,
-					   struct ahd_devinfo *devinfo,
-					   u_int bus_width);
-static void		ahd_construct_ppr(struct ahd_softc *ahd,
-					  struct ahd_devinfo *devinfo,
-					  u_int period, u_int offset,
-					  u_int bus_width, u_int ppr_options);
-static void		ahd_clear_msg_state(struct ahd_softc *ahd);
-static void		ahd_handle_message_phase(struct ahd_softc *ahd);
-typedef enum {
-	AHDMSG_1B,
-	AHDMSG_2B,
-	AHDMSG_EXT
-} ahd_msgtype;
-static int		ahd_sent_msg(struct ahd_softc *ahd, ahd_msgtype type,
-				     u_int msgval, int full);
-static int		ahd_parse_msg(struct ahd_softc *ahd,
-				      struct ahd_devinfo *devinfo);
-static int		ahd_handle_msg_reject(struct ahd_softc *ahd,
-					      struct ahd_devinfo *devinfo);
-static void		ahd_handle_ign_wide_residue(struct ahd_softc *ahd,
-						struct ahd_devinfo *devinfo);
-static void		ahd_reinitialize_dataptrs(struct ahd_softc *ahd);
-static void		ahd_handle_devreset(struct ahd_softc *ahd,
-					    struct ahd_devinfo *devinfo,
-					    u_int lun, cam_status status,
-					    char *message, int verbose_level);
-#if AHD_TARGET_MODE
-static void		ahd_setup_target_msgin(struct ahd_softc *ahd,
-					       struct ahd_devinfo *devinfo,
-					       struct scb *scb);
-#endif
-
-static u_int		ahd_sglist_size(struct ahd_softc *ahd);
-static u_int		ahd_sglist_allocsize(struct ahd_softc *ahd);
-static bus_dmamap_callback_t
-			ahd_dmamap_cb; 
-static void		ahd_initialize_hscbs(struct ahd_softc *ahd);
-static int		ahd_init_scbdata(struct ahd_softc *ahd);
-static void		ahd_fini_scbdata(struct ahd_softc *ahd);
-static void		ahd_setup_iocell_workaround(struct ahd_softc *ahd);
-static void		ahd_iocell_first_selection(struct ahd_softc *ahd);
-static void		ahd_add_col_list(struct ahd_softc *ahd,
-					 struct scb *scb, u_int col_idx);
-static void		ahd_rem_col_list(struct ahd_softc *ahd,
-					 struct scb *scb);
-static void		ahd_chip_init(struct ahd_softc *ahd);
-static void		ahd_qinfifo_requeue(struct ahd_softc *ahd,
-					    struct scb *prev_scb,
-					    struct scb *scb);
-static int		ahd_qinfifo_count(struct ahd_softc *ahd);
-static int		ahd_search_scb_list(struct ahd_softc *ahd, int target,
-					    char channel, int lun, u_int tag,
-					    role_t role, uint32_t status,
-					    ahd_search_action action,
-					    u_int *list_head, u_int tid);
-static void		ahd_stitch_tid_list(struct ahd_softc *ahd,
-					    u_int tid_prev, u_int tid_cur,
-					    u_int tid_next);
-static void		ahd_add_scb_to_free_list(struct ahd_softc *ahd,
-						 u_int scbid);
-static u_int		ahd_rem_wscb(struct ahd_softc *ahd, u_int scbid,
-				     u_int prev, u_int next, u_int tid);
-static void		ahd_reset_current_bus(struct ahd_softc *ahd);
-static ahd_callback_t	ahd_reset_poll;
-static ahd_callback_t	ahd_stat_timer;
-#ifdef AHD_DUMP_SEQ
-static void		ahd_dumpseq(struct ahd_softc *ahd);
-#endif
-static void		ahd_loadseq(struct ahd_softc *ahd);
-static int		ahd_check_patch(struct ahd_softc *ahd,
-					struct patch **start_patch,
-					u_int start_instr, u_int *skip_addr);
-static u_int		ahd_resolve_seqaddr(struct ahd_softc *ahd,
-					    u_int address);
-static void		ahd_download_instr(struct ahd_softc *ahd,
-					   u_int instrptr, uint8_t *dconsts);
-static int		ahd_probe_stack_size(struct ahd_softc *ahd);
-#ifdef AHD_TARGET_MODE
-static void		ahd_queue_lstate_event(struct ahd_softc *ahd,
-					       struct ahd_tmode_lstate *lstate,
-					       u_int initiator_id,
-					       u_int event_type,
-					       u_int event_arg);
-static void		ahd_update_scsiid(struct ahd_softc *ahd,
-					  u_int targid_mask);
-static int		ahd_handle_target_cmd(struct ahd_softc *ahd,
-					      struct target_cmd *cmd);
-#endif
-
-/******************************** Private Inlines *****************************/
-static __inline void	ahd_assert_atn(struct ahd_softc *ahd);
-static __inline int	ahd_currently_packetized(struct ahd_softc *ahd);
-static __inline int	ahd_set_active_fifo(struct ahd_softc *ahd);
-
-static __inline void
-ahd_assert_atn(struct ahd_softc *ahd)
-{
-	ahd_outb(ahd, SCSISIGO, ATNO);
-}
-
-/*
- * Determine if the current connection has a packetized
- * agreement.  This does not necessarily mean that we
- * are currently in a packetized transfer.  We could
- * just as easily be sending or receiving a message.
- */
-static __inline int
-ahd_currently_packetized(struct ahd_softc *ahd)
-{
-	ahd_mode_state	 saved_modes;
-	int		 packetized;
-
-	saved_modes = ahd_save_modes(ahd);
-	if ((ahd->bugs & AHD_PKTIZED_STATUS_BUG) != 0) {
-		/*
-		 * The packetized bit refers to the last
-		 * connection, not the current one.  Check
-		 * for non-zero LQISTATE instead.
-		 */
-		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
-		packetized = ahd_inb(ahd, LQISTATE) != 0;
-	} else {
-		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-		packetized = ahd_inb(ahd, LQISTAT2) & PACKETIZED;
-	}
-	ahd_restore_modes(ahd, saved_modes);
-	return (packetized);
-}
-
-static __inline int
-ahd_set_active_fifo(struct ahd_softc *ahd)
-{
-	u_int active_fifo;
-
-	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
-	active_fifo = ahd_inb(ahd, DFFSTAT) & CURRFIFO;
-	switch (active_fifo) {
-	case 0:
-	case 1:
-		ahd_set_modes(ahd, active_fifo, active_fifo);
-		return (1);
-	default:
-		return (0);
-	}
-}
-
-/************************* Sequencer Execution Control ************************/
-/*
- * Restart the sequencer program from address zero
- */
-void
-ahd_restart(struct ahd_softc *ahd)
-{
-
-	ahd_pause(ahd);
-
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-
-	/* No more pending messages */
-	ahd_clear_msg_state(ahd);
-	ahd_outb(ahd, SCSISIGO, 0);		/* De-assert BSY */
-	ahd_outb(ahd, MSG_OUT, MSG_NOOP);	/* No message to send */
-	ahd_outb(ahd, SXFRCTL1, ahd_inb(ahd, SXFRCTL1) & ~BITBUCKET);
-	ahd_outb(ahd, SEQINTCTL, 0);
-	ahd_outb(ahd, LASTPHASE, P_BUSFREE);
-	ahd_outb(ahd, SEQ_FLAGS, 0);
-	ahd_outb(ahd, SAVED_SCSIID, 0xFF);
-	ahd_outb(ahd, SAVED_LUN, 0xFF);
-
-	/*
-	 * Ensure that the sequencer's idea of TQINPOS
-	 * matches our own.  The sequencer increments TQINPOS
-	 * only after it sees a DMA complete and a reset could
-	 * occur before the increment leaving the kernel to believe
-	 * the command arrived but the sequencer to not.
-	 */
-	ahd_outb(ahd, TQINPOS, ahd->tqinfifonext);
-
-	/* Always allow reselection */
-	ahd_outb(ahd, SCSISEQ1,
-		 ahd_inb(ahd, SCSISEQ_TEMPLATE) & (ENSELI|ENRSELI|ENAUTOATNP));
-	/* Ensure that no DMA operations are in progress */
-	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
-	ahd_outb(ahd, SCBHCNT, 0);
-	ahd_outb(ahd, CCSCBCTL, CCSCBRESET);
-	ahd_outb(ahd, SEQCTL0, FASTMODE|SEQRESET);
-	ahd_unpause(ahd);
-}
-
-void
-ahd_clear_fifo(struct ahd_softc *ahd, u_int fifo)
-{
-	ahd_mode_state	 saved_modes;
-
-#ifdef AHD_DEBUG
-	if ((ahd_debug & AHD_SHOW_FIFOS) != 0)
-		printf("%s: Clearing FIFO %d\n", ahd_name(ahd), fifo);
-#endif
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, fifo, fifo);
-	ahd_outb(ahd, DFFSXFRCTL, RSTCHN|CLRSHCNT);
-	if ((ahd_inb(ahd, SG_STATE) & FETCH_INPROG) != 0)
-		ahd_outb(ahd, CCSGCTL, CCSGRESET);
-	ahd_outb(ahd, LONGJMP_ADDR + 1, INVALID_ADDR);
-	ahd_outb(ahd, SG_STATE, 0);
-	ahd_restore_modes(ahd, saved_modes);
-}
-
-/************************* Input/Output Queues ********************************/
-/*
- * Flush and completed commands that are sitting in the command
- * complete queues down on the chip but have yet to be dma'ed back up.
- */
-void
-ahd_flush_qoutfifo(struct ahd_softc *ahd)
-{
-	struct		scb *scb;
-	ahd_mode_state	saved_modes;
-	u_int		saved_scbptr;
-	u_int		ccscbctl;
-	u_int		scbid;
-	u_int		next_scbid;
-
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
-	saved_scbptr = ahd_get_scbptr(ahd);
-
-	/*
-	 * Wait for any inprogress DMA to complete and clear DMA state
-	 * if this if for an SCB in the qinfifo.
-	 */
-	while ((ccscbctl = ahd_inb(ahd, CCSCBCTL) & (CCARREN|CCSCBEN)) != 0) {
-
-		if ((ccscbctl & (CCSCBDIR|CCARREN)) == (CCSCBDIR|CCARREN)) {
-			if ((ccscbctl & ARRDONE) != 0)
-				break;
-		} else if ((ccscbctl & CCSCBDONE) != 0)
-			break;
-		ahd_delay(200);
-	}
-	if ((ccscbctl & CCSCBDIR) != 0)
-		ahd_outb(ahd, CCSCBCTL, ccscbctl & ~(CCARREN|CCSCBEN));
-
-	/*
-	 * Complete any SCBs that just finished being
-	 * DMA'ed into the qoutfifo.
-	 */
-	ahd_run_qoutfifo(ahd);
-
-	/*
-	 * Manually update/complete any completed SCBs that are waiting to be
-	 * DMA'ed back up to the host.
-	 */
-	scbid = ahd_inw(ahd, COMPLETE_DMA_SCB_HEAD);
-	while (!SCBID_IS_NULL(scbid)) {
-		uint8_t *hscb_ptr;
-		u_int	 i;
-		
-		ahd_set_scbptr(ahd, scbid);
-		next_scbid = ahd_inw(ahd, SCB_NEXT_COMPLETE);
-		scb = ahd_lookup_scb(ahd, scbid);
-		if (scb == NULL) {
-			printf("%s: Warning - DMA-up and complete "
-			       "SCB %d invalid\n", ahd_name(ahd), scbid);
-			continue;
-		}
-		hscb_ptr = (uint8_t *)scb->hscb;
-		for (i = 0; i < sizeof(struct hardware_scb); i++)
-			*hscb_ptr++ = ahd_inb(ahd, SCB_BASE + i);
-
-		ahd_complete_scb(ahd, scb);
-		scbid = next_scbid;
-	}
-	ahd_outw(ahd, COMPLETE_DMA_SCB_HEAD, SCB_LIST_NULL);
-
-	scbid = ahd_inw(ahd, COMPLETE_SCB_HEAD);
-	while (!SCBID_IS_NULL(scbid)) {
-
-		ahd_set_scbptr(ahd, scbid);
-		next_scbid = ahd_inw(ahd, SCB_NEXT_COMPLETE);
-		scb = ahd_lookup_scb(ahd, scbid);
-		if (scb == NULL) {
-			printf("%s: Warning - Complete SCB %d invalid\n",
-			       ahd_name(ahd), scbid);
-			continue;
-		}
-
-		ahd_complete_scb(ahd, scb);
-		scbid = next_scbid;
-	}
-	ahd_outw(ahd, COMPLETE_SCB_HEAD, SCB_LIST_NULL);
-	ahd_set_scbptr(ahd, saved_scbptr);
-
-	/*
-	 * Flush the good status FIFO for compelted packetized commands.
-	 */
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	while ((ahd_inb(ahd, LQISTAT2) & LQIGSAVAIL) != 0) {
-		scbid = (ahd_inb(ahd, GSFIFO+1) << 8)
-		      | ahd_inb(ahd, GSFIFO);
-		scb = ahd_lookup_scb(ahd, scbid);
-		if (scb == NULL) {
-			printf("%s: Warning - GSFIFO SCB %d invalid\n",
-			       ahd_name(ahd), scbid);
-			continue;
-		}
-		ahd_complete_scb(ahd, scb);
-	}
-
-	/*
-	 * Restore state.
-	 */
-	ahd_restore_modes(ahd, saved_modes);
-	ahd->flags |= AHD_UPDATE_PEND_CMDS;
-}
-
-void
-ahd_run_qoutfifo(struct ahd_softc *ahd)
-{
-	struct scb *scb;
-	u_int  scb_index;
-
-	if ((ahd->flags & AHD_RUNNING_QOUTFIFO) != 0)
-		panic("ahd_run_qoutfifo recursion");
-	ahd->flags |= AHD_RUNNING_QOUTFIFO;
-	ahd_sync_qoutfifo(ahd, BUS_DMASYNC_POSTREAD);
-	while ((ahd->qoutfifo[ahd->qoutfifonext]
-	     & QOUTFIFO_ENTRY_VALID_LE) == ahd->qoutfifonext_valid_tag) {
-
-		scb_index = ahd_le16toh(ahd->qoutfifo[ahd->qoutfifonext]
-				      & ~QOUTFIFO_ENTRY_VALID_LE);
-		scb = ahd_lookup_scb(ahd, scb_index);
-		if (scb == NULL) {
-			printf("%s: WARNING no command for scb %d "
-			       "(cmdcmplt)\nQOUTPOS = %d\n",
-			       ahd_name(ahd), scb_index,
-			       ahd->qoutfifonext);
-			ahd_dump_card_state(ahd);
-		} else
-			ahd_complete_scb(ahd, scb);
-
-		ahd->qoutfifonext = (ahd->qoutfifonext+1) & (AHD_QOUT_SIZE-1);
-		if (ahd->qoutfifonext == 0)
-			ahd->qoutfifonext_valid_tag ^= QOUTFIFO_ENTRY_VALID_LE;
-	}
-	ahd->flags &= ~AHD_RUNNING_QOUTFIFO;
-}
-
-/************************* Interrupt Handling *********************************/
-void
-ahd_handle_hwerrint(struct ahd_softc *ahd)
-{
-	/*
-	 * Some catastrophic hardware error has occurred.
-	 * Print it for the user and disable the controller.
-	 */
-	int i;
-	int error;
-
-	error = ahd_inb(ahd, ERROR);
-	for (i = 0; i < num_errors; i++) {
-		if ((error & ahd_hard_errors[i].errno) != 0)
-			printf("%s: hwerrint, %s\n",
-			       ahd_name(ahd), ahd_hard_errors[i].errmesg);
-	}
-
-	ahd_dump_card_state(ahd);
-	panic("BRKADRINT");
-
-	/* Tell everyone that this HBA is no longer availible */
-	ahd_abort_scbs(ahd, CAM_TARGET_WILDCARD, ALL_CHANNELS,
-		       CAM_LUN_WILDCARD, SCB_LIST_NULL, ROLE_UNKNOWN,
-		       CAM_NO_HBA);
-
-	/* Tell the system that this controller has gone away. */
-	ahd_free(ahd);
-}
-
-void
-ahd_handle_seqint(struct ahd_softc *ahd, u_int intstat)
-{
-	u_int seqintcode;
-
-	/*
-	 * Save the sequencer interrupt code and clear the SEQINT
-	 * bit. We will unpause the sequencer, if appropriate,
-	 * after servicing the request.
-	 */
-	seqintcode = ahd_inb(ahd, SEQINTCODE);
-	ahd_outb(ahd, CLRINT, CLRSEQINT);
-	if ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {
-		/*
-		 * Unpause the sequencer and let it clear
-		 * SEQINT by writing NO_SEQINT to it.  This
-		 * will cause the sequencer to be paused again,
-		 * which is the expected state of this routine.
-		 */
-		ahd_unpause(ahd);
-		while (!ahd_is_paused(ahd))
-			;
-		ahd_outb(ahd, CLRINT, CLRSEQINT);
-	}
-	ahd_update_modes(ahd);
-#ifdef AHD_DEBUG
-	if ((ahd_debug & AHD_SHOW_MISC) != 0)
-		printf("%s: Handle Seqint Called for code %d\n",
-		       ahd_name(ahd), seqintcode);
-#endif
-	switch (seqintcode) {
-	case ENTERING_NONPACK:
-	{
-		struct	scb *scb;
-		u_int	scbid;
-
-		AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
-				 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
-		scbid = ahd_get_scbptr(ahd);
-		scb = ahd_lookup_scb(ahd, scbid);
-		if (scb == NULL) {
-			/*
-			 * Somehow need to know if this
-			 * is from a selection or reselection.
-			 * From that, we can termine target
-			 * ID so we at least have an I_T nexus.
-			 */
-		} else {
-			ahd_outb(ahd, SAVED_SCSIID, scb->hscb->scsiid);
-			ahd_outb(ahd, SAVED_LUN, scb->hscb->lun);
-			ahd_outb(ahd, SEQ_FLAGS, 0x0);
-		}
-		if ((ahd_inb(ahd, LQISTAT2) & LQIPHASE_OUTPKT) != 0
-		 && (ahd_inb(ahd, SCSISIGO) & ATNO) != 0) {
-			/*
-			 * Phase change after read stream with
-			 * CRC error with P0 asserted on last
-			 * packet.
-			 */
-#ifdef AHD_DEBUG
-			if ((ahd_debug & AHD_SHOW_RECOVERY) != 0)
-				printf("%s: Assuming LQIPHASE_NLQ with "
-				       "P0 assertion\n", ahd_name(ahd));
-#endif
-		}
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_RECOVERY) != 0)
-			printf("%s: Entering NONPACK\n", ahd_name(ahd));
-#endif
-		break;
-	}
-	case INVALID_SEQINT:
-		printf("%s: Invalid Sequencer interrupt occurred.\n",
-		       ahd_name(ahd));
-		ahd_dump_card_state(ahd);
-		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
-		break;
-	case STATUS_OVERRUN:
-	{
-		printf("%s: Status Overrun", ahd_name(ahd));
-		ahd_dump_card_state(ahd);
-		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
-		break;
-	}
-	case CFG4ISTAT_INTR:
-	{
-		struct	scb *scb;
-		u_int	scbid;
-
-		scbid = ahd_get_scbptr(ahd);
-		scb = ahd_lookup_scb(ahd, scbid);
-		if (scb == NULL) {
-			ahd_dump_card_state(ahd);
-			printf("CFG4ISTAT: Free SCB %d referenced", scbid);
-			panic("For safety");
-		}
-		ahd_outq(ahd, HADDR, scb->sense_busaddr);
-		ahd_outw(ahd, HCNT, AHD_SENSE_BUFSIZE);
-		ahd_outb(ahd, HCNT + 2, 0);
-		ahd_outb(ahd, SG_CACHE_PRE, SG_LAST_SEG);
-		ahd_outb(ahd, DFCNTRL, PRELOADEN|SCSIEN|HDMAEN);
-		break;
-	}
-	case ILLEGAL_PHASE:
-	{
-		u_int bus_phase;
-
-		bus_phase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;
-		printf("%s: ILLEGAL_PHASE 0x%x\n",
-		       ahd_name(ahd), bus_phase);
-
-		switch (bus_phase) {
-		case P_DATAOUT:
-		case P_DATAIN:
-		case P_DATAOUT_DT:
-		case P_DATAIN_DT:
-		case P_MESGOUT:
-		case P_STATUS:
-		case P_MESGIN:
-			ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
-			printf("%s: Issued Bus Reset.\n", ahd_name(ahd));
-			break;
-		case P_COMMAND:
-		{
-			struct	ahd_devinfo devinfo;
-			struct	scb *scb;
-			struct	ahd_initiator_tinfo *targ_info;
-			struct	ahd_tmode_tstate *tstate;
-			struct	ahd_transinfo *tinfo;
-			u_int	scbid;
-
-			/*
-			 * If a target takes us into the command phase
-			 * assume that it has been externally reset and
-			 * has thus lost our previous packetized negotiation
-			 * agreement.  Since we have not sent an identify
-			 * message and may not have fully qualified the
-			 * connection, we change our command to TUR, assert
-			 * ATN and ABORT the task when we go to message in
-			 * phase.  The OSM will see the REQUEUE_REQUEST
-			 * status and retry the command.
-			 */
-			scbid = ahd_get_scbptr(ahd);
-			scb = ahd_lookup_scb(ahd, scbid);
-			if (scb == NULL) {
-				printf("Invalid phase with no valid SCB.  "
-				       "Resetting bus.\n");
-				ahd_reset_channel(ahd, 'A',
-						  /*Initiate Reset*/TRUE);
-				break;
-			}
-			ahd_compile_devinfo(&devinfo, SCB_GET_OUR_ID(scb),
-					    SCB_GET_TARGET(ahd, scb),
-					    SCB_GET_LUN(scb),
-					    SCB_GET_CHANNEL(ahd, scb),
-					    ROLE_INITIATOR);
-			targ_info = ahd_fetch_transinfo(ahd,
-							devinfo.channel,
-							devinfo.our_scsiid,
-							devinfo.target,
-							&tstate);
-			tinfo = &targ_info->curr;
-			ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
-				      AHD_TRANS_ACTIVE, /*paused*/TRUE);
-			ahd_set_syncrate(ahd, &devinfo, /*period*/0,
-					 /*offset*/0, /*ppr_options*/0,
-					 AHD_TRANS_ACTIVE, /*paused*/TRUE);
-			ahd_outb(ahd, SCB_CDB_STORE, 0);
-			ahd_outb(ahd, SCB_CDB_STORE+1, 0);
-			ahd_outb(ahd, SCB_CDB_STORE+2, 0);
-			ahd_outb(ahd, SCB_CDB_STORE+3, 0);
-			ahd_outb(ahd, SCB_CDB_STORE+4, 0);
-			ahd_outb(ahd, SCB_CDB_STORE+5, 0);
-			ahd_outb(ahd, SCB_CDB_LEN, 6);
-			scb->hscb->control &= ~(TAG_ENB|SCB_TAG_TYPE);
-			scb->hscb->control |= MK_MESSAGE;
-			ahd_outb(ahd, SCB_CONTROL, scb->hscb->control);
-			ahd_outb(ahd, MSG_OUT, HOST_MSG);
-			ahd_outb(ahd, SAVED_SCSIID, scb->hscb->scsiid);
-			/*
-			 * The lun is 0, regardless of the SCB's lun
-			 * as we have not sent an identify message.
-			 */
-			ahd_outb(ahd, SAVED_LUN, 0);
-			ahd_outb(ahd, SEQ_FLAGS, 0);
-			ahd_assert_atn(ahd);
-			scb->flags &= ~(SCB_PACKETIZED);
-			scb->flags |= SCB_ABORT|SCB_CMDPHASE_ABORT;
-			ahd_freeze_devq(ahd, scb);
-			ahd_set_transaction_status(scb, CAM_REQUEUE_REQ);
-			ahd_freeze_scb(scb);
-
-			/*
-			 * Allow the sequencer to continue with
-			 * non-pack processing.
-			 */
-			ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-			ahd_outb(ahd, CLRLQOINT1, CLRLQOPHACHGINPKT);
-			if ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0) {
-				ahd_outb(ahd, CLRLQOINT1, 0);
-			}
-#ifdef AHD_DEBUG
-			if ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {
-				ahd_print_path(ahd, scb);
-				printf("Unexpected command phase from "
-				       "packetized target\n");
-			}
-#endif
-			break;
-		}
-		}
-		break;
-	}
-	case CFG4OVERRUN:
-	{
-		struct	scb *scb;
-		u_int	scb_index;
-		
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {
-			printf("%s: CFG4OVERRUN mode = %x\n", ahd_name(ahd),
-			       ahd_inb(ahd, MODE_PTR));
-		}
-#endif
-		scb_index = ahd_get_scbptr(ahd);
-		scb = ahd_lookup_scb(ahd, scb_index);
-		if (scb == NULL) {
-			/*
-			 * Attempt to transfer to an SCB that is
-			 * not outstanding.
-			 */
-			ahd_assert_atn(ahd);
-			ahd_outb(ahd, MSG_OUT, HOST_MSG);
-			ahd->msgout_buf[0] = MSG_ABORT_TASK;
-			ahd->msgout_len = 1;
-			ahd->msgout_index = 0;
-			ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
-			/*
-			 * Clear status received flag to prevent any
-			 * attempt to complete this bogus SCB.
-			 */
-			ahd_outb(ahd, SCB_CONTROL,
-				 ahd_inb(ahd, SCB_CONTROL) & ~STATUS_RCVD);
-		}
-		break;
-	}
-	case DUMP_CARD_STATE:
-	{
-		ahd_dump_card_state(ahd);
-		break;
-	}
-	case PDATA_REINIT:
-	{
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {
-			printf("%s: PDATA_REINIT - DFCNTRL = 0x%x "
-			       "SG_CACHE_SHADOW = 0x%x\n",
-			       ahd_name(ahd), ahd_inb(ahd, DFCNTRL),
-			       ahd_inb(ahd, SG_CACHE_SHADOW));
-		}
-#endif
-		ahd_reinitialize_dataptrs(ahd);
-		break;
-	}
-	case HOST_MSG_LOOP:
-	{
-		struct ahd_devinfo devinfo;
-
-		/*
-		 * The sequencer has encountered a message phase
-		 * that requires host assistance for completion.
-		 * While handling the message phase(s), we will be
-		 * notified by the sequencer after each byte is
-		 * transfered so we can track bus phase changes.
-		 *
-		 * If this is the first time we've seen a HOST_MSG_LOOP
-		 * interrupt, initialize the state of the host message
-		 * loop.
-		 */
-		ahd_fetch_devinfo(ahd, &devinfo);
-		if (ahd->msg_type == MSG_TYPE_NONE) {
-			struct scb *scb;
-			u_int scb_index;
-			u_int bus_phase;
-
-			bus_phase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;
-			if (bus_phase != P_MESGIN
-			 && bus_phase != P_MESGOUT) {
-				printf("ahd_intr: HOST_MSG_LOOP bad "
-				       "phase 0x%x\n", bus_phase);
-				/*
-				 * Probably transitioned to bus free before
-				 * we got here.  Just punt the message.
-				 */
-				ahd_dump_card_state(ahd);
-				ahd_clear_intstat(ahd);
-				ahd_restart(ahd);
-				return;
-			}
-
-			scb_index = ahd_get_scbptr(ahd);
-			scb = ahd_lookup_scb(ahd, scb_index);
-			if (devinfo.role == ROLE_INITIATOR) {
-				if (bus_phase == P_MESGOUT)
-					ahd_setup_initiator_msgout(ahd,
-								   &devinfo,
-								   scb);
-				else {
-					ahd->msg_type =
-					    MSG_TYPE_INITIATOR_MSGIN;
-					ahd->msgin_index = 0;
-				}
-			}
-#if AHD_TARGET_MODE
-			else {
-				if (bus_phase == P_MESGOUT) {
-					ahd->msg_type =
-					    MSG_TYPE_TARGET_MSGOUT;
-					ahd->msgin_index = 0;
-				}
-				else 
-					ahd_setup_target_msgin(ahd,
-							       &devinfo,
-							       scb);
-			}
-#endif
-		}
-
-		ahd_handle_message_phase(ahd);
-		break;
-	}
-	case NO_MATCH:
-	{
-		/* Ensure we don't leave the selection hardware on */
-		AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
-		ahd_outb(ahd, SCSISEQ0, ahd_inb(ahd, SCSISEQ0) & ~ENSELO);
-
-		printf("%s:%c:%d: no active SCB for reconnecting "
-		       "target - issuing BUS DEVICE RESET\n",
-		       ahd_name(ahd), 'A', ahd_inb(ahd, SELID) >> 4);
-		printf("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
-		       "REG0 == 0x%x ACCUM = 0x%x\n",
-		       ahd_inb(ahd, SAVED_SCSIID), ahd_inb(ahd, SAVED_LUN),
-		       ahd_inw(ahd, REG0), ahd_inb(ahd, ACCUM));
-		printf("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
-		       "SINDEX == 0x%x\n",
-		       ahd_inb(ahd, SEQ_FLAGS), ahd_get_scbptr(ahd),
-		       ahd_find_busy_tcl(ahd,
-					 BUILD_TCL(ahd_inb(ahd, SAVED_SCSIID),
-						   ahd_inb(ahd, SAVED_LUN))),
-		       ahd_inw(ahd, SINDEX));
-		printf("SELID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
-		       "SCB_CONTROL == 0x%x\n",
-		       ahd_inb(ahd, SELID), ahd_inb_scbram(ahd, SCB_SCSIID),
-		       ahd_inb_scbram(ahd, SCB_LUN),
-		       ahd_inb_scbram(ahd, SCB_CONTROL));
-		printf("SCSIBUS[0] == 0x%x, SCSISIGI == 0x%x\n",
-		       ahd_inb(ahd, SCSIBUS), ahd_inb(ahd, SCSISIGI));
-		printf("SXFRCTL0 == 0x%x\n", ahd_inb(ahd, SXFRCTL0));
-		printf("SEQCTL0 == 0x%x\n", ahd_inb(ahd, SEQCTL0));
-		ahd_dump_card_state(ahd);
-		ahd->msgout_buf[0] = MSG_BUS_DEV_RESET;
-		ahd->msgout_len = 1;
-		ahd->msgout_index = 0;
-		ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
-		ahd_outb(ahd, MSG_OUT, HOST_MSG);
-		ahd_assert_atn(ahd);
-		break;
-	}
-	case PROTO_VIOLATION:
-	{
-		ahd_handle_proto_violation(ahd);
-		break;
-	}
-	case IGN_WIDE_RES:
-	{
-		struct ahd_devinfo devinfo;
-
-		ahd_fetch_devinfo(ahd, &devinfo);
-		ahd_handle_ign_wide_residue(ahd, &devinfo);
-		break;
-	}
-	case BAD_PHASE:
-	{
-		u_int lastphase;
-
-		lastphase = ahd_inb(ahd, LASTPHASE);
-		printf("%s:%c:%d: unknown scsi bus phase %x, "
-		       "lastphase = 0x%x.  Attempting to continue\n",
-		       ahd_name(ahd), 'A',
-		       SCSIID_TARGET(ahd, ahd_inb(ahd, SAVED_SCSIID)),
-		       lastphase, ahd_inb(ahd, SCSISIGI));
-		break;
-	}
-	case MISSED_BUSFREE:
-	{
-		u_int lastphase;
-
-		lastphase = ahd_inb(ahd, LASTPHASE);
-		printf("%s:%c:%d: Missed busfree. "
-		       "Lastphase = 0x%x, Curphase = 0x%x\n",
-		       ahd_name(ahd), 'A',
-		       SCSIID_TARGET(ahd, ahd_inb(ahd, SAVED_SCSIID)),
-		       lastphase, ahd_inb(ahd, SCSISIGI));
-		ahd_restart(ahd);
-		return;
-	}
-	case DATA_OVERRUN:
-	{
-		/*
-		 * When the sequencer detects an overrun, it
-		 * places the controller in "BITBUCKET" mode
-		 * and allows the target to complete its transfer.
-		 * Unfortunately, none of the counters get updated
-		 * when the controller is in this mode, so we have
-		 * no way of knowing how large the overrun was.
-		 */
-		struct	scb *scb;
-		u_int	scbindex;
-#ifdef AHD_DEBUG
-		u_int	lastphase;
-#endif
-
-		scbindex = ahd_get_scbptr(ahd);
-		scb = ahd_lookup_scb(ahd, scbindex);
-#ifdef AHD_DEBUG
-		lastphase = ahd_inb(ahd, LASTPHASE);
-		if ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {
-			ahd_print_path(ahd, scb);
-			printf("data overrun detected %s.  Tag == 0x%x.\n",
-			       ahd_lookup_phase_entry(lastphase)->phasemsg,
-			       SCB_GET_TAG(scb));
-			ahd_print_path(ahd, scb);
-			printf("%s seen Data Phase.  Length = %ld.  "
-			       "NumSGs = %d.\n",
-			       ahd_inb(ahd, SEQ_FLAGS) & DPHASE
-			       ? "Have" : "Haven't",
-			       ahd_get_transfer_length(scb), scb->sg_count);
-			ahd_dump_sglist(scb);
-		}
-#endif
-
-		/*
-		 * Set this and it will take effect when the
-		 * target does a command complete.
-		 */
-		ahd_freeze_devq(ahd, scb);
-		ahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);
-		ahd_freeze_scb(scb);
-		break;
-	}
-	case MKMSG_FAILED:
-	{
-		struct ahd_devinfo devinfo;
-		struct scb *scb;
-		u_int scbid;
-
-		ahd_fetch_devinfo(ahd, &devinfo);
-		printf("%s:%c:%d:%d: Attempt to issue message failed\n",
-		       ahd_name(ahd), devinfo.channel, devinfo.target,
-		       devinfo.lun);
-		scbid = ahd_get_scbptr(ahd);
-		scb = ahd_lookup_scb(ahd, scbid);
-		if (scb != NULL
-		 && (scb->flags & SCB_RECOVERY_SCB) != 0)
-			/*
-			 * Ensure that we didn't put a second instance of this
-			 * SCB into the QINFIFO.
-			 */
-			ahd_search_qinfifo(ahd, SCB_GET_TARGET(ahd, scb),
-					   SCB_GET_CHANNEL(ahd, scb),
-					   SCB_GET_LUN(scb), SCB_GET_TAG(scb),
-					   ROLE_INITIATOR, /*status*/0,
-					   SEARCH_REMOVE);
-		ahd_outb(ahd, SCB_CONTROL,
-			 ahd_inb(ahd, SCB_CONTROL) & ~MK_MESSAGE);
-		break;
-	}
-	case TASKMGMT_FUNC_COMPLETE:
-	{
-		u_int	scbid;
-		struct	scb *scb;
-
-		scbid = ahd_get_scbptr(ahd);
-		scb = ahd_lookup_scb(ahd, scbid);
-		if (scb != NULL) {
-			u_int	   lun;
-			u_int	   tag;
-			cam_status error;
-
-			ahd_print_path(ahd, scb);
-			printf("Task Management Func 0x%x Complete\n",
-			       scb->hscb->task_management);
-			lun = CAM_LUN_WILDCARD;
-			tag = SCB_LIST_NULL;
-
-			switch (scb->hscb->task_management) {
-			case SIU_TASKMGMT_ABORT_TASK:
-				tag = scb->hscb->tag;
-			case SIU_TASKMGMT_ABORT_TASK_SET:
-			case SIU_TASKMGMT_CLEAR_TASK_SET:
-				lun = scb->hscb->lun;
-				error = CAM_REQ_ABORTED;
-				ahd_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),
-					       'A', lun, tag, ROLE_INITIATOR,
-					       error);
-				break;
-			case SIU_TASKMGMT_LUN_RESET:
-				lun = scb->hscb->lun;
-			case SIU_TASKMGMT_TARGET_RESET:
-			{
-				struct ahd_devinfo devinfo;
-
-				ahd_scb_devinfo(ahd, &devinfo, scb);
-				error = CAM_BDR_SENT;
-				ahd_handle_devreset(ahd, &devinfo, lun,
-						    CAM_BDR_SENT,
-						    lun != CAM_LUN_WILDCARD
-						    ? "Lun Reset"
-						    : "Target Reset",
-						    /*verbose_level*/0);
-				break;
-			}
-			default:
-				panic("Unexpected TaskMgmt Func\n");
-				break;
-			}
-		}
-		break;
-	}
-	case TASKMGMT_CMD_CMPLT_OKAY:
-	{
-		u_int	scbid;
-		struct	scb *scb;
-
-		/*
-		 * An ABORT TASK TMF failed to be delivered before
-		 * the targeted command completed normally.
-		 */
-		scbid = ahd_get_scbptr(ahd);
-		scb = ahd_lookup_scb(ahd, scbid);
-		if (scb != NULL) {
-			/*
-			 * Remove the second instance of this SCB from
-			 * the QINFIFO if it is still there.
-                         */
-			ahd_print_path(ahd, scb);
-			printf("SCB completes before TMF\n");
-			/*
-			 * Handle losing the race.  Wait until any
-			 * current selection completes.  We will then
-			 * set the TMF back to zero in this SCB so that
-			 * the sequencer doesn't bother to issue another
-			 * sequencer interrupt for its completion.
-			 */
-			while ((ahd_inb(ahd, SCSISEQ0) & ENSELO) != 0
-			    && (ahd_inb(ahd, SSTAT0) & SELDO) == 0
-			    && (ahd_inb(ahd, SSTAT1) & SELTO) == 0)
-				;
-			ahd_outb(ahd, SCB_TASK_MANAGEMENT, 0);
-			ahd_search_qinfifo(ahd, SCB_GET_TARGET(ahd, scb),
-					   SCB_GET_CHANNEL(ahd, scb),  
-					   SCB_GET_LUN(scb), scb->hscb->tag, 
-					   ROLE_INITIATOR, /*status*/0,   
-					   SEARCH_REMOVE);
-		}
-		break;
-	}
-	case TRACEPOINT0:
-	case TRACEPOINT1:
-	case TRACEPOINT2:
-	case TRACEPOINT3:
-		printf("%s: Tracepoint %d\n", ahd_name(ahd),
-		       seqintcode - TRACEPOINT0);
-		break;
-	case NO_SEQINT:
-		break;
-	case SAW_HWERR:
-		ahd_handle_hwerrint(ahd);
-		break;
-	default:
-		printf("%s: Unexpected SEQINTCODE %d\n", ahd_name(ahd),
-		       seqintcode);
-		break;
-	}
-	/*
-	 *  The sequencer is paused immediately on
-	 *  a SEQINT, so we should restart it when
-	 *  we're done.
-	 */
-	ahd_unpause(ahd);
-}
-
-void
-ahd_handle_scsiint(struct ahd_softc *ahd, u_int intstat)
-{
-	struct scb	*scb;
-	u_int		 status0;
-	u_int		 status3;
-	u_int		 status;
-	u_int		 lqistat1;
-	u_int		 lqostat0;
-	u_int		 scbid;
-	u_int		 busfreetime;
-
-	ahd_update_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-
-	status3 = ahd_inb(ahd, SSTAT3) & (NTRAMPERR|OSRAMPERR);
-	status0 = ahd_inb(ahd, SSTAT0) & (IOERR|OVERRUN|SELDI|SELDO);
-	status = ahd_inb(ahd, SSTAT1) & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);
-	lqistat1 = ahd_inb(ahd, LQISTAT1);
-	lqostat0 = ahd_inb(ahd, LQOSTAT0);
-	busfreetime = ahd_inb(ahd, SSTAT2) & BUSFREETIME;
-	if ((status0 & (SELDI|SELDO)) != 0) {
-		u_int simode0;
-
-		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
-		simode0 = ahd_inb(ahd, SIMODE0);
-		status0 &= simode0 & (IOERR|OVERRUN|SELDI|SELDO);
-		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	}
-	scbid = ahd_get_scbptr(ahd);
-	scb = ahd_lookup_scb(ahd, scbid);
-	if (scb != NULL
-	 && (ahd_inb(ahd, SEQ_FLAGS) & NOT_IDENTIFIED) != 0)
-		scb = NULL;
-
-	/* Make sure the sequencer is in a safe location. */
-	ahd_clear_critical_section(ahd);
-
-	if ((status0 & IOERR) != 0) {
-		u_int now_lvd;
-
-		now_lvd = ahd_inb(ahd, SBLKCTL) & ENAB40;
-		printf("%s: Transceiver State Has Changed to %s mode\n",
-		       ahd_name(ahd), now_lvd ? "LVD" : "SE");
-		ahd_outb(ahd, CLRSINT0, CLRIOERR);
-		/*
-		 * A change in I/O mode is equivalent to a bus reset.
-		 */
-		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/FALSE);
-		ahd_pause(ahd);
-		ahd_setup_iocell_workaround(ahd);
-		ahd_unpause(ahd);
-	} else if ((status0 & OVERRUN) != 0) {
-		printf("%s: SCSI offset overrun detected.  Resetting bus.\n",
-		       ahd_name(ahd));
-		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
-	} else if ((status & SCSIRSTI) != 0) {
-		printf("%s: Someone reset channel A\n", ahd_name(ahd));
-		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/FALSE);
-	} else if ((status & SCSIPERR) != 0) {
-		ahd_handle_transmission_error(ahd);
-	} else if (lqostat0 != 0) {
-		printf("%s: lqostat0 == 0x%x!\n", ahd_name(ahd), lqostat0);
-		ahd_outb(ahd, CLRLQOINT0, lqostat0);
-		if ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0) {
-			ahd_outb(ahd, CLRLQOINT1, 0);
-		}
-	} else if ((status & SELTO) != 0) {
-		u_int  scbid;
-
-		/* Stop the selection */
-		ahd_outb(ahd, SCSISEQ0, 0);
-
-		/* No more pending messages */
-		ahd_clear_msg_state(ahd);
-
-		/* Clear interrupt state */
-		ahd_outb(ahd, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);
-
-		/*
-		 * Although the driver does not care about the
-		 * 'Selection in Progress' status bit, the busy
-		 * LED does.  SELINGO is only cleared by a sucessfull
-		 * selection, so we must manually clear it to insure
-		 * the LED turns off just incase no future successful
-		 * selections occur (e.g. no devices on the bus).
-		 */
-		ahd_outb(ahd, CLRSINT0, CLRSELINGO);
-
-		scbid = ahd_inw(ahd, WAITING_TID_HEAD);
-		scb = ahd_lookup_scb(ahd, scbid);
-		if (scb == NULL) {
-			printf("%s: ahd_intr - referenced scb not "
-			       "valid during SELTO scb(0x%x)\n",
-			       ahd_name(ahd), scbid);
-			ahd_dump_card_state(ahd);
-		} else {
-			struct ahd_devinfo devinfo;
-#ifdef AHD_DEBUG
-			if ((ahd_debug & AHD_SHOW_SELTO) != 0) {
-				ahd_print_path(ahd, scb);
-				printf("Saw Selection Timeout for SCB 0x%x\n",
-				       scbid);
-			}
-#endif
-			/*
-			 * Force a renegotiation with this target just in
-			 * case the cable was pulled and will later be
-			 * re-attached.  The target may forget its negotiation
-			 * settings with us should it attempt to reselect
-			 * during the interruption.  The target will not issue
-			 * a unit attention in this case, so we must always
-			 * renegotiate.
-			 */
-			ahd_scb_devinfo(ahd, &devinfo, scb);
-			ahd_force_renegotiation(ahd, &devinfo);
-			ahd_set_transaction_status(scb, CAM_SEL_TIMEOUT);
-			ahd_freeze_devq(ahd, scb);
-		}
-		ahd_outb(ahd, CLRINT, CLRSCSIINT);
-		ahd_iocell_first_selection(ahd);
-		ahd_unpause(ahd);
-	} else if ((status0 & (SELDI|SELDO)) != 0) {
-		ahd_iocell_first_selection(ahd);
-		ahd_unpause(ahd);
-	} else if (status3 != 0) {
-		printf("%s: SCSI Cell parity error SSTAT3 == 0x%x\n",
-		       ahd_name(ahd), status3);
-		ahd_outb(ahd, CLRSINT3, status3);
-	} else if ((lqistat1 & (LQIPHASE_LQ|LQIPHASE_NLQ)) != 0) {
-		ahd_handle_lqiphase_error(ahd, lqistat1);
-	} else if ((status & BUSFREE) != 0) {
-		u_int lqostat1;
-		int   restart;
-		int   clear_fifo;
-		int   packetized;
-		u_int mode;
-
-		/*
-		 * Clear our selection hardware as soon as possible.
-		 * We may have an entry in the waiting Q for this target,
-		 * that is affected by this busfree and we don't want to
-		 * go about selecting the target while we handle the event.
-		 */
-		ahd_outb(ahd, SCSISEQ0, 0);
-
-		/*
-		 * Determine what we were up to at the time of
-		 * the busfree.
-		 */
-		mode = AHD_MODE_SCSI;
-		busfreetime = ahd_inb(ahd, SSTAT2) & BUSFREETIME;
-		lqostat1 = ahd_inb(ahd, LQOSTAT1);
-		switch (busfreetime) {
-		case BUSFREE_DFF0:
-		case BUSFREE_DFF1:
-		{
-			u_int	scbid;
-			struct	scb *scb;
-
-			mode = busfreetime == BUSFREE_DFF0
-			     ? AHD_MODE_DFF0 : AHD_MODE_DFF1;
-			ahd_set_modes(ahd, mode, mode);
-			scbid = ahd_get_scbptr(ahd);
-			scb = ahd_lookup_scb(ahd, scbid);
-			if (scb == NULL) {
-				printf("%s: Invalid SCB in DFF%d "
-				       "during unexpected busfree\n",
-				       ahd_name(ahd), mode);
-				packetized = 0;
-			} else
-				packetized = (scb->flags & SCB_PACKETIZED) != 0;
-			clear_fifo = 1;
-			break;
-		}
-		case BUSFREE_LQO:
-			clear_fifo = 0;
-			packetized = 1;
-			break;
-		default:
-			clear_fifo = 0;
-			packetized =  (lqostat1 & LQOBUSFREE) != 0;
-			if (!packetized
-			 && ahd_inb(ahd, LASTPHASE) == P_BUSFREE)
-				packetized = 1;
-			break;
-		}
-
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_MISC) != 0)
-			printf("Saw Busfree.  Busfreetime = 0x%x.\n",
-			       busfreetime);
-#endif
-		/*
-		 * Busfrees that occur in non-packetized phases are
-		 * handled by the nonpkt_busfree handler.
-		 */
-		if (packetized && ahd_inb(ahd, LASTPHASE) == P_BUSFREE) {
-			restart = ahd_handle_pkt_busfree(ahd, busfreetime);
-		} else {
-			packetized = 0;
-			restart = ahd_handle_nonpkt_busfree(ahd);
-		}
-		/*
-		 * Clear the busfree interrupt status.  The setting of
-		 * the interrupt is a pulse, so in a perfect world, we
-		 * would not need to muck with the ENBUSFREE logic.  This
-		 * would ensure that if the bus moves on to another
-		 * connection, busfree protection is still in force.  If
-		 * BUSFREEREV is broken, however, we must manually clear
-		 * the ENBUSFREE if the busfree occurred during a non-pack
-		 * connection so that we don't get false positives during
-		 * future, packetized, connections.
-		 */
-		ahd_outb(ahd, CLRSINT1, CLRBUSFREE);
-		if (packetized == 0
-		 && (ahd->bugs & AHD_BUSFREEREV_BUG) != 0)
-			ahd_outb(ahd, SIMODE1,
-				 ahd_inb(ahd, SIMODE1) & ~ENBUSFREE);
-
-		if (clear_fifo)
-			ahd_clear_fifo(ahd, mode);
-
-		ahd_clear_msg_state(ahd);
-		ahd_outb(ahd, CLRINT, CLRSCSIINT);
-		if (restart) {
-			ahd_restart(ahd);
-		} else {
-			ahd_unpause(ahd);
-		}
-	} else {
-		printf("%s: Missing case in ahd_handle_scsiint. status = %x\n",
-		       ahd_name(ahd), status);
-		ahd_dump_card_state(ahd);
-		ahd_clear_intstat(ahd);
-		ahd_unpause(ahd);
-	}
-}
-
-static void
-ahd_handle_transmission_error(struct ahd_softc *ahd)
-{
-	struct	scb *scb;
-	u_int	scbid;
-	u_int	lqistat1;
-	u_int	lqistat2;
-	u_int	msg_out;
-	u_int	curphase;
-	u_int	lastphase;
-	u_int	perrdiag;
-	u_int	cur_col;
-	int	silent;
-
-	scb = NULL;
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	lqistat1 = ahd_inb(ahd, LQISTAT1) & ~(LQIPHASE_LQ|LQIPHASE_NLQ);
-	lqistat2 = ahd_inb(ahd, LQISTAT2);
-	if ((lqistat1 & (LQICRCI_NLQ|LQICRCI_LQ)) == 0
-	 && (ahd->bugs & AHD_NLQICRC_DELAYED_BUG) != 0) {
-		u_int lqistate;
-
-		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
-		lqistate = ahd_inb(ahd, LQISTATE);
-		if ((lqistate >= 0x1E && lqistate <= 0x24)
-		 || (lqistate == 0x29)) {
-#ifdef AHD_DEBUG
-			if ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {
-				printf("%s: NLQCRC found via LQISTATE\n",
-				       ahd_name(ahd));
-			}
-#endif
-			lqistat1 |= LQICRCI_NLQ;
-		}
-		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	}
-
-	ahd_outb(ahd, CLRLQIINT1, lqistat1);
-	lastphase = ahd_inb(ahd, LASTPHASE);
-	curphase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;
-	perrdiag = ahd_inb(ahd, PERRDIAG);
-	msg_out = MSG_INITIATOR_DET_ERR;
-	ahd_outb(ahd, CLRSINT1, CLRSCSIPERR);
-	
-	/*
-	 * Try to find the SCB associated with this error.
-	 */
-	silent = FALSE;
-	if (lqistat1 == 0
-	 || (lqistat1 & LQICRCI_NLQ) != 0) {
-	 	if ((lqistat1 & (LQICRCI_NLQ|LQIOVERI_NLQ)) != 0)
-			ahd_set_active_fifo(ahd);
-		scbid = ahd_get_scbptr(ahd);
-		scb = ahd_lookup_scb(ahd, scbid);
-		if (scb != NULL && SCB_IS_SILENT(scb))
-			silent = TRUE;
-	}
-
-	cur_col = 0;
-	if (silent == FALSE) {
-		printf("%s: Transmission error detected\n", ahd_name(ahd));
-		ahd_lqistat1_print(lqistat1, &cur_col, 50);
-		ahd_lastphase_print(lastphase, &cur_col, 50);
-		ahd_scsisigi_print(curphase, &cur_col, 50);
-		ahd_perrdiag_print(perrdiag, &cur_col, 50);
-		printf("\n");
-		ahd_dump_card_state(ahd);
-	}
-
-	if ((lqistat1 & (LQIOVERI_LQ|LQIOVERI_NLQ)) != 0) {
-		if (silent == FALSE) {
-			printf("%s: Gross protocol error during incoming "
-			       "packet.  lqistat1 == 0x%x.  Resetting bus.\n",
-			       ahd_name(ahd), lqistat1);
-		}
-		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
-		return;
-	} else if ((lqistat1 & LQICRCI_LQ) != 0) {
-		/*
-		 * A CRC error has been detected on an incoming LQ.
-		 * The bus is currently hung on the last ACK.
-		 * Hit LQIRETRY to release the last ack, and
-		 * wait for the sequencer to determine that ATNO
-		 * is asserted while in message out to take us
-		 * to our host message loop.  No NONPACKREQ or
-		 * LQIPHASE type errors will occur in this
-		 * scenario.  After this first LQIRETRY, the LQI
-		 * manager will be in ISELO where it will
-		 * happily sit until another packet phase begins.
-		 * Unexpected bus free detection is enabled
-		 * through any phases that occur after we release
-		 * this last ack until the LQI manager sees a
-		 * packet phase.  This implies we may have to
-		 * ignore a perfectly valid "unexected busfree"
-		 * after our "initiator detected error" message is
-		 * sent.  A busfree is the expected response after
-		 * we tell the target that it's L_Q was corrupted.
-		 * (SPI4R09 10.7.3.3.3)
-		 */
-		ahd_outb(ahd, LQCTL2, LQIRETRY);
-		printf("LQIRetry for LQICRCI_LQ to release ACK\n");
-	} else if ((lqistat1 & LQICRCI_NLQ) != 0) {
-		/*
-		 * We detected a CRC error in a NON-LQ packet.
-		 * The hardware has varying behavior in this situation
-		 * depending on whether this packet was part of a
-		 * stream or not.
-		 *
-		 * PKT by PKT mode:
-		 * The hardware has already acked the complete packet.
-		 * If the target honors our outstanding ATN condition,
-		 * we should be (or soon will be) in MSGOUT phase.
-		 * This will trigger the LQIPHASE_LQ status bit as the
-		 * hardware was expecting another LQ.  Unexpected
-		 * busfree detection is enabled.  Once LQIPHASE_LQ is
-		 * true (first entry into host message loop is much
-		 * the same), we must clear LQIPHASE_LQ and hit
-		 * LQIRETRY so the hardware is ready to handle
-		 * a future LQ.  NONPACKREQ will not be asserted again
-		 * once we hit LQIRETRY until another packet is
-		 * processed.  The target may either go busfree
-		 * or start another packet in response to our message.
-		 *
-		 * Read Streaming P0 asserted:
-		 * If we raise ATN and the target completes the entire
-		 * stream (P0 asserted during the last packet), the
-		 * hardware will ack all data and return to the ISTART
-		 * state.  When the target reponds to our ATN condition,
-		 * LQIPHASE_LQ will be asserted.  We should respond to
-		 * this with an LQIRETRY to prepare for any future
-		 * packets.  NONPACKREQ will not be asserted again
-		 * once we hit LQIRETRY until another packet is
-		 * processed.  The target may either go busfree or
-		 * start another packet in response to our message.
-		 * Busfree detection is enabled.
-		 *
-		 * Read Streaming P0 not asserted:
-		 * If we raise ATN and the target transitions to
-		 * MSGOUT in or after a packet where P0 is not
-		 * asserted, the hardware will assert LQIPHASE_NLQ.
-		 * We should respond to the LQIPHASE_NLQ with an
-		 * LQIRETRY.  Should the target stay in a non-pkt
-		 * phase after we send our message, the hardware
-		 * will assert LQIPHASE_LQ.  Recovery is then just as
-		 * listed above for the read streaming with P0 asserted.
-		 * Busfree detection is enabled.
-		 */
-		if (silent == FALSE)
-			printf("LQICRC_NLQ\n");
-		if (scb == NULL) {
-			printf("%s: No SCB valid for LQICRC_NLQ.  "
-			       "Resetting bus\n", ahd_name(ahd));
-			ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
-			return;
-		}
-	} else if ((lqistat1 & LQIBADLQI) != 0) {
-		printf("Need to handle BADLQI!\n");
-		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
-		return;
-	} else if ((perrdiag & (PARITYERR|PREVPHASE)) == PARITYERR) {
-		if ((curphase & ~P_DATAIN_DT) != 0) {
-			/* Ack the byte.  So we can continue. */
-			if (silent == FALSE)
-				printf("Acking %s to clear perror\n",
-				    ahd_lookup_phase_entry(curphase)->phasemsg);
-			ahd_inb(ahd, SCSIDAT);
-		}
-	
-		if (curphase == P_MESGIN)
-			msg_out = MSG_PARITY_ERROR;
-	}
-
-	/*
-	 * We've set the hardware to assert ATN if we 
-	 * get a parity error on "in" phases, so all we
-	 * need to do is stuff the message buffer with
-	 * the appropriate message.  "In" phases have set
-	 * mesg_out to something other than MSG_NOP.
-	 */
-	ahd->send_msg_perror = msg_out;
-	if (scb != NULL && msg_out == MSG_INITIATOR_DET_ERR)
-		scb->flags |= SCB_TRANSMISSION_ERROR;
-	ahd_outb(ahd, MSG_OUT, HOST_MSG);
-	ahd_outb(ahd, CLRINT, CLRSCSIINT);
-	ahd_unpause(ahd);
-}
-
-static void
-ahd_handle_lqiphase_error(struct ahd_softc *ahd, u_int lqistat1)
-{
-	/*
-	 * Clear the sources of the interrupts.
-	 */
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	ahd_outb(ahd, CLRLQIINT1, lqistat1);
-
-	/*
-	 * If the "illegal" phase changes were in response
-	 * to our ATN to flag a CRC error, AND we ended up
-	 * on packet boundaries, clear the error, restart the
-	 * LQI manager as appropriate, and go on our merry
-	 * way toward sending the message.  Otherwise, reset
-	 * the bus to clear the error.
-	 */
-	ahd_set_active_fifo(ahd);
-	if ((ahd_inb(ahd, SCSISIGO) & ATNO) != 0
-	 && (ahd_inb(ahd, MDFFSTAT) & DLZERO) != 0) {
-		if ((lqistat1 & LQIPHASE_LQ) != 0) {
-			printf("LQIRETRY for LQIPHASE_LQ\n");
-			ahd_outb(ahd, LQCTL2, LQIRETRY);
-		} else if ((lqistat1 & LQIPHASE_NLQ) != 0) {
-			printf("LQIRETRY for LQIPHASE_NLQ\n");
-			ahd_outb(ahd, LQCTL2, LQIRETRY);
-		} else
-			panic("ahd_handle_lqiphase_error: No phase errors\n");
-		ahd_dump_card_state(ahd);
-		ahd_outb(ahd, CLRINT, CLRSCSIINT);
-		ahd_unpause(ahd);
-	} else {
-		printf("Reseting Channel for LQI Phase error\n");
-		ahd_dump_card_state(ahd);
-		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
-	}
-}
-
-/*
- * Packetized unexpected or expected busfree.
- * Entered in mode based on busfreetime.
- */
-static int
-ahd_handle_pkt_busfree(struct ahd_softc *ahd, u_int busfreetime)
-{
-	u_int lqostat1;
-
-	AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
-			 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
-	lqostat1 = ahd_inb(ahd, LQOSTAT1);
-	if ((lqostat1 & LQOBUSFREE) != 0) {
-		struct scb *scb;
-		u_int scbid;
-		u_int saved_scbptr;
-		u_int waiting_h;
-		u_int waiting_t;
-		u_int next;
-
-		if ((busfreetime & BUSFREE_LQO) == 0)
-			printf("%s: Warning, BUSFREE time is 0x%x.  "
-			       "Expected BUSFREE_LQO.\n",
-			       ahd_name(ahd), busfreetime);
-		/*
-		 * The LQO manager detected an unexpected busfree
-		 * either:
-		 *
-		 * 1) During an outgoing LQ.
-		 * 2) After an outgoing LQ but before the first
-		 *    REQ of the command packet.
-		 * 3) During an outgoing command packet.
-		 *
-		 * In all cases, CURRSCB is pointing to the
-		 * SCB that encountered the failure.  Clean
-		 * up the queue, clear SELDO and LQOBUSFREE,
-		 * and allow the sequencer to restart the select
-		 * out at its lesure.
-		 */
-		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-		scbid = ahd_inw(ahd, CURRSCB);
-		scb = ahd_lookup_scb(ahd, scbid);
-		if (scb == NULL)
-		       panic("SCB not valid during LQOBUSFREE");
-		/*
-		 * Return the LQO manager to its idle loop.  It will
-		 * not do this automatically if the busfree occurs
-		 * after the first REQ of either the LQ or command
-		 * packet or between the LQ and command packet.
-		 */
-		ahd_outb(ahd, LQCTL2, ahd_inb(ahd, LQCTL2) | LQOTOIDLE);
-
-		/*
-		 * Clear the status.
-		 */
-		ahd_outb(ahd, CLRLQOINT1, CLRLQOBUSFREE);
-		if ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0)
-			ahd_outb(ahd, CLRLQOINT1, 0);
-		ahd_outb(ahd, SCSISEQ0, ahd_inb(ahd, SCSISEQ0) & ~ENSELO);
-		ahd_outb(ahd, CLRSINT0, CLRSELDO);
-
-		/*
-		 * Update the waiting for selection queue so
-		 * we restart on the correct SCB.
-		 */
-		waiting_h = ahd_inw(ahd, WAITING_TID_HEAD);
-		saved_scbptr = ahd_get_scbptr(ahd);
-		if (waiting_h != scbid) {
-
-			ahd_outw(ahd, WAITING_TID_HEAD, scbid);
-			waiting_t = ahd_inw(ahd, WAITING_TID_TAIL);
-			next = SCB_LIST_NULL;
-			if (waiting_t == waiting_h) {
-				ahd_outw(ahd, WAITING_TID_TAIL, scbid);
-			} else {
-				ahd_set_scbptr(ahd, waiting_h);
-				next = ahd_inw(ahd, SCB_NEXT2);
-			}
-			ahd_set_scbptr(ahd, scbid);
-			ahd_outw(ahd, SCB_NEXT2, next);
-		}
-		ahd_set_scbptr(ahd, saved_scbptr);
-		if (scb->crc_retry_count < AHD_MAX_LQ_CRC_ERRORS) {
-			if (SCB_IS_SILENT(scb) == FALSE) {
-				ahd_print_path(ahd, scb);
-				printf("Probable outgoing LQ CRC error.  "
-				       "Retrying command\n");
-			}
-			scb->crc_retry_count++;
-		} else {
-			ahd_set_transaction_status(scb, CAM_UNCOR_PARITY);
-			ahd_freeze_scb(scb);
-			ahd_freeze_devq(ahd, scb);
-		}
-		/* Return unpausing the sequencer. */
-		return (0);
-	} else if ((ahd_inb(ahd, PERRDIAG) & PARITYERR) != 0) {
-		/*
-		 * Ignore what are really parity errors that
-		 * occur on the last REQ of a free running
-		 * clock prior to going busfree.  Some drives
-		 * do not properly active negate just before
-		 * going busfree resulting in a parity glitch.
-		 */
-		ahd_outb(ahd, CLRSINT1, CLRSCSIPERR|CLRBUSFREE);
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_MASKED_ERRORS) != 0)
-			printf("%s: Parity on last REQ detected "
-			       "during busfree phase.\n",
-			       ahd_name(ahd));
-#endif
-		/* Return unpausing the sequencer. */
-		return (0);
-	}
-	if (ahd->src_mode != AHD_MODE_SCSI) {
-		u_int	scbid;
-		struct	scb *scb;
-
-		scbid = ahd_get_scbptr(ahd);
-		scb = ahd_lookup_scb(ahd, scbid);
-		ahd_print_path(ahd, scb);
-		printf("Unexpected PKT busfree condition\n");
-		ahd_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb), 'A',
-			       SCB_GET_LUN(scb), SCB_GET_TAG(scb),
-			       ROLE_INITIATOR, CAM_UNEXP_BUSFREE);
-
-		/* Return restarting the sequencer. */
-		return (1);
-	}
-	printf("%s: Unexpected PKT busfree condition\n", ahd_name(ahd));
-	ahd_dump_card_state(ahd);
-	/* Restart the sequencer. */
-	return (1);
-}
-
-/*
- * Non-packetized unexpected or expected busfree.
- */
-static int
-ahd_handle_nonpkt_busfree(struct ahd_softc *ahd)
-{
-	struct	ahd_devinfo devinfo;
-	struct	scb *scb;
-	u_int	lastphase;
-	u_int	saved_scsiid;
-	u_int	saved_lun;
-	u_int	target;
-	u_int	initiator_role_id;
-	u_int	scbid;
-	u_int	ppr_busfree;
-	int	printerror;
-
-	/*
-	 * Look at what phase we were last in.  If its message out,
-	 * chances are pretty good that the busfree was in response
-	 * to one of our abort requests.
-	 */
-	lastphase = ahd_inb(ahd, LASTPHASE);
-	saved_scsiid = ahd_inb(ahd, SAVED_SCSIID);
-	saved_lun = ahd_inb(ahd, SAVED_LUN);
-	target = SCSIID_TARGET(ahd, saved_scsiid);
-	initiator_role_id = SCSIID_OUR_ID(saved_scsiid);
-	ahd_compile_devinfo(&devinfo, initiator_role_id,
-			    target, saved_lun, 'A', ROLE_INITIATOR);
-	printerror = 1;
-
-	scbid = ahd_get_scbptr(ahd);
-	scb = ahd_lookup_scb(ahd, scbid);
-	if (scb != NULL
-	 && (ahd_inb(ahd, SEQ_FLAGS) & NOT_IDENTIFIED) != 0)
-		scb = NULL;
-
-	ppr_busfree = (ahd->msg_flags & MSG_FLAG_EXPECT_PPR_BUSFREE) != 0;
-	if (lastphase == P_MESGOUT) {
-		u_int tag;
-
-		tag = SCB_LIST_NULL;
-		if (ahd_sent_msg(ahd, AHDMSG_1B, MSG_ABORT_TAG, TRUE)
-		 || ahd_sent_msg(ahd, AHDMSG_1B, MSG_ABORT, TRUE)) {
-			int found;
-			int sent_msg;
-
-			if (scb == NULL) {
-				ahd_print_devinfo(ahd, &devinfo);
-				printf("Abort for unidentified "
-				       "connection completed.\n");
-				/* restart the sequencer. */
-				return (1);
-			}
-			sent_msg = ahd->msgout_buf[ahd->msgout_index - 1];
-			ahd_print_path(ahd, scb);
-			printf("SCB %d - Abort%s Completed.\n",
-			       SCB_GET_TAG(scb),
-			       sent_msg == MSG_ABORT_TAG ? "" : " Tag");
-
-			if (sent_msg == MSG_ABORT_TAG)
-				tag = SCB_GET_TAG(scb);
-
-			if ((scb->flags & SCB_CMDPHASE_ABORT) != 0) {
-				/*
-				 * This abort is in response to an
-				 * unexpected switch to command phase
-				 * for a packetized connection.  Since
-				 * the identify message was never sent,
-				 * "saved lun" is 0.  We really want to
-				 * abort only the SCB that encountered
-				 * this error, which could have a different
-				 * lun.  The SCB will be retried so the OS
-				 * will see the UA after renegotiating to
-				 * packetized.
-				 */
-				tag = SCB_GET_TAG(scb);
-				saved_lun = scb->hscb->lun;
-			}
-			found = ahd_abort_scbs(ahd, target, 'A', saved_lun,
-					       tag, ROLE_INITIATOR,
-					       CAM_REQ_ABORTED);
-			printf("found == 0x%x\n", found);
-			printerror = 0;
-		} else if (ahd_sent_msg(ahd, AHDMSG_1B,
-					MSG_BUS_DEV_RESET, TRUE)) {
-#ifdef __FreeBSD__
-			/*
-			 * Don't mark the user's request for this BDR
-			 * as completing with CAM_BDR_SENT.  CAM3
-			 * specifies CAM_REQ_CMP.
-			 */
-			if (scb != NULL
-			 && scb->io_ctx->ccb_h.func_code== XPT_RESET_DEV
-			 && ahd_match_scb(ahd, scb, target, 'A',
-					  CAM_LUN_WILDCARD, SCB_LIST_NULL,
-					  ROLE_INITIATOR))
-				ahd_set_transaction_status(scb, CAM_REQ_CMP);
-#endif
-			ahd_handle_devreset(ahd, &devinfo, CAM_LUN_WILDCARD,
-					    CAM_BDR_SENT, "Bus Device Reset",
-					    /*verbose_level*/0);
-			printerror = 0;
-		} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_PPR, FALSE)
-			&& ppr_busfree == 0) {
-			struct ahd_initiator_tinfo *tinfo;
-			struct ahd_tmode_tstate *tstate;
-
-			/*
-			 * PPR Rejected.  Try non-ppr negotiation
-			 * and retry command.
-			 */
-#ifdef AHD_DEBUG
-			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
-				printf("PPR negotiation rejected busfree.\n");
-#endif
-			tinfo = ahd_fetch_transinfo(ahd, devinfo.channel,
-						    devinfo.our_scsiid,
-						    devinfo.target, &tstate);
-			tinfo->curr.transport_version = 2;
-			tinfo->goal.transport_version = 2;
-			tinfo->goal.ppr_options = 0;
-			ahd_qinfifo_requeue_tail(ahd, scb);
-			printerror = 0;
-		} else if ((ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_WDTR, FALSE)
-			 || ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_SDTR, FALSE))
-			&& ppr_busfree == 0) {
-			/*
-			 * Negotiation Rejected.  Go-async and
-			 * retry command.
-			 */
-#ifdef AHD_DEBUG
-			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
-				printf("Negotiation rejected busfree.\n");
-#endif
-			ahd_set_width(ahd, &devinfo,
-				      MSG_EXT_WDTR_BUS_8_BIT,
-				      AHD_TRANS_CUR|AHD_TRANS_GOAL,
-				      /*paused*/TRUE);
-			ahd_set_syncrate(ahd, &devinfo,
-					/*period*/0, /*offset*/0,
-					/*ppr_options*/0,
-					AHD_TRANS_CUR|AHD_TRANS_GOAL,
-					/*paused*/TRUE);
-			ahd_qinfifo_requeue_tail(ahd, scb);
-			printerror = 0;
-		} else if ((ahd->msg_flags & MSG_FLAG_EXPECT_IDE_BUSFREE) != 0
-			&& ahd_sent_msg(ahd, AHDMSG_1B,
-					 MSG_INITIATOR_DET_ERR, TRUE)) {
-
-#ifdef AHD_DEBUG
-			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
-				printf("Expected IDE Busfree\n");
-#endif
-			printerror = 0;
-		} else if ((ahd->msg_flags & MSG_FLAG_EXPECT_QASREJ_BUSFREE)
-			&& ahd_sent_msg(ahd, AHDMSG_1B,
-					MSG_MESSAGE_REJECT, TRUE)) {
-
-#ifdef AHD_DEBUG
-			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
-				printf("Expected QAS Reject Busfree\n");
-#endif
-			printerror = 0;
-		}
-	}
-
-	/*
-	 * The busfree required flag is honored at the end of
-	 * the message phases.  We check it last in case we
-	 * had to send some other message that caused a busfree.
-	 */
-	if (printerror != 0
-	 && (lastphase == P_MESGIN || lastphase == P_MESGOUT)
-	 && ((ahd->msg_flags & MSG_FLAG_EXPECT_PPR_BUSFREE) != 0)) {
-
-		ahd_freeze_devq(ahd, scb);
-		ahd_set_transaction_status(scb, CAM_REQUEUE_REQ);
-		ahd_freeze_scb(scb);
-		if ((ahd->msg_flags & MSG_FLAG_IU_REQ_CHANGED) != 0) {
-			ahd_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),
-				       SCB_GET_CHANNEL(ahd, scb),
-				       SCB_GET_LUN(scb), SCB_LIST_NULL,
-				       ROLE_INITIATOR, CAM_REQ_ABORTED);
-		} else {
-#ifdef AHD_DEBUG
-			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
-				printf("PPR Negotiation Busfree.\n");
-#endif
-			ahd_done(ahd, scb);
-		}
-		printerror = 0;
-	}
-	if (printerror != 0) {
-		int aborted;
-
-		aborted = 0;
-		if (scb != NULL) {
-			u_int tag;
-
-			if ((scb->hscb->control & TAG_ENB) != 0)
-				tag = SCB_GET_TAG(scb);
-			else
-				tag = SCB_LIST_NULL;
-			ahd_print_path(ahd, scb);
-			aborted = ahd_abort_scbs(ahd, target, 'A',
-				       SCB_GET_LUN(scb), tag,
-				       ROLE_INITIATOR,
-				       CAM_UNEXP_BUSFREE);
-		} else {
-			/*
-			 * We had not fully identified this connection,
-			 * so we cannot abort anything.
-			 */
-			printf("%s: ", ahd_name(ahd));
-		}
-		if (lastphase != P_BUSFREE)
-			ahd_force_renegotiation(ahd, &devinfo);
-		printf("Unexpected busfree %s, %d SCBs aborted, "
-		       "PRGMCNT == 0x%x\n",
-		       ahd_lookup_phase_entry(lastphase)->phasemsg,
-		       aborted,
-		       ahd_inb(ahd, PRGMCNT)
-			| (ahd_inb(ahd, PRGMCNT+1) << 8));
-		ahd_dump_card_state(ahd);
-	}
-	/* Always restart the sequencer. */
-	return (1);
-}
-
-static void
-ahd_handle_proto_violation(struct ahd_softc *ahd)
-{
-	struct	ahd_devinfo devinfo;
-	struct	scb *scb;
-	u_int	scbid;
-	u_int	seq_flags;
-	u_int	curphase;
-	u_int	lastphase;
-	int	found;
-
-	ahd_fetch_devinfo(ahd, &devinfo);
-	scbid = ahd_get_scbptr(ahd);
-	scb = ahd_lookup_scb(ahd, scbid);
-	seq_flags = ahd_inb(ahd, SEQ_FLAGS);
-	curphase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;
-	lastphase = ahd_inb(ahd, LASTPHASE);
-	if ((seq_flags & NOT_IDENTIFIED) != 0) {
-
-		/*
-		 * The reconnecting target either did not send an
-		 * identify message, or did, but we didn't find an SCB
-		 * to match.
-		 */
-		ahd_print_devinfo(ahd, &devinfo);
-		printf("Target did not send an IDENTIFY message. "
-		       "LASTPHASE = 0x%x.\n", lastphase);
-		scb = NULL;
-	} else if (scb == NULL) {
-		/*
-		 * We don't seem to have an SCB active for this
-		 * transaction.  Print an error and reset the bus.
-		 */
-		ahd_print_devinfo(ahd, &devinfo);
-		printf("No SCB found during protocol violation\n");
-		goto proto_violation_reset;
-	} else {
-		ahd_set_transaction_status(scb, CAM_SEQUENCE_FAIL);
-		if ((seq_flags & NO_CDB_SENT) != 0) {
-			ahd_print_path(ahd, scb);
-			printf("No or incomplete CDB sent to device.\n");
-		} else if ((ahd_inb(ahd, SCB_CONTROL) & STATUS_RCVD) == 0) {
-			/*
-			 * The target never bothered to provide status to
-			 * us prior to completing the command.  Since we don't
-			 * know the disposition of this command, we must attempt
-			 * to abort it.  Assert ATN and prepare to send an abort
-			 * message.
-			 */
-			ahd_print_path(ahd, scb);
-			printf("Completed command without status.\n");
-		} else {
-			ahd_print_path(ahd, scb);
-			printf("Unknown protocol violation.\n");
-			ahd_dump_card_state(ahd);
-		}
-	}
-	if ((lastphase & ~P_DATAIN_DT) == 0
-	 || lastphase == P_COMMAND) {
-proto_violation_reset:
-		/*
-		 * Target either went directly to data
-		 * phase or didn't respond to our ATN.
-		 * The only safe thing to do is to blow
-		 * it away with a bus reset.
-		 */
-		found = ahd_reset_channel(ahd, 'A', TRUE);
-		printf("%s: Issued Channel %c Bus Reset. "
-		       "%d SCBs aborted\n", ahd_name(ahd), 'A', found);
-	} else {
-		/*
-		 * Leave the selection hardware off in case
-		 * this abort attempt will affect yet to
-		 * be sent commands.
-		 */
-		ahd_outb(ahd, SCSISEQ0,
-			 ahd_inb(ahd, SCSISEQ0) & ~ENSELO);
-		ahd_assert_atn(ahd);
-		ahd_outb(ahd, MSG_OUT, HOST_MSG);
-		if (scb == NULL) {
-			ahd_print_devinfo(ahd, &devinfo);
-			ahd->msgout_buf[0] = MSG_ABORT_TASK;
-			ahd->msgout_len = 1;
-			ahd->msgout_index = 0;
-			ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
-		} else {
-			ahd_print_path(ahd, scb);
-			scb->flags |= SCB_ABORT;
-		}
-		printf("Protocol violation %s.  Attempting to abort.\n",
-		       ahd_lookup_phase_entry(curphase)->phasemsg);
-	}
-}
-
-/*
- * Force renegotiation to occur the next time we initiate
- * a command to the current device.
- */
-static void
-ahd_force_renegotiation(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
-{
-	struct	ahd_initiator_tinfo *targ_info;
-	struct	ahd_tmode_tstate *tstate;
-
-#ifdef AHD_DEBUG
-	if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
-		ahd_print_devinfo(ahd, devinfo);
-		printf("Forcing renegotiation\n");
-	}
-#endif
-	targ_info = ahd_fetch_transinfo(ahd,
-					devinfo->channel,
-					devinfo->our_scsiid,
-					devinfo->target,
-					&tstate);
-	ahd_update_neg_request(ahd, devinfo, tstate,
-			       targ_info, AHD_NEG_IF_NON_ASYNC);
-}
-
-#define AHD_MAX_STEPS 2000
-void
-ahd_clear_critical_section(struct ahd_softc *ahd)
-{
-	ahd_mode_state	saved_modes;
-	int		stepping;
-	int		steps;
-	int		first_instr;
-	u_int		simode0;
-	u_int		simode1;
-	u_int		simode3;
-	u_int		lqimode0;
-	u_int		lqimode1;
-	u_int		lqomode0;
-	u_int		lqomode1;
-
-	if (ahd->num_critical_sections == 0)
-		return;
-
-	stepping = FALSE;
-	steps = 0;
-	first_instr = 0;
-	simode0 = 0;
-	simode1 = 0;
-	simode3 = 0;
-	lqimode0 = 0;
-	lqimode1 = 0;
-	lqomode0 = 0;
-	lqomode1 = 0;
-	saved_modes = ahd_save_modes(ahd);
-	for (;;) {
-		struct	cs *cs;
-		u_int	seqaddr;
-		u_int	i;
-
-		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-		seqaddr = ahd_inb(ahd, CURADDR)
-			| (ahd_inb(ahd, CURADDR+1) << 8);
-
-		cs = ahd->critical_sections;
-		for (i = 0; i < ahd->num_critical_sections; i++, cs++) {
-			
-			if (cs->begin < seqaddr && cs->end >= seqaddr)
-				break;
-		}
-
-		if (i == ahd->num_critical_sections)
-			break;
-
-		if (steps > AHD_MAX_STEPS) {
-			printf("%s: Infinite loop in critical section\n"
-			       "%s: First Instruction 0x%x now 0x%x\n",
-			       ahd_name(ahd), ahd_name(ahd), first_instr,
-			       seqaddr);
-			ahd_dump_card_state(ahd);
-			panic("critical section loop");
-		}
-
-		steps++;
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_MISC) != 0)
-			printf("%s: Single stepping at 0x%x\n", ahd_name(ahd),
-			       seqaddr);
-#endif
-		if (stepping == FALSE) {
-
-			first_instr = seqaddr;
-  			ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
-  			simode0 = ahd_inb(ahd, SIMODE0);
-			simode3 = ahd_inb(ahd, SIMODE3);
-			lqimode0 = ahd_inb(ahd, LQIMODE0);
-			lqimode1 = ahd_inb(ahd, LQIMODE1);
-			lqomode0 = ahd_inb(ahd, LQOMODE0);
-			lqomode1 = ahd_inb(ahd, LQOMODE1);
-			ahd_outb(ahd, SIMODE0, 0);
-			ahd_outb(ahd, SIMODE3, 0);
-			ahd_outb(ahd, LQIMODE0, 0);
-			ahd_outb(ahd, LQIMODE1, 0);
-			ahd_outb(ahd, LQOMODE0, 0);
-			ahd_outb(ahd, LQOMODE1, 0);
-			ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-  			simode1 = ahd_inb(ahd, SIMODE1);
-  			ahd_outb(ahd, SIMODE1, ENBUSFREE);
-			ahd_outb(ahd, SEQCTL0, ahd_inb(ahd, SEQCTL0) | STEP);
-			stepping = TRUE;
-		}
-		ahd_outb(ahd, CLRSINT1, CLRBUSFREE);
-		ahd_outb(ahd, CLRINT, CLRSCSIINT);
-		ahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);
-		ahd_outb(ahd, HCNTRL, ahd->unpause);
-		do {
-			ahd_delay(200);
-		} while (!ahd_is_paused(ahd));
-		ahd_update_modes(ahd);
-	}
-	if (stepping) {
-		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
-		ahd_outb(ahd, SIMODE0, simode0);
-		ahd_outb(ahd, SIMODE3, simode3);
-		ahd_outb(ahd, LQIMODE0, lqimode0);
-		ahd_outb(ahd, LQIMODE1, lqimode1);
-		ahd_outb(ahd, LQOMODE0, lqomode0);
-		ahd_outb(ahd, LQOMODE1, lqomode1);
-		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-		ahd_outb(ahd, SEQCTL0, ahd_inb(ahd, SEQCTL0) & ~STEP);
-  		ahd_outb(ahd, SIMODE1, simode1);
-	}
-	ahd_restore_modes(ahd, saved_modes);
-}
-
-/*
- * Clear any pending interrupt status.
- */
-void
-ahd_clear_intstat(struct ahd_softc *ahd)
-{
-	AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
-			 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
-	/* Clear any interrupt conditions this may have caused */
-	ahd_outb(ahd, CLRLQIINT0, CLRLQIATNQAS|CLRLQICRCT1|CLRLQICRCT2
-				 |CLRLQIBADLQT|CLRLQIATNLQ|CLRLQIATNCMD);
-	ahd_outb(ahd, CLRLQIINT1, CLRLQIPHASE_LQ|CLRLQIPHASE_NLQ|CLRLIQABORT
-				 |CLRLQICRCI_LQ|CLRLQICRCI_NLQ|CLRLQIBADLQI
-				 |CLRLQIOVERI_LQ|CLRLQIOVERI_NLQ|CLRNONPACKREQ);
-	ahd_outb(ahd, CLRLQOINT0, CLRLQOTARGSCBPERR|CLRLQOSTOPT2|CLRLQOATNLQ
-				 |CLRLQOATNPKT|CLRLQOTCRC);
-	ahd_outb(ahd, CLRLQOINT1, CLRLQOINITSCBPERR|CLRLQOSTOPI2|CLRLQOBADQAS
-				 |CLRLQOBUSFREE|CLRLQOPHACHGINPKT);
-	if ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0) {
-		ahd_outb(ahd, CLRLQOINT0, 0);
-		ahd_outb(ahd, CLRLQOINT1, 0);
-	}
-	ahd_outb(ahd, CLRSINT3, CLRNTRAMPERR|CLROSRAMPERR);
-	ahd_outb(ahd, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI
-				|CLRBUSFREE|CLRSCSIPERR|CLRREQINIT);
-	ahd_outb(ahd, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO
-			        |CLRIOERR|CLROVERRUN);
-	ahd_outb(ahd, CLRINT, CLRSCSIINT);
-}
-
-/**************************** Debugging Routines ******************************/
-#ifdef AHD_DEBUG
-uint32_t ahd_debug = AHD_DEBUG_OPTS;
-#endif
-void
-ahd_print_scb(struct scb *scb)
-{
-	struct hardware_scb *hscb;
-	int i;
-
-	hscb = scb->hscb;
-	printf("scb:%p control:0x%x scsiid:0x%x lun:%d cdb_len:%d\n",
-	       (void *)scb,
-	       hscb->control,
-	       hscb->scsiid,
-	       hscb->lun,
-	       hscb->cdb_len);
-	printf("Shared Data: ");
-	for (i = 0; i < sizeof(hscb->shared_data.idata.cdb); i++)
-		printf("%#02x", hscb->shared_data.idata.cdb[i]);
-	printf("        dataptr:%#x%x datacnt:%#x sgptr:%#x tag:%#x\n",
-	       (uint32_t)((ahd_le64toh(hscb->dataptr) >> 32) & 0xFFFFFFFF),
-	       (uint32_t)(ahd_le64toh(hscb->dataptr) & 0xFFFFFFFF),
-	       ahd_le32toh(hscb->datacnt),
-	       ahd_le32toh(hscb->sgptr),
-	       SCB_GET_TAG(scb));
-	ahd_dump_sglist(scb);
-}
-
-void
-ahd_dump_sglist(struct scb *scb)
-{
-	int i;
-
-	if (scb->sg_count > 0) {
-		if ((scb->ahd_softc->flags & AHD_64BIT_ADDRESSING) != 0) {
-			struct ahd_dma64_seg *sg_list;
-
-			sg_list = (struct ahd_dma64_seg*)scb->sg_list;
-			for (i = 0; i < scb->sg_count; i++) {
-				uint64_t addr;
-				uint32_t len;
-
-				addr = ahd_le64toh(sg_list[i].addr);
-				len = ahd_le32toh(sg_list[i].len);
-				printf("sg[%d] - Addr 0x%x%x : Length %d%s\n",
-				       i,
-				       (uint32_t)((addr >> 32) & 0xFFFFFFFF),
-				       (uint32_t)(addr & 0xFFFFFFFF),
-				       sg_list[i].len & AHD_SG_LEN_MASK,
-				       (sg_list[i].len & AHD_DMA_LAST_SEG)
-				     ? " Last" : "");
-			}
-		} else {
-			struct ahd_dma_seg *sg_list;
-
-			sg_list = (struct ahd_dma_seg*)scb->sg_list;
-			for (i = 0; i < scb->sg_count; i++) {
-				uint32_t len;
-
-				len = ahd_le32toh(sg_list[i].len);
-				printf("sg[%d] - Addr 0x%x%x : Length %d%s\n",
-				       i,
-				       (len >> 24) & SG_HIGH_ADDR_BITS,
-				       ahd_le32toh(sg_list[i].addr),
-				       len & AHD_SG_LEN_MASK,
-				       len & AHD_DMA_LAST_SEG ? " Last" : "");
-			}
-		}
-	}
-}
-
-/************************* Transfer Negotiation *******************************/
-/*
- * Allocate per target mode instance (ID we respond to as a target)
- * transfer negotiation data structures.
- */
-static struct ahd_tmode_tstate *
-ahd_alloc_tstate(struct ahd_softc *ahd, u_int scsi_id, char channel)
-{
-	struct ahd_tmode_tstate *master_tstate;
-	struct ahd_tmode_tstate *tstate;
-	int i;
-
-	master_tstate = ahd->enabled_targets[ahd->our_id];
-	if (ahd->enabled_targets[scsi_id] != NULL
-	 && ahd->enabled_targets[scsi_id] != master_tstate)
-		panic("%s: ahd_alloc_tstate - Target already allocated",
-		      ahd_name(ahd));
-	tstate = malloc(sizeof(*tstate), M_DEVBUF, M_NOWAIT);
-	if (tstate == NULL)
-		return (NULL);
-
-	/*
-	 * If we have allocated a master tstate, copy user settings from
-	 * the master tstate (taken from SRAM or the EEPROM) for this
-	 * channel, but reset our current and goal settings to async/narrow
-	 * until an initiator talks to us.
-	 */
-	if (master_tstate != NULL) {
-		memcpy(tstate, master_tstate, sizeof(*tstate));
-		memset(tstate->enabled_luns, 0, sizeof(tstate->enabled_luns));
-		for (i = 0; i < 16; i++) {
-			memset(&tstate->transinfo[i].curr, 0,
-			      sizeof(tstate->transinfo[i].curr));
-			memset(&tstate->transinfo[i].goal, 0,
-			      sizeof(tstate->transinfo[i].goal));
-		}
-	} else
-		memset(tstate, 0, sizeof(*tstate));
-	ahd->enabled_targets[scsi_id] = tstate;
-	return (tstate);
-}
-
-#ifdef AHD_TARGET_MODE
-/*
- * Free per target mode instance (ID we respond to as a target)
- * transfer negotiation data structures.
- */
-static void
-ahd_free_tstate(struct ahd_softc *ahd, u_int scsi_id, char channel, int force)
-{
-	struct ahd_tmode_tstate *tstate;
-
-	/*
-	 * Don't clean up our "master" tstate.
-	 * It has our default user settings.
-	 */
-	if (scsi_id == ahd->our_id
-	 && force == FALSE)
-		return;
-
-	tstate = ahd->enabled_targets[scsi_id];
-	if (tstate != NULL)
-		free(tstate, M_DEVBUF);
-	ahd->enabled_targets[scsi_id] = NULL;
-}
-#endif
-
-/*
- * Called when we have an active connection to a target on the bus,
- * this function finds the nearest period to the input period limited
- * by the capabilities of the bus connectivity of and sync settings for
- * the target.
- */
-void
-ahd_devlimited_syncrate(struct ahd_softc *ahd,
-			struct ahd_initiator_tinfo *tinfo,
-			u_int *period, u_int *ppr_options, role_t role)
-{
-	struct	ahd_transinfo *transinfo;
-	u_int	maxsync;
-
-	if ((ahd_inb(ahd, SBLKCTL) & ENAB40) != 0
-	 && (ahd_inb(ahd, SSTAT2) & EXP_ACTIVE) == 0) {
-		maxsync = AHD_SYNCRATE_PACED;
-	} else {
-		maxsync = AHD_SYNCRATE_ULTRA;
-		/* Can't do DT related options on an SE bus */
-		*ppr_options &= MSG_EXT_PPR_QAS_REQ;
-	}
-	/*
-	 * Never allow a value higher than our current goal
-	 * period otherwise we may allow a target initiated
-	 * negotiation to go above the limit as set by the
-	 * user.  In the case of an initiator initiated
-	 * sync negotiation, we limit based on the user
-	 * setting.  This allows the system to still accept
-	 * incoming negotiations even if target initiated
-	 * negotiation is not performed.
-	 */
-	if (role == ROLE_TARGET)
-		transinfo = &tinfo->user;
-	else 
-		transinfo = &tinfo->goal;
-	*ppr_options &= (transinfo->ppr_options|MSG_EXT_PPR_PCOMP_EN);
-	if (transinfo->width == MSG_EXT_WDTR_BUS_8_BIT) {
-		maxsync = MAX(maxsync, AHD_SYNCRATE_ULTRA2);
-		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
-	}
-	if (transinfo->period == 0) {
-		*period = 0;
-		*ppr_options = 0;
-	} else {
-		*period = MAX(*period, transinfo->period);
-		ahd_find_syncrate(ahd, period, ppr_options, maxsync);
-	}
-}
-
-/*
- * Look up the valid period to SCSIRATE conversion in our table.
- * Return the period and offset that should be sent to the target
- * if this was the beginning of an SDTR.
- */
-void
-ahd_find_syncrate(struct ahd_softc *ahd, u_int *period,
-		  u_int *ppr_options, u_int maxsync)
-{
-	if (*period < maxsync)
-		*period = maxsync;
-
-	if ((*ppr_options & MSG_EXT_PPR_DT_REQ) != 0
-	 && *period > AHD_SYNCRATE_MIN_DT)
-		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
-		
-	if (*period > AHD_SYNCRATE_MIN)
-		*period = 0;
-
-	/* Honor PPR option conformance rules. */
-	if (*period > AHD_SYNCRATE_PACED)
-		*ppr_options &= ~MSG_EXT_PPR_RTI;
-
-	if ((*ppr_options & MSG_EXT_PPR_IU_REQ) == 0)
-		*ppr_options &= (MSG_EXT_PPR_DT_REQ|MSG_EXT_PPR_QAS_REQ);
-
-	if ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0)
-		*ppr_options &= MSG_EXT_PPR_QAS_REQ;
-
-	/* Skip all PACED only entries if IU is not available */
-	if ((*ppr_options & MSG_EXT_PPR_IU_REQ) == 0
-	 && *period < AHD_SYNCRATE_DT)
-		*period = AHD_SYNCRATE_DT;
-
-	/* Skip all DT only entries if DT is not available */
-	if ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0
-	 && *period < AHD_SYNCRATE_ULTRA2)
-		*period = AHD_SYNCRATE_ULTRA2;
-}
-
-/*
- * Truncate the given synchronous offset to a value the
- * current adapter type and syncrate are capable of.
- */
-void
-ahd_validate_offset(struct ahd_softc *ahd,
-		    struct ahd_initiator_tinfo *tinfo,
-		    u_int period, u_int *offset, int wide,
-		    role_t role)
-{
-	u_int maxoffset;
-
-	/* Limit offset to what we can do */
-	if (period == 0)
-		maxoffset = 0;
-	else if (period <= AHD_SYNCRATE_PACED) {
-		if ((ahd->bugs & AHD_PACED_NEGTABLE_BUG) != 0)
-			maxoffset = MAX_OFFSET_PACED_BUG;
-		else
-			maxoffset = MAX_OFFSET_PACED;
-	} else
-		maxoffset = MAX_OFFSET_NON_PACED;
-	*offset = MIN(*offset, maxoffset);
-	if (tinfo != NULL) {
-		if (role == ROLE_TARGET)
-			*offset = MIN(*offset, tinfo->user.offset);
-		else
-			*offset = MIN(*offset, tinfo->goal.offset);
-	}
-}
-
-/*
- * Truncate the given transfer width parameter to a value the
- * current adapter type is capable of.
- */
-void
-ahd_validate_width(struct ahd_softc *ahd, struct ahd_initiator_tinfo *tinfo,
-		   u_int *bus_width, role_t role)
-{
-	switch (*bus_width) {
-	default:
-		if (ahd->features & AHD_WIDE) {
-			/* Respond Wide */
-			*bus_width = MSG_EXT_WDTR_BUS_16_BIT;
-			break;
-		}
-		/* FALLTHROUGH */
-	case MSG_EXT_WDTR_BUS_8_BIT:
-		*bus_width = MSG_EXT_WDTR_BUS_8_BIT;
-		break;
-	}
-	if (tinfo != NULL) {
-		if (role == ROLE_TARGET)
-			*bus_width = MIN(tinfo->user.width, *bus_width);
-		else
-			*bus_width = MIN(tinfo->goal.width, *bus_width);
-	}
-}
-
-/*
- * Update the bitmask of targets for which the controller should
- * negotiate with at the next convenient oportunity.  This currently
- * means the next time we send the initial identify messages for
- * a new transaction.
- */
-int
-ahd_update_neg_request(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
-		       struct ahd_tmode_tstate *tstate,
-		       struct ahd_initiator_tinfo *tinfo, ahd_neg_type neg_type)
-{
-	u_int auto_negotiate_orig;
-
-	auto_negotiate_orig = tstate->auto_negotiate;
-	if (neg_type == AHD_NEG_ALWAYS) {
-		/*
-		 * Force our "current" settings to be
-		 * unknown so that unless a bus reset
-		 * occurs the need to renegotiate is
-		 * recorded persistently.
-		 */
-		if ((ahd->features & AHD_WIDE) != 0)
-			tinfo->curr.width = AHD_WIDTH_UNKNOWN;
-		tinfo->curr.period = AHD_PERIOD_UNKNOWN;
-		tinfo->curr.offset = AHD_OFFSET_UNKNOWN;
-	}
-	if (tinfo->curr.period != tinfo->goal.period
-	 || tinfo->curr.width != tinfo->goal.width
-	 || tinfo->curr.offset != tinfo->goal.offset
-	 || tinfo->curr.ppr_options != tinfo->goal.ppr_options
-	 || (neg_type == AHD_NEG_IF_NON_ASYNC
-	  && (tinfo->goal.offset != 0
-	   || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT
-	   || tinfo->goal.ppr_options != 0)))
-		tstate->auto_negotiate |= devinfo->target_mask;
-	else
-		tstate->auto_negotiate &= ~devinfo->target_mask;
-
-	return (auto_negotiate_orig != tstate->auto_negotiate);
-}
-
-/*
- * Update the user/goal/curr tables of synchronous negotiation
- * parameters as well as, in the case of a current or active update,
- * any data structures on the host controller.  In the case of an
- * active update, the specified target is currently talking to us on
- * the bus, so the transfer parameter update must take effect
- * immediately.
- */
-void
-ahd_set_syncrate(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
-		 u_int period, u_int offset, u_int ppr_options,
-		 u_int type, int paused)
-{
-	struct	ahd_initiator_tinfo *tinfo;
-	struct	ahd_tmode_tstate *tstate;
-	u_int	old_period;
-	u_int	old_offset;
-	u_int	old_ppr;
-	int	active;
-	int	update_needed;
-
-	active = (type & AHD_TRANS_ACTIVE) == AHD_TRANS_ACTIVE;
-	update_needed = 0;
-
-	if (period == 0 || offset == 0) {
-		period = 0;
-		offset = 0;
-	}
-
-	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,
-				    devinfo->target, &tstate);
-
-	if ((type & AHD_TRANS_USER) != 0) {
-		tinfo->user.period = period;
-		tinfo->user.offset = offset;
-		tinfo->user.ppr_options = ppr_options;
-	}
-
-	if ((type & AHD_TRANS_GOAL) != 0) {
-		tinfo->goal.period = period;
-		tinfo->goal.offset = offset;
-		tinfo->goal.ppr_options = ppr_options;
-	}
-
-	old_period = tinfo->curr.period;
-	old_offset = tinfo->curr.offset;
-	old_ppr	   = tinfo->curr.ppr_options;
-
-	if ((type & AHD_TRANS_CUR) != 0
-	 && (old_period != period
-	  || old_offset != offset
-	  || old_ppr != ppr_options)) {
-
-		update_needed++;
-
-		tinfo->curr.period = period;
-		tinfo->curr.offset = offset;
-		tinfo->curr.ppr_options = ppr_options;
-
-		ahd_send_async(ahd, devinfo->channel, devinfo->target,
-			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
-		if (bootverbose) {
-			if (offset != 0) {
-				int options;
-
-				printf("%s: target %d synchronous with "
-				       "period = 0x%x, offset = 0x%x",
-				       ahd_name(ahd), devinfo->target,
-				       period, offset);
-				options = 0;
-				if ((ppr_options & MSG_EXT_PPR_DT_REQ) != 0) {
-					printf("(DT");
-					options++;
-				}
-				if ((ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
-					printf("%s", options ? "|IU" : "(IU");
-					options++;
-				}
-				if ((ppr_options & MSG_EXT_PPR_RTI) != 0) {
-					printf("%s", options ? "|RTI" : "(RTI");
-					options++;
-				}
-				if ((ppr_options & MSG_EXT_PPR_QAS_REQ) != 0) {
-					printf("%s", options ? "|QAS" : "(QAS");
-					options++;
-				}
-				if (options != 0)
-					printf(")\n");
-				else
-					printf("\n");
-			} else {
-				printf("%s: target %d using "
-				       "asynchronous transfers%s\n",
-				       ahd_name(ahd), devinfo->target,
-				       (ppr_options & MSG_EXT_PPR_QAS_REQ) != 0
-				     ?  "(QAS)" : "");
-			}
-		}
-	}
-	/*
-	 * Always refresh the neg-table to handle the case of the
-	 * sequencer setting the ENATNO bit for a MK_MESSAGE request.
-	 * We will always renegotiate in that case if this is a
-	 * packetized request.  Also manage the busfree expected flag
-	 * from this common routine so that we catch changes due to
-	 * WDTR or SDTR messages.
-	 */
-	if ((type & AHD_TRANS_CUR) != 0) {
-		if (!paused)
-			ahd_pause(ahd);
-		ahd_update_neg_table(ahd, devinfo, &tinfo->curr);
-		if (!paused)
-			ahd_unpause(ahd);
-		if (ahd->msg_type != MSG_TYPE_NONE) {
-			if ((old_ppr & MSG_EXT_PPR_IU_REQ)
-			 != (ppr_options & MSG_EXT_PPR_IU_REQ)) {
-#ifdef AHD_DEBUG
-				if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
-					ahd_print_devinfo(ahd, devinfo);
-					printf("Expecting IU Change busfree\n");
-				}
-#endif
-				ahd->msg_flags |= MSG_FLAG_EXPECT_PPR_BUSFREE
-					       |  MSG_FLAG_IU_REQ_CHANGED;
-			}
-			if ((old_ppr & MSG_EXT_PPR_IU_REQ) != 0) {
-#ifdef AHD_DEBUG
-				if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
-					printf("PPR with IU_REQ outstanding\n");
-#endif
-				ahd->msg_flags |= MSG_FLAG_EXPECT_PPR_BUSFREE;
-			}
-		}
-	}
-
-	update_needed += ahd_update_neg_request(ahd, devinfo, tstate,
-						tinfo, AHD_NEG_TO_GOAL);
-
-	if (update_needed && active)
-		ahd_update_pending_scbs(ahd);
-}
-
-/*
- * Update the user/goal/curr tables of wide negotiation
- * parameters as well as, in the case of a current or active update,
- * any data structures on the host controller.  In the case of an
- * active update, the specified target is currently talking to us on
- * the bus, so the transfer parameter update must take effect
- * immediately.
- */
-void
-ahd_set_width(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
-	      u_int width, u_int type, int paused)
-{
-	struct	ahd_initiator_tinfo *tinfo;
-	struct	ahd_tmode_tstate *tstate;
-	u_int	oldwidth;
-	int	active;
-	int	update_needed;
-
-	active = (type & AHD_TRANS_ACTIVE) == AHD_TRANS_ACTIVE;
-	update_needed = 0;
-	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,
-				    devinfo->target, &tstate);
-
-	if ((type & AHD_TRANS_USER) != 0)
-		tinfo->user.width = width;
-
-	if ((type & AHD_TRANS_GOAL) != 0)
-		tinfo->goal.width = width;
-
-	oldwidth = tinfo->curr.width;
-	if ((type & AHD_TRANS_CUR) != 0 && oldwidth != width) {
-
-		update_needed++;
-
-		tinfo->curr.width = width;
-		ahd_send_async(ahd, devinfo->channel, devinfo->target,
-			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
-		if (bootverbose) {
-			printf("%s: target %d using %dbit transfers\n",
-			       ahd_name(ahd), devinfo->target,
-			       8 * (0x01 << width));
-		}
-	}
-
-	if ((type & AHD_TRANS_CUR) != 0) {
-		if (!paused)
-			ahd_pause(ahd);
-		ahd_update_neg_table(ahd, devinfo, &tinfo->curr);
-		if (!paused)
-			ahd_unpause(ahd);
-	}
-
-	update_needed += ahd_update_neg_request(ahd, devinfo, tstate,
-						tinfo, AHD_NEG_TO_GOAL);
-	if (update_needed && active)
-		ahd_update_pending_scbs(ahd);
-
-}
-
-/*
- * Update the current state of tagged queuing for a given target.
- */
-void
-ahd_set_tags(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
-	     ahd_queue_alg alg)
-{
-	ahd_platform_set_tags(ahd, devinfo, alg);
-	ahd_send_async(ahd, devinfo->channel, devinfo->target,
-		       devinfo->lun, AC_TRANSFER_NEG, &alg);
-}
-
-static void
-ahd_update_neg_table(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
-		     struct ahd_transinfo *tinfo)
-{
-	ahd_mode_state	saved_modes;
-	u_int		period;
-	u_int		ppr_opts;
-	u_int		con_opts;
-	u_int		offset;
-	u_int		saved_negoaddr;
-	uint8_t		iocell_opts[sizeof(ahd->iocell_opts)];
-
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-
-	saved_negoaddr = ahd_inb(ahd, NEGOADDR);
-	ahd_outb(ahd, NEGOADDR, devinfo->target);
-	period = tinfo->period;
-	offset = tinfo->offset;
-	memcpy(iocell_opts, ahd->iocell_opts, sizeof(ahd->iocell_opts)); 
-	ppr_opts = tinfo->ppr_options & (MSG_EXT_PPR_QAS_REQ|MSG_EXT_PPR_DT_REQ
-					|MSG_EXT_PPR_IU_REQ|MSG_EXT_PPR_RTI);
-	con_opts = 0;
-	if (period == 0)
-		period = AHD_SYNCRATE_ASYNC;
-	if (period == AHD_SYNCRATE_160) {
-
-		if ((ahd->bugs & AHD_PACED_NEGTABLE_BUG) != 0) {
-			/*
-			 * When the SPI4 spec was finalized, PACE transfers
-			 * was not made a configurable option in the PPR
-			 * message.  Instead it is assumed to be enabled for
-			 * any syncrate faster than 80MHz.  Nevertheless,
-			 * Harpoon2A4 allows this to be configurable.
-			 *
-			 * Harpoon2A4 also assumes at most 2 data bytes per
-			 * negotiated REQ/ACK offset.  Paced transfers take
-			 * 4, so we must adjust our offset.
-			 */
-			ppr_opts |= PPROPT_PACE;
-			offset *= 2;
-
-			/*
-			 * Harpoon2A assumed that there would be a
-			 * fallback rate between 160MHz and 80Mhz,
-			 * so 7 is used as the period factor rather
-			 * than 8 for 160MHz.
-			 */
-			period = AHD_SYNCRATE_REVA_160;
-		}
-		if ((tinfo->ppr_options & MSG_EXT_PPR_PCOMP_EN) == 0)
-			iocell_opts[AHD_PRECOMP_SLEW_INDEX] &=
-			    ~AHD_PRECOMP_MASK;
-	} else {
-		/*
-		 * Precomp should be disabled for non-paced transfers.
-		 */
-		iocell_opts[AHD_PRECOMP_SLEW_INDEX] &= ~AHD_PRECOMP_MASK;
-
-		if ((ahd->features & AHD_NEW_IOCELL_OPTS) != 0
-		 && (ppr_opts & MSG_EXT_PPR_DT_REQ) != 0) {
-			/*
-			 * Slow down our CRC interval to be
-			 * compatible with devices that can't
-			 * handle a CRC at full speed.
-			 */
-			con_opts |= ENSLOWCRC;
-		}
-	}
-
-	ahd_outb(ahd, ANNEXCOL, AHD_ANNEXCOL_PRECOMP_SLEW);
-	ahd_outb(ahd, ANNEXDAT, iocell_opts[AHD_PRECOMP_SLEW_INDEX]);
-	ahd_outb(ahd, ANNEXCOL, AHD_ANNEXCOL_AMPLITUDE);
-	ahd_outb(ahd, ANNEXDAT, iocell_opts[AHD_AMPLITUDE_INDEX]);
-
-	ahd_outb(ahd, NEGPERIOD, period);
-	ahd_outb(ahd, NEGPPROPTS, ppr_opts);
-	ahd_outb(ahd, NEGOFFSET, offset);
-
-	if (tinfo->width == MSG_EXT_WDTR_BUS_16_BIT)
-		con_opts |= WIDEXFER;
-
-	/*
-	 * During packetized transfers, the target will
-	 * give us the oportunity to send command packets
-	 * without us asserting attention.
-	 */
-	if ((tinfo->ppr_options & MSG_EXT_PPR_IU_REQ) == 0)
-		con_opts |= ENAUTOATNO;
-	ahd_outb(ahd, NEGCONOPTS, con_opts);
-	ahd_outb(ahd, NEGOADDR, saved_negoaddr);
-	ahd_restore_modes(ahd, saved_modes);
-}
-
-/*
- * When the transfer settings for a connection change, setup for
- * negotiation in pending SCBs to effect the change as quickly as
- * possible.  We also cancel any negotiations that are scheduled
- * for inflight SCBs that have not been started yet.
- */
-static void
-ahd_update_pending_scbs(struct ahd_softc *ahd)
-{
-	struct		scb *pending_scb;
-	int		pending_scb_count;
-	int		i;
-	int		paused;
-	u_int		saved_scbptr;
-	ahd_mode_state	saved_modes;
-
-	/*
-	 * Traverse the pending SCB list and ensure that all of the
-	 * SCBs there have the proper settings.  We can only safely
-	 * clear the negotiation required flag (setting requires the
-	 * execution queue to be modified) and this is only possible
-	 * if we are not already attempting to select out for this
-	 * SCB.  For this reason, all callers only call this routine
-	 * if we are changing the negotiation settings for the currently
-	 * active transaction on the bus.
-	 */
-	pending_scb_count = 0;
-	LIST_FOREACH(pending_scb, &ahd->pending_scbs, pending_links) {
-		struct ahd_devinfo devinfo;
-		struct hardware_scb *pending_hscb;
-		struct ahd_initiator_tinfo *tinfo;
-		struct ahd_tmode_tstate *tstate;
-
-		ahd_scb_devinfo(ahd, &devinfo, pending_scb);
-		tinfo = ahd_fetch_transinfo(ahd, devinfo.channel,
-					    devinfo.our_scsiid,
-					    devinfo.target, &tstate);
-		pending_hscb = pending_scb->hscb;
-		if ((tstate->auto_negotiate & devinfo.target_mask) == 0
-		 && (pending_scb->flags & SCB_AUTO_NEGOTIATE) != 0) {
-			pending_scb->flags &= ~SCB_AUTO_NEGOTIATE;
-			pending_hscb->control &= ~MK_MESSAGE;
-		}
-		ahd_sync_scb(ahd, pending_scb,
-			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
-		pending_scb_count++;
-	}
-
-	if (pending_scb_count == 0)
-		return;
-
-	if (ahd_is_paused(ahd)) {
-		paused = 1;
-	} else {
-		paused = 0;
-		ahd_pause(ahd);
-	}
-
-	/*
-	 * Force the sequencer to reinitialize the selection for
-	 * the command at the head of the execution queue if it
-	 * has already been setup.  The negotiation changes may
-	 * effect whether we select-out with ATN.
-	 */
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	ahd_outb(ahd, SCSISEQ0, ahd_inb(ahd, SCSISEQ0) & ~ENSELO);
-	saved_scbptr = ahd_get_scbptr(ahd);
-	/* Ensure that the hscbs down on the card match the new information */
-	for (i = 0; i < ahd->scb_data.maxhscbs; i++) {
-		struct	hardware_scb *pending_hscb;
-		u_int	control;
-		u_int	scb_tag;
-
-		ahd_set_scbptr(ahd, i);
-		scb_tag = i;
-		pending_scb = ahd_lookup_scb(ahd, scb_tag);
-		if (pending_scb == NULL)
-			continue;
-
-		pending_hscb = pending_scb->hscb;
-		control = ahd_inb_scbram(ahd, SCB_CONTROL);
-		control &= ~MK_MESSAGE;
-		control |= pending_hscb->control & MK_MESSAGE;
-		ahd_outb(ahd, SCB_CONTROL, control);
-	}
-	ahd_set_scbptr(ahd, saved_scbptr);
-	ahd_restore_modes(ahd, saved_modes);
-
-	if (paused == 0)
-		ahd_unpause(ahd);
-}
-
-/**************************** Pathing Information *****************************/
-static void
-ahd_fetch_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
-{
-	ahd_mode_state	saved_modes;
-	u_int		saved_scsiid;
-	role_t		role;
-	int		our_id;
-
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-
-	if (ahd_inb(ahd, SSTAT0) & TARGET)
-		role = ROLE_TARGET;
-	else
-		role = ROLE_INITIATOR;
-
-	if (role == ROLE_TARGET
-	 && (ahd_inb(ahd, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {
-		/* We were selected, so pull our id from TARGIDIN */
-		our_id = ahd_inb(ahd, TARGIDIN) & OID;
-	} else if (role == ROLE_TARGET)
-		our_id = ahd_inb(ahd, TOWNID);
-	else
-		our_id = ahd_inb(ahd, IOWNID);
-
-	saved_scsiid = ahd_inb(ahd, SAVED_SCSIID);
-	ahd_compile_devinfo(devinfo,
-			    our_id,
-			    SCSIID_TARGET(ahd, saved_scsiid),
-			    ahd_inb(ahd, SAVED_LUN),
-			    SCSIID_CHANNEL(ahd, saved_scsiid),
-			    role);
-	ahd_restore_modes(ahd, saved_modes);
-}
-
-void
-ahd_print_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
-{
-	printf("%s:%c:%d:%d: ", ahd_name(ahd), 'A',
-	       devinfo->target, devinfo->lun);
-}
-
-struct ahd_phase_table_entry*
-ahd_lookup_phase_entry(int phase)
-{
-	struct ahd_phase_table_entry *entry;
-	struct ahd_phase_table_entry *last_entry;
-
-	/*
-	 * num_phases doesn't include the default entry which
-	 * will be returned if the phase doesn't match.
-	 */
-	last_entry = &ahd_phase_table[num_phases];
-	for (entry = ahd_phase_table; entry < last_entry; entry++) {
-		if (phase == entry->phase)
-			break;
-	}
-	return (entry);
-}
-
-void
-ahd_compile_devinfo(struct ahd_devinfo *devinfo, u_int our_id, u_int target,
-		    u_int lun, char channel, role_t role)
-{
-	devinfo->our_scsiid = our_id;
-	devinfo->target = target;
-	devinfo->lun = lun;
-	devinfo->target_offset = target;
-	devinfo->channel = channel;
-	devinfo->role = role;
-	if (channel == 'B')
-		devinfo->target_offset += 8;
-	devinfo->target_mask = (0x01 << devinfo->target_offset);
-}
-
-static void
-ahd_scb_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
-		struct scb *scb)
-{
-	role_t	role;
-	int	our_id;
-
-	our_id = SCSIID_OUR_ID(scb->hscb->scsiid);
-	role = ROLE_INITIATOR;
-	if ((scb->hscb->control & TARGET_SCB) != 0)
-		role = ROLE_TARGET;
-	ahd_compile_devinfo(devinfo, our_id, SCB_GET_TARGET(ahd, scb),
-			    SCB_GET_LUN(scb), SCB_GET_CHANNEL(ahd, scb), role);
-}
-
-
-/************************ Message Phase Processing ****************************/
-/*
- * When an initiator transaction with the MK_MESSAGE flag either reconnects
- * or enters the initial message out phase, we are interrupted.  Fill our
- * outgoing message buffer with the appropriate message and beging handing
- * the message phase(s) manually.
- */
-static void
-ahd_setup_initiator_msgout(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
-			   struct scb *scb)
-{
-	/*
-	 * To facilitate adding multiple messages together,
-	 * each routine should increment the index and len
-	 * variables instead of setting them explicitly.
-	 */
-	ahd->msgout_index = 0;
-	ahd->msgout_len = 0;
-
-	if (ahd_currently_packetized(ahd))
-		ahd->msg_flags |= MSG_FLAG_PACKETIZED;
-
-	if (ahd->send_msg_perror
-	 && ahd_inb(ahd, MSG_OUT) == HOST_MSG) {
-		ahd->msgout_buf[ahd->msgout_index++] = ahd->send_msg_perror;
-		ahd->msgout_len++;
-		ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
-			printf("Setting up for Parity Error delivery\n");
-#endif
-		return;
-	} else if (scb == NULL) {
-		printf("%s: WARNING. No pending message for "
-		       "I_T msgin.  Issuing NO-OP\n", ahd_name(ahd));
-		ahd->msgout_buf[ahd->msgout_index++] = MSG_NOOP;
-		ahd->msgout_len++;
-		ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
-		return;
-	}
-
-	if ((scb->flags & SCB_DEVICE_RESET) == 0
-	 && (scb->flags & SCB_PACKETIZED) == 0
-	 && ahd_inb(ahd, MSG_OUT) == MSG_IDENTIFYFLAG) {
-		u_int identify_msg;
-
-		identify_msg = MSG_IDENTIFYFLAG | SCB_GET_LUN(scb);
-		if ((scb->hscb->control & DISCENB) != 0)
-			identify_msg |= MSG_IDENTIFY_DISCFLAG;
-		ahd->msgout_buf[ahd->msgout_index++] = identify_msg;
-		ahd->msgout_len++;
-
-		if ((scb->hscb->control & TAG_ENB) != 0) {
-			ahd->msgout_buf[ahd->msgout_index++] =
-			    scb->hscb->control & (TAG_ENB|SCB_TAG_TYPE);
-			ahd->msgout_buf[ahd->msgout_index++] = SCB_GET_TAG(scb);
-			ahd->msgout_len += 2;
-		}
-	}
-
-	if (scb->flags & SCB_DEVICE_RESET) {
-		ahd->msgout_buf[ahd->msgout_index++] = MSG_BUS_DEV_RESET;
-		ahd->msgout_len++;
-		ahd_print_path(ahd, scb);
-		printf("Bus Device Reset Message Sent\n");
-		/*
-		 * Clear our selection hardware in advance of
-		 * the busfree.  We may have an entry in the waiting
-		 * Q for this target, and we don't want to go about
-		 * selecting while we handle the busfree and blow it
-		 * away.
-		 */
-		ahd_outb(ahd, SCSISEQ0, 0);
-	} else if ((scb->flags & SCB_ABORT) != 0) {
-
-		if ((scb->hscb->control & TAG_ENB) != 0) {
-			ahd->msgout_buf[ahd->msgout_index++] = MSG_ABORT_TAG;
-		} else {
-			ahd->msgout_buf[ahd->msgout_index++] = MSG_ABORT;
-		}
-		ahd->msgout_len++;
-		ahd_print_path(ahd, scb);
-		printf("Abort%s Message Sent\n",
-		       (scb->hscb->control & TAG_ENB) != 0 ? " Tag" : "");
-		/*
-		 * Clear our selection hardware in advance of
-		 * the busfree.  We may have an entry in the waiting
-		 * Q for this target, and we don't want to go about
-		 * selecting while we handle the busfree and blow it
-		 * away.
-		 */
-		ahd_outb(ahd, SCSISEQ0, 0);
-	} else if ((scb->flags & (SCB_AUTO_NEGOTIATE|SCB_NEGOTIATE)) != 0) {
-		ahd_build_transfer_msg(ahd, devinfo);
-		/*
-		 * Clear our selection hardware in advance of potential
-		 * PPR IU status change busfree.  We may have an entry in
-		 * the waiting Q for this target, and we don't want to go
-		 * about selecting while we handle the busfree and blow
-		 * it away.
-		 */
-		ahd_outb(ahd, SCSISEQ0, 0);
-	} else {
-		printf("ahd_intr: AWAITING_MSG for an SCB that "
-		       "does not have a waiting message\n");
-		printf("SCSIID = %x, target_mask = %x\n", scb->hscb->scsiid,
-		       devinfo->target_mask);
-		panic("SCB = %d, SCB Control = %x:%x, MSG_OUT = %x "
-		      "SCB flags = %x", SCB_GET_TAG(scb), scb->hscb->control,
-		      ahd_inb(ahd, SCB_CONTROL), ahd_inb(ahd, MSG_OUT),
-		      scb->flags);
-	}
-
-	/*
-	 * Clear the MK_MESSAGE flag from the SCB so we aren't
-	 * asked to send this message again.
-	 */
-	ahd_outb(ahd, SCB_CONTROL,
-		 ahd_inb_scbram(ahd, SCB_CONTROL) & ~MK_MESSAGE);
-	scb->hscb->control &= ~MK_MESSAGE;
-	ahd->msgout_index = 0;
-	ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
-}
-
-/*
- * Build an appropriate transfer negotiation message for the
- * currently active target.
- */
-static void
-ahd_build_transfer_msg(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
-{
-	/*
-	 * We need to initiate transfer negotiations.
-	 * If our current and goal settings are identical,
-	 * we want to renegotiate due to a check condition.
-	 */
-	struct	ahd_initiator_tinfo *tinfo;
-	struct	ahd_tmode_tstate *tstate;
-	int	dowide;
-	int	dosync;
-	int	doppr;
-	u_int	period;
-	u_int	ppr_options;
-	u_int	offset;
-
-	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,
-				    devinfo->target, &tstate);
-	/*
-	 * Filter our period based on the current connection.
-	 * If we can't perform DT transfers on this segment (not in LVD
-	 * mode for instance), then our decision to issue a PPR message
-	 * may change.
-	 */
-	period = tinfo->goal.period;
-	ppr_options = tinfo->goal.ppr_options;
-	/* Target initiated PPR is not allowed in the SCSI spec */
-	if (devinfo->role == ROLE_TARGET)
-		ppr_options = 0;
-	ahd_devlimited_syncrate(ahd, tinfo, &period,
-				&ppr_options, devinfo->role);
-	dowide = tinfo->curr.width != tinfo->goal.width;
-	dosync = tinfo->curr.period != period;
-	/*
-	 * Only use PPR if we have options that need it, even if the device
-	 * claims to support it.  There might be an expander in the way
-	 * that doesn't.
-	 */
-	doppr = ppr_options != 0;
-
-	if (!dowide && !dosync && !doppr) {
-		dowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;
-		dosync = tinfo->goal.period != 0;
-	}
-
-	if (!dowide && !dosync && !doppr) {
-		/*
-		 * Force async with a WDTR message if we have a wide bus,
-		 * or just issue an SDTR with a 0 offset.
-		 */
-		if ((ahd->features & AHD_WIDE) != 0)
-			dowide = 1;
-		else
-			dosync = 1;
-
-		if (bootverbose) {
-			ahd_print_devinfo(ahd, devinfo);
-			printf("Ensuring async\n");
-		}
-	}
-	/* Target initiated PPR is not allowed in the SCSI spec */
-	if (devinfo->role == ROLE_TARGET)
-		doppr = 0;
-
-	/*
-	 * Both the PPR message and SDTR message require the
-	 * goal syncrate to be limited to what the target device
-	 * is capable of handling (based on whether an LVD->SE
-	 * expander is on the bus), so combine these two cases.
-	 * Regardless, guarantee that if we are using WDTR and SDTR
-	 * messages that WDTR comes first.
-	 */
-	if (doppr || (dosync && !dowide)) {
-
-		offset = tinfo->goal.offset;
-		ahd_validate_offset(ahd, tinfo, period, &offset,
-				    doppr ? tinfo->goal.width
-					  : tinfo->curr.width,
-				    devinfo->role);
-		if (doppr) {
-			ahd_construct_ppr(ahd, devinfo, period, offset,
-					  tinfo->goal.width, ppr_options);
-		} else {
-			ahd_construct_sdtr(ahd, devinfo, period, offset);
-		}
-	} else {
-		ahd_construct_wdtr(ahd, devinfo, tinfo->goal.width);
-	}
-}
-
-/*
- * Build a synchronous negotiation message in our message
- * buffer based on the input parameters.
- */
-static void
-ahd_construct_sdtr(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
-		   u_int period, u_int offset)
-{
-	if (offset == 0)
-		period = AHD_ASYNC_XFER_PERIOD;
-	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXTENDED;
-	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_SDTR_LEN;
-	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_SDTR;
-	ahd->msgout_buf[ahd->msgout_index++] = period;
-	ahd->msgout_buf[ahd->msgout_index++] = offset;
-	ahd->msgout_len += 5;
-	if (bootverbose) {
-		printf("(%s:%c:%d:%d): Sending SDTR period %x, offset %x\n",
-		       ahd_name(ahd), devinfo->channel, devinfo->target,
-		       devinfo->lun, period, offset);
-	}
-}
-
-/*
- * Build a wide negotiateion message in our message
- * buffer based on the input parameters.
- */
-static void
-ahd_construct_wdtr(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
-		   u_int bus_width)
-{
-	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXTENDED;
-	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_WDTR_LEN;
-	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_WDTR;
-	ahd->msgout_buf[ahd->msgout_index++] = bus_width;
-	ahd->msgout_len += 4;
-	if (bootverbose) {
-		printf("(%s:%c:%d:%d): Sending WDTR %x\n",
-		       ahd_name(ahd), devinfo->channel, devinfo->target,
-		       devinfo->lun, bus_width);
-	}
-}
-
-/*
- * Build a parallel protocol request message in our message
- * buffer based on the input parameters.
- */
-static void
-ahd_construct_ppr(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
-		  u_int period, u_int offset, u_int bus_width,
-		  u_int ppr_options)
-{
-	/*
-	 * Always request precompensation from
-	 * the other target if we are running
-	 * at paced syncrates.
-	 */
-	if (period <= AHD_SYNCRATE_PACED)
-		ppr_options |= MSG_EXT_PPR_PCOMP_EN;
-	if (offset == 0)
-		period = AHD_ASYNC_XFER_PERIOD;
-	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXTENDED;
-	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_PPR_LEN;
-	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_PPR;
-	ahd->msgout_buf[ahd->msgout_index++] = period;
-	ahd->msgout_buf[ahd->msgout_index++] = 0;
-	ahd->msgout_buf[ahd->msgout_index++] = offset;
-	ahd->msgout_buf[ahd->msgout_index++] = bus_width;
-	ahd->msgout_buf[ahd->msgout_index++] = ppr_options;
-	ahd->msgout_len += 8;
-	if (bootverbose) {
-		printf("(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, "
-		       "offset %x, ppr_options %x\n", ahd_name(ahd),
-		       devinfo->channel, devinfo->target, devinfo->lun,
-		       bus_width, period, offset, ppr_options);
-	}
-}
-
-/*
- * Clear any active message state.
- */
-static void
-ahd_clear_msg_state(struct ahd_softc *ahd)
-{
-	ahd_mode_state saved_modes;
-
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	ahd->send_msg_perror = 0;
-	ahd->msg_flags = MSG_FLAG_NONE;
-	ahd->msgout_len = 0;
-	ahd->msgin_index = 0;
-	ahd->msg_type = MSG_TYPE_NONE;
-	if ((ahd_inb(ahd, SCSISIGO) & ATNO) != 0) {
-		/*
-		 * The target didn't care to respond to our
-		 * message request, so clear ATN.
-		 */
-		ahd_outb(ahd, CLRSINT1, CLRATNO);
-	}
-	ahd_outb(ahd, MSG_OUT, MSG_NOOP);
-	ahd_outb(ahd, SEQ_FLAGS2,
-		 ahd_inb(ahd, SEQ_FLAGS2) & ~TARGET_MSG_PENDING);
-	ahd_restore_modes(ahd, saved_modes);
-}
-
-/*
- * Manual message loop handler.
- */
-static void
-ahd_handle_message_phase(struct ahd_softc *ahd)
-{ 
-	struct	ahd_devinfo devinfo;
-	u_int	bus_phase;
-	int	end_session;
-
-	ahd_fetch_devinfo(ahd, &devinfo);
-	end_session = FALSE;
-	bus_phase = ahd_inb(ahd, LASTPHASE);
-
-	if ((ahd_inb(ahd, LQISTAT2) & LQIPHASE_OUTPKT) != 0) {
-		printf("LQIRETRY for LQIPHASE_OUTPKT\n");
-		ahd_outb(ahd, LQCTL2, LQIRETRY);
-	}
-reswitch:
-	switch (ahd->msg_type) {
-	case MSG_TYPE_INITIATOR_MSGOUT:
-	{
-		int lastbyte;
-		int phasemis;
-		int msgdone;
-
-		if (ahd->msgout_len == 0 && ahd->send_msg_perror == 0)
-			panic("HOST_MSG_LOOP interrupt with no active message");
-
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
-			ahd_print_devinfo(ahd, &devinfo);
-			printf("INITIATOR_MSG_OUT");
-		}
-#endif
-		phasemis = bus_phase != P_MESGOUT;
-		if (phasemis) {
-#ifdef AHD_DEBUG
-			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
-				printf(" PHASEMIS %s\n",
-				       ahd_lookup_phase_entry(bus_phase)
-							     ->phasemsg);
-			}
-#endif
-			if (bus_phase == P_MESGIN) {
-				/*
-				 * Change gears and see if
-				 * this messages is of interest to
-				 * us or should be passed back to
-				 * the sequencer.
-				 */
-				ahd_outb(ahd, CLRSINT1, CLRATNO);
-				ahd->send_msg_perror = 0;
-				ahd->msg_type = MSG_TYPE_INITIATOR_MSGIN;
-				ahd->msgin_index = 0;
-				goto reswitch;
-			}
-			end_session = TRUE;
-			break;
-		}
-
-		if (ahd->send_msg_perror) {
-			ahd_outb(ahd, CLRSINT1, CLRATNO);
-			ahd_outb(ahd, CLRSINT1, CLRREQINIT);
-#ifdef AHD_DEBUG
-			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
-				printf(" byte 0x%x\n", ahd->send_msg_perror);
-#endif
-			/*
-			 * If we are notifying the target of a CRC error
-			 * during packetized operations, the target is
-			 * within its rights to acknowledge our message
-			 * with a busfree.
-			 */
-			if ((ahd->msg_flags & MSG_FLAG_PACKETIZED) != 0
-			 && ahd->send_msg_perror == MSG_INITIATOR_DET_ERR)
-				ahd->msg_flags |= MSG_FLAG_EXPECT_IDE_BUSFREE;
-
-			ahd_outb(ahd, RETURN_2, ahd->send_msg_perror);
-			ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_WRITE);
-			break;
-		}
-
-		msgdone	= ahd->msgout_index == ahd->msgout_len;
-		if (msgdone) {
-			/*
-			 * The target has requested a retry.
-			 * Re-assert ATN, reset our message index to
-			 * 0, and try again.
-			 */
-			ahd->msgout_index = 0;
-			ahd_assert_atn(ahd);
-		}
-
-		lastbyte = ahd->msgout_index == (ahd->msgout_len - 1);
-		if (lastbyte) {
-			/* Last byte is signified by dropping ATN */
-			ahd_outb(ahd, CLRSINT1, CLRATNO);
-		}
-
-		/*
-		 * Clear our interrupt status and present
-		 * the next byte on the bus.
-		 */
-		ahd_outb(ahd, CLRSINT1, CLRREQINIT);
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
-			printf(" byte 0x%x\n",
-			       ahd->msgout_buf[ahd->msgout_index]);
-#endif
-		ahd_outb(ahd, RETURN_2, ahd->msgout_buf[ahd->msgout_index++]);
-		ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_WRITE);
-		break;
-	}
-	case MSG_TYPE_INITIATOR_MSGIN:
-	{
-		int phasemis;
-		int message_done;
-
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
-			ahd_print_devinfo(ahd, &devinfo);
-			printf("INITIATOR_MSG_IN");
-		}
-#endif
-		phasemis = bus_phase != P_MESGIN;
-		if (phasemis) {
-#ifdef AHD_DEBUG
-			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
-				printf(" PHASEMIS %s\n",
-				       ahd_lookup_phase_entry(bus_phase)
-							     ->phasemsg);
-			}
-#endif
-			ahd->msgin_index = 0;
-			if (bus_phase == P_MESGOUT
-			 && (ahd->send_msg_perror != 0
-			  || (ahd->msgout_len != 0
-			   && ahd->msgout_index == 0))) {
-				ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
-				goto reswitch;
-			}
-			end_session = TRUE;
-			break;
-		}
-
-		/* Pull the byte in without acking it */
-		ahd->msgin_buf[ahd->msgin_index] = ahd_inb(ahd, SCSIBUS);
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
-			printf(" byte 0x%x\n",
-			       ahd->msgin_buf[ahd->msgin_index]);
-#endif
-
-		message_done = ahd_parse_msg(ahd, &devinfo);
-
-		if (message_done) {
-			/*
-			 * Clear our incoming message buffer in case there
-			 * is another message following this one.
-			 */
-			ahd->msgin_index = 0;
-
-			/*
-			 * If this message illicited a response,
-			 * assert ATN so the target takes us to the
-			 * message out phase.
-			 */
-			if (ahd->msgout_len != 0) {
-#ifdef AHD_DEBUG
-				if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
-					ahd_print_devinfo(ahd, &devinfo);
-					printf("Asserting ATN for response\n");
-				}
-#endif
-				ahd_assert_atn(ahd);
-			}
-		} else 
-			ahd->msgin_index++;
-
-		if (message_done == MSGLOOP_TERMINATED) {
-			end_session = TRUE;
-		} else {
-			/* Ack the byte */
-			ahd_outb(ahd, CLRSINT1, CLRREQINIT);
-			ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_READ);
-		}
-		break;
-	}
-	case MSG_TYPE_TARGET_MSGIN:
-	{
-		int msgdone;
-		int msgout_request;
-
-		/*
-		 * By default, the message loop will continue.
-		 */
-		ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_TARG);
-
-		if (ahd->msgout_len == 0)
-			panic("Target MSGIN with no active message");
-
-		/*
-		 * If we interrupted a mesgout session, the initiator
-		 * will not know this until our first REQ.  So, we
-		 * only honor mesgout requests after we've sent our
-		 * first byte.
-		 */
-		if ((ahd_inb(ahd, SCSISIGI) & ATNI) != 0
-		 && ahd->msgout_index > 0)
-			msgout_request = TRUE;
-		else
-			msgout_request = FALSE;
-
-		if (msgout_request) {
-
-			/*
-			 * Change gears and see if
-			 * this messages is of interest to
-			 * us or should be passed back to
-			 * the sequencer.
-			 */
-			ahd->msg_type = MSG_TYPE_TARGET_MSGOUT;
-			ahd_outb(ahd, SCSISIGO, P_MESGOUT | BSYO);
-			ahd->msgin_index = 0;
-			/* Dummy read to REQ for first byte */
-			ahd_inb(ahd, SCSIDAT);
-			ahd_outb(ahd, SXFRCTL0,
-				 ahd_inb(ahd, SXFRCTL0) | SPIOEN);
-			break;
-		}
-
-		msgdone = ahd->msgout_index == ahd->msgout_len;
-		if (msgdone) {
-			ahd_outb(ahd, SXFRCTL0,
-				 ahd_inb(ahd, SXFRCTL0) & ~SPIOEN);
-			end_session = TRUE;
-			break;
-		}
-
-		/*
-		 * Present the next byte on the bus.
-		 */
-		ahd_outb(ahd, SXFRCTL0, ahd_inb(ahd, SXFRCTL0) | SPIOEN);
-		ahd_outb(ahd, SCSIDAT, ahd->msgout_buf[ahd->msgout_index++]);
-		break;
-	}
-	case MSG_TYPE_TARGET_MSGOUT:
-	{
-		int lastbyte;
-		int msgdone;
-
-		/*
-		 * By default, the message loop will continue.
-		 */
-		ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_TARG);
-
-		/*
-		 * The initiator signals that this is
-		 * the last byte by dropping ATN.
-		 */
-		lastbyte = (ahd_inb(ahd, SCSISIGI) & ATNI) == 0;
-
-		/*
-		 * Read the latched byte, but turn off SPIOEN first
-		 * so that we don't inadvertently cause a REQ for the
-		 * next byte.
-		 */
-		ahd_outb(ahd, SXFRCTL0, ahd_inb(ahd, SXFRCTL0) & ~SPIOEN);
-		ahd->msgin_buf[ahd->msgin_index] = ahd_inb(ahd, SCSIDAT);
-		msgdone = ahd_parse_msg(ahd, &devinfo);
-		if (msgdone == MSGLOOP_TERMINATED) {
-			/*
-			 * The message is *really* done in that it caused
-			 * us to go to bus free.  The sequencer has already
-			 * been reset at this point, so pull the ejection
-			 * handle.
-			 */
-			return;
-		}
-		
-		ahd->msgin_index++;
-
-		/*
-		 * XXX Read spec about initiator dropping ATN too soon
-		 *     and use msgdone to detect it.
-		 */
-		if (msgdone == MSGLOOP_MSGCOMPLETE) {
-			ahd->msgin_index = 0;
-
-			/*
-			 * If this message illicited a response, transition
-			 * to the Message in phase and send it.
-			 */
-			if (ahd->msgout_len != 0) {
-				ahd_outb(ahd, SCSISIGO, P_MESGIN | BSYO);
-				ahd_outb(ahd, SXFRCTL0,
-					 ahd_inb(ahd, SXFRCTL0) | SPIOEN);
-				ahd->msg_type = MSG_TYPE_TARGET_MSGIN;
-				ahd->msgin_index = 0;
-				break;
-			}
-		}
-
-		if (lastbyte)
-			end_session = TRUE;
-		else {
-			/* Ask for the next byte. */
-			ahd_outb(ahd, SXFRCTL0,
-				 ahd_inb(ahd, SXFRCTL0) | SPIOEN);
-		}
-
-		break;
-	}
-	default:
-		panic("Unknown REQINIT message type");
-	}
-
-	if (end_session) {
-		if ((ahd->msg_flags & MSG_FLAG_PACKETIZED) != 0) {
-			printf("%s: Returning to Idle Loop\n",
-			       ahd_name(ahd));
-			ahd_outb(ahd, LASTPHASE, P_BUSFREE);
-			ahd_clear_msg_state(ahd);
-			ahd_outb(ahd, SEQCTL0, FASTMODE|SEQRESET);
-		} else {
-			ahd_clear_msg_state(ahd);
-			ahd_outb(ahd, RETURN_1, EXIT_MSG_LOOP);
-		}
-	}
-}
-
-/*
- * See if we sent a particular extended message to the target.
- * If "full" is true, return true only if the target saw the full
- * message.  If "full" is false, return true if the target saw at
- * least the first byte of the message.
- */
-static int
-ahd_sent_msg(struct ahd_softc *ahd, ahd_msgtype type, u_int msgval, int full)
-{
-	int found;
-	u_int index;
-
-	found = FALSE;
-	index = 0;
-
-	while (index < ahd->msgout_len) {
-		if (ahd->msgout_buf[index] == MSG_EXTENDED) {
-			u_int end_index;
-
-			end_index = index + 1 + ahd->msgout_buf[index + 1];
-			if (ahd->msgout_buf[index+2] == msgval
-			 && type == AHDMSG_EXT) {
-
-				if (full) {
-					if (ahd->msgout_index > end_index)
-						found = TRUE;
-				} else if (ahd->msgout_index > index)
-					found = TRUE;
-			}
-			index = end_index;
-		} else if (ahd->msgout_buf[index] >= MSG_SIMPLE_TASK
-			&& ahd->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {
-
-			/* Skip tag type and tag id or residue param*/
-			index += 2;
-		} else {
-			/* Single byte message */
-			if (type == AHDMSG_1B
-			 && ahd->msgout_index > index
-			 && (ahd->msgout_buf[index] == msgval
-			  || ((ahd->msgout_buf[index] & MSG_IDENTIFYFLAG) != 0
-			   && msgval == MSG_IDENTIFYFLAG)))
-				found = TRUE;
-			index++;
-		}
-
-		if (found)
-			break;
-	}
-	return (found);
-}
-
-/*
- * Wait for a complete incoming message, parse it, and respond accordingly.
- */
-static int
-ahd_parse_msg(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
-{
-	struct	ahd_initiator_tinfo *tinfo;
-	struct	ahd_tmode_tstate *tstate;
-	int	reject;
-	int	done;
-	int	response;
-
-	done = MSGLOOP_IN_PROG;
-	response = FALSE;
-	reject = FALSE;
-	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,
-				    devinfo->target, &tstate);
-
-	/*
-	 * Parse as much of the message as is availible,
-	 * rejecting it if we don't support it.  When
-	 * the entire message is availible and has been
-	 * handled, return MSGLOOP_MSGCOMPLETE, indicating
-	 * that we have parsed an entire message.
-	 *
-	 * In the case of extended messages, we accept the length
-	 * byte outright and perform more checking once we know the
-	 * extended message type.
-	 */
-	switch (ahd->msgin_buf[0]) {
-	case MSG_DISCONNECT:
-	case MSG_SAVEDATAPOINTER:
-	case MSG_CMDCOMPLETE:
-	case MSG_RESTOREPOINTERS:
-	case MSG_IGN_WIDE_RESIDUE:
-		/*
-		 * End our message loop as these are messages
-		 * the sequencer handles on its own.
-		 */
-		done = MSGLOOP_TERMINATED;
-		break;
-	case MSG_MESSAGE_REJECT:
-		response = ahd_handle_msg_reject(ahd, devinfo);
-		/* FALLTHROUGH */
-	case MSG_NOOP:
-		done = MSGLOOP_MSGCOMPLETE;
-		break;
-	case MSG_EXTENDED:
-	{
-		/* Wait for enough of the message to begin validation */
-		if (ahd->msgin_index < 2)
-			break;
-		switch (ahd->msgin_buf[2]) {
-		case MSG_EXT_SDTR:
-		{
-			u_int	 period;
-			u_int	 ppr_options;
-			u_int	 offset;
-			u_int	 saved_offset;
-			
-			if (ahd->msgin_buf[1] != MSG_EXT_SDTR_LEN) {
-				reject = TRUE;
-				break;
-			}
-
-			/*
-			 * Wait until we have both args before validating
-			 * and acting on this message.
-			 *
-			 * Add one to MSG_EXT_SDTR_LEN to account for
-			 * the extended message preamble.
-			 */
-			if (ahd->msgin_index < (MSG_EXT_SDTR_LEN + 1))
-				break;
-
-			period = ahd->msgin_buf[3];
-			ppr_options = 0;
-			saved_offset = offset = ahd->msgin_buf[4];
-			ahd_devlimited_syncrate(ahd, tinfo, &period,
-						&ppr_options, devinfo->role);
-			ahd_validate_offset(ahd, tinfo, period, &offset,
-					    tinfo->curr.width, devinfo->role);
-			if (bootverbose) {
-				printf("(%s:%c:%d:%d): Received "
-				       "SDTR period %x, offset %x\n\t"
-				       "Filtered to period %x, offset %x\n",
-				       ahd_name(ahd), devinfo->channel,
-				       devinfo->target, devinfo->lun,
-				       ahd->msgin_buf[3], saved_offset,
-				       period, offset);
-			}
-			ahd_set_syncrate(ahd, devinfo, period,
-					 offset, ppr_options,
-					 AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
-					 /*paused*/TRUE);
-
-			/*
-			 * See if we initiated Sync Negotiation
-			 * and didn't have to fall down to async
-			 * transfers.
-			 */
-			if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_SDTR, TRUE)) {
-				/* We started it */
-				if (saved_offset != offset) {
-					/* Went too low - force async */
-					reject = TRUE;
-				}
-			} else {
-				/*
-				 * Send our own SDTR in reply
-				 */
-				if (bootverbose
-				 && devinfo->role == ROLE_INITIATOR) {
-					printf("(%s:%c:%d:%d): Target "
-					       "Initiated SDTR\n",
-					       ahd_name(ahd), devinfo->channel,
-					       devinfo->target, devinfo->lun);
-				}
-				ahd->msgout_index = 0;
-				ahd->msgout_len = 0;
-				ahd_construct_sdtr(ahd, devinfo,
-						   period, offset);
-				ahd->msgout_index = 0;
-				response = TRUE;
-			}
-			done = MSGLOOP_MSGCOMPLETE;
-			break;
-		}
-		case MSG_EXT_WDTR:
-		{
-			u_int bus_width;
-			u_int saved_width;
-			u_int sending_reply;
-
-			sending_reply = FALSE;
-			if (ahd->msgin_buf[1] != MSG_EXT_WDTR_LEN) {
-				reject = TRUE;
-				break;
-			}
-
-			/*
-			 * Wait until we have our arg before validating
-			 * and acting on this message.
-			 *
-			 * Add one to MSG_EXT_WDTR_LEN to account for
-			 * the extended message preamble.
-			 */
-			if (ahd->msgin_index < (MSG_EXT_WDTR_LEN + 1))
-				break;
-
-			bus_width = ahd->msgin_buf[3];
-			saved_width = bus_width;
-			ahd_validate_width(ahd, tinfo, &bus_width,
-					   devinfo->role);
-			if (bootverbose) {
-				printf("(%s:%c:%d:%d): Received WDTR "
-				       "%x filtered to %x\n",
-				       ahd_name(ahd), devinfo->channel,
-				       devinfo->target, devinfo->lun,
-				       saved_width, bus_width);
-			}
-
-			if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_WDTR, TRUE)) {
-				/*
-				 * Don't send a WDTR back to the
-				 * target, since we asked first.
-				 * If the width went higher than our
-				 * request, reject it.
-				 */
-				if (saved_width > bus_width) {
-					reject = TRUE;
-					printf("(%s:%c:%d:%d): requested %dBit "
-					       "transfers.  Rejecting...\n",
-					       ahd_name(ahd), devinfo->channel,
-					       devinfo->target, devinfo->lun,
-					       8 * (0x01 << bus_width));
-					bus_width = 0;
-				}
-			} else {
-				/*
-				 * Send our own WDTR in reply
-				 */
-				if (bootverbose
-				 && devinfo->role == ROLE_INITIATOR) {
-					printf("(%s:%c:%d:%d): Target "
-					       "Initiated WDTR\n",
-					       ahd_name(ahd), devinfo->channel,
-					       devinfo->target, devinfo->lun);
-				}
-				ahd->msgout_index = 0;
-				ahd->msgout_len = 0;
-				ahd_construct_wdtr(ahd, devinfo, bus_width);
-				ahd->msgout_index = 0;
-				response = TRUE;
-				sending_reply = TRUE;
-			}
-			ahd_set_width(ahd, devinfo, bus_width,
-				      AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
-				      /*paused*/TRUE);
-			/* After a wide message, we are async */
-			ahd_set_syncrate(ahd, devinfo, /*period*/0,
-					 /*offset*/0, /*ppr_options*/0,
-					 AHD_TRANS_ACTIVE, /*paused*/TRUE);
-			if (sending_reply == FALSE && reject == FALSE) {
-
-				if (tinfo->goal.offset) {
-					ahd->msgout_index = 0;
-					ahd->msgout_len = 0;
-					ahd_build_transfer_msg(ahd, devinfo);
-					ahd->msgout_index = 0;
-					response = TRUE;
-				}
-			}
-			done = MSGLOOP_MSGCOMPLETE;
-			break;
-		}
-		case MSG_EXT_PPR:
-		{
-			u_int	period;
-			u_int	offset;
-			u_int	bus_width;
-			u_int	ppr_options;
-			u_int	saved_width;
-			u_int	saved_offset;
-			u_int	saved_ppr_options;
-
-			if (ahd->msgin_buf[1] != MSG_EXT_PPR_LEN) {
-				reject = TRUE;
-				break;
-			}
-
-			/*
-			 * Wait until we have all args before validating
-			 * and acting on this message.
-			 *
-			 * Add one to MSG_EXT_PPR_LEN to account for
-			 * the extended message preamble.
-			 */
-			if (ahd->msgin_index < (MSG_EXT_PPR_LEN + 1))
-				break;
-
-			period = ahd->msgin_buf[3];
-			offset = ahd->msgin_buf[5];
-			bus_width = ahd->msgin_buf[6];
-			saved_width = bus_width;
-			ppr_options = ahd->msgin_buf[7];
-			/*
-			 * According to the spec, a DT only
-			 * period factor with no DT option
-			 * set implies async.
-			 */
-			if ((ppr_options & MSG_EXT_PPR_DT_REQ) == 0
-			 && period <= 9)
-				offset = 0;
-			saved_ppr_options = ppr_options;
-			saved_offset = offset;
-
-			/*
-			 * Transfer options are only available if we
-			 * are negotiating wide.
-			 */
-			if (bus_width == 0)
-				ppr_options &= MSG_EXT_PPR_QAS_REQ;
-
-			ahd_validate_width(ahd, tinfo, &bus_width,
-					   devinfo->role);
-			ahd_devlimited_syncrate(ahd, tinfo, &period,
-						&ppr_options, devinfo->role);
-			ahd_validate_offset(ahd, tinfo, period, &offset,
-					    bus_width, devinfo->role);
-
-			if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_PPR, TRUE)) {
-				/*
-				 * If we are unable to do any of the
-				 * requested options (we went too low),
-				 * then we'll have to reject the message.
-				 */
-				if (saved_width > bus_width
-				 || saved_offset != offset
-				 || saved_ppr_options != ppr_options) {
-					reject = TRUE;
-					period = 0;
-					offset = 0;
-					bus_width = 0;
-					ppr_options = 0;
-				}
-			} else {
-				if (devinfo->role != ROLE_TARGET)
-					printf("(%s:%c:%d:%d): Target "
-					       "Initiated PPR\n",
-					       ahd_name(ahd), devinfo->channel,
-					       devinfo->target, devinfo->lun);
-				else
-					printf("(%s:%c:%d:%d): Initiator "
-					       "Initiated PPR\n",
-					       ahd_name(ahd), devinfo->channel,
-					       devinfo->target, devinfo->lun);
-				ahd->msgout_index = 0;
-				ahd->msgout_len = 0;
-				ahd_construct_ppr(ahd, devinfo, period, offset,
-						  bus_width, ppr_options);
-				ahd->msgout_index = 0;
-				response = TRUE;
-			}
-			if (bootverbose) {
-				printf("(%s:%c:%d:%d): Received PPR width %x, "
-				       "period %x, offset %x,options %x\n"
-				       "\tFiltered to width %x, period %x, "
-				       "offset %x, options %x\n",
-				       ahd_name(ahd), devinfo->channel,
-				       devinfo->target, devinfo->lun,
-				       saved_width, ahd->msgin_buf[3],
-				       saved_offset, saved_ppr_options,
-				       bus_width, period, offset, ppr_options);
-			}
-			ahd_set_width(ahd, devinfo, bus_width,
-				      AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
-				      /*paused*/TRUE);
-			ahd_set_syncrate(ahd, devinfo, period,
-					 offset, ppr_options,
-					 AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
-					 /*paused*/TRUE);
-
-			done = MSGLOOP_MSGCOMPLETE;
-			break;
-		}
-		default:
-			/* Unknown extended message.  Reject it. */
-			reject = TRUE;
-			break;
-		}
-		break;
-	}
-#ifdef AHD_TARGET_MODE
-	case MSG_BUS_DEV_RESET:
-		ahd_handle_devreset(ahd, devinfo, CAM_LUN_WILDCARD,
-				    CAM_BDR_SENT,
-				    "Bus Device Reset Received",
-				    /*verbose_level*/0);
-		ahd_restart(ahd);
-		done = MSGLOOP_TERMINATED;
-		break;
-	case MSG_ABORT_TAG:
-	case MSG_ABORT:
-	case MSG_CLEAR_QUEUE:
-	{
-		int tag;
-
-		/* Target mode messages */
-		if (devinfo->role != ROLE_TARGET) {
-			reject = TRUE;
-			break;
-		}
-		tag = SCB_LIST_NULL;
-		if (ahd->msgin_buf[0] == MSG_ABORT_TAG)
-			tag = ahd_inb(ahd, INITIATOR_TAG);
-		ahd_abort_scbs(ahd, devinfo->target, devinfo->channel,
-			       devinfo->lun, tag, ROLE_TARGET,
-			       CAM_REQ_ABORTED);
-
-		tstate = ahd->enabled_targets[devinfo->our_scsiid];
-		if (tstate != NULL) {
-			struct ahd_tmode_lstate* lstate;
-
-			lstate = tstate->enabled_luns[devinfo->lun];
-			if (lstate != NULL) {
-				ahd_queue_lstate_event(ahd, lstate,
-						       devinfo->our_scsiid,
-						       ahd->msgin_buf[0],
-						       /*arg*/tag);
-				ahd_send_lstate_events(ahd, lstate);
-			}
-		}
-		ahd_restart(ahd);
-		done = MSGLOOP_TERMINATED;
-		break;
-	}
-#endif
-	case MSG_QAS_REQUEST:
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
-			printf("%s: QAS request.  SCSISIGI == 0x%x\n",
-			       ahd_name(ahd), ahd_inb(ahd, SCSISIGI));
-#endif
-		ahd->msg_flags |= MSG_FLAG_EXPECT_QASREJ_BUSFREE;
-		/* FALLTHROUGH */
-	case MSG_TERM_IO_PROC:
-	default:
-		reject = TRUE;
-		break;
-	}
-
-	if (reject) {
-		/*
-		 * Setup to reject the message.
-		 */
-		ahd->msgout_index = 0;
-		ahd->msgout_len = 1;
-		ahd->msgout_buf[0] = MSG_MESSAGE_REJECT;
-		done = MSGLOOP_MSGCOMPLETE;
-		response = TRUE;
-	}
-
-	if (done != MSGLOOP_IN_PROG && !response)
-		/* Clear the outgoing message buffer */
-		ahd->msgout_len = 0;
-
-	return (done);
-}
-
-/*
- * Process a message reject message.
- */
-static int
-ahd_handle_msg_reject(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
-{
-	/*
-	 * What we care about here is if we had an
-	 * outstanding SDTR or WDTR message for this
-	 * target.  If we did, this is a signal that
-	 * the target is refusing negotiation.
-	 */
-	struct scb *scb;
-	struct ahd_initiator_tinfo *tinfo;
-	struct ahd_tmode_tstate *tstate;
-	u_int scb_index;
-	u_int last_msg;
-	int   response = 0;
-
-	scb_index = ahd_get_scbptr(ahd);
-	scb = ahd_lookup_scb(ahd, scb_index);
-	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel,
-				    devinfo->our_scsiid,
-				    devinfo->target, &tstate);
-	/* Might be necessary */
-	last_msg = ahd_inb(ahd, LAST_MSG);
-
-	if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_PPR, /*full*/FALSE)) {
-		if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_PPR, /*full*/TRUE)
-		 && tinfo->goal.period <= AHD_SYNCRATE_PACED) {
-			/*
-			 * Target may not like our SPI-4 PPR Options.
-			 * Attempt to negotiate 80MHz which will turn
-			 * off these options.
-			 */
-			if (bootverbose) {
-				printf("(%s:%c:%d:%d): PPR Rejected. "
-				       "Trying simple U160 PPR\n",
-				       ahd_name(ahd), devinfo->channel,
-				       devinfo->target, devinfo->lun);
-			}
-			tinfo->goal.period = AHD_SYNCRATE_DT;
-			tinfo->goal.ppr_options &= MSG_EXT_PPR_IU_REQ
-						|  MSG_EXT_PPR_QAS_REQ
-						|  MSG_EXT_PPR_DT_REQ;
-		} else {
-			/*
-			 * Target does not support the PPR message.
-			 * Attempt to negotiate SPI-2 style.
-			 */
-			if (bootverbose) {
-				printf("(%s:%c:%d:%d): PPR Rejected. "
-				       "Trying WDTR/SDTR\n",
-				       ahd_name(ahd), devinfo->channel,
-				       devinfo->target, devinfo->lun);
-			}
-			tinfo->goal.ppr_options = 0;
-			tinfo->curr.transport_version = 2;
-			tinfo->goal.transport_version = 2;
-		}
-		ahd->msgout_index = 0;
-		ahd->msgout_len = 0;
-		ahd_build_transfer_msg(ahd, devinfo);
-		ahd->msgout_index = 0;
-		response = 1;
-	} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_WDTR, /*full*/FALSE)) {
-
-		/* note 8bit xfers */
-		printf("(%s:%c:%d:%d): refuses WIDE negotiation.  Using "
-		       "8bit transfers\n", ahd_name(ahd),
-		       devinfo->channel, devinfo->target, devinfo->lun);
-		ahd_set_width(ahd, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
-			      AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
-			      /*paused*/TRUE);
-		/*
-		 * No need to clear the sync rate.  If the target
-		 * did not accept the command, our syncrate is
-		 * unaffected.  If the target started the negotiation,
-		 * but rejected our response, we already cleared the
-		 * sync rate before sending our WDTR.
-		 */
-		if (tinfo->goal.offset != tinfo->curr.offset) {
-
-			/* Start the sync negotiation */
-			ahd->msgout_index = 0;
-			ahd->msgout_len = 0;
-			ahd_build_transfer_msg(ahd, devinfo);
-			ahd->msgout_index = 0;
-			response = 1;
-		}
-	} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_SDTR, /*full*/FALSE)) {
-		/* note asynch xfers and clear flag */
-		ahd_set_syncrate(ahd, devinfo, /*period*/0,
-				 /*offset*/0, /*ppr_options*/0,
-				 AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
-				 /*paused*/TRUE);
-		printf("(%s:%c:%d:%d): refuses synchronous negotiation. "
-		       "Using asynchronous transfers\n",
-		       ahd_name(ahd), devinfo->channel,
-		       devinfo->target, devinfo->lun);
-	} else if ((scb->hscb->control & MSG_SIMPLE_TASK) != 0) {
-		int tag_type;
-		int mask;
-
-		tag_type = (scb->hscb->control & MSG_SIMPLE_TASK);
-
-		if (tag_type == MSG_SIMPLE_TASK) {
-			printf("(%s:%c:%d:%d): refuses tagged commands.  "
-			       "Performing non-tagged I/O\n", ahd_name(ahd),
-			       devinfo->channel, devinfo->target, devinfo->lun);
-			ahd_set_tags(ahd, devinfo, AHD_QUEUE_NONE);
-			mask = ~0x23;
-		} else {
-			printf("(%s:%c:%d:%d): refuses %s tagged commands.  "
-			       "Performing simple queue tagged I/O only\n",
-			       ahd_name(ahd), devinfo->channel, devinfo->target,
-			       devinfo->lun, tag_type == MSG_ORDERED_TASK
-			       ? "ordered" : "head of queue");
-			ahd_set_tags(ahd, devinfo, AHD_QUEUE_BASIC);
-			mask = ~0x03;
-		}
-
-		/*
-		 * Resend the identify for this CCB as the target
-		 * may believe that the selection is invalid otherwise.
-		 */
-		ahd_outb(ahd, SCB_CONTROL,
-			 ahd_inb_scbram(ahd, SCB_CONTROL) & mask);
-	 	scb->hscb->control &= mask;
-		ahd_set_transaction_tag(scb, /*enabled*/FALSE,
-					/*type*/MSG_SIMPLE_TASK);
-		ahd_outb(ahd, MSG_OUT, MSG_IDENTIFYFLAG);
-		ahd_assert_atn(ahd);
-		ahd_busy_tcl(ahd, BUILD_TCL(scb->hscb->scsiid, devinfo->lun),
-			     SCB_GET_TAG(scb));
-
-		/*
-		 * Requeue all tagged commands for this target
-		 * currently in our posession so they can be
-		 * converted to untagged commands.
-		 */
-		ahd_search_qinfifo(ahd, SCB_GET_TARGET(ahd, scb),
-				   SCB_GET_CHANNEL(ahd, scb),
-				   SCB_GET_LUN(scb), /*tag*/SCB_LIST_NULL,
-				   ROLE_INITIATOR, CAM_REQUEUE_REQ,
-				   SEARCH_COMPLETE);
-	} else if (ahd_sent_msg(ahd, AHDMSG_1B, MSG_IDENTIFYFLAG, TRUE)) {
-		/*
-		 * Most likely the device believes that we had
-		 * previously negotiated packetized.
-		 */
-		ahd->msg_flags |= MSG_FLAG_EXPECT_PPR_BUSFREE
-			       |  MSG_FLAG_IU_REQ_CHANGED;
-
-		ahd_force_renegotiation(ahd, devinfo);
-		ahd->msgout_index = 0;
-		ahd->msgout_len = 0;
-		ahd_build_transfer_msg(ahd, devinfo);
-		ahd->msgout_index = 0;
-		response = 1;
-	} else {
-		/*
-		 * Otherwise, we ignore it.
-		 */
-		printf("%s:%c:%d: Message reject for %x -- ignored\n",
-		       ahd_name(ahd), devinfo->channel, devinfo->target,
-		       last_msg);
-	}
-	return (response);
-}
-
-/*
- * Process an ingnore wide residue message.
- */
-static void
-ahd_handle_ign_wide_residue(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
-{
-	u_int scb_index;
-	struct scb *scb;
-
-	scb_index = ahd_get_scbptr(ahd);
-	scb = ahd_lookup_scb(ahd, scb_index);
-	/*
-	 * XXX Actually check data direction in the sequencer?
-	 * Perhaps add datadir to some spare bits in the hscb?
-	 */
-	if ((ahd_inb(ahd, SEQ_FLAGS) & DPHASE) == 0
-	 || ahd_get_transfer_dir(scb) != CAM_DIR_IN) {
-		/*
-		 * Ignore the message if we haven't
-		 * seen an appropriate data phase yet.
-		 */
-	} else {
-		/*
-		 * If the residual occurred on the last
-		 * transfer and the transfer request was
-		 * expected to end on an odd count, do
-		 * nothing.  Otherwise, subtract a byte
-		 * and update the residual count accordingly.
-		 */
-		uint32_t sgptr;
-
-		sgptr = ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR);
-		if ((sgptr & SG_LIST_NULL) != 0
-		 && ahd_inb(ahd, DATA_COUNT_ODD) == 1) {
-			/*
-			 * If the residual occurred on the last
-			 * transfer and the transfer request was
-			 * expected to end on an odd count, do
-			 * nothing.
-			 */
-		} else {
-			uint32_t data_cnt;
-			uint64_t data_addr;
-			uint32_t sglen;
-
-			/* Pull in the rest of the sgptr */
-			sgptr |=
-			    (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 3) << 24)
-			  | (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 2) << 16)
-			  | (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 1) << 8);
-			sgptr &= SG_PTR_MASK;
-			data_cnt =
-			    (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT+3) << 24)
-			  | (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT+2) << 16)
-			  | (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT+1) << 8)
-			  | (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT));
-
-			data_addr = (((uint64_t)ahd_inb(ahd, SHADDR + 7)) << 56)
-				  | (((uint64_t)ahd_inb(ahd, SHADDR + 6)) << 48)
-				  | (((uint64_t)ahd_inb(ahd, SHADDR + 5)) << 40)
-				  | (((uint64_t)ahd_inb(ahd, SHADDR + 4)) << 32)
-				  | (ahd_inb(ahd, SHADDR + 3) << 24)
-				  | (ahd_inb(ahd, SHADDR + 2) << 16)
-				  | (ahd_inb(ahd, SHADDR + 1) << 8)
-				  | (ahd_inb(ahd, SHADDR));
-
-			data_cnt += 1;
-			data_addr -= 1;
-
-			if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
-				struct ahd_dma64_seg *sg;
-
-				sg = ahd_sg_bus_to_virt(ahd, scb, sgptr);
-
-				/*
-				 * The residual sg ptr points to the next S/G
-				 * to load so we must go back one.
-				 */
-				sg--;
-				sglen = ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;
-				if (sg != scb->sg_list
-				 && sglen < (data_cnt & AHD_SG_LEN_MASK)) {
-
-					sg--;
-					sglen = ahd_le32toh(sg->len);
-					/*
-					 * Preserve High Address and SG_LIST
-					 * bits while setting the count to 1.
-					 */
-					data_cnt = 1|(sglen&(~AHD_SG_LEN_MASK));
-					data_addr = ahd_le64toh(sg->addr)
-						  + (sglen & AHD_SG_LEN_MASK)
-						  - 1;
-
-					/*
-					 * Increment sg so it points to the
-					 * "next" sg.
-					 */
-					sg++;
-					sgptr = ahd_sg_virt_to_bus(ahd, scb,
-								   sg);
-				}
-			} else {
-				struct ahd_dma_seg *sg;
-
-				sg = ahd_sg_bus_to_virt(ahd, scb, sgptr);
-
-				/*
-				 * The residual sg ptr points to the next S/G
-				 * to load so we must go back one.
-				 */
-				sg--;
-				sglen = ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;
-				if (sg != scb->sg_list
-				 && sglen < (data_cnt & AHD_SG_LEN_MASK)) {
-
-					sg--;
-					sglen = ahd_le32toh(sg->len);
-					/*
-					 * Preserve High Address and SG_LIST
-					 * bits while setting the count to 1.
-					 */
-					data_cnt = 1|(sglen&(~AHD_SG_LEN_MASK));
-					data_addr = ahd_le32toh(sg->addr)
-						  + (sglen & AHD_SG_LEN_MASK)
-						  - 1;
-
-					/*
-					 * Increment sg so it points to the
-					 * "next" sg.
-					 */
-					sg++;
-					sgptr = ahd_sg_virt_to_bus(ahd, scb,
-								  sg);
-				}
-			}
-			ahd_outb(ahd, SCB_RESIDUAL_SGPTR + 3, sgptr >> 24);
-			ahd_outb(ahd, SCB_RESIDUAL_SGPTR + 2, sgptr >> 16);
-			ahd_outb(ahd, SCB_RESIDUAL_SGPTR + 1, sgptr >> 8);
-			ahd_outb(ahd, SCB_RESIDUAL_SGPTR, sgptr);
-
-			ahd_outb(ahd, SCB_RESIDUAL_DATACNT + 3, data_cnt >> 24);
-			ahd_outb(ahd, SCB_RESIDUAL_DATACNT + 2, data_cnt >> 16);
-			ahd_outb(ahd, SCB_RESIDUAL_DATACNT + 1, data_cnt >> 8);
-			ahd_outb(ahd, SCB_RESIDUAL_DATACNT, data_cnt);
-
-			/*
-			 * The FIFO's pointers will be updated if/when the
-			 * sequencer re-enters a data phase.
-			 */
-		}
-	}
-}
-
-
-/*
- * Reinitialize the data pointers for the active transfer
- * based on its current residual.
- */
-static void
-ahd_reinitialize_dataptrs(struct ahd_softc *ahd)
-{
-	struct		 scb *scb;
-	ahd_mode_state	 saved_modes;
-	u_int		 scb_index;
-	u_int		 wait;
-	uint32_t	 sgptr;
-	uint32_t	 resid;
-	uint64_t	 dataptr;
-
-	AHD_ASSERT_MODES(ahd, AHD_MODE_DFF0_MSK|AHD_MODE_DFF1_MSK,
-			 AHD_MODE_DFF0_MSK|AHD_MODE_DFF1_MSK);
-			 
-	scb_index = ahd_get_scbptr(ahd);
-	scb = ahd_lookup_scb(ahd, scb_index);
-
-	/*
-	 * Release and reacquire the FIFO so we
-	 * have a clean slate.
-	 */
-	ahd_outb(ahd, DFFSXFRCTL, CLRCHN);
-	wait = 1000;
-	do {
-		ahd_delay(100);
-	} while (--wait && !(ahd_inb(ahd, MDFFSTAT) & FIFOFREE));
-	if (wait == 0) {
-		ahd_print_path(ahd, scb);
-		printf("ahd_reinitialize_dataptrs: Forcing FIFO free.\n");
-		ahd_outb(ahd, DFFSXFRCTL, RSTCHN|CLRSHCNT);
-	}
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	ahd_outb(ahd, DFFSTAT,
-		 ahd_inb(ahd, DFFSTAT)
-		| (saved_modes == 0x11 ? CURRFIFO_1 : CURRFIFO_0));
-
-	/*
-	 * Determine initial values for data_addr and data_cnt
-	 * for resuming the data phase.
-	 */
-	sgptr = (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 3) << 24)
-	      | (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 2) << 16)
-	      | (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 1) << 8)
-	      |	ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR);
-	sgptr &= SG_PTR_MASK;
-
-	resid = (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT + 2) << 16)
-	      | (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT + 1) << 8)
-	      | ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT);
-
-	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
-		struct ahd_dma64_seg *sg;
-
-		sg = ahd_sg_bus_to_virt(ahd, scb, sgptr);
-
-		/* The residual sg_ptr always points to the next sg */
-		sg--;
-
-		dataptr = ahd_le64toh(sg->addr)
-			+ (ahd_le32toh(sg->len) & AHD_SG_LEN_MASK)
-			- resid;
-		ahd_outb(ahd, HADDR + 7, dataptr >> 56);
-		ahd_outb(ahd, HADDR + 6, dataptr >> 48);
-		ahd_outb(ahd, HADDR + 5, dataptr >> 40);
-		ahd_outb(ahd, HADDR + 4, dataptr >> 32);
-	} else {
-		struct	 ahd_dma_seg *sg;
-
-		sg = ahd_sg_bus_to_virt(ahd, scb, sgptr);
-
-		/* The residual sg_ptr always points to the next sg */
-		sg--;
-
-		dataptr = ahd_le32toh(sg->addr)
-			+ (ahd_le32toh(sg->len) & AHD_SG_LEN_MASK)
-			- resid;
-		ahd_outb(ahd, HADDR + 4,
-			 (ahd_le32toh(sg->len) & ~AHD_SG_LEN_MASK) >> 24);
-	}
-	ahd_outb(ahd, HADDR + 3, dataptr >> 24);
-	ahd_outb(ahd, HADDR + 2, dataptr >> 16);
-	ahd_outb(ahd, HADDR + 1, dataptr >> 8);
-	ahd_outb(ahd, HADDR, dataptr);
-	ahd_outb(ahd, HCNT + 2, resid >> 16);
-	ahd_outb(ahd, HCNT + 1, resid >> 8);
-	ahd_outb(ahd, HCNT, resid);
-}
-
-/*
- * Handle the effects of issuing a bus device reset message.
- */
-static void
-ahd_handle_devreset(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
-		    u_int lun, cam_status status, char *message,
-		    int verbose_level)
-{
-#ifdef AHD_TARGET_MODE
-	struct ahd_tmode_tstate* tstate;
-#endif
-	int found;
-
-	found = ahd_abort_scbs(ahd, devinfo->target, devinfo->channel,
-			       lun, SCB_LIST_NULL, devinfo->role,
-			       status);
-
-#ifdef AHD_TARGET_MODE
-	/*
-	 * Send an immediate notify ccb to all target mord peripheral
-	 * drivers affected by this action.
-	 */
-	tstate = ahd->enabled_targets[devinfo->our_scsiid];
-	if (tstate != NULL) {
-		u_int cur_lun;
-		u_int max_lun;
-
-		if (lun != CAM_LUN_WILDCARD) {
-			cur_lun = 0;
-			max_lun = AHD_NUM_LUNS - 1;
-		} else {
-			cur_lun = lun;
-			max_lun = lun;
-		}
-		for (cur_lun <= max_lun; cur_lun++) {
-			struct ahd_tmode_lstate* lstate;
-
-			lstate = tstate->enabled_luns[cur_lun];
-			if (lstate == NULL)
-				continue;
-
-			ahd_queue_lstate_event(ahd, lstate, devinfo->our_scsiid,
-					       MSG_BUS_DEV_RESET, /*arg*/0);
-			ahd_send_lstate_events(ahd, lstate);
-		}
-	}
-#endif
-
-	/*
-	 * Go back to async/narrow transfers and renegotiate.
-	 */
-	ahd_set_width(ahd, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
-		      AHD_TRANS_CUR, /*paused*/TRUE);
-	ahd_set_syncrate(ahd, devinfo, /*period*/0, /*offset*/0,
-			 /*ppr_options*/0, AHD_TRANS_CUR, /*paused*/TRUE);
-	
-	ahd_send_async(ahd, devinfo->channel, devinfo->target,
-		       lun, AC_SENT_BDR, NULL);
-
-	if (message != NULL
-	 && (verbose_level <= bootverbose))
-		printf("%s: %s on %c:%d. %d SCBs aborted\n", ahd_name(ahd),
-		       message, devinfo->channel, devinfo->target, found);
-}
-
-#ifdef AHD_TARGET_MODE
-static void
-ahd_setup_target_msgin(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
-		       struct scb *scb)
-{
-
-	/*              
-	 * To facilitate adding multiple messages together,
-	 * each routine should increment the index and len
-	 * variables instead of setting them explicitly.
-	 */             
-	ahd->msgout_index = 0;
-	ahd->msgout_len = 0;
-
-	if (scb != NULL && (scb->flags & SCB_AUTO_NEGOTIATE) != 0)
-		ahd_build_transfer_msg(ahd, devinfo);
-	else
-		panic("ahd_intr: AWAITING target message with no message");
-
-	ahd->msgout_index = 0;
-	ahd->msg_type = MSG_TYPE_TARGET_MSGIN;
-}
-#endif
-/**************************** Initialization **********************************/
-static u_int
-ahd_sglist_size(struct ahd_softc *ahd)
-{
-	bus_size_t list_size;
-
-	list_size = sizeof(struct ahd_dma_seg) * AHD_NSEG;
-	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)
-		list_size = sizeof(struct ahd_dma64_seg) * AHD_NSEG;
-	return (list_size);
-}
-
-/*
- * Calculate the optimum S/G List allocation size.  S/G elements used
- * for a given transaction must be physically contiguous.  Assume the
- * OS will allocate full pages to us, so it doesn't make sense to request
- * less than a page.
- */
-static u_int
-ahd_sglist_allocsize(struct ahd_softc *ahd)
-{
-	bus_size_t sg_list_increment;
-	bus_size_t sg_list_size;
-	bus_size_t max_list_size;
-	bus_size_t best_list_size;
-
-	/* Start out with the minimum required for AHD_NSEG. */
-	sg_list_increment = ahd_sglist_size(ahd);
-	sg_list_size = sg_list_increment;
-
-	/* Get us as close as possible to a page in size. */
-	while ((sg_list_size + sg_list_increment) <= PAGE_SIZE)
-		sg_list_size += sg_list_increment;
-
-	/*
-	 * Try to reduce the amount of wastage by allocating
-	 * multiple pages.
-	 */
-	best_list_size = sg_list_size;
-	max_list_size = roundup(sg_list_increment, PAGE_SIZE);
-	if (max_list_size < 4 * PAGE_SIZE)
-		max_list_size = 4 * PAGE_SIZE;
-	if (max_list_size > (AHD_SCB_MAX_ALLOC * sg_list_increment))
-		max_list_size = (AHD_SCB_MAX_ALLOC * sg_list_increment);
-	while ((sg_list_size + sg_list_increment) <= max_list_size
-	   &&  (sg_list_size % PAGE_SIZE) != 0) {
-		bus_size_t new_mod;
-		bus_size_t best_mod;
-
-		sg_list_size += sg_list_increment;
-		new_mod = sg_list_size % PAGE_SIZE;
-		best_mod = best_list_size % PAGE_SIZE;
-		if (new_mod > best_mod || new_mod == 0) {
-			best_list_size = sg_list_size;
-		}
-	}
-	return (best_list_size);
-}
-
-/*
- * Allocate a controller structure for a new device
- * and perform initial initializion.
- */
-struct ahd_softc *
-ahd_alloc(void *platform_arg, char *name)
-{
-	struct  ahd_softc *ahd;
-
-#ifndef	__FreeBSD__
-	ahd = malloc(sizeof(*ahd), M_DEVBUF, M_NOWAIT);
-	if (!ahd) {
-		printf("aic7xxx: cannot malloc softc!\n");
-		free(name, M_DEVBUF);
-		return NULL;
-	}
-#else
-	ahd = device_get_softc((device_t)platform_arg);
-#endif
-	memset(ahd, 0, sizeof(*ahd));
-	ahd->seep_config = malloc(sizeof(*ahd->seep_config),
-				  M_DEVBUF, M_NOWAIT);
-	if (ahd->seep_config == NULL) {
-#ifndef	__FreeBSD__
-		free(ahd, M_DEVBUF);
-#endif
-		free(name, M_DEVBUF);
-		return (NULL);
-	}
-	LIST_INIT(&ahd->pending_scbs);
-	/* We don't know our unit number until the OSM sets it */
-	ahd->name = name;
-	ahd->unit = -1;
-	ahd->description = NULL;
-	ahd->bus_description = NULL;
-	ahd->channel = 'A';
-	ahd->chip = AHD_NONE;
-	ahd->features = AHD_FENONE;
-	ahd->bugs = AHD_BUGNONE;
-	ahd->flags = AHD_SPCHK_ENB_A|AHD_RESET_BUS_A|AHD_TERM_ENB_A
-		   | AHD_EXTENDED_TRANS_A|AHD_STPWLEVEL_A;
-	ahd_timer_init(&ahd->reset_timer);
-	ahd_timer_init(&ahd->stat_timer);
-	ahd->int_coalessing_timer = AHD_INT_COALESSING_TIMER_DEFAULT;
-	ahd->int_coalessing_maxcmds = AHD_INT_COALESSING_MAXCMDS_DEFAULT;
-	ahd->int_coalessing_mincmds = AHD_INT_COALESSING_MINCMDS_DEFAULT;
-	ahd->int_coalessing_threshold = AHD_INT_COALESSING_THRESHOLD_DEFAULT;
-	ahd->int_coalessing_stop_threshold =
-	    AHD_INT_COALESSING_STOP_THRESHOLD_DEFAULT;
-
-	if (ahd_platform_alloc(ahd, platform_arg) != 0) {
-		ahd_free(ahd);
-		ahd = NULL;
-	}
-#ifdef AHD_DEBUG
-	if ((ahd_debug & AHD_SHOW_MEMORY) != 0) {
-		printf("%s: scb size = 0x%x, hscb size = 0x%x\n",
-		       ahd_name(ahd), (u_int)sizeof(struct scb),
-		       (u_int)sizeof(struct hardware_scb));
-	}
-#endif
-	return (ahd);
-}
-
-int
-ahd_softc_init(struct ahd_softc *ahd)
-{
-
-	ahd->unpause = 0;
-	ahd->pause = PAUSE; 
-	return (0);
-}
-
-void
-ahd_softc_insert(struct ahd_softc *ahd)
-{
-	struct ahd_softc *list_ahd;
-
-#if AHD_PCI_CONFIG > 0
-	/*
-	 * Second Function PCI devices need to inherit some
-	 * settings from function 0.
-	 */
-	if ((ahd->features & AHD_MULTI_FUNC) != 0) {
-		TAILQ_FOREACH(list_ahd, &ahd_tailq, links) {
-			ahd_dev_softc_t list_pci;
-			ahd_dev_softc_t pci;
-
-			list_pci = list_ahd->dev_softc;
-			pci = ahd->dev_softc;
-			if (ahd_get_pci_slot(list_pci) == ahd_get_pci_slot(pci)
-			 && ahd_get_pci_bus(list_pci) == ahd_get_pci_bus(pci)) {
-				struct ahd_softc *master;
-				struct ahd_softc *slave;
-
-				if (ahd_get_pci_function(list_pci) == 0) {
-					master = list_ahd;
-					slave = ahd;
-				} else {
-					master = ahd;
-					slave = list_ahd;
-				}
-				slave->flags &= ~AHD_BIOS_ENABLED; 
-				slave->flags |=
-				    master->flags & AHD_BIOS_ENABLED;
-				slave->flags &= ~AHD_PRIMARY_CHANNEL; 
-				slave->flags |=
-				    master->flags & AHD_PRIMARY_CHANNEL;
-				break;
-			}
-		}
-	}
-#endif
-
-	/*
-	 * Insertion sort into our list of softcs.
-	 */
-	list_ahd = TAILQ_FIRST(&ahd_tailq);
-	while (list_ahd != NULL
-	    && ahd_softc_comp(list_ahd, ahd) <= 0)
-		list_ahd = TAILQ_NEXT(list_ahd, links);
-	if (list_ahd != NULL)
-		TAILQ_INSERT_BEFORE(list_ahd, ahd, links);
-	else
-		TAILQ_INSERT_TAIL(&ahd_tailq, ahd, links);
-	ahd->init_level++;
-}
-
-/*
- * Verify that the passed in softc pointer is for a
- * controller that is still configured.
- */
-struct ahd_softc *
-ahd_find_softc(struct ahd_softc *ahd)
-{
-	struct ahd_softc *list_ahd;
-
-	TAILQ_FOREACH(list_ahd, &ahd_tailq, links) {
-		if (list_ahd == ahd)
-			return (ahd);
-	}
-	return (NULL);
-}
-
-void
-ahd_set_unit(struct ahd_softc *ahd, int unit)
-{
-	ahd->unit = unit;
-}
-
-void
-ahd_set_name(struct ahd_softc *ahd, char *name)
-{
-	if (ahd->name != NULL)
-		free(ahd->name, M_DEVBUF);
-	ahd->name = name;
-}
-
-void
-ahd_free(struct ahd_softc *ahd)
-{
-	int i;
-
-	ahd_fini_scbdata(ahd);
-	switch (ahd->init_level) {
-	default:
-	case 5:
-		ahd_shutdown(ahd);
-		TAILQ_REMOVE(&ahd_tailq, ahd, links);
-		/* FALLTHROUGH */
-	case 4:
-		ahd_dmamap_unload(ahd, ahd->shared_data_dmat,
-				  ahd->shared_data_dmamap);
-		/* FALLTHROUGH */
-	case 3:
-		ahd_dmamem_free(ahd, ahd->shared_data_dmat, ahd->qoutfifo,
-				ahd->shared_data_dmamap);
-		ahd_dmamap_destroy(ahd, ahd->shared_data_dmat,
-				   ahd->shared_data_dmamap);
-		/* FALLTHROUGH */
-	case 2:
-		ahd_dma_tag_destroy(ahd, ahd->shared_data_dmat);
-	case 1:
-#ifndef __linux__
-		ahd_dma_tag_destroy(ahd, ahd->buffer_dmat);
-#endif
-		break;
-	case 0:
-		break;
-	}
-
-#ifndef __linux__
-	ahd_dma_tag_destroy(ahd, ahd->parent_dmat);
-#endif
-	ahd_platform_free(ahd);
-	for (i = 0; i < AHD_NUM_TARGETS; i++) {
-		struct ahd_tmode_tstate *tstate;
-
-		tstate = ahd->enabled_targets[i];
-		if (tstate != NULL) {
-#if AHD_TARGET_MODE
-			int j;
-
-			for (j = 0; j < AHD_NUM_LUNS; j++) {
-				struct ahd_tmode_lstate *lstate;
-
-				lstate = tstate->enabled_luns[j];
-				if (lstate != NULL) {
-					xpt_free_path(lstate->path);
-					free(lstate, M_DEVBUF);
-				}
-			}
-#endif
-			free(tstate, M_DEVBUF);
-		}
-	}
-#if AHD_TARGET_MODE
-	if (ahd->black_hole != NULL) {
-		xpt_free_path(ahd->black_hole->path);
-		free(ahd->black_hole, M_DEVBUF);
-	}
-#endif
-	if (ahd->name != NULL)
-		free(ahd->name, M_DEVBUF);
-	if (ahd->seep_config != NULL)
-		free(ahd->seep_config, M_DEVBUF);
-	if (ahd->saved_stack != NULL)
-		free(ahd->saved_stack, M_DEVBUF);
-#ifndef __FreeBSD__
-	free(ahd, M_DEVBUF);
-#endif
-	return;
-}
-
-void
-ahd_shutdown(void *arg)
-{
-	struct	ahd_softc *ahd;
-
-	ahd = (struct ahd_softc *)arg;
-
-	/*
-	 * Stop periodic timer callbacks.
-	 */
-	ahd_timer_stop(&ahd->reset_timer);
-	ahd_timer_stop(&ahd->stat_timer);
-
-	/* This will reset most registers to 0, but not all */
-	ahd_reset(ahd);
-}
-
-/*
- * Reset the controller and record some information about it
- * that is only available just after a reset.
- */
-int
-ahd_reset(struct ahd_softc *ahd)
-{
-	u_int	 sxfrctl1;
-	int	 wait;
-	uint32_t cmd;
-	
-	/*
-	 * Preserve the value of the SXFRCTL1 register for all channels.
-	 * It contains settings that affect termination and we don't want
-	 * to disturb the integrity of the bus.
-	 */
-	ahd_pause(ahd);
-	sxfrctl1 = ahd_inb(ahd, SXFRCTL1);
-
-	cmd = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, /*bytes*/2);
-	if ((ahd->bugs & AHD_PCIX_CHIPRST_BUG) != 0) {
-		uint32_t mod_cmd;
-
-		/*
-		 * A4 Razor #632
-		 * During the assertion of CHIPRST, the chip
-		 * does not disable its parity logic prior to
-		 * the start of the reset.  This may cause a
-		 * parity error to be detected and thus a
-		 * spurious SERR or PERR assertion.  Disble
-		 * PERR and SERR responses during the CHIPRST.
-		 */
-		mod_cmd = cmd & ~(PCIM_CMD_PERRESPEN|PCIM_CMD_SERRESPEN);
-		ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
-				     mod_cmd, /*bytes*/2);
-	}
-	ahd_outb(ahd, HCNTRL, CHIPRST | ahd->pause);
-
-	/*
-	 * Ensure that the reset has finished.  We delay 1000us
-	 * prior to reading the register to make sure the chip
-	 * has sufficiently completed its reset to handle register
-	 * accesses.
-	 */
-	wait = 1000;
-	do {
-		ahd_delay(1000);
-	} while (--wait && !(ahd_inb(ahd, HCNTRL) & CHIPRSTACK));
-
-	if (wait == 0) {
-		printf("%s: WARNING - Failed chip reset!  "
-		       "Trying to initialize anyway.\n", ahd_name(ahd));
-	}
-	ahd_outb(ahd, HCNTRL, ahd->pause);
-
-	if ((ahd->bugs & AHD_PCIX_CHIPRST_BUG) != 0) {
-		/*
-		 * Clear any latched PCI error status and restore
-		 * previous SERR and PERR response enables.
-		 */
-		ahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
-				     0xFF, /*bytes*/1);
-		ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
-				     cmd, /*bytes*/2);
-	}
-	/* After a reset, we know the state of the mode register. */
-	ahd_known_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-
-	/* Determine chip configuration */
-	ahd->features &= ~AHD_WIDE;
-	if ((ahd_inb(ahd, SBLKCTL) & SELWIDE) != 0)
-		ahd->features |= AHD_WIDE;
-
-	/*
-	 * Restore SXFRCTL1.
-	 *
-	 * We must always initialize STPWEN to 1 before we
-	 * restore the saved values.  STPWEN is initialized
-	 * to a tri-state condition which can only be cleared
-	 * by turning it on.
-	 */
-	ahd_outb(ahd, SXFRCTL1, sxfrctl1|STPWEN);
-	ahd_outb(ahd, SXFRCTL1, sxfrctl1);
-
-	/*
-	 * If a recovery action has forced a chip reset,
-	 * re-initialize the chip to our likeing.
-	 */
-	if (ahd->init_level > 0)
-		ahd_chip_init(ahd);
-
-	return (0);
-}
-
-/*
- * Determine the number of SCBs available on the controller
- */
-int
-ahd_probe_scbs(struct ahd_softc *ahd) {
-	int i;
-
-	AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
-			 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
-	for (i = 0; i < AHD_SCB_MAX; i++) {
-		int j;
-
-		ahd_set_scbptr(ahd, i);
-		ahd_outw(ahd, SCB_BASE, i);
-		for (j = 2; j < 64; j++)
-			ahd_outb(ahd, SCB_BASE+j, 0);
-		/* Start out life as unallocated (needing an abort) */
-		ahd_outb(ahd, SCB_CONTROL, MK_MESSAGE);
-		if (ahd_inw_scbram(ahd, SCB_BASE) != i)
-			break;
-		ahd_set_scbptr(ahd, 0);
-		if (ahd_inw_scbram(ahd, SCB_BASE) != 0)
-			break;
-	}
-	return (i);
-}
-
-static void
-ahd_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error) 
-{
-	bus_addr_t *baddr;
-
-	baddr = (bus_addr_t *)arg;
-	*baddr = segs->ds_addr;
-}
-
-static void
-ahd_initialize_hscbs(struct ahd_softc *ahd)
-{
-	int i;
-
-	for (i = 0; i < ahd->scb_data.maxhscbs; i++) {
-		ahd_set_scbptr(ahd, i);
-
-		/* Clear the control byte. */
-		ahd_outb(ahd, SCB_CONTROL, 0);
-
-		/* Set the next pointer */
-		ahd_outw(ahd, SCB_NEXT, SCB_LIST_NULL);
-	}
-}
-
-static int
-ahd_init_scbdata(struct ahd_softc *ahd)
-{
-	struct	scb_data *scb_data;
-	int	i;
-
-	scb_data = &ahd->scb_data;
-	TAILQ_INIT(&scb_data->free_scbs);
-	for (i = 0; i < AHD_NUM_TARGETS * AHD_NUM_LUNS_NONPKT; i++)
-		LIST_INIT(&scb_data->free_scb_lists[i]);
-	LIST_INIT(&scb_data->any_dev_free_scb_list);
-	SLIST_INIT(&scb_data->hscb_maps);
-	SLIST_INIT(&scb_data->sg_maps);
-	SLIST_INIT(&scb_data->sense_maps);
-
-	/* Determine the number of hardware SCBs and initialize them */
-	scb_data->maxhscbs = ahd_probe_scbs(ahd);
-	if (scb_data->maxhscbs == 0) {
-		printf("%s: No SCB space found\n", ahd_name(ahd));
-		return (ENXIO);
-	}
-
-	ahd_initialize_hscbs(ahd);
-
-	/*
-	 * Create our DMA tags.  These tags define the kinds of device
-	 * accessible memory allocations and memory mappings we will
-	 * need to perform during normal operation.
-	 *
-	 * Unless we need to further restrict the allocation, we rely
-	 * on the restrictions of the parent dmat, hence the common
-	 * use of MAXADDR and MAXSIZE.
-	 */
-
-	/* DMA tag for our hardware scb structures */
-	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
-			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
-			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
-			       /*highaddr*/BUS_SPACE_MAXADDR,
-			       /*filter*/NULL, /*filterarg*/NULL,
-			       PAGE_SIZE, /*nsegments*/1,
-			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
-			       /*flags*/0, &scb_data->hscb_dmat) != 0) {
-		goto error_exit;
-	}
-
-	scb_data->init_level++;
-
-	/* DMA tag for our S/G structures. */
-	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
-			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
-			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
-			       /*highaddr*/BUS_SPACE_MAXADDR,
-			       /*filter*/NULL, /*filterarg*/NULL,
-			       ahd_sglist_allocsize(ahd), /*nsegments*/1,
-			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
-			       /*flags*/0, &scb_data->sg_dmat) != 0) {
-		goto error_exit;
-	}
-#ifdef AHD_DEBUG
-	if ((ahd_debug & AHD_SHOW_MEMORY) != 0)
-		printf("%s: ahd_sglist_allocsize = 0x%x\n", ahd_name(ahd),
-		       ahd_sglist_allocsize(ahd));
-#endif
-
-	scb_data->init_level++;
-
-	/* DMA tag for our sense buffers.  We allocate in page sized chunks */
-	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
-			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
-			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
-			       /*highaddr*/BUS_SPACE_MAXADDR,
-			       /*filter*/NULL, /*filterarg*/NULL,
-			       PAGE_SIZE, /*nsegments*/1,
-			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
-			       /*flags*/0, &scb_data->sense_dmat) != 0) {
-		goto error_exit;
-	}
-
-	scb_data->init_level++;
-
-	/* Perform initial CCB allocation */
-	ahd_alloc_scbs(ahd);
-
-	if (scb_data->numscbs == 0) {
-		printf("%s: ahd_init_scbdata - "
-		       "Unable to allocate initial scbs\n",
-		       ahd_name(ahd));
-		goto error_exit;
-	}
-
-	/*
-	 * Note that we were successfull
-	 */
-	return (0); 
-
-error_exit:
-
-	return (ENOMEM);
-}
-
-static struct scb *
-ahd_find_scb_by_tag(struct ahd_softc *ahd, u_int tag)
-{
-	struct scb *scb;
-
-	/*
-	 * Look on the pending list.
-	 */
-	LIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {
-		if (SCB_GET_TAG(scb) == tag)
-			return (scb);
-	}
-
-	/*
-	 * Then on all of the collision free lists.
-	 */
-	TAILQ_FOREACH(scb, &ahd->scb_data.free_scbs, links.tqe) {
-		struct scb *list_scb;
-
-		list_scb = scb;
-		do {
-			if (SCB_GET_TAG(list_scb) == tag)
-				return (list_scb);
-			list_scb = LIST_NEXT(list_scb, collision_links);
-		} while (list_scb);
-	}
-
-	/*
-	 * And finally on the generic free list.
-	 */
-	LIST_FOREACH(scb, &ahd->scb_data.any_dev_free_scb_list, links.le) {
-		if (SCB_GET_TAG(scb) == tag)
-			return (scb);
-	}
-
-	return (NULL);
-}
-
-static void
-ahd_fini_scbdata(struct ahd_softc *ahd)
-{
-	struct scb_data *scb_data;
-
-	scb_data = &ahd->scb_data;
-	if (scb_data == NULL)
-		return;
-
-	switch (scb_data->init_level) {
-	default:
-	case 7:
-	{
-		struct map_node *sns_map;
-
-		while ((sns_map = SLIST_FIRST(&scb_data->sense_maps)) != NULL) {
-			SLIST_REMOVE_HEAD(&scb_data->sense_maps, links);
-			ahd_dmamap_unload(ahd, scb_data->sense_dmat,
-					  sns_map->dmamap);
-			ahd_dmamem_free(ahd, scb_data->sense_dmat,
-					sns_map->vaddr, sns_map->dmamap);
-			free(sns_map, M_DEVBUF);
-		}
-		ahd_dma_tag_destroy(ahd, scb_data->sense_dmat);
-		/* FALLTHROUGH */
-	}
-	case 6:
-	{
-		struct map_node *sg_map;
-
-		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps)) != NULL) {
-			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
-			ahd_dmamap_unload(ahd, scb_data->sg_dmat,
-					  sg_map->dmamap);
-			ahd_dmamem_free(ahd, scb_data->sg_dmat,
-					sg_map->vaddr, sg_map->dmamap);
-			free(sg_map, M_DEVBUF);
-		}
-		ahd_dma_tag_destroy(ahd, scb_data->sg_dmat);
-		/* FALLTHROUGH */
-	}
-	case 5:
-	{
-		struct map_node *hscb_map;
-
-		while ((hscb_map = SLIST_FIRST(&scb_data->hscb_maps)) != NULL) {
-			SLIST_REMOVE_HEAD(&scb_data->hscb_maps, links);
-			ahd_dmamap_unload(ahd, scb_data->hscb_dmat,
-					  hscb_map->dmamap);
-			ahd_dmamem_free(ahd, scb_data->hscb_dmat,
-					hscb_map->vaddr, hscb_map->dmamap);
-			free(hscb_map, M_DEVBUF);
-		}
-		ahd_dma_tag_destroy(ahd, scb_data->hscb_dmat);
-		/* FALLTHROUGH */
-	}
-	case 4:
-	case 3:
-	case 2:
-	case 1:
-	case 0:
-		break;
-	}
-}
-
-/*
- * DSP filter Bypass must be enabled until the first selection
- * after a change in bus mode (Razor #491 and #493).
- */
-static void
-ahd_setup_iocell_workaround(struct ahd_softc *ahd)
-{
-	ahd_mode_state saved_modes;
-
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
-	ahd_outb(ahd, DSPDATACTL, ahd_inb(ahd, DSPDATACTL)
-	       | BYPASSENAB | RCVROFFSTDIS | XMITOFFSTDIS);
-	ahd_outb(ahd, SIMODE0, ahd_inb(ahd, SIMODE0) | (ENSELDO|ENSELDI));
-#ifdef AHD_DEBUG
-	if ((ahd_debug & AHD_SHOW_MISC) != 0)
-		printf("%s: Setting up iocell workaround\n", ahd_name(ahd));
-#endif
-	ahd_restore_modes(ahd, saved_modes);
-}
-
-static void
-ahd_iocell_first_selection(struct ahd_softc *ahd)
-{
-	ahd_mode_state	saved_modes;
-	u_int		sblkctl;
-
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	sblkctl = ahd_inb(ahd, SBLKCTL);
-	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
-#ifdef AHD_DEBUG
-	if ((ahd_debug & AHD_SHOW_MISC) != 0)
-		printf("%s: iocell first selection\n", ahd_name(ahd));
-#endif
-	if ((sblkctl & ENAB40) != 0) {
-		ahd_outb(ahd, DSPDATACTL,
-			 ahd_inb(ahd, DSPDATACTL) & ~BYPASSENAB);
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_MISC) != 0)
-			printf("%s: BYPASS now disabled\n", ahd_name(ahd));
-#endif
-	}
-	ahd_outb(ahd, SIMODE0, ahd_inb(ahd, SIMODE0) & ~(ENSELDO|ENSELDI));
-	ahd_outb(ahd, CLRINT, CLRSCSIINT);
-	ahd_restore_modes(ahd, saved_modes);
-}
-
-/*************************** SCB Management ***********************************/
-static void
-ahd_add_col_list(struct ahd_softc *ahd, struct scb *scb, u_int col_idx)
-{
-	struct	scb_list *free_list;
-	struct	scb_tailq *free_tailq;
-	struct	scb *first_scb;
-
-	scb->flags |= SCB_ON_COL_LIST;
-	AHD_SET_SCB_COL_IDX(scb, col_idx);
-	free_list = &ahd->scb_data.free_scb_lists[col_idx];
-	free_tailq = &ahd->scb_data.free_scbs;
-	first_scb = LIST_FIRST(free_list);
-	if (first_scb != NULL) {
-		LIST_INSERT_AFTER(first_scb, scb, collision_links);
-	} else {
-		LIST_INSERT_HEAD(free_list, scb, collision_links);
-		TAILQ_INSERT_TAIL(free_tailq, scb, links.tqe);
-	}
-}
-
-static void
-ahd_rem_col_list(struct ahd_softc *ahd, struct scb *scb)
-{
-	struct	scb_list *free_list;
-	struct	scb_tailq *free_tailq;
-	struct	scb *first_scb;
-	u_int	col_idx;
-
-	scb->flags &= ~SCB_ON_COL_LIST;
-	col_idx = AHD_GET_SCB_COL_IDX(ahd, scb);
-	free_list = &ahd->scb_data.free_scb_lists[col_idx];
-	free_tailq = &ahd->scb_data.free_scbs;
-	first_scb = LIST_FIRST(free_list);
-	if (first_scb == scb) {
-		struct scb *next_scb;
-
-		/*
-		 * Maintain order in the collision free
-		 * lists for fairness if this device has
-		 * other colliding tags active.
-		 */
-		next_scb = LIST_NEXT(scb, collision_links);
-		if (next_scb != NULL) {
-			TAILQ_INSERT_AFTER(free_tailq, scb,
-					   next_scb, links.tqe);
-		}
-		TAILQ_REMOVE(free_tailq, scb, links.tqe);
-	}
-	LIST_REMOVE(scb, collision_links);
-}
-
-/*
- * Get a free scb. If there are none, see if we can allocate a new SCB.
- */
-struct scb *
-ahd_get_scb(struct ahd_softc *ahd, u_int col_idx)
-{
-	struct scb *scb;
-	int tries;
-
-	tries = 0;
-look_again:
-	TAILQ_FOREACH(scb, &ahd->scb_data.free_scbs, links.tqe) {
-		if (AHD_GET_SCB_COL_IDX(ahd, scb) != col_idx) {
-			ahd_rem_col_list(ahd, scb);
-			goto found;
-		}
-	}
-	if ((scb = LIST_FIRST(&ahd->scb_data.any_dev_free_scb_list)) == NULL) {
-
-		if (tries++ != 0)
-			return (NULL);
-		ahd_alloc_scbs(ahd);
-		goto look_again;
-	}
-	LIST_REMOVE(scb, links.le);
-	if (col_idx != AHD_NEVER_COL_IDX
-	 && (scb->col_scb != NULL)
-	 && (scb->col_scb->flags & SCB_ACTIVE) == 0) {
-		LIST_REMOVE(scb->col_scb, links.le);
-		ahd_add_col_list(ahd, scb->col_scb, col_idx);
-	}
-found:
-	scb->flags |= SCB_ACTIVE;
-	return (scb);
-}
-
-/*
- * Return an SCB resource to the free list.
- */
-void
-ahd_free_scb(struct ahd_softc *ahd, struct scb *scb)
-{       
-
-	/* Clean up for the next user */
-	scb->flags = SCB_FLAG_NONE;
-	scb->hscb->control = 0;
-	ahd->scb_data.scbindex[scb->hscb->tag] = NULL;
-
-	if (scb->col_scb == NULL) {
-
-		/*
-		 * No collision possible.  Just free normally.
-		 */
-		LIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,
-				 scb, links.le);
-	} else if ((scb->col_scb->flags & SCB_ON_COL_LIST) != 0) {
-
-		/*
-		 * The SCB we might have collided with is on
-		 * a free collision list.  Put both SCBs on
-		 * the generic list.
-		 */
-		ahd_rem_col_list(ahd, scb->col_scb);
-		LIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,
-				 scb, links.le);
-		LIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,
-				 scb->col_scb, links.le);
-	} else if ((scb->col_scb->flags
-		  & (SCB_PACKETIZED|SCB_ACTIVE)) == SCB_ACTIVE
-		&& (scb->col_scb->hscb->control & TAG_ENB) != 0) {
-
-		/*
-		 * The SCB we might collide with on the next allocation
-		 * is still active in a non-packetized, tagged, context.
-		 * Put us on the SCB collision list.
-		 */
-		ahd_add_col_list(ahd, scb,
-				 AHD_GET_SCB_COL_IDX(ahd, scb->col_scb));
-	} else {
-		/*
-		 * The SCB we might collide with on the next allocation
-		 * is either active in a packetized context, or free.
-		 * Since we can't collide, put this SCB on the generic
-		 * free list.
-		 */
-		LIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,
-				 scb, links.le);
-	}
-
-	ahd_platform_scb_free(ahd, scb);
-}
-
-void
-ahd_alloc_scbs(struct ahd_softc *ahd)
-{
-	struct scb_data *scb_data;
-	struct scb	*next_scb;
-	struct hardware_scb *hscb;
-	struct map_node *hscb_map;
-	struct map_node *sg_map;
-	struct map_node *sense_map;
-	uint8_t		*segs;
-	uint8_t		*sense_data;
-	bus_addr_t	 hscb_busaddr;
-	bus_addr_t	 sg_busaddr;
-	bus_addr_t	 sense_busaddr;
-	int		 newcount;
-	int		 i;
-
-	scb_data = &ahd->scb_data;
-	if (scb_data->numscbs >= AHD_SCB_MAX_ALLOC)
-		/* Can't allocate any more */
-		return;
-
-	if (scb_data->scbs_left != 0) {
-		int offset;
-
-		offset = (PAGE_SIZE / sizeof(*hscb)) - scb_data->scbs_left;
-		hscb_map = SLIST_FIRST(&scb_data->hscb_maps);
-		hscb = &((struct hardware_scb *)hscb_map->vaddr)[offset];
-		hscb_busaddr = hscb_map->physaddr + (offset * sizeof(*hscb));
-	} else {
-		hscb_map = malloc(sizeof(*hscb_map), M_DEVBUF, M_NOWAIT);
-
-		if (hscb_map == NULL)
-			return;
-
-		/* Allocate the next batch of hardware SCBs */
-		if (ahd_dmamem_alloc(ahd, scb_data->hscb_dmat,
-				     (void **)&hscb_map->vaddr,
-				     BUS_DMA_NOWAIT, &hscb_map->dmamap) != 0) {
-			free(hscb_map, M_DEVBUF);
-			return;
-		}
-
-		SLIST_INSERT_HEAD(&scb_data->hscb_maps, hscb_map, links);
-
-		ahd_dmamap_load(ahd, scb_data->hscb_dmat, hscb_map->dmamap,
-				hscb_map->vaddr, PAGE_SIZE, ahd_dmamap_cb,
-				&hscb_map->physaddr, /*flags*/0);
-
-		hscb = (struct hardware_scb *)hscb_map->vaddr;
-		hscb_busaddr = hscb_map->physaddr;
-		scb_data->scbs_left = PAGE_SIZE / sizeof(*hscb);
-	}
-
-	if (scb_data->sgs_left != 0) {
-		int offset;
-
-		offset = ahd_sglist_allocsize(ahd)
-		       - (scb_data->sgs_left * ahd_sglist_size(ahd));
-		sg_map = SLIST_FIRST(&scb_data->sg_maps);
-		segs = sg_map->vaddr + offset;
-		sg_busaddr = sg_map->physaddr + offset;
-	} else {
-		sg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);
-
-		if (sg_map == NULL)
-			return;
-
-		/* Allocate the next batch of S/G lists */
-		if (ahd_dmamem_alloc(ahd, scb_data->sg_dmat,
-				     (void **)&sg_map->vaddr,
-				     BUS_DMA_NOWAIT, &sg_map->dmamap) != 0) {
-			free(sg_map, M_DEVBUF);
-			return;
-		}
-
-		SLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);
-
-		ahd_dmamap_load(ahd, scb_data->sg_dmat, sg_map->dmamap,
-				sg_map->vaddr, ahd_sglist_allocsize(ahd),
-				ahd_dmamap_cb, &sg_map->physaddr, /*flags*/0);
-
-		segs = sg_map->vaddr;
-		sg_busaddr = sg_map->physaddr;
-		scb_data->sgs_left =
-		    ahd_sglist_allocsize(ahd) / ahd_sglist_size(ahd);
-#ifdef AHD_DEBUG
-		if (ahd_debug & AHD_SHOW_MEMORY)
-			printf("Mapped SG data\n");
-#endif
-	}
-
-	if (scb_data->sense_left != 0) {
-		int offset;
-
-		offset = PAGE_SIZE - (AHD_SENSE_BUFSIZE * scb_data->sense_left);
-		sense_map = SLIST_FIRST(&scb_data->sense_maps);
-		sense_data = sense_map->vaddr + offset;
-		sense_busaddr = sense_map->physaddr + offset;
-	} else {
-		sense_map = malloc(sizeof(*sense_map), M_DEVBUF, M_NOWAIT);
-
-		if (sense_map == NULL)
-			return;
-
-		/* Allocate the next batch of sense buffers */
-		if (ahd_dmamem_alloc(ahd, scb_data->sense_dmat,
-				     (void **)&sense_map->vaddr,
-				     BUS_DMA_NOWAIT, &sense_map->dmamap) != 0) {
-			free(sense_map, M_DEVBUF);
-			return;
-		}
-
-		SLIST_INSERT_HEAD(&scb_data->sense_maps, sense_map, links);
-
-		ahd_dmamap_load(ahd, scb_data->sense_dmat, sense_map->dmamap,
-				sense_map->vaddr, PAGE_SIZE, ahd_dmamap_cb,
-				&sense_map->physaddr, /*flags*/0);
-
-		sense_data = sense_map->vaddr;
-		sense_busaddr = sense_map->physaddr;
-		scb_data->sense_left = PAGE_SIZE / AHD_SENSE_BUFSIZE;
-#ifdef AHD_DEBUG
-		if (ahd_debug & AHD_SHOW_MEMORY)
-			printf("Mapped sense data\n");
-#endif
-	}
-
-	newcount = MIN(scb_data->sense_left, scb_data->scbs_left);
-	newcount = MIN(newcount, scb_data->sgs_left);
-	newcount = MIN(newcount, (AHD_SCB_MAX_ALLOC - scb_data->numscbs));
-	scb_data->sense_left -= newcount;
-	scb_data->scbs_left -= newcount;
-	scb_data->sgs_left -= newcount;
-	for (i = 0; i < newcount; i++) {
-		u_int col_tag;
-
-		struct scb_platform_data *pdata;
-#ifndef __linux__
-		int error;
-#endif
-		next_scb = (struct scb *)malloc(sizeof(*next_scb),
-						M_DEVBUF, M_NOWAIT);
-		if (next_scb == NULL)
-			break;
-
-		pdata = (struct scb_platform_data *)malloc(sizeof(*pdata),
-							   M_DEVBUF, M_NOWAIT);
-		if (pdata == NULL) {
-			free(next_scb, M_DEVBUF);
-			break;
-		}
-		next_scb->platform_data = pdata;
-		next_scb->hscb_map = hscb_map;
-		next_scb->sg_map = sg_map;
-		next_scb->sense_map = sense_map;
-		next_scb->sg_list = segs;
-		next_scb->sense_data = sense_data;
-		next_scb->sense_busaddr = sense_busaddr;
-		next_scb->hscb = hscb;
-		hscb->hscb_busaddr = ahd_htole32(hscb_busaddr);
-
-		/*
-		 * The sequencer always starts with the second entry.
-		 * The first entry is embedded in the scb.
-		 */
-		next_scb->sg_list_busaddr = sg_busaddr;
-		if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)
-			next_scb->sg_list_busaddr
-			    += sizeof(struct ahd_dma64_seg);
-		else
-			next_scb->sg_list_busaddr += sizeof(struct ahd_dma_seg);
-		next_scb->ahd_softc = ahd;
-		next_scb->flags = SCB_FLAG_NONE;
-#ifndef __linux__
-		error = ahd_dmamap_create(ahd, ahd->buffer_dmat, /*flags*/0,
-					  &next_scb->dmamap);
-		if (error != 0) {
-			free(next_scb, M_DEVBUF);
-			free(pdata, M_DEVBUF);
-			break;
-		}
-#endif
-		next_scb->hscb->tag = ahd_htole16(scb_data->numscbs);
-		col_tag = scb_data->numscbs ^ 0x100;
-		next_scb->col_scb = ahd_find_scb_by_tag(ahd, col_tag);
-		if (next_scb->col_scb != NULL)
-			next_scb->col_scb->col_scb = next_scb;
-		ahd_free_scb(ahd, next_scb);
-		hscb++;
-		hscb_busaddr += sizeof(*hscb);
-		segs += ahd_sglist_size(ahd);
-		sg_busaddr += ahd_sglist_size(ahd);
-		sense_data += AHD_SENSE_BUFSIZE;
-		sense_busaddr += AHD_SENSE_BUFSIZE;
-		scb_data->numscbs++;
-	}
-}
-
-void
-ahd_controller_info(struct ahd_softc *ahd, char *buf)
-{
-	const char *speed;
-	const char *type;
-	int len;
-
-	len = sprintf(buf, "%s: ", ahd_chip_names[ahd->chip & AHD_CHIPID_MASK]);
-	buf += len;
-
-	speed = "Ultra320 ";
-	if ((ahd->features & AHD_WIDE) != 0) {
-		type = "Wide ";
-	} else {
-		type = "Single ";
-	}
-	len = sprintf(buf, "%s%sChannel %c, SCSI Id=%d, ",
-		      speed, type, ahd->channel, ahd->our_id);
-	buf += len;
-
-	sprintf(buf, "%s, %d SCBs", ahd->bus_description,
-		ahd->scb_data.maxhscbs);
-}
-
-static const char *channel_strings[] = {
-	"Primary Low",
-	"Primary High",
-	"Secondary Low", 
-	"Secondary High"
-};
-
-static const char *termstat_strings[] = {
-	"Terminated Correctly",
-	"Over Terminated",
-	"Under Terminated",
-	"Not Configured"
-};
-
-/*
- * Start the board, ready for normal operation
- */
-int
-ahd_init(struct ahd_softc *ahd)
-{
-	uint8_t		*base_vaddr;
-	uint8_t		*next_vaddr;
-	bus_addr_t	 next_baddr;
-	size_t		 driver_data_size;
-	int		 i;
-	int		 error;
-	u_int		 warn_user;
-	uint8_t		 current_sensing;
-	uint8_t		 fstat;
-
-	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
-
-	ahd->stack_size = ahd_probe_stack_size(ahd);
-	ahd->saved_stack = malloc(ahd->stack_size * sizeof(uint16_t),
-				  M_DEVBUF, M_NOWAIT);
-	if (ahd->saved_stack == NULL)
-		return (ENOMEM);
-
-	/*
-	 * Verify that the compiler hasn't over-agressively
-	 * padded important structures.
-	 */
-	if (sizeof(struct hardware_scb) != 64)
-		panic("Hardware SCB size is incorrect");
-
-#ifdef AHD_DEBUG
-	if ((ahd_debug & AHD_DEBUG_SEQUENCER) != 0)
-		ahd->flags |= AHD_SEQUENCER_DEBUG;
-#endif
-
-	/*
-	 * Default to allowing initiator operations.
-	 */
-	ahd->flags |= AHD_INITIATORROLE;
-
-	/*
-	 * Only allow target mode features if this unit has them enabled.
-	 */
-	if ((AHD_TMODE_ENABLE & (0x1 << ahd->unit)) == 0)
-		ahd->features &= ~AHD_TARGETMODE;
-
-#ifndef __linux__
-	/* DMA tag for mapping buffers into device visible space. */
-	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
-			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
-			       /*lowaddr*/BUS_SPACE_MAXADDR,
-			       /*highaddr*/BUS_SPACE_MAXADDR,
-			       /*filter*/NULL, /*filterarg*/NULL,
-			       /*maxsize*/(AHD_NSEG - 1) * PAGE_SIZE,
-			       /*nsegments*/AHD_NSEG,
-			       /*maxsegsz*/AHD_MAXTRANSFER_SIZE,
-			       /*flags*/BUS_DMA_ALLOCNOW,
-			       &ahd->buffer_dmat) != 0) {
-		return (ENOMEM);
-	}
-#endif
-
-	ahd->init_level++;
-
-	/*
-	 * DMA tag for our command fifos and other data in system memory
-	 * the card's sequencer must be able to access.  For initiator
-	 * roles, we need to allocate space for the qoutfifo.  When providing
-	 * for the target mode role, we must additionally provide space for
-	 * the incoming target command fifo.
-	 */
-	driver_data_size = AHD_SCB_MAX * sizeof(uint16_t)
-			 + sizeof(struct hardware_scb);
-	if ((ahd->features & AHD_TARGETMODE) != 0)
-		driver_data_size += AHD_TMODE_CMDS * sizeof(struct target_cmd);
-	if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0)
-		driver_data_size += PKT_OVERRUN_BUFSIZE;
-	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
-			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
-			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
-			       /*highaddr*/BUS_SPACE_MAXADDR,
-			       /*filter*/NULL, /*filterarg*/NULL,
-			       driver_data_size,
-			       /*nsegments*/1,
-			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
-			       /*flags*/0, &ahd->shared_data_dmat) != 0) {
-		return (ENOMEM);
-	}
-
-	ahd->init_level++;
-
-	/* Allocation of driver data */
-	if (ahd_dmamem_alloc(ahd, ahd->shared_data_dmat,
-			     (void **)&base_vaddr,
-			     BUS_DMA_NOWAIT, &ahd->shared_data_dmamap) != 0) {
-		return (ENOMEM);
-	}
-
-	ahd->init_level++;
-
-	/* And permanently map it in */
-	ahd_dmamap_load(ahd, ahd->shared_data_dmat, ahd->shared_data_dmamap,
-			base_vaddr, driver_data_size, ahd_dmamap_cb,
-			&ahd->shared_data_busaddr, /*flags*/0);
-	ahd->qoutfifo = (uint16_t *)base_vaddr;
-	next_vaddr = (uint8_t *)&ahd->qoutfifo[AHD_QOUT_SIZE];
-	next_baddr = ahd->shared_data_busaddr + AHD_QOUT_SIZE*sizeof(uint16_t);
-	if ((ahd->features & AHD_TARGETMODE) != 0) {
-		ahd->targetcmds = (struct target_cmd *)next_vaddr;
-		next_vaddr += AHD_TMODE_CMDS * sizeof(struct target_cmd);
-		next_baddr += AHD_TMODE_CMDS * sizeof(struct target_cmd);
-	}
-
-	if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0) {
-		ahd->overrun_buf = next_vaddr;
-		next_vaddr += PKT_OVERRUN_BUFSIZE;
-		next_baddr += PKT_OVERRUN_BUFSIZE;
-	}
-
-	/*
-	 * We need one SCB to serve as the "next SCB".  Since the
-	 * tag identifier in this SCB will never be used, there is
-	 * no point in using a valid HSCB tag from an SCB pulled from
-	 * the standard free pool.  So, we allocate this "sentinel"
-	 * specially from the DMA safe memory chunk used for the QOUTFIFO.
-	 */
-	ahd->next_queued_hscb = (struct hardware_scb *)next_vaddr;
-	ahd->next_queued_hscb->hscb_busaddr = next_baddr;
-
-	ahd->init_level++;
-
-	/* Allocate SCB data now that buffer_dmat is initialized */
-	if (ahd_init_scbdata(ahd) != 0)
-		return (ENOMEM);
-
-	if ((ahd->flags & AHD_INITIATORROLE) == 0)
-		ahd->flags &= ~AHD_RESET_BUS_A;
-
-	/*
-	 * Before committing these settings to the chip, give
-	 * the OSM one last chance to modify our configuration.
-	 */
-	ahd_platform_init(ahd);
-
-	/* Bring up the chip. */
-	ahd_chip_init(ahd);
-
-	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
-
-	if ((ahd->flags & AHD_CURRENT_SENSING) == 0)
-		goto init_done;
-
-	/*
-	 * Verify termination based on current draw and
-	 * warn user if the bus is over/under terminated.
-	 */
-	error = ahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL,
-				   CURSENSE_ENB);
-	if (error != 0) {
-		printf("%s: current sensing timeout 1\n", ahd_name(ahd));
-		goto init_done;
-	}
-	for (i = 20, fstat = FLX_FSTAT_BUSY;
-	     (fstat & FLX_FSTAT_BUSY) != 0 && i; i--) {
-		error = ahd_read_flexport(ahd, FLXADDR_FLEXSTAT, &fstat);
-		if (error != 0) {
-			printf("%s: current sensing timeout 2\n",
-			       ahd_name(ahd));
-			goto init_done;
-		}
-	}
-	if (i == 0) {
-		printf("%s: Timedout during current-sensing test\n",
-		       ahd_name(ahd));
-		goto init_done;
-	}
-
-	/* Latch Current Sensing status. */
-	error = ahd_read_flexport(ahd, FLXADDR_CURRENT_STAT, &current_sensing);
-	if (error != 0) {
-		printf("%s: current sensing timeout 3\n", ahd_name(ahd));
-		goto init_done;
-	}
-
-	/* Diable current sensing. */
-	ahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, 0);
-
-#ifdef AHD_DEBUG
-	if ((ahd_debug & AHD_SHOW_TERMCTL) != 0) {
-		printf("%s: current_sensing == 0x%x\n",
-		       ahd_name(ahd), current_sensing);
-	}
-#endif
-	warn_user = 0;
-	for (i = 0; i < 4; i++, current_sensing >>= FLX_CSTAT_SHIFT) {
-		u_int term_stat;
-
-		term_stat = (current_sensing & FLX_CSTAT_MASK);
-		switch (term_stat) {
-		case FLX_CSTAT_OVER:
-		case FLX_CSTAT_UNDER:
-			warn_user++;
-		case FLX_CSTAT_INVALID:
-		case FLX_CSTAT_OKAY:
-			if (warn_user == 0 && bootverbose == 0)
-				break;
-			printf("%s: %s Channel %s\n", ahd_name(ahd),
-			       channel_strings[i], termstat_strings[term_stat]);
-			break;
-		}
-	}
-	if (warn_user) {
-		printf("%s: WARNING. Termination is not configured correctly.\n"
-		       "%s: WARNING. SCSI bus operations may FAIL.\n",
-		       ahd_name(ahd), ahd_name(ahd));
-	}
-init_done:
-	ahd_restart(ahd);
-	ahd_timer_reset(&ahd->stat_timer, AHD_STAT_UPDATE_US,
-			ahd_stat_timer, ahd);
-	return (0);
-}
-
-/*
- * (Re)initialize chip state after a chip reset.
- */
-static void
-ahd_chip_init(struct ahd_softc *ahd)
-{
-	uint32_t busaddr;
-	u_int	 sxfrctl1;
-	u_int	 scsiseq_template;
-	u_int	 wait;
-	u_int	 i;
-	u_int	 target;
-
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	/*
-	 * Take the LED out of diagnostic mode
-	 */
-	ahd_outb(ahd, SBLKCTL, ahd_inb(ahd, SBLKCTL) & ~(DIAGLEDEN|DIAGLEDON));
-
-	/*
-	 * Return HS_MAILBOX to its default value.
-	 */
-	ahd->hs_mailbox = 0;
-	ahd_outb(ahd, HS_MAILBOX, 0);
-
-	/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1. */
-	ahd_outb(ahd, IOWNID, ahd->our_id);
-	ahd_outb(ahd, TOWNID, ahd->our_id);
-	sxfrctl1 = (ahd->flags & AHD_TERM_ENB_A) != 0 ? STPWEN : 0;
-	sxfrctl1 |= (ahd->flags & AHD_SPCHK_ENB_A) != 0 ? ENSPCHK : 0;
-	if ((ahd->bugs & AHD_LONG_SETIMO_BUG)
-	 && (ahd->seltime != STIMESEL_MIN)) {
-		/*
-		 * The selection timer duration is twice as long
-		 * as it should be.  Halve it by adding "1" to
-		 * the user specified setting.
-		 */
-		sxfrctl1 |= ahd->seltime + STIMESEL_BUG_ADJ;
-	} else {
-		sxfrctl1 |= ahd->seltime;
-	}
-		
-	ahd_outb(ahd, SXFRCTL0, DFON);
-	ahd_outb(ahd, SXFRCTL1, sxfrctl1|ahd->seltime|ENSTIMER|ACTNEGEN);
-	ahd_outb(ahd, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);
-
-	/*
-	 * Now that termination is set, wait for up
-	 * to 500ms for our transceivers to settle.  If
-	 * the adapter does not have a cable attached,
-	 * the tranceivers may never settle, so don't
-	 * complain if we fail here.
-	 */
-	for (wait = 10000;
-	     (ahd_inb(ahd, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;
-	     wait--)
-		ahd_delay(100);
-
-	/* Clear any false bus resets due to the transceivers settling */
-	ahd_outb(ahd, CLRSINT1, CLRSCSIRSTI);
-	ahd_outb(ahd, CLRINT, CLRSCSIINT);
-
-	/* Initialize mode specific S/G state. */
-	for (i = 0; i < 2; i++) {
-		ahd_set_modes(ahd, AHD_MODE_DFF0 + i, AHD_MODE_DFF0 + i);
-		ahd_outb(ahd, LONGJMP_ADDR + 1, INVALID_ADDR);
-		ahd_outw(ahd, LONGJMP_SCB, SCB_LIST_NULL);
-		ahd_outb(ahd, SG_STATE, 0);
-		ahd_outb(ahd, CLRSEQINTSRC, 0xFF);
-		ahd_outb(ahd, SEQIMODE,
-			 ENSAVEPTRS|ENCFG4DATA|ENCFG4ISTAT
-			|ENCFG4TSTAT|ENCFG4ICMD|ENCFG4TCMD);
-	}
-
-	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
-	ahd_outb(ahd, DSCOMMAND0, ahd_inb(ahd, DSCOMMAND0)|MPARCKEN|CACHETHEN);
-	ahd_outb(ahd, DFF_THRSH, RD_DFTHRSH_75|WR_DFTHRSH_75);
-	ahd_outb(ahd, SIMODE0, ENIOERR|ENOVERRUN);
-	ahd_outb(ahd, SIMODE3, ENNTRAMPERR|ENOSRAMPERR);
-	if ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0) {
-		ahd_outb(ahd, OPTIONMODE, AUTOACKEN|AUTO_MSGOUT_DE);
-	} else {
-		ahd_outb(ahd, OPTIONMODE, AUTOACKEN|BUSFREEREV|AUTO_MSGOUT_DE);
-	}
-	ahd_outb(ahd, SCSCHKN, CURRFIFODEF|WIDERESEN);
-	if ((ahd->chip & AHD_BUS_MASK) == AHD_PCIX)
-		/*
-		 * Do not issue a target abort when a split completion
-		 * error occurs.  Let our PCIX interrupt handler deal
-		 * with it instead. H2A4 Razor #625
-		 */
-		ahd_outb(ahd, PCIXCTL, ahd_inb(ahd, PCIXCTL) | SPLTSTADIS);
-
-	if ((ahd->bugs & AHD_LQOOVERRUN_BUG) != 0)
-		ahd_outb(ahd, LQOSCSCTL, LQONOCHKOVER);
-
-	/*
-	 * Tweak IOCELL settings.
-	 */
-	if ((ahd->flags & AHD_HP_BOARD) != 0) {
-		for (i = 0; i < NUMDSPS; i++) {
-			ahd_outb(ahd, DSPSELECT, i);
-			ahd_outb(ahd, WRTBIASCTL, WRTBIASCTL_HP_DEFAULT);
-		}
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_MISC) != 0)
-			printf("%s: WRTBIASCTL now 0x%x\n", ahd_name(ahd),
-			       WRTBIASCTL_HP_DEFAULT);
-#endif
-	}
-	ahd_setup_iocell_workaround(ahd);
-
-	/*
-	 * Enable LQI Manager interrupts.
-	 */
-	ahd_outb(ahd, LQIMODE1, ENLQIPHASE_LQ|ENLQIPHASE_NLQ|ENLIQABORT
-			      | ENLQICRCI_LQ|ENLQICRCI_NLQ|ENLQIBADLQI
-			      | ENLQIOVERI_LQ|ENLQIOVERI_NLQ);
-	ahd_outb(ahd, LQOMODE0, ENLQOATNLQ|ENLQOATNPKT|ENLQOTCRC);
-	/*
-	 * An interrupt from LQOBUSFREE is made redundant by the
-	 * BUSFREE interrupt.  We choose to have the sequencer catch
-	 * LQOPHCHGINPKT errors manually for the command phase at the
-	 * start of a packetized selection case.
-	ahd_outb(ahd, LQOMODE1, ENLQOBUSFREE|ENLQOPHACHGINPKT);
-	 */
-	ahd_outb(ahd, LQOMODE1, 0);
-
-	/*
-	 * Setup sequencer interrupt handlers.
-	 */
-	ahd_outw(ahd, INTVEC1_ADDR, ahd_resolve_seqaddr(ahd, LABEL_seq_isr));
-	ahd_outw(ahd, INTVEC2_ADDR, ahd_resolve_seqaddr(ahd, LABEL_timer_isr));
-
-	/*
-	 * Setup SCB Offset registers.
-	 */
-	if ((ahd->bugs & AHD_PKT_LUN_BUG) != 0) {
-		ahd_outb(ahd, LUNPTR, offsetof(struct hardware_scb,
-			 pkt_long_lun));
-	} else {
-		ahd_outb(ahd, LUNPTR, offsetof(struct hardware_scb, lun));
-	}
-	ahd_outb(ahd, CMDLENPTR, offsetof(struct hardware_scb, cdb_len));
-	ahd_outb(ahd, ATTRPTR, offsetof(struct hardware_scb, task_attribute));
-	ahd_outb(ahd, FLAGPTR, offsetof(struct hardware_scb, task_management));
-	ahd_outb(ahd, CMDPTR, offsetof(struct hardware_scb,
-				       shared_data.idata.cdb));
-	ahd_outb(ahd, QNEXTPTR,
-		 offsetof(struct hardware_scb, next_hscb_busaddr));
-	ahd_outb(ahd, ABRTBITPTR, MK_MESSAGE_BIT_OFFSET);
-	ahd_outb(ahd, ABRTBYTEPTR, offsetof(struct hardware_scb, control));
-	if ((ahd->bugs & AHD_PKT_LUN_BUG) != 0) {
-		ahd_outb(ahd, LUNLEN,
-			 sizeof(ahd->next_queued_hscb->pkt_long_lun) - 1);
-	} else {
-		ahd_outb(ahd, LUNLEN, sizeof(ahd->next_queued_hscb->lun) - 1);
-	}
-	ahd_outb(ahd, CDBLIMIT, SCB_CDB_LEN_PTR - 1);
-	ahd_outb(ahd, MAXCMD, 0xFF);
-	ahd_outb(ahd, SCBAUTOPTR,
-		 AUSCBPTR_EN | offsetof(struct hardware_scb, tag));
-
-	/* We haven't been enabled for target mode yet. */
-	ahd_outb(ahd, MULTARGID, 0);
-	ahd_outb(ahd, MULTARGID + 1, 0);
-
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	/* Initialize the negotiation table. */
-	if ((ahd->features & AHD_NEW_IOCELL_OPTS) == 0) {
-		/*
-		 * Clear the spare bytes in the neg table to avoid
-		 * spurious parity errors.
-		 */
-		for (target = 0; target < AHD_NUM_TARGETS; target++) {
-			ahd_outb(ahd, NEGOADDR, target);
-			ahd_outb(ahd, ANNEXCOL, AHD_ANNEXCOL_PER_DEV0);
-			for (i = 0; i < AHD_NUM_PER_DEV_ANNEXCOLS; i++)
-				ahd_outb(ahd, ANNEXDAT, 0);
-		}
-	}
-	for (target = 0; target < AHD_NUM_TARGETS; target++) {
-		struct	 ahd_devinfo devinfo;
-		struct	 ahd_initiator_tinfo *tinfo;
-		struct	 ahd_tmode_tstate *tstate;
-
-		tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
-					    target, &tstate);
-		ahd_compile_devinfo(&devinfo, ahd->our_id,
-				    target, CAM_LUN_WILDCARD,
-				    'A', ROLE_INITIATOR);
-		ahd_update_neg_table(ahd, &devinfo, &tinfo->curr);
-	}
-
-	ahd_outb(ahd, CLRSINT3, NTRAMPERR|OSRAMPERR);
-	ahd_outb(ahd, CLRINT, CLRSCSIINT);
-
-	/*
-	 * Always enable abort on incoming L_Qs if this feature is
-	 * supported.  We use this to catch invalid SCB references.
-	 */
-	if ((ahd->bugs & AHD_ABORT_LQI_BUG) == 0)
-		ahd_outb(ahd, LQCTL1, ABORTPENDING);
-	else
-		ahd_outb(ahd, LQCTL1, 0);
-
-	/* All of our queues are empty */
-	ahd->qoutfifonext = 0;
-	ahd->qoutfifonext_valid_tag = QOUTFIFO_ENTRY_VALID_LE;
-	ahd_outb(ahd, QOUTFIFO_ENTRY_VALID_TAG, QOUTFIFO_ENTRY_VALID >> 8);
-	for (i = 0; i < AHD_QOUT_SIZE; i++)
-		ahd->qoutfifo[i] = 0;
-	ahd_sync_qoutfifo(ahd, BUS_DMASYNC_PREREAD);
-
-	ahd->qinfifonext = 0;
-	for (i = 0; i < AHD_QIN_SIZE; i++)
-		ahd->qinfifo[i] = SCB_LIST_NULL;
-
-	if ((ahd->features & AHD_TARGETMODE) != 0) {
-		/* All target command blocks start out invalid. */
-		for (i = 0; i < AHD_TMODE_CMDS; i++)
-			ahd->targetcmds[i].cmd_valid = 0;
-		ahd_sync_tqinfifo(ahd, BUS_DMASYNC_PREREAD);
-		ahd->tqinfifonext = 1;
-		ahd_outb(ahd, KERNEL_TQINPOS, ahd->tqinfifonext - 1);
-		ahd_outb(ahd, TQINPOS, ahd->tqinfifonext);
-	}
-
-	/* Initialize Scratch Ram. */
-	ahd_outb(ahd, SEQ_FLAGS, 0);
-	ahd_outb(ahd, SEQ_FLAGS2, 0);
-
-	/* We don't have any waiting selections */
-	ahd_outw(ahd, WAITING_TID_HEAD, SCB_LIST_NULL);
-	ahd_outw(ahd, WAITING_TID_TAIL, SCB_LIST_NULL);
-	for (i = 0; i < AHD_NUM_TARGETS; i++)
-		ahd_outw(ahd, WAITING_SCB_TAILS + (2 * i), SCB_LIST_NULL);
-
-	/*
-	 * Nobody is waiting to be DMAed into the QOUTFIFO.
-	 */
-	ahd_outw(ahd, COMPLETE_SCB_HEAD, SCB_LIST_NULL);
-	ahd_outw(ahd, COMPLETE_SCB_DMAINPROG_HEAD, SCB_LIST_NULL);
-	ahd_outw(ahd, COMPLETE_DMA_SCB_HEAD, SCB_LIST_NULL);
-
-	/*
-	 * The Freeze Count is 0.
-	 */
-	ahd_outw(ahd, QFREEZE_COUNT, 0);
-
-	/*
-	 * Tell the sequencer where it can find our arrays in memory.
-	 */
-	busaddr = ahd->shared_data_busaddr;
-	ahd_outb(ahd, SHARED_DATA_ADDR, busaddr & 0xFF);
-	ahd_outb(ahd, SHARED_DATA_ADDR + 1, (busaddr >> 8) & 0xFF);
-	ahd_outb(ahd, SHARED_DATA_ADDR + 2, (busaddr >> 16) & 0xFF);
-	ahd_outb(ahd, SHARED_DATA_ADDR + 3, (busaddr >> 24) & 0xFF);
-	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR, busaddr & 0xFF);
-	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR + 1, (busaddr >> 8) & 0xFF);
-	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR + 2, (busaddr >> 16) & 0xFF);
-	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR + 3, (busaddr >> 24) & 0xFF);
-
-	/*
-	 * Setup the allowed SCSI Sequences based on operational mode.
-	 * If we are a target, we'll enable select in operations once
-	 * we've had a lun enabled.
-	 */
-	scsiseq_template = ENAUTOATNP;
-	if ((ahd->flags & AHD_INITIATORROLE) != 0)
-		scsiseq_template |= ENRSELI;
-	ahd_outb(ahd, SCSISEQ_TEMPLATE, scsiseq_template);
-
-	/* There are no busy SCBs yet. */
-	for (target = 0; target < AHD_NUM_TARGETS; target++) {
-		int lun;
-
-		for (lun = 0; lun < AHD_NUM_LUNS_NONPKT; lun++)
-			ahd_unbusy_tcl(ahd, BUILD_TCL_RAW(target, 'A', lun));
-	}
-
-	/*
-	 * Initialize the group code to command length table.
-	 * Vendor Unique codes are set to 0 so we only capture
-	 * the first byte of the cdb.  These can be overridden
-	 * when target mode is enabled.
-	 */
-	ahd_outb(ahd, CMDSIZE_TABLE, 5);
-	ahd_outb(ahd, CMDSIZE_TABLE + 1, 9);
-	ahd_outb(ahd, CMDSIZE_TABLE + 2, 9);
-	ahd_outb(ahd, CMDSIZE_TABLE + 3, 0);
-	ahd_outb(ahd, CMDSIZE_TABLE + 4, 15);
-	ahd_outb(ahd, CMDSIZE_TABLE + 5, 11);
-	ahd_outb(ahd, CMDSIZE_TABLE + 6, 0);
-	ahd_outb(ahd, CMDSIZE_TABLE + 7, 0);
-		
-	/* Tell the sequencer of our initial queue positions */
-	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
-	ahd_outb(ahd, QOFF_CTLSTA, SCB_QSIZE_512);
-	ahd->qinfifonext = 0;
-	ahd_set_hnscb_qoff(ahd, ahd->qinfifonext);
-	ahd_set_hescb_qoff(ahd, 0);
-	ahd_set_snscb_qoff(ahd, 0);
-	ahd_set_sescb_qoff(ahd, 0);
-	ahd_set_sdscb_qoff(ahd, 0);
-
-	/*
-	 * Tell the sequencer which SCB will be the next one it receives.
-	 */
-	busaddr = ahd_le32toh(ahd->next_queued_hscb->hscb_busaddr);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 0, busaddr & 0xFF);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 1, (busaddr >> 8) & 0xFF);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 2, (busaddr >> 16) & 0xFF);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 3, (busaddr >> 24) & 0xFF);
-
-	/*
-	 * Default to coalessing disabled.
-	 */
-	ahd_outw(ahd, INT_COALESSING_CMDCOUNT, 0);
-	ahd_outw(ahd, CMDS_PENDING, 0);
-	ahd_update_coalessing_values(ahd, ahd->int_coalessing_timer,
-				     ahd->int_coalessing_maxcmds,
-				     ahd->int_coalessing_mincmds);
-	ahd_enable_coalessing(ahd, FALSE);
-
-	ahd_loadseq(ahd);
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-}
-
-/*
- * Setup default device and controller settings.
- * This should only be called if our probe has
- * determined that no configuration data is available.
- */
-int
-ahd_default_config(struct ahd_softc *ahd)
-{
-	int	targ;
-
-	ahd->our_id = 7;
-
-	/*
-	 * Allocate a tstate to house information for our
-	 * initiator presence on the bus as well as the user
-	 * data for any target mode initiator.
-	 */
-	if (ahd_alloc_tstate(ahd, ahd->our_id, 'A') == NULL) {
-		printf("%s: unable to allocate ahd_tmode_tstate.  "
-		       "Failing attach\n", ahd_name(ahd));
-		return (ENOMEM);
-	}
-
-	for (targ = 0; targ < AHD_NUM_TARGETS; targ++) {
-		struct	 ahd_devinfo devinfo;
-		struct	 ahd_initiator_tinfo *tinfo;
-		struct	 ahd_tmode_tstate *tstate;
-		uint16_t target_mask;
-
-		tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
-					    targ, &tstate);
-		/*
-		 * We support SPC2 and SPI4.
-		 */
-		tinfo->user.protocol_version = 4;
-		tinfo->user.transport_version = 4;
-
-		target_mask = 0x01 << targ;
-		ahd->user_discenable |= target_mask;
-		tstate->discenable |= target_mask;
-		ahd->user_tagenable |= target_mask;
-#ifdef AHD_FORCE_160
-		tinfo->user.period = AHD_SYNCRATE_DT;
-#else
-		tinfo->user.period = AHD_SYNCRATE_160;
-#endif
-		tinfo->user.offset= ~0;
-		tinfo->user.ppr_options = MSG_EXT_PPR_RD_STRM
-					| MSG_EXT_PPR_WR_FLOW
-					| MSG_EXT_PPR_HOLD_MCS
-					| MSG_EXT_PPR_IU_REQ
-					| MSG_EXT_PPR_QAS_REQ
-					| MSG_EXT_PPR_DT_REQ;
-		if ((ahd->features & AHD_RTI) != 0)
-			tinfo->user.ppr_options |= MSG_EXT_PPR_RTI;
-
-		tinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;
-
-		/*
-		 * Start out Async/Narrow/Untagged and with
-		 * conservative protocol support.
-		 */
-		tinfo->goal.protocol_version = 2;
-		tinfo->goal.transport_version = 2;
-		tinfo->curr.protocol_version = 2;
-		tinfo->curr.transport_version = 2;
-		ahd_compile_devinfo(&devinfo, ahd->our_id,
-				    targ, CAM_LUN_WILDCARD,
-				    'A', ROLE_INITIATOR);
-		tstate->tagenable &= ~target_mask;
-		ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
-			      AHD_TRANS_CUR|AHD_TRANS_GOAL, /*paused*/TRUE);
-		ahd_set_syncrate(ahd, &devinfo, /*period*/0, /*offset*/0,
-				 /*ppr_options*/0, AHD_TRANS_CUR|AHD_TRANS_GOAL,
-				 /*paused*/TRUE);
-	}
-	return (0);
-}
-
-/*
- * Parse device configuration information.
- */
-int
-ahd_parse_cfgdata(struct ahd_softc *ahd, struct seeprom_config *sc)
-{
-	int targ;
-	int max_targ;
-
-	max_targ = sc->max_targets & CFMAXTARG;
-	ahd->our_id = sc->brtime_id & CFSCSIID;
-
-	/*
-	 * Allocate a tstate to house information for our
-	 * initiator presence on the bus as well as the user
-	 * data for any target mode initiator.
-	 */
-	if (ahd_alloc_tstate(ahd, ahd->our_id, 'A') == NULL) {
-		printf("%s: unable to allocate ahd_tmode_tstate.  "
-		       "Failing attach\n", ahd_name(ahd));
-		return (ENOMEM);
-	}
-
-	for (targ = 0; targ < max_targ; targ++) {
-		struct	 ahd_devinfo devinfo;
-		struct	 ahd_initiator_tinfo *tinfo;
-		struct	 ahd_transinfo *user_tinfo;
-		struct	 ahd_tmode_tstate *tstate;
-		uint16_t target_mask;
-
-		tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
-					    targ, &tstate);
-		user_tinfo = &tinfo->user;
-
-		/*
-		 * We support SPC2 and SPI4.
-		 */
-		tinfo->user.protocol_version = 4;
-		tinfo->user.transport_version = 4;
-
-		target_mask = 0x01 << targ;
-		ahd->user_discenable &= ~target_mask;
-		tstate->discenable &= ~target_mask;
-		ahd->user_tagenable &= ~target_mask;
-		if (sc->device_flags[targ] & CFDISC) {
-			tstate->discenable |= target_mask;
-			ahd->user_discenable |= target_mask;
-			ahd->user_tagenable |= target_mask;
-		} else {
-			/*
-			 * Cannot be packetized without disconnection.
-			 */
-			sc->device_flags[targ] &= ~CFPACKETIZED;
-		}
-
-		user_tinfo->ppr_options = 0;
-		user_tinfo->period = (sc->device_flags[targ] & CFXFER);
-		if (user_tinfo->period < CFXFER_ASYNC) {
-			if (user_tinfo->period <= AHD_PERIOD_10MHz)
-				user_tinfo->ppr_options |= MSG_EXT_PPR_DT_REQ;
-			user_tinfo->offset = MAX_OFFSET;
-		} else  {
-			user_tinfo->offset = 0;
-			user_tinfo->period = AHD_ASYNC_XFER_PERIOD;
-		}
-#ifdef AHD_FORCE_160
-		if (user_tinfo->period <= AHD_SYNCRATE_160)
-			user_tinfo->period = AHD_SYNCRATE_DT;
-#endif
-
-		if ((sc->device_flags[targ] & CFPACKETIZED) != 0) {
-			user_tinfo->ppr_options |= MSG_EXT_PPR_RD_STRM
-						|  MSG_EXT_PPR_WR_FLOW
-						|  MSG_EXT_PPR_HOLD_MCS
-						|  MSG_EXT_PPR_IU_REQ;
-			if ((ahd->features & AHD_RTI) != 0)
-				user_tinfo->ppr_options |= MSG_EXT_PPR_RTI;
-		}
-
-		if ((sc->device_flags[targ] & CFQAS) != 0)
-			user_tinfo->ppr_options |= MSG_EXT_PPR_QAS_REQ;
-
-		if ((sc->device_flags[targ] & CFWIDEB) != 0)
-			user_tinfo->width = MSG_EXT_WDTR_BUS_16_BIT;
-		else
-			user_tinfo->width = MSG_EXT_WDTR_BUS_8_BIT;
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_MISC) != 0)
-			printf("(%d): %x:%x:%x:%x\n", targ, user_tinfo->width,
-			       user_tinfo->period, user_tinfo->offset,
-			       user_tinfo->ppr_options);
-#endif
-		/*
-		 * Start out Async/Narrow/Untagged and with
-		 * conservative protocol support.
-		 */
-		tstate->tagenable &= ~target_mask;
-		tinfo->goal.protocol_version = 2;
-		tinfo->goal.transport_version = 2;
-		tinfo->curr.protocol_version = 2;
-		tinfo->curr.transport_version = 2;
-		ahd_compile_devinfo(&devinfo, ahd->our_id,
-				    targ, CAM_LUN_WILDCARD,
-				    'A', ROLE_INITIATOR);
-		ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
-			      AHD_TRANS_CUR|AHD_TRANS_GOAL, /*paused*/TRUE);
-		ahd_set_syncrate(ahd, &devinfo, /*period*/0, /*offset*/0,
-				 /*ppr_options*/0, AHD_TRANS_CUR|AHD_TRANS_GOAL,
-				 /*paused*/TRUE);
-	}
-
-	ahd->flags &= ~AHD_SPCHK_ENB_A;
-	if (sc->bios_control & CFSPARITY)
-		ahd->flags |= AHD_SPCHK_ENB_A;
-
-	ahd->flags &= ~AHD_RESET_BUS_A;
-	if (sc->bios_control & CFRESETB)
-		ahd->flags |= AHD_RESET_BUS_A;
-
-	ahd->flags &= ~AHD_EXTENDED_TRANS_A;
-	if (sc->bios_control & CFEXTEND)
-		ahd->flags |= AHD_EXTENDED_TRANS_A;
-
-	ahd->flags &= ~AHD_BIOS_ENABLED;
-	if ((sc->bios_control & CFBIOSSTATE) == CFBS_ENABLED)
-		ahd->flags |= AHD_BIOS_ENABLED;
-
-	ahd->flags &= ~AHD_STPWLEVEL_A;
-	if ((sc->adapter_control & CFSTPWLEVEL) != 0)
-		ahd->flags |= AHD_STPWLEVEL_A;
-
-	return (0);
-}
-
-void
-ahd_intr_enable(struct ahd_softc *ahd, int enable)
-{
-	u_int hcntrl;
-
-	hcntrl = ahd_inb(ahd, HCNTRL);
-	hcntrl &= ~INTEN;
-	ahd->pause &= ~INTEN;
-	ahd->unpause &= ~INTEN;
-	if (enable) {
-		hcntrl |= INTEN;
-		ahd->pause |= INTEN;
-		ahd->unpause |= INTEN;
-	}
-	ahd_outb(ahd, HCNTRL, hcntrl);
-}
-
-void
-ahd_update_coalessing_values(struct ahd_softc *ahd, u_int timer, u_int maxcmds,
-			     u_int mincmds)
-{
-	if (timer > AHD_TIMER_MAX_US)
-		timer = AHD_TIMER_MAX_US;
-	ahd->int_coalessing_timer = timer;
-
-	if (maxcmds > AHD_INT_COALESSING_MAXCMDS_MAX)
-		maxcmds = AHD_INT_COALESSING_MAXCMDS_MAX;
-	if (mincmds > AHD_INT_COALESSING_MINCMDS_MAX)
-		mincmds = AHD_INT_COALESSING_MINCMDS_MAX;
-	ahd->int_coalessing_maxcmds = maxcmds;
-	ahd_outw(ahd, INT_COALESSING_TIMER, timer / AHD_TIMER_US_PER_TICK);
-	ahd_outb(ahd, INT_COALESSING_MAXCMDS, -maxcmds);
-	ahd_outb(ahd, INT_COALESSING_MINCMDS, -mincmds);
-}
-
-void
-ahd_enable_coalessing(struct ahd_softc *ahd, int enable)
-{
-
-	ahd->hs_mailbox &= ~ENINT_COALESS;
-	if (enable)
-		ahd->hs_mailbox |= ENINT_COALESS;
-	ahd_outb(ahd, HS_MAILBOX, ahd->hs_mailbox);
-	ahd_flush_device_writes(ahd);
-	ahd_run_qoutfifo(ahd);
-}
-
-/*
- * Ensure that the card is paused in a location
- * outside of all critical sections and that all
- * pending work is completed prior to returning.
- * This routine should only be called from outside
- * an interrupt context.
- */
-void
-ahd_pause_and_flushwork(struct ahd_softc *ahd)
-{
-	u_int intstat;
-	u_int maxloops;
-	int   paused;
-
-	maxloops = 1000;
-	ahd->flags |= AHD_ALL_INTERRUPTS;
-	intstat = 0;
-	paused = FALSE;
-	do {
-		struct scb *waiting_scb;
-
-		if (paused)
-			ahd_unpause(ahd);
-		ahd_intr(ahd);
-		ahd_pause(ahd);
-		paused = TRUE;
-		ahd_clear_critical_section(ahd);
-		if ((ahd_inb(ahd, SSTAT0) & (SELDO|SELINGO)) == 0)
-			ahd_outb(ahd, SCSISEQ0,
-				 ahd_inb(ahd, SCSISEQ0) & ~ENSELO);
-		/*
-		 * In the non-packetized case, the sequencer (for Rev A),
-		 * relies on ENSELO remaining set after SELDO.  The hardware
-		 * auto-clears ENSELO in the packetized case.
-		 */
-		waiting_scb = ahd_lookup_scb(ahd,
-					     ahd_inw(ahd, WAITING_TID_HEAD));
-		if (waiting_scb != NULL
-		 && (waiting_scb->flags & SCB_PACKETIZED) == 0
-		 && (ahd_inb(ahd, SSTAT0) & (SELDO|SELINGO)) != 0)
-			ahd_outb(ahd, SCSISEQ0,
-				 ahd_inb(ahd, SCSISEQ0) | ENSELO);
-
-		if (intstat == 0xFF && (ahd->features & AHD_REMOVABLE) != 0)
-			break;
-	} while (--maxloops
-	      && (((intstat = ahd_inb(ahd, INTSTAT)) & INT_PEND) != 0
-	       || (ahd_inb(ahd, SSTAT0) & (SELDO|SELINGO))));
-	if (maxloops == 0) {
-		printf("Infinite interrupt loop, INTSTAT = %x",
-		      ahd_inb(ahd, INTSTAT));
-	}
-
-	ahd_flush_qoutfifo(ahd);
-
-	ahd_platform_flushwork(ahd);
-	ahd->flags &= ~AHD_ALL_INTERRUPTS;
-}
-
-int
-ahd_suspend(struct ahd_softc *ahd)
-{
-#if 0
-	uint8_t *ptr;
-	int	 i;
-
-	ahd_pause_and_flushwork(ahd);
-
-	if (LIST_FIRST(&ahd->pending_scbs) != NULL)
-		return (EBUSY);
-
-#if AHD_TARGET_MODE
-	/*
-	 * XXX What about ATIOs that have not yet been serviced?
-	 * Perhaps we should just refuse to be suspended if we
-	 * are acting in a target role.
-	 */
-	if (ahd->pending_device != NULL)
-		return (EBUSY);
-#endif
-
-	/* Save volatile registers */
-	ahd->suspend_state.channel[0].scsiseq = ahd_inb(ahd, SCSISEQ0);
-	ahd->suspend_state.channel[0].sxfrctl0 = ahd_inb(ahd, SXFRCTL0);
-	ahd->suspend_state.channel[0].sxfrctl1 = ahd_inb(ahd, SXFRCTL1);
-	ahd->suspend_state.channel[0].simode0 = ahd_inb(ahd, SIMODE0);
-	ahd->suspend_state.channel[0].simode1 = ahd_inb(ahd, SIMODE1);
-	ahd->suspend_state.channel[0].seltimer = ahd_inb(ahd, SELTIMER);
-	ahd->suspend_state.channel[0].seqctl = ahd_inb(ahd, SEQCTL0);
-	ahd->suspend_state.dscommand0 = ahd_inb(ahd, DSCOMMAND0);
-	ahd->suspend_state.dspcistatus = ahd_inb(ahd, DSPCISTATUS);
-
-	if ((ahd->features & AHD_DT) != 0) {
-		u_int sfunct;
-
-		sfunct = ahd_inb(ahd, SFUNCT) & ~ALT_MODE;
-		ahd_outb(ahd, SFUNCT, sfunct | ALT_MODE);
-		ahd->suspend_state.optionmode = ahd_inb(ahd, OPTIONMODE);
-		ahd_outb(ahd, SFUNCT, sfunct);
-		ahd->suspend_state.crccontrol1 = ahd_inb(ahd, CRCCONTROL1);
-	}
-
-	if ((ahd->features & AHD_MULTI_FUNC) != 0)
-		ahd->suspend_state.scbbaddr = ahd_inb(ahd, SCBBADDR);
-
-	if ((ahd->features & AHD_ULTRA2) != 0)
-		ahd->suspend_state.dff_thrsh = ahd_inb(ahd, DFF_THRSH);
-
-	ptr = ahd->suspend_state.scratch_ram;
-	for (i = 0; i < 64; i++)
-		*ptr++ = ahd_inb(ahd, SRAM_BASE + i);
-
-	if ((ahd->features & AHD_MORE_SRAM) != 0) {
-		for (i = 0; i < 16; i++)
-			*ptr++ = ahd_inb(ahd, TARG_OFFSET + i);
-	}
-
-	ptr = ahd->suspend_state.btt;
-	for (i = 0;i < AHD_NUM_TARGETS; i++) {
-		int j;
-
-		for (j = 0;j < AHD_NUM_LUNS_NONPKT; j++) {
-			u_int tcl;
-
-			tcl = BUILD_TCL_RAW(i, 'A', j);
-			*ptr = ahd_find_busy_tcl(ahd, tcl);
-		}
-	}
-	ahd_shutdown(ahd);
-#endif
-	return (0);
-}
-
-int
-ahd_resume(struct ahd_softc *ahd)
-{
-#if 0
-	uint8_t *ptr;
-	int	 i;
-
-	ahd_reset(ahd);
-
-	ahd_build_free_scb_list(ahd);
-
-	/* Restore volatile registers */
-	ahd_outb(ahd, SCSISEQ0, ahd->suspend_state.channel[0].scsiseq);
-	ahd_outb(ahd, SXFRCTL0, ahd->suspend_state.channel[0].sxfrctl0);
-	ahd_outb(ahd, SXFRCTL1, ahd->suspend_state.channel[0].sxfrctl1);
-	ahd_outb(ahd, SIMODE0, ahd->suspend_state.channel[0].simode0);
-	ahd_outb(ahd, SIMODE1, ahd->suspend_state.channel[0].simode1);
-	ahd_outb(ahd, SELTIMER, ahd->suspend_state.channel[0].seltimer);
-	ahd_outb(ahd, SEQCTL0, ahd->suspend_state.channel[0].seqctl);
-	if ((ahd->features & AHD_ULTRA2) != 0)
-		ahd_outb(ahd, SCSIID_ULTRA2, ahd->our_id);
-	else
-		ahd_outb(ahd, SCSIID, ahd->our_id);
-
-	ahd_outb(ahd, DSCOMMAND0, ahd->suspend_state.dscommand0);
-	ahd_outb(ahd, DSPCISTATUS, ahd->suspend_state.dspcistatus);
-
-	if ((ahd->features & AHD_DT) != 0) {
-		u_int sfunct;
-
-		sfunct = ahd_inb(ahd, SFUNCT) & ~ALT_MODE;
-		ahd_outb(ahd, SFUNCT, sfunct | ALT_MODE);
-		ahd_outb(ahd, OPTIONMODE, ahd->suspend_state.optionmode);
-		ahd_outb(ahd, SFUNCT, sfunct);
-		ahd_outb(ahd, CRCCONTROL1, ahd->suspend_state.crccontrol1);
-	}
-
-	if ((ahd->features & AHD_MULTI_FUNC) != 0)
-		ahd_outb(ahd, SCBBADDR, ahd->suspend_state.scbbaddr);
-
-	if ((ahd->features & AHD_ULTRA2) != 0)
-		ahd_outb(ahd, DFF_THRSH, ahd->suspend_state.dff_thrsh);
-
-	ptr = ahd->suspend_state.scratch_ram;
-	for (i = 0; i < 64; i++)
-		ahd_outb(ahd, SRAM_BASE + i, *ptr++);
-
-	if ((ahd->features & AHD_MORE_SRAM) != 0) {
-		for (i = 0; i < 16; i++)
-			ahd_outb(ahd, TARG_OFFSET + i, *ptr++);
-	}
-
-	ptr = ahd->suspend_state.btt;
-	for (i = 0;i < AHD_NUM_TARGETS; i++) {
-		int j;
-
-		for (j = 0;j < AHD_NUM_LUNS; j++) {
-			u_int tcl;
-
-			tcl = BUILD_TCL(i << 4, j);
-			ahd_busy_tcl(ahd, tcl, *ptr);
-		}
-	}
-#endif
-	return (0);
-}
-
-/************************** Busy Target Table *********************************/
-/*
- * Set SCBPTR to the SCB that contains the busy
- * table entry for TCL.  Return the offset into
- * the SCB that contains the entry for TCL.
- * saved_scbid is dereferenced and set to the
- * scbid that should be restored once manipualtion
- * of the TCL entry is complete.
- */
-static __inline u_int
-ahd_index_busy_tcl(struct ahd_softc *ahd, u_int *saved_scbid, u_int tcl)
-{
-	/*
-	 * Index to the SCB that contains the busy entry.
-	 */
-	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
-	*saved_scbid = ahd_get_scbptr(ahd);
-	ahd_set_scbptr(ahd, TCL_LUN(tcl)
-		     | ((TCL_TARGET_OFFSET(tcl) & 0xC) << 4));
-
-	/*
-	 * And now calculate the SCB offset to the entry.
-	 * Each entry is 2 bytes wide, hence the
-	 * multiplication by 2.
-	 */
-	return (((TCL_TARGET_OFFSET(tcl) & 0x3) << 1) + SCB_DISCONNECTED_LISTS);
-}
-
-/*
- * Return the untagged transaction id for a given target/channel lun.
- * Optionally, clear the entry.
- */
-u_int
-ahd_find_busy_tcl(struct ahd_softc *ahd, u_int tcl)
-{
-	u_int scbid;
-	u_int scb_offset;
-	u_int saved_scbptr;
-		
-	scb_offset = ahd_index_busy_tcl(ahd, &saved_scbptr, tcl);
-	scbid = ahd_inw_scbram(ahd, scb_offset);
-	ahd_set_scbptr(ahd, saved_scbptr);
-	return (scbid);
-}
-
-void
-ahd_busy_tcl(struct ahd_softc *ahd, u_int tcl, u_int scbid)
-{
-	u_int scb_offset;
-	u_int saved_scbptr;
-		
-	scb_offset = ahd_index_busy_tcl(ahd, &saved_scbptr, tcl);
-	ahd_outw(ahd, scb_offset, scbid);
-	ahd_set_scbptr(ahd, saved_scbptr);
-}
-
-/************************** SCB and SCB queue management **********************/
-int
-ahd_match_scb(struct ahd_softc *ahd, struct scb *scb, int target,
-	      char channel, int lun, u_int tag, role_t role)
-{
-	int targ = SCB_GET_TARGET(ahd, scb);
-	char chan = SCB_GET_CHANNEL(ahd, scb);
-	int slun = SCB_GET_LUN(scb);
-	int match;
-
-	match = ((chan == channel) || (channel == ALL_CHANNELS));
-	if (match != 0)
-		match = ((targ == target) || (target == CAM_TARGET_WILDCARD));
-	if (match != 0)
-		match = ((lun == slun) || (lun == CAM_LUN_WILDCARD));
-	if (match != 0) {
-#if AHD_TARGET_MODE
-		int group;
-
-		group = XPT_FC_GROUP(scb->io_ctx->ccb_h.func_code);
-		if (role == ROLE_INITIATOR) {
-			match = (group != XPT_FC_GROUP_TMODE)
-			      && ((tag == SCB_GET_TAG(scb))
-			       || (tag == SCB_LIST_NULL));
-		} else if (role == ROLE_TARGET) {
-			match = (group == XPT_FC_GROUP_TMODE)
-			      && ((tag == scb->io_ctx->csio.tag_id)
-			       || (tag == SCB_LIST_NULL));
-		}
-#else /* !AHD_TARGET_MODE */
-		match = ((tag == SCB_GET_TAG(scb)) || (tag == SCB_LIST_NULL));
-#endif /* AHD_TARGET_MODE */
-	}
-
-	return match;
-}
-
-void
-ahd_freeze_devq(struct ahd_softc *ahd, struct scb *scb)
-{
-	int	target;
-	char	channel;
-	int	lun;
-
-	target = SCB_GET_TARGET(ahd, scb);
-	lun = SCB_GET_LUN(scb);
-	channel = SCB_GET_CHANNEL(ahd, scb);
-	
-	ahd_search_qinfifo(ahd, target, channel, lun,
-			   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,
-			   CAM_REQUEUE_REQ, SEARCH_COMPLETE);
-
-	ahd_platform_freeze_devq(ahd, scb);
-}
-
-void
-ahd_qinfifo_requeue_tail(struct ahd_softc *ahd, struct scb *scb)
-{
-	struct scb	*prev_scb;
-	ahd_mode_state	 saved_modes;
-
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
-	prev_scb = NULL;
-	if (ahd_qinfifo_count(ahd) != 0) {
-		u_int prev_tag;
-		u_int prev_pos;
-
-		prev_pos = AHD_QIN_WRAP(ahd->qinfifonext - 1);
-		prev_tag = ahd->qinfifo[prev_pos];
-		prev_scb = ahd_lookup_scb(ahd, prev_tag);
-	}
-	ahd_qinfifo_requeue(ahd, prev_scb, scb);
-	ahd_set_hnscb_qoff(ahd, ahd->qinfifonext);
-	ahd_restore_modes(ahd, saved_modes);
-}
-
-static void
-ahd_qinfifo_requeue(struct ahd_softc *ahd, struct scb *prev_scb,
-		    struct scb *scb)
-{
-	if (prev_scb == NULL) {
-		uint32_t busaddr;
-
-		busaddr = ahd_le32toh(scb->hscb->hscb_busaddr);
-		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 0, busaddr & 0xFF);
-		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 1, (busaddr >> 8) & 0xFF);
-		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 2, (busaddr >> 16) & 0xFF);
-		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 3, (busaddr >> 24) & 0xFF);
-	} else {
-		prev_scb->hscb->next_hscb_busaddr = scb->hscb->hscb_busaddr;
-		ahd_sync_scb(ahd, prev_scb, 
-			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
-	}
-	ahd->qinfifo[AHD_QIN_WRAP(ahd->qinfifonext)] = SCB_GET_TAG(scb);
-	ahd->qinfifonext++;
-	scb->hscb->next_hscb_busaddr = ahd->next_queued_hscb->hscb_busaddr;
-	ahd_sync_scb(ahd, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
-}
-
-static int
-ahd_qinfifo_count(struct ahd_softc *ahd)
-{
-	u_int qinpos;
-	u_int wrap_qinpos;
-	u_int wrap_qinfifonext;
-
-	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
-	qinpos = ahd_get_snscb_qoff(ahd);
-	wrap_qinpos = AHD_QIN_WRAP(qinpos);
-	wrap_qinfifonext = AHD_QIN_WRAP(ahd->qinfifonext);
-	if (wrap_qinfifonext >= wrap_qinpos)
-		return (wrap_qinfifonext - wrap_qinpos);
-	else
-		return (wrap_qinfifonext
-		      + NUM_ELEMENTS(ahd->qinfifo) - wrap_qinpos);
-}
-
-void
-ahd_reset_cmds_pending(struct ahd_softc *ahd)
-{
-	struct		scb *scb;
-	ahd_mode_state	saved_modes;
-	u_int		pending_cmds;
-
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
-
-	/*
-	 * Don't count any commands as outstanding that the
-	 * sequencer has already marked for completion.
-	 */
-	ahd_flush_qoutfifo(ahd);
-
-	pending_cmds = 0;
-	LIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {
-		pending_cmds++;
-	}
-	ahd_outw(ahd, CMDS_PENDING, pending_cmds - ahd_qinfifo_count(ahd));
-	ahd_restore_modes(ahd, saved_modes);
-	ahd->flags &= ~AHD_UPDATE_PEND_CMDS;
-}
-
-int
-ahd_search_qinfifo(struct ahd_softc *ahd, int target, char channel,
-		   int lun, u_int tag, role_t role, uint32_t status,
-		   ahd_search_action action)
-{
-	struct scb	*scb;
-	struct scb	*prev_scb;
-	ahd_mode_state	 saved_modes;
-	u_int		 qinstart;
-	u_int		 qinpos;
-	u_int		 qintail;
-	u_int		 tid_next;
-	u_int		 tid_prev;
-	u_int		 scbid;
-	u_int		 savedscbptr;
-	uint32_t	 busaddr;
-	int		 found;
-	int		 targets;
-
-	/* Must be in CCHAN mode */
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
-
-	/*
-	 * Halt any pending SCB DMA.  The sequencer will reinitiate
-	 * this dma if the qinfifo is not empty once we unpause.
-	 */
-	if ((ahd_inb(ahd, CCSCBCTL) & (CCARREN|CCSCBEN|CCSCBDIR))
-	 == (CCARREN|CCSCBEN|CCSCBDIR)) {
-		ahd_outb(ahd, CCSCBCTL,
-			 ahd_inb(ahd, CCSCBCTL) & ~(CCARREN|CCSCBEN));
-		while ((ahd_inb(ahd, CCSCBCTL) & (CCARREN|CCSCBEN)) != 0)
-			;
-	}
-	/* Determine sequencer's position in the qinfifo. */
-	qintail = AHD_QIN_WRAP(ahd->qinfifonext);
-	qinstart = ahd_get_snscb_qoff(ahd);
-	qinpos = AHD_QIN_WRAP(qinstart);
-	found = 0;
-	prev_scb = NULL;
-
-	if (action == SEARCH_PRINT) {
-		printf("qinstart = %d qinfifonext = %d\nQINFIFO:",
-		       qinstart, ahd->qinfifonext);
-	}
-
-	/*
-	 * Start with an empty queue.  Entries that are not chosen
-	 * for removal will be re-added to the queue as we go.
-	 */
-	ahd->qinfifonext = qinstart;
-	busaddr = ahd_le32toh(ahd->next_queued_hscb->hscb_busaddr);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 0, busaddr & 0xFF);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 1, (busaddr >> 8) & 0xFF);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 2, (busaddr >> 16) & 0xFF);
-	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 3, (busaddr >> 24) & 0xFF);
-
-	while (qinpos != qintail) {
-		scb = ahd_lookup_scb(ahd, ahd->qinfifo[qinpos]);
-		if (scb == NULL) {
-			printf("qinpos = %d, SCB index = %d\n",
-				qinpos, ahd->qinfifo[qinpos]);
-			panic("Loop 1\n");
-		}
-
-		if (ahd_match_scb(ahd, scb, target, channel, lun, tag, role)) {
-			/*
-			 * We found an scb that needs to be acted on.
-			 */
-			found++;
-			switch (action) {
-			case SEARCH_COMPLETE:
-			{
-				cam_status ostat;
-				cam_status cstat;
-
-				ostat = ahd_get_transaction_status(scb);
-				if (ostat == CAM_REQ_INPROG)
-					ahd_set_transaction_status(scb,
-								   status);
-				cstat = ahd_get_transaction_status(scb);
-				if (cstat != CAM_REQ_CMP)
-					ahd_freeze_scb(scb);
-				if ((scb->flags & SCB_ACTIVE) == 0)
-					printf("Inactive SCB in qinfifo\n");
-				ahd_done(ahd, scb);
-
-				/* FALLTHROUGH */
-			}
-			case SEARCH_REMOVE:
-				break;
-			case SEARCH_PRINT:
-				printf(" 0x%x", ahd->qinfifo[qinpos]);
-				/* FALLTHROUGH */
-			case SEARCH_COUNT:
-				ahd_qinfifo_requeue(ahd, prev_scb, scb);
-				prev_scb = scb;
-				break;
-			}
-		} else {
-			ahd_qinfifo_requeue(ahd, prev_scb, scb);
-			prev_scb = scb;
-		}
-		qinpos = AHD_QIN_WRAP(qinpos+1);
-	}
-
-	ahd_set_hnscb_qoff(ahd, ahd->qinfifonext);
-
-	if (action == SEARCH_PRINT)
-		printf("\nWAITING_TID_QUEUES:\n");
-
-	/*
-	 * Search waiting for selection lists.  We traverse the
-	 * list of "their ids" waiting for selection and, if
-	 * appropriate, traverse the SCBs of each "their id"
-	 * looking for matches.
-	 */
-	savedscbptr = ahd_get_scbptr(ahd);
-	tid_next = ahd_inw(ahd, WAITING_TID_HEAD);
-	tid_prev = SCB_LIST_NULL;
-	targets = 0;
-	for (scbid = tid_next; !SCBID_IS_NULL(scbid); scbid = tid_next) {
-		u_int tid_head;
-
-		/*
-		 * We limit based on the number of SCBs since
-		 * MK_MESSAGE SCBs are not in the per-tid lists.
-		 */
-		targets++;
-		if (targets > AHD_SCB_MAX) {
-			panic("TID LIST LOOP");
-		}
-		if (scbid >= ahd->scb_data.numscbs) {
-			printf("%s: Waiting TID List inconsistency. "
-			       "SCB index == 0x%x, yet numscbs == 0x%x.",
-			       ahd_name(ahd), scbid, ahd->scb_data.numscbs);
-			ahd_dump_card_state(ahd);
-			panic("for safety");
-		}
-		scb = ahd_lookup_scb(ahd, scbid);
-		if (scb == NULL) {
-			printf("%s: SCB = 0x%x Not Active!\n",
-			       ahd_name(ahd), scbid);
-			panic("Waiting TID List traversal\n");
-		}
-		ahd_set_scbptr(ahd, scbid);
-		tid_next = ahd_inw_scbram(ahd, SCB_NEXT2);
-		if (ahd_match_scb(ahd, scb, target, channel, CAM_LUN_WILDCARD,
-				  SCB_LIST_NULL, ROLE_UNKNOWN) == 0) {
-			tid_prev = scbid;
-			continue;
-		}
-
-		/*
-		 * We found a list of scbs that needs to be searched.
-		 */
-		if (action == SEARCH_PRINT)
-			printf("       %d ( ", SCB_GET_TARGET(ahd, scb));
-		tid_head = scbid;
-		found += ahd_search_scb_list(ahd, target, channel,
-					     lun, tag, role, status,
-					     action, &tid_head,
-					     SCB_GET_TARGET(ahd, scb));
-		if (tid_head != scbid)
-			ahd_stitch_tid_list(ahd, tid_prev, tid_head, tid_next);
-		if (!SCBID_IS_NULL(tid_head))
-			tid_prev = tid_head;
-		if (action == SEARCH_PRINT)
-			printf(")\n");
-	}
-	ahd_set_scbptr(ahd, savedscbptr);
-	ahd_restore_modes(ahd, saved_modes);
-	return (found);
-}
-
-static int
-ahd_search_scb_list(struct ahd_softc *ahd, int target, char channel,
-		    int lun, u_int tag, role_t role, uint32_t status,
-		    ahd_search_action action, u_int *list_head, u_int tid)
-{
-	struct	scb *scb;
-	u_int	scbid;
-	u_int	next;
-	u_int	prev;
-	int	found;
-
-	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
-	found = 0;
-	prev = SCB_LIST_NULL;
-	next = *list_head;
-	for (scbid = next; !SCBID_IS_NULL(scbid); scbid = next) {
-		if (scbid >= ahd->scb_data.numscbs) {
-			printf("%s:SCB List inconsistency. "
-			       "SCB == 0x%x, yet numscbs == 0x%x.",
-			       ahd_name(ahd), scbid, ahd->scb_data.numscbs);
-			ahd_dump_card_state(ahd);
-			panic("for safety");
-		}
-		scb = ahd_lookup_scb(ahd, scbid);
-		if (scb == NULL) {
-			printf("%s: SCB = %d Not Active!\n",
-			       ahd_name(ahd), scbid);
-			panic("Waiting List traversal\n");
-		}
-		ahd_set_scbptr(ahd, scbid);
-		next = ahd_inw_scbram(ahd, SCB_NEXT);
-		if (ahd_match_scb(ahd, scb, target, channel,
-				  lun, SCB_LIST_NULL, role) == 0) {
-			prev = scbid;
-			continue;
-		}
-		found++;
-		switch (action) {
-		case SEARCH_COMPLETE:
-		{
-			cam_status ostat;
-			cam_status cstat;
-
-			ostat = ahd_get_transaction_status(scb);
-			if (ostat == CAM_REQ_INPROG)
-				ahd_set_transaction_status(scb, status);
-			cstat = ahd_get_transaction_status(scb);
-			if (cstat != CAM_REQ_CMP)
-				ahd_freeze_scb(scb);
-			if ((scb->flags & SCB_ACTIVE) == 0)
-				printf("Inactive SCB in Waiting List\n");
-			ahd_done(ahd, scb);
-			/* FALLTHROUGH */
-		}
-		case SEARCH_REMOVE:
-			ahd_rem_wscb(ahd, scbid, prev, next, tid);
-			if (prev == SCB_LIST_NULL)
-				*list_head = next;
-			break;
-		case SEARCH_PRINT:
-			printf("0x%x ", scbid);
-		case SEARCH_COUNT:
-			prev = scbid;
-			break;
-		}
-		if (found > AHD_SCB_MAX)
-			panic("SCB LIST LOOP");
-	}
-	if (action == SEARCH_COMPLETE
-	 || action == SEARCH_REMOVE)
-		ahd_outw(ahd, CMDS_PENDING, ahd_inw(ahd, CMDS_PENDING) - found);
-	return (found);
-}
-
-static void
-ahd_stitch_tid_list(struct ahd_softc *ahd, u_int tid_prev,
-		    u_int tid_cur, u_int tid_next)
-{
-	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
-
-	if (SCBID_IS_NULL(tid_cur)) {
-
-		/* Bypass current TID list */
-		if (SCBID_IS_NULL(tid_prev)) {
-			ahd_outw(ahd, WAITING_TID_HEAD, tid_next);
-		} else {
-			ahd_set_scbptr(ahd, tid_prev);
-			ahd_outw(ahd, SCB_NEXT2, tid_next);
-		}
-		if (SCBID_IS_NULL(tid_next))
-			ahd_outw(ahd, WAITING_TID_TAIL, tid_prev);
-	} else {
-
-		/* Stitch through tid_cur */
-		if (SCBID_IS_NULL(tid_prev)) {
-			ahd_outw(ahd, WAITING_TID_HEAD, tid_cur);
-		} else {
-			ahd_set_scbptr(ahd, tid_prev);
-			ahd_outw(ahd, SCB_NEXT2, tid_cur);
-		}
-		ahd_set_scbptr(ahd, tid_cur);
-		ahd_outw(ahd, SCB_NEXT2, tid_next);
-
-		if (SCBID_IS_NULL(tid_next))
-			ahd_outw(ahd, WAITING_TID_TAIL, tid_cur);
-	}
-}
-
-/*
- * Manipulate the waiting for selection list and return the
- * scb that follows the one that we remove.
- */
-static u_int
-ahd_rem_wscb(struct ahd_softc *ahd, u_int scbid,
-	     u_int prev, u_int next, u_int tid)
-{
-	u_int tail_offset;
-
-	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
-	if (!SCBID_IS_NULL(prev)) {
-		ahd_set_scbptr(ahd, prev);
-		ahd_outw(ahd, SCB_NEXT, next);
-	}
-
-	/*
-	 * SCBs that had MK_MESSAGE set in them will not
-	 * be queued to the per-target lists, so don't
-	 * blindly clear the tail pointer.
-	 */
-	tail_offset = WAITING_SCB_TAILS + (2 * tid);
-	if (SCBID_IS_NULL(next)
-	 && ahd_inw(ahd, tail_offset) == scbid)
-		ahd_outw(ahd, tail_offset, prev);
-	ahd_add_scb_to_free_list(ahd, scbid);
-	return (next);
-}
-
-/*
- * Add the SCB as selected by SCBPTR onto the on chip list of
- * free hardware SCBs.  This list is empty/unused if we are not
- * performing SCB paging.
- */
-static void
-ahd_add_scb_to_free_list(struct ahd_softc *ahd, u_int scbid)
-{
-/* XXX Need some other mechanism to designate "free". */
-	/*
-	 * Invalidate the tag so that our abort
-	 * routines don't think it's active.
-	ahd_outb(ahd, SCB_TAG, SCB_LIST_NULL);
-	 */
-}
-
-/******************************** Error Handling ******************************/
-/*
- * Abort all SCBs that match the given description (target/channel/lun/tag),
- * setting their status to the passed in status if the status has not already
- * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer
- * is paused before it is called.
- */
-int
-ahd_abort_scbs(struct ahd_softc *ahd, int target, char channel,
-	       int lun, u_int tag, role_t role, uint32_t status)
-{
-	struct		scb *scbp;
-	struct		scb *scbp_next;
-	u_int		active_scb;
-	u_int		i, j;
-	u_int		maxtarget;
-	u_int		minlun;
-	u_int		maxlun;
-	int		found;
-	ahd_mode_state	saved_modes;
-
-	/* restore these when we're done */
-	active_scb = ahd_get_scbptr(ahd);
-	saved_modes = ahd_save_modes(ahd);
-
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	found = ahd_search_qinfifo(ahd, target, channel, lun, SCB_LIST_NULL,
-				   role, CAM_REQUEUE_REQ, SEARCH_COMPLETE);
-
-	/*
-	 * Clean out the busy target table for any untagged commands.
-	 */
-	i = 0;
-	maxtarget = 16;
-	if (target != CAM_TARGET_WILDCARD) {
-		i = target;
-		if (channel == 'B')
-			i += 8;
-		maxtarget = i + 1;
-	}
-
-	if (lun == CAM_LUN_WILDCARD) {
-		minlun = 0;
-		maxlun = AHD_NUM_LUNS_NONPKT;
-	} else if (lun >= AHD_NUM_LUNS_NONPKT) {
-		minlun = maxlun = 0;
-	} else {
-		minlun = lun;
-		maxlun = lun + 1;
-	}
-
-	if (role != ROLE_TARGET) {
-		for (;i < maxtarget; i++) {
-			for (j = minlun;j < maxlun; j++) {
-				u_int scbid;
-				u_int tcl;
-
-				tcl = BUILD_TCL_RAW(i, 'A', j);
-				scbid = ahd_find_busy_tcl(ahd, tcl);
-				scbp = ahd_lookup_scb(ahd, scbid);
-				if (scbp == NULL
-				 || ahd_match_scb(ahd, scbp, target, channel,
-						  lun, tag, role) == 0)
-					continue;
-				ahd_unbusy_tcl(ahd, BUILD_TCL_RAW(i, 'A', j));
-			}
-		}
-	}
-
-	/*
-	 * Don't abort commands that have already completed,
-	 * but haven't quite made it up to the host yet.
-	 */
-	ahd_flush_qoutfifo(ahd);
-
-	/*
-	 * Go through the pending CCB list and look for
-	 * commands for this target that are still active.
-	 * These are other tagged commands that were
-	 * disconnected when the reset occurred.
-	 */
-	scbp_next = LIST_FIRST(&ahd->pending_scbs);
-	while (scbp_next != NULL) {
-		scbp = scbp_next;
-		scbp_next = LIST_NEXT(scbp, pending_links);
-		if (ahd_match_scb(ahd, scbp, target, channel, lun, tag, role)) {
-			cam_status ostat;
-
-			ostat = ahd_get_transaction_status(scbp);
-			if (ostat == CAM_REQ_INPROG)
-				ahd_set_transaction_status(scbp, status);
-			if (ahd_get_transaction_status(scbp) != CAM_REQ_CMP)
-				ahd_freeze_scb(scbp);
-			if ((scbp->flags & SCB_ACTIVE) == 0)
-				printf("Inactive SCB on pending list\n");
-			ahd_done(ahd, scbp);
-			found++;
-		}
-	}
-	ahd_set_scbptr(ahd, active_scb);
-	ahd_restore_modes(ahd, saved_modes);
-	ahd_platform_abort_scbs(ahd, target, channel, lun, tag, role, status);
-	ahd->flags |= AHD_UPDATE_PEND_CMDS;
-	return found;
-}
-
-static void
-ahd_reset_current_bus(struct ahd_softc *ahd)
-{
-	uint8_t scsiseq;
-
-	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
-	ahd_outb(ahd, SIMODE1, ahd_inb(ahd, SIMODE1) & ~ENSCSIRST);
-	scsiseq = ahd_inb(ahd, SCSISEQ0) & ~(ENSELO|ENARBO|SCSIRSTO);
-	ahd_outb(ahd, SCSISEQ0, scsiseq | SCSIRSTO);
-	ahd_delay(AHD_BUSRESET_DELAY);
-	/* Turn off the bus reset */
-	ahd_outb(ahd, SCSISEQ0, scsiseq);
-	if ((ahd->bugs & AHD_SCSIRST_BUG) != 0) {
-		/*
-		 * 2A Razor #474
-		 * Certain chip state is not cleared for
-		 * SCSI bus resets that we initiate, so
-		 * we must reset the chip.
-		 */
-		ahd_delay(AHD_BUSRESET_DELAY);
-		ahd_reset(ahd);
-		ahd_intr_enable(ahd, /*enable*/TRUE);
-		AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
-	}
-
-	ahd_clear_intstat(ahd);
-}
-
-int
-ahd_reset_channel(struct ahd_softc *ahd, char channel, int initiate_reset)
-{
-	struct	ahd_devinfo devinfo;
-	u_int	initiator;
-	u_int	target;
-	u_int	max_scsiid;
-	int	found;
-	u_int	fifo;
-	u_int	next_fifo;
-
-	ahd->pending_device = NULL;
-
-	ahd_compile_devinfo(&devinfo,
-			    CAM_TARGET_WILDCARD,
-			    CAM_TARGET_WILDCARD,
-			    CAM_LUN_WILDCARD,
-			    channel, ROLE_UNKNOWN);
-	ahd_pause(ahd);
-
-	/* Make sure the sequencer is in a safe location. */
-	ahd_clear_critical_section(ahd);
-
-#if AHD_TARGET_MODE
-	if ((ahd->flags & AHD_TARGETROLE) != 0) {
-		ahd_run_tqinfifo(ahd, /*paused*/TRUE);
-	}
-#endif
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-
-	/*
-	 * Disable selections so no automatic hardware
-	 * functions will modify chip state.
-	 */
-	ahd_outb(ahd, SCSISEQ0, 0);
-	ahd_outb(ahd, SCSISEQ1, 0);
-
-	/*
-	 * Safely shut down our DMA engines.  Always start with
-	 * the FIFO that is not currently active (if any are
-	 * actively connected).
-	 */
-	next_fifo = fifo = ahd_inb(ahd, DFFSTAT) & CURRFIFO;
-	if (next_fifo > CURRFIFO_1)
-		/* If disconneced, arbitrarily start with FIFO1. */
-		next_fifo = fifo = 0;
-	do {
-		next_fifo ^= CURRFIFO_1;
-		ahd_set_modes(ahd, next_fifo, next_fifo);
-		ahd_outb(ahd, DFCNTRL,
-			 ahd_inb(ahd, DFCNTRL) & ~(SCSIEN|HDMAEN));
-		while ((ahd_inb(ahd, DFCNTRL) & HDMAENACK) != 0)
-			ahd_delay(10);
-		/*
-		 * Set CURRFIFO to the now inactive channel.
-		 */
-		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-		ahd_outb(ahd, DFFSTAT, next_fifo);
-	} while (next_fifo != fifo);
-	/*
-	 * Reset the bus if we are initiating this reset
-	 */
-	ahd_clear_msg_state(ahd);
-	ahd_outb(ahd, SIMODE1,
-		 ahd_inb(ahd, SIMODE1) & ~(ENBUSFREE|ENSCSIRST|ENBUSFREE));
-	if (initiate_reset)
-		ahd_reset_current_bus(ahd);
-	ahd_clear_intstat(ahd);
-
-	/*
-	 * Clean up all the state information for the
-	 * pending transactions on this bus.
-	 */
-	found = ahd_abort_scbs(ahd, CAM_TARGET_WILDCARD, channel,
-			       CAM_LUN_WILDCARD, SCB_LIST_NULL,
-			       ROLE_UNKNOWN, CAM_SCSI_BUS_RESET);
-
-	/*
-	 * Cleanup anything left in the FIFOs.
-	 */
-	ahd_clear_fifo(ahd, 0);
-	ahd_clear_fifo(ahd, 1);
-
-	/*
-	 * Revert to async/narrow transfers until we renegotiate.
-	 */
-	max_scsiid = (ahd->features & AHD_WIDE) ? 15 : 7;
-	for (target = 0; target <= max_scsiid; target++) {
-
-		if (ahd->enabled_targets[target] == NULL)
-			continue;
-		for (initiator = 0; initiator <= max_scsiid; initiator++) {
-			struct ahd_devinfo devinfo;
-
-			ahd_compile_devinfo(&devinfo, target, initiator,
-					    CAM_LUN_WILDCARD,
-					    'A', ROLE_UNKNOWN);
-			ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
-				      AHD_TRANS_CUR, /*paused*/TRUE);
-			ahd_set_syncrate(ahd, &devinfo, /*period*/0,
-					 /*offset*/0, /*ppr_options*/0,
-					 AHD_TRANS_CUR, /*paused*/TRUE);
-		}
-	}
-
-#ifdef AHD_TARGET_MODE
-	max_scsiid = (ahd->features & AHD_WIDE) ? 15 : 7;
-
-	/*
-	 * Send an immediate notify ccb to all target more peripheral
-	 * drivers affected by this action.
-	 */
-	for (target = 0; target <= max_scsiid; target++) {
-		struct ahd_tmode_tstate* tstate;
-		u_int lun;
-
-		tstate = ahd->enabled_targets[target];
-		if (tstate == NULL)
-			continue;
-		for (lun = 0; lun < AHD_NUM_LUNS; lun++) {
-			struct ahd_tmode_lstate* lstate;
-
-			lstate = tstate->enabled_luns[lun];
-			if (lstate == NULL)
-				continue;
-
-			ahd_queue_lstate_event(ahd, lstate, CAM_TARGET_WILDCARD,
-					       EVENT_TYPE_BUS_RESET, /*arg*/0);
-			ahd_send_lstate_events(ahd, lstate);
-		}
-	}
-#endif
-	/* Notify the XPT that a bus reset occurred */
-	ahd_send_async(ahd, devinfo.channel, CAM_TARGET_WILDCARD,
-		       CAM_LUN_WILDCARD, AC_BUS_RESET, NULL);
-	ahd_restart(ahd);
-	/*
-	 * Freeze the SIMQ until our poller can determine that
-	 * the bus reset has really gone away.  We set the initial
-	 * timer to 0 to have the check performed as soon as possible
-	 * from the timer context.
-	 */
-	if ((ahd->flags & AHD_RESET_POLL_ACTIVE) == 0) {
-		ahd->flags |= AHD_RESET_POLL_ACTIVE;
-		ahd_freeze_simq(ahd);
-		ahd_timer_reset(&ahd->reset_timer, 0, ahd_reset_poll, ahd);
-	}
-	return (found);
-}
-
-
-#define AHD_RESET_POLL_US 1000
-static void
-ahd_reset_poll(void *arg)
-{
-	struct	ahd_softc *ahd;
-	u_int	scsiseq1;
-	u_long	l;
-	u_long	s;
-	
-	ahd_list_lock(&l);
-	ahd = ahd_find_softc((struct ahd_softc *)arg);
-	if (ahd == NULL) {
-		printf("ahd_reset_poll: Instance %p no longer exists\n", arg);
-		ahd_list_unlock(&l);
-		return;
-	}
-	ahd_lock(ahd, &s);
-	ahd_pause(ahd);
-	ahd_update_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	ahd_outb(ahd, CLRSINT1, CLRSCSIRSTI);
-	if ((ahd_inb(ahd, SSTAT1) & SCSIRSTI) != 0) {
-		ahd_timer_reset(&ahd->reset_timer, AHD_RESET_POLL_US,
-				ahd_reset_poll, ahd);
-		ahd_unpause(ahd);
-		ahd_unlock(ahd, &s);
-		ahd_list_unlock(&l);
-		return;
-	}
-
-	/* Reset is now low.  Complete chip reinitialization. */
-	ahd_outb(ahd, SIMODE1, ahd_inb(ahd, SIMODE1) | ENSCSIRST);
-	scsiseq1 = ahd_inb(ahd, SCSISEQ_TEMPLATE);
-	ahd_outb(ahd, SCSISEQ1, scsiseq1 & (ENSELI|ENRSELI|ENAUTOATNP));
-	ahd_unpause(ahd);
-	ahd->flags &= ~AHD_RESET_POLL_ACTIVE;
-	ahd_unlock(ahd, &s);
-	ahd_release_simq(ahd);
-	ahd_list_unlock(&l);
-}
-
-/**************************** Statistics Processing ***************************/
-static void
-ahd_stat_timer(void *arg)
-{
-	struct	ahd_softc *ahd;
-	u_long	l;
-	u_long	s;
-	int	enint_coal;
-	
-	ahd_list_lock(&l);
-	ahd = ahd_find_softc((struct ahd_softc *)arg);
-	if (ahd == NULL) {
-		printf("ahd_stat_timer: Instance %p no longer exists\n", arg);
-		ahd_list_unlock(&l);
-		return;
-	}
-	ahd_lock(ahd, &s);
-
-	enint_coal = ahd->hs_mailbox & ENINT_COALESS;
-	if (ahd->cmdcmplt_total > ahd->int_coalessing_threshold)
-		enint_coal |= ENINT_COALESS;
-	else if (ahd->cmdcmplt_total < ahd->int_coalessing_stop_threshold)
-		enint_coal &= ~ENINT_COALESS;
-
-	if (enint_coal != (ahd->hs_mailbox & ENINT_COALESS)) {
-		ahd_enable_coalessing(ahd, enint_coal);
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_INT_COALESSING) != 0)
-			printf("%s: Interrupt coalessing "
-			       "now %sabled. Cmds %d\n",
-			       ahd_name(ahd),
-			       (enint_coal & ENINT_COALESS) ? "en" : "dis",
-			       ahd->cmdcmplt_total);
-#endif
-	}
-
-	ahd->cmdcmplt_bucket = (ahd->cmdcmplt_bucket+1) & (AHD_STAT_BUCKETS-1);
-	ahd->cmdcmplt_total -= ahd->cmdcmplt_counts[ahd->cmdcmplt_bucket];
-	ahd->cmdcmplt_counts[ahd->cmdcmplt_bucket] = 0;
-	ahd_timer_reset(&ahd->stat_timer, AHD_STAT_UPDATE_US,
-			ahd_stat_timer, ahd);
-	ahd_unlock(ahd, &s);
-	ahd_list_unlock(&l);
-}
-
-/****************************** Status Processing *****************************/
-void
-ahd_handle_scb_status(struct ahd_softc *ahd, struct scb *scb)
-{
-	if (scb->hscb->shared_data.istatus.scsi_status != 0) {
-		ahd_handle_scsi_status(ahd, scb);
-	} else {
-		ahd_calc_residual(ahd, scb);
-		ahd_done(ahd, scb);
-	}
-}
-
-void
-ahd_handle_scsi_status(struct ahd_softc *ahd, struct scb *scb)
-{
-	struct hardware_scb *hscb;
-	u_int  qfreeze_cnt;
-	ahd_mode_state saved_modes;
-
-	/*
-	 * The sequencer freezes its select-out queue
-	 * anytime a SCSI status error occurs.  We must
-	 * handle the error and decrement the QFREEZE count
-	 * to allow the sequencer to continue.
-	 */
-	hscb = scb->hscb; 
-
-	/* Freeze the queue until the client sees the error. */
-	ahd_pause(ahd);
-	saved_modes = ahd_save_modes(ahd);
-	ahd_clear_critical_section(ahd);
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	ahd_freeze_devq(ahd, scb);
-	ahd_freeze_scb(scb);
-	qfreeze_cnt = ahd_inw(ahd, QFREEZE_COUNT);
-	if (qfreeze_cnt == 0) {
-		printf("%s: Bad status with 0 qfreeze count!\n", ahd_name(ahd));
-	} else {
-		qfreeze_cnt--;
-		ahd_outw(ahd, QFREEZE_COUNT, qfreeze_cnt);
-	}
-	if (qfreeze_cnt == 0)
-		ahd_outb(ahd, SEQ_FLAGS2,
-			 ahd_inb(ahd, SEQ_FLAGS2) & ~SELECTOUT_QFROZEN);
-	ahd_unpause(ahd);
-	/* Don't want to clobber the original sense code */
-	if ((scb->flags & SCB_SENSE) != 0) {
-		/*
-		 * Clear the SCB_SENSE Flag and perform
-		 * a normal command completion.
-		 */
-		scb->flags &= ~SCB_SENSE;
-		ahd_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
-		ahd_done(ahd, scb);
-		return;
-	}
-	ahd_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);
-	ahd_set_scsi_status(scb, hscb->shared_data.istatus.scsi_status);
-	switch (hscb->shared_data.istatus.scsi_status) {
-	case STATUS_PKT_SENSE:
-	{
-		struct scsi_status_iu_header *siu;
-
-		ahd_sync_sense(ahd, scb, BUS_DMASYNC_POSTREAD);
-		siu = (struct scsi_status_iu_header *)scb->sense_data;
-		ahd_set_scsi_status(scb, siu->status);
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_SENSE) != 0) {
-			ahd_print_path(ahd, scb);
-			printf("SCB 0x%x Received PKT Status of 0x%x\n",
-			       SCB_GET_TAG(scb), siu->status);
-			printf("\tflags = 0x%x, sense len = 0x%x, "
-			       "pktfail = 0x%x\n",
-			       siu->flags, scsi_4btoul(siu->sense_length),
-			       scsi_4btoul(siu->pkt_failures_length));
-		}
-#endif
-		if ((siu->flags & SIU_RSPVALID) != 0) {
-			ahd_print_path(ahd, scb);
-			if (scsi_4btoul(siu->pkt_failures_length) < 4) {
-				printf("Unable to parse pkt_failures\n");
-			} else {
-
-				switch (SIU_PKTFAIL_CODE(siu)) {
-				case SIU_PFC_NONE:
-					printf("No packet failure found\n");
-					break;
-				case SIU_PFC_CIU_FIELDS_INVALID:
-					printf("Invalid Command IU Field\n");
-					break;
-				case SIU_PFC_TMF_NOT_SUPPORTED:
-					printf("TMF not supportd\n");
-					break;
-				case SIU_PFC_TMF_FAILED:
-					printf("TMF failed\n");
-					break;
-				case SIU_PFC_INVALID_TYPE_CODE:
-					printf("Invalid L_Q Type code\n");
-					break;
-				case SIU_PFC_ILLEGAL_REQUEST:
-					printf("Illegal request\n");
-				default:
-					break;
-				}
-			}
-			if (siu->status == SCSI_STATUS_OK)
-				ahd_set_transaction_status(scb,
-							   CAM_REQ_CMP_ERR);
-		}
-		if ((siu->flags & SIU_SNSVALID) != 0) {
-			scb->flags |= SCB_PKT_SENSE;
-#ifdef AHD_DEBUG
-			if ((ahd_debug & AHD_SHOW_SENSE) != 0)
-				printf("Sense data available\n");
-#endif
-		}
-		ahd_done(ahd, scb);
-		break;
-	}
-	case SCSI_STATUS_CMD_TERMINATED:
-	case SCSI_STATUS_CHECK_COND:
-	{
-		struct ahd_devinfo devinfo;
-		struct ahd_dma_seg *sg;
-		struct scsi_sense *sc;
-		struct ahd_initiator_tinfo *targ_info;
-		struct ahd_tmode_tstate *tstate;
-		struct ahd_transinfo *tinfo;
-#ifdef AHD_DEBUG
-		if (ahd_debug & AHD_SHOW_SENSE) {
-			ahd_print_path(ahd, scb);
-			printf("SCB %d: requests Check Status\n",
-			       SCB_GET_TAG(scb));
-		}
-#endif
-
-		if (ahd_perform_autosense(scb) == 0)
-			break;
-
-		ahd_compile_devinfo(&devinfo, SCB_GET_OUR_ID(scb),
-				    SCB_GET_TARGET(ahd, scb),
-				    SCB_GET_LUN(scb),
-				    SCB_GET_CHANNEL(ahd, scb),
-				    ROLE_INITIATOR);
-		targ_info = ahd_fetch_transinfo(ahd,
-						devinfo.channel,
-						devinfo.our_scsiid,
-						devinfo.target,
-						&tstate);
-		tinfo = &targ_info->curr;
-		sg = scb->sg_list;
-		sc = (struct scsi_sense *)hscb->shared_data.idata.cdb;
-		/*
-		 * Save off the residual if there is one.
-		 */
-		ahd_update_residual(ahd, scb);
-#ifdef AHD_DEBUG
-		if (ahd_debug & AHD_SHOW_SENSE) {
-			ahd_print_path(ahd, scb);
-			printf("Sending Sense\n");
-		}
-#endif
-		scb->sg_count = 0;
-		sg = ahd_sg_setup(ahd, scb, sg, ahd_get_sense_bufaddr(ahd, scb),
-				  ahd_get_sense_bufsize(ahd, scb),
-				  /*last*/TRUE);
-		sc->opcode = REQUEST_SENSE;
-		sc->byte2 = 0;
-		if (tinfo->protocol_version <= SCSI_REV_2
-		 && SCB_GET_LUN(scb) < 8)
-			sc->byte2 = SCB_GET_LUN(scb) << 5;
-		sc->unused[0] = 0;
-		sc->unused[1] = 0;
-		sc->length = ahd_get_sense_bufsize(ahd, scb);
-		sc->control = 0;
-
-		/*
-		 * We can't allow the target to disconnect.
-		 * This will be an untagged transaction and
-		 * having the target disconnect will make this
-		 * transaction indestinguishable from outstanding
-		 * tagged transactions.
-		 */
-		hscb->control = 0;
-
-		/*
-		 * This request sense could be because the
-		 * the device lost power or in some other
-		 * way has lost our transfer negotiations.
-		 * Renegotiate if appropriate.  Unit attention
-		 * errors will be reported before any data
-		 * phases occur.
-		 */
-		if (ahd_get_residual(scb) == ahd_get_transfer_length(scb)) {
-			ahd_update_neg_request(ahd, &devinfo,
-					       tstate, targ_info,
-					       AHD_NEG_IF_NON_ASYNC);
-		}
-		if (tstate->auto_negotiate & devinfo.target_mask) {
-			hscb->control |= MK_MESSAGE;
-			scb->flags &=
-			    ~(SCB_NEGOTIATE|SCB_ABORT|SCB_DEVICE_RESET);
-			scb->flags |= SCB_AUTO_NEGOTIATE;
-		}
-		hscb->cdb_len = sizeof(*sc);
-		ahd_setup_data_scb(ahd, scb);
-		scb->flags |= SCB_SENSE;
-		ahd_queue_scb(ahd, scb);
-		/*
-		 * Ensure we have enough time to actually
-		 * retrieve the sense.
-		 */
-		ahd_scb_timer_reset(scb, 5 * 1000000);
-		break;
-	}
-	case SCSI_STATUS_OK:
-		printf("%s: Interrupted for staus of 0???\n",
-		       ahd_name(ahd));
-		/* FALLTHROUGH */
-	default:
-		ahd_done(ahd, scb);
-		break;
-	}
-}
-
-/*
- * Calculate the residual for a just completed SCB.
- */
-void
-ahd_calc_residual(struct ahd_softc *ahd, struct scb *scb)
-{
-	struct hardware_scb *hscb;
-	struct initiator_status *spkt;
-	uint32_t sgptr;
-	uint32_t resid_sgptr;
-	uint32_t resid;
-
-	/*
-	 * 5 cases.
-	 * 1) No residual.
-	 *    SG_STATUS_VALID clear in sgptr.
-	 * 2) Transferless command
-	 * 3) Never performed any transfers.
-	 *    sgptr has SG_FULL_RESID set.
-	 * 4) No residual but target did not
-	 *    save data pointers after the
-	 *    last transfer, so sgptr was
-	 *    never updated.
-	 * 5) We have a partial residual.
-	 *    Use residual_sgptr to determine
-	 *    where we are.
-	 */
-
-	hscb = scb->hscb;
-	sgptr = ahd_le32toh(hscb->sgptr);
-	if ((sgptr & SG_STATUS_VALID) == 0)
-		/* Case 1 */
-		return;
-	sgptr &= ~SG_STATUS_VALID;
-
-	if ((sgptr & SG_LIST_NULL) != 0)
-		/* Case 2 */
-		return;
-
-	/*
-	 * Residual fields are the same in both
-	 * target and initiator status packets,
-	 * so we can always use the initiator fields
-	 * regardless of the role for this SCB.
-	 */
-	spkt = &hscb->shared_data.istatus;
-	resid_sgptr = ahd_le32toh(spkt->residual_sgptr);
-	if ((sgptr & SG_FULL_RESID) != 0) {
-		/* Case 3 */
-		resid = ahd_get_transfer_length(scb);
-	} else if ((resid_sgptr & SG_LIST_NULL) != 0) {
-		/* Case 4 */
-		return;
-	} else if ((resid_sgptr & SG_OVERRUN_RESID) != 0) {
-		ahd_print_path(ahd, scb);
-		printf("data overrun detected Tag == 0x%x.\n",
-		       SCB_GET_TAG(scb));
-		ahd_freeze_devq(ahd, scb);
-		ahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);
-		ahd_freeze_scb(scb);
-		return;
-	} else if ((resid_sgptr & ~SG_PTR_MASK) != 0) {
-		panic("Bogus resid sgptr value 0x%x\n", resid_sgptr);
-		/* NOTREACHED */
-	} else {
-		struct ahd_dma_seg *sg;
-
-		/*
-		 * Remainder of the SG where the transfer
-		 * stopped.  
-		 */
-		resid = ahd_le32toh(spkt->residual_datacnt) & AHD_SG_LEN_MASK;
-		sg = ahd_sg_bus_to_virt(ahd, scb, resid_sgptr & SG_PTR_MASK);
-
-		/* The residual sg_ptr always points to the next sg */
-		sg--;
-
-		/*
-		 * Add up the contents of all residual
-		 * SG segments that are after the SG where
-		 * the transfer stopped.
-		 */
-		while ((ahd_le32toh(sg->len) & AHD_DMA_LAST_SEG) == 0) {
-			sg++;
-			resid += ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;
-		}
-	}
-	if ((scb->flags & SCB_SENSE) == 0)
-		ahd_set_residual(scb, resid);
-	else
-		ahd_set_sense_residual(scb, resid);
-
-#ifdef AHD_DEBUG
-	if ((ahd_debug & AHD_SHOW_MISC) != 0) {
-		ahd_print_path(ahd, scb);
-		printf("Handled %sResidual of %d bytes\n",
-		       (scb->flags & SCB_SENSE) ? "Sense " : "", resid);
-	}
-#endif
-}
-
-/******************************* Target Mode **********************************/
-#ifdef AHD_TARGET_MODE
-/*
- * Add a target mode event to this lun's queue
- */
-static void
-ahd_queue_lstate_event(struct ahd_softc *ahd, struct ahd_tmode_lstate *lstate,
-		       u_int initiator_id, u_int event_type, u_int event_arg)
-{
-	struct ahd_tmode_event *event;
-	int pending;
-
-	xpt_freeze_devq(lstate->path, /*count*/1);
-	if (lstate->event_w_idx >= lstate->event_r_idx)
-		pending = lstate->event_w_idx - lstate->event_r_idx;
-	else
-		pending = AHD_TMODE_EVENT_BUFFER_SIZE + 1
-			- (lstate->event_r_idx - lstate->event_w_idx);
-
-	if (event_type == EVENT_TYPE_BUS_RESET
-	 || event_type == MSG_BUS_DEV_RESET) {
-		/*
-		 * Any earlier events are irrelevant, so reset our buffer.
-		 * This has the effect of allowing us to deal with reset
-		 * floods (an external device holding down the reset line)
-		 * without losing the event that is really interesting.
-		 */
-		lstate->event_r_idx = 0;
-		lstate->event_w_idx = 0;
-		xpt_release_devq(lstate->path, pending, /*runqueue*/FALSE);
-	}
-
-	if (pending == AHD_TMODE_EVENT_BUFFER_SIZE) {
-		xpt_print_path(lstate->path);
-		printf("immediate event %x:%x lost\n",
-		       lstate->event_buffer[lstate->event_r_idx].event_type,
-		       lstate->event_buffer[lstate->event_r_idx].event_arg);
-		lstate->event_r_idx++;
-		if (lstate->event_r_idx == AHD_TMODE_EVENT_BUFFER_SIZE)
-			lstate->event_r_idx = 0;
-		xpt_release_devq(lstate->path, /*count*/1, /*runqueue*/FALSE);
-	}
-
-	event = &lstate->event_buffer[lstate->event_w_idx];
-	event->initiator_id = initiator_id;
-	event->event_type = event_type;
-	event->event_arg = event_arg;
-	lstate->event_w_idx++;
-	if (lstate->event_w_idx == AHD_TMODE_EVENT_BUFFER_SIZE)
-		lstate->event_w_idx = 0;
-}
-
-/*
- * Send any target mode events queued up waiting
- * for immediate notify resources.
- */
-void
-ahd_send_lstate_events(struct ahd_softc *ahd, struct ahd_tmode_lstate *lstate)
-{
-	struct ccb_hdr *ccbh;
-	struct ccb_immed_notify *inot;
-
-	while (lstate->event_r_idx != lstate->event_w_idx
-	    && (ccbh = SLIST_FIRST(&lstate->immed_notifies)) != NULL) {
-		struct ahd_tmode_event *event;
-
-		event = &lstate->event_buffer[lstate->event_r_idx];
-		SLIST_REMOVE_HEAD(&lstate->immed_notifies, sim_links.sle);
-		inot = (struct ccb_immed_notify *)ccbh;
-		switch (event->event_type) {
-		case EVENT_TYPE_BUS_RESET:
-			ccbh->status = CAM_SCSI_BUS_RESET|CAM_DEV_QFRZN;
-			break;
-		default:
-			ccbh->status = CAM_MESSAGE_RECV|CAM_DEV_QFRZN;
-			inot->message_args[0] = event->event_type;
-			inot->message_args[1] = event->event_arg;
-			break;
-		}
-		inot->initiator_id = event->initiator_id;
-		inot->sense_len = 0;
-		xpt_done((union ccb *)inot);
-		lstate->event_r_idx++;
-		if (lstate->event_r_idx == AHD_TMODE_EVENT_BUFFER_SIZE)
-			lstate->event_r_idx = 0;
-	}
-}
-#endif
-
-/******************** Sequencer Program Patching/Download *********************/
-
-#ifdef AHD_DUMP_SEQ
-void
-ahd_dumpseq(struct ahd_softc* ahd)
-{
-	int i;
-	int max_prog;
-
-	max_prog = 2048;
-
-	ahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
-	ahd_outb(ahd, PRGMCNT, 0);
-	ahd_outb(ahd, PRGMCNT+1, 0);
-	for (i = 0; i < max_prog; i++) {
-		uint8_t ins_bytes[4];
-
-		ahd_insb(ahd, SEQRAM, ins_bytes, 4);
-		printf("0x%08x\n", ins_bytes[0] << 24
-				 | ins_bytes[1] << 16
-				 | ins_bytes[2] << 8
-				 | ins_bytes[3]);
-	}
-}
-#endif
-
-static void
-ahd_loadseq(struct ahd_softc *ahd)
-{
-	struct	cs cs_table[num_critical_sections];
-	u_int	begin_set[num_critical_sections];
-	u_int	end_set[num_critical_sections];
-	struct	patch *cur_patch;
-	u_int	cs_count;
-	u_int	cur_cs;
-	u_int	i;
-	int	downloaded;
-	u_int	skip_addr;
-	u_int	sg_prefetch_cnt;
-	u_int	sg_prefetch_cnt_limit;
-	u_int	sg_prefetch_align;
-	u_int	sg_size;
-	uint8_t	download_consts[DOWNLOAD_CONST_COUNT];
-
-	if (bootverbose)
-		printf("%s: Downloading Sequencer Program...",
-		       ahd_name(ahd));
-
-#if DOWNLOAD_CONST_COUNT != 7
-#error "Download Const Mismatch"
-#endif
-	/*
-	 * Start out with 0 critical sections
-	 * that apply to this firmware load.
-	 */
-	cs_count = 0;
-	cur_cs = 0;
-	memset(begin_set, 0, sizeof(begin_set));
-	memset(end_set, 0, sizeof(end_set));
-
-	/*
-	 * Setup downloadable constant table.
-	 * 
-	 * The computation for the S/G prefetch variables is
-	 * a bit complicated.  We would like to always fetch
-	 * in terms of cachelined sized increments.  However,
-	 * if the cacheline is not an even multiple of the
-	 * SG element size or is larger than our SG RAM, using
-	 * just the cache size might leave us with only a portion
-	 * of an SG element at the tail of a prefetch.  If the
-	 * cacheline is larger than our S/G prefetch buffer less
-	 * the size of an SG element, we may round down to a cacheline
-	 * that doesn't contain any or all of the S/G of interest
-	 * within the bounds of our S/G ram.  Provide variables to
-	 * the sequencer that will allow it to handle these edge
-	 * cases.
-	 */
-	/* Start by aligning to the nearest cacheline. */
-	sg_prefetch_align = ahd->pci_cachesize;
-	if (sg_prefetch_align == 0)
-		sg_prefetch_cnt = 8;
-	/* Round down to the nearest power of 2. */
-	while (powerof2(sg_prefetch_align) == 0)
-		sg_prefetch_align--;
-	/*
-	 * If the cacheline boundary is greater than half our prefetch RAM
-	 * we risk not being able to fetch even a single complete S/G
-	 * segment if we align to that boundary.
-	 */
-	if (sg_prefetch_align > CCSGADDR_MAX/2)
-		sg_prefetch_align = CCSGADDR_MAX/2;
-	/* Start by fetching a single cacheline. */
-	sg_prefetch_cnt = sg_prefetch_align;
-	/*
-	 * Increment the prefetch count by cachelines until
-	 * at least one S/G element will fit.
-	 */
-	sg_size = sizeof(struct ahd_dma_seg);
-	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)
-		sg_size = sizeof(struct ahd_dma64_seg);
-	while (sg_prefetch_cnt < sg_size)
-		sg_prefetch_cnt += sg_prefetch_align;
-	/*
-	 * If the cacheline is not an even multiple of
-	 * the S/G size, we may only get a partial S/G when
-	 * we align. Add a cacheline if this is the case.
-	 */
-	if ((sg_prefetch_align % sg_size) != 0
-	 && (sg_prefetch_cnt < CCSGADDR_MAX))
-		sg_prefetch_cnt += sg_prefetch_align;
-	/*
-	 * Lastly, compute a value that the sequencer can use
-	 * to determine if the remainder of the CCSGRAM buffer
-	 * has a full S/G element in it.
-	 */
-	sg_prefetch_cnt_limit = -(sg_prefetch_cnt - sg_size + 1);
-	download_consts[SG_PREFETCH_CNT] = sg_prefetch_cnt;
-	download_consts[SG_PREFETCH_CNT_LIMIT] = sg_prefetch_cnt_limit;
-	download_consts[SG_PREFETCH_ALIGN_MASK] = ~(sg_prefetch_align - 1);
-	download_consts[SG_PREFETCH_ADDR_MASK] = (sg_prefetch_align - 1);
-	download_consts[SG_SIZEOF] = sg_size;
-	download_consts[PKT_OVERRUN_BUFOFFSET] =
-		(ahd->overrun_buf - (uint8_t *)ahd->qoutfifo) / 256;
-	download_consts[SCB_TRANSFER_SIZE] = SCB_TRANSFER_SIZE_1BYTE_LUN;
-	if ((ahd->bugs & AHD_PKT_LUN_BUG) != 0)
-		download_consts[SCB_TRANSFER_SIZE] = SCB_TRANSFER_SIZE_FULL_LUN;
-	cur_patch = patches;
-	downloaded = 0;
-	skip_addr = 0;
-	ahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
-	ahd_outb(ahd, PRGMCNT, 0);
-	ahd_outb(ahd, PRGMCNT+1, 0);
-
-	for (i = 0; i < sizeof(seqprog)/4; i++) {
-		if (ahd_check_patch(ahd, &cur_patch, i, &skip_addr) == 0) {
-			/*
-			 * Don't download this instruction as it
-			 * is in a patch that was removed.
-			 */
-			continue;
-		}
-		/*
-		 * Move through the CS table until we find a CS
-		 * that might apply to this instruction.
-		 */
-		for (; cur_cs < num_critical_sections; cur_cs++) {
-			if (critical_sections[cur_cs].end <= i) {
-				if (begin_set[cs_count] == TRUE
-				 && end_set[cs_count] == FALSE) {
-					cs_table[cs_count].end = downloaded;
-				 	end_set[cs_count] = TRUE;
-					cs_count++;
-				}
-				continue;
-			}
-			if (critical_sections[cur_cs].begin <= i
-			 && begin_set[cs_count] == FALSE) {
-				cs_table[cs_count].begin = downloaded;
-				begin_set[cs_count] = TRUE;
-			}
-			break;
-		}
-		ahd_download_instr(ahd, i, download_consts);
-		downloaded++;
-	}
-
-	ahd->num_critical_sections = cs_count;
-	if (cs_count != 0) {
-
-		cs_count *= sizeof(struct cs);
-		ahd->critical_sections = malloc(cs_count, M_DEVBUF, M_NOWAIT);
-		if (ahd->critical_sections == NULL)
-			panic("ahd_loadseq: Could not malloc");
-		memcpy(ahd->critical_sections, cs_table, cs_count);
-	}
-	ahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE);
-
-	if (bootverbose) {
-		printf(" %d instructions downloaded\n", downloaded);
-		printf("%s: Features 0x%x, Bugs 0x%x, Flags 0x%x\n",
-		       ahd_name(ahd), ahd->features, ahd->bugs, ahd->flags);
-	}
-}
-
-static int
-ahd_check_patch(struct ahd_softc *ahd, struct patch **start_patch,
-		u_int start_instr, u_int *skip_addr)
-{
-	struct	patch *cur_patch;
-	struct	patch *last_patch;
-	u_int	num_patches;
-
-	num_patches = sizeof(patches)/sizeof(struct patch);
-	last_patch = &patches[num_patches];
-	cur_patch = *start_patch;
-
-	while (cur_patch < last_patch && start_instr == cur_patch->begin) {
-
-		if (cur_patch->patch_func(ahd) == 0) {
-
-			/* Start rejecting code */
-			*skip_addr = start_instr + cur_patch->skip_instr;
-			cur_patch += cur_patch->skip_patch;
-		} else {
-			/* Accepted this patch.  Advance to the next
-			 * one and wait for our intruction pointer to
-			 * hit this point.
-			 */
-			cur_patch++;
-		}
-	}
-
-	*start_patch = cur_patch;
-	if (start_instr < *skip_addr)
-		/* Still skipping */
-		return (0);
-
-	return (1);
-}
-
-static u_int
-ahd_resolve_seqaddr(struct ahd_softc *ahd, u_int address)
-{
-	struct patch *cur_patch;
-	int address_offset;
-	u_int skip_addr;
-	u_int i;
-
-	address_offset = 0;
-	cur_patch = patches;
-	skip_addr = 0;
-
-	for (i = 0; i < address;) {
-
-		ahd_check_patch(ahd, &cur_patch, i, &skip_addr);
-
-		if (skip_addr > i) {
-			int end_addr;
-
-			end_addr = MIN(address, skip_addr);
-			address_offset += end_addr - i;
-			i = skip_addr;
-		} else {
-			i++;
-		}
-	}
-	return (address - address_offset);
-}
-
-static void
-ahd_download_instr(struct ahd_softc *ahd, u_int instrptr, uint8_t *dconsts)
-{
-	union	ins_formats instr;
-	struct	ins_format1 *fmt1_ins;
-	struct	ins_format3 *fmt3_ins;
-	u_int	opcode;
-
-	/*
-	 * The firmware is always compiled into a little endian format.
-	 */
-	instr.integer = ahd_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);
-
-	fmt1_ins = &instr.format1;
-	fmt3_ins = NULL;
-
-	/* Pull the opcode */
-	opcode = instr.format1.opcode;
-	switch (opcode) {
-	case AIC_OP_JMP:
-	case AIC_OP_JC:
-	case AIC_OP_JNC:
-	case AIC_OP_CALL:
-	case AIC_OP_JNE:
-	case AIC_OP_JNZ:
-	case AIC_OP_JE:
-	case AIC_OP_JZ:
-	{
-		fmt3_ins = &instr.format3;
-		fmt3_ins->address = ahd_resolve_seqaddr(ahd, fmt3_ins->address);
-		/* FALLTHROUGH */
-	}
-	case AIC_OP_OR:
-	case AIC_OP_AND:
-	case AIC_OP_XOR:
-	case AIC_OP_ADD:
-	case AIC_OP_ADC:
-	case AIC_OP_BMOV:
-		if (fmt1_ins->parity != 0) {
-			fmt1_ins->immediate = dconsts[fmt1_ins->immediate];
-		}
-		fmt1_ins->parity = 0;
-		/* FALLTHROUGH */
-	case AIC_OP_ROL:
-	{
-		int i, count;
-
-		/* Calculate odd parity for the instruction */
-		for (i = 0, count = 0; i < 31; i++) {
-			uint32_t mask;
-
-			mask = 0x01 << i;
-			if ((instr.integer & mask) != 0)
-				count++;
-		}
-		if ((count & 0x01) == 0)
-			instr.format1.parity = 1;
-
-		/* The sequencer is a little endian cpu */
-		instr.integer = ahd_htole32(instr.integer);
-		ahd_outsb(ahd, SEQRAM, instr.bytes, 4);
-		break;
-	}
-	default:
-		panic("Unknown opcode encountered in seq program");
-		break;
-	}
-}
-
-static int
-ahd_probe_stack_size(struct ahd_softc *ahd)
-{
-	int last_probe;
-
-	last_probe = 0;
-	while (1) {
-		int i;
-
-		/*
-		 * We avoid using 0 as a pattern to avoid
-		 * confusion if the stack implementation
-		 * "back-fills" with zeros when "poping'
-		 * entries.
-		 */
-		for (i = 1; i <= last_probe+1; i++) {
-		       ahd_outb(ahd, STACK, i & 0xFF);
-		       ahd_outb(ahd, STACK, (i >> 8) & 0xFF);
-		}
-
-		/* Verify */
-		for (i = last_probe+1; i > 0; i--) {
-			u_int stack_entry;
-
-			stack_entry = ahd_inb(ahd, STACK)
-				    |(ahd_inb(ahd, STACK) << 8);
-			if (stack_entry != i)
-				goto sized;
-		}
-		last_probe++;
-	}
-sized:
-	return (last_probe);
-}
-
-void
-ahd_dump_all_cards_state()
-{
-	struct ahd_softc *list_ahd;
-
-	TAILQ_FOREACH(list_ahd, &ahd_tailq, links) {
-		ahd_dump_card_state(list_ahd);
-	}
-}
-
-int
-ahd_print_register(ahd_reg_parse_entry_t *table, u_int num_entries,
-		   const char *name, u_int address, u_int value,
-		   u_int *cur_column, u_int wrap_point)
-{
-	int	printed;
-	u_int	printed_mask;
-
-	if (cur_column != NULL && *cur_column >= wrap_point) {
-		printf("\n");
-		*cur_column = 0;
-	}
-	printed = printf("%s[0x%x]", name, value);
-	if (table == NULL) {
-		printed += printf(" ");
-		*cur_column += printed;
-		return (printed);
-	}
-	printed_mask = 0;
-	while (printed_mask != 0xFF) {
-		int entry;
-
-		for (entry = 0; entry < num_entries; entry++) {
-			if (((value & table[entry].mask)
-			  != table[entry].value)
-			 || ((printed_mask & table[entry].mask)
-			  == table[entry].mask))
-				continue;
-
-			printed += printf("%s%s",
-					  printed_mask == 0 ? ":(" : "|",
-					  table[entry].name);
-			printed_mask |= table[entry].mask;
-			
-			break;
-		}
-		if (entry >= num_entries)
-			break;
-	}
-	if (printed_mask != 0)
-		printed += printf(") ");
-	else
-		printed += printf(" ");
-	if (cur_column != NULL)
-		*cur_column += printed;
-	return (printed);
-}
-
-void
-ahd_dump_card_state(struct ahd_softc *ahd)
-{
-	struct scb	*scb;
-	ahd_mode_state	 saved_modes;
-	u_int		 dffstat;
-	int		 paused;
-	u_int		 scb_index;
-	u_int		 saved_scb_index;
-	u_int		 cur_col;
-	int		 i;
-
-	if (ahd_is_paused(ahd)) {
-		paused = 1;
-	} else {
-		paused = 0;
-		ahd_pause(ahd);
-	}
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	printf(">>>>>>>>>>>>>>>>>> Dump Card State Begins <<<<<<<<<<<<<<<<<\n"
-	       "%s: Dumping Card State at program address 0x%x Mode 0x%x\n",
-	       ahd_name(ahd), 
-	       ahd_inb(ahd, CURADDR) | (ahd_inb(ahd, CURADDR+1) << 8),
-	       ahd_build_mode_state(ahd, ahd->saved_src_mode,
-				    ahd->saved_dst_mode));
-	if (paused)
-		printf("Card was paused\n");
-	/*
-	 * Mode independent registers.
-	 */
-	cur_col = 0;
-	ahd_hs_mailbox_print(ahd_inb(ahd, LOCAL_HS_MAILBOX), &cur_col, 50);
-	ahd_intctl_print(ahd_inb(ahd, INTCTL), &cur_col, 50);
-	ahd_seqintstat_print(ahd_inb(ahd, SEQINTSTAT), &cur_col, 50);
-	ahd_saved_mode_print(ahd_inb(ahd, SAVED_MODE), &cur_col, 50);
-	ahd_dffstat_print(ahd_inb(ahd, DFFSTAT), &cur_col, 50);
-	ahd_scsisigi_print(ahd_inb(ahd, SCSISIGI), &cur_col, 50);
-	ahd_scsiphase_print(ahd_inb(ahd, SCSIPHASE), &cur_col, 50);
-	ahd_scsibus_print(ahd_inb(ahd, SCSIBUS), &cur_col, 50);
-	ahd_lastphase_print(ahd_inb(ahd, LASTPHASE), &cur_col, 50);
-	ahd_scsiseq0_print(ahd_inb(ahd, SCSISEQ0), &cur_col, 50);
-	ahd_scsiseq1_print(ahd_inb(ahd, SCSISEQ1), &cur_col, 50);
-	ahd_seqctl0_print(ahd_inb(ahd, SEQCTL0), &cur_col, 50);
-	ahd_seqintctl_print(ahd_inb(ahd, SEQINTCTL), &cur_col, 50);
-	ahd_seq_flags_print(ahd_inb(ahd, SEQ_FLAGS), &cur_col, 50);
-	ahd_seq_flags2_print(ahd_inb(ahd, SEQ_FLAGS2), &cur_col, 50);
-	ahd_sstat0_print(ahd_inb(ahd, SSTAT0), &cur_col, 50);
-	ahd_sstat1_print(ahd_inb(ahd, SSTAT1), &cur_col, 50);
-	ahd_sstat2_print(ahd_inb(ahd, SSTAT2), &cur_col, 50);
-	ahd_sstat3_print(ahd_inb(ahd, SSTAT3), &cur_col, 50);
-	ahd_perrdiag_print(ahd_inb(ahd, PERRDIAG), &cur_col, 50);
-	ahd_simode1_print(ahd_inb(ahd, SIMODE1), &cur_col, 50);
-	ahd_lqistat0_print(ahd_inb(ahd, LQISTAT0), &cur_col, 50);
-	ahd_lqistat1_print(ahd_inb(ahd, LQISTAT1), &cur_col, 50);
-	ahd_lqistat2_print(ahd_inb(ahd, LQISTAT2), &cur_col, 50);
-	ahd_lqostat0_print(ahd_inb(ahd, LQOSTAT0), &cur_col, 50);
-	ahd_lqostat1_print(ahd_inb(ahd, LQOSTAT1), &cur_col, 50);
-	ahd_lqostat2_print(ahd_inb(ahd, LQOSTAT2), &cur_col, 50);
-	printf("\n");
-	printf("\nSCB Count = %d CMDS_PENDING = %d LASTSCB 0x%x "
-	       "CURRSCB 0x%x NEXTSCB 0x%x\n",
-	       ahd->scb_data.numscbs, ahd_inw(ahd, CMDS_PENDING),
-	       ahd_inw(ahd, LASTSCB), ahd_inw(ahd, CURRSCB),
-	       ahd_inw(ahd, NEXTSCB));
-	cur_col = 0;
-	/* QINFIFO */
-	ahd_search_qinfifo(ahd, CAM_TARGET_WILDCARD, ALL_CHANNELS,
-			   CAM_LUN_WILDCARD, SCB_LIST_NULL,
-			   ROLE_UNKNOWN, /*status*/0, SEARCH_PRINT);
-	saved_scb_index = ahd_get_scbptr(ahd);
-	printf("Pending list:");
-	i = 0;
-	LIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {
-		if (i++ > AHD_SCB_MAX)
-			break;
-		cur_col = printf("\n%3d ", SCB_GET_TAG(scb));
-		ahd_set_scbptr(ahd, SCB_GET_TAG(scb));
-		ahd_scb_control_print(ahd_inb(ahd, SCB_CONTROL), &cur_col, 60);
-		ahd_scb_scsiid_print(ahd_inb(ahd, SCB_SCSIID), &cur_col, 60);
-		ahd_scb_tag_print(ahd_inb(ahd, SCB_TAG), &cur_col, 60);
-	}
-	printf("\nTotal %d\n", i);
-
-	printf("Kernel Free SCB list: ");
-	i = 0;
-	TAILQ_FOREACH(scb, &ahd->scb_data.free_scbs, links.tqe) {
-		struct scb *list_scb;
-
-		list_scb = scb;
-		do {
-			printf("%d ", SCB_GET_TAG(list_scb));
-			list_scb = LIST_NEXT(list_scb, collision_links);
-		} while (list_scb && i++ < AHD_SCB_MAX);
-	}
-
-	LIST_FOREACH(scb, &ahd->scb_data.any_dev_free_scb_list, links.le) {
-		if (i++ > AHD_SCB_MAX)
-			break;
-		printf("%d ", SCB_GET_TAG(scb));
-	}
-	printf("\n");
-
-	printf("Sequencer Complete DMA-inprog list: ");
-	scb_index = ahd_inw(ahd, COMPLETE_SCB_DMAINPROG_HEAD);
-	i = 0;
-	while (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {
-		ahd_set_scbptr(ahd, scb_index);
-		printf("%d ", scb_index);
-		scb_index = ahd_inw(ahd, SCB_NEXT_COMPLETE);
-	}
-	printf("\n");
-
-	printf("Sequencer Complete list: ");
-	scb_index = ahd_inw(ahd, COMPLETE_SCB_HEAD);
-	i = 0;
-	while (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {
-		ahd_set_scbptr(ahd, scb_index);
-		printf("%d ", scb_index);
-		scb_index = ahd_inw(ahd, SCB_NEXT_COMPLETE);
-	}
-	printf("\n");
-
-	
-	printf("Sequencer DMA-Up and Complete list: ");
-	scb_index = ahd_inw(ahd, COMPLETE_DMA_SCB_HEAD);
-	i = 0;
-	while (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {
-		ahd_set_scbptr(ahd, scb_index);
-		printf("%d ", scb_index);
-		scb_index = ahd_inw(ahd, SCB_NEXT_COMPLETE);
-	}
-	printf("\n");
-	ahd_set_scbptr(ahd, saved_scb_index);
-	dffstat = ahd_inb(ahd, DFFSTAT);
-	for (i = 0; i < 2; i++) {
-#ifdef AHD_DEBUG
-		struct scb *fifo_scb;
-#endif
-		u_int	    fifo_scbptr;
-
-		ahd_set_modes(ahd, AHD_MODE_DFF0 + i, AHD_MODE_DFF0 + i);
-		fifo_scbptr = ahd_get_scbptr(ahd);
-		printf("\n%s: FIFO%d %s, LONGJMP == 0x%x, "
-		       "SCB 0x%x, LJSCB 0x%x\n",
-		       ahd_name(ahd), i,
-		       (dffstat & (FIFO0FREE << i)) ? "Free" : "Active",
-		       ahd_inw(ahd, LONGJMP_ADDR), fifo_scbptr,
-		       ahd_inw(ahd, LONGJMP_SCB));
-		cur_col = 0;
-		ahd_seqimode_print(ahd_inb(ahd, SEQIMODE), &cur_col, 50);
-		ahd_seqintsrc_print(ahd_inb(ahd, SEQINTSRC), &cur_col, 50);
-		ahd_dfcntrl_print(ahd_inb(ahd, DFCNTRL), &cur_col, 50);
-		ahd_dfstatus_print(ahd_inb(ahd, DFSTATUS), &cur_col, 50);
-		ahd_sg_cache_shadow_print(ahd_inb(ahd, SG_CACHE_SHADOW),
-					  &cur_col, 50);
-		ahd_sg_state_print(ahd_inb(ahd, SG_STATE), &cur_col, 50);
-		ahd_dffsxfrctl_print(ahd_inb(ahd, DFFSXFRCTL), &cur_col, 50);
-		ahd_soffcnt_print(ahd_inb(ahd, SOFFCNT), &cur_col, 50);
-		ahd_mdffstat_print(ahd_inb(ahd, MDFFSTAT), &cur_col, 50);
-		if (cur_col > 50) {
-			printf("\n");
-			cur_col = 0;
-		}
-		cur_col += printf("SHADDR = 0x%x%x, SHCNT = 0x%x ",
-				  ahd_inl(ahd, SHADDR+4),
-				  ahd_inl(ahd, SHADDR),
-				  (ahd_inb(ahd, SHCNT)
-				| (ahd_inb(ahd, SHCNT + 1) << 8)
-				| (ahd_inb(ahd, SHCNT + 2) << 16)));
-		if (cur_col > 50) {
-			printf("\n");
-			cur_col = 0;
-		}
-		cur_col += printf("HADDR = 0x%x%x, HCNT = 0x%x ",
-				  ahd_inl(ahd, HADDR+4),
-				  ahd_inl(ahd, HADDR),
-				  (ahd_inb(ahd, HCNT)
-				| (ahd_inb(ahd, HCNT + 1) << 8)
-				| (ahd_inb(ahd, HCNT + 2) << 16)));
-		ahd_ccsgctl_print(ahd_inb(ahd, CCSGCTL), &cur_col, 50);
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_SG) != 0) {
-			fifo_scb = ahd_lookup_scb(ahd, fifo_scbptr);
-			if (fifo_scb != NULL)
-				ahd_dump_sglist(fifo_scb);
-		}
-#endif
-	}
-	printf("\nLQIN: ");
-	for (i = 0; i < 20; i++)
-		printf("0x%x ", ahd_inb(ahd, LQIN + i));
-	printf("\n");
-	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
-	printf("%s: LQISTATE = 0x%x, LQOSTATE = 0x%x, OPTIONMODE = 0x%x\n",
-	       ahd_name(ahd), ahd_inb(ahd, LQISTATE), ahd_inb(ahd, LQOSTATE),
-	       ahd_inb(ahd, OPTIONMODE));
-	printf("%s: OS_SPACE_CNT = 0x%x MAXCMDCNT = 0x%x\n",
-	       ahd_name(ahd), ahd_inb(ahd, OS_SPACE_CNT),
-	       ahd_inb(ahd, MAXCMDCNT));
-	ahd_simode0_print(ahd_inb(ahd, SIMODE0), &cur_col, 50);
-	printf("\n");
-	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
-	cur_col = 0;
-	ahd_ccscbctl_print(ahd_inb(ahd, CCSCBCTL), &cur_col, 50);
-	printf("\n");
-	ahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);
-	printf("%s: REG0 == 0x%x, SINDEX = 0x%x, DINDEX = 0x%x\n",
-	       ahd_name(ahd), ahd_inw(ahd, REG0), ahd_inw(ahd, SINDEX),
-	       ahd_inw(ahd, DINDEX));
-	printf("%s: SCBPTR == 0x%x, SCB_NEXT == 0x%x, SCB_NEXT2 == 0x%x\n",
-	       ahd_name(ahd), ahd_get_scbptr(ahd), ahd_inw(ahd, SCB_NEXT),
-	       ahd_inw(ahd, SCB_NEXT2));
-	printf("CDB %x %x %x %x %x %x\n",
-	       ahd_inb(ahd, SCB_CDB_STORE),
-	       ahd_inb(ahd, SCB_CDB_STORE+1),
-	       ahd_inb(ahd, SCB_CDB_STORE+2),
-	       ahd_inb(ahd, SCB_CDB_STORE+3),
-	       ahd_inb(ahd, SCB_CDB_STORE+4),
-	       ahd_inb(ahd, SCB_CDB_STORE+5));
-	printf("STACK:");
-	for (i = 0; i < ahd->stack_size; i++) {
-		ahd->saved_stack[i] =
-		    ahd_inb(ahd, STACK)|(ahd_inb(ahd, STACK) << 8);
-		printf(" 0x%x", ahd->saved_stack[i]);
-	}
-	for (i = ahd->stack_size-1; i >= 0; i--) {
-		ahd_outb(ahd, STACK, ahd->saved_stack[i] & 0xFF);
-		ahd_outb(ahd, STACK, (ahd->saved_stack[i] >> 8) & 0xFF);
-	}
-	printf("\n<<<<<<<<<<<<<<<<< Dump Card State Ends >>>>>>>>>>>>>>>>>>\n");
-	ahd_platform_dump_card_state(ahd);
-	ahd_restore_modes(ahd, saved_modes);
-	if (paused == 0)
-		ahd_unpause(ahd);
-}
-
-void
-ahd_dump_scbs(struct ahd_softc *ahd)
-{
-	ahd_mode_state saved_modes;
-	u_int	       saved_scb_index;
-	int	       i;
-
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	saved_scb_index = ahd_get_scbptr(ahd);
-	for (i = 0; i < AHD_SCB_MAX; i++) {
-		ahd_set_scbptr(ahd, i);
-		printf("%3d", i);
-		printf("(CTRL 0x%x ID 0x%x N 0x%x N2 0x%x SG 0x%x, RSG 0x%x)\n",
-		       ahd_inb(ahd, SCB_CONTROL),
-		       ahd_inb(ahd, SCB_SCSIID), ahd_inw(ahd, SCB_NEXT),
-		       ahd_inw(ahd, SCB_NEXT2), ahd_inl(ahd, SCB_SGPTR),
-		       ahd_inl(ahd, SCB_RESIDUAL_SGPTR));
-	}
-	printf("\n");
-	ahd_set_scbptr(ahd, saved_scb_index);
-	ahd_restore_modes(ahd, saved_modes);
-}
-
-/**************************** Flexport Logic **********************************/
-/*
- * Read count 16bit words from 16bit word address start_addr from the
- * SEEPROM attached to the controller, into buf, using the controller's
- * SEEPROM reading state machine.
- */
-int
-ahd_read_seeprom(struct ahd_softc *ahd, uint16_t *buf,
-		 u_int start_addr, u_int count)
-{
-	u_int cur_addr;
-	u_int end_addr;
-	int   error;
-
-	/*
-	 * If we never make it through the loop even once,
-	 * we were passed invalid arguments.
-	 */
-	error = EINVAL;
-	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
-	end_addr = start_addr + count;
-	for (cur_addr = start_addr; cur_addr < end_addr; cur_addr++) {
-		ahd_outb(ahd, SEEADR, cur_addr);
-		ahd_outb(ahd, SEECTL, SEEOP_READ | SEESTART);
-		
-		error = ahd_wait_seeprom(ahd);
-		if (error)
-			break;
-		*buf++ = ahd_inw(ahd, SEEDAT);
-	}
-	return (error);
-}
-
-/*
- * Write count 16bit words from buf, into SEEPROM attache to the
- * controller starting at 16bit word address start_addr, using the
- * controller's SEEPROM writing state machine.
- */
-int
-ahd_write_seeprom(struct ahd_softc *ahd, uint16_t *buf,
-		  u_int start_addr, u_int count)
-{
-	u_int cur_addr;
-	u_int end_addr;
-	int   error;
-	int   retval;
-
-	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
-	error = ENOENT;
-
-	/* Place the chip into write-enable mode */
-	ahd_outb(ahd, SEEADR, SEEOP_EWEN_ADDR);
-	ahd_outb(ahd, SEECTL, SEEOP_EWEN | SEESTART);
-	error = ahd_wait_seeprom(ahd);
-	if (error)
-		return (error);
-
-	/*
-	 * Write the data.  If we don't get throught the loop at
-	 * least once, the arguments were invalid.
-	 */
-	retval = EINVAL;
-	end_addr = start_addr + count;
-	for (cur_addr = start_addr; cur_addr < end_addr; cur_addr++) {
-		ahd_outw(ahd, SEEDAT, *buf++);
-		ahd_outb(ahd, SEEADR, cur_addr);
-		ahd_outb(ahd, SEECTL, SEEOP_WRITE | SEESTART);
-		
-		retval = ahd_wait_seeprom(ahd);
-		if (retval)
-			break;
-	}
-
-	/*
-	 * Disable writes.
-	 */
-	ahd_outb(ahd, SEEADR, SEEOP_EWDS_ADDR);
-	ahd_outb(ahd, SEECTL, SEEOP_EWDS | SEESTART);
-	error = ahd_wait_seeprom(ahd);
-	if (error)
-		return (error);
-	return (retval);
-}
-
-/*
- * Wait ~100us for the serial eeprom to satisfy our request.
- */
-int
-ahd_wait_seeprom(struct ahd_softc *ahd)
-{
-	int cnt;
-
-	cnt = 20;
-	while ((ahd_inb(ahd, SEESTAT) & (SEEARBACK|SEEBUSY)) != 0 && --cnt)
-		ahd_delay(5);
-
-	if (cnt == 0)
-		return (ETIMEDOUT);
-	return (0);
-}
-
-int
-ahd_verify_cksum(struct seeprom_config *sc)
-{
-	int i;
-	int maxaddr;
-	uint32_t checksum;
-	uint16_t *scarray;
-
-	maxaddr = (sizeof(*sc)/2) - 1;
-	checksum = 0;
-	scarray = (uint16_t *)sc;
-
-	for (i = 0; i < maxaddr; i++)
-		checksum = checksum + scarray[i];
-	if (checksum == 0
-	 || (checksum & 0xFFFF) != sc->checksum) {
-		return (0);
-	} else {
-		return (1);
-	}
-}
-
-int
-ahd_acquire_seeprom(struct ahd_softc *ahd)
-{
-	/*
-	 * We should be able to determine the SEEPROM type
-	 * from the flexport logic, but unfortunately not
-	 * all implementations have this logic and there is
-	 * no programatic method for determining if the logic
-	 * is present.
-	 */
-	return (1);
-#if 0
-	uint8_t	seetype;
-	int	error;
-
-	error = ahd_read_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, &seetype);
-	if (error != 0
-         || ((seetype & FLX_ROMSTAT_SEECFG) == FLX_ROMSTAT_SEE_NONE))
-		return (0);
-	return (1);
-#endif
-}
-
-void
-ahd_release_seeprom(struct ahd_softc *ahd)
-{
-	/* Currently a no-op */
-}
-
-int
-ahd_write_flexport(struct ahd_softc *ahd, u_int addr, u_int value)
-{
-	int error;
-
-	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
-	if (addr > 7)
-		panic("ahd_write_flexport: address out of range");
-	ahd_outb(ahd, BRDCTL, BRDEN|(addr << 3));
-	error = ahd_wait_flexport(ahd);
-	if (error != 0)
-		return (error);
-	ahd_outb(ahd, BRDDAT, value);
-	ahd_flush_device_writes(ahd);
-	ahd_outb(ahd, BRDCTL, BRDSTB|BRDEN|(addr << 3));
-	ahd_flush_device_writes(ahd);
-	ahd_outb(ahd, BRDCTL, BRDEN|(addr << 3));
-	ahd_flush_device_writes(ahd);
-	ahd_outb(ahd, BRDCTL, 0);
-	ahd_flush_device_writes(ahd);
-	return (0);
-}
-
-int
-ahd_read_flexport(struct ahd_softc *ahd, u_int addr, uint8_t *value)
-{
-	int	error;
-
-	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
-	if (addr > 7)
-		panic("ahd_read_flexport: address out of range");
-	ahd_outb(ahd, BRDCTL, BRDRW|BRDEN|(addr << 3));
-	error = ahd_wait_flexport(ahd);
-	if (error != 0)
-		return (error);
-	*value = ahd_inb(ahd, BRDDAT);
-	ahd_outb(ahd, BRDCTL, 0);
-	ahd_flush_device_writes(ahd);
-	return (0);
-}
-
-/*
- * Wait at most 2 seconds for flexport arbitration to succeed.
- */
-int
-ahd_wait_flexport(struct ahd_softc *ahd)
-{
-	int cnt;
-
-	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
-	cnt = 1000000 * 2 / 5;
-	while ((ahd_inb(ahd, BRDCTL) & FLXARBACK) == 0 && --cnt)
-		ahd_delay(5);
-
-	if (cnt == 0)
-		return (ETIMEDOUT);
-	return (0);
-}
-
-/************************* Target Mode ****************************************/
-#ifdef AHD_TARGET_MODE
-cam_status
-ahd_find_tmode_devs(struct ahd_softc *ahd, struct cam_sim *sim, union ccb *ccb,
-		    struct ahd_tmode_tstate **tstate,
-		    struct ahd_tmode_lstate **lstate,
-		    int notfound_failure)
-{
-
-	if ((ahd->features & AHD_TARGETMODE) == 0)
-		return (CAM_REQ_INVALID);
-
-	/*
-	 * Handle the 'black hole' device that sucks up
-	 * requests to unattached luns on enabled targets.
-	 */
-	if (ccb->ccb_h.target_id == CAM_TARGET_WILDCARD
-	 && ccb->ccb_h.target_lun == CAM_LUN_WILDCARD) {
-		*tstate = NULL;
-		*lstate = ahd->black_hole;
-	} else {
-		u_int max_id;
-
-		max_id = (ahd->features & AHD_WIDE) ? 15 : 7;
-		if (ccb->ccb_h.target_id > max_id)
-			return (CAM_TID_INVALID);
-
-		if (ccb->ccb_h.target_lun >= AHD_NUM_LUNS)
-			return (CAM_LUN_INVALID);
-
-		*tstate = ahd->enabled_targets[ccb->ccb_h.target_id];
-		*lstate = NULL;
-		if (*tstate != NULL)
-			*lstate =
-			    (*tstate)->enabled_luns[ccb->ccb_h.target_lun];
-	}
-
-	if (notfound_failure != 0 && *lstate == NULL)
-		return (CAM_PATH_INVALID);
-
-	return (CAM_REQ_CMP);
-}
-
-void
-ahd_handle_en_lun(struct ahd_softc *ahd, struct cam_sim *sim, union ccb *ccb)
-{
-#if NOT_YET
-	struct	   ahd_tmode_tstate *tstate;
-	struct	   ahd_tmode_lstate *lstate;
-	struct	   ccb_en_lun *cel;
-	cam_status status;
-	u_int	   target;
-	u_int	   lun;
-	u_int	   target_mask;
-	u_long	   s;
-	char	   channel;
-
-	status = ahd_find_tmode_devs(ahd, sim, ccb, &tstate, &lstate,
-				     /*notfound_failure*/FALSE);
-
-	if (status != CAM_REQ_CMP) {
-		ccb->ccb_h.status = status;
-		return;
-	}
-
-	if ((ahd->features & AHD_MULTIROLE) != 0) {
-		u_int	   our_id;
-
-		our_id = ahd->our_id;
-		if (ccb->ccb_h.target_id != our_id) {
-			if ((ahd->features & AHD_MULTI_TID) != 0
-		   	 && (ahd->flags & AHD_INITIATORROLE) != 0) {
-				/*
-				 * Only allow additional targets if
-				 * the initiator role is disabled.
-				 * The hardware cannot handle a re-select-in
-				 * on the initiator id during a re-select-out
-				 * on a different target id.
-				 */
-				status = CAM_TID_INVALID;
-			} else if ((ahd->flags & AHD_INITIATORROLE) != 0
-				|| ahd->enabled_luns > 0) {
-				/*
-				 * Only allow our target id to change
-				 * if the initiator role is not configured
-				 * and there are no enabled luns which
-				 * are attached to the currently registered
-				 * scsi id.
-				 */
-				status = CAM_TID_INVALID;
-			}
-		}
-	}
-
-	if (status != CAM_REQ_CMP) {
-		ccb->ccb_h.status = status;
-		return;
-	}
-
-	/*
-	 * We now have an id that is valid.
-	 * If we aren't in target mode, switch modes.
-	 */
-	if ((ahd->flags & AHD_TARGETROLE) == 0
-	 && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {
-		u_long	s;
-
-		printf("Configuring Target Mode\n");
-		ahd_lock(ahd, &s);
-		if (LIST_FIRST(&ahd->pending_scbs) != NULL) {
-			ccb->ccb_h.status = CAM_BUSY;
-			ahd_unlock(ahd, &s);
-			return;
-		}
-		ahd->flags |= AHD_TARGETROLE;
-		if ((ahd->features & AHD_MULTIROLE) == 0)
-			ahd->flags &= ~AHD_INITIATORROLE;
-		ahd_pause(ahd);
-		ahd_loadseq(ahd);
-		ahd_unlock(ahd, &s);
-	}
-	cel = &ccb->cel;
-	target = ccb->ccb_h.target_id;
-	lun = ccb->ccb_h.target_lun;
-	channel = SIM_CHANNEL(ahd, sim);
-	target_mask = 0x01 << target;
-	if (channel == 'B')
-		target_mask <<= 8;
-
-	if (cel->enable != 0) {
-		u_int scsiseq1;
-
-		/* Are we already enabled?? */
-		if (lstate != NULL) {
-			xpt_print_path(ccb->ccb_h.path);
-			printf("Lun already enabled\n");
-			ccb->ccb_h.status = CAM_LUN_ALRDY_ENA;
-			return;
-		}
-
-		if (cel->grp6_len != 0
-		 || cel->grp7_len != 0) {
-			/*
-			 * Don't (yet?) support vendor
-			 * specific commands.
-			 */
-			ccb->ccb_h.status = CAM_REQ_INVALID;
-			printf("Non-zero Group Codes\n");
-			return;
-		}
-
-		/*
-		 * Seems to be okay.
-		 * Setup our data structures.
-		 */
-		if (target != CAM_TARGET_WILDCARD && tstate == NULL) {
-			tstate = ahd_alloc_tstate(ahd, target, channel);
-			if (tstate == NULL) {
-				xpt_print_path(ccb->ccb_h.path);
-				printf("Couldn't allocate tstate\n");
-				ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
-				return;
-			}
-		}
-		lstate = malloc(sizeof(*lstate), M_DEVBUF, M_NOWAIT);
-		if (lstate == NULL) {
-			xpt_print_path(ccb->ccb_h.path);
-			printf("Couldn't allocate lstate\n");
-			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
-			return;
-		}
-		memset(lstate, 0, sizeof(*lstate));
-		status = xpt_create_path(&lstate->path, /*periph*/NULL,
-					 xpt_path_path_id(ccb->ccb_h.path),
-					 xpt_path_target_id(ccb->ccb_h.path),
-					 xpt_path_lun_id(ccb->ccb_h.path));
-		if (status != CAM_REQ_CMP) {
-			free(lstate, M_DEVBUF);
-			xpt_print_path(ccb->ccb_h.path);
-			printf("Couldn't allocate path\n");
-			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
-			return;
-		}
-		SLIST_INIT(&lstate->accept_tios);
-		SLIST_INIT(&lstate->immed_notifies);
-		ahd_lock(ahd, &s);
-		ahd_pause(ahd);
-		if (target != CAM_TARGET_WILDCARD) {
-			tstate->enabled_luns[lun] = lstate;
-			ahd->enabled_luns++;
-
-			if ((ahd->features & AHD_MULTI_TID) != 0) {
-				u_int targid_mask;
-
-				targid_mask = ahd_inb(ahd, TARGID)
-					    | (ahd_inb(ahd, TARGID + 1) << 8);
-
-				targid_mask |= target_mask;
-				ahd_outb(ahd, TARGID, targid_mask);
-				ahd_outb(ahd, TARGID+1, (targid_mask >> 8));
-				
-				ahd_update_scsiid(ahd, targid_mask);
-			} else {
-				u_int our_id;
-				char  channel;
-
-				channel = SIM_CHANNEL(ahd, sim);
-				our_id = SIM_SCSI_ID(ahd, sim);
-
-				/*
-				 * This can only happen if selections
-				 * are not enabled
-				 */
-				if (target != our_id) {
-					u_int sblkctl;
-					char  cur_channel;
-					int   swap;
-
-					sblkctl = ahd_inb(ahd, SBLKCTL);
-					cur_channel = (sblkctl & SELBUSB)
-						    ? 'B' : 'A';
-					if ((ahd->features & AHD_TWIN) == 0)
-						cur_channel = 'A';
-					swap = cur_channel != channel;
-					ahd->our_id = target;
-
-					if (swap)
-						ahd_outb(ahd, SBLKCTL,
-							 sblkctl ^ SELBUSB);
-
-					ahd_outb(ahd, SCSIID, target);
-
-					if (swap)
-						ahd_outb(ahd, SBLKCTL, sblkctl);
-				}
-			}
-		} else
-			ahd->black_hole = lstate;
-		/* Allow select-in operations */
-		if (ahd->black_hole != NULL && ahd->enabled_luns > 0) {
-			scsiseq1 = ahd_inb(ahd, SCSISEQ_TEMPLATE);
-			scsiseq1 |= ENSELI;
-			ahd_outb(ahd, SCSISEQ_TEMPLATE, scsiseq1);
-			scsiseq1 = ahd_inb(ahd, SCSISEQ1);
-			scsiseq1 |= ENSELI;
-			ahd_outb(ahd, SCSISEQ1, scsiseq1);
-		}
-		ahd_unpause(ahd);
-		ahd_unlock(ahd, &s);
-		ccb->ccb_h.status = CAM_REQ_CMP;
-		xpt_print_path(ccb->ccb_h.path);
-		printf("Lun now enabled for target mode\n");
-	} else {
-		struct scb *scb;
-		int i, empty;
-
-		if (lstate == NULL) {
-			ccb->ccb_h.status = CAM_LUN_INVALID;
-			return;
-		}
-
-		ahd_lock(ahd, &s);
-		
-		ccb->ccb_h.status = CAM_REQ_CMP;
-		LIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {
-			struct ccb_hdr *ccbh;
-
-			ccbh = &scb->io_ctx->ccb_h;
-			if (ccbh->func_code == XPT_CONT_TARGET_IO
-			 && !xpt_path_comp(ccbh->path, ccb->ccb_h.path)){
-				printf("CTIO pending\n");
-				ccb->ccb_h.status = CAM_REQ_INVALID;
-				ahd_unlock(ahd, &s);
-				return;
-			}
-		}
-
-		if (SLIST_FIRST(&lstate->accept_tios) != NULL) {
-			printf("ATIOs pending\n");
-			ccb->ccb_h.status = CAM_REQ_INVALID;
-		}
-
-		if (SLIST_FIRST(&lstate->immed_notifies) != NULL) {
-			printf("INOTs pending\n");
-			ccb->ccb_h.status = CAM_REQ_INVALID;
-		}
-
-		if (ccb->ccb_h.status != CAM_REQ_CMP) {
-			ahd_unlock(ahd, &s);
-			return;
-		}
-
-		xpt_print_path(ccb->ccb_h.path);
-		printf("Target mode disabled\n");
-		xpt_free_path(lstate->path);
-		free(lstate, M_DEVBUF);
-
-		ahd_pause(ahd);
-		/* Can we clean up the target too? */
-		if (target != CAM_TARGET_WILDCARD) {
-			tstate->enabled_luns[lun] = NULL;
-			ahd->enabled_luns--;
-			for (empty = 1, i = 0; i < 8; i++)
-				if (tstate->enabled_luns[i] != NULL) {
-					empty = 0;
-					break;
-				}
-
-			if (empty) {
-				ahd_free_tstate(ahd, target, channel,
-						/*force*/FALSE);
-				if (ahd->features & AHD_MULTI_TID) {
-					u_int targid_mask;
-
-					targid_mask = ahd_inb(ahd, TARGID)
-						    | (ahd_inb(ahd, TARGID + 1)
-						       << 8);
-
-					targid_mask &= ~target_mask;
-					ahd_outb(ahd, TARGID, targid_mask);
-					ahd_outb(ahd, TARGID+1,
-					 	 (targid_mask >> 8));
-					ahd_update_scsiid(ahd, targid_mask);
-				}
-			}
-		} else {
-
-			ahd->black_hole = NULL;
-
-			/*
-			 * We can't allow selections without
-			 * our black hole device.
-			 */
-			empty = TRUE;
-		}
-		if (ahd->enabled_luns == 0) {
-			/* Disallow select-in */
-			u_int scsiseq1;
-
-			scsiseq1 = ahd_inb(ahd, SCSISEQ_TEMPLATE);
-			scsiseq1 &= ~ENSELI;
-			ahd_outb(ahd, SCSISEQ_TEMPLATE, scsiseq1);
-			scsiseq1 = ahd_inb(ahd, SCSISEQ1);
-			scsiseq1 &= ~ENSELI;
-			ahd_outb(ahd, SCSISEQ1, scsiseq1);
-
-			if ((ahd->features & AHD_MULTIROLE) == 0) {
-				printf("Configuring Initiator Mode\n");
-				ahd->flags &= ~AHD_TARGETROLE;
-				ahd->flags |= AHD_INITIATORROLE;
-				ahd_pause(ahd);
-				ahd_loadseq(ahd);
-			}
-		}
-		ahd_unpause(ahd);
-		ahd_unlock(ahd, &s);
-	}
-#endif
-}
-
-static void
-ahd_update_scsiid(struct ahd_softc *ahd, u_int targid_mask)
-{
-#if NOT_YET
-	u_int scsiid_mask;
-	u_int scsiid;
-
-	if ((ahd->features & AHD_MULTI_TID) == 0)
-		panic("ahd_update_scsiid called on non-multitid unit\n");
-
-	/*
-	 * Since we will rely on the TARGID mask
-	 * for selection enables, ensure that OID
-	 * in SCSIID is not set to some other ID
-	 * that we don't want to allow selections on.
-	 */
-	if ((ahd->features & AHD_ULTRA2) != 0)
-		scsiid = ahd_inb(ahd, SCSIID_ULTRA2);
-	else
-		scsiid = ahd_inb(ahd, SCSIID);
-	scsiid_mask = 0x1 << (scsiid & OID);
-	if ((targid_mask & scsiid_mask) == 0) {
-		u_int our_id;
-
-		/* ffs counts from 1 */
-		our_id = ffs(targid_mask);
-		if (our_id == 0)
-			our_id = ahd->our_id;
-		else
-			our_id--;
-		scsiid &= TID;
-		scsiid |= our_id;
-	}
-	if ((ahd->features & AHD_ULTRA2) != 0)
-		ahd_outb(ahd, SCSIID_ULTRA2, scsiid);
-	else
-		ahd_outb(ahd, SCSIID, scsiid);
-#endif
-}
-
-void
-ahd_run_tqinfifo(struct ahd_softc *ahd, int paused)
-{
-	struct target_cmd *cmd;
-
-	ahd_sync_tqinfifo(ahd, BUS_DMASYNC_POSTREAD);
-	while ((cmd = &ahd->targetcmds[ahd->tqinfifonext])->cmd_valid != 0) {
-
-		/*
-		 * Only advance through the queue if we
-		 * have the resources to process the command.
-		 */
-		if (ahd_handle_target_cmd(ahd, cmd) != 0)
-			break;
-
-		cmd->cmd_valid = 0;
-		ahd_dmamap_sync(ahd, ahd->shared_data_dmat,
-				ahd->shared_data_dmamap,
-				ahd_targetcmd_offset(ahd, ahd->tqinfifonext),
-				sizeof(struct target_cmd),
-				BUS_DMASYNC_PREREAD);
-		ahd->tqinfifonext++;
-
-		/*
-		 * Lazily update our position in the target mode incoming
-		 * command queue as seen by the sequencer.
-		 */
-		if ((ahd->tqinfifonext & (HOST_TQINPOS - 1)) == 1) {
-			u_int hs_mailbox;
-
-			hs_mailbox = ahd_inb(ahd, HS_MAILBOX);
-			hs_mailbox &= ~HOST_TQINPOS;
-			hs_mailbox |= ahd->tqinfifonext & HOST_TQINPOS;
-			ahd_outb(ahd, HS_MAILBOX, hs_mailbox);
-		}
-	}
-}
-
-static int
-ahd_handle_target_cmd(struct ahd_softc *ahd, struct target_cmd *cmd)
-{
-	struct	  ahd_tmode_tstate *tstate;
-	struct	  ahd_tmode_lstate *lstate;
-	struct	  ccb_accept_tio *atio;
-	uint8_t *byte;
-	int	  initiator;
-	int	  target;
-	int	  lun;
-
-	initiator = SCSIID_TARGET(ahd, cmd->scsiid);
-	target = SCSIID_OUR_ID(cmd->scsiid);
-	lun    = (cmd->identify & MSG_IDENTIFY_LUNMASK);
-
-	byte = cmd->bytes;
-	tstate = ahd->enabled_targets[target];
-	lstate = NULL;
-	if (tstate != NULL)
-		lstate = tstate->enabled_luns[lun];
-
-	/*
-	 * Commands for disabled luns go to the black hole driver.
-	 */
-	if (lstate == NULL)
-		lstate = ahd->black_hole;
-
-	atio = (struct ccb_accept_tio*)SLIST_FIRST(&lstate->accept_tios);
-	if (atio == NULL) {
-		ahd->flags |= AHD_TQINFIFO_BLOCKED;
-		/*
-		 * Wait for more ATIOs from the peripheral driver for this lun.
-		 */
-		return (1);
-	} else
-		ahd->flags &= ~AHD_TQINFIFO_BLOCKED;
-#ifdef AHD_DEBUG
-	if ((ahd_debug & AHD_SHOW_TQIN) != 0)
-		printf("Incoming command from %d for %d:%d%s\n",
-		       initiator, target, lun,
-		       lstate == ahd->black_hole ? "(Black Holed)" : "");
-#endif
-	SLIST_REMOVE_HEAD(&lstate->accept_tios, sim_links.sle);
-
-	if (lstate == ahd->black_hole) {
-		/* Fill in the wildcards */
-		atio->ccb_h.target_id = target;
-		atio->ccb_h.target_lun = lun;
-	}
-
-	/*
-	 * Package it up and send it off to
-	 * whomever has this lun enabled.
-	 */
-	atio->sense_len = 0;
-	atio->init_id = initiator;
-	if (byte[0] != 0xFF) {
-		/* Tag was included */
-		atio->tag_action = *byte++;
-		atio->tag_id = *byte++;
-		atio->ccb_h.flags = CAM_TAG_ACTION_VALID;
-	} else {
-		atio->ccb_h.flags = 0;
-	}
-	byte++;
-
-	/* Okay.  Now determine the cdb size based on the command code */
-	switch (*byte >> CMD_GROUP_CODE_SHIFT) {
-	case 0:
-		atio->cdb_len = 6;
-		break;
-	case 1:
-	case 2:
-		atio->cdb_len = 10;
-		break;
-	case 4:
-		atio->cdb_len = 16;
-		break;
-	case 5:
-		atio->cdb_len = 12;
-		break;
-	case 3:
-	default:
-		/* Only copy the opcode. */
-		atio->cdb_len = 1;
-		printf("Reserved or VU command code type encountered\n");
-		break;
-	}
-	
-	memcpy(atio->cdb_io.cdb_bytes, byte, atio->cdb_len);
-
-	atio->ccb_h.status |= CAM_CDB_RECVD;
-
-	if ((cmd->identify & MSG_IDENTIFY_DISCFLAG) == 0) {
-		/*
-		 * We weren't allowed to disconnect.
-		 * We're hanging on the bus until a
-		 * continue target I/O comes in response
-		 * to this accept tio.
-		 */
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_TQIN) != 0)
-			printf("Received Immediate Command %d:%d:%d - %p\n",
-			       initiator, target, lun, ahd->pending_device);
-#endif
-		ahd->pending_device = lstate;
-		ahd_freeze_ccb((union ccb *)atio);
-		atio->ccb_h.flags |= CAM_DIS_DISCONNECT;
-	}
-	xpt_done((union ccb*)atio);
-	return (0);
-}
-
-#endif
diff -urNp linux-5720/drivers/scsi/aic79xx/aic79xx_inline.h linux-5730/drivers/scsi/aic79xx/aic79xx_inline.h
--- linux-5720/drivers/scsi/aic79xx/aic79xx_inline.h
+++ linux-5730/drivers/scsi/aic79xx/aic79xx_inline.h
@@ -1,950 +0,0 @@
-/*
- * Inline routines shareable across OS platforms.
- *
- * Copyright (c) 1994-2001 Justin T. Gibbs.
- * Copyright (c) 2000-2003 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx_inline.h#41 $
- *
- * $FreeBSD$
- */
-
-#ifndef _AIC79XX_INLINE_H_
-#define _AIC79XX_INLINE_H_
-
-/******************************** Debugging ***********************************/
-static __inline char *ahd_name(struct ahd_softc *ahd);
-
-static __inline char *
-ahd_name(struct ahd_softc *ahd)
-{
-	return (ahd->name);
-}
-
-/************************ Sequencer Execution Control *************************/
-static __inline void ahd_known_modes(struct ahd_softc *ahd,
-				     ahd_mode src, ahd_mode dst);
-static __inline ahd_mode_state ahd_build_mode_state(struct ahd_softc *ahd,
-						    ahd_mode src,
-						    ahd_mode dst);
-static __inline void ahd_extract_mode_state(struct ahd_softc *ahd,
-					    ahd_mode_state state,
-					    ahd_mode *src, ahd_mode *dst);
-static __inline void ahd_set_modes(struct ahd_softc *ahd, ahd_mode src,
-				   ahd_mode dst);
-static __inline void ahd_update_modes(struct ahd_softc *ahd);
-static __inline void ahd_assert_modes(struct ahd_softc *ahd, ahd_mode srcmode,
-				      ahd_mode dstmode, const char *file,
-				      int line);
-static __inline ahd_mode_state ahd_save_modes(struct ahd_softc *ahd);
-static __inline void ahd_restore_modes(struct ahd_softc *ahd,
-				       ahd_mode_state state);
-static __inline int  ahd_is_paused(struct ahd_softc *ahd);
-static __inline void ahd_pause(struct ahd_softc *ahd);
-static __inline void ahd_unpause(struct ahd_softc *ahd);
-
-static __inline void
-ahd_known_modes(struct ahd_softc *ahd, ahd_mode src, ahd_mode dst)
-{
-	ahd->src_mode = src;
-	ahd->dst_mode = dst;
-	ahd->saved_src_mode = src;
-	ahd->saved_dst_mode = dst;
-}
-
-static __inline ahd_mode_state
-ahd_build_mode_state(struct ahd_softc *ahd, ahd_mode src, ahd_mode dst)
-{
-	return ((src << SRC_MODE_SHIFT) | (dst << DST_MODE_SHIFT));
-}
-
-static __inline void
-ahd_extract_mode_state(struct ahd_softc *ahd, ahd_mode_state state,
-		       ahd_mode *src, ahd_mode *dst)
-{
-	*src = (state & SRC_MODE) >> SRC_MODE_SHIFT;
-	*dst = (state & DST_MODE) >> DST_MODE_SHIFT;
-}
-
-static __inline void
-ahd_set_modes(struct ahd_softc *ahd, ahd_mode src, ahd_mode dst)
-{
-	if (ahd->src_mode == src && ahd->dst_mode == dst)
-		return;
-#ifdef AHD_DEBUG
-	if (ahd->src_mode == AHD_MODE_UNKNOWN
-	 || ahd->dst_mode == AHD_MODE_UNKNOWN)
-		panic("Setting mode prior to saving it.\n");
-	if ((ahd_debug & AHD_SHOW_MODEPTR) != 0)
-		printf("%s: Setting mode 0x%x\n", ahd_name(ahd),
-		       ahd_build_mode_state(ahd, src, dst));
-#endif
-	ahd_outb(ahd, MODE_PTR, ahd_build_mode_state(ahd, src, dst));
-	ahd->src_mode = src;
-	ahd->dst_mode = dst;
-}
-
-static __inline void
-ahd_update_modes(struct ahd_softc *ahd)
-{
-	ahd_mode_state mode_ptr;
-	ahd_mode src;
-	ahd_mode dst;
-
-	mode_ptr = ahd_inb(ahd, MODE_PTR);
-#ifdef AHD_DEBUG
-	if ((ahd_debug & AHD_SHOW_MODEPTR) != 0)
-		printf("Reading mode 0x%x\n", mode_ptr);
-#endif
-	ahd_extract_mode_state(ahd, mode_ptr, &src, &dst);
-	ahd_known_modes(ahd, src, dst);
-}
-
-static __inline void
-ahd_assert_modes(struct ahd_softc *ahd, ahd_mode srcmode,
-		 ahd_mode dstmode, const char *file, int line)
-{
-#ifdef AHD_DEBUG
-	if ((srcmode & AHD_MK_MSK(ahd->src_mode)) == 0
-	 || (dstmode & AHD_MK_MSK(ahd->dst_mode)) == 0) {
-		panic("%s:%s:%d: Mode assertion failed.\n",
-		       ahd_name(ahd), file, line);
-	}
-#endif
-}
-
-static __inline ahd_mode_state
-ahd_save_modes(struct ahd_softc *ahd)
-{
-	if (ahd->src_mode == AHD_MODE_UNKNOWN
-	 || ahd->dst_mode == AHD_MODE_UNKNOWN)
-		ahd_update_modes(ahd);
-
-	return (ahd_build_mode_state(ahd, ahd->src_mode, ahd->dst_mode));
-}
-
-static __inline void
-ahd_restore_modes(struct ahd_softc *ahd, ahd_mode_state state)
-{
-	ahd_mode src;
-	ahd_mode dst;
-
-	ahd_extract_mode_state(ahd, state, &src, &dst);
-	ahd_set_modes(ahd, src, dst);
-}
-
-#define AHD_ASSERT_MODES(ahd, source, dest) \
-	ahd_assert_modes(ahd, source, dest, __FILE__, __LINE__);
-
-/*
- * Determine whether the sequencer has halted code execution.
- * Returns non-zero status if the sequencer is stopped.
- */
-static __inline int
-ahd_is_paused(struct ahd_softc *ahd)
-{
-	return ((ahd_inb(ahd, HCNTRL) & PAUSE) != 0);
-}
-
-/*
- * Request that the sequencer stop and wait, indefinitely, for it
- * to stop.  The sequencer will only acknowledge that it is paused
- * once it has reached an instruction boundary and PAUSEDIS is
- * cleared in the SEQCTL register.  The sequencer may use PAUSEDIS
- * for critical sections.
- */
-static __inline void
-ahd_pause(struct ahd_softc *ahd)
-{
-	ahd_outb(ahd, HCNTRL, ahd->pause);
-
-	/*
-	 * Since the sequencer can disable pausing in a critical section, we
-	 * must loop until it actually stops.
-	 */
-	while (ahd_is_paused(ahd) == 0)
-		;
-}
-
-/*
- * Allow the sequencer to continue program execution.
- * We check here to ensure that no additional interrupt
- * sources that would cause the sequencer to halt have been
- * asserted.  If, for example, a SCSI bus reset is detected
- * while we are fielding a different, pausing, interrupt type,
- * we don't want to release the sequencer before going back
- * into our interrupt handler and dealing with this new
- * condition.
- */
-static __inline void
-ahd_unpause(struct ahd_softc *ahd)
-{
-	/*
-	 * Automatically restore our modes to those saved
-	 * prior to the first change of the mode.
-	 */
-	if (ahd->saved_src_mode != AHD_MODE_UNKNOWN
-	 && ahd->saved_dst_mode != AHD_MODE_UNKNOWN) {
-		if ((ahd->flags & AHD_UPDATE_PEND_CMDS) != 0)
-			ahd_reset_cmds_pending(ahd);
-		ahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);
-	}
-
-	if ((ahd_inb(ahd, INTSTAT) & ~(SWTMINT | CMDCMPLT)) == 0)
-		ahd_outb(ahd, HCNTRL, ahd->unpause);
-
-	ahd_known_modes(ahd, AHD_MODE_UNKNOWN, AHD_MODE_UNKNOWN);
-}
-
-/*********************** Scatter Gather List Handling *************************/
-static __inline void	*ahd_sg_setup(struct ahd_softc *ahd, struct scb *scb,
-				      void *sgptr, bus_addr_t addr,
-				      bus_size_t len, int last);
-static __inline void	 ahd_setup_scb_common(struct ahd_softc *ahd,
-					      struct scb *scb);
-static __inline void	 ahd_setup_data_scb(struct ahd_softc *ahd,
-					    struct scb *scb);
-static __inline void	 ahd_setup_noxfer_scb(struct ahd_softc *ahd,
-					      struct scb *scb);
-
-static __inline void *
-ahd_sg_setup(struct ahd_softc *ahd, struct scb *scb,
-	     void *sgptr, bus_addr_t addr, bus_size_t len, int last)
-{
-	scb->sg_count++;
-	if (sizeof(bus_addr_t) > 4
-	 && (ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
-		struct ahd_dma64_seg *sg;
-
-		sg = (struct ahd_dma64_seg *)sgptr;
-		sg->addr = ahd_htole64(addr);
-		sg->len = ahd_htole32(len | (last ? AHD_DMA_LAST_SEG : 0));
-		return (sg + 1);
-	} else {
-		struct ahd_dma_seg *sg;
-
-		sg = (struct ahd_dma_seg *)sgptr;
-		sg->addr = ahd_htole32(addr & 0xFFFFFFFF);
-		sg->len = ahd_htole32(len | ((addr >> 8) & 0x7F000000)
-				    | (last ? AHD_DMA_LAST_SEG : 0));
-		return (sg + 1);
-	}
-}
-
-static __inline void
-ahd_setup_scb_common(struct ahd_softc *ahd, struct scb *scb)
-{
-	/* XXX Handle target mode SCBs. */
-	scb->crc_retry_count = 0;
-	if ((scb->flags & SCB_PACKETIZED) != 0) {
-		/* XXX what about ACA??  It is type 4, but TAG_TYPE == 0x3. */
-		scb->hscb->task_attribute= scb->hscb->control & SCB_TAG_TYPE;
-		/*
-		 * For Rev A short lun workaround.
-		 */
-		scb->hscb->pkt_long_lun[6] = scb->hscb->lun;
-	}
-
-	if (scb->hscb->cdb_len <= MAX_CDB_LEN_WITH_SENSE_ADDR
-	 || (scb->hscb->cdb_len & SCB_CDB_LEN_PTR) != 0)
-		scb->hscb->shared_data.idata.cdb_plus_saddr.sense_addr =
-		    ahd_htole32(scb->sense_busaddr);
-}
-
-static __inline void
-ahd_setup_data_scb(struct ahd_softc *ahd, struct scb *scb)
-{
-	/*
-	 * Copy the first SG into the "current" data ponter area.
-	 */
-	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
-		struct ahd_dma64_seg *sg;
-
-		sg = (struct ahd_dma64_seg *)scb->sg_list;
-		scb->hscb->dataptr = sg->addr;
-		scb->hscb->datacnt = sg->len;
-	} else {
-		struct ahd_dma_seg *sg;
-
-		sg = (struct ahd_dma_seg *)scb->sg_list;
-		scb->hscb->dataptr = sg->addr;
-		if ((ahd->flags & AHD_39BIT_ADDRESSING) != 0) {
-			uint64_t high_addr;
-
-			high_addr = ahd_le32toh(sg->len) & 0x7F000000;
-			scb->hscb->dataptr |= ahd_htole64(high_addr << 8);
-		}
-		scb->hscb->datacnt = sg->len;
-	}
-	/*
-	 * Note where to find the SG entries in bus space.
-	 * We also set the full residual flag which the 
-	 * sequencer will clear as soon as a data transfer
-	 * occurs.
-	 */
-	scb->hscb->sgptr = ahd_htole32(scb->sg_list_busaddr|SG_FULL_RESID);
-}
-
-static __inline void
-ahd_setup_noxfer_scb(struct ahd_softc *ahd, struct scb *scb)
-{
-	scb->hscb->sgptr = ahd_htole32(SG_LIST_NULL);
-	scb->hscb->dataptr = 0;
-	scb->hscb->datacnt = 0;
-}
-
-/************************** Memory mapping routines ***************************/
-static __inline size_t	ahd_sg_size(struct ahd_softc *ahd);
-static __inline void *
-			ahd_sg_bus_to_virt(struct ahd_softc *ahd,
-					   struct scb *scb,
-					   uint32_t sg_busaddr);
-static __inline uint32_t
-			ahd_sg_virt_to_bus(struct ahd_softc *ahd,
-					   struct scb *scb,
-					   void *sg);
-static __inline void	ahd_sync_scb(struct ahd_softc *ahd,
-				     struct scb *scb, int op);
-static __inline void	ahd_sync_sglist(struct ahd_softc *ahd,
-					struct scb *scb, int op);
-static __inline void	ahd_sync_sense(struct ahd_softc *ahd,
-				       struct scb *scb, int op);
-static __inline uint32_t
-			ahd_targetcmd_offset(struct ahd_softc *ahd,
-					     u_int index);
-
-static __inline size_t
-ahd_sg_size(struct ahd_softc *ahd)
-{
-	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)
-		return (sizeof(struct ahd_dma64_seg));
-	return (sizeof(struct ahd_dma_seg));
-}
-
-static __inline void *
-ahd_sg_bus_to_virt(struct ahd_softc *ahd, struct scb *scb, uint32_t sg_busaddr)
-{
-	bus_addr_t sg_offset;
-
-	/* sg_list_phys points to entry 1, not 0 */
-	sg_offset = sg_busaddr - (scb->sg_list_busaddr - ahd_sg_size(ahd));
-	return ((uint8_t *)scb->sg_list + sg_offset);
-}
-
-static __inline uint32_t
-ahd_sg_virt_to_bus(struct ahd_softc *ahd, struct scb *scb, void *sg)
-{
-	bus_addr_t sg_offset;
-
-	/* sg_list_phys points to entry 1, not 0 */
-	sg_offset = ((uint8_t *)sg - (uint8_t *)scb->sg_list)
-		  - ahd_sg_size(ahd);
-
-	return (scb->sg_list_busaddr + sg_offset);
-}
-
-static __inline void
-ahd_sync_scb(struct ahd_softc *ahd, struct scb *scb, int op)
-{
-	ahd_dmamap_sync(ahd, ahd->scb_data.hscb_dmat,
-			scb->hscb_map->dmamap,
-			/*offset*/(uint8_t*)scb->hscb - scb->hscb_map->vaddr,
-			/*len*/sizeof(*scb->hscb), op);
-}
-
-static __inline void
-ahd_sync_sglist(struct ahd_softc *ahd, struct scb *scb, int op)
-{
-	if (scb->sg_count == 0)
-		return;
-
-	ahd_dmamap_sync(ahd, ahd->scb_data.sg_dmat,
-			scb->sg_map->dmamap,
-			/*offset*/scb->sg_list_busaddr - ahd_sg_size(ahd),
-			/*len*/ahd_sg_size(ahd) * scb->sg_count, op);
-}
-
-static __inline void
-ahd_sync_sense(struct ahd_softc *ahd, struct scb *scb, int op)
-{
-	ahd_dmamap_sync(ahd, ahd->scb_data.sense_dmat,
-			scb->sense_map->dmamap,
-			/*offset*/scb->sense_busaddr,
-			/*len*/AHD_SENSE_BUFSIZE, op);
-}
-
-static __inline uint32_t
-ahd_targetcmd_offset(struct ahd_softc *ahd, u_int index)
-{
-	return (((uint8_t *)&ahd->targetcmds[index])
-	       - (uint8_t *)ahd->qoutfifo);
-}
-
-/*********************** Miscelaneous Support Functions ***********************/
-static __inline void	ahd_complete_scb(struct ahd_softc *ahd,
-					 struct scb *scb);
-static __inline void	ahd_update_residual(struct ahd_softc *ahd,
-					    struct scb *scb);
-static __inline struct ahd_initiator_tinfo *
-			ahd_fetch_transinfo(struct ahd_softc *ahd,
-					    char channel, u_int our_id,
-					    u_int remote_id,
-					    struct ahd_tmode_tstate **tstate);
-static __inline uint16_t
-			ahd_inw(struct ahd_softc *ahd, u_int port);
-static __inline void	ahd_outw(struct ahd_softc *ahd, u_int port,
-				 u_int value);
-static __inline uint32_t
-			ahd_inl(struct ahd_softc *ahd, u_int port);
-static __inline void	ahd_outl(struct ahd_softc *ahd, u_int port,
-				 uint32_t value);
-static __inline uint64_t
-			ahd_inq(struct ahd_softc *ahd, u_int port);
-static __inline void	ahd_outq(struct ahd_softc *ahd, u_int port,
-				 uint64_t value);
-static __inline u_int	ahd_get_scbptr(struct ahd_softc *ahd);
-static __inline void	ahd_set_scbptr(struct ahd_softc *ahd, u_int scbptr);
-static __inline u_int	ahd_get_hnscb_qoff(struct ahd_softc *ahd);
-static __inline void	ahd_set_hnscb_qoff(struct ahd_softc *ahd, u_int value);
-static __inline u_int	ahd_get_hescb_qoff(struct ahd_softc *ahd);
-static __inline void	ahd_set_hescb_qoff(struct ahd_softc *ahd, u_int value);
-static __inline u_int	ahd_get_snscb_qoff(struct ahd_softc *ahd);
-static __inline void	ahd_set_snscb_qoff(struct ahd_softc *ahd, u_int value);
-static __inline u_int	ahd_get_sescb_qoff(struct ahd_softc *ahd);
-static __inline void	ahd_set_sescb_qoff(struct ahd_softc *ahd, u_int value);
-static __inline u_int	ahd_get_sdscb_qoff(struct ahd_softc *ahd);
-static __inline void	ahd_set_sdscb_qoff(struct ahd_softc *ahd, u_int value);
-static __inline u_int	ahd_inb_scbram(struct ahd_softc *ahd, u_int offset);
-static __inline u_int	ahd_inw_scbram(struct ahd_softc *ahd, u_int offset);
-static __inline uint32_t
-			ahd_inl_scbram(struct ahd_softc *ahd, u_int offset);
-static __inline void	ahd_swap_with_next_hscb(struct ahd_softc *ahd,
-						struct scb *scb);
-static __inline void	ahd_queue_scb(struct ahd_softc *ahd, struct scb *scb);
-static __inline uint8_t *
-			ahd_get_sense_buf(struct ahd_softc *ahd,
-					  struct scb *scb);
-static __inline uint32_t
-			ahd_get_sense_bufaddr(struct ahd_softc *ahd,
-					      struct scb *scb);
-
-static __inline void
-ahd_complete_scb(struct ahd_softc *ahd, struct scb *scb)
-{
-	uint32_t sgptr;
-
-	sgptr = ahd_le32toh(scb->hscb->sgptr);
-	if ((sgptr & SG_STATUS_VALID) != 0)
-		ahd_handle_scb_status(ahd, scb);
-	else
-		ahd_done(ahd, scb);
-}
-
-/*
- * Determine whether the sequencer reported a residual
- * for this SCB/transaction.
- */
-static __inline void
-ahd_update_residual(struct ahd_softc *ahd, struct scb *scb)
-{
-	uint32_t sgptr;
-
-	sgptr = ahd_le32toh(scb->hscb->sgptr);
-	if ((sgptr & SG_STATUS_VALID) != 0)
-		ahd_calc_residual(ahd, scb);
-}
-
-/*
- * Return pointers to the transfer negotiation information
- * for the specified our_id/remote_id pair.
- */
-static __inline struct ahd_initiator_tinfo *
-ahd_fetch_transinfo(struct ahd_softc *ahd, char channel, u_int our_id,
-		    u_int remote_id, struct ahd_tmode_tstate **tstate)
-{
-	/*
-	 * Transfer data structures are stored from the perspective
-	 * of the target role.  Since the parameters for a connection
-	 * in the initiator role to a given target are the same as
-	 * when the roles are reversed, we pretend we are the target.
-	 */
-	if (channel == 'B')
-		our_id += 8;
-	*tstate = ahd->enabled_targets[our_id];
-	return (&(*tstate)->transinfo[remote_id]);
-}
-
-#define AHD_COPY_COL_IDX(dst, src)				\
-do {								\
-	dst->hscb->scsiid = src->hscb->scsiid;			\
-	dst->hscb->lun = src->hscb->lun;			\
-} while (0)
-
-static __inline uint16_t
-ahd_inw(struct ahd_softc *ahd, u_int port)
-{
-	return ((ahd_inb(ahd, port+1) << 8) | ahd_inb(ahd, port));
-}
-
-static __inline void
-ahd_outw(struct ahd_softc *ahd, u_int port, u_int value)
-{
-	ahd_outb(ahd, port, value & 0xFF);
-	ahd_outb(ahd, port+1, (value >> 8) & 0xFF);
-}
-
-static __inline uint32_t
-ahd_inl(struct ahd_softc *ahd, u_int port)
-{
-	return ((ahd_inb(ahd, port))
-	      | (ahd_inb(ahd, port+1) << 8)
-	      | (ahd_inb(ahd, port+2) << 16)
-	      | (ahd_inb(ahd, port+3) << 24));
-}
-
-static __inline void
-ahd_outl(struct ahd_softc *ahd, u_int port, uint32_t value)
-{
-	ahd_outb(ahd, port, (value) & 0xFF);
-	ahd_outb(ahd, port+1, ((value) >> 8) & 0xFF);
-	ahd_outb(ahd, port+2, ((value) >> 16) & 0xFF);
-	ahd_outb(ahd, port+3, ((value) >> 24) & 0xFF);
-}
-
-static __inline uint64_t
-ahd_inq(struct ahd_softc *ahd, u_int port)
-{
-	return ((ahd_inb(ahd, port))
-	      | (ahd_inb(ahd, port+1) << 8)
-	      | (ahd_inb(ahd, port+2) << 16)
-	      | (ahd_inb(ahd, port+3) << 24)
-	      | (((uint64_t)ahd_inb(ahd, port+4)) << 32)
-	      | (((uint64_t)ahd_inb(ahd, port+5)) << 40)
-	      | (((uint64_t)ahd_inb(ahd, port+6)) << 48)
-	      | (((uint64_t)ahd_inb(ahd, port+7)) << 56));
-}
-
-static __inline void
-ahd_outq(struct ahd_softc *ahd, u_int port, uint64_t value)
-{
-	ahd_outb(ahd, port, value & 0xFF);
-	ahd_outb(ahd, port+1, (value >> 8) & 0xFF);
-	ahd_outb(ahd, port+2, (value >> 16) & 0xFF);
-	ahd_outb(ahd, port+3, (value >> 24) & 0xFF);
-	ahd_outb(ahd, port+4, (value >> 32) & 0xFF);
-	ahd_outb(ahd, port+5, (value >> 40) & 0xFF);
-	ahd_outb(ahd, port+6, (value >> 48) & 0xFF);
-	ahd_outb(ahd, port+7, (value >> 56) & 0xFF);
-}
-
-static __inline u_int
-ahd_get_scbptr(struct ahd_softc *ahd)
-{
-	AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
-			 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
-	return (ahd_inb(ahd, SCBPTR) | (ahd_inb(ahd, SCBPTR + 1) << 8));
-}
-
-static __inline void
-ahd_set_scbptr(struct ahd_softc *ahd, u_int scbptr)
-{
-	AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
-			 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
-	ahd_outb(ahd, SCBPTR, scbptr & 0xFF);
-	ahd_outb(ahd, SCBPTR+1, (scbptr >> 8) & 0xFF);
-}
-
-static __inline u_int
-ahd_get_hnscb_qoff(struct ahd_softc *ahd)
-{
-	return (ahd_inw_atomic(ahd, HNSCB_QOFF));
-}
-
-static __inline void
-ahd_set_hnscb_qoff(struct ahd_softc *ahd, u_int value)
-{
-	ahd_outw_atomic(ahd, HNSCB_QOFF, value);
-}
-
-static __inline u_int
-ahd_get_hescb_qoff(struct ahd_softc *ahd)
-{
-	return (ahd_inb(ahd, HESCB_QOFF));
-}
-
-static __inline void
-ahd_set_hescb_qoff(struct ahd_softc *ahd, u_int value)
-{
-	ahd_outb(ahd, HESCB_QOFF, value);
-}
-
-static __inline u_int
-ahd_get_snscb_qoff(struct ahd_softc *ahd)
-{
-	u_int oldvalue;
-
-	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
-	oldvalue = ahd_inw(ahd, SNSCB_QOFF);
-	ahd_outw(ahd, SNSCB_QOFF, oldvalue);
-	return (oldvalue);
-}
-
-static __inline void
-ahd_set_snscb_qoff(struct ahd_softc *ahd, u_int value)
-{
-	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
-	ahd_outw(ahd, SNSCB_QOFF, value);
-}
-
-static __inline u_int
-ahd_get_sescb_qoff(struct ahd_softc *ahd)
-{
-	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
-	return (ahd_inb(ahd, SESCB_QOFF));
-}
-
-static __inline void
-ahd_set_sescb_qoff(struct ahd_softc *ahd, u_int value)
-{
-	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
-	ahd_outb(ahd, SESCB_QOFF, value);
-}
-
-static __inline u_int
-ahd_get_sdscb_qoff(struct ahd_softc *ahd)
-{
-	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
-	return (ahd_inb(ahd, SDSCB_QOFF) | (ahd_inb(ahd, SDSCB_QOFF + 1) << 8));
-}
-
-static __inline void
-ahd_set_sdscb_qoff(struct ahd_softc *ahd, u_int value)
-{
-	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
-	ahd_outb(ahd, SDSCB_QOFF, value & 0xFF);
-	ahd_outb(ahd, SDSCB_QOFF+1, (value >> 8) & 0xFF);
-}
-
-static __inline u_int
-ahd_inb_scbram(struct ahd_softc *ahd, u_int offset)
-{
-	u_int value;
-
-	/*
-	 * Workaround PCI-X Rev A. hardware bug.
-	 * After a host read of SCB memory, the chip
-	 * may become confused into thinking prefetch
-	 * was required.  This starts the discard timer
-	 * running and can cause an unexpected discard
-	 * timer interrupt.  The work around is to read
-	 * a normal register prior to the exhaustion of
-	 * the discard timer.  The mode pointer register
-	 * has no side effects and so serves well for
-	 * this purpose.
-	 *
-	 * Razor #528
-	 */
-	value = ahd_inb(ahd, offset);
-	ahd_inb(ahd, MODE_PTR);
-	return (value);
-}
-
-static __inline u_int
-ahd_inw_scbram(struct ahd_softc *ahd, u_int offset)
-{
-	return (ahd_inb_scbram(ahd, offset)
-	      | (ahd_inb_scbram(ahd, offset+1) << 8));
-}
-
-static __inline uint32_t
-ahd_inl_scbram(struct ahd_softc *ahd, u_int offset)
-{
-	return (ahd_inb_scbram(ahd, offset)
-	      | (ahd_inb_scbram(ahd, offset+1) << 8)
-	      | (ahd_inb_scbram(ahd, offset+2) << 16)
-	      | (ahd_inb_scbram(ahd, offset+3) << 24));
-}
-
-static __inline struct scb *
-ahd_lookup_scb(struct ahd_softc *ahd, u_int tag)
-{
-	struct scb* scb;
-
-	if (tag >= AHD_SCB_MAX)
-		return (NULL);
-	scb = ahd->scb_data.scbindex[tag];
-	if (scb != NULL)
-		ahd_sync_scb(ahd, scb,
-			     BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
-	return (scb);
-}
-
-static __inline void
-ahd_swap_with_next_hscb(struct ahd_softc *ahd, struct scb *scb)
-{
-	struct hardware_scb *q_hscb;
-	uint32_t saved_hscb_busaddr;
-
-	/*
-	 * Our queuing method is a bit tricky.  The card
-	 * knows in advance which HSCB (by address) to download,
-	 * and we can't disappoint it.  To achieve this, the next
-	 * HSCB to download is saved off in ahd->next_queued_hscb.
-	 * When we are called to queue "an arbitrary scb",
-	 * we copy the contents of the incoming HSCB to the one
-	 * the sequencer knows about, swap HSCB pointers and
-	 * finally assign the SCB to the tag indexed location
-	 * in the scb_array.  This makes sure that we can still
-	 * locate the correct SCB by SCB_TAG.
-	 */
-	q_hscb = ahd->next_queued_hscb;
-	saved_hscb_busaddr = q_hscb->hscb_busaddr;
-	memcpy(q_hscb, scb->hscb, sizeof(*scb->hscb));
-	q_hscb->hscb_busaddr = saved_hscb_busaddr;
-	q_hscb->next_hscb_busaddr = scb->hscb->hscb_busaddr;
-
-	/* Now swap HSCB pointers. */
-	ahd->next_queued_hscb = scb->hscb;
-	scb->hscb = q_hscb;
-
-	/* Now define the mapping from tag to SCB in the scbindex */
-	ahd->scb_data.scbindex[SCB_GET_TAG(scb)] = scb;
-}
-
-/*
- * Tell the sequencer about a new transaction to execute.
- */
-static __inline void
-ahd_queue_scb(struct ahd_softc *ahd, struct scb *scb)
-{
-	ahd_swap_with_next_hscb(ahd, scb);
-
-	if (SCBID_IS_NULL(SCB_GET_TAG(scb)))
-		panic("Attempt to queue invalid SCB tag %x\n",
-		      SCB_GET_TAG(scb));
-
-	/*
-	 * Keep a history of SCBs we've downloaded in the qinfifo.
-	 */
-	ahd->qinfifo[AHD_QIN_WRAP(ahd->qinfifonext)] = SCB_GET_TAG(scb);
-	ahd->qinfifonext++;
-
-	if (scb->sg_count != 0)
-		ahd_setup_data_scb(ahd, scb);
-	else
-		ahd_setup_noxfer_scb(ahd, scb);
-	ahd_setup_scb_common(ahd, scb);
-
-	/*
-	 * Make sure our data is consistant from the
-	 * perspective of the adapter.
-	 */
-	ahd_sync_scb(ahd, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
-
-#ifdef AHD_DEBUG
-	if ((ahd_debug & AHD_SHOW_QUEUE) != 0) {
-		printf("%s: Queueing SCB 0x%x bus addr 0x%x - 0x%x%x/0x%x\n",
-		       ahd_name(ahd),
-		       SCB_GET_TAG(scb), scb->hscb->hscb_busaddr,
-		       (u_int)((scb->hscb->dataptr >> 32) & 0xFFFFFFFF),
-		       (u_int)(scb->hscb->dataptr & 0xFFFFFFFF),
-		       scb->hscb->datacnt);
-	}
-#endif
-	/* Tell the adapter about the newly queued SCB */
-	ahd_set_hnscb_qoff(ahd, ahd->qinfifonext);
-}
-
-static __inline uint8_t *
-ahd_get_sense_buf(struct ahd_softc *ahd, struct scb *scb)
-{
-	return (scb->sense_data);
-}
-
-static __inline uint32_t
-ahd_get_sense_bufaddr(struct ahd_softc *ahd, struct scb *scb)
-{
-	return (scb->sense_busaddr);
-}
-
-/************************** Interrupt Processing ******************************/
-static __inline void	ahd_sync_qoutfifo(struct ahd_softc *ahd, int op);
-static __inline void	ahd_sync_tqinfifo(struct ahd_softc *ahd, int op);
-static __inline u_int	ahd_check_cmdcmpltqueues(struct ahd_softc *ahd);
-static __inline void	ahd_intr(struct ahd_softc *ahd);
-
-static __inline void
-ahd_sync_qoutfifo(struct ahd_softc *ahd, int op)
-{
-	ahd_dmamap_sync(ahd, ahd->shared_data_dmat, ahd->shared_data_dmamap,
-			/*offset*/0, /*len*/AHC_SCB_MAX * sizeof(uint16_t), op);
-}
-
-static __inline void
-ahd_sync_tqinfifo(struct ahd_softc *ahd, int op)
-{
-#ifdef AHD_TARGET_MODE
-	if ((ahd->flags & AHD_TARGETROLE) != 0) {
-		ahd_dmamap_sync(ahd, ahd->shared_data_dmat,
-				ahd->shared_data_dmamap,
-				ahd_targetcmd_offset(ahd, 0),
-				sizeof(struct target_cmd) * AHD_TMODE_CMDS,
-				op);
-	}
-#endif
-}
-
-/*
- * See if the firmware has posted any completed commands
- * into our in-core command complete fifos.
- */
-#define AHD_RUN_QOUTFIFO 0x1
-#define AHD_RUN_TQINFIFO 0x2
-static __inline u_int
-ahd_check_cmdcmpltqueues(struct ahd_softc *ahd)
-{
-	u_int retval;
-
-	retval = 0;
-	ahd_dmamap_sync(ahd, ahd->shared_data_dmat, ahd->shared_data_dmamap,
-			/*offset*/ahd->qoutfifonext, /*len*/2,
-			BUS_DMASYNC_POSTREAD);
-	if ((ahd->qoutfifo[ahd->qoutfifonext]
-	     & QOUTFIFO_ENTRY_VALID_LE) == ahd->qoutfifonext_valid_tag)
-		retval |= AHD_RUN_QOUTFIFO;
-#ifdef AHD_TARGET_MODE
-	if ((ahd->flags & AHD_TARGETROLE) != 0
-	 && (ahd->flags & AHD_TQINFIFO_BLOCKED) == 0) {
-		ahd_dmamap_sync(ahd, ahd->shared_data_dmat,
-				ahd->shared_data_dmamap,
-				ahd_targetcmd_offset(ahd, ahd->tqinfifofnext),
-				/*len*/sizeof(struct target_cmd),
-				BUS_DMASYNC_POSTREAD);
-		if (ahd->targetcmds[ahd->tqinfifonext].cmd_valid != 0)
-			retval |= AHD_RUN_TQINFIFO;
-	}
-#endif
-	return (retval);
-}
-
-/*
- * Catch an interrupt from the adapter
- */
-static __inline void
-ahd_intr(struct ahd_softc *ahd)
-{
-	u_int	intstat;
-
-	if ((ahd->pause & INTEN) == 0) {
-		/*
-		 * Our interrupt is not enabled on the chip
-		 * and may be disabled for re-entrancy reasons,
-		 * so just return.  This is likely just a shared
-		 * interrupt.
-		 */
-		return;
-	}
-
-	/*
-	 * Instead of directly reading the interrupt status register,
-	 * infer the cause of the interrupt by checking our in-core
-	 * completion queues.  This avoids a costly PCI bus read in
-	 * most cases.
-	 */
-	if ((ahd->flags & AHD_ALL_INTERRUPTS) == 0
-	 && (ahd_check_cmdcmpltqueues(ahd) != 0))
-		intstat = CMDCMPLT;
-	else
-		intstat = ahd_inb(ahd, INTSTAT);
-
-	if (intstat & CMDCMPLT) {
-		ahd_outb(ahd, CLRINT, CLRCMDINT);
-
-		/*
-		 * Ensure that the chip sees that we've cleared
-		 * this interrupt before we walk the output fifo.
-		 * Otherwise, we may, due to posted bus writes,
-		 * clear the interrupt after we finish the scan,
-		 * and after the sequencer has added new entries
-		 * and asserted the interrupt again.
-		 */
-		if ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {
-			if (ahd_is_paused(ahd)) {
-				/*
-				 * Potentially lost SEQINT.
-				 * If SEQINTCODE is non-zero,
-				 * simulate the SEQINT.
-				 */
-				if (ahd_inb(ahd, SEQINTCODE) != NO_SEQINT)
-					intstat |= SEQINT;
-			}
-		} else {
-			ahd_flush_device_writes(ahd);
-		}
-		ahd_run_qoutfifo(ahd);
-		ahd->cmdcmplt_counts[ahd->cmdcmplt_bucket]++;
-		ahd->cmdcmplt_total++;
-#ifdef AHD_TARGET_MODE
-		if ((ahd->flags & AHD_TARGETROLE) != 0)
-			ahd_run_tqinfifo(ahd, /*paused*/FALSE);
-#endif
-	}
-
-	if (intstat == 0xFF && (ahd->features & AHD_REMOVABLE) != 0)
-		/* Hot eject */
-		return;
-
-	if ((intstat & INT_PEND) == 0)
-		return;
-
-	if (intstat & HWERRINT) {
-		ahd_handle_hwerrint(ahd);
-		return;
-	}
-
-	if ((intstat & (PCIINT|SPLTINT)) != 0) {
-		ahd->bus_intr(ahd);
-		return;
-	}
-
-	if ((intstat & SEQINT) != 0)
-		ahd_handle_seqint(ahd, intstat);
-
-	if ((intstat & SCSIINT) != 0)
-		ahd_handle_scsiint(ahd, intstat);
-}
-
-#endif  /* _AIC79XX_INLINE_H_ */
diff -urNp linux-5720/drivers/scsi/aic79xx/aic79xx_osm.c linux-5730/drivers/scsi/aic79xx/aic79xx_osm.c
--- linux-5720/drivers/scsi/aic79xx/aic79xx_osm.c
+++ linux-5730/drivers/scsi/aic79xx/aic79xx_osm.c
@@ -1,5322 +0,0 @@
-/*
- * Adaptec AIC79xx device driver for Linux.
- *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#115 $
- *
- * --------------------------------------------------------------------------
- * Copyright (c) 1994-2000 Justin T. Gibbs.
- * Copyright (c) 1997-1999 Doug Ledford
- * Copyright (c) 2000-2003 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- */
-
-/*
- * This is the only file where module.h should
- * embed module global version info.
- */
-#define AHD_MODVERSION_FILE
-
-#include "aic79xx_osm.h"
-#include "aic79xx_inline.h"
-#include <scsi/scsicam.h>
-
-/*
- * Include aiclib.c as part of our
- * "module dependencies are hard" work around.
- */
-#include "aiclib.c"
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-#include <linux/init.h>		/* __setup */
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-#include "sd.h"			/* For geometry detection */
-#endif
-
-#include <linux/mm.h>		/* For fetching system memory size */
-
-#define __KERNEL_SYSCALLS__
-
-#include <linux/unistd.h>
-static int errno;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
-/*
- * Lock protecting manipulation of the ahd softc list.
- */
-spinlock_t ahd_list_spinlock;
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
-struct proc_dir_entry proc_scsi_aic79xx = {
-	PROC_SCSI_AIC79XX, 7, "aic79xx",
-	S_IFDIR | S_IRUGO | S_IXUGO, 2,
-	0, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL
-};
-#endif
-
-/*
- * Bucket size for counting good commands in between bad ones.
- */
-#define AHD_LINUX_ERR_THRESH	1000
-
-/*
- * Set this to the delay in seconds after SCSI bus reset.
- * Note, we honor this only for the initial bus reset.
- * The scsi error recovery code performs its own bus settle
- * delay handling for error recovery actions.
- */
-#ifdef CONFIG_AIC79XX_RESET_DELAY_MS
-#define AIC79XX_RESET_DELAY CONFIG_AIC79XX_RESET_DELAY_MS
-#else
-#define AIC79XX_RESET_DELAY 5000
-#endif
-
-/*
- * To change the default number of tagged transactions allowed per-device,
- * add a line to the lilo.conf file like:
- * append="aic79xx=verbose,tag_info:{{32,32,32,32},{32,32,32,32}}"
- * which will result in the first four devices on the first two
- * controllers being set to a tagged queue depth of 32.
- *
- * The tag_commands is an array of 16 to allow for wide and twin adapters.
- * Twin adapters will use indexes 0-7 for channel 0, and indexes 8-15
- * for channel 1.
- */
-typedef struct {
-	uint16_t tag_commands[16];	/* Allow for wide/twin adapters. */
-} adapter_tag_info_t;
-
-/*
- * Modify this as you see fit for your system.
- *
- * 0			tagged queuing disabled
- * 1 <= n <= 253	n == max tags ever dispatched.
- *
- * The driver will throttle the number of commands dispatched to a
- * device if it returns queue full.  For devices with a fixed maximum
- * queue depth, the driver will eventually determine this depth and
- * lock it in (a console message is printed to indicate that a lock
- * has occurred).  On some devices, queue full is returned for a temporary
- * resource shortage.  These devices will return queue full at varying
- * depths.  The driver will throttle back when the queue fulls occur and
- * attempt to slowly increase the depth over time as the device recovers
- * from the resource shortage.
- *
- * In this example, the first line will disable tagged queueing for all
- * the devices on the first probed aic79xx adapter.
- *
- * The second line enables tagged queueing with 4 commands/LUN for IDs
- * (0, 2-11, 13-15), disables tagged queueing for ID 12, and tells the
- * driver to attempt to use up to 64 tags for ID 1.
- *
- * The third line is the same as the first line.
- *
- * The fourth line disables tagged queueing for devices 0 and 3.  It
- * enables tagged queueing for the other IDs, with 16 commands/LUN
- * for IDs 1 and 4, 127 commands/LUN for ID 8, and 4 commands/LUN for
- * IDs 2, 5-7, and 9-15.
- */
-
-/*
- * NOTE: The below structure is for reference only, the actual structure
- *       to modify in order to change things is just below this comment block.
-adapter_tag_info_t aic79xx_tag_info[] =
-{
-	{{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
-	{{4, 64, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4}},
-	{{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
-	{{0, 16, 4, 0, 16, 4, 4, 4, 127, 4, 4, 4, 4, 4, 4, 4}}
-};
-*/
-
-#ifdef CONFIG_AIC79XX_CMDS_PER_DEVICE
-#define AIC79XX_CMDS_PER_DEVICE CONFIG_AIC79XX_CMDS_PER_DEVICE
-#else
-#define AIC79XX_CMDS_PER_DEVICE AHD_MAX_QUEUE
-#endif
-
-#define AIC79XX_CONFIGED_TAG_COMMANDS {					\
-	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
-	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
-	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
-	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
-	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
-	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
-	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
-	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE		\
-}
-
-/*
- * By default, use the number of commands specified by
- * the users kernel configuration.
- */
-static adapter_tag_info_t aic79xx_tag_info[] =
-{
-	{AIC79XX_CONFIGED_TAG_COMMANDS},
-	{AIC79XX_CONFIGED_TAG_COMMANDS},
-	{AIC79XX_CONFIGED_TAG_COMMANDS},
-	{AIC79XX_CONFIGED_TAG_COMMANDS},
-	{AIC79XX_CONFIGED_TAG_COMMANDS},
-	{AIC79XX_CONFIGED_TAG_COMMANDS},
-	{AIC79XX_CONFIGED_TAG_COMMANDS},
-	{AIC79XX_CONFIGED_TAG_COMMANDS},
-	{AIC79XX_CONFIGED_TAG_COMMANDS},
-	{AIC79XX_CONFIGED_TAG_COMMANDS},
-	{AIC79XX_CONFIGED_TAG_COMMANDS},
-	{AIC79XX_CONFIGED_TAG_COMMANDS},
-	{AIC79XX_CONFIGED_TAG_COMMANDS},
-	{AIC79XX_CONFIGED_TAG_COMMANDS},
-	{AIC79XX_CONFIGED_TAG_COMMANDS},
-	{AIC79XX_CONFIGED_TAG_COMMANDS}
-};
-
-/*
- * By default, read streaming is disabled.  In theory,
- * read streaming should enhance performance, but early
- * U320 drive firmware actually performs slower with
- * read streaming enabled.
- */
-#ifdef CONFIG_AIC79XX_ENABLE_RD_STRM
-#define AIC79XX_CONFIGED_RD_STRM 0xFFFF
-#else
-#define AIC79XX_CONFIGED_RD_STRM 0
-#endif
-
-static uint16_t aic79xx_rd_strm_info[] =
-{
-	AIC79XX_CONFIGED_RD_STRM,
-	AIC79XX_CONFIGED_RD_STRM,
-	AIC79XX_CONFIGED_RD_STRM,
-	AIC79XX_CONFIGED_RD_STRM,
-	AIC79XX_CONFIGED_RD_STRM,
-	AIC79XX_CONFIGED_RD_STRM,
-	AIC79XX_CONFIGED_RD_STRM,
-	AIC79XX_CONFIGED_RD_STRM,
-	AIC79XX_CONFIGED_RD_STRM,
-	AIC79XX_CONFIGED_RD_STRM,
-	AIC79XX_CONFIGED_RD_STRM,
-	AIC79XX_CONFIGED_RD_STRM,
-	AIC79XX_CONFIGED_RD_STRM,
-	AIC79XX_CONFIGED_RD_STRM,
-	AIC79XX_CONFIGED_RD_STRM,
-	AIC79XX_CONFIGED_RD_STRM
-};
-
-/*
- * DV option:
- *
- * positive value = DV Enabled
- * zero		  = DV Disabled
- * negative value = DV Default for adapter type/seeprom
- */
-#ifdef CONFIG_AIC79XX_DV_SETTING
-#define AIC79XX_CONFIGED_DV CONFIG_AIC79XX_DV_SETTING
-#else
-#define AIC79XX_CONFIGED_DV -1
-#endif
-
-static int8_t aic79xx_dv_settings[] =
-{
-	AIC79XX_CONFIGED_DV,
-	AIC79XX_CONFIGED_DV,
-	AIC79XX_CONFIGED_DV,
-	AIC79XX_CONFIGED_DV,
-	AIC79XX_CONFIGED_DV,
-	AIC79XX_CONFIGED_DV,
-	AIC79XX_CONFIGED_DV,
-	AIC79XX_CONFIGED_DV,
-	AIC79XX_CONFIGED_DV,
-	AIC79XX_CONFIGED_DV,
-	AIC79XX_CONFIGED_DV,
-	AIC79XX_CONFIGED_DV,
-	AIC79XX_CONFIGED_DV,
-	AIC79XX_CONFIGED_DV,
-	AIC79XX_CONFIGED_DV,
-	AIC79XX_CONFIGED_DV
-};
-
-/*
- * The I/O cell on the chip is very configurable in respect to its analog
- * characteristics.  Set the defaults here; they can be overriden with
- * the proper insmod parameters.
- */
-struct ahd_linux_iocell_opts
-{
-	uint8_t	precomp;
-	uint8_t	slewrate;
-	uint8_t amplitude;
-};
-#define AIC79XX_DEFAULT_PRECOMP		0xFF
-#define AIC79XX_DEFAULT_SLEWRATE	0xFF
-#define AIC79XX_DEFAULT_AMPLITUDE	0xFF
-#define AIC79XX_DEFAULT_IOOPTS			\
-{						\
-	AIC79XX_DEFAULT_PRECOMP,		\
-	AIC79XX_DEFAULT_SLEWRATE,		\
-	AIC79XX_DEFAULT_AMPLITUDE		\
-}
-#define AIC79XX_PRECOMP_INDEX	0
-#define AIC79XX_SLEWRATE_INDEX	1
-#define AIC79XX_AMPLITUDE_INDEX	2
-static struct ahd_linux_iocell_opts aic79xx_iocell_info[] =
-{
-	AIC79XX_DEFAULT_IOOPTS,
-	AIC79XX_DEFAULT_IOOPTS,
-	AIC79XX_DEFAULT_IOOPTS,
-	AIC79XX_DEFAULT_IOOPTS,
-	AIC79XX_DEFAULT_IOOPTS,
-	AIC79XX_DEFAULT_IOOPTS,
-	AIC79XX_DEFAULT_IOOPTS,
-	AIC79XX_DEFAULT_IOOPTS,
-	AIC79XX_DEFAULT_IOOPTS,
-	AIC79XX_DEFAULT_IOOPTS,
-	AIC79XX_DEFAULT_IOOPTS,
-	AIC79XX_DEFAULT_IOOPTS,
-	AIC79XX_DEFAULT_IOOPTS,
-	AIC79XX_DEFAULT_IOOPTS,
-	AIC79XX_DEFAULT_IOOPTS,
-	AIC79XX_DEFAULT_IOOPTS
-};
-
-/*
- * There should be a specific return value for this in scsi.h, but
- * it seems that most drivers ignore it.
- */
-#define DID_UNDERFLOW   DID_ERROR
-
-void
-ahd_print_path(struct ahd_softc *ahd, struct scb *scb)
-{
-	printk("(scsi%d:%c:%d:%d): ",
-	       ahd->platform_data->host->host_no,
-	       scb != NULL ? SCB_GET_CHANNEL(ahd, scb) : 'X',
-	       scb != NULL ? SCB_GET_TARGET(ahd, scb) : -1,
-	       scb != NULL ? SCB_GET_LUN(scb) : -1);
-}
-
-/*
- * XXX - these options apply unilaterally to _all_ adapters
- *       cards in the system.  This should be fixed.  Exceptions to this
- *       rule are noted in the comments.
- */
-
-/*
- * Skip the scsi bus reset.  Non 0 make us skip the reset at startup.  This
- * has no effect on any later resets that might occur due to things like
- * SCSI bus timeouts.
- */
-static uint32_t aic79xx_no_reset;
-
-/*
- * Certain PCI motherboards will scan PCI devices from highest to lowest,
- * others scan from lowest to highest, and they tend to do all kinds of
- * strange things when they come into contact with PCI bridge chips.  The
- * net result of all this is that the PCI card that is actually used to boot
- * the machine is very hard to detect.  Most motherboards go from lowest
- * PCI slot number to highest, and the first SCSI controller found is the
- * one you boot from.  The only exceptions to this are when a controller
- * has its BIOS disabled.  So, we by default sort all of our SCSI controllers
- * from lowest PCI slot number to highest PCI slot number.  We also force
- * all controllers with their BIOS disabled to the end of the list.  This
- * works on *almost* all computers.  Where it doesn't work, we have this
- * option.  Setting this option to non-0 will reverse the order of the sort
- * to highest first, then lowest, but will still leave cards with their BIOS
- * disabled at the very end.  That should fix everyone up unless there are
- * really strange cirumstances.
- */
-static int aic79xx_reverse_scan = 0;
-
-/*
- * Should we force EXTENDED translation on a controller.
- *     0 == Use whatever is in the SEEPROM or default to off
- *     1 == Use whatever is in the SEEPROM or default to on
- */
-static uint32_t aic79xx_extended = 0;
-
-/*
- * PCI bus parity checking of the Adaptec controllers.  This is somewhat
- * dubious at best.  To my knowledge, this option has never actually
- * solved a PCI parity problem, but on certain machines with broken PCI
- * chipset configurations, it can generate tons of false error messages.
- * It's included in the driver for completeness.
- *   0 = Shut off PCI parity check
- *  -1 = Normal polarity pci parity checking
- *   1 = reverse polarity pci parity checking
- *
- * NOTE: you can't actually pass -1 on the lilo prompt.  So, to set this
- * variable to -1 you would actually want to simply pass the variable
- * name without a number.  That will invert the 0 which will result in
- * -1.
- */
-static int aic79xx_pci_parity = 0;
-
-/*
- * There are lots of broken chipsets in the world.  Some of them will
- * violate the PCI spec when we issue byte sized memory writes to our
- * controller.  I/O mapped register access, if allowed by the given
- * platform, will work in almost all cases.
- */
-int aic79xx_allow_memio = 1;
-
-/*
- * aic79xx_detect() has been run, so register all device arrivals
- * immediately with the system rather than deferring to the sorted
- * attachment performed by aic79xx_detect().
- */
-int aic79xx_detect_complete;
-
-/*
- * So that we can set how long each device is given as a selection timeout.
- * The table of values goes like this:
- *   0 - 256ms
- *   1 - 128ms
- *   2 - 64ms
- *   3 - 32ms
- * We default to 256ms because some older devices need a longer time
- * to respond to initial selection.
- */
-static int aic79xx_seltime = 0x00;
-
-/*
- * Certain devices do not perform any aging on commands.  Should the
- * device be saturated by commands in one portion of the disk, it is
- * possible for transactions on far away sectors to never be serviced.
- * To handle these devices, we can periodically send an ordered tag to
- * force all outstanding transactions to be serviced prior to a new
- * transaction.
- */
-int aic79xx_periodic_otag;
-
-/*
- * Module information and settable options.
- */
-#ifdef MODULE
-static char *aic79xx = NULL;
-/*
- * Just in case someone uses commas to separate items on the insmod
- * command line, we define a dummy buffer here to avoid having insmod
- * write wild stuff into our code segment
- */
-static char dummy_buffer[60] = "Please don't trounce on me insmod!!\n";
-
-MODULE_AUTHOR("Maintainer: Justin T. Gibbs <gibbs@scsiguy.com>");
-MODULE_DESCRIPTION("Adaptec Aic77XX/78XX SCSI Host Bus Adapter driver");
-#ifdef MODULE_LICENSE
-MODULE_LICENSE("Dual BSD/GPL");
-#endif
-MODULE_PARM(aic79xx, "s");
-MODULE_PARM_DESC(aic79xx,
-"period delimited, options string.\n"
-"	verbose			Enable verbose/diagnostic logging\n"
-"	allow_memio		Allow device registers to be memory mapped\n"
-"	debug			Bitmask of debug values to enable\n"
-"	no_reset		Supress initial bus resets\n"
-"	extended		Enable extended geometry on all controllers\n"
-"	periodic_otag		Send an ordered tagged transaction\n"
-"				periodically to prevent tag starvation.\n"
-"				This may be required by some older disk\n"
-"				or drives/RAID arrays.\n"
-"	reverse_scan		Sort PCI devices highest Bus/Slot to lowest\n"
-"	tag_info:<tag_str>	Set per-target tag depth\n"
-"	global_tag_depth:<int>	Global tag depth for all targets on all buses\n"
-"	rd_strm:<rd_strm_masks> Set per-target read streaming setting.\n"
-"	dv:<dv_settings>	Set per-controller Domain Validation Setting.\n"
-"	slewrate:<slewrate_list>Set the signal slew rate (0-15).\n"
-"	precomp:<pcomp_list>	Set the signal precompensation (0-7).\n"
-"	amplitude:<int>		Set the signal amplitude (0-7).\n"
-"	seltime:<int>		Selection Timeout:\n"
-"				(0/256ms,1/128ms,2/64ms,3/32ms)\n"
-"\n"
-"	Sample /etc/modules.conf line:\n"
-"		Enable verbose logging\n"
-"		Set tag depth on Controller 2/Target 2 to 10 tags\n"
-"		Shorten the selection timeout to 128ms\n"
-"\n"
-"	options aic79xx='\"verbose.tag_info:{{}.{}.{..10}}.seltime:1\"'\n"
-"\n"
-"	Sample /etc/modules.conf line:\n"
-"		Change Read Streaming for Controller's 2 and 3\n"
-"\n"
-"	options aic79xx='\"rd_strm:{..0xFFF0.0xC0F0}\"'");
-#endif
-
-static void ahd_linux_handle_scsi_status(struct ahd_softc *,
-					 struct ahd_linux_device *,
-					 struct scb *);
-static void ahd_linux_queue_cmd_complete(struct ahd_softc *ahd,
-					 Scsi_Cmnd *cmd);
-static void ahd_linux_filter_inquiry(struct ahd_softc *ahd,
-				     struct ahd_devinfo *devinfo);
-static void ahd_linux_dev_timed_unfreeze(u_long arg);
-static void ahd_linux_sem_timeout(u_long arg);
-static void ahd_linux_initialize_scsi_bus(struct ahd_softc *ahd);
-static void ahd_linux_thread_run_complete_queue(struct ahd_softc *ahd);
-static void ahd_linux_start_dv(struct ahd_softc *ahd);
-static void ahd_linux_dv_timeout(struct scsi_cmnd *cmd);
-static int  ahd_linux_dv_thread(void *data);
-static void ahd_linux_dv_target(struct ahd_softc *ahd, u_int target);
-static void ahd_linux_dv_transition(struct ahd_softc *ahd,
-				    struct scsi_cmnd *cmd,
-				    struct ahd_devinfo *devinfo,
-				    struct ahd_linux_target *targ);
-static void ahd_linux_dv_fill_cmd(struct ahd_softc *ahd,
-				  struct scsi_cmnd *cmd,
-				  struct ahd_devinfo *devinfo);
-static void ahd_linux_dv_inq(struct ahd_softc *ahd,
-			     struct scsi_cmnd *cmd,
-			     struct ahd_devinfo *devinfo,
-			     struct ahd_linux_target *targ,
-			     u_int request_length);
-static void ahd_linux_dv_tur(struct ahd_softc *ahd,
-			     struct scsi_cmnd *cmd,
-			     struct ahd_devinfo *devinfo);
-static void ahd_linux_dv_rebd(struct ahd_softc *ahd,
-			      struct scsi_cmnd *cmd,
-			      struct ahd_devinfo *devinfo,
-			      struct ahd_linux_target *targ);
-static void ahd_linux_dv_web(struct ahd_softc *ahd,
-			     struct scsi_cmnd *cmd,
-			     struct ahd_devinfo *devinfo,
-			     struct ahd_linux_target *targ);
-static void ahd_linux_dv_reb(struct ahd_softc *ahd,
-			     struct scsi_cmnd *cmd,
-			     struct ahd_devinfo *devinfo,
-			     struct ahd_linux_target *targ);
-static void ahd_linux_dv_su(struct ahd_softc *ahd,
-			    struct scsi_cmnd *cmd,
-			    struct ahd_devinfo *devinfo,
-			    struct ahd_linux_target *targ);
-static __inline int
-	   ahd_linux_dv_fallback(struct ahd_softc *ahd,
-				 struct ahd_devinfo *devinfo);
-static int ahd_linux_fallback(struct ahd_softc *ahd,
-			      struct ahd_devinfo *devinfo);
-static __inline int ahd_linux_dv_fallback(struct ahd_softc *ahd,
-					  struct ahd_devinfo *devinfo);
-static void ahd_linux_dv_complete(Scsi_Cmnd *cmd);
-static void ahd_linux_generate_dv_pattern(struct ahd_linux_target *targ);
-static u_int ahd_linux_user_tagdepth(struct ahd_softc *ahd,
-				     struct ahd_devinfo *devinfo);
-static u_int ahd_linux_user_dv_setting(struct ahd_softc *ahd);
-static void ahd_linux_device_queue_depth(struct ahd_softc *ahd,
-					 struct ahd_linux_device *dev);
-static struct ahd_linux_target*	ahd_linux_alloc_target(struct ahd_softc*,
-						       u_int, u_int);
-static void			ahd_linux_free_target(struct ahd_softc*,
-						      struct ahd_linux_target*);
-static struct ahd_linux_device*	ahd_linux_alloc_device(struct ahd_softc*,
-						       struct ahd_linux_target*,
-						       u_int);
-static void			ahd_linux_free_device(struct ahd_softc*,
-						      struct ahd_linux_device*);
-static void ahd_linux_run_device_queue(struct ahd_softc*,
-				       struct ahd_linux_device*);
-static void ahd_linux_setup_tag_info(char *p, char *end, char *s);
-static void ahd_linux_setup_tag_info_global(char *p);
-static void ahd_linux_setup_rd_strm_info(char *p, char *end, char *s);
-static void ahd_linux_setup_dv(char *p, char *end, char *s);
-static void ahd_linux_setup_iocell_info(char *p, char *end, char *s, int index);
-static int ahd_linux_next_unit(void);
-static void ahd_runq_tasklet(unsigned long data);
-static int ahd_linux_halt(struct notifier_block *nb, u_long event, void *buf);
-static int aic79xx_setup(char *c);
-
-/****************************** Inlines ***************************************/
-static __inline void ahd_schedule_completeq(struct ahd_softc *ahd,
-					    struct ahd_cmd *acmd);
-static __inline void ahd_schedule_runq(struct ahd_softc *ahd);
-static __inline void ahd_setup_runq_tasklet(struct ahd_softc *ahd);
-static __inline void ahd_teardown_runq_tasklet(struct ahd_softc *ahd);
-static __inline struct ahd_linux_device*
-		     ahd_linux_get_device(struct ahd_softc *ahd, u_int channel,
-					  u_int target, u_int lun, int alloc);
-static struct ahd_cmd *ahd_linux_run_complete_queue(struct ahd_softc *ahd,
-						    struct ahd_cmd *acmd);
-static __inline void ahd_linux_check_device_queue(struct ahd_softc *ahd,
-						  struct ahd_linux_device *dev);
-static __inline struct ahd_linux_device *
-		     ahd_linux_next_device_to_run(struct ahd_softc *ahd);
-static __inline void ahd_linux_run_device_queues(struct ahd_softc *ahd);
-static __inline void ahd_linux_unmap_scb(struct ahd_softc*, struct scb*);
-
-static __inline int ahd_linux_map_seg(struct ahd_softc *ahd, struct scb *scb,
-		 		      struct ahd_dma_seg *sg,
-				      bus_addr_t addr, bus_size_t len);
-
-static __inline void
-ahd_schedule_completeq(struct ahd_softc *ahd, struct ahd_cmd *acmd)
-{
-	while (acmd != NULL) {
-		struct ahd_completeq *completeq;
-		struct ahd_cmd *list_cmd;
-		struct ahd_cmd *next_cmd;
-
-		next_cmd = TAILQ_NEXT(acmd, acmd_links.tqe);
-		completeq = &ahd->platform_data->completeq;
-		list_cmd = TAILQ_FIRST(completeq);
-		while (list_cmd != NULL
-		    && acmd_scsi_cmd(list_cmd).serial_number
-		     < acmd_scsi_cmd(acmd).serial_number)
-			list_cmd = TAILQ_NEXT(list_cmd, acmd_links.tqe);
-		if (list_cmd != NULL)
-			TAILQ_INSERT_BEFORE(list_cmd, acmd, acmd_links.tqe);
-		else
-			TAILQ_INSERT_TAIL(completeq, acmd, acmd_links.tqe);
-		acmd = next_cmd;
-	}
-	if ((ahd->platform_data->flags & AHD_RUN_CMPLT_Q_TIMER) == 0) {
-		ahd->platform_data->flags |= AHD_RUN_CMPLT_Q_TIMER;
-		ahd->platform_data->completeq_timer.expires = jiffies;
-		add_timer(&ahd->platform_data->completeq_timer);
-	}
-}
-
-static __inline void
-ahd_schedule_runq(struct ahd_softc *ahd)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	tasklet_schedule(&ahd->platform_data->runq_tasklet);
-#else
-	/*
-	 * Tasklets are not available, so run inline.
-	 */
-	ahd_runq_tasklet((unsigned long)ahd);
-#endif
-}
-
-static __inline
-void ahd_setup_runq_tasklet(struct ahd_softc *ahd)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	tasklet_init(&ahd->platform_data->runq_tasklet, ahd_runq_tasklet,
-		     (unsigned long)ahd);
-#endif
-}
-
-static __inline void
-ahd_teardown_runq_tasklet(struct ahd_softc *ahd)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	tasklet_kill(&ahd->platform_data->runq_tasklet);
-#endif
-}
-
-static __inline struct ahd_linux_device*
-ahd_linux_get_device(struct ahd_softc *ahd, u_int channel, u_int target,
-		     u_int lun, int alloc)
-{
-	struct ahd_linux_target *targ;
-	struct ahd_linux_device *dev;
-	u_int target_offset;
-
-	target_offset = target;
-	if (channel != 0)
-		target_offset += 8;
-	targ = ahd->platform_data->targets[target_offset];
-	if (targ == NULL) {
-		if (alloc != 0) {
-			targ = ahd_linux_alloc_target(ahd, channel, target);
-			if (targ == NULL)
-				return (NULL);
-		} else
-			return (NULL);
-	}
-	dev = targ->devices[lun];
-	if (dev == NULL && alloc != 0)
-		dev = ahd_linux_alloc_device(ahd, targ, lun);
-	return (dev);
-}
-
-#define AHD_LINUX_MAX_RETURNED_ERRORS 4
-static struct ahd_cmd *
-ahd_linux_run_complete_queue(struct ahd_softc *ahd, struct ahd_cmd *acmd)
-{	
-	u_long	done_flags;
-	int	with_errors;
-
-	ahd_done_lock(ahd, &done_flags);
-	with_errors = 0;
-	while (acmd != NULL) {
-		Scsi_Cmnd *cmd;
-
-		cmd = &acmd_scsi_cmd(acmd);
-		acmd = TAILQ_NEXT(acmd, acmd_links.tqe);
-		cmd->host_scribble = NULL;
-		if (ahd_cmd_get_transaction_status(cmd) != DID_OK
-		 || (cmd->result & 0xFF) != SCSI_STATUS_OK)
-			with_errors++;
-
-		cmd->scsi_done(cmd);
-
-		if (with_errors > AHD_LINUX_MAX_RETURNED_ERRORS) {
-			/*
-			 * Linux uses stack recursion to requeue
-			 * commands that need to be retried.  Avoid
-			 * blowing out the stack by "spoon feeding"
-			 * commands that completed with error back
-			 * the operating system in case they are going
-			 * to be retried. "ick"
-			 */
-			break;
-		}
-	}
-	ahd_done_unlock(ahd, &done_flags);
-	return (acmd);
-}
-
-static __inline void
-ahd_linux_check_device_queue(struct ahd_softc *ahd,
-			     struct ahd_linux_device *dev)
-{
-	if ((dev->flags & AHD_DEV_FREEZE_TIL_EMPTY) != 0
-	 && dev->active == 0) {
-		dev->flags &= ~AHD_DEV_FREEZE_TIL_EMPTY;
-		dev->qfrozen--;
-	}
-
-	if (TAILQ_FIRST(&dev->busyq) == NULL
-	 || dev->openings == 0 || dev->qfrozen != 0)
-		return;
-
-	ahd_linux_run_device_queue(ahd, dev);
-}
-
-static __inline struct ahd_linux_device *
-ahd_linux_next_device_to_run(struct ahd_softc *ahd)
-{
-	
-	if ((ahd->flags & AHD_RESOURCE_SHORTAGE) != 0
-	 || (ahd->platform_data->qfrozen != 0
-	  && AHD_DV_SIMQ_FROZEN(ahd) == 0))
-		return (NULL);
-	return (TAILQ_FIRST(&ahd->platform_data->device_runq));
-}
-
-static __inline void
-ahd_linux_run_device_queues(struct ahd_softc *ahd)
-{
-	struct ahd_linux_device *dev;
-
-	while ((dev = ahd_linux_next_device_to_run(ahd)) != NULL) {
-		TAILQ_REMOVE(&ahd->platform_data->device_runq, dev, links);
-		dev->flags &= ~AHD_DEV_ON_RUN_LIST;
-		ahd_linux_check_device_queue(ahd, dev);
-	}
-}
-
-static __inline void
-ahd_linux_unmap_scb(struct ahd_softc *ahd, struct scb *scb)
-{
-	Scsi_Cmnd *cmd;
-	int direction;
-
-	cmd = scb->io_ctx;
-	direction = scsi_to_pci_dma_dir(cmd->sc_data_direction);
-	ahd_sync_sglist(ahd, scb, BUS_DMASYNC_POSTWRITE);
-	if (cmd->use_sg != 0) {
-		struct scatterlist *sg;
-
-		sg = (struct scatterlist *)cmd->request_buffer;
-		pci_unmap_sg(ahd->dev_softc, sg, cmd->use_sg, direction);
-	} else if (cmd->request_bufflen != 0) {
-		pci_unmap_single(ahd->dev_softc,
-				 scb->platform_data->buf_busaddr,
-				 cmd->request_bufflen, direction);
-	}
-}
-
-static __inline int
-ahd_linux_map_seg(struct ahd_softc *ahd, struct scb *scb,
-		  struct ahd_dma_seg *sg, bus_addr_t addr, bus_size_t len)
-{
-	int	 consumed;
-
-	if ((scb->sg_count + 1) > AHD_NSEG)
-		panic("Too few segs for dma mapping.  "
-		      "Increase AHD_NSEG\n");
-
-	consumed = 1;
-	sg->addr = ahd_htole32(addr & 0xFFFFFFFF);
-	scb->platform_data->xfer_len += len;
-	if (sizeof(bus_addr_t) > 4
-	 && (ahd->flags & AHD_39BIT_ADDRESSING) != 0) {
-		/*
-		 * Due to DAC restrictions, we can't
-		 * cross a 4GB boundary.
-		 */
-		if ((addr ^ (addr + len - 1)) & ~0xFFFFFFFF) {
-			struct	 ahd_dma_seg *next_sg;
-			uint32_t next_len;
-
-			printf("Crossed Seg\n");
-			if ((scb->sg_count + 2) > AHD_NSEG)
-				panic("Too few segs for dma mapping.  "
-				      "Increase AHD_NSEG\n");
-
-			consumed++;
-			next_sg = sg + 1;
-			next_sg->addr = 0;
-			next_len = 0x100000000 - (addr & 0xFFFFFFFF);
-			len -= next_len;
-			next_len |= ((addr >> 8) + 0x1000000) & 0x7F000000;
-			next_sg->len = ahd_htole32(next_len);
-		}
-		len |= (addr >> 8) & 0x7F000000;
-	}
-	sg->len = ahd_htole32(len);
-	return (consumed);
-}
-
-/******************************** Macros **************************************/
-#define BUILD_SCSIID(ahd, cmd)						\
-	((((cmd)->device->id << TID_SHIFT) & TID) | (ahd)->our_id)
-
-/************************  Host template entry points *************************/
-static int	   ahd_linux_detect(Scsi_Host_Template *);
-static int	   ahd_linux_release(struct Scsi_Host *);
-static const char *ahd_linux_info(struct Scsi_Host *);
-static int	   ahd_linux_queue(Scsi_Cmnd *, void (*)(Scsi_Cmnd *));
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-static int	   ahd_linux_slave_alloc(Scsi_Device *);
-static int	   ahd_linux_slave_configure(Scsi_Device *);
-static void	   ahd_linux_slave_destroy(Scsi_Device *);
-static int	   ahd_linux_biosparam(struct scsi_device*,
-				       struct block_device*, sector_t, int[]);
-#else
-static void	   ahd_linux_select_queue_depth(struct Scsi_Host *host,
-						Scsi_Device *scsi_devs);
-static int	   ahd_linux_biosparam(Disk *, kdev_t, int[]);
-#endif
-static int	   ahd_linux_bus_reset(Scsi_Cmnd *);
-static int	   ahd_linux_dev_reset(Scsi_Cmnd *);
-static int	   ahd_linux_abort(Scsi_Cmnd *);
-
-/*
- * Try to detect an Adaptec 79XX controller.
- */
-static int
-ahd_linux_detect(Scsi_Host_Template *template)
-{
-	struct	ahd_softc *ahd;
-	int     found;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	/*
-	 * It is a bug that the upper layer takes
-	 * this lock just prior to calling us.
-	 */
-	spin_unlock_irq(&io_request_lock);
-#endif
-
-	/*
-	 * Sanity checking of Linux SCSI data structures so
-	 * that some of our hacks^H^H^H^H^Hassumptions aren't
-	 * violated.
-	 */
-	if (offsetof(struct ahd_cmd_internal, end)
-	  > offsetof(struct scsi_cmnd, host_scribble)) {
-		printf("ahd_linux_detect: SCSI data structures changed.\n");
-		printf("ahd_linux_detect: Unable to attach\n");
-		return (0);
-	}
-#ifdef MODULE
-	/*
-	 * If we've been passed any parameters, process them now.
-	 */
-	if (aic79xx)
-		aic79xx_setup(aic79xx);
-	if (dummy_buffer[0] != 'P')
-		printk(KERN_WARNING
-"aic79xx: Please read the file /usr/src/linux/drivers/scsi/README.aic79xx\n"
-"aic79xx: to see the proper way to specify options to the aic79xx module\n"
-"aic79xx: Specifically, don't use any commas when passing arguments to\n"
-"aic79xx: insmod or else it might trash certain memory areas.\n");
-#endif
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
-	template->proc_name = "aic79xx";
-#else
-	template->proc_dir = &proc_scsi_aic79xx;
-#endif
-
-	/*
-	 * Initialize our softc list lock prior to
-	 * probing for any adapters.
-	 */
-	ahd_list_lockinit();
-
-#ifdef CONFIG_PCI
-	ahd_linux_pci_probe(template);
-#endif
-
-	/*
-	 * Register with the SCSI layer all
-	 * controllers we've found.
-	 */
-	found = 0;
-	TAILQ_FOREACH(ahd, &ahd_tailq, links) {
-
-		if (ahd_linux_register_host(ahd, template) == 0)
-			found++;
-	}
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	spin_lock_irq(&io_request_lock);
-#endif
-	aic79xx_detect_complete++;
-	return (found);
-}
-
-/*
- * Free the passed in Scsi_Host memory structures prior to unloading the
- * module.
- */
-static int
-ahd_linux_release(struct Scsi_Host * host)
-{
-	struct ahd_softc *ahd;
-	u_long l;
-
-	ahd_list_lock(&l);
-	if (host != NULL) {
-
-		/*
-		 * We should be able to just perform
-		 * the free directly, but check our
-		 * list for extra sanity.
-		 */
-		ahd = ahd_find_softc(*(struct ahd_softc **)host->hostdata);
-		if (ahd != NULL) {
-			u_long s;
-
-			ahd_lock(ahd, &s);
-			ahd_intr_enable(ahd, FALSE);
-			ahd_unlock(ahd, &s);
-			ahd_free(ahd);
-		}
-	}
-	ahd_list_unlock(&l);
-	return (0);
-}
-
-/*
- * Return a string describing the driver.
- */
-static const char *
-ahd_linux_info(struct Scsi_Host *host)
-{
-	static char buffer[512];
-	char	ahd_info[256];
-	char   *bp;
-	struct ahd_softc *ahd;
-
-	bp = &buffer[0];
-	ahd = *(struct ahd_softc **)host->hostdata;
-	memset(bp, 0, sizeof(buffer));
-	strcpy(bp, "Adaptec AIC79XX PCI-X SCSI HBA DRIVER, Rev ");
-	strcat(bp, AIC79XX_DRIVER_VERSION);
-	strcat(bp, "\n");
-	strcat(bp, "        <");
-	strcat(bp, ahd->description);
-	strcat(bp, ">\n");
-	strcat(bp, "        ");
-	ahd_controller_info(ahd, ahd_info);
-	strcat(bp, ahd_info);
-	strcat(bp, "\n");
-
-	return (bp);
-}
-
-/*
- * Queue an SCB to the controller.
- */
-static int
-ahd_linux_queue(Scsi_Cmnd * cmd, void (*scsi_done) (Scsi_Cmnd *))
-{
-	struct	 ahd_softc *ahd;
-	struct	 ahd_linux_device *dev;
-	u_long	 flags;
-
-	ahd = *(struct ahd_softc **)cmd->device->host->hostdata;
-
-	/*
-	 * Save the callback on completion function.
-	 */
-	cmd->scsi_done = scsi_done;
-
-	ahd_midlayer_entrypoint_lock(ahd, &flags);
-
-	/*
-	 * Close the race of a command that was in the process of
-	 * being queued to us just as our simq was frozen.  Let
-	 * DV commands through so long as we are only frozen to
-	 * perform DV.
-	 */
-	if (ahd->platform_data->qfrozen != 0
-	 && AHD_DV_CMD(cmd) == 0) {
-
-		ahd_cmd_set_transaction_status(cmd, CAM_REQUEUE_REQ);
-		ahd_linux_queue_cmd_complete(ahd, cmd);
-		ahd_schedule_completeq(ahd, NULL);
-		ahd_midlayer_entrypoint_unlock(ahd, &flags);
-		return (0);
-	}
-	dev = ahd_linux_get_device(ahd, cmd->device->channel,
-				   cmd->device->id, cmd->device->lun,
-				   /*alloc*/TRUE);
-	if (dev == NULL) {
-		ahd_midlayer_entrypoint_unlock(ahd, &flags);
-		printf("aic79xx_linux_queue: Unable to allocate device!\n");
-		return (-ENOMEM);
-	}
-	if (cmd->cmd_len > MAX_CDB_LEN)
-		return (-EINVAL);
-	cmd->result = CAM_REQ_INPROG << 16;
-	TAILQ_INSERT_TAIL(&dev->busyq, (struct ahd_cmd *)cmd, acmd_links.tqe);
-	if ((dev->flags & AHD_DEV_ON_RUN_LIST) == 0) {
-		TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq, dev, links);
-		dev->flags |= AHD_DEV_ON_RUN_LIST;
-		ahd_linux_run_device_queues(ahd);
-	}
-	ahd_midlayer_entrypoint_unlock(ahd, &flags);
-	return (0);
-}
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-static int
-ahd_linux_slave_alloc(Scsi_Device *device)
-{
-	struct	ahd_softc *ahd;
-
-	ahd = *((struct ahd_softc **)device->host->hostdata);
-	if (bootverbose)
-		printf("%s: Slave Alloc %d\n", ahd_name(ahd), device->id);
-	return (0);
-}
-
-static int
-ahd_linux_slave_configure(Scsi_Device *device)
-{
-	struct	ahd_softc *ahd;
-	struct	ahd_linux_device *dev;
-	u_long	flags;
-
-	ahd = *((struct ahd_softc **)device->host->hostdata);
-	if (bootverbose)
-		printf("%s: Slave Configure %d\n", ahd_name(ahd), device->id);
-	ahd_midlayer_entrypoint_lock(ahd, &flags);
-	/*
-	 * Since Linux has attached to the device, configure
-	 * it so we don't free and allocate the device
-	 * structure on every command.
-	 */
-	dev = ahd_linux_get_device(ahd, device->channel,
-				   device->id, device->lun,
-				   /*alloc*/TRUE);
-	if (dev != NULL) {
-		dev->flags &= ~AHD_DEV_UNCONFIGURED;
-		dev->flags |= AHD_DEV_SLAVE_CONFIGURED;
-		dev->scsi_device = device;
-		ahd_linux_device_queue_depth(ahd, dev);
-	}
-	ahd_midlayer_entrypoint_unlock(ahd, &flags);
-	return (0);
-}
-
-static void
-ahd_linux_slave_destroy(Scsi_Device *device)
-{
-	struct	ahd_softc *ahd;
-	struct	ahd_linux_device *dev;
-	u_long	flags;
-
-	ahd = *((struct ahd_softc **)device->host->hostdata);
-	if (bootverbose)
-		printf("%s: Slave Destroy %d\n", ahd_name(ahd), device->id);
-	ahd_midlayer_entrypoint_lock(ahd, &flags);
-	dev = ahd_linux_get_device(ahd, device->channel,
-				   device->id, device->lun,
-					   /*alloc*/FALSE);
-
-	/*
-	 * Filter out "silly" deletions of real devices by only
-	 * deleting devices that have had slave_configure()
-	 * called on them.  All other devices that have not
-	 * been configured will automatically be deleted by
-	 * the refcounting process.
-	 */
-	if (dev != NULL
-	 && (dev->flags & AHD_DEV_SLAVE_CONFIGURED) != 0) {
-		dev->flags |= AHD_DEV_UNCONFIGURED;
-		if (TAILQ_EMPTY(&dev->busyq)
-		 && dev->active == 0)
-			ahd_linux_free_device(ahd, dev);
-	}
-	ahd_midlayer_entrypoint_unlock(ahd, &flags);
-}
-#else
-/*
- * Sets the queue depth for each SCSI device hanging
- * off the input host adapter.
- */
-static void
-ahd_linux_select_queue_depth(struct Scsi_Host * host,
-			     Scsi_Device * scsi_devs)
-{
-	Scsi_Device *device;
-	struct	ahd_softc *ahd;
-	u_long	flags;
-	int	scbnum;
-
-	ahd = *((struct ahd_softc **)host->hostdata);
-	ahd_midlayer_entrypoint_lock(ahd, &flags);
-	scbnum = 0;
-	for (device = scsi_devs; device != NULL; device = device->next) {
-
-		if (device->host == host) {
-			struct	 ahd_linux_device *dev;
-
-			/*
-			 * Since Linux has attached to the device, configure
-			 * it so we don't free and allocate the device
-			 * structure on every command.
-			 */
-			dev = ahd_linux_get_device(ahd, device->channel,
-						   device->id, device->lun,
-						   /*alloc*/TRUE);
-			if (dev != NULL) {
-				dev->flags &= ~AHD_DEV_UNCONFIGURED;
-				dev->scsi_device = device;
-				ahd_linux_device_queue_depth(ahd, dev);
-				device->queue_depth = dev->openings
-						    + dev->active;
-				if ((dev->flags & (AHD_DEV_Q_BASIC
-						| AHD_DEV_Q_TAGGED)) == 0) {
-					/*
-					 * We allow the OS to queue 2 untagged
-					 * transactions to us at any time even
-					 * though we can only execute them
-					 * serially on the controller/device.
-					 * This should remove some latency.
-					 */
-					device->queue_depth = 2;
-				}
-			}
-		}
-	}
-	ahd_midlayer_entrypoint_unlock(ahd, &flags);
-}
-#endif
-
-/*
- * Return the disk geometry for the given SCSI device.
- */
-static int
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-ahd_linux_biosparam(struct scsi_device *sdev, struct block_device *bdev,
-		    sector_t capacity, int geom[])
-{
-	uint8_t *bh;
-#else
-ahd_linux_biosparam(Disk *disk, kdev_t dev, int geom[])
-{
-	struct	scsi_device *sdev = disk->device;
-	u_long	capacity = disk->capacity;
-	struct	buffer_head *bh;
-#endif
-	int	 heads;
-	int	 sectors;
-	int	 cylinders;
-	int	 ret;
-	int	 extended;
-	struct	 ahd_softc *ahd;
-
-	ahd = *((struct ahd_softc **)sdev->host->hostdata);
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-	bh = scsi_bios_ptable(bdev);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,17)
-	bh = bread(MKDEV(MAJOR(dev), MINOR(dev) & ~0xf), 0, block_size(dev));
-#else
-	bh = bread(MKDEV(MAJOR(dev), MINOR(dev) & ~0xf), 0, 1024);
-#endif
-
-	if (bh) {
-		ret = scsi_partsize(bh, capacity,
-				    &geom[2], &geom[0], &geom[1]);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-		kfree(bh);
-#else
-		brelse(bh);
-#endif
-		if (ret != -1)
-			return (ret);
-	}
-	heads = 64;
-	sectors = 32;
-	cylinders = aic_sector_div(capacity, heads, sectors);
-
-	if (aic79xx_extended != 0)
-		extended = 1;
-	else
-		extended = (ahd->flags & AHD_EXTENDED_TRANS_A) != 0;
-	if (extended && cylinders >= 1024) {
-		heads = 255;
-		sectors = 63;
-		cylinders = aic_sector_div(capacity, heads, sectors);
-	}
-	geom[0] = heads;
-	geom[1] = sectors;
-	geom[2] = cylinders;
-	return (0);
-}
-
-/*
- * Abort the current SCSI command(s).
- */
-static int
-ahd_linux_abort(Scsi_Cmnd *cmd)
-{
-	struct ahd_softc *ahd;
-	struct ahd_cmd *acmd;
-	struct ahd_cmd *list_acmd;
-	struct ahd_linux_device *dev;
-	struct scb *pending_scb;
-	u_long s;
-	u_int  saved_scbptr;
-	u_int  active_scbptr;
-	u_int  last_phase;
-	int    retval;
-	int    paused;
-	int    wait;
-	int    disconnected;
-	ahd_mode_state saved_modes;
-
-	pending_scb = NULL;
-	paused = FALSE;
-	wait = FALSE;
-	ahd = *(struct ahd_softc **)cmd->device->host->hostdata;
-	acmd = (struct ahd_cmd *)cmd;
-
-	printf("%s:%d:%d:%d: Attempting to abort cmd %p\n",
-	       ahd_name(ahd), cmd->device->channel, cmd->device->id,
-	       cmd->device->lun, cmd);
-
-	/*
-	 * In all versions of Linux, we have to work around
-	 * a major flaw in how the mid-layer is locked down
-	 * if we are to sleep successfully in our error handler
-	 * while allowing our interrupt handler to run.  Since
-	 * the midlayer acquires either the io_request_lock or
-	 * our lock prior to calling us, we must use the
-	 * spin_unlock_irq() method for unlocking our lock.
-	 * This will force interrupts to be enabled on the
-	 * current CPU.  Since the EH thread should not have
-	 * been running with CPU interrupts disabled other than
-	 * by acquiring either the io_request_lock or our own
-	 * lock, this *should* be safe.
-	 */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	spin_unlock_irq(&io_request_lock);
-#endif
-	ahd_midlayer_entrypoint_lock(ahd, &s);
-
-	/*
-	 * First determine if we currently own this command.
-	 * Start by searching the device queue.  If not found
-	 * there, check the pending_scb list.  If not found
-	 * at all, and the system wanted us to just abort the
-	 * command return success.
-	 */
-	dev = ahd_linux_get_device(ahd, cmd->device->channel,
-				   cmd->device->id, cmd->device->lun,
-				   /*alloc*/FALSE);
-
-	if (dev == NULL) {
-		/*
-		 * No target device for this command exists,
-		 * so we must not still own the command.
-		 */
-		printf("%s:%d:%d:%d: Is not an active device\n",
-		       ahd_name(ahd), cmd->device->channel, cmd->device->id,
-		       cmd->device->lun);
-		retval = SUCCESS;
-		goto no_cmd;
-	}
-
-	TAILQ_FOREACH(list_acmd, &dev->busyq, acmd_links.tqe) {
-		if (list_acmd == acmd)
-			break;
-	}
-
-	if (list_acmd != NULL) {
-		printf("%s:%d:%d:%d: Command found on device queue\n",
-		       ahd_name(ahd), cmd->device->channel, cmd->device->id,
-		       cmd->device->lun);
-		TAILQ_REMOVE(&dev->busyq, list_acmd, acmd_links.tqe);
-		cmd->result = DID_ABORT << 16;
-		ahd_linux_queue_cmd_complete(ahd, cmd);
-		retval = SUCCESS;
-		goto done;
-	}
-
-	/*
-	 * See if we can find a matching cmd in the pending list.
-	 */
-	LIST_FOREACH(pending_scb, &ahd->pending_scbs, pending_links) {
-		if (pending_scb->io_ctx == cmd)
-			break;
-	}
-
-	if (pending_scb == NULL) {
-		printf("%s:%d:%d:%d: Command not found\n",
-		       ahd_name(ahd), cmd->device->channel, cmd->device->id,
-		       cmd->device->lun);
-		goto no_cmd;
-	}
-
-	if ((pending_scb->flags & SCB_RECOVERY_SCB) != 0) {
-		/*
-		 * We can't queue two recovery actions using the same SCB
-		 */
-		retval = FAILED;
-		goto  done;
-	}
-
-	/*
-	 * Ensure that the card doesn't do anything
-	 * behind our back.  Also make sure that we
-	 * didn't "just" miss an interrupt that would
-	 * affect this cmd.
-	 */
-	ahd_pause_and_flushwork(ahd);
-	paused = TRUE;
-
-	if ((pending_scb->flags & SCB_ACTIVE) == 0) {
-		printf("%s:%d:%d:%d: Command already completed\n",
-		       ahd_name(ahd), cmd->device->channel, cmd->device->id,
-		       cmd->device->lun);
-		goto no_cmd;
-	}
-
-	ahd_dump_card_state(ahd);
-
-	disconnected = TRUE;
-	if (ahd_search_qinfifo(ahd, cmd->device->id, cmd->device->channel + 'A',
-			       cmd->device->lun, pending_scb->hscb->tag,
-			       ROLE_INITIATOR, CAM_REQ_ABORTED,
-			       SEARCH_COMPLETE) > 0) {
-		printf("%s:%d:%d:%d: Cmd aborted from QINFIFO\n",
-		       ahd_name(ahd), cmd->device->channel, cmd->device->id,
-				cmd->device->lun);
-		retval = SUCCESS;
-		goto done;
-	}
-
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	last_phase = ahd_inb(ahd, LASTPHASE);
-	saved_scbptr = ahd_get_scbptr(ahd);
-	active_scbptr = saved_scbptr;
-	if (disconnected && (ahd_inb(ahd, SEQ_FLAGS) & NOT_IDENTIFIED) == 0) {
-		struct scb *bus_scb;
-
-		bus_scb = ahd_lookup_scb(ahd, active_scbptr);
-		if (bus_scb == pending_scb)
-			disconnected = FALSE;
-	}
-
-	/*
-	 * At this point, pending_scb is the scb associated with the
-	 * passed in command.  That command is currently active on the
-	 * bus or is in the disconnected state.
-	 */
-	if (last_phase != P_BUSFREE
-	 && pending_scb->hscb->tag == active_scbptr) {
-
-		/*
-		 * We're active on the bus, so assert ATN
-		 * and hope that the target responds.
-		 */
-		pending_scb = ahd_lookup_scb(ahd, active_scbptr);
-		pending_scb->flags |= SCB_RECOVERY_SCB|SCB_ABORT;
-		ahd_outb(ahd, MSG_OUT, HOST_MSG);
-		ahd_outb(ahd, SCSISIGO, last_phase|ATNO);
-		printf("%s:%d:%d:%d: Device is active, asserting ATN\n",
-		       ahd_name(ahd), cmd->device->channel,
-		       cmd->device->id, cmd->device->lun);
-		wait = TRUE;
-	} else if (disconnected) {
-
-		/*
-		 * Actually re-queue this SCB in an attempt
-		 * to select the device before it reconnects.
-		 */
-		pending_scb->flags |= SCB_RECOVERY_SCB|SCB_ABORT;
-		ahd_set_scbptr(ahd, pending_scb->hscb->tag);
-		pending_scb->hscb->cdb_len = 0;
-		pending_scb->hscb->task_attribute = 0;
-		pending_scb->hscb->task_management = SIU_TASKMGMT_ABORT_TASK;
-
-		if ((pending_scb->flags & SCB_PACKETIZED) != 0) {
-			/*
-			 * Mark the SCB has having an outstanding
-			 * task management function.  Should the command
-			 * complete normally before the task management
-			 * function can be sent, the host will be notified
-			 * to abort our requeued SCB.
-			 */
-			ahd_outb(ahd, SCB_TASK_MANAGEMENT,
-				 pending_scb->hscb->task_management);
-		} else {
-			/*
-			 * If non-packetized, set the MK_MESSAGE control
-			 * bit indicating that we desire to send a message.
-			 * We also set the disconnected flag since there is
-			 * no guarantee that our SCB control byte matches
-			 * the version on the card.  We don't want the
-			 * sequencer to abort the command thinking an
-			 * unsolicited reselection occurred.
-			 */
-			pending_scb->hscb->control |= MK_MESSAGE|DISCONNECTED;
-
-			/*
-			 * The sequencer will never re-reference the
-			 * in-core SCB.  To make sure we are notified
-			 * during reslection, set the MK_MESSAGE flag in
-			 * the card's copy of the SCB.
-			 */
-			ahd_outb(ahd, SCB_CONTROL,
-				 ahd_inb(ahd, SCB_CONTROL)|MK_MESSAGE);
-		}
-
-		/*
-		 * Clear out any entries in the QINFIFO first
-		 * so we are the next SCB for this target
-		 * to run.
-		 */
-		ahd_search_qinfifo(ahd, cmd->device->id,
-				   cmd->device->channel + 'A', cmd->device->lun,
-				   SCB_LIST_NULL, ROLE_INITIATOR,
-				   CAM_REQUEUE_REQ, SEARCH_COMPLETE);
-		ahd_qinfifo_requeue_tail(ahd, pending_scb);
-		ahd_set_scbptr(ahd, saved_scbptr);
-		ahd_print_path(ahd, pending_scb);
-		printf("Device is disconnected, re-queuing SCB\n");
-		wait = TRUE;
-	} else {
-		printf("%s:%d:%d:%d: Unable to deliver message\n",
-		       ahd_name(ahd), cmd->device->channel,
-		       cmd->device->id, cmd->device->lun);
-		retval = FAILED;
-		goto done;
-	}
-
-no_cmd:
-	/*
-	 * Our assumption is that if we don't have the command, no
-	 * recovery action was required, so we return success.  Again,
-	 * the semantics of the mid-layer recovery engine are not
-	 * well defined, so this may change in time.
-	 */
-	retval = SUCCESS;
-done:
-	if (paused)
-		ahd_unpause(ahd);
-	if (wait) {
-		struct timer_list timer;
-		int ret;
-
-		ahd->platform_data->flags |= AHD_UP_EH_SEMAPHORE;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-		ahd_unlock(ahd, &s);
-#else
-		spin_unlock_irq(ahd->platform_data->host->host_lock);
-#endif
-		init_timer(&timer);
-		timer.data = (u_long)ahd;
-		timer.expires = jiffies + (5 * HZ);
-		timer.function = ahd_linux_sem_timeout;
-		add_timer(&timer);
-		printf("Recovery code sleeping\n");
-		down(&ahd->platform_data->eh_sem);
-		printf("Recovery code awake\n");
-        	ret = del_timer(&timer);
-		if (ret == 0) {
-			printf("Timer Expired\n");
-			retval = FAILED;
-		}
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-		ahd_lock(ahd, &s);
-#else
-		spin_lock_irq(ahd->platform_data->host->host_lock);
-#endif
-	}
-	acmd = TAILQ_FIRST(&ahd->platform_data->completeq);
-	TAILQ_INIT(&ahd->platform_data->completeq);
-	ahd_midlayer_entrypoint_unlock(ahd, &s);
-	if (acmd != NULL) {
-		acmd = ahd_linux_run_complete_queue(ahd, acmd);
-		if (acmd != NULL) {
-			ahd_midlayer_entrypoint_lock(ahd, &s);
-			ahd_schedule_completeq(ahd, acmd);
-			ahd_midlayer_entrypoint_unlock(ahd, &s);
-		}
-	}
-	ahd_schedule_runq(ahd);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	spin_lock_irq(&io_request_lock);
-#endif
-	return (retval);
-}
-
-
-static void
-ahd_linux_dev_reset_complete(Scsi_Cmnd *cmd)
-{
-	free(cmd, M_DEVBUF);
-}
-
-/*
- * Attempt to send a target reset message to the device that timed out.
- */
-static int
-ahd_linux_dev_reset(Scsi_Cmnd *cmd)
-{
-	struct	ahd_softc *ahd;
-	struct	scsi_cmnd *recovery_cmd;
-	struct	ahd_linux_device *dev;
-	struct	ahd_initiator_tinfo *tinfo;
-	struct	ahd_tmode_tstate *tstate;
-	struct	scb *scb;
-	struct	hardware_scb *hscb;
-	struct	ahd_cmd *acmd;
-	u_long	s;
-	struct	timer_list timer;
-	int	retval;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	spin_unlock_irq(&io_request_lock);
-#endif
-	ahd = *(struct ahd_softc **)cmd->device->host->hostdata;
-	recovery_cmd = malloc(sizeof(struct scsi_cmnd), M_DEVBUF, M_WAITOK);
-	memset(recovery_cmd, 0, sizeof(struct scsi_cmnd));
-	recovery_cmd->device = cmd->device;
-	recovery_cmd->scsi_done = ahd_linux_dev_reset_complete;
-#if AHD_DEBUG
-	if ((ahd_debug & AHD_SHOW_RECOVERY) != 0)
-		printf("%s:%d:%d:%d: Device reset called for cmd %p\n",
-		       ahd_name(ahd), cmd->device->channel, cmd->device->id,
-		       cmd->device->lun, cmd);
-#endif
-	ahd_midlayer_entrypoint_lock(ahd, &s);
-
-	dev = ahd_linux_get_device(ahd, cmd->device->channel, cmd->device->id,
-				   cmd->device->lun, /*alloc*/FALSE);
-	if (dev == NULL) {
-		ahd_midlayer_entrypoint_unlock(ahd, &s);
-		return (FAILED);
-	}
-	if ((scb = ahd_get_scb(ahd, AHD_NEVER_COL_IDX)) == NULL) {
-		ahd_midlayer_entrypoint_unlock(ahd, &s);
-		return (FAILED);
-	}
-	tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
-				    cmd->device->id, &tstate);
-	recovery_cmd->result = CAM_REQ_INPROG << 16;
-	recovery_cmd->host_scribble = (char *)scb;
-	scb->io_ctx = recovery_cmd;
-	scb->platform_data->dev = dev;
-	scb->sg_count = 0;
-	ahd_set_residual(scb, 0);
-	ahd_set_sense_residual(scb, 0);
-	hscb = scb->hscb;
-	hscb->control = 0;
-	hscb->scsiid = BUILD_SCSIID(ahd, cmd);
-	hscb->lun = cmd->lun;
-	hscb->cdb_len = 0;
-	hscb->task_management = SIU_TASKMGMT_LUN_RESET;
-	scb->flags |= SCB_DEVICE_RESET|SCB_RECOVERY_SCB|SCB_ACTIVE;
-	if ((tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
-		scb->flags |= SCB_PACKETIZED;
-	} else {
-		hscb->control |= MK_MESSAGE;
-	}
-	dev->openings--;
-	dev->active++;
-	dev->commands_issued++;
-	LIST_INSERT_HEAD(&ahd->pending_scbs, scb, pending_links);
-	ahd_queue_scb(ahd, scb);
-
-	ahd->platform_data->flags |= AHD_UP_EH_SEMAPHORE;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	ahd_unlock(ahd, &s);
-#else
-	spin_unlock_irq(ahd->platform_data->host->host_lock);
-#endif
-	init_timer(&timer);
-	timer.data = (u_long)ahd;
-	timer.expires = jiffies + (5 * HZ);
-	timer.function = ahd_linux_sem_timeout;
-	add_timer(&timer);
-	printf("Recovery code sleeping\n");
-	down(&ahd->platform_data->eh_sem);
-	printf("Recovery code awake\n");
-	retval = SUCCESS;
-	if (del_timer(&timer) == 0) {
-		printf("Timer Expired\n");
-		retval = FAILED;
-	}
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	ahd_lock(ahd, &s);
-#else
-	spin_lock_irq(ahd->platform_data->host->host_lock);
-#endif
-	acmd = TAILQ_FIRST(&ahd->platform_data->completeq);
-	TAILQ_INIT(&ahd->platform_data->completeq);
-	ahd_midlayer_entrypoint_unlock(ahd, &s);
-	if (acmd != NULL) {
-		acmd = ahd_linux_run_complete_queue(ahd, acmd);
-		if (acmd != NULL) {
-			ahd_midlayer_entrypoint_lock(ahd, &s);
-			ahd_schedule_completeq(ahd, acmd);
-			ahd_midlayer_entrypoint_unlock(ahd, &s);
-		}
-	}
-	ahd_schedule_runq(ahd);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	spin_lock_irq(&io_request_lock);
-#endif
-	printf("%s: Device reset returning 0x%x\n", ahd_name(ahd), retval);
-	return (retval);
-}
-
-/*
- * Reset the SCSI bus.
- */
-static int
-ahd_linux_bus_reset(Scsi_Cmnd *cmd)
-{
-	struct ahd_softc *ahd;
-	struct ahd_cmd *acmd;
-	u_long s;
-	int    found;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	spin_unlock_irq(&io_request_lock);
-#endif
-	ahd = *(struct ahd_softc **)cmd->device->host->hostdata;
-#ifdef AHD_DEBUG
-	if ((ahd_debug & AHD_SHOW_RECOVERY) != 0)
-		printf("%s: Bus reset called for cmd %p\n",
-		       ahd_name(ahd), cmd);
-#endif
-	ahd_midlayer_entrypoint_lock(ahd, &s);
-	found = ahd_reset_channel(ahd, cmd->channel + 'A',
-				  /*initiate reset*/TRUE);
-	acmd = TAILQ_FIRST(&ahd->platform_data->completeq);
-	TAILQ_INIT(&ahd->platform_data->completeq);
-	ahd_midlayer_entrypoint_unlock(ahd, &s);
-	if (bootverbose)
-		printf("%s: SCSI bus reset delivered. "
-		       "%d SCBs aborted.\n", ahd_name(ahd), found);
-
-	if (acmd != NULL) {
-		acmd = ahd_linux_run_complete_queue(ahd, acmd);
-		if (acmd != NULL) {
-			ahd_midlayer_entrypoint_lock(ahd, &s);
-			ahd_schedule_completeq(ahd, acmd);
-			ahd_midlayer_entrypoint_unlock(ahd, &s);
-		}
-	}
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	spin_lock_irq(&io_request_lock);
-#endif
-	return (SUCCESS);
-}
-
-Scsi_Host_Template aic79xx_driver_template = {
-	.proc_info		= ahd_linux_proc_info,
-	.detect			= ahd_linux_detect,
-	.release		= ahd_linux_release,
-	.info			= ahd_linux_info,
-	.queuecommand		= ahd_linux_queue,
-	.eh_abort_handler	= ahd_linux_abort,
-	.eh_device_reset_handler = ahd_linux_dev_reset,
-	.eh_bus_reset_handler	= ahd_linux_bus_reset,
-#if defined(__i386__)
-	.bios_param		= ahd_linux_biosparam,
-#endif
-	.can_queue		= AHD_MAX_QUEUE,
-	.this_id		= -1,
-	.sg_tablesize		= AHD_NSEG,
-	.cmd_per_lun		= 2,
-	.use_clustering		= ENABLE_CLUSTERING,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,7)
-	/*
-	 * We can only map 16MB per-SG
-	 * so create a sector limit of
-	 * "16MB" in 2K sectors.
-	 */
-	.max_sectors		= 8192,
-#endif
-#if defined CONFIG_HIGHIO || LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,18)
-/* Assume RedHat Distribution with its different HIGHIO conventions. */
-	.can_dma_32		= 1,
-	.single_sg_okay		= 1,
-#else
-	.highmem_io		= 1,
-#endif
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-	.name			= "aic79xx",
-	.slave_alloc		= ahd_linux_slave_alloc,
-	.slave_configure	= ahd_linux_slave_configure,
-	.slave_destroy		= ahd_linux_slave_destroy,
-#else
-	.select_queue_depths	= ahd_linux_select_queue_depth,
-	.use_new_eh_code	= 1,
-#endif
-};
-
-#define driver_template aic79xx_driver_template
-#include "scsi_module.c"
-/**************************** Tasklet Handler *********************************/
-
-static void
-ahd_runq_tasklet(unsigned long data)
-{
-	struct ahd_softc* ahd;
-	struct ahd_linux_device *dev;
-	u_long flags;
-
-	ahd = (struct ahd_softc *)data;
-	ahd_lock(ahd, &flags);
-	while ((dev = ahd_linux_next_device_to_run(ahd)) != NULL) {
-	
-		TAILQ_REMOVE(&ahd->platform_data->device_runq, dev, links);
-		dev->flags &= ~AHD_DEV_ON_RUN_LIST;
-		ahd_linux_check_device_queue(ahd, dev);
-		/* Yeild to our interrupt handler */
-		ahd_unlock(ahd, &flags);
-		ahd_lock(ahd, &flags);
-	}
-	ahd_unlock(ahd, &flags);
-}
-
-/************************ Shutdown/halt/reboot hook ***************************/
-#include <linux/notifier.h>
-#include <linux/reboot.h>
-
-static struct notifier_block ahd_linux_notifier = {
-	ahd_linux_halt, NULL, 0
-};
-
-static int ahd_linux_halt(struct notifier_block *nb, u_long event, void *buf)
-{
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	struct ahd_softc *ahd;
-
-	/*
-	 * In 2.5.X, this is called prior to the filesystems
-	 * being synced and the SCSI layer being properly
-	 * shutdown.  A different API is required there,
-	 * but the device hooks for this don't quite look
-	 * right.
-	 */
-	if (event == SYS_DOWN || event == SYS_HALT) {
-		TAILQ_FOREACH(ahd, &ahd_tailq, links) {
-			ahd_shutdown(ahd);
-		}
-	}
-#endif
-	return (NOTIFY_OK);
-}
-
-/******************************** Bus DMA *************************************/
-int
-ahd_dma_tag_create(struct ahd_softc *ahd, bus_dma_tag_t parent,
-		   bus_size_t alignment, bus_size_t boundary,
-		   bus_addr_t lowaddr, bus_addr_t highaddr,
-		   bus_dma_filter_t *filter, void *filterarg,
-		   bus_size_t maxsize, int nsegments,
-		   bus_size_t maxsegsz, int flags, bus_dma_tag_t *ret_tag)
-{
-	bus_dma_tag_t dmat;
-
-	dmat = malloc(sizeof(*dmat), M_DEVBUF, M_NOWAIT);
-	if (dmat == NULL)
-		return (ENOMEM);
-
-	/*
-	 * Linux is very simplistic about DMA memory.  For now don't
-	 * maintain all specification information.  Once Linux supplies
-	 * better facilities for doing these operations, or the
-	 * needs of this particular driver change, we might need to do
-	 * more here.
-	 */
-	dmat->alignment = alignment;
-	dmat->boundary = boundary;
-	dmat->maxsize = maxsize;
-	*ret_tag = dmat;
-	return (0);
-}
-
-void
-ahd_dma_tag_destroy(struct ahd_softc *ahd, bus_dma_tag_t dmat)
-{
-	free(dmat, M_DEVBUF);
-}
-
-int
-ahd_dmamem_alloc(struct ahd_softc *ahd, bus_dma_tag_t dmat, void** vaddr,
-		 int flags, bus_dmamap_t *mapp)
-{
-	bus_dmamap_t map;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	map = malloc(sizeof(*map), M_DEVBUF, M_NOWAIT);
-	if (map == NULL)
-		return (ENOMEM);
-	/*
-	 * Although we can dma data above 4GB, our
-	 * "consistent" memory is below 4GB for
-	 * space efficiency reasons (only need a 4byte
-	 * address).  For this reason, we have to reset
-	 * our dma mask when doing allocations.
-	 */
-	if (ahd->dev_softc != NULL)
-		ahd_pci_set_dma_mask(ahd->dev_softc, 0xFFFFFFFF);
-	*vaddr = pci_alloc_consistent(ahd->dev_softc,
-				      dmat->maxsize, &map->bus_addr);
-	if (ahd->dev_softc != NULL)
-		ahd_pci_set_dma_mask(ahd->dev_softc,
-				     ahd->platform_data->hw_dma_mask);
-#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0) */
-	/*
-	 * At least in 2.2.14, malloc is a slab allocator so all
-	 * allocations are aligned.  We assume for these kernel versions
-	 * that all allocations will be bellow 4Gig, physically contiguous,
-	 * and accessable via DMA by the controller.
-	 */
-	map = NULL; /* No additional information to store */
-	*vaddr = malloc(dmat->maxsize, M_DEVBUF, M_NOWAIT);
-#endif
-	if (*vaddr == NULL)
-		return (ENOMEM);
-	*mapp = map;
-	return(0);
-}
-
-void
-ahd_dmamem_free(struct ahd_softc *ahd, bus_dma_tag_t dmat,
-		void* vaddr, bus_dmamap_t map)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	pci_free_consistent(ahd->dev_softc, dmat->maxsize,
-			    vaddr, map->bus_addr);
-#else
-	free(vaddr, M_DEVBUF);
-#endif
-}
-
-int
-ahd_dmamap_load(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map,
-		void *buf, bus_size_t buflen, bus_dmamap_callback_t *cb,
-		void *cb_arg, int flags)
-{
-	/*
-	 * Assume for now that this will only be used during
-	 * initialization and not for per-transaction buffer mapping.
-	 */
-	bus_dma_segment_t stack_sg;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	stack_sg.ds_addr = map->bus_addr;
-#else
-#define VIRT_TO_BUS(a) (uint32_t)virt_to_bus((void *)(a))
-	stack_sg.ds_addr = VIRT_TO_BUS(buf);
-#endif
-	stack_sg.ds_len = dmat->maxsize;
-	cb(cb_arg, &stack_sg, /*nseg*/1, /*error*/0);
-	return (0);
-}
-
-void
-ahd_dmamap_destroy(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map)
-{
-	/*
-	 * The map may is NULL in our < 2.3.X implementation.
-	 */
-	if (map != NULL)
-		free(map, M_DEVBUF);
-}
-
-int
-ahd_dmamap_unload(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map)
-{
-	/* Nothing to do */
-	return (0);
-}
-
-/********************* Platform Dependent Functions ***************************/
-int
-ahd_softc_comp(struct ahd_softc *lahd, struct ahd_softc *rahd)
-{
-	int	value;
-	char	primary_channel;
-
-	/*
-	 * Under Linux, cards are ordered as follows:
-	 *	1) PCI devices with BIOS enabled sorted by bus/slot/func.
-	 *	2) All remaining PCI devices sorted by bus/slot/func.
-	 */
-	value = (lahd->flags & AHD_BIOS_ENABLED)
-	      - (rahd->flags & AHD_BIOS_ENABLED);
-	if (value != 0)
-		/* Controllers with BIOS enabled have a *higher* priority */
-		return (-value);
-
-	/* Still equal.  Sort by bus/slot/func. */
-	if (aic79xx_reverse_scan != 0)
-		value = ahd_get_pci_bus(rahd->dev_softc)
-		      - ahd_get_pci_bus(lahd->dev_softc);
-	else
-		value = ahd_get_pci_bus(lahd->dev_softc)
-		      - ahd_get_pci_bus(rahd->dev_softc);
-	if (value != 0)
-		return (value);
-	if (aic79xx_reverse_scan != 0)
-		value = ahd_get_pci_slot(rahd->dev_softc)
-		      - ahd_get_pci_slot(lahd->dev_softc);
-	else
-		value = ahd_get_pci_slot(lahd->dev_softc)
-		      - ahd_get_pci_slot(rahd->dev_softc);
-	if (value != 0)
-		return (value);
-
-	/*
-	 * On multi-function devices, the user can choose
-	 * to have function 1 probed before function 0.
-	 * Give whichever channel is the primary channel
-	 * the lowest priority.
-	 */
-	primary_channel = (lahd->flags & AHD_PRIMARY_CHANNEL) + 'A';
-	value = 1;
-	if (lahd->channel == primary_channel)
-		value = -1;
-	return (value);
-}
-
-static void
-ahd_linux_setup_tag_info(char *p, char *end, char *s)
-{
-	char	*base;
-	char	*tok;
-	char	*tok_end;
-	char	*tok_end2;
-	int      i;
-	int      instance;
-	int	 targ;
-	int	 done;
-	char	 tok_list[] = {'.', ',', '{', '}', '\0'};
-
-	if (*p != ':')
-		return;
-
-	instance = -1;
-	targ = -1;
-	done = FALSE;
-	base = p;
-	/* Forward us just past the ':' */
-	tok = base + 1;
-	tok_end = strchr(tok, '\0');
-	if (tok_end < end)
-		*tok_end = ',';
-	while (!done) {
-		switch (*tok) {
-		case '{':
-			if (instance == -1)
-				instance = 0;
-			else if (targ == -1)
-				targ = 0;
-			tok++;
-			break;
-		case '}':
-			if (targ != -1)
-				targ = -1;
-			else if (instance != -1)
-				instance = -1;
-			tok++;
-			break;
-		case ',':
-		case '.':
-			if (instance == -1)
-				done = TRUE;
-			else if (targ >= 0)
-				targ++;
-			else if (instance >= 0)
-				instance++;
-			if ((targ >= AHD_NUM_TARGETS) ||
-			    (instance >= NUM_ELEMENTS(aic79xx_tag_info)))
-				done = TRUE;
-			tok++;
-			if (!done) {
-				base = tok;
-			}
-			break;
-		case '\0':
-			done = TRUE;
-			break;
-		default:
-			done = TRUE;
-			tok_end = strchr(tok, '\0');
-			for (i = 0; tok_list[i]; i++) {
-				tok_end2 = strchr(tok, tok_list[i]);
-				if ((tok_end2) && (tok_end2 < tok_end)) {
-					tok_end = tok_end2;
-					done = FALSE;
-				}
-			}
-			if ((instance >= 0) && (targ >= 0)
-			 && (instance < NUM_ELEMENTS(aic79xx_tag_info))
-			 && (targ < AHD_NUM_TARGETS)) {
-				aic79xx_tag_info[instance].tag_commands[targ] =
-				    simple_strtoul(tok, NULL, 0) & 0xff;
-			}
-			tok = tok_end;
-			break;
-		}
-	}
-	while ((p != base) && (p != NULL))
-		p = strsep(&s, ",.");
-}
-
-static void
-ahd_linux_setup_rd_strm_info(char *p, char *end, char *s)
-{
-	char	*base;
-	char	*tok;
-	char	*tok_end;
-	char	*tok_end2;
-	int      i;
-	int      instance;
-	int	 done;
-	char	 tok_list[] = {'.', ',', '{', '}', '\0'};
-
-	if (*p != ':')
-		return;
-
-	instance = -1;
-	done = FALSE;
-	base = p;
-	/* Forward us just past the ':' */
-	tok = base + 1;
-	tok_end = strchr(tok, '\0');
-	if (tok_end < end)
-		*tok_end = ',';
-	while (!done) {
-		switch (*tok) {
-		case '{':
-			if (instance == -1)
-				instance = 0;
-			tok++;
-			break;
-		case '}':
-			if (instance != -1)
-				instance = -1;
-			tok++;
-			break;
-		case ',':
-		case '.':
-			if (instance == -1)
-				done = TRUE;
-			else if (instance >= 0)
-				instance++;
-			if (instance >= NUM_ELEMENTS(aic79xx_rd_strm_info))
-				done = TRUE;
-			tok++;
-			if (!done) {
-				base = tok;
-			}
-			break;
-		case '\0':
-			done = TRUE;
-			break;
-		default:
-			done = TRUE;
-			tok_end = strchr(tok, '\0');
-			for (i = 0; tok_list[i]; i++) {
-				tok_end2 = strchr(tok, tok_list[i]);
-				if ((tok_end2) && (tok_end2 < tok_end)) {
-					tok_end = tok_end2;
-					done = FALSE;
-				}
-			}
-			if ((instance >= 0)
-			 && (instance < NUM_ELEMENTS(aic79xx_rd_strm_info))) {
-				aic79xx_rd_strm_info[instance] =
-				    simple_strtoul(tok, NULL, 0) & 0xffff;
-			}
-			tok = tok_end;
-			break;
-		}
-	}
-	while ((p != base) && (p != NULL))
-		p = strsep(&s, ",.");
-}
-
-static void
-ahd_linux_setup_dv(char *p, char *end, char *s)
-{
-	char	*base;
-	char	*tok;
-	char	*tok_end;
-	char	*tok_end2;
-	int      i;
-	int      instance;
-	int	 done;
-	char	 tok_list[] = {'.', ',', '{', '}', '\0'};
-
-	if (*p != ':')
-		return;
-
-	instance = -1;
-	done = FALSE;
-	base = p;
-	/* Forward us just past the ':' */
-	tok = base + 1;
-	tok_end = strchr(tok, '\0');
-	if (tok_end < end)
-		*tok_end = ',';
-	while (!done) {
-		switch (*tok) {
-		case '{':
-			if (instance == -1)
-				instance = 0;
-			tok++;
-			break;
-		case '}':
-			if (instance != -1)
-				instance = -1;
-			tok++;
-			break;
-		case ',':
-		case '.':
-			if (instance == -1)
-				done = TRUE;
-			else if (instance >= 0)
-				instance++;
-			if (instance >= NUM_ELEMENTS(aic79xx_dv_settings))
-				done = TRUE;
-			tok++;
-			if (!done) {
-				base = tok;
-			}
-			break;
-		case '\0':
-			done = TRUE;
-			break;
-		default:
-			done = TRUE;
-			tok_end = strchr(tok, '\0');
-			for (i = 0; tok_list[i]; i++) {
-				tok_end2 = strchr(tok, tok_list[i]);
-				if ((tok_end2) && (tok_end2 < tok_end)) {
-					tok_end = tok_end2;
-					done = FALSE;
-				}
-			}
-			if ((instance >= 0)
-			 && (instance < NUM_ELEMENTS(aic79xx_dv_settings))) {
-				aic79xx_dv_settings[instance] =
-				    simple_strtol(tok, NULL, 0);
-			}
-			tok = tok_end;
-			break;
-		}
-	}
-	while ((p != base) && (p != NULL))
-		p = strsep(&s, ",.");
-}
-
-static void
-ahd_linux_setup_iocell_info(char *p, char *end, char *s, int index)
-{
-	char	*base;
-	char	*tok;
-	char	*tok_end;
-	char	*tok_end2;
-	uint8_t	*iocell_info;
-	int      i;
-	int      instance;
-	int	 done;
-	char	 tok_list[] = {'.', ',', '{', '}', '\0'};
-
-	if (*p != ':')
-		return;
-
-	instance = -1;
-	done = FALSE;
-	base = p;
-	/* Forward us just past the ':' */
-	tok = base + 1;
-	tok_end = strchr(tok, '\0');
-	if (tok_end < end)
-		*tok_end = ',';
-	while (!done) {
-		switch (*tok) {
-		case '{':
-			if (instance == -1)
-				instance = 0;
-			tok++;
-			break;
-		case '}':
-			if (instance != -1)
-				instance = -1;
-			tok++;
-			break;
-		case ',':
-		case '.':
-			if (instance == -1)
-				done = TRUE;
-			else if (instance >= 0)
-				instance++;
-			if (instance >= NUM_ELEMENTS(aic79xx_iocell_info))
-				done = TRUE;
-			tok++;
-			if (!done) {
-				base = tok;
-			}
-			break;
-		case '\0':
-			done = TRUE;
-			break;
-		default:
-			done = TRUE;
-			tok_end = strchr(tok, '\0');
-			for (i = 0; tok_list[i]; i++) {
-				tok_end2 = strchr(tok, tok_list[i]);
-				if ((tok_end2) && (tok_end2 < tok_end)) {
-					tok_end = tok_end2;
-					done = FALSE;
-				}
-			}
-			if ((instance >= 0)
-			 && (instance < NUM_ELEMENTS(aic79xx_iocell_info))) {
-				iocell_info =
-				    (uint8_t*)&aic79xx_iocell_info[instance];
-				iocell_info[index] = 
-				    simple_strtoul(tok, NULL, 0) & 0xffff;
-			}
-			tok = tok_end;
-			break;
-		}
-	}
-	while ((p != base) && (p != NULL))
-		p = strsep(&s, ",.");
-}
-
-static void
-ahd_linux_setup_tag_info_global(char *p)
-{
-	int tags, i, j;
-
-	tags = simple_strtoul(p + 1, NULL, 0) & 0xff;
-	printf("Setting Global Tags= %d\n", tags);
-
-	for (i = 0; i < NUM_ELEMENTS(aic79xx_tag_info); i++) {
-		for (j = 0; j < AHD_NUM_TARGETS; j++) {
-			aic79xx_tag_info[i].tag_commands[j] = tags;
-		}
-	}
-}
-
-/*
- * Handle Linux boot parameters. This routine allows for assigning a value
- * to a parameter with a ':' between the parameter and the value.
- * ie. aic79xx=stpwlev:1,extended
- */
-static int
-aic79xx_setup(char *s)
-{
-	int	i, n;
-	char   *p;
-	char   *end;
-
-	static struct {
-		const char *name;
-		uint32_t *flag;
-	} options[] = {
-		{ "extended", &aic79xx_extended },
-		{ "no_reset", &aic79xx_no_reset },
-		{ "verbose", &aic79xx_verbose },
-		{ "allow_memio", &aic79xx_allow_memio},
-#ifdef AHD_DEBUG
-		{ "debug", &ahd_debug },
-#endif
-		{ "reverse_scan", &aic79xx_reverse_scan },
-		{ "periodic_otag", &aic79xx_periodic_otag },
-		{ "pci_parity", &aic79xx_pci_parity },
-		{ "seltime", &aic79xx_seltime },
-		{ "tag_info", NULL },
-		{ "global_tag_depth", NULL},
-		{ "rd_strm", NULL },
-		{ "dv", NULL },
-		{ "slewrate", NULL },
-		{ "precomp", NULL },
-		{ "amplitude", NULL },
-	};
-
-	end = strchr(s, '\0');
-
-	while ((p = strsep(&s, ",.")) != NULL) {
-		if (*p == '\0')
-			continue;
-		for (i = 0; i < NUM_ELEMENTS(options); i++) {
-			n = strlen(options[i].name);
-
-			if (strncmp(options[i].name, p, n) != 0)
-				continue;
-
-			if (!strncmp(p, "global_tag_depth", n)) {
-				ahd_linux_setup_tag_info_global(p + n);
-			} else if (!strncmp(p, "tag_info", n)) {
-				ahd_linux_setup_tag_info(p + n, end, s);
-			} else if (strncmp(p, "rd_strm", n) == 0) {
-				ahd_linux_setup_rd_strm_info(p + n, end, s);
-			} else if (strncmp(p, "dv", n) == 0) {
-				ahd_linux_setup_dv(p + n, end, s);
-			} else if (strncmp(p, "slewrate", n) == 0) {
-				ahd_linux_setup_iocell_info(p + n, end, s,
-				    AIC79XX_SLEWRATE_INDEX);
-			} else if (strncmp(p, "precomp", n) == 0) {
-				ahd_linux_setup_iocell_info(p + n, end, s,
-				    AIC79XX_PRECOMP_INDEX);
-			} else if (strncmp(p, "amplitude", n) == 0) {
-				ahd_linux_setup_iocell_info(p + n, end, s,
-				    AIC79XX_AMPLITUDE_INDEX);
-			} else if (p[n] == ':') {
-				*(options[i].flag) =
-				    simple_strtoul(p + n + 1, NULL, 0);
-			} else if (!strncmp(p, "verbose", n)) {
-				*(options[i].flag) = 1;
-			} else {
-				*(options[i].flag) = ~(*(options[i].flag));
-			}
-			break;
-		}
-	}
-	return 1;
-}
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
-__setup("aic79xx=", aic79xx_setup);
-#endif
-
-int aic79xx_verbose;
-
-int
-ahd_linux_register_host(struct ahd_softc *ahd, Scsi_Host_Template *template)
-{
-	char	buf[80];
-	struct	Scsi_Host *host;
-	char	*new_name;
-	u_long	s;
-	u_long	target;
-
-	template->name = ahd->description;
-	host = scsi_register(template, sizeof(struct ahd_softc *));
-	if (host == NULL)
-		return (ENOMEM);
-
-	*((struct ahd_softc **)host->hostdata) = ahd;
-	ahd_lock(ahd, &s);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-	scsi_assign_lock(host, &ahd->platform_data->spin_lock);
-#endif
-	ahd->platform_data->host = host;
-	host->can_queue = AHD_MAX_QUEUE;
-	host->cmd_per_lun = 2;
-	host->sg_tablesize = AHD_NSEG;
-	host->this_id = ahd->our_id;
-	host->irq = ahd->platform_data->irq;
-	host->max_id = (ahd->features & AHD_WIDE) ? 16 : 8;
-	host->max_lun = AHD_NUM_LUNS;
-	host->max_channel = 0;
-	ahd_set_unit(ahd, ahd_linux_next_unit());
-	sprintf(buf, "scsi%d", host->host_no);
-	new_name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
-	if (new_name != NULL) {
-		strcpy(new_name, buf);
-		ahd_set_name(ahd, new_name);
-	}
-	host->unique_id = ahd->unit;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,4)
-	scsi_set_pci_device(host, ahd->dev_softc);
-#endif
-	ahd_linux_initialize_scsi_bus(ahd);
-	ahd_unlock(ahd, &s);
-	ahd->platform_data->dv_pid = kernel_thread(ahd_linux_dv_thread, ahd, 0);
-	ahd_lock(ahd, &s);
-	if (ahd->platform_data->dv_pid < 0) {
-		printf("%s: Failed to create DV thread, error= %d\n",
-		       ahd_name(ahd), ahd->platform_data->dv_pid);
-		return (-ahd->platform_data->dv_pid);
-	}
-	/*
-	 * Initially allocate *all* of our linux target objects
-	 * so that the DV thread will scan them all in parallel
-	 * just after driver initialization.  Any device that
-	 * does not exist will have its target object destroyed
-	 * by the selection timeout handler.  In the case of a
-	 * device that appears after the initial DV scan, async
-	 * negotiation will occur for the first command, and DV
-	 * will comence should that first command be successful.
-	 */
-	for (target = 0; target < host->max_id; target++)
-		ahd_linux_alloc_target(ahd, 0, target);
-	ahd_intr_enable(ahd, TRUE);
-	ahd_linux_start_dv(ahd);
-	ahd_unlock(ahd, &s);
-	return (0);
-}
-
-uint64_t
-ahd_linux_get_memsize()
-{
-	struct sysinfo si;
-
-	si_meminfo(&si);
-	return ((uint64_t)si.totalram << PAGE_SHIFT);
-}
-
-/*
- * Find the smallest available unit number to use
- * for a new device.  We don't just use a static
- * count to handle the "repeated hot-(un)plug"
- * scenario.
- */
-static int
-ahd_linux_next_unit()
-{
-	struct ahd_softc *ahd;
-	int unit;
-
-	unit = 0;
-retry:
-	TAILQ_FOREACH(ahd, &ahd_tailq, links) {
-		if (ahd->unit == unit) {
-			unit++;
-			goto retry;
-		}
-	}
-	return (unit);
-}
-
-/*
- * Place the SCSI bus into a known state by either resetting it,
- * or forcing transfer negotiations on the next command to any
- * target.
- */
-static void
-ahd_linux_initialize_scsi_bus(struct ahd_softc *ahd)
-{
-	u_int target_id;
-	u_int numtarg;
-
-	target_id = 0;
-	numtarg = 0;
-
-	if (aic79xx_no_reset != 0)
-		ahd->flags &= ~AHD_RESET_BUS_A;
-
-	if ((ahd->flags & AHD_RESET_BUS_A) != 0)
-		ahd_reset_channel(ahd, 'A', /*initiate_reset*/TRUE);
-	else
-		numtarg = (ahd->features & AHD_WIDE) ? 16 : 8;
-
-	/*
-	 * Force negotiation to async for all targets that
-	 * will not see an initial bus reset.
-	 */
-	for (; target_id < numtarg; target_id++) {
-		struct ahd_devinfo devinfo;
-		struct ahd_initiator_tinfo *tinfo;
-		struct ahd_tmode_tstate *tstate;
-
-		tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
-					    target_id, &tstate);
-		ahd_compile_devinfo(&devinfo, ahd->our_id, target_id,
-				    CAM_LUN_WILDCARD, 'A', ROLE_INITIATOR);
-		ahd_update_neg_request(ahd, &devinfo, tstate,
-				       tinfo, AHD_NEG_ALWAYS);
-	}
-	/* Give the bus some time to recover */
-	if ((ahd->flags & AHD_RESET_BUS_A) != 0) {
-		ahd_freeze_simq(ahd);
-		init_timer(&ahd->platform_data->reset_timer);
-		ahd->platform_data->reset_timer.data = (u_long)ahd;
-		ahd->platform_data->reset_timer.expires =
-		    jiffies + (AIC79XX_RESET_DELAY * HZ)/1000;
-		ahd->platform_data->reset_timer.function =
-		    (ahd_linux_callback_t *)ahd_release_simq;
-		add_timer(&ahd->platform_data->reset_timer);
-	}
-}
-
-int
-ahd_platform_alloc(struct ahd_softc *ahd, void *platform_arg)
-{
-	ahd->platform_data =
-	    malloc(sizeof(struct ahd_platform_data), M_DEVBUF, M_NOWAIT);
-	if (ahd->platform_data == NULL)
-		return (ENOMEM);
-	memset(ahd->platform_data, 0, sizeof(struct ahd_platform_data));
-	TAILQ_INIT(&ahd->platform_data->completeq);
-	TAILQ_INIT(&ahd->platform_data->device_runq);
-	ahd->platform_data->irq = AHD_LINUX_NOIRQ;
-	ahd->platform_data->hw_dma_mask = 0xFFFFFFFF;
-	ahd_lockinit(ahd);
-	ahd_done_lockinit(ahd);
-	init_timer(&ahd->platform_data->completeq_timer);
-	ahd->platform_data->completeq_timer.data = (u_long)ahd;
-	ahd->platform_data->completeq_timer.function =
-	    (ahd_linux_callback_t *)ahd_linux_thread_run_complete_queue;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	init_MUTEX_LOCKED(&ahd->platform_data->eh_sem);
-	init_MUTEX_LOCKED(&ahd->platform_data->dv_sem);
-	init_MUTEX_LOCKED(&ahd->platform_data->dv_cmd_sem);
-#else
-	ahd->platform_data->eh_sem = MUTEX_LOCKED;
-	ahd->platform_data->dv_sem = MUTEX_LOCKED;
-	ahd->platform_data->dv_cmd_sem = MUTEX_LOCKED;
-#endif
-	ahd_setup_runq_tasklet(ahd);
-	ahd->seltime = (aic79xx_seltime & 0x3) << 4;
-	if (TAILQ_EMPTY(&ahd_tailq))
-		register_reboot_notifier(&ahd_linux_notifier);
-	return (0);
-}
-
-void
-ahd_platform_free(struct ahd_softc *ahd)
-{
-	struct ahd_linux_target *targ;
-	struct ahd_linux_device *dev;
-	u_long s;
-	int i, j;
-
-	if (ahd->platform_data != NULL) {
-		/* Kill the DV kthread */
-		if (ahd->platform_data->dv_pid != 0) {
-			ahd_lock(ahd, &s);
-			ahd->platform_data->flags |= AHD_DV_SHUTDOWN;
-			ahd_unlock(ahd, &s);
-			up(&ahd->platform_data->dv_sem);
-			do {
-#ifdef AHD_DEBUG
-				if (ahd_debug & AHD_SHOW_DV) {
-					printf("%s: Waiting for DV thread to "
-					       "exit\n", ahd_name(ahd));
-				}
-#endif
-			} while (waitpid(ahd->platform_data->dv_pid, NULL,
-					 __WCLONE) == -ERESTARTSYS);
-		}
-		ahd_teardown_runq_tasklet(ahd);
-		if (ahd->platform_data->host != NULL)
-			scsi_unregister(ahd->platform_data->host);
-
-		/* destroy all of the device and target objects */
-		for (i = 0; i < AHD_NUM_TARGETS; i++) {
-			targ = ahd->platform_data->targets[i];
-			if (targ != NULL) {
-				for (j = 0; j < AHD_NUM_LUNS; j++) {
-					if (targ->devices[j] != NULL) {
-						dev = targ->devices[j];
-						ahd_linux_free_device(ahd, dev);
-					}
-					if (ahd->platform_data->targets[i] ==
-					    NULL)
-						break;
-				}
-			}
-		}
-
-		if (ahd->platform_data->irq != AHD_LINUX_NOIRQ)
-			free_irq(ahd->platform_data->irq, ahd);
-		if (ahd->tags[0] == BUS_SPACE_PIO
-		 && ahd->bshs[0].ioport != 0)
-			release_region(ahd->bshs[0].ioport, 256);
-		if (ahd->tags[1] == BUS_SPACE_PIO
-		 && ahd->bshs[1].ioport != 0)
-			release_region(ahd->bshs[1].ioport, 256);
-		if (ahd->tags[0] == BUS_SPACE_MEMIO
-		 && ahd->bshs[0].maddr != NULL) {
-			u_long base_addr;
-
-			base_addr = (u_long)ahd->bshs[0].maddr;
-			base_addr &= PAGE_MASK;
-			iounmap((void *)base_addr);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-			release_mem_region(ahd->platform_data->mem_busaddr,
-					   0x1000);
-#endif
-		}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-		/* XXX Need an instance detach in the PCI code */
-		if (ahd->dev_softc != NULL)
-			ahd->dev_softc->driver = NULL;
-#endif
-		free(ahd->platform_data, M_DEVBUF);
-	}
-	if (TAILQ_EMPTY(&ahd_tailq)) {
-		unregister_reboot_notifier(&ahd_linux_notifier);
-#ifdef CONFIG_PCI
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-		pci_unregister_driver(&aic79xx_pci_driver);
-#endif
-#endif
-	}
-}
-
-void
-ahd_platform_init(struct ahd_softc *ahd)
-{
-	/*
-	 * Lookup and commit any modified IO Cell options.
-	 */
-	if (ahd->unit < NUM_ELEMENTS(aic79xx_iocell_info)) {
-		struct ahd_linux_iocell_opts *iocell_opts;
-
-		iocell_opts = &aic79xx_iocell_info[ahd->unit];
-		if (iocell_opts->precomp != AIC79XX_DEFAULT_PRECOMP)
-			AHD_SET_PRECOMP(ahd, iocell_opts->precomp);
-		if (iocell_opts->slewrate != AIC79XX_DEFAULT_SLEWRATE)
-			AHD_SET_SLEWRATE(ahd, iocell_opts->slewrate);
-		if (iocell_opts->amplitude != AIC79XX_DEFAULT_AMPLITUDE)
-			AHD_SET_AMPLITUDE(ahd, iocell_opts->amplitude);
-	}
-
-}
-
-void
-ahd_platform_freeze_devq(struct ahd_softc *ahd, struct scb *scb)
-{
-	ahd_platform_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),
-				SCB_GET_CHANNEL(ahd, scb),
-				SCB_GET_LUN(scb), SCB_LIST_NULL,
-				ROLE_UNKNOWN, CAM_REQUEUE_REQ);
-}
-
-void
-ahd_platform_set_tags(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
-		      ahd_queue_alg alg)
-{
-	struct ahd_linux_device *dev;
-	int was_queuing;
-	int now_queuing;
-
-	dev = ahd_linux_get_device(ahd, devinfo->channel - 'A',
-				   devinfo->target,
-				   devinfo->lun, /*alloc*/FALSE);
-	if (dev == NULL)
-		return;
-	was_queuing = dev->flags & (AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED);
-	now_queuing = alg != AHD_QUEUE_NONE;
-	if ((dev->flags & AHD_DEV_FREEZE_TIL_EMPTY) == 0
-	 && (was_queuing != now_queuing)
-	 && (dev->active != 0)) {
-		dev->flags |= AHD_DEV_FREEZE_TIL_EMPTY;
-		dev->qfrozen++;
-	}
-
-	dev->flags &= ~(AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED|AHD_DEV_PERIODIC_OTAG);
-	if (now_queuing) {
-		u_int usertags;
-
-		usertags = ahd_linux_user_tagdepth(ahd, devinfo);
-		if (!was_queuing) {
-			/*
-			 * Start out agressively and allow our
-			 * dynamic queue depth algorithm to take
-			 * care of the rest.
-			 */
-			dev->maxtags = usertags;
-			dev->openings = dev->maxtags - dev->active;
-		}
-		if (dev->maxtags == 0) {
-			/*
-			 * Queueing is disabled by the user.
-			 */
-			dev->openings = 1;
-		} else if (alg == AHD_QUEUE_TAGGED) {
-			dev->flags |= AHD_DEV_Q_TAGGED;
-			if (aic79xx_periodic_otag != 0)
-				dev->flags |= AHD_DEV_PERIODIC_OTAG;
-		} else
-			dev->flags |= AHD_DEV_Q_BASIC;
-	} else {
-		/* We can only have one opening. */
-		dev->maxtags = 0;
-		dev->openings =  1 - dev->active;
-	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-	if (dev->scsi_device != NULL) {
-		switch ((dev->flags & (AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED))) {
-		case AHD_DEV_Q_BASIC:
-			scsi_adjust_queue_depth(dev->scsi_device,
-						MSG_SIMPLE_TASK,
-						dev->openings + dev->active);
-			break;
-		case AHD_DEV_Q_TAGGED:
-			scsi_adjust_queue_depth(dev->scsi_device,
-						MSG_ORDERED_TASK,
-						dev->openings + dev->active);
-			break;
-		default:
-			/*
-			 * We allow the OS to queue 2 untagged transactions to
-			 * us at any time even though we can only execute them
-			 * serially on the controller/device.  This should
-			 * remove some latency.
-			 */
-			scsi_adjust_queue_depth(dev->scsi_device,
-						/*NON-TAGGED*/0,
-						/*queue depth*/2);
-			break;
-		}
-	}
-#endif
-}
-
-int
-ahd_platform_abort_scbs(struct ahd_softc *ahd, int target, char channel,
-			int lun, u_int tag, role_t role, uint32_t status)
-{
-	int targ;
-	int maxtarg;
-	int maxlun;
-	int clun;
-	int count;
-
-	if (tag != SCB_LIST_NULL)
-		return (0);
-
-	targ = 0;
-	if (target != CAM_TARGET_WILDCARD) {
-		targ = target;
-		maxtarg = targ + 1;
-	} else {
-		maxtarg = (ahd->features & AHD_WIDE) ? 16 : 8;
-	}
-	clun = 0;
-	if (lun != CAM_LUN_WILDCARD) {
-		clun = lun;
-		maxlun = clun + 1;
-	} else {
-		maxlun = AHD_NUM_LUNS;
-	}
-
-	count = 0;
-	for (; targ < maxtarg; targ++) {
-
-		for (; clun < maxlun; clun++) {
-			struct ahd_linux_device *dev;
-			struct ahd_busyq *busyq;
-			struct ahd_cmd *acmd;
-
-			dev = ahd_linux_get_device(ahd, /*chan*/0, targ,
-						   clun, /*alloc*/FALSE);
-			if (dev == NULL)
-				continue;
-
-			busyq = &dev->busyq;
-			while ((acmd = TAILQ_FIRST(busyq)) != NULL) {
-				Scsi_Cmnd *cmd;
-
-				cmd = &acmd_scsi_cmd(acmd);
-				TAILQ_REMOVE(busyq, acmd,
-					     acmd_links.tqe);
-				count++;
-				cmd->result = status << 16;
-				ahd_linux_queue_cmd_complete(ahd, cmd);
-			}
-		}
-	}
-
-	return (count);
-}
-
-static void
-ahd_linux_thread_run_complete_queue(struct ahd_softc *ahd)
-{
-	struct ahd_cmd *acmd;
-	u_long flags;
-
-	ahd_lock(ahd, &flags);
-	del_timer(&ahd->platform_data->completeq_timer);
-	ahd->platform_data->flags &= ~AHD_RUN_CMPLT_Q_TIMER;
-	acmd = TAILQ_FIRST(&ahd->platform_data->completeq);
-	TAILQ_INIT(&ahd->platform_data->completeq);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	ahd_unlock(ahd, &flags);
-#endif
-	if (acmd != NULL) {
-		acmd = ahd_linux_run_complete_queue(ahd, acmd);
-		if (acmd != NULL) {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-			ahd_lock(ahd, &flags);
-#endif
-			ahd_schedule_completeq(ahd, acmd);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-			ahd_unlock(ahd, &flags);
-#endif
-		}
-	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-	ahd_unlock(ahd, &flags);
-#endif
-}
-
-static void
-ahd_linux_start_dv(struct ahd_softc *ahd)
-{
-
-	/*
-	 * Freeze the simq and signal ahd_linux_queue to not let any
-	 * more commands through
-	 */
-	if ((ahd->platform_data->flags & AHD_DV_ACTIVE) == 0) {
-#ifdef AHD_DEBUG
-		if (ahd_debug & AHD_SHOW_DV)
-			printf("%s: Starting DV\n", ahd_name(ahd));
-#endif
-
-		ahd->platform_data->flags |= AHD_DV_ACTIVE;
-		ahd_freeze_simq(ahd);
-
-		/* Wake up the DV kthread */
-		up(&ahd->platform_data->dv_sem);
-	}
-}
-
-static int
-ahd_linux_dv_thread(void *data)
-{
-	struct	ahd_softc *ahd;
-	int	target;
-	u_long	s;
-
-	ahd = (struct ahd_softc *)data;
-
-#ifdef AHD_DEBUG
-	if (ahd_debug & AHD_SHOW_DV)
-		printf("In DV Thread\n");
-#endif
-
-	/*
-	 * Don't care about any signals.
-	 */
-	siginitsetinv(&current->blocked, 0);
-
-	/*
-	 * Complete thread creation.
-	 */
-	lock_kernel();
-	daemonize();
-	sprintf(current->comm, "ahd_dv_%d", ahd->unit);
-	unlock_kernel();
-
-	while (1) {
-		/*
-		 * Use down_interruptible() rather than down() to
-		 * avoid inclusion in the load average.
-		 */
-		down_interruptible(&ahd->platform_data->dv_sem);
-
-		/* Check to see if we've been signaled to exit */
-		ahd_lock(ahd, &s);
-		if ((ahd->platform_data->flags & AHD_DV_SHUTDOWN) != 0) {
-			ahd_unlock(ahd, &s);
-			return (0);
-		}
-		ahd_unlock(ahd, &s);
-
-#ifdef AHD_DEBUG
-		if (ahd_debug & AHD_SHOW_DV)
-			printf("%s: Beginning Domain Validation\n",
-			       ahd_name(ahd));
-#endif
-
-		/*
-		 * Wait for any pending commands to drain before proceeding.
-		 */
-		ahd_lock(ahd, &s);
-		while (LIST_FIRST(&ahd->pending_scbs) != NULL) {
-			ahd->platform_data->flags |= AHD_DV_WAIT_SIMQ_EMPTY;
-			ahd_unlock(ahd, &s);
-			down_interruptible(&ahd->platform_data->dv_sem);
-			ahd_lock(ahd, &s);
-		}
-
-		/*
-		 * Wait for the SIMQ to be released so that DV is the
-		 * only reason the queue is frozen.
-		 */
-		while (AHD_DV_SIMQ_FROZEN(ahd) == 0) {
-			ahd->platform_data->flags |= AHD_DV_WAIT_SIMQ_RELEASE;
-			ahd_unlock(ahd, &s);
-			down_interruptible(&ahd->platform_data->dv_sem);
-			ahd_lock(ahd, &s);
-		}
-		ahd_unlock(ahd, &s);
-
-		for (target = 0; target < AHD_NUM_TARGETS; target++)
-			ahd_linux_dv_target(ahd, target);
-
-		ahd_lock(ahd, &s);
-		ahd->platform_data->flags &= ~AHD_DV_ACTIVE;
-		ahd_unlock(ahd, &s);
-
-		/*
-		 * Release the SIMQ so that normal commands are
-		 * allowed to continue on the bus.
-		 */
-		ahd_release_simq(ahd);
-	}
-
-	return (0);
-}
-
-#define AHD_LINUX_DV_INQ_SHORT_LEN	36
-#define AHD_LINUX_DV_INQ_LEN		256
-#define AHD_LINUX_DV_TIMEOUT		(HZ / 4)
-
-#define AHD_SET_DV_STATE(ahd, targ, newstate) \
-	ahd_set_dv_state(ahd, targ, newstate, __LINE__)
-
-static __inline void
-ahd_set_dv_state(struct ahd_softc *ahd, struct ahd_linux_target *targ,
-		 ahd_dv_state newstate, u_int line)
-{
-	ahd_dv_state oldstate;
-
-	oldstate = targ->dv_state;
-#ifdef AHD_DEBUG
-	if (ahd_debug & AHD_SHOW_DV)
-		printf("%s:%d: Going from state %d to state %d\n",
-		       ahd_name(ahd), line, oldstate, newstate);
-#endif
-
-	if (oldstate == newstate)
-		targ->dv_state_retry++;
-	else
-		targ->dv_state_retry = 0;
-	targ->dv_state = newstate;
-}
-
-static void
-ahd_linux_dv_target(struct ahd_softc *ahd, u_int target_offset)
-{
-	struct	 ahd_devinfo devinfo;
-	struct	 ahd_linux_target *targ;
-	struct	 scsi_cmnd *cmd;
-	struct	 scsi_device *scsi_dev;
-	struct	 scsi_sense_data *sense;
-	uint8_t *buffer;
-	u_long	 s;
-	u_int	 timeout;
-	int	 echo_size;
-
-	sense = NULL;
-	buffer = NULL;
-	echo_size = 0;
-	ahd_lock(ahd, &s);
-	targ = ahd->platform_data->targets[target_offset];
-	if (targ == NULL || (targ->flags & AHD_DV_REQUIRED) == 0) {
-		ahd_unlock(ahd, &s);
-		return;
-	}
-	ahd_compile_devinfo(&devinfo, ahd->our_id, targ->target, /*lun*/0,
-			    targ->channel + 'A', ROLE_INITIATOR);
-#ifdef AHD_DEBUG
-	if (ahd_debug & AHD_SHOW_DV) {
-		ahd_print_devinfo(ahd, &devinfo);
-		printf("Performing DV\n");
-	}
-#endif
-
-	ahd_unlock(ahd, &s);
-
-	cmd = malloc(sizeof(struct scsi_cmnd), M_DEVBUF, M_WAITOK);
-	scsi_dev = malloc(sizeof(struct scsi_device), M_DEVBUF, M_WAITOK);
-	scsi_dev->host = ahd->platform_data->host;
-	scsi_dev->id = devinfo.target;
-	scsi_dev->lun = devinfo.lun;
-	scsi_dev->channel = devinfo.channel - 'A';
-	ahd->platform_data->dv_scsi_dev = scsi_dev;
-
-	AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_INQ_SHORT_ASYNC);
-
-	while (targ->dv_state != AHD_DV_STATE_EXIT) {
-		timeout = AHD_LINUX_DV_TIMEOUT;
-		switch (targ->dv_state) {
-		case AHD_DV_STATE_INQ_SHORT_ASYNC:
-		case AHD_DV_STATE_INQ_ASYNC:
-		case AHD_DV_STATE_INQ_ASYNC_VERIFY:
-			/*
-			 * Set things to async narrow to reduce the
-			 * chance that the INQ will fail.
-			 */
-			ahd_lock(ahd, &s);
-			ahd_set_syncrate(ahd, &devinfo, 0, 0, 0,
-					 AHD_TRANS_GOAL, /*paused*/FALSE);
-			ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
-				      AHD_TRANS_GOAL, /*paused*/FALSE);
-			ahd_unlock(ahd, &s);
-			timeout = 10 * HZ;
-			targ->flags &= ~AHD_INQ_VALID;
-			/* FALLTHROUGH */
-		case AHD_DV_STATE_INQ_VERIFY:
-		{
-			u_int inq_len;
-
-			if (targ->dv_state == AHD_DV_STATE_INQ_SHORT_ASYNC)
-				inq_len = AHD_LINUX_DV_INQ_SHORT_LEN;
-			else
-				inq_len = targ->inq_data->additional_length + 5;
-			ahd_linux_dv_inq(ahd, cmd, &devinfo, targ, inq_len);
-			break;
-		}
-		case AHD_DV_STATE_TUR:
-		case AHD_DV_STATE_BUSY:
-			ahd_linux_dv_tur(ahd, cmd, &devinfo);
-			break;
-		case AHD_DV_STATE_REBD:
-			ahd_linux_dv_rebd(ahd, cmd, &devinfo, targ);
-			break;
-		case AHD_DV_STATE_WEB:
-			ahd_linux_dv_web(ahd, cmd, &devinfo, targ);
-			break;
-
-		case AHD_DV_STATE_REB:
-			ahd_linux_dv_reb(ahd, cmd, &devinfo, targ);
-			break;
-
-		case AHD_DV_STATE_SU:
-			ahd_linux_dv_su(ahd, cmd, &devinfo, targ);
-			timeout = 50 * HZ;
-			break;
-
-		default:
-			ahd_print_devinfo(ahd, &devinfo);
-			printf("Unknown DV state %d\n", targ->dv_state);
-			goto out;
-		}
-
-		/* Queue the command and wait for it to complete */
-		/* Abuse eh_timeout in the scsi_cmnd struct for our purposes */
-		init_timer(&cmd->eh_timeout);
-#ifdef AHD_DEBUG
-		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
-			/*
-			 * All of the printfs during negotiation
-			 * really slow down the negotiation.
-			 * Add a bit of time just to be safe.
-			 */
-			timeout += HZ;
-#endif
-		scsi_add_timer(cmd, timeout, ahd_linux_dv_timeout);
-		/*
-		 * In 2.5.X, it is assumed that all calls from the
-		 * "midlayer" (which we are emulating) will have the
-		 * ahd host lock held.
-		 */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-		ahd_lock(ahd, &s);
-#endif
-		ahd_linux_queue(cmd, ahd_linux_dv_complete);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-		ahd_unlock(ahd, &s);
-#endif
-		down_interruptible(&ahd->platform_data->dv_cmd_sem);
-		/*
-		 * Wait for the SIMQ to be released so that DV is the
-		 * only reason the queue is frozen.
-		 */
-		ahd_lock(ahd, &s);
-		while (AHD_DV_SIMQ_FROZEN(ahd) == 0) {
-			ahd->platform_data->flags |= AHD_DV_WAIT_SIMQ_RELEASE;
-			ahd_unlock(ahd, &s);
-			down_interruptible(&ahd->platform_data->dv_sem);
-			ahd_lock(ahd, &s);
-		}
-		ahd_unlock(ahd, &s);
-
-		ahd_linux_dv_transition(ahd, cmd, &devinfo, targ);
-	}
-
-out:
-	if ((targ->flags & AHD_INQ_VALID) != 0
-	 && ahd_linux_get_device(ahd, devinfo.channel - 'A',
-				 devinfo.target, devinfo.lun,
-				 /*alloc*/FALSE) == NULL) {
-		/*
-		 * The DV state machine failed to configure this device.  
-		 * This is normal if DV is disabled.  Since we have inquiry
-		 * data, filter it and use the "optimistic" negotiation
-		 * parameters found in the inquiry string.
-		 */
-		ahd_linux_filter_inquiry(ahd, &devinfo);
-		if ((targ->flags & (AHD_BASIC_DV|AHD_ENHANCED_DV)) != 0) {
-			ahd_print_devinfo(ahd, &devinfo);
-			printf("DV failed to configure device.  "
-			       "Please file a bug report against "
-			       "this driver.\n");
-		}
-	}
-
-	if (cmd != NULL)
-		free(cmd, M_DEVBUF);
-
-	if (ahd->platform_data->dv_scsi_dev != NULL) {
-		free(ahd->platform_data->dv_scsi_dev, M_DEVBUF);
-		ahd->platform_data->dv_scsi_dev = NULL;
-	}
-
-	ahd_lock(ahd, &s);
-	if (targ->dv_buffer != NULL)
-		free(targ->dv_buffer, M_DEVBUF);
-	if (targ->dv_buffer1 != NULL)
-		free(targ->dv_buffer1, M_DEVBUF);
-	targ->flags &= ~AHD_DV_REQUIRED;
-	if (targ->refcount == 0)
-		ahd_linux_free_target(ahd, targ);
-	ahd_unlock(ahd, &s);
-}
-
-static void
-ahd_linux_dv_transition(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
-			struct ahd_devinfo *devinfo,
-			struct ahd_linux_target *targ)
-{
-	cam_status cam_status;
-	u_int32_t status;
-	u_int scsi_status;
-
-	scsi_status = ahd_cmd_get_scsi_status(cmd);
-	cam_status = ahd_cmd_get_transaction_status(cmd);
-	status = aic_error_action(cmd, targ->inq_data, cam_status, scsi_status);
-
-	
-#ifdef AHD_DEBUG
-	if (ahd_debug & AHD_SHOW_DV) {
-		ahd_print_devinfo(ahd, devinfo);
-		printf("Entering ahd_linux_dv_transition, state= %d, "
-		       "status= 0x%x, cmd->result= 0x%x\n", targ->dv_state,
-		       status, cmd->result);
-	}
-#endif
-
-	switch (targ->dv_state) {
-	case AHD_DV_STATE_INQ_SHORT_ASYNC:
-	case AHD_DV_STATE_INQ_ASYNC:
-		switch (status & SS_MASK) {
-		case SS_NOP:
-		{
-			AHD_SET_DV_STATE(ahd, targ, targ->dv_state+1);
-			break;
-		}
-		case SS_INQ_REFRESH:
-			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
-			break;
-		case SS_TUR:
-		case SS_RETRY:
-			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
-			 == CAM_REQUEUE_REQ)
-				targ->dv_state_retry--;
-			if ((status & SS_ERRMASK) == EBUSY)
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_BUSY);
-			if (targ->dv_state_retry < 10)
-				break;
-			/* FALLTHROUGH */
-		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-#ifdef AHD_DEBUG
-			if (ahd_debug & AHD_SHOW_DV) {
-				ahd_print_devinfo(ahd, devinfo);
-				printf("Failed DV inquiry, skipping\n");
-			}
-#endif
-			break;
-		}
-		break;
-	case AHD_DV_STATE_INQ_ASYNC_VERIFY:
-		switch (status & SS_MASK) {
-		case SS_NOP:
-		{
-			u_int xportflags;
-			u_int spi3data;
-
-			if (memcmp(targ->inq_data, targ->dv_buffer,
-				   AHD_LINUX_DV_INQ_LEN) != 0) {
-				/*
-				 * Inquiry data must have changed.
-				 * Try from the top again.
-				 */
-				AHD_SET_DV_STATE(ahd, targ,
-						 AHD_DV_STATE_INQ_SHORT_ASYNC);
-				break;
-			}
-
-			AHD_SET_DV_STATE(ahd, targ, targ->dv_state+1);
-			targ->flags |= AHD_INQ_VALID;
-			if (ahd_linux_user_dv_setting(ahd) == 0)
-				break;
-
-			xportflags = targ->inq_data->flags;
-			if ((xportflags & (SID_Sync|SID_WBus16)) == 0)
-				break;
-
-			spi3data = targ->inq_data->spi3data;
-			switch (spi3data & SID_SPI_CLOCK_DT_ST) {
-			default:
-			case SID_SPI_CLOCK_ST:
-				/* Assume only basic DV is supported. */
-				targ->flags |= AHD_BASIC_DV;
-				break;
-			case SID_SPI_CLOCK_DT:
-			case SID_SPI_CLOCK_DT_ST:
-				targ->flags |= AHD_ENHANCED_DV;
-				break;
-			}
-			break;
-		}
-		case SS_INQ_REFRESH:
-			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
-			break;
-		case SS_TUR:
-		case SS_RETRY:
-			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
-			 == CAM_REQUEUE_REQ)
-				targ->dv_state_retry--;
-
-			if ((status & SS_ERRMASK) == EBUSY)
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_BUSY);
-			if (targ->dv_state_retry < 10)
-				break;
-			/* FALLTHROUGH */
-		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-#ifdef AHD_DEBUG
-			if (ahd_debug & AHD_SHOW_DV) {
-				ahd_print_devinfo(ahd, devinfo);
-				printf("Failed DV inquiry, skipping\n");
-			}
-#endif
-			break;
-		}
-		break;
-	case AHD_DV_STATE_INQ_VERIFY:
-		switch (status & SS_MASK) {
-		case SS_NOP:
-		{
-
-			if (memcmp(targ->inq_data, targ->dv_buffer,
-				   AHD_LINUX_DV_INQ_LEN) == 0) {
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-				break;
-			}
-
-#ifdef AHD_DEBUG
-			if (ahd_debug & AHD_SHOW_DV) {
-				int i;
-
-				ahd_print_devinfo(ahd, devinfo);
-				printf("Inquiry buffer mismatch:");
-				for (i = 0; i < AHD_LINUX_DV_INQ_LEN; i++) {
-					if ((i & 0xF) == 0)
-						printf("\n        ");
-					printf("0x%x:0x0%x ",
-					       ((uint8_t *)targ->inq_data)[i], 
-					       targ->dv_buffer[i]);
-				}
-				printf("\n");
-			}
-#endif
-
-			if (ahd_linux_dv_fallback(ahd, devinfo) != 0) {
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-				break;
-			}
-			/*
-			 * Do not count "falling back"
-			 * against our retries.
-			 */
-			targ->dv_state_retry = 0;
-			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			break;
-		}
-		case SS_INQ_REFRESH:
-			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
-			break;
-		case SS_TUR:
-		case SS_RETRY:
-			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
-			 == CAM_REQUEUE_REQ) {
-				targ->dv_state_retry--;
-			} else if ((status & SSQ_FALLBACK) != 0) {
-				if (ahd_linux_dv_fallback(ahd, devinfo) != 0) {
-					AHD_SET_DV_STATE(ahd, targ,
-							 AHD_DV_STATE_EXIT);
-					break;
-				}
-				/*
-				 * Do not count "falling back"
-				 * against our retries.
-				 */
-				targ->dv_state_retry = 0;
-			} else if ((status & SS_ERRMASK) == EBUSY)
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_BUSY);
-			if (targ->dv_state_retry < 10)
-				break;
-			/* FALLTHROUGH */
-		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-#ifdef AHD_DEBUG
-			if (ahd_debug & AHD_SHOW_DV) {
-				ahd_print_devinfo(ahd, devinfo);
-				printf("Failed DV inquiry, skipping\n");
-			}
-#endif
-			break;
-		}
-		break;
-
-	case AHD_DV_STATE_TUR:
-		switch (status & SS_MASK) {
-		case SS_NOP:
-			if ((targ->flags & AHD_BASIC_DV) != 0) {
-				ahd_linux_filter_inquiry(ahd, devinfo);
-				AHD_SET_DV_STATE(ahd, targ,
-						 AHD_DV_STATE_INQ_VERIFY);
-			} else if ((targ->flags & AHD_ENHANCED_DV) != 0) {
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_REBD);
-			} else {
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-			}
-			break;
-		case SS_RETRY:
-		case SS_TUR:
-			if ((status & SS_ERRMASK) == EBUSY) {
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_BUSY);
-				break;
-			}
-			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
-			 == CAM_REQUEUE_REQ) {
-				targ->dv_state_retry--;
-			} else if ((status & SSQ_FALLBACK) != 0) {
-				if (ahd_linux_dv_fallback(ahd, devinfo) != 0) {
-					AHD_SET_DV_STATE(ahd, targ,
-							 AHD_DV_STATE_EXIT);
-					break;
-				}
-				/*
-				 * Do not count "falling back"
-				 * against our retries.
-				 */
-				targ->dv_state_retry = 0;
-			}
-			if (targ->dv_state_retry >= 10) {
-#ifdef AHD_DEBUG
-				if (ahd_debug & AHD_SHOW_DV) {
-					ahd_print_devinfo(ahd, devinfo);
-					printf("DV TUR reties exhausted\n");
-				}
-#endif
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-				break;
-			}
-			if (status & SSQ_DELAY)
-				scsi_sleep(1 * HZ);
-
-			break;
-		case SS_START:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_SU);
-			break;
-		case SS_INQ_REFRESH:
-			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
-			break;
-		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-			break;
-		}
-		break;
-
-	case AHD_DV_STATE_REBD:
-		switch (status & SS_MASK) {
-		case SS_NOP:
-		{
-			uint32_t echo_size;
-
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_WEB);
-			echo_size = scsi_3btoul(&targ->dv_buffer[1]);
-			echo_size &= 0x1FFF;
-#ifdef AHD_DEBUG
-			if (ahd_debug & AHD_SHOW_DV) {
-				ahd_print_devinfo(ahd, devinfo);
-				printf("Echo buffer size= %d\n", echo_size);
-			}
-#endif
-			if (echo_size == 0) {
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-				break;
-			}
-
-			/* Generate the buffer pattern */
-			targ->dv_echo_size = echo_size;
-			ahd_linux_generate_dv_pattern(targ);
-			/*
-			 * Setup initial negotiation values.
-			 */
-			ahd_linux_filter_inquiry(ahd, devinfo);
-			break;
-		}
-		case SS_INQ_REFRESH:
-			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
-			break;
-		case SS_RETRY:
-			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
-			 == CAM_REQUEUE_REQ)
-				targ->dv_state_retry--;
-			if (targ->dv_state_retry <= 10)
-				break;
-#ifdef AHD_DEBUG
-			if (ahd_debug & AHD_SHOW_DV) {
-				ahd_print_devinfo(ahd, devinfo);
-				printf("DV REBD reties exhausted\n");
-			}
-#endif
-			/* FALLTHROUGH */
-		case SS_FATAL:
-		default:
-			/*
-			 * Setup initial negotiation values
-			 * and try level 1 DV.
-			 */
-			ahd_linux_filter_inquiry(ahd, devinfo);
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_INQ_VERIFY);
-			targ->dv_echo_size = 0;
-			break;
-		}
-		break;
-
-	case AHD_DV_STATE_WEB:
-		switch (status & SS_MASK) {
-		case SS_NOP:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_REB);
-			break;
-		case SS_INQ_REFRESH:
-			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
-			break;
-		case SS_RETRY:
-			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
-			 == CAM_REQUEUE_REQ) {
-				targ->dv_state_retry--;
-			} else if ((status & SSQ_FALLBACK) != 0) {
-				if (ahd_linux_dv_fallback(ahd, devinfo) != 0) {
-					AHD_SET_DV_STATE(ahd, targ,
-							 AHD_DV_STATE_EXIT);
-					break;
-				}
-				/*
-				 * Do not count "falling back"
-				 * against our retries.
-				 */
-				targ->dv_state_retry = 0;
-			}
-			if (targ->dv_state_retry <= 10)
-				break;
-			/* FALLTHROUGH */
-#ifdef AHD_DEBUG
-			if (ahd_debug & AHD_SHOW_DV) {
-				ahd_print_devinfo(ahd, devinfo);
-				printf("DV WEB reties exhausted\n");
-			}
-#endif
-		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-			break;
-		}
-		break;
-
-	case AHD_DV_STATE_REB:
-		switch (status & SS_MASK) {
-		case SS_NOP:
-			if (memcmp(targ->dv_buffer, targ->dv_buffer1,
-				   targ->dv_echo_size) != 0) {
-				if (ahd_linux_dv_fallback(ahd, devinfo) != 0)
-					AHD_SET_DV_STATE(ahd, targ,
-							 AHD_DV_STATE_EXIT);
-				else
-					AHD_SET_DV_STATE(ahd, targ,
-							 AHD_DV_STATE_WEB);
-				break;
-			}
-			
-			if (targ->dv_buffer != NULL) {
-				free(targ->dv_buffer, M_DEVBUF);
-				targ->dv_buffer = NULL;
-			}
-			if (targ->dv_buffer1 != NULL) {
-				free(targ->dv_buffer1, M_DEVBUF);
-				targ->dv_buffer1 = NULL;
-			}
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-			break;
-		case SS_INQ_REFRESH:
-			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
-			break;
-		case SS_RETRY:
-			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
-			 == CAM_REQUEUE_REQ) {
-				targ->dv_state_retry--;
-			} else if ((status & SSQ_FALLBACK) != 0) {
-				if (ahd_linux_dv_fallback(ahd, devinfo) != 0) {
-					AHD_SET_DV_STATE(ahd, targ,
-							 AHD_DV_STATE_EXIT);
-					break;
-				}
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_WEB);
-			}
-			if (targ->dv_state_retry <= 10) {
-				if ((status & (SSQ_DELAY_RANDOM|SSQ_DELAY))!= 0)
-					scsi_sleep(ahd->our_id*HZ/10);
-				break;
-			}
-#ifdef AHD_DEBUG
-			if (ahd_debug & AHD_SHOW_DV) {
-				ahd_print_devinfo(ahd, devinfo);
-				printf("DV REB reties exhausted\n");
-			}
-#endif
-			/* FALLTHROUGH */
-		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-			break;
-		}
-		break;
-
-	case AHD_DV_STATE_SU:
-		switch (status & SS_MASK) {
-		case SS_NOP:
-		case SS_INQ_REFRESH:
-			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
-			break;
-		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-			break;
-		}
-		break;
-
-	case AHD_DV_STATE_BUSY:
-		switch (status & SS_MASK) {
-		case SS_NOP:
-		case SS_INQ_REFRESH:
-			AHD_SET_DV_STATE(ahd, targ,
-					 AHD_DV_STATE_INQ_SHORT_ASYNC);
-			break;
-		case SS_TUR:
-		case SS_RETRY:
-			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
-			if (ahd_cmd_get_transaction_status(cmd)
-			 == CAM_REQUEUE_REQ) {
-				targ->dv_state_retry--;
-			} else if (targ->dv_state_retry < 60) {
-				if ((status & SSQ_DELAY) != 0)
-					scsi_sleep(1 * HZ);
-			} else {
-#ifdef AHD_DEBUG
-				if (ahd_debug & AHD_SHOW_DV) {
-					ahd_print_devinfo(ahd, devinfo);
-					printf("DV BUSY reties exhausted\n");
-				}
-#endif
-				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-			}
-			break;
-		default:
-			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-			break;
-		}
-		break;
-
-	default:
-		printf("%s: Invalid DV completion state %d\n", ahd_name(ahd),
-		       targ->dv_state);
-		AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
-		break;
-	}
-}
-
-static void
-ahd_linux_dv_fill_cmd(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
-		      struct ahd_devinfo *devinfo)
-{
-	memset(cmd, 0, sizeof(struct scsi_cmnd));
-	cmd->device = ahd->platform_data->dv_scsi_dev;
-	cmd->scsi_done = ahd_linux_dv_complete;
-}
-
-/*
- * Synthesize an inquiry command.  On the return trip, it'll be
- * sniffed and the device transfer settings set for us.
- */
-static void
-ahd_linux_dv_inq(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
-		 struct ahd_devinfo *devinfo, struct ahd_linux_target *targ,
-		 u_int request_length)
-{
-
-#ifdef AHD_DEBUG
-	if (ahd_debug & AHD_SHOW_DV) {
-		ahd_print_devinfo(ahd, devinfo);
-		printf("Sending INQ\n");
-	}
-#endif
-	if (targ->inq_data == NULL)
-		targ->inq_data = malloc(AHD_LINUX_DV_INQ_LEN,
-					M_DEVBUF, M_WAITOK);
-	if (targ->dv_state > AHD_DV_STATE_INQ_ASYNC) {
-		if (targ->dv_buffer != NULL)
-			free(targ->dv_buffer, M_DEVBUF);
-		targ->dv_buffer = malloc(AHD_LINUX_DV_INQ_LEN,
-					 M_DEVBUF, M_WAITOK);
-	}
-
-	ahd_linux_dv_fill_cmd(ahd, cmd, devinfo);
-	cmd->sc_data_direction = SCSI_DATA_READ;
-	cmd->cmd_len = 6;
-	cmd->cmnd[0] = INQUIRY;
-	cmd->cmnd[4] = request_length;
-	cmd->request_bufflen = request_length;
-	if (targ->dv_state > AHD_DV_STATE_INQ_ASYNC)
-		cmd->request_buffer = targ->dv_buffer;
-	else
-		cmd->request_buffer = targ->inq_data;
-	memset(cmd->request_buffer, 0, AHD_LINUX_DV_INQ_LEN);
-}
-
-static void
-ahd_linux_dv_tur(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
-		 struct ahd_devinfo *devinfo)
-{
-
-#ifdef AHD_DEBUG
-	if (ahd_debug & AHD_SHOW_DV) {
-		ahd_print_devinfo(ahd, devinfo);
-		printf("Sending TUR\n");
-	}
-#endif
-	/* Do a TUR to clear out any non-fatal transitional state */
-	ahd_linux_dv_fill_cmd(ahd, cmd, devinfo);
-	cmd->sc_data_direction = SCSI_DATA_NONE;
-	cmd->cmd_len = 6;
-	cmd->cmnd[0] = TEST_UNIT_READY;
-}
-
-#define AHD_REBD_LEN 4
-
-static void
-ahd_linux_dv_rebd(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
-		 struct ahd_devinfo *devinfo, struct ahd_linux_target *targ)
-{
-
-#ifdef AHD_DEBUG
-	if (ahd_debug & AHD_SHOW_DV) {
-		ahd_print_devinfo(ahd, devinfo);
-		printf("Sending REBD\n");
-	}
-#endif
-	if (targ->dv_buffer != NULL)
-		free(targ->dv_buffer, M_DEVBUF);
-	targ->dv_buffer = malloc(AHD_REBD_LEN, M_DEVBUF, M_WAITOK);
-	ahd_linux_dv_fill_cmd(ahd, cmd, devinfo);
-	cmd->sc_data_direction = SCSI_DATA_READ;
-	cmd->cmd_len = 10;
-	cmd->cmnd[0] = READ_BUFFER;
-	cmd->cmnd[1] = 0x0b;
-	scsi_ulto3b(AHD_REBD_LEN, &cmd->cmnd[6]);
-	cmd->request_bufflen = AHD_REBD_LEN;
-	cmd->underflow = cmd->request_bufflen;
-	cmd->request_buffer = targ->dv_buffer;
-}
-
-static void
-ahd_linux_dv_web(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
-		 struct ahd_devinfo *devinfo, struct ahd_linux_target *targ)
-{
-
-#ifdef AHD_DEBUG
-	if (ahd_debug & AHD_SHOW_DV) {
-		ahd_print_devinfo(ahd, devinfo);
-		printf("Sending WEB\n");
-	}
-#endif
-	ahd_linux_dv_fill_cmd(ahd, cmd, devinfo);
-	cmd->sc_data_direction = SCSI_DATA_WRITE;
-	cmd->cmd_len = 10;
-	cmd->cmnd[0] = WRITE_BUFFER;
-	cmd->cmnd[1] = 0x0a;
-	scsi_ulto3b(targ->dv_echo_size, &cmd->cmnd[6]);
-	cmd->request_bufflen = targ->dv_echo_size;
-	cmd->underflow = cmd->request_bufflen;
-	cmd->request_buffer = targ->dv_buffer;
-}
-
-static void
-ahd_linux_dv_reb(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
-		 struct ahd_devinfo *devinfo, struct ahd_linux_target *targ)
-{
-
-#ifdef AHD_DEBUG
-	if (ahd_debug & AHD_SHOW_DV) {
-		ahd_print_devinfo(ahd, devinfo);
-		printf("Sending REB\n");
-	}
-#endif
-	ahd_linux_dv_fill_cmd(ahd, cmd, devinfo);
-	cmd->sc_data_direction = SCSI_DATA_READ;
-	cmd->cmd_len = 10;
-	cmd->cmnd[0] = READ_BUFFER;
-	cmd->cmnd[1] = 0x0a;
-	scsi_ulto3b(targ->dv_echo_size, &cmd->cmnd[6]);
-	cmd->request_bufflen = targ->dv_echo_size;
-	cmd->underflow = cmd->request_bufflen;
-	cmd->request_buffer = targ->dv_buffer1;
-}
-
-static void
-ahd_linux_dv_su(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
-		struct ahd_devinfo *devinfo,
-		struct ahd_linux_target *targ)
-{
-	u_int le;
-
-	le = SID_IS_REMOVABLE(targ->inq_data) ? SSS_LOEJ : 0;
-
-#ifdef AHD_DEBUG
-	if (ahd_debug & AHD_SHOW_DV) {
-		ahd_print_devinfo(ahd, devinfo);
-		printf("Sending SU\n");
-	}
-#endif
-	ahd_linux_dv_fill_cmd(ahd, cmd, devinfo);
-	cmd->sc_data_direction = SCSI_DATA_NONE;
-	cmd->cmd_len = 6;
-	cmd->cmnd[0] = START_STOP_UNIT;
-	cmd->cmnd[4] = le | SSS_START;
-}
-
-static __inline int
-ahd_linux_dv_fallback(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
-{
-	u_long s;
-	int retval;
-
-	ahd_lock(ahd, &s);
-	retval = ahd_linux_fallback(ahd, devinfo);
-	ahd_unlock(ahd, &s);
-
-	return (retval);
-}
-
-static int
-ahd_linux_fallback(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
-{
-	struct	ahd_linux_target *targ;
-	struct	ahd_initiator_tinfo *tinfo;
-	struct	ahd_transinfo *goal;
-	struct	ahd_tmode_tstate *tstate;
-	u_int	width;
-	u_int	period;
-	u_int	offset;
-	u_int	ppr_options;
-	u_int	cur_speed;
-	u_int	wide_speed;
-	u_int	narrow_speed;
-	u_int	fallback_speed;
-
-#ifdef AHD_DEBUG
-	if (ahd_debug & AHD_SHOW_DV) {
-		ahd_print_devinfo(ahd, devinfo);
-		printf("Trying to fallback\n");
-	}
-#endif
-	targ = ahd->platform_data->targets[devinfo->target_offset];
-	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel,
-				    devinfo->our_scsiid,
-				    devinfo->target, &tstate);
-	goal = &tinfo->goal;
-	width = goal->width;
-	period = goal->period;
-	offset = goal->offset;
-	ppr_options = goal->ppr_options;
-	if (offset == 0)
-		period = AHD_ASYNC_XFER_PERIOD;
-	if (targ->dv_next_narrow_period == 0)
-		targ->dv_next_narrow_period = MAX(period, AHD_SYNCRATE_ULTRA2);
-	if (targ->dv_next_wide_period == 0)
-		targ->dv_next_wide_period = period;
-	if (targ->dv_max_width == 0)
-		targ->dv_max_width = width;
-	if (targ->dv_max_ppr_options == 0)
-		targ->dv_max_ppr_options = ppr_options;
-	if (targ->dv_last_ppr_options == 0)
-		targ->dv_last_ppr_options = ppr_options;
-
-	cur_speed = aic_calc_speed(width, period, offset, AHD_SYNCRATE_MIN);
-	wide_speed = aic_calc_speed(MSG_EXT_WDTR_BUS_16_BIT,
-					  targ->dv_next_wide_period,
-					  MAX_OFFSET, AHD_SYNCRATE_MIN);
-	narrow_speed = aic_calc_speed(MSG_EXT_WDTR_BUS_8_BIT,
-					    targ->dv_next_narrow_period,
-					    MAX_OFFSET, AHD_SYNCRATE_MIN);
-	fallback_speed = aic_calc_speed(width, period+1, offset,
-					      AHD_SYNCRATE_MIN);
-#ifdef AHD_DEBUG
-	if (ahd_debug & AHD_SHOW_DV) {
-		printf("cur_speed= %d, wide_speed= %d, narrow_speed= %d, "
-		       "fallback_speed= %d\n", cur_speed, wide_speed,
-		       narrow_speed, fallback_speed);
-	}
-#endif
-
-	if (cur_speed > 160000) {
-		/*
-		 * Paced/DT/IU_REQ only transfer speeds.  All we
-		 * can do is fallback in terms of syncrate.
-		 */
-		period++;
-	} else if (cur_speed > 80000) {
-		if ((ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
-			/*
-			 * Try without IU_REQ as it may be confusing
-			 * an expander.
-			 */
-			ppr_options &= ~MSG_EXT_PPR_IU_REQ;
-		} else {
-			/*
-			 * Paced/DT only transfer speeds.  All we
-			 * can do is fallback in terms of syncrate.
-			 */
-			period++;
-			ppr_options = targ->dv_max_ppr_options;
-		}
-	} else if (cur_speed > 3300) {
-
-		/*
-		 * In this range we the following
-		 * options ordered from highest to
-		 * lowest desireability:
-		 *
-		 * o Wide/DT
-		 * o Wide/non-DT
-		 * o Narrow at a potentally higher sync rate.
-		 *
-		 * All modes are tested with and without IU_REQ
-		 * set since using IUs may confuse an expander.
-		 */
-		if ((ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
-
-			ppr_options &= ~MSG_EXT_PPR_IU_REQ;
-		} else if ((ppr_options & MSG_EXT_PPR_DT_REQ) != 0) {
-			/*
-			 * Try going non-DT.
-			 */
-			ppr_options = targ->dv_max_ppr_options;
-			ppr_options &= ~MSG_EXT_PPR_DT_REQ;
-		} else if (targ->dv_last_ppr_options != 0) {
-			/*
-			 * Try without QAS or any other PPR options.
-			 * We may need a non-PPR message to work with
-			 * an expander.  We look at the "last PPR options"
-			 * so we will perform this fallback even if the
-			 * target responded to our PPR negotiation with
-			 * no option bits set.
-			 */
-			ppr_options = 0;
-		} else if (width == MSG_EXT_WDTR_BUS_16_BIT) {
-			/*
-			 * If the next narrow speed is greater than
-			 * the next wide speed, fallback to narrow.
-			 * Otherwise fallback to the next DT/Wide setting.
-			 * The narrow async speed will always be smaller
-			 * than the wide async speed, so handle this case
-			 * specifically.
-			 */
-			ppr_options = targ->dv_max_ppr_options;
-			if (narrow_speed > fallback_speed
-			 || period >= AHD_ASYNC_XFER_PERIOD) {
-				targ->dv_next_wide_period = period+1;
-				width = MSG_EXT_WDTR_BUS_8_BIT;
-				period = targ->dv_next_narrow_period;
-			} else {
-				period++;
-			}
-		} else if ((ahd->features & AHD_WIDE) != 0
-			&& targ->dv_max_width != 0
-			&& wide_speed >= fallback_speed
-			&& (targ->dv_next_wide_period <= AHD_ASYNC_XFER_PERIOD
-			 || period >= AHD_ASYNC_XFER_PERIOD)) {
-
-			/*
-			 * We are narrow.  Try falling back
-			 * to the next wide speed with 
-			 * all supported ppr options set.
-			 */
-			targ->dv_next_narrow_period = period+1;
-			width = MSG_EXT_WDTR_BUS_16_BIT;
-			period = targ->dv_next_wide_period;
-			ppr_options = targ->dv_max_ppr_options;
-		} else {
-			/* Only narrow fallback is allowed. */
-			period++;
-			ppr_options = targ->dv_max_ppr_options;
-		}
-	} else {
-		return (-1);
-	}
-	offset = MAX_OFFSET;
-	ahd_find_syncrate(ahd, &period, &ppr_options, AHD_SYNCRATE_PACED);
-	ahd_set_width(ahd, devinfo, width, AHD_TRANS_GOAL, FALSE);
-	if (period == 0) {
-		period = 0;
-		offset = 0;
-		ppr_options = 0;
-		if (width == MSG_EXT_WDTR_BUS_8_BIT)
-			targ->dv_next_narrow_period = AHD_ASYNC_XFER_PERIOD;
-		else
-			targ->dv_next_wide_period = AHD_ASYNC_XFER_PERIOD;
-	}
-	ahd_set_syncrate(ahd, devinfo, period, offset,
-			 ppr_options, AHD_TRANS_GOAL, FALSE);
-	targ->dv_last_ppr_options = ppr_options;
-	return (0);
-}
-
-static void
-ahd_linux_dv_timeout(struct scsi_cmnd *cmd)
-{
-	struct	ahd_softc *ahd;
-	struct	ahd_cmd *acmd;
-	struct	ahd_linux_device *next_dev;
-	struct	scb *scb;
-	u_long	flags;
-
-	ahd = *((struct ahd_softc **)cmd->device->host->hostdata);
-	ahd_lock(ahd, &flags);
-
-#ifdef AHD_DEBUG
-	if (ahd_debug & AHD_SHOW_DV) {
-		printf("%s: Timeout while doing DV command %x.\n",
-		       ahd_name(ahd), cmd->cmnd[0]);
-		ahd_dump_card_state(ahd);
-	}
-#endif
-	
-	/*
-	 * Guard against "done race".  No action is
-	 * required if we just completed.
-	 */
-	if ((scb = (struct scb *)cmd->host_scribble) == NULL) {
-		ahd_unlock(ahd, &flags);
-		return;
-	}
-
-	/*
-	 * Command has not completed.  Mark this
-	 * SCB as having failing status prior to
-	 * resetting the bus, so we get the correct
-	 * error code.
-	 */
-	if ((scb->flags & SCB_SENSE) != 0)
-		ahd_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
-	else
-		ahd_set_transaction_status(scb, CAM_CMD_TIMEOUT);
-	ahd_reset_channel(ahd, cmd->channel + 'A', /*initiate*/TRUE);
-
-	/*
-	 * Add a minimal bus settle delay for devices that are slow to
-	 * respond after bus resets.
-	 */
-	ahd_freeze_simq(ahd);
-	init_timer(&ahd->platform_data->reset_timer);
-	ahd->platform_data->reset_timer.data = (u_long)ahd;
-	ahd->platform_data->reset_timer.expires = jiffies + HZ / 2;
-	ahd->platform_data->reset_timer.function =
-	    (ahd_linux_callback_t *)ahd_release_simq;
-	add_timer(&ahd->platform_data->reset_timer);
-	/*
-	 * In 2.5.X, the "done lock" is the ahd_lock.
-	 * Instead of dropping and re-acquiring the same
-	 * lock in the 2.5.X case, just hold our ahd_lock
-	 * the whole time.  ahd_done_lock() has been
-	 * made a no-op for 2.5.X too.
-	 */
-	acmd = TAILQ_FIRST(&ahd->platform_data->completeq);
-	TAILQ_INIT(&ahd->platform_data->completeq);
-	next_dev = ahd_linux_next_device_to_run(ahd);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	ahd_unlock(ahd, &flags);
-#endif
-	if (next_dev)
-		ahd_schedule_runq(ahd);
-	if (acmd != NULL) {
-		acmd = ahd_linux_run_complete_queue(ahd, acmd);
-		if (acmd != NULL) {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-			ahd_lock(ahd, &flags);
-#endif
-			ahd_schedule_completeq(ahd, acmd);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-			ahd_unlock(ahd, &flags);
-#endif
-		}
-	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-	ahd_unlock(ahd, &flags);
-#endif
-}
-
-static void
-ahd_linux_dv_complete(struct scsi_cmnd *cmd)
-{
-	struct ahd_softc *ahd;
-
-	ahd = *((struct ahd_softc **)cmd->device->host->hostdata);
-
-	/* Delete the DV timer before it goes off! */
-	scsi_delete_timer(cmd);
-
-#ifdef AHD_DEBUG
-	if (ahd_debug & AHD_SHOW_DV)
-		printf("%s:%c:%d: Command completed, status= 0x%x\n",
-		       ahd_name(ahd), cmd->device->channel, cmd->device->id,
-		       cmd->result);
-#endif
-
-	/* Wake up the state machine */
-	up(&ahd->platform_data->dv_cmd_sem);
-}
-
-static void
-ahd_linux_generate_dv_pattern(struct ahd_linux_target *targ)
-{
-	uint16_t b;
-	u_int	 i;
-	u_int	 j;
-
-	if (targ->dv_buffer != NULL)
-		free(targ->dv_buffer, M_DEVBUF);
-	targ->dv_buffer = malloc(targ->dv_echo_size, M_DEVBUF, M_WAITOK);
-	if (targ->dv_buffer1 != NULL)
-		free(targ->dv_buffer1, M_DEVBUF);
-	targ->dv_buffer1 = malloc(targ->dv_echo_size, M_DEVBUF, M_WAITOK);
-
-	i = 0;
-
-	b = 0x0001;
-	for (j = 0 ; i < targ->dv_echo_size; j++) {
-		if (j < 32) {
-			/*
-			 * 32bytes of sequential numbers.
-			 */
-			targ->dv_buffer[i++] = j & 0xff;
-		} else if (j < 48) {
-			/*
-			 * 32bytes of repeating 0x0000, 0xffff.
-			 */
-			targ->dv_buffer[i++] = (j & 0x02) ? 0xff : 0x00;
-		} else if (j < 64) {
-			/*
-			 * 32bytes of repeating 0x5555, 0xaaaa.
-			 */
-			targ->dv_buffer[i++] = (j & 0x02) ? 0xaa : 0x55;
-		} else {
-			/*
-			 * Remaining buffer is filled with a repeating
-			 * patter of:
-			 *
-			 *	 0xffff
-			 *	~0x0001 << shifted once in each loop.
-			 */
-			if (j & 0x02) {
-				if (j & 0x01) {
-					targ->dv_buffer[i++] = ~(b >> 8) & 0xff;
-					b <<= 1;
-					if (b == 0x0000)
-						b = 0x0001;
-				} else {
-					targ->dv_buffer[i++] = (~b & 0xff);
-				}
-			} else {
-				targ->dv_buffer[i++] = 0xff;
-			}
-		}
-	}
-}
-
-static u_int
-ahd_linux_user_tagdepth(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
-{
-	static int warned_user;
-	u_int tags;
-
-	tags = 0;
-	if ((ahd->user_discenable & devinfo->target_mask) != 0) {
-		if (warned_user == 0
-		 && ahd->unit >= NUM_ELEMENTS(aic79xx_tag_info)) {
-
-			printf("aic79xx: WARNING, insufficient "
-			       "tag_info instances for installed "
-			       "controllers. Using defaults\n");
-			printf("aic79xx: Please update the "
-			       "aic79xx_tag_info array in the "
-			       "aic79xx.c source file.\n");
-			tags = AHD_MAX_QUEUE;
-			warned_user++;
-		} else {
-			adapter_tag_info_t *tag_info;
-
-			tag_info = &aic79xx_tag_info[ahd->unit];
-			tags = tag_info->tag_commands[devinfo->target_offset];
-			if (tags > AHD_MAX_QUEUE)
-				tags = AHD_MAX_QUEUE;
-		}
-	}
-	return (tags);
-}
-
-static u_int
-ahd_linux_user_dv_setting(struct ahd_softc *ahd)
-{
-	static int warned_user;
-	int dv;
-
-	if (warned_user == 0
-	 && ahd->unit >= NUM_ELEMENTS(aic79xx_dv_settings)) {
-
-		printf("aic79xx: WARNING, insufficient "
-		       "dv settings instances for installed "
-		       "controllers. Using defaults\n");
-		printf("aic79xx: Please update the "
-		       "aic79xx_dv_settings array in the "
-		       "aic79xx.c source file.\n");
-		dv = -1;
-		warned_user++;
-	} else {
-
-		dv = aic79xx_dv_settings[ahd->unit];
-	}
-
-	if (dv < 0) {
-		/*
-		 * Apply the default.
-		 */
-		dv = 1;
-		if (ahd->seep_config != 0)
-			dv = (ahd->seep_config->bios_control & CFENABLEDV);
-	}
-	return (dv);
-}
-
-/*
- * Determines the queue depth for a given device.
- */
-static void
-ahd_linux_device_queue_depth(struct ahd_softc *ahd,
-			     struct ahd_linux_device *dev)
-{
-	struct	ahd_devinfo devinfo;
-	u_int	tags;
-
-	ahd_compile_devinfo(&devinfo,
-			    ahd->our_id,
-			    dev->target->target, dev->lun,
-			    dev->target->channel == 0 ? 'A' : 'B',
-			    ROLE_INITIATOR);
-	tags = ahd_linux_user_tagdepth(ahd, &devinfo);
-	if (tags != 0
-	 && dev->scsi_device != NULL
-	 && dev->scsi_device->tagged_supported != 0) {
-
-		ahd_set_tags(ahd, &devinfo, AHD_QUEUE_TAGGED);
-		printf("scsi%d:%c:%d:%d: Tagged Queuing enabled.  Depth %d\n",
-	       	       ahd->platform_data->host->host_no, devinfo.channel,
-		       devinfo.target, devinfo.lun, tags);
-	} else {
-		ahd_set_tags(ahd, &devinfo, AHD_QUEUE_NONE);
-	}
-}
-
-static void
-ahd_linux_run_device_queue(struct ahd_softc *ahd, struct ahd_linux_device *dev)
-{
-	struct	 ahd_cmd *acmd;
-	struct	 scsi_cmnd *cmd;
-	struct	 scb *scb;
-	struct	 hardware_scb *hscb;
-	struct	 ahd_initiator_tinfo *tinfo;
-	struct	 ahd_tmode_tstate *tstate;
-	u_int	 col_idx;
-	uint16_t mask;
-
-	if ((dev->flags & AHD_DEV_ON_RUN_LIST) != 0)
-		panic("running device on run list");
-
-	while ((acmd = TAILQ_FIRST(&dev->busyq)) != NULL
-	    && dev->openings > 0 && dev->qfrozen == 0) {
-
-		/*
-		 * Schedule us to run later.  The only reason we are not
-		 * running is because the whole controller Q is frozen.
-		 */
-		if (ahd->platform_data->qfrozen != 0
-		 && AHD_DV_SIMQ_FROZEN(ahd) == 0) {
-
-			TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq,
-					  dev, links);
-			dev->flags |= AHD_DEV_ON_RUN_LIST;
-			return;
-		}
-
-		cmd = &acmd_scsi_cmd(acmd);
-
-		/*
-		 * Get an scb to use.
-		 */
-		tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
-					    cmd->device->id, &tstate);
-		if ((dev->flags & (AHD_DEV_Q_TAGGED|AHD_DEV_Q_BASIC)) == 0
-		 || (tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
-			col_idx = AHD_NEVER_COL_IDX;
-		} else {
-			col_idx = AHD_BUILD_COL_IDX(cmd->device->id,
-						    cmd->device->lun);
-		}
-		if ((scb = ahd_get_scb(ahd, col_idx)) == NULL) {
-			TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq,
-					 dev, links);
-			dev->flags |= AHD_DEV_ON_RUN_LIST;
-			ahd->flags |= AHD_RESOURCE_SHORTAGE;
-			return;
-		}
-		TAILQ_REMOVE(&dev->busyq, acmd, acmd_links.tqe);
-		scb->io_ctx = cmd;
-		scb->platform_data->dev = dev;
-		hscb = scb->hscb;
-		cmd->host_scribble = (char *)scb;
-
-		/*
-		 * Fill out basics of the HSCB.
-		 */
-		hscb->control = 0;
-		hscb->scsiid = BUILD_SCSIID(ahd, cmd);
-		hscb->lun = cmd->lun;
-		scb->hscb->task_management = 0;
-		mask = SCB_GET_TARGET_MASK(ahd, scb);
-
-		if ((ahd->user_discenable & mask) != 0)
-			hscb->control |= DISCENB;
-
-	 	if (AHD_DV_CMD(cmd) != 0)
-			scb->flags |= SCB_SILENT;
-
-		if ((tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0)
-			scb->flags |= SCB_PACKETIZED;
-
-		if ((tstate->auto_negotiate & mask) != 0) {
-			scb->flags |= SCB_AUTO_NEGOTIATE;
-			scb->hscb->control |= MK_MESSAGE;
-		}
-
-		if ((dev->flags & (AHD_DEV_Q_TAGGED|AHD_DEV_Q_BASIC)) != 0) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-			int	msg_bytes;
-			uint8_t tag_msgs[2];
-
-			msg_bytes = scsi_populate_tag_msg(cmd, tag_msgs);
-			if (msg_bytes && tag_msgs[0] != MSG_SIMPLE_TASK) {
-				hscb->control |= tag_msgs[0];
-				if (tag_msgs[0] == MSG_ORDERED_TASK)
-					dev->commands_since_idle_or_otag = 0;
-			} else
-#endif
-			if (dev->commands_since_idle_or_otag == AHD_OTAG_THRESH
-			 && (dev->flags & AHD_DEV_Q_TAGGED) != 0) {
-				hscb->control |= MSG_ORDERED_TASK;
-				dev->commands_since_idle_or_otag = 0;
-			} else {
-				hscb->control |= MSG_SIMPLE_TASK;
-			}
-		}
-
-		hscb->cdb_len = cmd->cmd_len;
-		memcpy(hscb->shared_data.idata.cdb, cmd->cmnd, hscb->cdb_len);
-
-		scb->sg_count = 0;
-		ahd_set_residual(scb, 0);
-		ahd_set_sense_residual(scb, 0);
-		if (cmd->use_sg != 0) {
-			void	*sg;
-			struct	 scatterlist *cur_seg;
-			u_int	 nseg;
-			int	 dir;
-
-			cur_seg = (struct scatterlist *)cmd->request_buffer;
-			dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
-			nseg = pci_map_sg(ahd->dev_softc, cur_seg,
-					  cmd->use_sg, dir);
-			scb->platform_data->xfer_len = 0;
-			for (sg = scb->sg_list; nseg > 0; nseg--, cur_seg++) {
-				bus_addr_t addr;
-				bus_size_t len;
-
-				addr = sg_dma_address(cur_seg);
-				len = sg_dma_len(cur_seg);
-				scb->platform_data->xfer_len += len;
-				sg = ahd_sg_setup(ahd, scb, sg, addr, len,
-						  /*last*/nseg == 1);
-			}
-		} else if (cmd->request_bufflen != 0) {
-			void *sg;
-			bus_addr_t addr;
-			int dir;
-
-			sg = scb->sg_list;
-			dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
-			addr = pci_map_single(ahd->dev_softc,
-					      cmd->request_buffer,
-					      cmd->request_bufflen, dir);
-			scb->platform_data->xfer_len = cmd->request_bufflen;
-			scb->platform_data->buf_busaddr = addr;
-			sg = ahd_sg_setup(ahd, scb, sg, addr,
-					  cmd->request_bufflen, /*last*/TRUE);
-		}
-
-		LIST_INSERT_HEAD(&ahd->pending_scbs, scb, pending_links);
-		dev->openings--;
-		dev->active++;
-		dev->commands_issued++;
-
-		/* Update the error counting bucket and dump if needed */
-		if (dev->target->cmds_since_error) {
-			dev->target->cmds_since_error++;
-			if (dev->target->cmds_since_error >
-			    AHD_LINUX_ERR_THRESH)
-				dev->target->cmds_since_error = 0;
-		}
-
-		if ((dev->flags & AHD_DEV_PERIODIC_OTAG) != 0)
-			dev->commands_since_idle_or_otag++;
-		scb->flags |= SCB_ACTIVE;
-		ahd_queue_scb(ahd, scb);
-	}
-}
-
-/*
- * SCSI controller interrupt handler.
- */
-void
-ahd_linux_isr(int irq, void *dev_id, struct pt_regs * regs)
-{
-	struct	ahd_softc *ahd;
-	struct	ahd_cmd *acmd;
-	u_long	flags;
-	struct	ahd_linux_device *next_dev;
-
-	ahd = (struct ahd_softc *) dev_id;
-	ahd_lock(ahd, &flags); 
-	ahd_intr(ahd);
-	acmd = TAILQ_FIRST(&ahd->platform_data->completeq);
-	TAILQ_INIT(&ahd->platform_data->completeq);
-	next_dev = ahd_linux_next_device_to_run(ahd);
-	/*
-	 * In 2.5.X, the "done lock" is the ahd_lock.
-	 * Instead of dropping and re-acquiring the same
-	 * lock in the 2.5.X case, just hold our ahd_lock
-	 * the whole time.  ahd_done_lock() has been
-	 * made a no-op for 2.5.X too.
-	 */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	ahd_unlock(ahd, &flags);
-#endif
-	if (next_dev)
-		ahd_schedule_runq(ahd);
-	if (acmd != NULL) {
-		acmd = ahd_linux_run_complete_queue(ahd, acmd);
-		if (acmd != NULL) {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-			ahd_lock(ahd, &flags);
-#endif
-			ahd_schedule_completeq(ahd, acmd);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-			ahd_unlock(ahd, &flags);
-#endif
-		}
-	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-	ahd_unlock(ahd, &flags);
-#endif
-}
-
-void
-ahd_platform_flushwork(struct ahd_softc *ahd)
-{
-	struct ahd_cmd *acmd;
-
-	acmd = TAILQ_FIRST(&ahd->platform_data->completeq);
-	TAILQ_INIT(&ahd->platform_data->completeq);
-	while (acmd != NULL)
-		acmd = ahd_linux_run_complete_queue(ahd, acmd);
-}
-
-static struct ahd_linux_target*
-ahd_linux_alloc_target(struct ahd_softc *ahd, u_int channel, u_int target)
-{
-	struct ahd_linux_target *targ;
-	u_int target_offset;
-
-	target_offset = target;
-	/*
-	 * Never allow allocation of a target object for
-	 * our own SCSIID.
-	 */
-	if (target == ahd->our_id) {
-		ahd->platform_data->targets[target_offset] = NULL;
-		return (NULL);
-	}
-
-	targ = malloc(sizeof(*targ), M_DEVBUF, M_NOWAIT);
-	if (targ == NULL)
-		return (NULL);
-	memset(targ, 0, sizeof(*targ));
-	targ->channel = channel;
-	targ->target = target;
-	targ->ahd = ahd;
-	targ->flags = AHD_DV_REQUIRED;
-	ahd->platform_data->targets[target_offset] = targ;
-	return (targ);
-}
-
-static void
-ahd_linux_free_target(struct ahd_softc *ahd, struct ahd_linux_target *targ)
-{
-	struct ahd_devinfo devinfo;
-	struct ahd_initiator_tinfo *tinfo;
-	struct ahd_tmode_tstate *tstate;
-	u_int our_id;
-	u_int target_offset;
-	char channel;
-
-	/*
-	 * Force a negotiation to async/narrow on any
-	 * future command to this device unless a bus
-	 * reset occurs between now and that command.
-	 */
-	channel = 'A' + targ->channel;
-	our_id = ahd->our_id;
-	target_offset = targ->target;
-	tinfo = ahd_fetch_transinfo(ahd, channel, our_id,
-				    targ->target, &tstate);
-	ahd_compile_devinfo(&devinfo, our_id, targ->target, CAM_LUN_WILDCARD,
-			    channel, ROLE_INITIATOR);
-	ahd_set_syncrate(ahd, &devinfo, 0, 0, 0,
-			 AHD_TRANS_GOAL, /*paused*/FALSE);
-	ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
-		      AHD_TRANS_GOAL, /*paused*/FALSE);
-	ahd_update_neg_request(ahd, &devinfo, tstate, tinfo, AHD_NEG_ALWAYS);
- 	ahd->platform_data->targets[target_offset] = NULL;
-	if (targ->inq_data != NULL)
-		free(targ->inq_data, M_DEVBUF);
-	if (targ->dv_buffer != NULL)
-		free(targ->dv_buffer, M_DEVBUF);
-	if (targ->dv_buffer1 != NULL)
-		free(targ->dv_buffer1, M_DEVBUF);
-	free(targ, M_DEVBUF);
-}
-
-static struct ahd_linux_device*
-ahd_linux_alloc_device(struct ahd_softc *ahd,
-		 struct ahd_linux_target *targ, u_int lun)
-{
-	struct ahd_linux_device *dev;
-
-	dev = malloc(sizeof(*dev), M_DEVBUG, M_NOWAIT);
-	if (dev == NULL)
-		return (NULL);
-	memset(dev, 0, sizeof(*dev));
-	init_timer(&dev->timer);
-	TAILQ_INIT(&dev->busyq);
-	dev->flags = AHD_DEV_UNCONFIGURED;
-	dev->lun = lun;
-	dev->target = targ;
-
-	/*
-	 * We start out life using untagged
-	 * transactions of which we allow one.
-	 */
-	dev->openings = 1;
-
-	/*
-	 * Set maxtags to 0.  This will be changed if we
-	 * later determine that we are dealing with
-	 * a tagged queuing capable device.
-	 */
-	dev->maxtags = 0;
-	
-	targ->refcount++;
-	targ->devices[lun] = dev;
-	return (dev);
-}
-
-static void
-ahd_linux_free_device(struct ahd_softc *ahd, struct ahd_linux_device *dev)
-{
-	struct ahd_linux_target *targ;
-
-	del_timer(&dev->timer);
-	targ = dev->target;
-	targ->devices[dev->lun] = NULL;
-	free(dev, M_DEVBUF);
-	targ->refcount--;
-	if (targ->refcount == 0
-	 && (targ->flags & AHD_DV_REQUIRED) == 0)
-		ahd_linux_free_target(ahd, targ);
-}
-
-void
-ahd_send_async(struct ahd_softc *ahd, char channel,
-	       u_int target, u_int lun, ac_code code, void *arg)
-{
-	switch (code) {
-	case AC_TRANSFER_NEG:
-	{
-		char	buf[80];
-		struct	ahd_linux_target *targ;
-		struct	info_str info;
-		struct	ahd_initiator_tinfo *tinfo;
-		struct	ahd_tmode_tstate *tstate;
-
-		info.buffer = buf;
-		info.length = sizeof(buf);
-		info.offset = 0;
-		info.pos = 0;
-		tinfo = ahd_fetch_transinfo(ahd, channel, ahd->our_id,
-					    target, &tstate);
-
-		/*
-		 * Don't bother reporting results while
-		 * negotiations are still pending.
-		 */
-		if (tinfo->curr.period != tinfo->goal.period
-		 || tinfo->curr.width != tinfo->goal.width
-		 || tinfo->curr.offset != tinfo->goal.offset
-		 || tinfo->curr.ppr_options != tinfo->goal.ppr_options)
-			if (bootverbose == 0)
-				break;
-
-		/*
-		 * Don't bother reporting results that
-		 * are identical to those last reported.
-		 */
-		targ = ahd->platform_data->targets[target];
-		if (targ == NULL)
-			break;
-		if (tinfo->curr.period == targ->last_tinfo.period
-		 && tinfo->curr.width == targ->last_tinfo.width
-		 && tinfo->curr.offset == targ->last_tinfo.offset
-		 && tinfo->curr.ppr_options == targ->last_tinfo.ppr_options)
-			if (bootverbose == 0)
-				break;
-
-		targ->last_tinfo.period = tinfo->curr.period;
-		targ->last_tinfo.width = tinfo->curr.width;
-		targ->last_tinfo.offset = tinfo->curr.offset;
-		targ->last_tinfo.ppr_options = tinfo->curr.ppr_options;
-
-		printf("(%s:%c:", ahd_name(ahd), channel);
-		if (target == CAM_TARGET_WILDCARD)
-			printf("*): ");
-		else
-			printf("%d): ", target);
-		ahd_format_transinfo(&info, &tinfo->curr);
-		if (info.pos < info.length)
-			*info.buffer = '\0';
-		else
-			buf[info.length - 1] = '\0';
-		printf("%s", buf);
-		break;
-	}
-        case AC_SENT_BDR:
-	{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-		Scsi_Device *scsi_dev;
-
-		/*
-		 * Find the SCSI device associated with this
-		 * request and indicate that a UA is expected.
-		 * XXX This should really be handled by the mid-layer.
-		 */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-		list_for_each_entry(scsi_dev,
-				    &ahd->platform_data->host->my_devices,
-				    siblings) {
-#else
-		for (scsi_dev = ahd->platform_data->host->host_queue;
-		     scsi_dev != NULL; scsi_dev = scsi_dev->next) {
-#endif
-			if (channel - 'A' == scsi_dev->channel
-			 && target == scsi_dev->id
-			 && (lun == CAM_LUN_WILDCARD
-			  || lun == scsi_dev->lun)) {
-				scsi_dev->was_reset = 1;
-				scsi_dev->expecting_cc_ua = 1;
-			}
-		}
-#endif
-		break;
-	}
-        case AC_BUS_RESET:
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-		if (ahd->platform_data->host != NULL) {
-			scsi_report_bus_reset(ahd->platform_data->host,
-					      channel - 'A');
-		}
-#endif
-                break;
-        default:
-                panic("ahd_send_async: Unexpected async event");
-        }
-}
-
-/*
- * Calls the higher level scsi done function and frees the scb.
- */
-void
-ahd_done(struct ahd_softc *ahd, struct scb *scb)
-{
-	Scsi_Cmnd *cmd;
-	struct	  ahd_linux_device *dev;
-
-	LIST_REMOVE(scb, pending_links);
-
-	if ((scb->flags & SCB_ACTIVE) == 0) {
-		printf("SCB %d done'd twice\n", scb->hscb->tag);
-		ahd_dump_card_state(ahd);
-		panic("Stopping for safety");
-	}
-	cmd = scb->io_ctx;
-	dev = scb->platform_data->dev;
-	dev->active--;
-	dev->openings++;
-	if ((cmd->result & (CAM_DEV_QFRZN << 16)) != 0) {
-		cmd->result &= ~(CAM_DEV_QFRZN << 16);
-		dev->qfrozen--;
-	}
-	ahd_linux_unmap_scb(ahd, scb);
-
-	/*
-	 * Guard against stale sense data.
-	 * The Linux mid-layer assumes that sense
-	 * was retrieved anytime the first byte of
-	 * the sense buffer looks "sane".
-	 */
-	cmd->sense_buffer[0] = 0;
-	if (ahd_get_transaction_status(scb) == CAM_REQ_INPROG) {
-		uint32_t amount_xferred;
-
-		amount_xferred =
-		    ahd_get_transfer_length(scb) - ahd_get_residual(scb);
-		if ((scb->flags & SCB_TRANSMISSION_ERROR) != 0) {
-#ifdef AHD_DEBUG
-			if ((ahd_debug & AHD_SHOW_MISC) != 0) {
-				ahd_print_path(ahd, scb);
-				printf("Set CAM_UNCOR_PARITY\n");
-			}
-#endif
-			ahd_set_transaction_status(scb, CAM_UNCOR_PARITY);
-		} else if (amount_xferred < scb->io_ctx->underflow) {
-			printf("Saw underflow (%ld of %ld bytes). "
-			       "Treated as error\n",
-				ahd_get_residual(scb),
-				ahd_get_transfer_length(scb));
-			ahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);
-		} else {
-			ahd_set_transaction_status(scb, CAM_REQ_CMP);
-		}
-	} else if (ahd_get_transaction_status(scb) == CAM_SCSI_STATUS_ERROR) {
-		ahd_linux_handle_scsi_status(ahd, dev, scb);
-	} else if (ahd_get_transaction_status(scb) == CAM_SEL_TIMEOUT) {
-		dev->flags |= AHD_DEV_UNCONFIGURED;
-		if (AHD_DV_CMD(cmd) == FALSE)
-			dev->target->flags &= ~AHD_DV_REQUIRED;
-	}
-	/*
-	 * Start DV for devices that require it assuming the first command
-	 * sent does not result in a selection timeout.
-	 */
-	if (ahd_get_transaction_status(scb) != CAM_SEL_TIMEOUT
-	 && (dev->target->flags & AHD_DV_REQUIRED) != 0)
-		ahd_linux_start_dv(ahd);
-
-	if (dev->openings == 1
-	 && ahd_get_transaction_status(scb) == CAM_REQ_CMP
-	 && ahd_get_scsi_status(scb) != SCSI_STATUS_QUEUE_FULL)
-		dev->tag_success_count++;
-	/*
-	 * Some devices deal with temporary internal resource
-	 * shortages by returning queue full.  When the queue
-	 * full occurrs, we throttle back.  Slowly try to get
-	 * back to our previous queue depth.
-	 */
-	if ((dev->openings + dev->active) < dev->maxtags
-	 && dev->tag_success_count > AHD_TAG_SUCCESS_INTERVAL) {
-		dev->tag_success_count = 0;
-		dev->openings++;
-	}
-
-	if (dev->active == 0)
-		dev->commands_since_idle_or_otag = 0;
-
-	if (TAILQ_EMPTY(&dev->busyq)) {
-		if ((dev->flags & AHD_DEV_UNCONFIGURED) != 0
-		 && dev->active == 0)
-			ahd_linux_free_device(ahd, dev);
-	} else if ((dev->flags & AHD_DEV_ON_RUN_LIST) == 0) {
-		TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq, dev, links);
-		dev->flags |= AHD_DEV_ON_RUN_LIST;
-	}
-
-	if ((scb->flags & SCB_RECOVERY_SCB) != 0) {
-		printf("Recovery SCB completes\n");
-		if (ahd_get_transaction_status(scb) == CAM_BDR_SENT
-		 || ahd_get_transaction_status(scb) == CAM_REQ_ABORTED)
-			ahd_set_transaction_status(scb, CAM_CMD_TIMEOUT);
-		if ((ahd->platform_data->flags & AHD_UP_EH_SEMAPHORE) != 0) {
-			ahd->platform_data->flags &= ~AHD_UP_EH_SEMAPHORE;
-			up(&ahd->platform_data->eh_sem);
-		}
-	}
-
-	ahd_free_scb(ahd, scb);
-	ahd_linux_queue_cmd_complete(ahd, cmd);
-
-	if ((ahd->platform_data->flags & AHD_DV_WAIT_SIMQ_EMPTY) != 0
-	 && LIST_FIRST(&ahd->pending_scbs) == NULL) {
-		ahd->platform_data->flags &= ~AHD_DV_WAIT_SIMQ_EMPTY;
-		up(&ahd->platform_data->dv_sem);
-	}
-}
-
-static void
-ahd_linux_handle_scsi_status(struct ahd_softc *ahd,
-			     struct ahd_linux_device *dev, struct scb *scb)
-{
-	struct	ahd_devinfo devinfo;
-
-	ahd_compile_devinfo(&devinfo,
-			    ahd->our_id,
-			    dev->target->target, dev->lun,
-			    dev->target->channel == 0 ? 'A' : 'B',
-			    ROLE_INITIATOR);
-	
-	/*
-	 * We don't currently trust the mid-layer to
-	 * properly deal with queue full or busy.  So,
-	 * when one occurs, we tell the mid-layer to
-	 * unconditionally requeue the command to us
-	 * so that we can retry it ourselves.  We also
-	 * implement our own throttling mechanism so
-	 * we don't clobber the device with too many
-	 * commands.
-	 */
-	switch (ahd_get_scsi_status(scb)) {
-	default:
-		break;
-	case SCSI_STATUS_CHECK_COND:
-	case SCSI_STATUS_CMD_TERMINATED:
-	{
-		Scsi_Cmnd *cmd;
-
-		/*
-		 * Copy sense information to the OS's cmd
-		 * structure if it is available.
-		 */
-		cmd = scb->io_ctx;
-		if ((scb->flags & (SCB_SENSE|SCB_PKT_SENSE)) != 0) {
-			struct scsi_status_iu_header *siu;
-			u_int sense_size;
-			u_int sense_offset;
-
-			if (scb->flags & SCB_SENSE) {
-				sense_size = MIN(sizeof(struct scsi_sense_data)
-					       - ahd_get_sense_residual(scb),
-						 sizeof(cmd->sense_buffer));
-				sense_offset = 0;
-			} else {
-				/*
-				 * Copy only the sense data into the provided
-				 * buffer.
-				 */
-				siu = (struct scsi_status_iu_header *)
-				    scb->sense_data;
-				sense_size = MIN(scsi_4btoul(siu->sense_length),
-						sizeof(cmd->sense_buffer));
-				sense_offset = SIU_SENSE_OFFSET(siu);
-			}
-
-			memset(cmd->sense_buffer, 0, sizeof(cmd->sense_buffer));
-			memcpy(cmd->sense_buffer,
-			       ahd_get_sense_buf(ahd, scb)
-			       + sense_offset, sense_size);
-			cmd->result |= (DRIVER_SENSE << 24);
-
-#ifdef AHD_DEBUG
-			if (ahd_debug & AHD_SHOW_SENSE) {
-				int i;
-
-				printf("Copied %d bytes of sense data at %d:",
-				       sense_size, sense_offset);
-				for (i = 0; i < sense_size; i++) {
-					if ((i & 0xF) == 0)
-						printf("\n");
-					printf("0x%x ", cmd->sense_buffer[i]);
-				}
-				printf("\n");
-			}
-#endif
-		}
-		break;
-	}
-	case SCSI_STATUS_QUEUE_FULL:
-	{
-		/*
-		 * By the time the core driver has returned this
-		 * command, all other commands that were queued
-		 * to us but not the device have been returned.
-		 * This ensures that dev->active is equal to
-		 * the number of commands actually queued to
-		 * the device.
-		 */
-		dev->tag_success_count = 0;
-		if (dev->active != 0) {
-			/*
-			 * Drop our opening count to the number
-			 * of commands currently outstanding.
-			 */
-			dev->openings = 0;
-#ifdef AHD_DEBUG
-			if (ahd_debug & AHD_SHOW_QFULL) {
-				ahd_print_path(ahd, scb);
-				printf("Dropping tag count to %d\n",
-				       dev->active);
-			}
-#endif
-			if (dev->active == dev->tags_on_last_queuefull) {
-
-				dev->last_queuefull_same_count++;
-				/*
-				 * If we repeatedly see a queue full
-				 * at the same queue depth, this
-				 * device has a fixed number of tag
-				 * slots.  Lock in this tag depth
-				 * so we stop seeing queue fulls from
-				 * this device.
-				 */
-				if (dev->last_queuefull_same_count
-				 == AHD_LOCK_TAGS_COUNT) {
-					dev->maxtags = dev->active;
-					ahd_print_path(ahd, scb);
-					printf("Locking max tag count at %d\n",
-					       dev->active);
-				}
-			} else {
-				dev->tags_on_last_queuefull = dev->active;
-				dev->last_queuefull_same_count = 0;
-			}
-			ahd_set_transaction_status(scb, CAM_REQUEUE_REQ);
-			ahd_set_scsi_status(scb, SCSI_STATUS_OK);
-			ahd_set_tags(ahd, &devinfo,
-				     (dev->flags & AHD_DEV_Q_BASIC)
-				   ? AHD_QUEUE_BASIC : AHD_QUEUE_TAGGED);
-			break;
-		}
-		/*
-		 * Drop down to a single opening, and treat this
-		 * as if the target returned BUSY SCSI status.
-		 */
-		dev->openings = 1;
-		ahd_set_tags(ahd, &devinfo,
-			     (dev->flags & AHD_DEV_Q_BASIC)
-			   ? AHD_QUEUE_BASIC : AHD_QUEUE_TAGGED);
-		ahd_set_scsi_status(scb, SCSI_STATUS_BUSY);
-		/* FALLTHROUGH */
-	}
-	case SCSI_STATUS_BUSY:
-		/*
-		 * Set a short timer to defer sending commands for
-		 * a bit since Linux will not delay in this case.
-		 */
-		if ((dev->flags & AHD_DEV_TIMER_ACTIVE) != 0) {
-			printf("%s:%c:%d: Device Timer still active during "
-			       "busy processing\n", ahd_name(ahd),
-				dev->target->channel, dev->target->target);
-			break;
-		}
-		dev->flags |= AHD_DEV_TIMER_ACTIVE;
-		dev->qfrozen++;
-		init_timer(&dev->timer);
-		dev->timer.data = (u_long)dev;
-		dev->timer.expires = jiffies + (HZ/2);
-		dev->timer.function = ahd_linux_dev_timed_unfreeze;
-		add_timer(&dev->timer);
-		break;
-	}
-}
-
-static void
-ahd_linux_queue_cmd_complete(struct ahd_softc *ahd, Scsi_Cmnd *cmd)
-{
-	/*
-	 * Typically, the complete queue has very few entries
-	 * queued to it before the queue is emptied by
-	 * ahd_linux_run_complete_queue, so sorting the entries
-	 * by generation number should be inexpensive.
-	 * We perform the sort so that commands that complete
-	 * with an error are retuned in the order origionally
-	 * queued to the controller so that any subsequent retries
-	 * are performed in order.  The underlying ahd routines do
-	 * not guarantee the order that aborted commands will be
-	 * returned to us.
-	 */
-	struct ahd_completeq *completeq;
-	struct ahd_cmd *list_cmd;
-	struct ahd_cmd *acmd;
-
-	/*
-	 * Map CAM error codes into Linux Error codes.  We
-	 * avoid the conversion so that the DV code has the
-	 * full error information available when making
-	 * state change decisions.
-	 */
-	if (AHD_DV_CMD(cmd) == FALSE) {
-		uint32_t status;
-		u_int new_status;
-
-		status = ahd_cmd_get_transaction_status(cmd);
-		if (status != CAM_REQ_CMP) {
-			struct ahd_linux_device *dev;
-			struct ahd_devinfo devinfo;
-			cam_status cam_status;
-			uint32_t action;
-			u_int scsi_status;
-
-			dev = ahd_linux_get_device(ahd, cmd->channel,
-						   cmd->device->id,
-						   cmd->device->lun,
-						   /*alloc*/FALSE);
-
-			if (dev == NULL)
-				goto no_fallback;
-
-			ahd_compile_devinfo(&devinfo,
-					    ahd->our_id,
-					    dev->target->target, dev->lun,
-					    dev->target->channel == 0 ? 'A':'B',
-					    ROLE_INITIATOR);
-
-			scsi_status = ahd_cmd_get_scsi_status(cmd);
-			cam_status = ahd_cmd_get_transaction_status(cmd);
-			action = aic_error_action(cmd, dev->target->inq_data,
-						  cam_status, scsi_status);
-			if ((action & SSQ_FALLBACK) != 0) {
-
-				/* Update stats */
-				dev->target->errors_detected++;
-				if (dev->target->cmds_since_error == 0)
-					dev->target->cmds_since_error++;
-				else {
-					dev->target->cmds_since_error = 0;
-					ahd_linux_fallback(ahd, &devinfo);
-				}
-			}
-		}
-no_fallback:
-		switch (status) {
-		case CAM_REQ_INPROG:
-		case CAM_REQ_CMP:
-		case CAM_SCSI_STATUS_ERROR:
-			new_status = DID_OK;
-			break;
-		case CAM_REQ_ABORTED:
-			new_status = DID_ABORT;
-			break;
-		case CAM_BUSY:
-			new_status = DID_BUS_BUSY;
-			break;
-		case CAM_REQ_INVALID:
-		case CAM_PATH_INVALID:
-			new_status = DID_BAD_TARGET;
-			break;
-		case CAM_SEL_TIMEOUT:
-			new_status = DID_NO_CONNECT;
-			break;
-		case CAM_SCSI_BUS_RESET:
-		case CAM_BDR_SENT:
-			new_status = DID_RESET;
-			break;
-		case CAM_UNCOR_PARITY:
-			new_status = DID_PARITY;
-			break;
-		case CAM_CMD_TIMEOUT:
-			new_status = DID_TIME_OUT;
-			break;
-		case CAM_UA_ABORT:
-		case CAM_REQ_CMP_ERR:
-		case CAM_AUTOSENSE_FAIL:
-		case CAM_NO_HBA:
-		case CAM_DATA_RUN_ERR:
-		case CAM_UNEXP_BUSFREE:
-		case CAM_SEQUENCE_FAIL:
-		case CAM_CCB_LEN_ERR:
-		case CAM_PROVIDE_FAIL:
-		case CAM_REQ_TERMIO:
-		case CAM_UNREC_HBA_ERROR:
-		case CAM_REQ_TOO_BIG:
-			new_status = DID_ERROR;
-			break;
-		case CAM_REQUEUE_REQ:
-			/*
-			 * If we want the request requeued, make sure there
-			 * are sufficent retries.  In the old scsi error code,
-			 * we used to be able to specify a result code that
-			 * bypassed the retry count.  Now we must use this
-			 * hack.  We also "fake" a check condition with
-			 * a sense code of ABORTED COMMAND.  This seems to
-			 * evoke a retry even if this command is being sent
-			 * via the eh thread.  Ick!  Ick!  Ick!
-			 */
-			if (cmd->retries > 0)
-				cmd->retries--;
-			new_status = DID_OK;
-			ahd_cmd_set_scsi_status(cmd, SCSI_STATUS_CHECK_COND);
-			cmd->result |= (DRIVER_SENSE << 24);
-			memset(cmd->sense_buffer, 0,
-			       sizeof(cmd->sense_buffer));
-			cmd->sense_buffer[0] = SSD_ERRCODE_VALID
-					     | SSD_CURRENT_ERROR;
-			cmd->sense_buffer[2] = SSD_KEY_ABORTED_COMMAND;
-			break;
-		default:
-			/* We should never get here */
-			new_status = DID_ERROR;
-			break;
-		}
-
-		ahd_cmd_set_transaction_status(cmd, new_status);
-	}
-
-	completeq = &ahd->platform_data->completeq;
-	list_cmd = TAILQ_FIRST(completeq);
-	acmd = (struct ahd_cmd *)cmd;
-	while (list_cmd != NULL
-	    && acmd_scsi_cmd(list_cmd).serial_number
-	     < acmd_scsi_cmd(acmd).serial_number)
-		list_cmd = TAILQ_NEXT(list_cmd, acmd_links.tqe);
-	if (list_cmd != NULL)
-		TAILQ_INSERT_BEFORE(list_cmd, acmd, acmd_links.tqe);
-	else
-		TAILQ_INSERT_TAIL(completeq, acmd, acmd_links.tqe);
-}
-
-static void
-ahd_linux_filter_inquiry(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
-{
-	struct	scsi_inquiry_data *sid;
-	struct	ahd_initiator_tinfo *tinfo;
-	struct	ahd_transinfo *user;
-	struct	ahd_transinfo *goal;
-	struct	ahd_transinfo *curr;
-	struct	ahd_tmode_tstate *tstate;
-	struct	ahd_linux_device *dev;
-	u_int	width;
-	u_int	period;
-	u_int	offset;
-	u_int	ppr_options;
-	u_int	trans_version;
-	u_int	prot_version;
-	static	int warned_user;
-
-	/*
-	 * Determine if this lun actually exists.  If so,
-	 * hold on to its corresponding device structure.
-	 * If not, make sure we release the device and
-	 * don't bother processing the rest of this inquiry
-	 * command.
-	 */
-	dev = ahd_linux_get_device(ahd, devinfo->channel - 'A',
-				   devinfo->target, devinfo->lun,
-				   /*alloc*/TRUE);
-
-	sid = (struct scsi_inquiry_data *)dev->target->inq_data;
-	if (SID_QUAL(sid) == SID_QUAL_LU_CONNECTED) {
-
-		dev->flags &= ~AHD_DEV_UNCONFIGURED;
-	} else {
-		dev->flags |= AHD_DEV_UNCONFIGURED;
-		return;
-	}
-
-	/*
-	 * Update our notion of this device's transfer
-	 * negotiation capabilities.
-	 */
-	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel,
-				    devinfo->our_scsiid,
-				    devinfo->target, &tstate);
-	user = &tinfo->user;
-	goal = &tinfo->goal;
-	curr = &tinfo->curr;
-	width = user->width;
-	period = user->period;
-	offset = user->offset;
-	ppr_options = user->ppr_options;
-	trans_version = user->transport_version;
-	prot_version = MIN(user->protocol_version, SID_ANSI_REV(sid));
-
-	/*
-	 * If we have read streaming info for this controller,
-	 * apply it to this target.
-	 */
-	if (warned_user == 0
-	 && ahd->unit >= NUM_ELEMENTS(aic79xx_rd_strm_info)) {
-
-		printf("aic79xx: WARNING, insufficient rd_strm instances "
-		       "for installed controllers. Using defaults\n");
-		printf("aic79xx: Please update the aic79xx_rd_strm_info "
-		       "array in the aic79xx_osm.c source file.\n");
-		warned_user++;
-	} else {
-		uint16_t rd_strm_mask;
-
-		rd_strm_mask = aic79xx_rd_strm_info[ahd->unit];
-		if ((rd_strm_mask & devinfo->target_mask) == 0)
-			ppr_options &= ~MSG_EXT_PPR_RD_STRM;
-	}
-	
-	/*
-	 * Only attempt SPI3/4 once we've verified that
-	 * the device claims to support SPI3/4 features.
-	 */
-	if (prot_version < SCSI_REV_2)
-		trans_version = SID_ANSI_REV(sid);
-	else
-		trans_version = SCSI_REV_2;
-
-	if ((sid->flags & SID_WBus16) == 0)
-		width = MSG_EXT_WDTR_BUS_8_BIT;
-	if ((sid->flags & SID_Sync) == 0) {
-		period = 0;
-		offset = 0;
-		ppr_options = 0;
-	}
-	if ((sid->spi3data & SID_SPI_QAS) == 0)
-		ppr_options &= ~MSG_EXT_PPR_QAS_REQ;
-	if ((sid->spi3data & SID_SPI_CLOCK_DT) == 0)
-		ppr_options &= MSG_EXT_PPR_QAS_REQ;
-	if ((sid->spi3data & SID_SPI_IUS) == 0)
-		ppr_options &= (MSG_EXT_PPR_DT_REQ
-			      | MSG_EXT_PPR_QAS_REQ);
-
-	if (prot_version > SCSI_REV_2
-	 && ppr_options != 0)
-		trans_version = user->transport_version;
-
-	ahd_validate_width(ahd, /*tinfo limit*/NULL, &width, ROLE_UNKNOWN);
-	ahd_find_syncrate(ahd, &period, &ppr_options, AHD_SYNCRATE_MAX);
-	ahd_validate_offset(ahd, /*tinfo limit*/NULL, period,
-			    &offset, width, ROLE_UNKNOWN);
-	if (offset == 0 || period == 0) {
-		period = 0;
-		offset = 0;
-		ppr_options = 0;
-	}
-	/* Apply our filtered user settings. */
-	curr->transport_version = trans_version;
-	curr->protocol_version = prot_version;
-	ahd_set_width(ahd, devinfo, width, AHD_TRANS_GOAL, /*paused*/FALSE);
-	ahd_set_syncrate(ahd, devinfo, period, offset, ppr_options,
-			 AHD_TRANS_GOAL, /*paused*/FALSE);
-}
-
-void
-ahd_freeze_simq(struct ahd_softc *ahd)
-{
-	ahd->platform_data->qfrozen++;
-	if (ahd->platform_data->qfrozen == 1) {
-		scsi_block_requests(ahd->platform_data->host);
-		ahd_platform_abort_scbs(ahd, CAM_TARGET_WILDCARD, ALL_CHANNELS,
-					CAM_LUN_WILDCARD, SCB_LIST_NULL,
-					ROLE_INITIATOR, CAM_REQUEUE_REQ);
-	}
-}
-
-void
-ahd_release_simq(struct ahd_softc *ahd)
-{
-	u_long s;
-	int    unblock_reqs;
-
-	unblock_reqs = 0;
-	ahd_lock(ahd, &s);
-	if (ahd->platform_data->qfrozen > 0)
-		ahd->platform_data->qfrozen--;
-	if (ahd->platform_data->qfrozen == 0) {
-		unblock_reqs = 1;
-	}
-	if (AHD_DV_SIMQ_FROZEN(ahd)
-	 && ((ahd->platform_data->flags & AHD_DV_WAIT_SIMQ_RELEASE) != 0)) {
-		ahd->platform_data->flags &= ~AHD_DV_WAIT_SIMQ_RELEASE;
-		up(&ahd->platform_data->dv_sem);
-	}
-	ahd_unlock(ahd, &s);
-	/*
-	 * There is still a race here.  The mid-layer
-	 * should keep its own freeze count and use
-	 * a bottom half handler to run the queues
-	 * so we can unblock with our own lock held.
-	 */
-	if (unblock_reqs)
-		scsi_unblock_requests(ahd->platform_data->host);
-
-	ahd_schedule_runq(ahd);
-}
-
-static void
-ahd_linux_sem_timeout(u_long arg)
-{
-	struct	ahd_softc *ahd;
-	u_long	s;
-
-	ahd = (struct ahd_softc *)arg;
-	ahd_lock(ahd, &s);
-	if ((ahd->platform_data->flags & AHD_UP_EH_SEMAPHORE) != 0) {
-		ahd->platform_data->flags &= ~AHD_UP_EH_SEMAPHORE;
-		up(&ahd->platform_data->eh_sem);
-	}
-	ahd_unlock(ahd, &s);
-}
-
-static void
-ahd_linux_dev_timed_unfreeze(u_long arg)
-{
-	struct ahd_linux_device *dev;
-	struct ahd_softc *ahd;
-	u_long s;
-
-	dev = (struct ahd_linux_device *)arg;
-	ahd = dev->target->ahd;
-	ahd_lock(ahd, &s);
-	dev->flags &= ~AHD_DEV_TIMER_ACTIVE;
-	if (dev->qfrozen > 0)
-		dev->qfrozen--;
-	if (dev->qfrozen == 0
-	 && (dev->flags & AHD_DEV_ON_RUN_LIST) == 0)
-		ahd_linux_run_device_queue(ahd, dev);
-	ahd_unlock(ahd, &s);
-}
-
-void
-ahd_platform_dump_card_state(struct ahd_softc *ahd)
-{
-	struct ahd_linux_device *dev;
-	int target;
-	int maxtarget;
-	int lun;
-	int i;
-
-	maxtarget = (ahd->features & AHD_WIDE) ? 15 : 7;
-	for (target = 0; target <=maxtarget; target++) {
-
-		for (lun = 0; lun < AHD_NUM_LUNS; lun++) {
-			struct ahd_cmd *acmd;
-
-			dev = ahd_linux_get_device(ahd, 0, target,
-						   lun, /*alloc*/FALSE);
-			if (dev == NULL)
-				continue;
-
-			printf("DevQ(%d:%d:%d): ", 0, target, lun);
-			i = 0;
-			TAILQ_FOREACH(acmd, &dev->busyq, acmd_links.tqe) {
-				if (i++ > AHD_SCB_MAX)
-					break;
-			}
-			printf("%d waiting\n", i);
-		}
-	}
-}
diff -urNp linux-5720/drivers/scsi/aic79xx/aic79xx_osm.h linux-5730/drivers/scsi/aic79xx/aic79xx_osm.h
--- linux-5720/drivers/scsi/aic79xx/aic79xx_osm.h
+++ linux-5730/drivers/scsi/aic79xx/aic79xx_osm.h
@@ -1,1288 +0,0 @@
-/*
- * Adaptec AIC79xx device driver for Linux.
- *
- * Copyright (c) 2000-2001 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#108 $
- *
- */
-#ifndef _AIC79XX_LINUX_H_
-#define _AIC79XX_LINUX_H_
-
-#include <linux/types.h>
-#include <linux/blk.h>
-#include <linux/blkdev.h>
-#include <linux/delay.h>
-#include <linux/ioport.h>
-#include <linux/pci.h>
-#include <linux/smp_lock.h>
-#include <linux/version.h>
-#ifndef AHD_MODVERSION_FILE
-#define __NO_VERSION__
-#endif
-#include <linux/module.h>
-#include <asm/byteorder.h>
-#include <asm/io.h>
-
-#ifndef KERNEL_VERSION
-#define KERNEL_VERSION(x,y,z) (((x)<<16)+((y)<<8)+(z))
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-#include <linux/interrupt.h> /* For tasklet support. */
-#include <linux/config.h>
-#include <linux/slab.h>
-#else
-#include <linux/malloc.h>
-#endif
-
-/* Core SCSI definitions */
-#define AIC_LIB_PREFIX ahd
-#include "scsi.h"
-#include "hosts.h"
-
-/* Name space conflict with BSD queue macros */
-#ifdef LIST_HEAD
-#undef LIST_HEAD
-#endif
-
-#include "cam.h"
-#include "queue.h"
-#include "scsi_message.h"
-#include "scsi_iu.h"
-#include "aiclib.h"
-
-/*********************************** Debugging ********************************/
-#ifdef CONFIG_AIC79XX_DEBUG_ENABLE
-#ifdef CONFIG_AIC79XX_DEBUG_MASK
-#define AHD_DEBUG 1
-#define AHD_DEBUG_OPTS CONFIG_AIC79XX_DEBUG_MASK
-#else
-/*
- * Compile in debugging code, but do not enable any printfs.
- */
-#define AHD_DEBUG 1
-#endif
-/* No debugging code. */
-#endif
-
-/********************************** Misc Macros *******************************/
-#define	roundup(x, y)   ((((x)+((y)-1))/(y))*(y))
-#define	powerof2(x)	((((x)-1)&(x))==0)
-
-/************************* Forward Declarations *******************************/
-struct ahd_softc;
-typedef struct pci_dev *ahd_dev_softc_t;
-typedef Scsi_Cmnd      *ahd_io_ctx_t;
-
-/******************************* Byte Order ***********************************/
-#define ahd_htobe16(x)	cpu_to_be16(x)
-#define ahd_htobe32(x)	cpu_to_be32(x)
-#define ahd_htobe64(x)	cpu_to_be64(x)
-#define ahd_htole16(x)	cpu_to_le16(x)
-#define ahd_htole32(x)	cpu_to_le32(x)
-#define ahd_htole64(x)	cpu_to_le64(x)
-
-#define ahd_be16toh(x)	be16_to_cpu(x)
-#define ahd_be32toh(x)	be32_to_cpu(x)
-#define ahd_be64toh(x)	be64_to_cpu(x)
-#define ahd_le16toh(x)	le16_to_cpu(x)
-#define ahd_le32toh(x)	le32_to_cpu(x)
-#define ahd_le64toh(x)	le64_to_cpu(x)
-
-#ifndef LITTLE_ENDIAN
-#define LITTLE_ENDIAN 1234
-#endif
-
-#ifndef BIG_ENDIAN
-#define BIG_ENDIAN 4321
-#endif
-
-#ifndef BYTE_ORDER
-#if defined(__BIG_ENDIAN)
-#define BYTE_ORDER BIG_ENDIAN
-#endif
-#if defined(__LITTLE_ENDIAN)
-#define BYTE_ORDER LITTLE_ENDIAN
-#endif
-#endif /* BYTE_ORDER */
-
-/************************* Configuration Data *********************************/
-extern int aic79xx_allow_memio;
-extern int aic79xx_detect_complete;
-extern Scsi_Host_Template aic79xx_driver_template;
-
-/***************************** Bus Space/DMA **********************************/
-
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,2,17)
-typedef dma_addr_t bus_addr_t;
-#else
-typedef uint32_t bus_addr_t;
-#endif
-typedef uint32_t bus_size_t;
-
-typedef enum {
-	BUS_SPACE_MEMIO,
-	BUS_SPACE_PIO
-} bus_space_tag_t;
-
-typedef union {
-	u_long		  ioport;
-	volatile uint8_t *maddr;
-} bus_space_handle_t;
-
-typedef struct bus_dma_segment
-{
-	bus_addr_t	ds_addr;
-	bus_size_t	ds_len;
-} bus_dma_segment_t;
-
-struct ahd_linux_dma_tag
-{
-	bus_size_t	alignment;
-	bus_size_t	boundary;
-	bus_size_t	maxsize;
-};
-typedef struct ahd_linux_dma_tag* bus_dma_tag_t;
-
-struct ahd_linux_dmamap
-{
-	bus_addr_t	bus_addr;
-};
-typedef struct ahd_linux_dmamap* bus_dmamap_t;
-
-typedef int bus_dma_filter_t(void*, bus_addr_t);
-typedef void bus_dmamap_callback_t(void *, bus_dma_segment_t *, int, int);
-
-#define BUS_DMA_WAITOK		0x0
-#define BUS_DMA_NOWAIT		0x1
-#define BUS_DMA_ALLOCNOW	0x2
-#define BUS_DMA_LOAD_SEGS	0x4	/*
-					 * Argument is an S/G list not
-					 * a single buffer.
-					 */
-
-#define BUS_SPACE_MAXADDR	0xFFFFFFFF
-#define BUS_SPACE_MAXADDR_32BIT	0xFFFFFFFF
-#define BUS_SPACE_MAXSIZE_32BIT	0xFFFFFFFF
-
-int	ahd_dma_tag_create(struct ahd_softc *, bus_dma_tag_t /*parent*/,
-			   bus_size_t /*alignment*/, bus_size_t /*boundary*/,
-			   bus_addr_t /*lowaddr*/, bus_addr_t /*highaddr*/,
-			   bus_dma_filter_t*/*filter*/, void */*filterarg*/,
-			   bus_size_t /*maxsize*/, int /*nsegments*/,
-			   bus_size_t /*maxsegsz*/, int /*flags*/,
-			   bus_dma_tag_t */*dma_tagp*/);
-
-void	ahd_dma_tag_destroy(struct ahd_softc *, bus_dma_tag_t /*tag*/);
-
-int	ahd_dmamem_alloc(struct ahd_softc *, bus_dma_tag_t /*dmat*/,
-			 void** /*vaddr*/, int /*flags*/,
-			 bus_dmamap_t* /*mapp*/);
-
-void	ahd_dmamem_free(struct ahd_softc *, bus_dma_tag_t /*dmat*/,
-			void* /*vaddr*/, bus_dmamap_t /*map*/);
-
-void	ahd_dmamap_destroy(struct ahd_softc *, bus_dma_tag_t /*tag*/,
-			   bus_dmamap_t /*map*/);
-
-int	ahd_dmamap_load(struct ahd_softc *ahd, bus_dma_tag_t /*dmat*/,
-			bus_dmamap_t /*map*/, void * /*buf*/,
-			bus_size_t /*buflen*/, bus_dmamap_callback_t *,
-			void */*callback_arg*/, int /*flags*/);
-
-int	ahd_dmamap_unload(struct ahd_softc *, bus_dma_tag_t, bus_dmamap_t);
-
-/*
- * Operations performed by ahd_dmamap_sync().
- */
-#define BUS_DMASYNC_PREREAD	0x01	/* pre-read synchronization */
-#define BUS_DMASYNC_POSTREAD	0x02	/* post-read synchronization */
-#define BUS_DMASYNC_PREWRITE	0x04	/* pre-write synchronization */
-#define BUS_DMASYNC_POSTWRITE	0x08	/* post-write synchronization */
-
-/*
- * XXX
- * ahd_dmamap_sync is only used on buffers allocated with
- * the pci_alloc_consistent() API.  Although I'm not sure how
- * this works on architectures with a write buffer, Linux does
- * not have an API to sync "coherent" memory.  Perhaps we need
- * to do an mb()?
- */
-#define ahd_dmamap_sync(ahd, dma_tag, dmamap, offset, len, op)
-
-/************************** Timer DataStructures ******************************/
-typedef struct timer_list ahd_timer_t;
-
-/********************************** Includes **********************************/
-#if CONFIG_AIC79XX_REG_PRETTY_PRINT
-#define AIC_DEBUG_REGISTERS 1
-#else
-#define AIC_DEBUG_REGISTERS 0
-#endif
-#include "aic79xx.h"
-
-/***************************** Timer Facilities *******************************/
-#define ahd_timer_init init_timer
-#define ahd_timer_stop del_timer
-typedef void ahd_linux_callback_t (u_long);  
-static __inline void ahd_timer_reset(ahd_timer_t *timer, u_int usec,
-				     ahd_callback_t *func, void *arg);
-static __inline void ahd_scb_timer_reset(struct scb *scb, u_int usec);
-
-static __inline void
-ahd_timer_reset(ahd_timer_t *timer, u_int usec, ahd_callback_t *func, void *arg)
-{
-	struct ahd_softc *ahd;
-
-	ahd = (struct ahd_softc *)arg;
-	del_timer(timer);
-	timer->data = (u_long)arg;
-	timer->expires = jiffies + (usec * HZ)/1000000;
-	timer->function = (ahd_linux_callback_t*)func;
-	add_timer(timer);
-}
-
-static __inline void
-ahd_scb_timer_reset(struct scb *scb, u_int usec)
-{
-	mod_timer(&scb->io_ctx->eh_timeout, jiffies + (usec * HZ)/1000000);
-}
-
-/***************************** SMP support ************************************/
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,17)
-#include <linux/spinlock.h>
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,93)
-#include <linux/smp.h>
-#endif
-
-#define AIC79XX_DRIVER_VERSION "1.3.0"
-
-/**************************** Front End Queues ********************************/
-/*
- * Data structure used to cast the Linux struct scsi_cmnd to something
- * that allows us to use the queue macros.  The linux structure has
- * plenty of space to hold the links fields as required by the queue
- * macros, but the queue macors require them to have the correct type.
- */
-struct ahd_cmd_internal {
-	/* Area owned by the Linux scsi layer. */
-	uint8_t	private[offsetof(struct scsi_cmnd, SCp.Status)];
-	union {
-		STAILQ_ENTRY(ahd_cmd)	ste;
-		LIST_ENTRY(ahd_cmd)	le;
-		TAILQ_ENTRY(ahd_cmd)	tqe;
-	} links;
-	uint32_t			end;
-};
-
-struct ahd_cmd {
-	union {
-		struct ahd_cmd_internal	icmd;
-		struct scsi_cmnd	scsi_cmd;
-	} un;
-};
-
-#define acmd_icmd(cmd) ((cmd)->un.icmd)
-#define acmd_scsi_cmd(cmd) ((cmd)->un.scsi_cmd)
-#define acmd_links un.icmd.links
-
-/*************************** Device Data Structures ***************************/
-/*
- * A per probed device structure used to deal with some error recovery
- * scenarios that the Linux mid-layer code just doesn't know how to
- * handle.  The structure allocated for a device only becomes persistant
- * after a successfully completed inquiry command to the target when
- * that inquiry data indicates a lun is present.
- */
-TAILQ_HEAD(ahd_busyq, ahd_cmd);
-typedef enum {
-	AHD_DEV_UNCONFIGURED	 = 0x01,
-	AHD_DEV_FREEZE_TIL_EMPTY = 0x02, /* Freeze queue until active == 0 */
-	AHD_DEV_TIMER_ACTIVE	 = 0x04, /* Our timer is active */
-	AHD_DEV_ON_RUN_LIST	 = 0x08, /* Queued to be run later */
-	AHD_DEV_Q_BASIC		 = 0x10, /* Allow basic device queuing */
-	AHD_DEV_Q_TAGGED	 = 0x20, /* Allow full SCSI2 command queueing */
-	AHD_DEV_PERIODIC_OTAG	 = 0x40, /* Send OTAG to prevent starvation */
-	AHD_DEV_SLAVE_CONFIGURED = 0x80	 /* slave_configure() has been called */
-} ahd_linux_dev_flags;
-
-struct ahd_linux_target;
-struct ahd_linux_device {
-	TAILQ_ENTRY(ahd_linux_device) links;
-	struct			ahd_busyq busyq;
-
-	/*
-	 * The number of transactions currently
-	 * queued to the device.
-	 */
-	int			active;
-
-	/*
-	 * The currently allowed number of 
-	 * transactions that can be queued to
-	 * the device.  Must be signed for
-	 * conversion from tagged to untagged
-	 * mode where the device may have more
-	 * than one outstanding active transaction.
-	 */
-	int			openings;
-
-	/*
-	 * A positive count indicates that this
-	 * device's queue is halted.
-	 */
-	u_int			qfrozen;
-	
-	/*
-	 * Cumulative command counter.
-	 */
-	u_long			commands_issued;
-
-	/*
-	 * The number of tagged transactions when
-	 * running at our current opening level
-	 * that have been successfully received by
-	 * this device since the last QUEUE FULL.
-	 */
-	u_int			tag_success_count;
-#define AHD_TAG_SUCCESS_INTERVAL 50
-
-	ahd_linux_dev_flags	flags;
-
-	/*
-	 * Per device timer.
-	 */
-	struct timer_list	timer;
-
-	/*
-	 * The high limit for the tags variable.
-	 */
-	u_int			maxtags;
-
-	/*
-	 * The computed number of tags outstanding
-	 * at the time of the last QUEUE FULL event.
-	 */
-	u_int			tags_on_last_queuefull;
-
-	/*
-	 * How many times we have seen a queue full
-	 * with the same number of tags.  This is used
-	 * to stop our adaptive queue depth algorithm
-	 * on devices with a fixed number of tags.
-	 */
-	u_int			last_queuefull_same_count;
-#define AHD_LOCK_TAGS_COUNT 50
-
-	/*
-	 * How many transactions have been queued
-	 * without the device going idle.  We use
-	 * this statistic to determine when to issue
-	 * an ordered tag to prevent transaction
-	 * starvation.  This statistic is only updated
-	 * if the AHD_DEV_PERIODIC_OTAG flag is set
-	 * on this device.
-	 */
-	u_int			commands_since_idle_or_otag;
-#define AHD_OTAG_THRESH	500
-
-	int			lun;
-	Scsi_Device	       *scsi_device;
-	struct			ahd_linux_target *target;
-};
-
-typedef enum {
-	AHD_DV_REQUIRED		 = 0x01,
-	AHD_INQ_VALID		 = 0x02,
-	AHD_BASIC_DV		 = 0x04,
-	AHD_ENHANCED_DV		 = 0x08
-} ahd_linux_targ_flags;
-
-/* DV States */
-typedef enum {
-	AHD_DV_STATE_EXIT = 0,
-	AHD_DV_STATE_INQ_SHORT_ASYNC,
-	AHD_DV_STATE_INQ_ASYNC,
-	AHD_DV_STATE_INQ_ASYNC_VERIFY,
-	AHD_DV_STATE_TUR,
-	AHD_DV_STATE_REBD,
-	AHD_DV_STATE_INQ_VERIFY,
-	AHD_DV_STATE_WEB,
-	AHD_DV_STATE_REB,
-	AHD_DV_STATE_SU,
-	AHD_DV_STATE_BUSY
-} ahd_dv_state;
-
-struct ahd_linux_target {
-	struct ahd_linux_device	 *devices[AHD_NUM_LUNS];
-	int			  channel;
-	int			  target;
-	int			  refcount;
-	struct ahd_transinfo	  last_tinfo;
-	struct ahd_softc	 *ahd;
-	ahd_linux_targ_flags	  flags;
-	struct scsi_inquiry_data *inq_data;
-	/*
-	 * The next "fallback" period to use for narrow/wide transfers.
-	 */
-	uint8_t			  dv_next_narrow_period;
-	uint8_t			  dv_next_wide_period;
-	uint8_t			  dv_max_width;
-	uint8_t			  dv_max_ppr_options;
-	uint8_t			  dv_last_ppr_options;
-	u_int			  dv_echo_size;
-	ahd_dv_state		  dv_state;
-	u_int			  dv_state_retry;
-	uint8_t			 *dv_buffer;
-	uint8_t			 *dv_buffer1;
-
-	/*
-	 * Cumulative counter of errors.
-	 */
-	u_long			errors_detected;
-	u_long			cmds_since_error;
-};
-
-/********************* Definitions Required by the Core ***********************/
-/*
- * Number of SG segments we require.  So long as the S/G segments for
- * a particular transaction are allocated in a physically contiguous
- * manner and are allocated below 4GB, the number of S/G segments is
- * unrestricted.
- */
-#define        AHD_NSEG 128
-
-/*
- * Per-SCB OSM storage.
- */
-typedef enum {
-	AHD_UP_EH_SEMAPHORE = 0x1
-} ahd_linux_scb_flags;
-
-struct scb_platform_data {
-	struct ahd_linux_device	*dev;
-	bus_addr_t		 buf_busaddr;
-	uint32_t		 xfer_len;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
-	uint32_t		 resid;		/* Transfer residual */
-#endif
-	uint32_t		 sense_resid;	/* Auto-Sense residual */
-	ahd_linux_scb_flags	 flags;
-};
-
-/*
- * Define a structure used for each host adapter.  All members are
- * aligned on a boundary >= the size of the member to honor the
- * alignment restrictions of the various platforms supported by
- * this driver.
- */
-typedef enum {
-	AHD_DV_WAIT_SIMQ_EMPTY	 = 0x01,
-	AHD_DV_WAIT_SIMQ_RELEASE = 0x02,
-	AHD_DV_ACTIVE		 = 0x04,
-	AHD_DV_SHUTDOWN		 = 0x08,
-	AHD_RUN_CMPLT_Q_TIMER	 = 0x10
-} ahd_linux_softc_flags;
-
-TAILQ_HEAD(ahd_completeq, ahd_cmd);
-
-struct ahd_platform_data {
-	/*
-	 * Fields accessed from interrupt context.
-	 */
-	struct ahd_linux_target *targets[AHD_NUM_TARGETS]; 
-	TAILQ_HEAD(, ahd_linux_device) device_runq;
-	struct ahd_completeq	 completeq;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,93)
-	spinlock_t		 spin_lock;
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	struct tasklet_struct	 runq_tasklet;
-#endif
-	u_int			 qfrozen;
-	pid_t			 dv_pid;
-	struct timer_list	 completeq_timer;
-	struct timer_list	 reset_timer;
-	struct timer_list	 stats_timer;
-	struct semaphore	 eh_sem;
-	struct semaphore	 dv_sem;
-	struct semaphore	 dv_cmd_sem;	/* XXX This needs to be in
-						 * the target struct
-						 */
-	struct scsi_device	*dv_scsi_dev;
-	struct Scsi_Host        *host;		/* pointer to scsi host */
-#define AHD_LINUX_NOIRQ	((uint32_t)~0)
-	uint32_t		 irq;		/* IRQ for this adapter */
-	uint32_t		 bios_address;
-	uint32_t		 mem_busaddr;	/* Mem Base Addr */
-	bus_addr_t		 hw_dma_mask;
-	ahd_linux_softc_flags	 flags;
-};
-
-/************************** OS Utility Wrappers *******************************/
-#define printf printk
-#define M_NOWAIT GFP_ATOMIC
-#define M_WAITOK 0
-#define malloc(size, type, flags) kmalloc(size, flags)
-#define free(ptr, type) kfree(ptr)
-
-static __inline void ahd_delay(long);
-static __inline void
-ahd_delay(long usec)
-{
-	/*
-	 * udelay on Linux can have problems for
-	 * multi-millisecond waits.  Wait at most
-	 * 1024us per call.
-	 */
-	while (usec > 0) {
-		udelay(usec % 1024);
-		usec -= 1024;
-	}
-}
-
-
-/***************************** Low Level I/O **********************************/
-#if defined(__powerpc__) || defined(__i386__) || defined(__ia64__)
-#define MMAPIO
-#endif
-
-static __inline uint8_t ahd_inb(struct ahd_softc * ahd, long port);
-static __inline uint16_t ahd_inw_atomic(struct ahd_softc * ahd, long port);
-static __inline void ahd_outb(struct ahd_softc * ahd, long port, uint8_t val);
-static __inline void ahd_outw_atomic(struct ahd_softc * ahd,
-				     long port, uint16_t val);
-static __inline void ahd_outsb(struct ahd_softc * ahd, long port,
-			       uint8_t *, int count);
-static __inline void ahd_insb(struct ahd_softc * ahd, long port,
-			       uint8_t *, int count);
-
-static __inline uint8_t
-ahd_inb(struct ahd_softc * ahd, long port)
-{
-	uint8_t x;
-#ifdef MMAPIO
-
-	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
-		x = readb(ahd->bshs[0].maddr + port);
-	} else {
-		x = inb(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
-	}
-#else
-	x = inb(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
-#endif
-	mb();
-	return (x);
-}
-
-static __inline uint16_t
-ahd_inw_atomic(struct ahd_softc * ahd, long port)
-{
-	uint8_t x;
-#ifdef MMAPIO
-
-	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
-		x = readw(ahd->bshs[0].maddr + port);
-	} else {
-		x = inw(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
-	}
-#else
-	x = inw(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
-#endif
-	mb();
-	return (x);
-}
-
-static __inline void
-ahd_outb(struct ahd_softc * ahd, long port, uint8_t val)
-{
-#ifdef MMAPIO
-	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
-		writeb(val, ahd->bshs[0].maddr + port);
-	} else {
-		outb(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
-	}
-#else
-	outb(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
-#endif
-	mb();
-}
-
-static __inline void
-ahd_outw_atomic(struct ahd_softc * ahd, long port, uint16_t val)
-{
-#ifdef MMAPIO
-	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
-		writew(val, ahd->bshs[0].maddr + port);
-	} else {
-		outw(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
-	}
-#else
-	outw(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
-#endif
-	mb();
-}
-
-static __inline void
-ahd_outsb(struct ahd_softc * ahd, long port, uint8_t *array, int count)
-{
-	int i;
-
-	/*
-	 * There is probably a more efficient way to do this on Linux
-	 * but we don't use this for anything speed critical and this
-	 * should work.
-	 */
-	for (i = 0; i < count; i++)
-		ahd_outb(ahd, port, *array++);
-}
-
-static __inline void
-ahd_insb(struct ahd_softc * ahd, long port, uint8_t *array, int count)
-{
-	int i;
-
-	/*
-	 * There is probably a more efficient way to do this on Linux
-	 * but we don't use this for anything speed critical and this
-	 * should work.
-	 */
-	for (i = 0; i < count; i++)
-		*array++ = ahd_inb(ahd, port);
-}
-
-/**************************** Initialization **********************************/
-int		ahd_linux_register_host(struct ahd_softc *,
-					Scsi_Host_Template *);
-
-uint64_t	ahd_linux_get_memsize(void);
-
-/*************************** Pretty Printing **********************************/
-struct info_str {
-	char *buffer;
-	int length;
-	off_t offset;
-	int pos;
-};
-
-void	ahd_format_transinfo(struct info_str *info,
-			     struct ahd_transinfo *tinfo);
-
-/******************************** Locking *************************************/
-/* Lock protecting internal data structures */
-static __inline void ahd_lockinit(struct ahd_softc *);
-static __inline void ahd_lock(struct ahd_softc *, unsigned long *flags);
-static __inline void ahd_unlock(struct ahd_softc *, unsigned long *flags);
-
-/* Lock acquisition and release of the above lock in midlayer entry points. */
-static __inline void ahd_midlayer_entrypoint_lock(struct ahd_softc *,
-						  unsigned long *flags);
-static __inline void ahd_midlayer_entrypoint_unlock(struct ahd_softc *,
-						    unsigned long *flags);
-
-/* Lock held during command compeletion to the upper layer */
-static __inline void ahd_done_lockinit(struct ahd_softc *);
-static __inline void ahd_done_lock(struct ahd_softc *, unsigned long *flags);
-static __inline void ahd_done_unlock(struct ahd_softc *, unsigned long *flags);
-
-/* Lock held during ahd_list manipulation and ahd softc frees */
-extern spinlock_t ahd_list_spinlock;
-static __inline void ahd_list_lockinit(void);
-static __inline void ahd_list_lock(unsigned long *flags);
-static __inline void ahd_list_unlock(unsigned long *flags);
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,93)
-static __inline void
-ahd_lockinit(struct ahd_softc *ahd)
-{
-	spin_lock_init(&ahd->platform_data->spin_lock);
-}
-
-static __inline void
-ahd_lock(struct ahd_softc *ahd, unsigned long *flags)
-{
-	*flags = 0;
-	spin_lock_irqsave(&ahd->platform_data->spin_lock, *flags);
-}
-
-static __inline void
-ahd_unlock(struct ahd_softc *ahd, unsigned long *flags)
-{
-	spin_unlock_irqrestore(&ahd->platform_data->spin_lock, *flags);
-}
-
-static __inline void
-ahd_midlayer_entrypoint_lock(struct ahd_softc *ahd, unsigned long *flags)
-{
-	/*
-	 * In 2.5.X, the midlayer takes our lock just before
-	 * calling us, so avoid locking again.
-	 */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	ahd_lock(ahd, flags);
-#endif
-}
-
-static __inline void
-ahd_midlayer_entrypoint_unlock(struct ahd_softc *ahd, unsigned long *flags)
-{
-	/*
-	 * In 2.5.X, the midlayer takes our lock just before
-	 * calling us and unlocks when we return, so let it do the unlock.
-	 */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	ahd_unlock(ahd, flags);
-#endif
-}
-
-static __inline void
-ahd_done_lockinit(struct ahd_softc *ahd)
-{
-	/*
-	 * In 2.5.X, our own lock is held during completions.
-	 * In previous versions, the io_request_lock is used.
-	 * In either case, we can't initialize this lock again.
-	 */
-}
-
-static __inline void
-ahd_done_lock(struct ahd_softc *ahd, unsigned long *flags)
-{
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	*flags = 0;
-	spin_lock_irqsave(&io_request_lock, *flags);
-#endif
-}
-
-static __inline void
-ahd_done_unlock(struct ahd_softc *ahd, unsigned long *flags)
-{
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	spin_unlock_irqrestore(&io_request_lock, *flags);
-#endif
-}
-
-static __inline void
-ahd_list_lockinit()
-{
-	spin_lock_init(&ahd_list_spinlock);
-}
-
-static __inline void
-ahd_list_lock(unsigned long *flags)
-{
-	*flags = 0;
-	spin_lock_irqsave(&ahd_list_spinlock, *flags);
-}
-
-static __inline void
-ahd_list_unlock(unsigned long *flags)
-{
-	spin_unlock_irqrestore(&ahd_list_spinlock, *flags);
-}
-
-#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0) */
-
-ahd_lockinit(struct ahd_softc *ahd)
-{
-}
-
-static __inline void
-ahd_lock(struct ahd_softc *ahd, unsigned long *flags)
-{
-	*flags = 0;
-	save_flags(*flags);
-	cli();
-}
-
-static __inline void
-ahd_unlock(struct ahd_softc *ahd, unsigned long *flags)
-{
-	restore_flags(*flags);
-}
-
-ahd_done_lockinit(struct ahd_softc *ahd)
-{
-}
-
-static __inline void
-ahd_done_lock(struct ahd_softc *ahd, unsigned long *flags)
-{
-	/*
-	 * The done lock is always held while
-	 * the ahd lock is held so blocking
-	 * interrupts again would have no effect.
-	 */
-}
-
-static __inline void
-ahd_done_unlock(struct ahd_softc *ahd, unsigned long *flags)
-{
-}
-
-static __inline void
-ahd_list_lockinit()
-{
-}
-
-static __inline void
-ahd_list_lock(unsigned long *flags)
-{
-	*flags = 0;
-	save_flags(*flags);
-	cli();
-}
-
-static __inline void
-ahd_list_unlock(unsigned long *flags)
-{
-	restore_flags(*flags);
-}
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0) */
-
-/******************************* PCI Definitions ******************************/
-/*
- * PCIM_xxx: mask to locate subfield in register
- * PCIR_xxx: config register offset
- * PCIC_xxx: device class
- * PCIS_xxx: device subclass
- * PCIP_xxx: device programming interface
- * PCIV_xxx: PCI vendor ID (only required to fixup ancient devices)
- * PCID_xxx: device ID
- */
-#define PCIR_DEVVENDOR		0x00
-#define PCIR_VENDOR		0x00
-#define PCIR_DEVICE		0x02
-#define PCIR_COMMAND		0x04
-#define PCIM_CMD_PORTEN		0x0001
-#define PCIM_CMD_MEMEN		0x0002
-#define PCIM_CMD_BUSMASTEREN	0x0004
-#define PCIM_CMD_MWRICEN	0x0010
-#define PCIM_CMD_PERRESPEN	0x0040
-#define	PCIM_CMD_SERRESPEN	0x0100
-#define PCIR_STATUS		0x06
-#define PCIR_REVID		0x08
-#define PCIR_PROGIF		0x09
-#define PCIR_SUBCLASS		0x0a
-#define PCIR_CLASS		0x0b
-#define PCIR_CACHELNSZ		0x0c
-#define PCIR_LATTIMER		0x0d
-#define PCIR_HEADERTYPE		0x0e
-#define PCIM_MFDEV		0x80
-#define PCIR_BIST		0x0f
-#define PCIR_CAP_PTR		0x34
-
-/* config registers for header type 0 devices */
-#define PCIR_MAPS	0x10
-#define PCIR_SUBVEND_0	0x2c
-#define PCIR_SUBDEV_0	0x2e
-
-/****************************** PCI-X definitions *****************************/
-#define PCIXR_COMMAND	0x96
-#define PCIXR_DEVADDR	0x98
-#define PCIXM_DEVADDR_FNUM	0x0003	/* Function Number */
-#define PCIXM_DEVADDR_DNUM	0x00F8	/* Device Number */
-#define PCIXM_DEVADDR_BNUM	0xFF00	/* Bus Number */
-#define PCIXR_STATUS	0x9A
-#define PCIXM_STATUS_64BIT	0x0001	/* Active 64bit connection to device. */
-#define PCIXM_STATUS_133CAP	0x0002	/* Device is 133MHz capable */
-#define PCIXM_STATUS_SCDISC	0x0004	/* Split Completion Discarded */
-#define PCIXM_STATUS_UNEXPSC	0x0008	/* Unexpected Split Completion */
-#define PCIXM_STATUS_CMPLEXDEV	0x0010	/* Device Complexity (set == bridge) */
-#define PCIXM_STATUS_MAXMRDBC	0x0060	/* Maximum Burst Read Count */
-#define PCIXM_STATUS_MAXSPLITS	0x0380	/* Maximum Split Transactions */
-#define PCIXM_STATUS_MAXCRDS	0x1C00	/* Maximum Cumulative Read Size */
-#define PCIXM_STATUS_RCVDSCEM	0x2000	/* Received a Split Comp w/Error msg */
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-extern struct pci_driver aic79xx_pci_driver;
-#endif
-
-typedef enum
-{
-	AHD_POWER_STATE_D0,
-	AHD_POWER_STATE_D1,
-	AHD_POWER_STATE_D2,
-	AHD_POWER_STATE_D3
-} ahd_power_state;
-
-void ahd_power_state_change(struct ahd_softc *ahd,
-			    ahd_power_state new_state);
-
-/******************************* PCI Routines *********************************/
-/*
- * We need to use the bios32.h routines if we are kernel version 2.1.92 or less.
- */
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,1,92)
-#if defined(__sparc_v9__) || defined(__powerpc__)
-#error "PPC and Sparc platforms are only support under 2.1.92 and above"
-#endif
-#include <linux/bios32.h>
-#endif
-
-int			 ahd_linux_pci_probe(Scsi_Host_Template *);
-int			 ahd_pci_map_registers(struct ahd_softc *ahd);
-int			 ahd_pci_map_int(struct ahd_softc *ahd);
-
-static __inline uint32_t ahd_pci_read_config(ahd_dev_softc_t pci,
-					     int reg, int width);
-
-static __inline uint32_t
-ahd_pci_read_config(ahd_dev_softc_t pci, int reg, int width)
-{
-	switch (width) {
-	case 1:
-	{
-		uint8_t retval;
-
-		pci_read_config_byte(pci, reg, &retval);
-		return (retval);
-	}
-	case 2:
-	{
-		uint16_t retval;
-		pci_read_config_word(pci, reg, &retval);
-		return (retval);
-	}
-	case 4:
-	{
-		uint32_t retval;
-		pci_read_config_dword(pci, reg, &retval);
-		return (retval);
-	}
-	default:
-		panic("ahd_pci_read_config: Read size too big");
-		/* NOTREACHED */
-		return (0);
-	}
-}
-
-static __inline void ahd_pci_write_config(ahd_dev_softc_t pci,
-					  int reg, uint32_t value,
-					  int width);
-
-static __inline void
-ahd_pci_write_config(ahd_dev_softc_t pci, int reg, uint32_t value, int width)
-{
-	switch (width) {
-	case 1:
-		pci_write_config_byte(pci, reg, value);
-		break;
-	case 2:
-		pci_write_config_word(pci, reg, value);
-		break;
-	case 4:
-		pci_write_config_dword(pci, reg, value);
-		break;
-	default:
-		panic("ahd_pci_write_config: Write size too big");
-		/* NOTREACHED */
-	}
-}
-
-static __inline int ahd_get_pci_function(ahd_dev_softc_t);
-static __inline int
-ahd_get_pci_function(ahd_dev_softc_t pci)
-{
-	return (PCI_FUNC(pci->devfn));
-}
-
-static __inline int ahd_get_pci_slot(ahd_dev_softc_t);
-static __inline int
-ahd_get_pci_slot(ahd_dev_softc_t pci)
-{
-	return (PCI_SLOT(pci->devfn));
-}
-
-static __inline int ahd_get_pci_bus(ahd_dev_softc_t);
-static __inline int
-ahd_get_pci_bus(ahd_dev_softc_t pci)
-{
-	return (pci->bus->number);
-}
-
-static __inline void ahd_flush_device_writes(struct ahd_softc *);
-static __inline void
-ahd_flush_device_writes(struct ahd_softc *ahd)
-{
-	/* XXX Is this sufficient for all architectures??? */
-	ahd_inb(ahd, INTSTAT);
-}
-
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,3,0)
-#define pci_map_sg(pdev, sg_list, nseg, direction) (nseg)
-#define pci_unmap_sg(pdev, sg_list, nseg, direction)
-#define sg_dma_address(sg) (VIRT_TO_BUS((sg)->address))
-#define sg_dma_len(sg) ((sg)->length)
-#define pci_map_single(pdev, buffer, bufflen, direction) \
-	(VIRT_TO_BUS(buffer))
-#define pci_unmap_single(pdev, buffer, buflen, direction)
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,3)
-#define ahd_pci_set_dma_mask pci_set_dma_mask
-#else
-/*
- * Always "return" 0 for success.
- */
-#define ahd_pci_set_dma_mask(dev_softc, mask)	\
-	(((dev_softc)->dma_mask = mask) && 0)
-#endif
-/**************************** Proc FS Support *********************************/
-int	ahd_linux_proc_info(char *, char **, off_t, int, int, int);
-
-/*************************** Domain Validation ********************************/
-#define AHD_DV_CMD(cmd) ((cmd)->scsi_done == ahd_linux_dv_complete)
-#define AHD_DV_SIMQ_FROZEN(ahd)					\
-	((((ahd)->platform_data->flags & AHD_DV_ACTIVE) != 0)	\
-	 && (ahd)->platform_data->qfrozen == 1)
-
-/*********************** Transaction Access Wrappers **************************/
-static __inline void ahd_cmd_set_transaction_status(Scsi_Cmnd *, uint32_t);
-static __inline void ahd_set_transaction_status(struct scb *, uint32_t);
-static __inline void ahd_cmd_set_scsi_status(Scsi_Cmnd *, uint32_t);
-static __inline void ahd_set_scsi_status(struct scb *, uint32_t);
-static __inline uint32_t ahd_cmd_get_transaction_status(Scsi_Cmnd *cmd);
-static __inline uint32_t ahd_get_transaction_status(struct scb *);
-static __inline uint32_t ahd_cmd_get_scsi_status(Scsi_Cmnd *cmd);
-static __inline uint32_t ahd_get_scsi_status(struct scb *);
-static __inline void ahd_set_transaction_tag(struct scb *, int, u_int);
-static __inline u_long ahd_get_transfer_length(struct scb *);
-static __inline int ahd_get_transfer_dir(struct scb *);
-static __inline void ahd_set_residual(struct scb *, u_long);
-static __inline void ahd_set_sense_residual(struct scb *scb, u_long resid);
-static __inline u_long ahd_get_residual(struct scb *);
-static __inline u_long ahd_get_sense_residual(struct scb *);
-static __inline int ahd_perform_autosense(struct scb *);
-static __inline uint32_t ahd_get_sense_bufsize(struct ahd_softc *,
-					       struct scb *);
-static __inline void ahd_notify_xfer_settings_change(struct ahd_softc *,
-						     struct ahd_devinfo *);
-static __inline void ahd_platform_scb_free(struct ahd_softc *ahd,
-					   struct scb *scb);
-static __inline void ahd_freeze_scb(struct scb *scb);
-
-static __inline
-void ahd_cmd_set_transaction_status(Scsi_Cmnd *cmd, uint32_t status)
-{
-	cmd->result &= ~(CAM_STATUS_MASK << 16);
-	cmd->result |= status << 16;
-}
-
-static __inline
-void ahd_set_transaction_status(struct scb *scb, uint32_t status)
-{
-	ahd_cmd_set_transaction_status(scb->io_ctx,status);
-}
-
-static __inline
-void ahd_cmd_set_scsi_status(Scsi_Cmnd *cmd, uint32_t status)
-{
-	cmd->result &= ~0xFFFF;
-	cmd->result |= status;
-}
-
-static __inline
-void ahd_set_scsi_status(struct scb *scb, uint32_t status)
-{
-	ahd_cmd_set_scsi_status(scb->io_ctx, status);
-}
-
-static __inline
-uint32_t ahd_cmd_get_transaction_status(Scsi_Cmnd *cmd)
-{
-	return ((cmd->result >> 16) & CAM_STATUS_MASK);
-}
-
-static __inline
-uint32_t ahd_get_transaction_status(struct scb *scb)
-{
-	return (ahd_cmd_get_transaction_status(scb->io_ctx));
-}
-
-static __inline
-uint32_t ahd_cmd_get_scsi_status(Scsi_Cmnd *cmd)
-{
-	return (cmd->result & 0xFFFF);
-}
-
-static __inline
-uint32_t ahd_get_scsi_status(struct scb *scb)
-{
-	return (ahd_cmd_get_scsi_status(scb->io_ctx));
-}
-
-static __inline
-void ahd_set_transaction_tag(struct scb *scb, int enabled, u_int type)
-{
-	/*
-	 * Nothing to do for linux as the incoming transaction
-	 * has no concept of tag/non tagged, etc.
-	 */
-}
-
-static __inline
-u_long ahd_get_transfer_length(struct scb *scb)
-{
-	return (scb->platform_data->xfer_len);
-}
-
-static __inline
-int ahd_get_transfer_dir(struct scb *scb)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,40)
-	return (scb->io_ctx->sc_data_direction);
-#else
-	if (scb->io_ctx->bufflen == 0)
-		return (CAM_DIR_NONE);
-
-	switch(scb->io_ctx->cmnd[0]) {
-	case 0x08:  /* READ(6)  */
-	case 0x28:  /* READ(10) */
-	case 0xA8:  /* READ(12) */
-		return (CAM_DIR_IN);
-        case 0x0A:  /* WRITE(6)  */
-        case 0x2A:  /* WRITE(10) */
-        case 0xAA:  /* WRITE(12) */
-		return (CAM_DIR_OUT);
-        default:
-		return (CAM_DIR_NONE);
-        }
-#endif
-}
-
-static __inline
-void ahd_set_residual(struct scb *scb, u_long resid)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	scb->io_ctx->resid = resid;
-#else
-	scb->platform_data->resid = resid;
-#endif
-}
-
-static __inline
-void ahd_set_sense_residual(struct scb *scb, u_long resid)
-{
-	scb->platform_data->sense_resid = resid;
-}
-
-static __inline
-u_long ahd_get_residual(struct scb *scb)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	return (scb->io_ctx->resid);
-#else
-	return (scb->platform_data->resid);
-#endif
-}
-
-static __inline
-u_long ahd_get_sense_residual(struct scb *scb)
-{
-	return (scb->platform_data->sense_resid);
-}
-
-static __inline
-int ahd_perform_autosense(struct scb *scb)
-{
-	/*
-	 * We always perform autosense in Linux.
-	 * On other platforms this is set on a
-	 * per-transaction basis.
-	 */
-	return (1);
-}
-
-static __inline uint32_t
-ahd_get_sense_bufsize(struct ahd_softc *ahd, struct scb *scb)
-{
-	return (sizeof(struct scsi_sense_data));
-}
-
-static __inline void
-ahd_notify_xfer_settings_change(struct ahd_softc *ahd,
-				struct ahd_devinfo *devinfo)
-{
-	/* Nothing to do here for linux */
-}
-
-static __inline void
-ahd_platform_scb_free(struct ahd_softc *ahd, struct scb *scb)
-{
-	ahd->flags &= ~AHD_RESOURCE_SHORTAGE;
-}
-
-int	ahd_platform_alloc(struct ahd_softc *ahd, void *platform_arg);
-void	ahd_platform_free(struct ahd_softc *ahd);
-void	ahd_platform_init(struct ahd_softc *ahd);
-void	ahd_platform_freeze_devq(struct ahd_softc *ahd, struct scb *scb);
-void	ahd_freeze_simq(struct ahd_softc *ahd);
-void	ahd_release_simq(struct ahd_softc *ahd);
-
-static __inline void
-ahd_freeze_scb(struct scb *scb)
-{
-	if ((scb->io_ctx->result & (CAM_DEV_QFRZN << 16)) == 0) {
-                scb->io_ctx->result |= CAM_DEV_QFRZN << 16;
-                scb->platform_data->dev->qfrozen++;
-        }
-}
-
-void	ahd_platform_set_tags(struct ahd_softc *ahd,
-			      struct ahd_devinfo *devinfo, ahd_queue_alg);
-int	ahd_platform_abort_scbs(struct ahd_softc *ahd, int target,
-				char channel, int lun, u_int tag,
-				role_t role, uint32_t status);
-void	ahd_linux_isr(int irq, void *dev_id, struct pt_regs * regs);
-void	ahd_platform_flushwork(struct ahd_softc *ahd);
-int	ahd_softc_comp(struct ahd_softc *, struct ahd_softc *);
-void	ahd_done(struct ahd_softc*, struct scb*);
-void	ahd_send_async(struct ahd_softc *, char channel,
-		       u_int target, u_int lun, ac_code, void *);
-void	ahd_print_path(struct ahd_softc *, struct scb *);
-void	ahd_platform_dump_card_state(struct ahd_softc *ahd);
-
-#ifdef CONFIG_PCI
-#define AHD_PCI_CONFIG 1
-#else
-#define AHD_PCI_CONFIG 0
-#endif
-#define bootverbose aic79xx_verbose
-extern int aic79xx_verbose;
-#endif /* _AIC79XX_LINUX_H_ */
diff -urNp linux-5720/drivers/scsi/aic79xx/aic79xx_osm_pci.c linux-5730/drivers/scsi/aic79xx/aic79xx_osm_pci.c
--- linux-5720/drivers/scsi/aic79xx/aic79xx_osm_pci.c
+++ linux-5730/drivers/scsi/aic79xx/aic79xx_osm_pci.c
@@ -1,432 +0,0 @@
-/*
- * Linux driver attachment glue for PCI based U320 controllers.
- *
- * Copyright (c) 2000-2001 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#20 $
- */
-
-#include "aic79xx_osm.h"
-#include "aic79xx_inline.h"
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
-struct pci_device_id
-{
-};
-#endif
-
-static int	ahd_linux_pci_dev_probe(struct pci_dev *pdev,
-					const struct pci_device_id *ent);
-static int	ahd_linux_pci_reserve_io_regions(struct ahd_softc *ahd,
-						 u_long *base, u_long *base2);
-static int	ahd_linux_pci_reserve_mem_region(struct ahd_softc *ahd,
-						 u_long *bus_addr,
-						 uint8_t **maddr);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-static void	ahd_linux_pci_dev_remove(struct pci_dev *pdev);
-
-/* We do our own ID filtering.  So, grab all SCSI storage class devices. */
-static struct pci_device_id ahd_linux_pci_id_table[] = {
-	{
-		0x9005, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
-		PCI_CLASS_STORAGE_SCSI << 8, 0xFFFF00, 0
-	},
-	{ 0 }
-};
-
-MODULE_DEVICE_TABLE(pci, ahd_linux_pci_id_table);
-
-struct pci_driver aic79xx_pci_driver = {
-	name:		"aic79xx",
-	probe:		ahd_linux_pci_dev_probe,
-	remove:		ahd_linux_pci_dev_remove,
-	id_table:	ahd_linux_pci_id_table
-};
-
-static void
-ahd_linux_pci_dev_remove(struct pci_dev *pdev)
-{
-	struct ahd_softc *ahd;
-	u_long l;
-
-	/*
-	 * We should be able to just perform
-	 * the free directly, but check our
-	 * list for extra sanity.
-	 */
-	ahd_list_lock(&l);
-	ahd = ahd_find_softc((struct ahd_softc *)pci_get_drvdata(pdev));
-	if (ahd != NULL) {
-		u_long s;
-
-		ahd_lock(ahd, &s);
-		ahd_intr_enable(ahd, FALSE);
-		ahd_unlock(ahd, &s);
-		ahd_free(ahd);
-	}
-	ahd_list_unlock(&l);
-}
-#endif /* !LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0) */
-
-static int
-ahd_linux_pci_dev_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
-{
-	char		 buf[80];
-	struct		 ahd_softc *ahd;
-	ahd_dev_softc_t	 pci;
-	struct		 ahd_pci_identity *entry;
-	char		*name;
-	int		 error;
-
-	/*
-	 * Some BIOSen report the same device multiple times.
-	 */
-	TAILQ_FOREACH(ahd, &ahd_tailq, links) {
-		struct pci_dev *probed_pdev;
-
-		probed_pdev = ahd->dev_softc;
-		if (probed_pdev->bus->number == pdev->bus->number
-		 && probed_pdev->devfn == pdev->devfn)
-			break;
-	}
-	if (ahd != NULL) {
-		/* Skip duplicate. */
-		return (-ENODEV);
-	}
-
-	pci = pdev;
-	entry = ahd_find_pci_device(pci);
-	if (entry == NULL)
-		return (-ENODEV);
-
-	/*
-	 * Allocate a softc for this card and
-	 * set it up for attachment by our
-	 * common detect routine.
-	 */
-	sprintf(buf, "ahd_pci:%d:%d:%d",
-		ahd_get_pci_bus(pci),
-		ahd_get_pci_slot(pci),
-		ahd_get_pci_function(pci));
-	name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
-	if (name == NULL)
-		return (-ENOMEM);
-	strcpy(name, buf);
-	ahd = ahd_alloc(NULL, name);
-	if (ahd == NULL)
-		return (-ENOMEM);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	if (pci_enable_device(pdev)) {
-		ahd_free(ahd);
-		return (-ENODEV);
-	}
-	pci_set_master(pdev);
-
-	if (sizeof(bus_addr_t) > 4) {
-		uint64_t memsize;
-
-		memsize = ahd_linux_get_memsize();
-		if (memsize >= 0x8000000000
-	 	 && ahd_pci_set_dma_mask(pdev, 0xFFFFFFFFFFFFFFFFULL) == 0) {
-			ahd->flags |= AHD_64BIT_ADDRESSING;
-			ahd->platform_data->hw_dma_mask =
-			    (bus_addr_t)(0xFFFFFFFFFFFFFFFFULL&(bus_addr_t)~0);
-		} else if (memsize > 0x80000000
-			&& ahd_pci_set_dma_mask(pdev, 0x7FFFFFFFFFULL) == 0) {
-			ahd->flags |= AHD_39BIT_ADDRESSING;
-			ahd->platform_data->hw_dma_mask =
-			    (bus_addr_t)(0x7FFFFFFFFFULL & (bus_addr_t)~0);
-		}
-	} else {
-		ahd_pci_set_dma_mask(pdev, 0xFFFFFFFF);
-		ahd->platform_data->hw_dma_mask = 0xFFFFFFFF;
-	}
-#endif
-	ahd->dev_softc = pci;
-	error = ahd_pci_config(ahd, entry);
-	if (error != 0) {
-		ahd_free(ahd);
-		return (-error);
-	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	pci_set_drvdata(pdev, ahd);
-	if (aic79xx_detect_complete)
-		ahd_linux_register_host(ahd, &aic79xx_driver_template);
-#endif
-	return (0);
-}
-
-int
-ahd_linux_pci_probe(Scsi_Host_Template *template)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	return (pci_module_init(&aic79xx_pci_driver));
-#else
-	struct pci_dev *pdev;
-	u_int class;
-	int found;
-
-	/* If we don't have a PCI bus, we can't find any adapters. */
-	if (pci_present() == 0)
-		return (0);
-
-	found = 0;
-	pdev = NULL;
-	class = PCI_CLASS_STORAGE_SCSI << 8;
-	while ((pdev = pci_find_class(class, pdev)) != NULL) {
-		ahd_dev_softc_t pci;
-		int error;
-
-		pci = pdev;
-		error = ahd_linux_pci_dev_probe(pdev, /*pci_devid*/NULL);
-		if (error == 0)
-			found++;
-	}
-	return (found);
-#endif
-}
-
-static int
-ahd_linux_pci_reserve_io_regions(struct ahd_softc *ahd, u_long *base,
-				 u_long *base2)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	*base = pci_resource_start(ahd->dev_softc, 0);
-	/*
-	 * This is really the 3rd bar and should be at index 2,
-	 * but the Linux PCI code doesn't know how to "count" 64bit
-	 * bars.
-	 */
-	*base2 = pci_resource_start(ahd->dev_softc, 3);
-#else
-	*base = ahd_pci_read_config(ahd->dev_softc, AHD_PCI_IOADDR0, 4);
-	*base2 = ahd_pci_read_config(ahd->dev_softc, AHD_PCI_IOADDR1, 4);
-	*base &= PCI_BASE_ADDRESS_IO_MASK;
-	*base2 &= PCI_BASE_ADDRESS_IO_MASK;
-#endif
-	if (*base == 0 || *base2 == 0)
-		return (ENOMEM);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
-	if (check_region(*base, 256) != 0
-	 || check_region(*base2, 256) != 0)
-		return (ENOMEM);
-	request_region(*base, 256, "aic79xx");
-	request_region(*base2, 256, "aic79xx");
-#else
-	if (request_region(*base, 256, "aic79xx") == 0)
-		return (ENOMEM);
-	if (request_region(*base2, 256, "aic79xx") == 0) {
-		release_region(*base2, 256);
-		return (ENOMEM);
-	}
-#endif
-	return (0);
-}
-
-static int
-ahd_linux_pci_reserve_mem_region(struct ahd_softc *ahd,
-				 u_long *bus_addr,
-				 uint8_t **maddr)
-{
-	u_long	start;
-	u_long	base_page;
-	u_long	base_offset;
-	int	error;
-
-	if (aic79xx_allow_memio == 0)
-		return (ENOMEM);
-
-	if ((ahd->bugs & AHD_PCIX_MMAPIO_BUG) != 0)
-		return (ENOMEM);
-
-	error = 0;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	start = pci_resource_start(ahd->dev_softc, 1);
-	base_page = start & PAGE_MASK;
-	base_offset = start - base_page;
-#else
-	start = ahd_pci_read_config(ahd->dev_softc, PCIR_MAPS+4, 4);
-	base_offset = start & PCI_BASE_ADDRESS_MEM_MASK;
-	base_page = base_offset & PAGE_MASK;
-	base_offset -= base_page;
-#endif
-	if (start != 0) {
-		*bus_addr = start;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-		if (request_mem_region(start, 0x1000, "aic79xx") == 0)
-			error = ENOMEM;
-#endif
-		if (error == 0) {
-			*maddr = ioremap_nocache(base_page, base_offset + 256);
-			if (*maddr == NULL) {
-				error = ENOMEM;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-				release_mem_region(start, 0x1000);
-#endif
-			} else
-				*maddr += base_offset;
-		}
-	} else
-		error = ENOMEM;
-	return (error);
-}
-
-int
-ahd_pci_map_registers(struct ahd_softc *ahd)
-{
-	uint32_t command;
-	u_long	 base;
-	uint8_t	*maddr;
-	int	 error;
-
-	/*
-	 * If its allowed, we prefer memory mapped access.
-	 */
-	command = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, 4);
-	command &= ~(PCIM_CMD_PORTEN|PCIM_CMD_MEMEN);
-	base = 0;
-	maddr = NULL;
-#ifdef MMAPIO
-	error = ahd_linux_pci_reserve_mem_region(ahd, &base, &maddr);
-	if (error == 0) {
-		ahd->platform_data->mem_busaddr = base;
-		ahd->tags[0] = BUS_SPACE_MEMIO;
-		ahd->bshs[0].maddr = maddr;
-		ahd->tags[1] = BUS_SPACE_MEMIO;
-		ahd->bshs[1].maddr = maddr + 0x100;
-		ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
-				     command | PCIM_CMD_MEMEN, 4);
-
-		if (ahd_pci_test_register_access(ahd) != 0) {
-
-			printf("aic79xx: PCI Device %d:%d:%d "
-			       "failed memory mapped test.  Using PIO.\n",
-			       ahd_get_pci_bus(ahd->dev_softc),
-			       ahd_get_pci_slot(ahd->dev_softc),
-			       ahd_get_pci_function(ahd->dev_softc));
-			iounmap((void *)((u_long)maddr & PAGE_MASK));
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-			release_mem_region(ahd->platform_data->mem_busaddr,
-					   0x1000);
-#endif
-			ahd->bshs[0].maddr = NULL;
-			maddr = NULL;
-		} else
-			command |= PCIM_CMD_MEMEN;
-	} else if (bootverbose) {
-		printf("aic79xx: PCI%d:%d:%d MEM region 0x%lx "
-		       "unavailable. Cannot memory map device.\n",
-		       ahd_get_pci_bus(ahd->dev_softc),
-		       ahd_get_pci_slot(ahd->dev_softc),
-		       ahd_get_pci_function(ahd->dev_softc),
-		       base);
-	}
-#endif
-
-	if (maddr == NULL) {
-		u_long	 base2;
-
-		error = ahd_linux_pci_reserve_io_regions(ahd, &base, &base2);
-		if (error == 0) {
-			ahd->tags[0] = BUS_SPACE_PIO;
-			ahd->tags[1] = BUS_SPACE_PIO;
-			ahd->bshs[0].ioport = base;
-			ahd->bshs[1].ioport = base2;
-			command |= PCIM_CMD_PORTEN;
-		} else {
-			printf("aic79xx: PCI%d:%d:%d IO regions 0x%lx and 0x%lx"
-			       "unavailable. Cannot map device.\n",
-			       ahd_get_pci_bus(ahd->dev_softc),
-			       ahd_get_pci_slot(ahd->dev_softc),
-			       ahd_get_pci_function(ahd->dev_softc),
-			       base, base2);
-		}
-	}
-	ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, command, 4);
-	return (error);
-}
-
-int
-ahd_pci_map_int(struct ahd_softc *ahd)
-{
-	int error;
-
-	error = request_irq(ahd->dev_softc->irq, ahd_linux_isr,
-			    SA_SHIRQ, "aic79xx", ahd);
-	if (error == 0)
-		ahd->platform_data->irq = ahd->dev_softc->irq;
-	
-	return (-error);
-}
-
-void
-ahd_power_state_change(struct ahd_softc *ahd, ahd_power_state new_state)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	pci_set_power_state(ahd->dev_softc, new_state);
-#else
-	uint32_t cap;
-	u_int cap_offset;
-
-	/*
-	 * Traverse the capability list looking for
-	 * the power management capability.
-	 */
-	cap = 0;
-	cap_offset = ahd_pci_read_config(ahd->dev_softc,
-					 PCIR_CAP_PTR, /*bytes*/1);
-	while (cap_offset != 0) {
-
-		cap = ahd_pci_read_config(ahd->dev_softc,
-					  cap_offset, /*bytes*/4);
-		if ((cap & 0xFF) == 1
-		 && ((cap >> 16) & 0x3) > 0) {
-			uint32_t pm_control;
-
-			pm_control = ahd_pci_read_config(ahd->dev_softc,
-							 cap_offset + 4,
-							 /*bytes*/4);
-			pm_control &= ~0x3;
-			pm_control |= new_state;
-			ahd_pci_write_config(ahd->dev_softc,
-					     cap_offset + 4,
-					     pm_control, /*bytes*/2);
-			break;
-		}
-		cap_offset = (cap >> 8) & 0xFF;
-	}
-#endif 
-}
diff -urNp linux-5720/drivers/scsi/aic79xx/aic79xx_pci.c linux-5730/drivers/scsi/aic79xx/aic79xx_pci.c
--- linux-5720/drivers/scsi/aic79xx/aic79xx_pci.c
+++ linux-5730/drivers/scsi/aic79xx/aic79xx_pci.c
@@ -1,923 +0,0 @@
-/*
- * Product specific probe and attach routines for:
- *	aic7901 and aic7902 SCSI controllers
- *
- * Copyright (c) 1994-2001 Justin T. Gibbs.
- * Copyright (c) 2000-2002 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx_pci.c#61 $
- *
- * $FreeBSD$
- */
-
-#ifdef __linux__
-#include "aic79xx_osm.h"
-#include "aic79xx_inline.h"
-#else
-#include <dev/aic7xxx/aic79xx_osm.h>
-#include <dev/aic7xxx/aic79xx_inline.h>
-#endif
-
-static __inline uint64_t
-ahd_compose_id(u_int device, u_int vendor, u_int subdevice, u_int subvendor)
-{
-	uint64_t id;
-
-	id = subvendor
-	   | (subdevice << 16)
-	   | ((uint64_t)vendor << 32)
-	   | ((uint64_t)device << 48);
-
-	return (id);
-}
-
-#define ID_ALL_MASK			0xFFFFFFFFFFFFFFFFull
-#define ID_DEV_VENDOR_MASK		0xFFFFFFFF00000000ull
-#define ID_9005_GENERIC_MASK		0xFFF0FFFF00000000ull
-
-#define ID_AIC7901			0x800F9005FFFF9005ull
-#define ID_AIC7901A			0x801E9005FFFF9005ull
-#define ID_AIC7901A_IROC		0x809E9005FFFF9005ull
-#define ID_AHA_29320A			0x8000900500609005ull
-#define ID_AHA_29320LP			0x8014900500449005ull
-#define ID_AHA_29320LP_IROC		0x8094900500449005ull
-
-#define ID_AIC7902			0x801F9005FFFF9005ull
-#define ID_AIC7902_IROC			0x809F9005FFFF9005ull
-#define ID_AIC7902_B			0x801D9005FFFF9005ull
-#define ID_AIC7902_B_IROC		0x809D9005FFFF9005ull
-#define ID_AHA_39320			0x8010900500409005ull
-#define ID_AHA_39320D			0x8011900500419005ull
-#define ID_AHA_39320D_B			0x801C900500419005ull
-#define ID_AHA_39320D_HP		0x8011900500AC0E11ull
-#define ID_AHA_39320D_B_HP		0x801C900500AC0E11ull
-#define ID_AHA_29320			0x8012900500429005ull
-#define ID_AHA_29320B			0x8013900500439005ull
-#define ID_AIC7902_PCI_REV_A4		0x3
-#define ID_AIC7902_PCI_REV_B0		0x10
-#define SUBID_HP			0x0E11
-
-#define DEVID_9005_TYPE(id) ((id) & 0xF)
-#define		DEVID_9005_TYPE_HBA		0x0	/* Standard Card */
-#define		DEVID_9005_TYPE_HBA_2EXT	0x1	/* 2 External Ports */
-#define		DEVID_9005_TYPE_IROC		0x8	/* Raid(0,1,10) Card */
-#define		DEVID_9005_TYPE_MB		0xF	/* On Motherboard */
-
-#define DEVID_9005_MFUNC(id) ((id) & 0x10)
-
-#define DEVID_9005_PACKETIZED(id) ((id) & 0x8000)
-
-#define SUBID_9005_TYPE(id) ((id) & 0xF)
-#define		SUBID_9005_TYPE_HBA		0x0	/* Standard Card */
-#define		SUBID_9005_TYPE_MB		0xF	/* On Motherboard */
-
-#define SUBID_9005_AUTOTERM(id)	(((id) & 0x10) == 0)
-
-#define SUBID_9005_LEGACYCONN_FUNC(id) ((id) & 0x20)
-
-#define SUBID_9005_SEEPTYPE(id) ((id) & 0x0C0) >> 6)
-#define		SUBID_9005_SEEPTYPE_NONE	0x0
-#define		SUBID_9005_SEEPTYPE_4K		0x1
-
-static ahd_device_setup_t ahd_aic7901A_setup;
-static ahd_device_setup_t ahd_aic7902_setup;
-
-struct ahd_pci_identity ahd_pci_ident_table [] =
-{
-	/* aic7901A based controllers */
-	{
-		ID_AHA_29320LP,
-		ID_ALL_MASK,
-		"Adaptec 29320LP Ultra320 SCSI adapter",
-		ahd_aic7901A_setup
-	},
-	{
-		ID_AHA_29320A,
-		ID_ALL_MASK,
-		"Adaptec 29320A Ultra320 SCSI adapter",
-		ahd_aic7901A_setup
-	},
-	/* aic7902 based controllers */	
-	{
-		ID_AHA_39320,
-		ID_ALL_MASK,
-		"Adaptec 39320 Ultra320 SCSI adapter",
-		ahd_aic7902_setup
-	},
-	{
-		ID_AHA_39320D,
-		ID_ALL_MASK,
-		"Adaptec 39320D Ultra320 SCSI adapter",
-		ahd_aic7902_setup
-	},
-	{
-		ID_AHA_39320D_HP,
-		ID_ALL_MASK,
-		"Adaptec (HP OEM) 39320D Ultra320 SCSI adapter",
-		ahd_aic7902_setup
-	},
-	{
-		ID_AHA_39320D_B,
-		ID_ALL_MASK,
-		"Adaptec 39320D Ultra320 SCSI adapter",
-		ahd_aic7902_setup
-	},
-	{
-		ID_AHA_39320D_B_HP,
-		ID_ALL_MASK,
-		"Adaptec (HP OEM) 39320D Ultra320 SCSI adapter",
-		ahd_aic7902_setup
-	},
-	{
-		ID_AHA_29320,
-		ID_ALL_MASK,
-		"Adaptec 29320 Ultra320 SCSI adapter",
-		ahd_aic7902_setup
-	},
-	{
-		ID_AHA_29320B,
-		ID_ALL_MASK,
-		"Adaptec 29320B Ultra320 SCSI adapter",
-		ahd_aic7902_setup
-	},
-	/* Generic chip probes for devices we don't know 'exactly' */
-	{
-		ID_AIC7901A & ID_DEV_VENDOR_MASK,
-		ID_DEV_VENDOR_MASK,
-		"Adaptec AIC7901A Ultra320 SCSI adapter",
-		ahd_aic7901A_setup
-	},
-	{
-		ID_AIC7902 & ID_9005_GENERIC_MASK,
-		ID_9005_GENERIC_MASK,
-		"Adaptec AIC7902 Ultra320 SCSI adapter",
-		ahd_aic7902_setup
-	}
-};
-
-const u_int ahd_num_pci_devs = NUM_ELEMENTS(ahd_pci_ident_table);
-		
-#define	DEVCONFIG		0x40
-#define		PCIXINITPAT	0x0000E000ul
-#define			PCIXINIT_PCI33_66	0x0000E000ul
-#define			PCIXINIT_PCIX50_66	0x0000C000ul
-#define			PCIXINIT_PCIX66_100	0x0000A000ul
-#define			PCIXINIT_PCIX100_133	0x00008000ul
-#define	PCI_BUS_MODES_INDEX(devconfig)	\
-	(((devconfig) & PCIXINITPAT) >> 13)
-static const char *pci_bus_modes[] =
-{
-	"PCI bus mode unknown",
-	"PCI bus mode unknown",
-	"PCI bus mode unknown",
-	"PCI bus mode unknown",
-	"PCI-X 101-133Mhz",
-	"PCI-X 67-100Mhz",
-	"PCI-X 50-66Mhz",
-	"PCI 33 or 66Mhz"
-};
-
-#define		TESTMODE	0x00000800ul
-#define		IRDY_RST	0x00000200ul
-#define		FRAME_RST	0x00000100ul
-#define		PCI64BIT	0x00000080ul
-#define		MRDCEN		0x00000040ul
-#define		ENDIANSEL	0x00000020ul
-#define		MIXQWENDIANEN	0x00000008ul
-#define		DACEN		0x00000004ul
-#define		STPWLEVEL	0x00000002ul
-#define		QWENDIANSEL	0x00000001ul
-
-#define	DEVCONFIG1		0x44
-#define		PREQDIS		0x01
-
-#define	CSIZE_LATTIME		0x0c
-#define		CACHESIZE	0x000000fful
-#define		LATTIME		0x0000ff00ul
-
-static int	ahd_check_extport(struct ahd_softc *ahd);
-static void	ahd_configure_termination(struct ahd_softc *ahd,
-					  u_int adapter_control);
-static void	ahd_pci_split_intr(struct ahd_softc *ahd, u_int intstat);
-
-struct ahd_pci_identity *
-ahd_find_pci_device(ahd_dev_softc_t pci)
-{
-	uint64_t  full_id;
-	uint16_t  device;
-	uint16_t  vendor;
-	uint16_t  subdevice;
-	uint16_t  subvendor;
-	struct	  ahd_pci_identity *entry;
-	u_int	  i;
-
-	vendor = ahd_pci_read_config(pci, PCIR_DEVVENDOR, /*bytes*/2);
-	device = ahd_pci_read_config(pci, PCIR_DEVICE, /*bytes*/2);
-	subvendor = ahd_pci_read_config(pci, PCIR_SUBVEND_0, /*bytes*/2);
-	subdevice = ahd_pci_read_config(pci, PCIR_SUBDEV_0, /*bytes*/2);
-	full_id = ahd_compose_id(device,
-				 vendor,
-				 subdevice,
-				 subvendor);
-
-	for (i = 0; i < ahd_num_pci_devs; i++) {
-		entry = &ahd_pci_ident_table[i];
-		if (entry->full_id == (full_id & entry->id_mask)) {
-			/* Honor exclusion entries. */
-			if (entry->name == NULL)
-				return (NULL);
-			return (entry);
-		}
-	}
-	return (NULL);
-}
-
-int
-ahd_pci_config(struct ahd_softc *ahd, struct ahd_pci_identity *entry)
-{
-	struct scb_data *shared_scb_data;
-	u_long		 l;
-	u_int		 command;
-	uint32_t	 devconfig;
-	uint16_t	 subvendor; 
-	int		 error;
-
-	shared_scb_data = NULL;
-	ahd->description = entry->name;
-	/*
-	 * Record if this is an HP board.
-	 */
-	subvendor = ahd_pci_read_config(ahd->dev_softc,
-					PCIR_SUBVEND_0, /*bytes*/2);
-	if (subvendor == SUBID_HP)
-		ahd->flags |= AHD_HP_BOARD;
-
-	error = entry->setup(ahd);
-	if (error != 0)
-		return (error);
-	
-	devconfig = ahd_pci_read_config(ahd->dev_softc, DEVCONFIG, /*bytes*/4);
-	if ((devconfig & PCIXINITPAT) == PCIXINIT_PCI33_66) {
-		ahd->chip |= AHD_PCI;
-		/* Disable PCIX workarounds when running in PCI mode. */
-		ahd->bugs &= ~AHD_PCIX_BUG_MASK;
-	} else {
-		ahd->chip |= AHD_PCIX;
-	}
-	ahd->bus_description = pci_bus_modes[PCI_BUS_MODES_INDEX(devconfig)];
-
-	ahd_power_state_change(ahd, AHD_POWER_STATE_D0);
-
-	error = ahd_pci_map_registers(ahd);
-	if (error != 0)
-		return (error);
-
-	/*
-	 * If we need to support high memory, enable dual
-	 * address cycles.  This bit must be set to enable
-	 * high address bit generation even if we are on a
-	 * 64bit bus (PCI64BIT set in devconfig).
-	 */
-	if ((ahd->flags & (AHD_39BIT_ADDRESSING|AHD_64BIT_ADDRESSING)) != 0) {
-		uint32_t devconfig;
-
-		if (bootverbose)
-			printf("%s: Enabling 39Bit Addressing\n",
-			       ahd_name(ahd));
-		devconfig = ahd_pci_read_config(ahd->dev_softc,
-						DEVCONFIG, /*bytes*/4);
-		devconfig |= DACEN;
-		ahd_pci_write_config(ahd->dev_softc, DEVCONFIG,
-				     devconfig, /*bytes*/4);
-	}
-	
-	/* Ensure busmastering is enabled */
-	command = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, /*bytes*/1);
-	command |= PCIM_CMD_BUSMASTEREN;
-	ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, command, /*bytes*/1);
-
-	error = ahd_softc_init(ahd);
-	if (error != 0)
-		return (error);
-
-	ahd->bus_intr = ahd_pci_intr;
-
-	error = ahd_reset(ahd);
-	if (error != 0)
-		return (ENXIO);
-
-	ahd->pci_cachesize =
-	    ahd_pci_read_config(ahd->dev_softc, CSIZE_LATTIME,
-				/*bytes*/1) & CACHESIZE;
-	ahd->pci_cachesize *= 4;
-
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	/* See if we have a SEEPROM and perform auto-term */
-	error = ahd_check_extport(ahd);
-	if (error != 0)
-		return (error);
-
-	/* Core initialization */
-	error = ahd_init(ahd);
-	if (error != 0)
-		return (error);
-
-	/*
-	 * Allow interrupts now that we are completely setup.
-	 */
-	error = ahd_pci_map_int(ahd);
-	if (error != 0)
-		return (error);
-
-	ahd_list_lock(&l);
-	/*
-	 * Link this softc in with all other ahd instances.
-	 */
-	ahd_softc_insert(ahd);
-	ahd_list_unlock(&l);
-	return (0);
-}
-
-/*
- * Perform some simple tests that should catch situations where
- * our registers are invalidly mapped.
- */
-int
-ahd_pci_test_register_access(struct ahd_softc *ahd)
-{
-	ahd_mode_state	saved_modes;
-	uint32_t	cmd;
-	int		error;
-	uint8_t		hcntrl;
-
-	saved_modes = ahd_save_modes(ahd);
-	error = EIO;
-
-	/*
-	 * Enable PCI error interrupt status, but suppress NMIs
-	 * generated by SERR raised due to target aborts.
-	 */
-	cmd = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, /*bytes*/2);
-	ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
-			     cmd & ~PCIM_CMD_SERRESPEN, /*bytes*/2);
-
-	/*
-	 * First a simple test to see if any
-	 * registers can be read.  Reading
-	 * HCNTRL has no side effects and has
-	 * at least one bit that is guaranteed to
-	 * be zero so it is a good register to
-	 * use for this test.
-	 */
-	hcntrl = ahd_inb(ahd, HCNTRL);
-	if (hcntrl == 0xFF)
-		goto fail;
-
-	/*
-	 * Next create a situation where write combining
-	 * or read prefetching could be initiated by the
-	 * CPU or host bridge.  Our device does not support
-	 * either, so look for data corruption and/or flaged
-	 * PCI errors.
-	 */
-	ahd_outb(ahd, HCNTRL, hcntrl|PAUSE);
-	while (ahd_is_paused(ahd) == 0)
-		;
-	ahd_outb(ahd, SEQCTL0, PERRORDIS);
-	ahd_outl(ahd, SRAM_BASE, 0x5aa555aa);
-	if (ahd_inl(ahd, SRAM_BASE) != 0x5aa555aa)
-		goto fail;
-
-	if ((ahd_inb(ahd, INTSTAT) & PCIINT) != 0) {
-		u_int targpcistat;
-
-		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
-		targpcistat = ahd_inb(ahd, TARGPCISTAT);
-		if ((targpcistat & STA) != 0)
-			goto fail;
-	}
-
-	error = 0;
-
-fail:
-	if ((ahd_inb(ahd, INTSTAT) & PCIINT) != 0) {
-		u_int targpcistat;
-		u_int pci_status1;
-
-		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
-		targpcistat = ahd_inb(ahd, TARGPCISTAT);
-
-		/* Silently clear any latched errors. */
-		ahd_outb(ahd, TARGPCISTAT, targpcistat);
-		pci_status1 = ahd_pci_read_config(ahd->dev_softc,
-						  PCIR_STATUS + 1, /*bytes*/1);
-		ahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
-				     pci_status1, /*bytes*/1);
-		ahd_outb(ahd, CLRINT, CLRPCIINT);
-	}
-
-	ahd_restore_modes(ahd, saved_modes);
-	ahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS);
-	ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, cmd, /*bytes*/2);
-	return (error);
-}
-
-/*
- * Check the external port logic for a serial eeprom
- * and termination/cable detection contrls.
- */
-static int
-ahd_check_extport(struct ahd_softc *ahd)
-{
-	struct	seeprom_config *sc;
-	u_int	adapter_control;
-	int	have_seeprom;
-	int	error;
-
-	sc = ahd->seep_config;
-	have_seeprom = ahd_acquire_seeprom(ahd);
-	if (have_seeprom) {
-		u_int start_addr;
-
-		if (bootverbose) 
-			printf("%s: Reading SEEPROM...", ahd_name(ahd));
-
-		/* Address is always in units of 16bit words */
-		start_addr = (sizeof(*sc) / 2) * (ahd->channel - 'A');
-
-		error = ahd_read_seeprom(ahd, (uint16_t *)sc,
-					 start_addr, sizeof(*sc)/2);
-
-		if (error != 0) {
-			printf("Unable to read SEEPROM\n");
-			have_seeprom = 0;
-		} else {
-			have_seeprom = ahd_verify_cksum(sc);
-
-			if (bootverbose) {
-				if (have_seeprom == 0)
-					printf ("checksum error\n");
-				else
-					printf ("done.\n");
-			}
-		}
-		ahd_release_seeprom(ahd);
-	}
-
-	if (!have_seeprom) {
-		u_int	  nvram_scb;
-
-		/*
-		 * Pull scratch ram settings and treat them as
-		 * if they are the contents of an seeprom if
-		 * the 'ADPT', 'BIOS', or 'ASPI' signature is found
-		 * in SCB 0xFF.  We manually compose the data as 16bit
-		 * values to avoid endian issues.
-		 */
-		ahd_set_scbptr(ahd, 0xFF);
-		nvram_scb = ahd_inb_scbram(ahd, SCB_BASE + NVRAM_SCB_OFFSET);
-		if (nvram_scb != 0xFF
-		 && ((ahd_inb_scbram(ahd, SCB_BASE + 0) == 'A'
-		   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'D'
-		   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'P'
-		   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'T')
-		  || (ahd_inb_scbram(ahd, SCB_BASE + 0) == 'B'
-		   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'I'
-		   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'O'
-		   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'S')
-		  || (ahd_inb_scbram(ahd, SCB_BASE + 0) == 'A'
-		   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'S'
-		   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'P'
-		   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'I'))) {
-			uint16_t *sc_data;
-			int	  i;
-
-			ahd_set_scbptr(ahd, nvram_scb);
-			sc_data = (uint16_t *)sc;
-			for (i = 0; i < 64; i += 2)
-				*sc_data++ = ahd_inw_scbram(ahd, SCB_BASE+i);
-			have_seeprom = ahd_verify_cksum(sc);
-			if (have_seeprom)
-				ahd->flags |= AHD_SCB_CONFIG_USED;
-		}
-	}
-
-#if AHD_DEBUG
-	if (have_seeprom != 0
-	 && (ahd_debug & AHD_DUMP_SEEPROM) != 0) {
-		uint8_t *sc_data;
-		int	 i;
-
-		printf("%s: Seeprom Contents:", ahd_name(ahd));
-		sc_data = (uint8_t *)sc;
-		for (i = 0; i < (sizeof(*sc)); i += 2)
-			printf("\n\t0x%.4x", 
-			       sc_data[i] | (sc_data[i+1] << 8));
-		printf("\n");
-	}
-#endif
-
-	if (!have_seeprom) {
-		if (bootverbose)
-			printf("%s: No SEEPROM available.\n", ahd_name(ahd));
-		ahd->flags |= AHD_USEDEFAULTS;
-		error = ahd_default_config(ahd);
-		adapter_control = CFAUTOTERM|CFSEAUTOTERM;
-		free(ahd->seep_config, M_DEVBUF);
-		ahd->seep_config = NULL;
-	} else {
-		error = ahd_parse_cfgdata(ahd, sc);
-		adapter_control = sc->adapter_control;
-	}
-	if (error != 0)
-		return (error);
-
-	ahd_configure_termination(ahd, adapter_control);
-
-	return (0);
-}
-
-static void
-ahd_configure_termination(struct ahd_softc *ahd, u_int adapter_control)
-{
-	int	 error;
-	u_int	 sxfrctl1;
-	uint8_t	 termctl;
-	uint32_t devconfig;
-
-	devconfig = ahd_pci_read_config(ahd->dev_softc, DEVCONFIG, /*bytes*/4);
-	devconfig &= ~STPWLEVEL;
-	if ((ahd->flags & AHD_STPWLEVEL_A) != 0)
-		devconfig |= STPWLEVEL;
-	if (bootverbose)
-		printf("%s: STPWLEVEL is %s\n",
-		       ahd_name(ahd), (devconfig & STPWLEVEL) ? "on" : "off");
-	ahd_pci_write_config(ahd->dev_softc, DEVCONFIG, devconfig, /*bytes*/4);
- 
-	/* Make sure current sensing is off. */
-	if ((ahd->flags & AHD_CURRENT_SENSING) != 0) {
-		(void)ahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, 0);
-	}
-
-	/*
-	 * Read to sense.  Write to set.
-	 */
-	error = ahd_read_flexport(ahd, FLXADDR_TERMCTL, &termctl);
-	if ((adapter_control & CFAUTOTERM) == 0) {
-		if (bootverbose)
-			printf("%s: Manual Primary Termination\n",
-			       ahd_name(ahd));
-		termctl &= ~(FLX_TERMCTL_ENPRILOW|FLX_TERMCTL_ENPRIHIGH);
-		if ((adapter_control & CFSTERM) != 0)
-			termctl |= FLX_TERMCTL_ENPRILOW;
-		if ((adapter_control & CFWSTERM) != 0)
-			termctl |= FLX_TERMCTL_ENPRIHIGH;
-	} else if (error != 0) {
-		printf("%s: Primary Auto-Term Sensing failed! "
-		       "Using Defaults.\n", ahd_name(ahd));
-		termctl = FLX_TERMCTL_ENPRILOW|FLX_TERMCTL_ENPRIHIGH;
-	}
-
-	if ((adapter_control & CFSEAUTOTERM) == 0) {
-		if (bootverbose)
-			printf("%s: Manual Secondary Termination\n",
-			       ahd_name(ahd));
-		termctl &= ~(FLX_TERMCTL_ENSECLOW|FLX_TERMCTL_ENSECHIGH);
-		if ((adapter_control & CFSELOWTERM) != 0)
-			termctl |= FLX_TERMCTL_ENSECLOW;
-		if ((adapter_control & CFSEHIGHTERM) != 0)
-			termctl |= FLX_TERMCTL_ENSECHIGH;
-	} else if (error != 0) {
-		printf("%s: Secondary Auto-Term Sensing failed! "
-		       "Using Defaults.\n", ahd_name(ahd));
-		termctl |= FLX_TERMCTL_ENSECLOW|FLX_TERMCTL_ENSECHIGH;
-	}
-
-	/*
-	 * Now set the termination based on what we found.
-	 */
-	sxfrctl1 = ahd_inb(ahd, SXFRCTL1) & ~STPWEN;
-	if ((termctl & FLX_TERMCTL_ENPRILOW) != 0) {
-		ahd->flags |= AHD_TERM_ENB_A;
-		sxfrctl1 |= STPWEN;
-	}
-	/* Must set the latch once in order to be effective. */
-	ahd_outb(ahd, SXFRCTL1, sxfrctl1|STPWEN);
-	ahd_outb(ahd, SXFRCTL1, sxfrctl1);
-
-	error = ahd_write_flexport(ahd, FLXADDR_TERMCTL, termctl);
-	if (error != 0) {
-		printf("%s: Unable to set termination settings!\n",
-		       ahd_name(ahd));
-	} else if (bootverbose) {
-		printf("%s: Primary High byte termination %sabled\n",
-		       ahd_name(ahd),
-		       (termctl & FLX_TERMCTL_ENPRIHIGH) ? "En" : "Dis");
-
-		printf("%s: Primary Low byte termination %sabled\n",
-		       ahd_name(ahd),
-		       (termctl & FLX_TERMCTL_ENPRILOW) ? "En" : "Dis");
-
-		printf("%s: Secondary High byte termination %sabled\n",
-		       ahd_name(ahd),
-		       (termctl & FLX_TERMCTL_ENSECHIGH) ? "En" : "Dis");
-
-		printf("%s: Secondary Low byte termination %sabled\n",
-		       ahd_name(ahd),
-		       (termctl & FLX_TERMCTL_ENSECLOW) ? "En" : "Dis");
-	}
-	return;
-}
-
-#define	DPE	0x80
-#define SSE	0x40
-#define	RMA	0x20
-#define	RTA	0x10
-#define STA	0x08
-#define DPR	0x01
-
-static const char *split_status_source[] =
-{
-	"DFF0",
-	"DFF1",
-	"OVLY",
-	"CMC",
-};
-
-static const char *pci_status_source[] =
-{
-	"DFF0",
-	"DFF1",
-	"SG",
-	"CMC",
-	"OVLY",
-	"NONE",
-	"MSI",
-	"TARG"
-};
-
-static const char *split_status_strings[] =
-{
-	"%s: Received split response in %s.\n"
-	"%s: Received split completion error message in %s\n",
-	"%s: Receive overrun in %s\n",
-	"%s: Count not complete in %s\n",
-	"%s: Split completion data bucket in %s\n",
-	"%s: Split completion address error in %s\n",
-	"%s: Split completion byte count error in %s\n",
-	"%s: Signaled Target-abort to early terminate a split in %s\n",
-};
-
-static const char *pci_status_strings[] =
-{
-	"%s: Data Parity Error has been reported via PERR# in %s\n",
-	"%s: Target initial wait state error in %s\n",
-	"%s: Split completion read data parity error in %s\n",
-	"%s: Split completion address attribute parity error in %s\n",
-	"%s: Received a Target Abort in %s\n",
-	"%s: Received a Master Abort in %s\n",
-	"%s: Signal System Error Detected in %s\n",
-	"%s: Address or Write Phase Parity Error Detected in %s.\n"
-};
-
-void
-ahd_pci_intr(struct ahd_softc *ahd)
-{
-	uint8_t		pci_status[8];
-	ahd_mode_state	saved_modes;
-	u_int		pci_status1;
-	u_int		intstat;
-	u_int		i;
-	u_int		reg;
-	
-	intstat = ahd_inb(ahd, INTSTAT);
-
-	if ((intstat & SPLTINT) != 0)
-		ahd_pci_split_intr(ahd, intstat);
-
-	if ((intstat & PCIINT) == 0)
-		return;
-
-	printf("%s: PCI error Interrupt\n", ahd_name(ahd));
-	saved_modes = ahd_save_modes(ahd);
-	ahd_dump_card_state(ahd);
-	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
-	for (i = 0, reg = DF0PCISTAT; i < 8; i++, reg++) {
-
-		if (i == 5)
-			continue;
-		pci_status[i] = ahd_inb(ahd, reg);
-		/* Clear latched errors.  So our interupt deasserts. */
-		ahd_outb(ahd, reg, pci_status[i]);
-	}
-
-	for (i = 0; i < 8; i++) {
-		u_int bit;
-	
-		if (i == 5)
-			continue;
-
-		for (bit = 0; bit < 8; bit++) {
-
-			if ((pci_status[i] & (0x1 << bit)) != 0) {
-				static const char *s;
-
-				s = pci_status_strings[bit];
-				if (i == 7/*TARG*/ && bit == 3)
-					s = "%s: Signaled Target Abort\n";
-				printf(s, ahd_name(ahd), pci_status_source[i]);
-			}
-		}	
-	}
-	pci_status1 = ahd_pci_read_config(ahd->dev_softc,
-					  PCIR_STATUS + 1, /*bytes*/1);
-	ahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
-			     pci_status1, /*bytes*/1);
-	ahd_restore_modes(ahd, saved_modes);
-	ahd_outb(ahd, CLRINT, CLRPCIINT);
-	ahd_unpause(ahd);
-}
-
-static void
-ahd_pci_split_intr(struct ahd_softc *ahd, u_int intstat)
-{
-	uint8_t		split_status[4];
-	uint8_t		split_status1[4];
-	uint8_t		sg_split_status[2];
-	uint8_t		sg_split_status1[2];
-	ahd_mode_state	saved_modes;
-	u_int		i;
-	uint16_t	pcix_status;
-
-	/*
-	 * Check for splits in all modes.  Modes 0 and 1
-	 * additionally have SG engine splits to look at.
-	 */
-	pcix_status = ahd_pci_read_config(ahd->dev_softc, PCIXR_STATUS,
-					  /*bytes*/2);
-	printf("%s: PCI Split Interrupt - PCI-X status = 0x%x\n",
-	       ahd_name(ahd), pcix_status);
-	saved_modes = ahd_save_modes(ahd);
-	for (i = 0; i < 4; i++) {
-		ahd_set_modes(ahd, i, i);
-
-		split_status[i] = ahd_inb(ahd, DCHSPLTSTAT0);
-		split_status1[i] = ahd_inb(ahd, DCHSPLTSTAT1);
-		/* Clear latched errors.  So our interupt deasserts. */
-		ahd_outb(ahd, DCHSPLTSTAT0, split_status[i]);
-		ahd_outb(ahd, DCHSPLTSTAT1, split_status1[i]);
-		if (i != 0)
-			continue;
-		sg_split_status[i] = ahd_inb(ahd, SGSPLTSTAT0);
-		sg_split_status1[i] = ahd_inb(ahd, SGSPLTSTAT1);
-		/* Clear latched errors.  So our interupt deasserts. */
-		ahd_outb(ahd, SGSPLTSTAT0, sg_split_status[i]);
-		ahd_outb(ahd, SGSPLTSTAT1, sg_split_status1[i]);
-	}
-
-	for (i = 0; i < 4; i++) {
-		u_int bit;
-
-		for (bit = 0; bit < 8; bit++) {
-
-			if ((split_status[i] & (0x1 << bit)) != 0) {
-				static const char *s;
-
-				s = split_status_strings[bit];
-				printf(s, ahd_name(ahd),
-				       split_status_source[i]);
-			}
-
-			if (i != 0)
-				continue;
-
-			if ((sg_split_status[i] & (0x1 << bit)) != 0) {
-				static const char *s;
-
-				s = split_status_strings[bit];
-				printf(s, ahd_name(ahd), "SG");
-			}
-		}
-	}
-	/*
-	 * Clear PCI-X status bits.
-	 */
-	ahd_pci_write_config(ahd->dev_softc, PCIXR_STATUS,
-			     pcix_status, /*bytes*/2);
-	ahd_outb(ahd, CLRINT, CLRSPLTINT);
-	ahd_restore_modes(ahd, saved_modes);
-}
-
-static int
-ahd_aic7901A_setup(struct ahd_softc *ahd)
-{
-	int error;
-
-	error = ahd_aic7902_setup(ahd);
-	if (error != 0)
-		return (error);
-	ahd->chip = AHD_AIC7901A;
-	return (0);
-}
-
-static int
-ahd_aic7902_setup(struct ahd_softc *ahd)
-{
-	ahd_dev_softc_t pci;
-	u_int rev;
-
-	pci = ahd->dev_softc;
-	rev = ahd_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
-	if (rev < ID_AIC7902_PCI_REV_A4) {
-		printf("%s: Unable to attach to unsupported chip revision %d\n",
-		       ahd_name(ahd), rev);
-		ahd_pci_write_config(pci, PCIR_COMMAND, 0, /*bytes*/1);
-		return (ENXIO);
-	}
-	ahd->channel = ahd_get_pci_function(pci) + 'A';
-	ahd->chip = AHD_AIC7902;
-	ahd->features = AHD_AIC7902_FE;
-	if (rev < ID_AIC7902_PCI_REV_B0) {
-		/*
-		 * Enable A series workarounds.
-		 */
-		ahd->bugs |= AHD_SENT_SCB_UPDATE_BUG|AHD_ABORT_LQI_BUG
-			  |  AHD_PKT_BITBUCKET_BUG|AHD_LONG_SETIMO_BUG
-			  |  AHD_NLQICRC_DELAYED_BUG|AHD_SCSIRST_BUG
-			  |  AHD_LQO_ATNO_BUG|AHD_AUTOFLUSH_BUG
-			  |  AHD_CLRLQO_AUTOCLR_BUG|AHD_PCIX_MMAPIO_BUG
-			  |  AHD_PCIX_CHIPRST_BUG|AHD_PKTIZED_STATUS_BUG
-			  |  AHD_PKT_LUN_BUG|AHD_MDFF_WSCBPTR_BUG
-			  |  AHD_REG_SLOW_SETTLE_BUG|AHD_SET_MODE_BUG
-			  |  AHD_BUSFREEREV_BUG|AHD_NONPACKFIFO_BUG
-			  |  AHD_PACED_NEGTABLE_BUG;
-
-		/*
-		 * IO Cell paramter setup.
-		 */
-		AHD_SET_PRECOMP(ahd, AHD_PRECOMP_CUTBACK_29);
-
-		if ((ahd->flags & AHD_HP_BOARD) == 0)
-			AHD_SET_SLEWRATE(ahd, AHD_SLEWRATE_DEF_REVA);
-	} else {
-		u_int devconfig1;
-
-		ahd->features |= AHD_RTI|AHD_NEW_IOCELL_OPTS
-			      |  AHD_NEW_DFCNTRL_OPTS;
-		ahd->bugs |= AHD_LQOOVERRUN_BUG|AHD_ABORT_LQI_BUG
-			  |  AHD_INTCOLLISION_BUG;
-
-		/*
-		 * IO Cell paramter setup.
-		 */
-		AHD_SET_PRECOMP(ahd, AHD_PRECOMP_CUTBACK_29);
-		AHD_SET_SLEWRATE(ahd, AHD_SLEWRATE_DEF_REVB);
-		AHD_SET_AMPLITUDE(ahd, AHD_AMPLITUDE_DEF);
-
-		/*
-		 * Set the PREQDIS bit for H2B which disables some workaround
-		 * that doesn't work on regular PCI busses.
-		 * XXX - Find out exactly what this does from the hardware
-		 * 	 folks!
-		 */
-		devconfig1 = ahd_pci_read_config(pci, DEVCONFIG1, /*bytes*/1);
-		ahd_pci_write_config(pci, DEVCONFIG1,
-				     devconfig1|PREQDIS, /*bytes*/1);
-		devconfig1 = ahd_pci_read_config(pci, DEVCONFIG1, /*bytes*/1);
-	}
-
-	return (0);
-}
diff -urNp linux-5720/drivers/scsi/aic79xx/aic79xx_proc.c linux-5730/drivers/scsi/aic79xx/aic79xx_proc.c
--- linux-5720/drivers/scsi/aic79xx/aic79xx_proc.c
+++ linux-5730/drivers/scsi/aic79xx/aic79xx_proc.c
@@ -1,345 +0,0 @@
-/*
- * Copyright (c) 2000-2001 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * String handling code courtesy of Gerard Roudier's <groudier@club-internet.fr>
- * sym driver.
- *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#11 $
- */
-#include "aic79xx_osm.h"
-#include "aic79xx_inline.h"
-
-static void	copy_mem_info(struct info_str *info, char *data, int len);
-static int	copy_info(struct info_str *info, char *fmt, ...);
-static void	ahd_dump_target_state(struct ahd_softc *ahd,
-				      struct info_str *info,
-				      u_int our_id, char channel,
-				      u_int target_id, u_int target_offset);
-static void	ahd_dump_device_state(struct info_str *info,
-				      struct ahd_linux_device *dev);
-static int	ahd_proc_write_seeprom(struct ahd_softc *ahd,
-				       char *buffer, int length);
-
-static void
-copy_mem_info(struct info_str *info, char *data, int len)
-{
-	if (info->pos + len > info->offset + info->length)
-		len = info->offset + info->length - info->pos;
-
-	if (info->pos + len < info->offset) {
-		info->pos += len;
-		return;
-	}
-
-	if (info->pos < info->offset) {
-		off_t partial;
-
-		partial = info->offset - info->pos;
-		data += partial;
-		info->pos += partial;
-		len  -= partial;
-	}
-
-	if (len > 0) {
-		memcpy(info->buffer, data, len);
-		info->pos += len;
-		info->buffer += len;
-	}
-}
-
-static int
-copy_info(struct info_str *info, char *fmt, ...)
-{
-	va_list args;
-	char buf[256];
-	int len;
-
-	va_start(args, fmt);
-	len = vsprintf(buf, fmt, args);
-	va_end(args);
-
-	copy_mem_info(info, buf, len);
-	return (len);
-}
-
-void
-ahd_format_transinfo(struct info_str *info, struct ahd_transinfo *tinfo)
-{
-	u_int speed;
-	u_int freq;
-	u_int mb;
-
-	if (tinfo->period == AHD_PERIOD_UNKNOWN) {
-		copy_info(info, "Renegotiation Pending\n");
-		return;
-	}
-        speed = 3300;
-        freq = 0;
-	if (tinfo->offset != 0) {
-		freq = aic_calc_syncsrate(tinfo->period);
-		speed = freq;
-	}
-	speed *= (0x01 << tinfo->width);
-        mb = speed / 1000;
-        if (mb > 0)
-		copy_info(info, "%d.%03dMB/s transfers", mb, speed % 1000);
-        else
-		copy_info(info, "%dKB/s transfers", speed);
-
-	if (freq != 0) {
-		int	printed_options;
-
-		printed_options = 0;
-		copy_info(info, " (%d.%03dMHz", freq / 1000, freq % 1000);
-		if ((tinfo->ppr_options & MSG_EXT_PPR_DT_REQ) != 0) {
-			copy_info(info, " DT");
-			printed_options++;
-		}
-		if ((tinfo->ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
-			copy_info(info, "%s", printed_options ? "|IU" : " IU");
-			printed_options++;
-		}
-		if ((tinfo->ppr_options & MSG_EXT_PPR_RTI) != 0) {
-			copy_info(info, "%s",
-				  printed_options ? "|RTI" : " RTI");
-			printed_options++;
-		}
-		if ((tinfo->ppr_options & MSG_EXT_PPR_QAS_REQ) != 0) {
-			copy_info(info, "%s",
-				  printed_options ? "|QAS" : " QAS");
-			printed_options++;
-		}
-	}
-
-	if (tinfo->width > 0) {
-		if (freq != 0) {
-			copy_info(info, ", ");
-		} else {
-			copy_info(info, " (");
-		}
-		copy_info(info, "%dbit)", 8 * (0x01 << tinfo->width));
-	} else if (freq != 0) {
-		copy_info(info, ")");
-	}
-	copy_info(info, "\n");
-}
-
-static void
-ahd_dump_target_state(struct ahd_softc *ahd, struct info_str *info,
-		      u_int our_id, char channel, u_int target_id,
-		      u_int target_offset)
-{
-	struct	ahd_linux_target *targ;
-	struct	ahd_initiator_tinfo *tinfo;
-	struct	ahd_tmode_tstate *tstate;
-	int	lun;
-
-	tinfo = ahd_fetch_transinfo(ahd, channel, our_id,
-				    target_id, &tstate);
-	copy_info(info, "Channel %c Target %d Negotiation Settings\n",
-		  channel, target_id);
-	copy_info(info, "\tUser: ");
-	ahd_format_transinfo(info, &tinfo->user);
-	targ = ahd->platform_data->targets[target_offset];
-	if (targ == NULL)
-		return;
-
-	copy_info(info, "\tGoal: ");
-	ahd_format_transinfo(info, &tinfo->goal);
-	copy_info(info, "\tCurr: ");
-	ahd_format_transinfo(info, &tinfo->curr);
-	copy_info(info, "\tTransmission Errors %ld\n", targ->errors_detected);
-
-	for (lun = 0; lun < AHD_NUM_LUNS; lun++) {
-		struct ahd_linux_device *dev;
-
-		dev = targ->devices[lun];
-
-		if (dev == NULL)
-			continue;
-
-		ahd_dump_device_state(info, dev);
-	}
-}
-
-static void
-ahd_dump_device_state(struct info_str *info, struct ahd_linux_device *dev)
-{
-	copy_info(info, "\tChannel %c Target %d Lun %d Settings\n",
-		  dev->target->channel + 'A', dev->target->target, dev->lun);
-
-	copy_info(info, "\t\tCommands Queued %ld\n", dev->commands_issued);
-	copy_info(info, "\t\tCommands Active %d\n", dev->active);
-	copy_info(info, "\t\tCommand Openings %d\n", dev->openings);
-	copy_info(info, "\t\tMax Tagged Openings %d\n", dev->maxtags);
-	copy_info(info, "\t\tDevice Queue Frozen Count %d\n", dev->qfrozen);
-}
-
-static int
-ahd_proc_write_seeprom(struct ahd_softc *ahd, char *buffer, int length)
-{
-	ahd_mode_state saved_modes;
-	int have_seeprom;
-	u_long s;
-	int paused;
-	int written;
-
-	/* Default to failure. */
-	written = -EINVAL;
-	ahd_lock(ahd, &s);
-	paused = ahd_is_paused(ahd);
-	if (!paused)
-		ahd_pause(ahd);
-
-	saved_modes = ahd_save_modes(ahd);
-	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
-	if (length != sizeof(struct seeprom_config)) {
-		printf("ahd_proc_write_seeprom: incorrect buffer size\n");
-		goto done;
-	}
-
-	have_seeprom = ahd_verify_cksum((struct seeprom_config*)buffer);
-	if (have_seeprom == 0) {
-		printf("ahd_proc_write_seeprom: cksum verification failed\n");
-		goto done;
-	}
-
-	have_seeprom = ahd_acquire_seeprom(ahd);
-	if (!have_seeprom) {
-		printf("ahd_proc_write_seeprom: No Serial EEPROM\n");
-		goto done;
-	} else {
-		u_int start_addr;
-
-		if (ahd->seep_config == NULL) {
-			ahd->seep_config = malloc(sizeof(*ahd->seep_config),
-						  M_DEVBUF, M_NOWAIT);
-			if (ahd->seep_config == NULL) {
-				printf("aic79xx: Unable to allocate serial "
-				       "eeprom buffer.  Write failing\n");
-				goto done;
-			}
-		}
-		printf("aic79xx: Writing Serial EEPROM\n");
-		start_addr = 32 * (ahd->channel - 'A');
-		ahd_write_seeprom(ahd, (u_int16_t *)buffer, start_addr,
-				  sizeof(struct seeprom_config)/2);
-		ahd_read_seeprom(ahd, (uint16_t *)ahd->seep_config,
-				 start_addr, sizeof(struct seeprom_config)/2);
-		ahd_release_seeprom(ahd);
-		written = length;
-	}
-
-done:
-	ahd_restore_modes(ahd, saved_modes);
-	if (!paused)
-		ahd_unpause(ahd);
-	ahd_unlock(ahd, &s);
-	return (written);
-}
-/*
- * Return information to handle /proc support for the driver.
- */
-int
-ahd_linux_proc_info(char *buffer, char **start, off_t offset,
-		  int length, int hostno, int inout)
-{
-	struct	ahd_softc *ahd;
-	struct	info_str info;
-	char	ahd_info[256];
-	u_long	l;
-	u_int	max_targ;
-	u_int	i;
-	int	retval;
-
-	retval = -EINVAL;
-	ahd_list_lock(&l);
-	TAILQ_FOREACH(ahd, &ahd_tailq, links) {
-		if (ahd->platform_data->host->host_no == hostno)
-			break;
-	}
-
-	if (ahd == NULL)
-		goto done;
-
-	 /* Has data been written to the file? */ 
-	if (inout == TRUE) {
-		retval = ahd_proc_write_seeprom(ahd, buffer, length);
-		goto done;
-	}
-
-	if (start)
-		*start = buffer;
-
-	info.buffer	= buffer;
-	info.length	= length;
-	info.offset	= offset;
-	info.pos	= 0;
-
-	copy_info(&info, "Adaptec AIC79xx driver version: %s\n",
-		  AIC79XX_DRIVER_VERSION);
-	ahd_controller_info(ahd, ahd_info);
-	copy_info(&info, "%s\n\n", ahd_info);
-
-	if (ahd->seep_config == NULL)
-		copy_info(&info, "No Serial EEPROM\n");
-	else {
-		copy_info(&info, "Serial EEPROM:\n");
-		for (i = 0; i < sizeof(*ahd->seep_config)/2; i++) {
-			if (((i % 8) == 0) && (i != 0)) {
-				copy_info(&info, "\n");
-			}
-			copy_info(&info, "0x%.4x ",
-				  ((uint16_t*)ahd->seep_config)[i]);
-		}
-		copy_info(&info, "\n");
-	}
-	copy_info(&info, "\n");
-
-	max_targ = 15;
-	if ((ahd->features & AHD_WIDE) == 0)
-		max_targ = 7;
-
-	for (i = 0; i <= max_targ; i++) {
-
-		ahd_dump_target_state(ahd, &info, ahd->our_id, 'A',
-				      /*target_id*/i, /*target_offset*/i);
-	}
-	retval = info.pos > info.offset ? info.pos - info.offset : 0;
-done:
-	ahd_list_unlock(&l);
-	return (retval);
-}
diff -urNp linux-5720/drivers/scsi/aic79xx/aic79xx_reg.h linux-5730/drivers/scsi/aic79xx/aic79xx_reg.h
--- linux-5720/drivers/scsi/aic79xx/aic79xx_reg.h
+++ linux-5730/drivers/scsi/aic79xx/aic79xx_reg.h
@@ -1,3778 +0,0 @@
-/*
- * DO NOT EDIT - This file is automatically generated
- *		 from the following source files:
- *
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#78 $
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#60 $
- */
-typedef int (ahd_reg_print_t)(u_int, u_int *, u_int);
-typedef struct ahd_reg_parse_entry {
-	char	*name;
-	uint8_t	 value;
-	uint8_t	 mask;
-} ahd_reg_parse_entry_t;
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_mode_ptr_print;
-#else
-#define ahd_mode_ptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "MODE_PTR", 0x00, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_intstat_print;
-#else
-#define ahd_intstat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "INTSTAT", 0x01, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seqintcode_print;
-#else
-#define ahd_seqintcode_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEQINTCODE", 0x02, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_clrint_print;
-#else
-#define ahd_clrint_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CLRINT", 0x03, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_error_print;
-#else
-#define ahd_error_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ERROR", 0x04, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_clrerr_print;
-#else
-#define ahd_clrerr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CLRERR", 0x04, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_hcntrl_print;
-#else
-#define ahd_hcntrl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "HCNTRL", 0x05, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_hnscb_qoff_print;
-#else
-#define ahd_hnscb_qoff_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "HNSCB_QOFF", 0x06, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_hescb_qoff_print;
-#else
-#define ahd_hescb_qoff_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "HESCB_QOFF", 0x08, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_hs_mailbox_print;
-#else
-#define ahd_hs_mailbox_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "HS_MAILBOX", 0x0b, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_clrseqintstat_print;
-#else
-#define ahd_clrseqintstat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CLRSEQINTSTAT", 0x0c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seqintstat_print;
-#else
-#define ahd_seqintstat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEQINTSTAT", 0x0c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_swtimer_print;
-#else
-#define ahd_swtimer_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SWTIMER", 0x0e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_snscb_qoff_print;
-#else
-#define ahd_snscb_qoff_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SNSCB_QOFF", 0x10, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sescb_qoff_print;
-#else
-#define ahd_sescb_qoff_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SESCB_QOFF", 0x12, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sdscb_qoff_print;
-#else
-#define ahd_sdscb_qoff_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SDSCB_QOFF", 0x14, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_qoff_ctlsta_print;
-#else
-#define ahd_qoff_ctlsta_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "QOFF_CTLSTA", 0x16, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_intctl_print;
-#else
-#define ahd_intctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "INTCTL", 0x18, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dfcntrl_print;
-#else
-#define ahd_dfcntrl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFCNTRL", 0x19, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dscommand0_print;
-#else
-#define ahd_dscommand0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DSCOMMAND0", 0x19, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dfstatus_print;
-#else
-#define ahd_dfstatus_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFSTATUS", 0x1a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sg_cache_shadow_print;
-#else
-#define ahd_sg_cache_shadow_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SG_CACHE_SHADOW", 0x1b, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_arbctl_print;
-#else
-#define ahd_arbctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ARBCTL", 0x1b, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sg_cache_pre_print;
-#else
-#define ahd_sg_cache_pre_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SG_CACHE_PRE", 0x1b, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqin_print;
-#else
-#define ahd_lqin_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQIN", 0x20, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_typeptr_print;
-#else
-#define ahd_typeptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "TYPEPTR", 0x20, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_tagptr_print;
-#else
-#define ahd_tagptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "TAGPTR", 0x21, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lunptr_print;
-#else
-#define ahd_lunptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LUNPTR", 0x22, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_datalenptr_print;
-#else
-#define ahd_datalenptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DATALENPTR", 0x23, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_statlenptr_print;
-#else
-#define ahd_statlenptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "STATLENPTR", 0x24, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmdlenptr_print;
-#else
-#define ahd_cmdlenptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMDLENPTR", 0x25, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_attrptr_print;
-#else
-#define ahd_attrptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ATTRPTR", 0x26, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_flagptr_print;
-#else
-#define ahd_flagptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "FLAGPTR", 0x27, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmdptr_print;
-#else
-#define ahd_cmdptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMDPTR", 0x28, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_qnextptr_print;
-#else
-#define ahd_qnextptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "QNEXTPTR", 0x29, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_idptr_print;
-#else
-#define ahd_idptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "IDPTR", 0x2a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_abrtbyteptr_print;
-#else
-#define ahd_abrtbyteptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ABRTBYTEPTR", 0x2b, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_abrtbitptr_print;
-#else
-#define ahd_abrtbitptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ABRTBITPTR", 0x2c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_maxcmdbytes_print;
-#else
-#define ahd_maxcmdbytes_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "MAXCMDBYTES", 0x2d, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_maxcmd2rcv_print;
-#else
-#define ahd_maxcmd2rcv_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "MAXCMD2RCV", 0x2e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_shortthresh_print;
-#else
-#define ahd_shortthresh_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SHORTTHRESH", 0x2f, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lunlen_print;
-#else
-#define ahd_lunlen_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LUNLEN", 0x30, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cdblimit_print;
-#else
-#define ahd_cdblimit_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CDBLIMIT", 0x31, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_maxcmd_print;
-#else
-#define ahd_maxcmd_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "MAXCMD", 0x32, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_maxcmdcnt_print;
-#else
-#define ahd_maxcmdcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "MAXCMDCNT", 0x33, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqrsvd01_print;
-#else
-#define ahd_lqrsvd01_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQRSVD01", 0x34, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqrsvd16_print;
-#else
-#define ahd_lqrsvd16_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQRSVD16", 0x35, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqrsvd17_print;
-#else
-#define ahd_lqrsvd17_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQRSVD17", 0x36, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmdrsvd0_print;
-#else
-#define ahd_cmdrsvd0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMDRSVD0", 0x37, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqctl0_print;
-#else
-#define ahd_lqctl0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQCTL0", 0x38, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqctl1_print;
-#else
-#define ahd_lqctl1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQCTL1", 0x38, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scsbist0_print;
-#else
-#define ahd_scsbist0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCSBIST0", 0x39, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqctl2_print;
-#else
-#define ahd_lqctl2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQCTL2", 0x39, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scsbist1_print;
-#else
-#define ahd_scsbist1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCSBIST1", 0x3a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scsiseq0_print;
-#else
-#define ahd_scsiseq0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCSISEQ0", 0x3a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scsiseq1_print;
-#else
-#define ahd_scsiseq1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCSISEQ1", 0x3b, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sxfrctl0_print;
-#else
-#define ahd_sxfrctl0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SXFRCTL0", 0x3c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_businitid_print;
-#else
-#define ahd_businitid_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "BUSINITID", 0x3c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dlcount_print;
-#else
-#define ahd_dlcount_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DLCOUNT", 0x3c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sxfrctl1_print;
-#else
-#define ahd_sxfrctl1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SXFRCTL1", 0x3d, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_bustargid_print;
-#else
-#define ahd_bustargid_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "BUSTARGID", 0x3e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sxfrctl2_print;
-#else
-#define ahd_sxfrctl2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SXFRCTL2", 0x3e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dffstat_print;
-#else
-#define ahd_dffstat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFFSTAT", 0x3f, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scsisigo_print;
-#else
-#define ahd_scsisigo_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCSISIGO", 0x40, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_multargid_print;
-#else
-#define ahd_multargid_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "MULTARGID", 0x40, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scsisigi_print;
-#else
-#define ahd_scsisigi_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCSISIGI", 0x41, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scsiphase_print;
-#else
-#define ahd_scsiphase_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCSIPHASE", 0x42, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scsidat0_img_print;
-#else
-#define ahd_scsidat0_img_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCSIDAT0_IMG", 0x43, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scsidat_print;
-#else
-#define ahd_scsidat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCSIDAT", 0x44, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scsibus_print;
-#else
-#define ahd_scsibus_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCSIBUS", 0x46, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_targidin_print;
-#else
-#define ahd_targidin_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "TARGIDIN", 0x48, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_selid_print;
-#else
-#define ahd_selid_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SELID", 0x49, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sblkctl_print;
-#else
-#define ahd_sblkctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SBLKCTL", 0x4a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_optionmode_print;
-#else
-#define ahd_optionmode_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "OPTIONMODE", 0x4a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sstat0_print;
-#else
-#define ahd_sstat0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SSTAT0", 0x4b, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_clrsint0_print;
-#else
-#define ahd_clrsint0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CLRSINT0", 0x4b, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_simode0_print;
-#else
-#define ahd_simode0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SIMODE0", 0x4b, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_clrsint1_print;
-#else
-#define ahd_clrsint1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CLRSINT1", 0x4c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sstat1_print;
-#else
-#define ahd_sstat1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SSTAT1", 0x4c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sstat2_print;
-#else
-#define ahd_sstat2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SSTAT2", 0x4d, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_clrsint2_print;
-#else
-#define ahd_clrsint2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CLRSINT2", 0x4d, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_simode2_print;
-#else
-#define ahd_simode2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SIMODE2", 0x4d, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_perrdiag_print;
-#else
-#define ahd_perrdiag_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "PERRDIAG", 0x4e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqistate_print;
-#else
-#define ahd_lqistate_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQISTATE", 0x4e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_soffcnt_print;
-#else
-#define ahd_soffcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SOFFCNT", 0x4f, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqostate_print;
-#else
-#define ahd_lqostate_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQOSTATE", 0x4f, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqistat0_print;
-#else
-#define ahd_lqistat0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQISTAT0", 0x50, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_clrlqiint0_print;
-#else
-#define ahd_clrlqiint0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CLRLQIINT0", 0x50, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqimode0_print;
-#else
-#define ahd_lqimode0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQIMODE0", 0x50, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqimode1_print;
-#else
-#define ahd_lqimode1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQIMODE1", 0x51, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqistat1_print;
-#else
-#define ahd_lqistat1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQISTAT1", 0x51, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_clrlqiint1_print;
-#else
-#define ahd_clrlqiint1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CLRLQIINT1", 0x51, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqistat2_print;
-#else
-#define ahd_lqistat2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQISTAT2", 0x52, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sstat3_print;
-#else
-#define ahd_sstat3_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SSTAT3", 0x53, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_simode3_print;
-#else
-#define ahd_simode3_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SIMODE3", 0x53, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_clrsint3_print;
-#else
-#define ahd_clrsint3_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CLRSINT3", 0x53, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqomode0_print;
-#else
-#define ahd_lqomode0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQOMODE0", 0x54, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqostat0_print;
-#else
-#define ahd_lqostat0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQOSTAT0", 0x54, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_clrlqoint0_print;
-#else
-#define ahd_clrlqoint0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CLRLQOINT0", 0x54, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqostat1_print;
-#else
-#define ahd_lqostat1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQOSTAT1", 0x55, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_clrlqoint1_print;
-#else
-#define ahd_clrlqoint1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CLRLQOINT1", 0x55, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqomode1_print;
-#else
-#define ahd_lqomode1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQOMODE1", 0x55, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqostat2_print;
-#else
-#define ahd_lqostat2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQOSTAT2", 0x56, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_os_space_cnt_print;
-#else
-#define ahd_os_space_cnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "OS_SPACE_CNT", 0x56, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_simode1_print;
-#else
-#define ahd_simode1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SIMODE1", 0x57, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_gsfifo_print;
-#else
-#define ahd_gsfifo_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "GSFIFO", 0x58, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dffsxfrctl_print;
-#else
-#define ahd_dffsxfrctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFFSXFRCTL", 0x5a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lqoscsctl_print;
-#else
-#define ahd_lqoscsctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LQOSCSCTL", 0x5a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_nextscb_print;
-#else
-#define ahd_nextscb_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "NEXTSCB", 0x5a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_clrseqintsrc_print;
-#else
-#define ahd_clrseqintsrc_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CLRSEQINTSRC", 0x5b, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seqintsrc_print;
-#else
-#define ahd_seqintsrc_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEQINTSRC", 0x5b, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_currscb_print;
-#else
-#define ahd_currscb_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CURRSCB", 0x5c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seqimode_print;
-#else
-#define ahd_seqimode_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEQIMODE", 0x5c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_mdffstat_print;
-#else
-#define ahd_mdffstat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "MDFFSTAT", 0x5d, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_crccontrol_print;
-#else
-#define ahd_crccontrol_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CRCCONTROL", 0x5d, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dfftag_print;
-#else
-#define ahd_dfftag_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFFTAG", 0x5e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lastscb_print;
-#else
-#define ahd_lastscb_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LASTSCB", 0x5e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scsitest_print;
-#else
-#define ahd_scsitest_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCSITEST", 0x5e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_iopdnctl_print;
-#else
-#define ahd_iopdnctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "IOPDNCTL", 0x5f, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_shaddr_print;
-#else
-#define ahd_shaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SHADDR", 0x60, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_negoaddr_print;
-#else
-#define ahd_negoaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "NEGOADDR", 0x60, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dgrpcrci_print;
-#else
-#define ahd_dgrpcrci_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DGRPCRCI", 0x60, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_negperiod_print;
-#else
-#define ahd_negperiod_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "NEGPERIOD", 0x61, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_packcrci_print;
-#else
-#define ahd_packcrci_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "PACKCRCI", 0x62, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_negoffset_print;
-#else
-#define ahd_negoffset_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "NEGOFFSET", 0x62, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_negppropts_print;
-#else
-#define ahd_negppropts_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "NEGPPROPTS", 0x63, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_negconopts_print;
-#else
-#define ahd_negconopts_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "NEGCONOPTS", 0x64, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_annexcol_print;
-#else
-#define ahd_annexcol_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ANNEXCOL", 0x65, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scschkn_print;
-#else
-#define ahd_scschkn_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCSCHKN", 0x66, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_annexdat_print;
-#else
-#define ahd_annexdat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ANNEXDAT", 0x66, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_iownid_print;
-#else
-#define ahd_iownid_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "IOWNID", 0x67, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_pll960ctl0_print;
-#else
-#define ahd_pll960ctl0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "PLL960CTL0", 0x68, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_shcnt_print;
-#else
-#define ahd_shcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SHCNT", 0x68, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_townid_print;
-#else
-#define ahd_townid_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "TOWNID", 0x69, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_pll960ctl1_print;
-#else
-#define ahd_pll960ctl1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "PLL960CTL1", 0x69, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_pll960cnt0_print;
-#else
-#define ahd_pll960cnt0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "PLL960CNT0", 0x6a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_xsig_print;
-#else
-#define ahd_xsig_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "XSIG", 0x6a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seloid_print;
-#else
-#define ahd_seloid_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SELOID", 0x6b, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_pll400ctl0_print;
-#else
-#define ahd_pll400ctl0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "PLL400CTL0", 0x6c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_fairness_print;
-#else
-#define ahd_fairness_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "FAIRNESS", 0x6c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_pll400ctl1_print;
-#else
-#define ahd_pll400ctl1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "PLL400CTL1", 0x6d, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_pll400cnt0_print;
-#else
-#define ahd_pll400cnt0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "PLL400CNT0", 0x6e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_unfairness_print;
-#else
-#define ahd_unfairness_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "UNFAIRNESS", 0x6e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_haddr_print;
-#else
-#define ahd_haddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "HADDR", 0x70, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_plldelay_print;
-#else
-#define ahd_plldelay_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "PLLDELAY", 0x70, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_hodmaadr_print;
-#else
-#define ahd_hodmaadr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "HODMAADR", 0x70, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_hodmacnt_print;
-#else
-#define ahd_hodmacnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "HODMACNT", 0x78, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_hcnt_print;
-#else
-#define ahd_hcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "HCNT", 0x78, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_hodmaen_print;
-#else
-#define ahd_hodmaen_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "HODMAEN", 0x7a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sghaddr_print;
-#else
-#define ahd_sghaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SGHADDR", 0x7c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scbhaddr_print;
-#else
-#define ahd_scbhaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCBHADDR", 0x7c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sghcnt_print;
-#else
-#define ahd_sghcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SGHCNT", 0x84, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scbhcnt_print;
-#else
-#define ahd_scbhcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCBHCNT", 0x84, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dff_thrsh_print;
-#else
-#define ahd_dff_thrsh_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFF_THRSH", 0x88, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_romaddr_print;
-#else
-#define ahd_romaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ROMADDR", 0x8a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_romcntrl_print;
-#else
-#define ahd_romcntrl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ROMCNTRL", 0x8d, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_romdata_print;
-#else
-#define ahd_romdata_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ROMDATA", 0x8e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmcrxmsg0_print;
-#else
-#define ahd_cmcrxmsg0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMCRXMSG0", 0x90, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_roenable_print;
-#else
-#define ahd_roenable_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ROENABLE", 0x90, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ovlyrxmsg0_print;
-#else
-#define ahd_ovlyrxmsg0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "OVLYRXMSG0", 0x90, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dchrxmsg0_print;
-#else
-#define ahd_dchrxmsg0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DCHRXMSG0", 0x90, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ovlyrxmsg1_print;
-#else
-#define ahd_ovlyrxmsg1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "OVLYRXMSG1", 0x91, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_nsenable_print;
-#else
-#define ahd_nsenable_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "NSENABLE", 0x91, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dchrxmsg1_print;
-#else
-#define ahd_dchrxmsg1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DCHRXMSG1", 0x91, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmcrxmsg1_print;
-#else
-#define ahd_cmcrxmsg1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMCRXMSG1", 0x91, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dchrxmsg2_print;
-#else
-#define ahd_dchrxmsg2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DCHRXMSG2", 0x92, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ovlyrxmsg2_print;
-#else
-#define ahd_ovlyrxmsg2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "OVLYRXMSG2", 0x92, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmcrxmsg2_print;
-#else
-#define ahd_cmcrxmsg2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMCRXMSG2", 0x92, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ost_print;
-#else
-#define ahd_ost_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "OST", 0x92, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dchrxmsg3_print;
-#else
-#define ahd_dchrxmsg3_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DCHRXMSG3", 0x93, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmcrxmsg3_print;
-#else
-#define ahd_cmcrxmsg3_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMCRXMSG3", 0x93, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_pcixctl_print;
-#else
-#define ahd_pcixctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "PCIXCTL", 0x93, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ovlyrxmsg3_print;
-#else
-#define ahd_ovlyrxmsg3_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "OVLYRXMSG3", 0x93, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ovlyseqbcnt_print;
-#else
-#define ahd_ovlyseqbcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "OVLYSEQBCNT", 0x94, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmcseqbcnt_print;
-#else
-#define ahd_cmcseqbcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMCSEQBCNT", 0x94, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dchseqbcnt_print;
-#else
-#define ahd_dchseqbcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DCHSEQBCNT", 0x94, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmcspltstat0_print;
-#else
-#define ahd_cmcspltstat0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMCSPLTSTAT0", 0x96, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ovlyspltstat0_print;
-#else
-#define ahd_ovlyspltstat0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "OVLYSPLTSTAT0", 0x96, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dchspltstat0_print;
-#else
-#define ahd_dchspltstat0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DCHSPLTSTAT0", 0x96, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dchspltstat1_print;
-#else
-#define ahd_dchspltstat1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DCHSPLTSTAT1", 0x97, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmcspltstat1_print;
-#else
-#define ahd_cmcspltstat1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMCSPLTSTAT1", 0x97, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ovlyspltstat1_print;
-#else
-#define ahd_ovlyspltstat1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "OVLYSPLTSTAT1", 0x97, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sgrxmsg0_print;
-#else
-#define ahd_sgrxmsg0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SGRXMSG0", 0x98, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_slvspltoutadr0_print;
-#else
-#define ahd_slvspltoutadr0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SLVSPLTOUTADR0", 0x98, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sgrxmsg1_print;
-#else
-#define ahd_sgrxmsg1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SGRXMSG1", 0x99, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_slvspltoutadr1_print;
-#else
-#define ahd_slvspltoutadr1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SLVSPLTOUTADR1", 0x99, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sgrxmsg2_print;
-#else
-#define ahd_sgrxmsg2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SGRXMSG2", 0x9a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_slvspltoutadr2_print;
-#else
-#define ahd_slvspltoutadr2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SLVSPLTOUTADR2", 0x9a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sgrxmsg3_print;
-#else
-#define ahd_sgrxmsg3_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SGRXMSG3", 0x9b, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_slvspltoutadr3_print;
-#else
-#define ahd_slvspltoutadr3_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SLVSPLTOUTADR3", 0x9b, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sgseqbcnt_print;
-#else
-#define ahd_sgseqbcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SGSEQBCNT", 0x9c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_slvspltoutattr0_print;
-#else
-#define ahd_slvspltoutattr0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SLVSPLTOUTATTR0", 0x9c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_slvspltoutattr1_print;
-#else
-#define ahd_slvspltoutattr1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SLVSPLTOUTATTR1", 0x9d, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_slvspltoutattr2_print;
-#else
-#define ahd_slvspltoutattr2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SLVSPLTOUTATTR2", 0x9e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sgspltstat0_print;
-#else
-#define ahd_sgspltstat0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SGSPLTSTAT0", 0x9e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sfunct_print;
-#else
-#define ahd_sfunct_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SFUNCT", 0x9f, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sgspltstat1_print;
-#else
-#define ahd_sgspltstat1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SGSPLTSTAT1", 0x9f, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_df0pcistat_print;
-#else
-#define ahd_df0pcistat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DF0PCISTAT", 0xa0, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_reg0_print;
-#else
-#define ahd_reg0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "REG0", 0xa0, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_df1pcistat_print;
-#else
-#define ahd_df1pcistat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DF1PCISTAT", 0xa1, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sgpcistat_print;
-#else
-#define ahd_sgpcistat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SGPCISTAT", 0xa2, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_reg1_print;
-#else
-#define ahd_reg1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "REG1", 0xa2, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmcpcistat_print;
-#else
-#define ahd_cmcpcistat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMCPCISTAT", 0xa3, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ovlypcistat_print;
-#else
-#define ahd_ovlypcistat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "OVLYPCISTAT", 0xa4, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_reg_isr_print;
-#else
-#define ahd_reg_isr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "REG_ISR", 0xa4, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sg_state_print;
-#else
-#define ahd_sg_state_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SG_STATE", 0xa6, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_msipcistat_print;
-#else
-#define ahd_msipcistat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "MSIPCISTAT", 0xa6, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_targpcistat_print;
-#else
-#define ahd_targpcistat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "TARGPCISTAT", 0xa7, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_data_count_odd_print;
-#else
-#define ahd_data_count_odd_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DATA_COUNT_ODD", 0xa7, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scbptr_print;
-#else
-#define ahd_scbptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCBPTR", 0xa8, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ccscbacnt_print;
-#else
-#define ahd_ccscbacnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CCSCBACNT", 0xab, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scbautoptr_print;
-#else
-#define ahd_scbautoptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCBAUTOPTR", 0xab, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ccsgaddr_print;
-#else
-#define ahd_ccsgaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CCSGADDR", 0xac, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ccscbaddr_print;
-#else
-#define ahd_ccscbaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CCSCBADDR", 0xac, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ccscbadr_bk_print;
-#else
-#define ahd_ccscbadr_bk_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CCSCBADR_BK", 0xac, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmc_rambist_print;
-#else
-#define ahd_cmc_rambist_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMC_RAMBIST", 0xad, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ccsgctl_print;
-#else
-#define ahd_ccsgctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CCSGCTL", 0xad, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ccscbctl_print;
-#else
-#define ahd_ccscbctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CCSCBCTL", 0xad, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ccsgram_print;
-#else
-#define ahd_ccsgram_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CCSGRAM", 0xb0, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_flexadr_print;
-#else
-#define ahd_flexadr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "FLEXADR", 0xb0, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ccscbram_print;
-#else
-#define ahd_ccscbram_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CCSCBRAM", 0xb0, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_flexcnt_print;
-#else
-#define ahd_flexcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "FLEXCNT", 0xb3, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_flexdmastat_print;
-#else
-#define ahd_flexdmastat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "FLEXDMASTAT", 0xb5, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_flexdata_print;
-#else
-#define ahd_flexdata_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "FLEXDATA", 0xb6, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_brddat_print;
-#else
-#define ahd_brddat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "BRDDAT", 0xb8, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_brdctl_print;
-#else
-#define ahd_brdctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "BRDCTL", 0xb9, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seeadr_print;
-#else
-#define ahd_seeadr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEEADR", 0xba, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seedat_print;
-#else
-#define ahd_seedat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEEDAT", 0xbc, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seectl_print;
-#else
-#define ahd_seectl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEECTL", 0xbe, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seestat_print;
-#else
-#define ahd_seestat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEESTAT", 0xbe, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scbcnt_print;
-#else
-#define ahd_scbcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCBCNT", 0xbf, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dfwaddr_print;
-#else
-#define ahd_dfwaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFWADDR", 0xc0, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dspfltrctl_print;
-#else
-#define ahd_dspfltrctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DSPFLTRCTL", 0xc0, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dspdatactl_print;
-#else
-#define ahd_dspdatactl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DSPDATACTL", 0xc1, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dfraddr_print;
-#else
-#define ahd_dfraddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFRADDR", 0xc2, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dspreqctl_print;
-#else
-#define ahd_dspreqctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DSPREQCTL", 0xc2, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dspackctl_print;
-#else
-#define ahd_dspackctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DSPACKCTL", 0xc3, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dfdat_print;
-#else
-#define ahd_dfdat_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFDAT", 0xc4, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dspselect_print;
-#else
-#define ahd_dspselect_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DSPSELECT", 0xc4, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_wrtbiasctl_print;
-#else
-#define ahd_wrtbiasctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "WRTBIASCTL", 0xc5, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_rcvrbiosctl_print;
-#else
-#define ahd_rcvrbiosctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "RCVRBIOSCTL", 0xc6, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_wrtbiascalc_print;
-#else
-#define ahd_wrtbiascalc_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "WRTBIASCALC", 0xc7, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dfptrs_print;
-#else
-#define ahd_dfptrs_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFPTRS", 0xc8, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_rcvrbiascalc_print;
-#else
-#define ahd_rcvrbiascalc_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "RCVRBIASCALC", 0xc8, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dfbkptr_print;
-#else
-#define ahd_dfbkptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFBKPTR", 0xc9, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_skewcalc_print;
-#else
-#define ahd_skewcalc_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SKEWCALC", 0xc9, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dfdbctl_print;
-#else
-#define ahd_dfdbctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFDBCTL", 0xcb, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dfscnt_print;
-#else
-#define ahd_dfscnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFSCNT", 0xcc, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dfbcnt_print;
-#else
-#define ahd_dfbcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DFBCNT", 0xce, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ovlyaddr_print;
-#else
-#define ahd_ovlyaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "OVLYADDR", 0xd4, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seqctl0_print;
-#else
-#define ahd_seqctl0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEQCTL0", 0xd6, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seqctl1_print;
-#else
-#define ahd_seqctl1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEQCTL1", 0xd7, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_flags_print;
-#else
-#define ahd_flags_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "FLAGS", 0xd8, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seqintctl_print;
-#else
-#define ahd_seqintctl_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEQINTCTL", 0xd9, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seqram_print;
-#else
-#define ahd_seqram_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEQRAM", 0xda, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_prgmcnt_print;
-#else
-#define ahd_prgmcnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "PRGMCNT", 0xde, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_accum_print;
-#else
-#define ahd_accum_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ACCUM", 0xe0, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sindex_print;
-#else
-#define ahd_sindex_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SINDEX", 0xe2, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dindex_print;
-#else
-#define ahd_dindex_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DINDEX", 0xe4, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_brkaddr1_print;
-#else
-#define ahd_brkaddr1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "BRKADDR1", 0xe6, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_brkaddr0_print;
-#else
-#define ahd_brkaddr0_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "BRKADDR0", 0xe6, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_allones_print;
-#else
-#define ahd_allones_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ALLONES", 0xe8, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_allzeros_print;
-#else
-#define ahd_allzeros_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ALLZEROS", 0xea, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_none_print;
-#else
-#define ahd_none_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "NONE", 0xea, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sindir_print;
-#else
-#define ahd_sindir_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SINDIR", 0xec, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dindir_print;
-#else
-#define ahd_dindir_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DINDIR", 0xed, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_function1_print;
-#else
-#define ahd_function1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "FUNCTION1", 0xf0, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_stack_print;
-#else
-#define ahd_stack_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "STACK", 0xf2, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_curaddr_print;
-#else
-#define ahd_curaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CURADDR", 0xf4, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_intvec1_addr_print;
-#else
-#define ahd_intvec1_addr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "INTVEC1_ADDR", 0xf4, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_intvec2_addr_print;
-#else
-#define ahd_intvec2_addr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "INTVEC2_ADDR", 0xf6, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lastaddr_print;
-#else
-#define ahd_lastaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LASTADDR", 0xf6, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_longjmp_addr_print;
-#else
-#define ahd_longjmp_addr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LONGJMP_ADDR", 0xf8, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_longjmp_scb_print;
-#else
-#define ahd_longjmp_scb_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LONGJMP_SCB", 0xfa, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_accum_save_print;
-#else
-#define ahd_accum_save_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ACCUM_SAVE", 0xfc, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_waiting_scb_tails_print;
-#else
-#define ahd_waiting_scb_tails_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "WAITING_SCB_TAILS", 0x100, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_ahd_pci_config_base_print;
-#else
-#define ahd_ahd_pci_config_base_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "AHD_PCI_CONFIG_BASE", 0x100, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_sram_base_print;
-#else
-#define ahd_sram_base_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SRAM_BASE", 0x100, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_waiting_tid_head_print;
-#else
-#define ahd_waiting_tid_head_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "WAITING_TID_HEAD", 0x120, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_waiting_tid_tail_print;
-#else
-#define ahd_waiting_tid_tail_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "WAITING_TID_TAIL", 0x122, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_next_queued_scb_addr_print;
-#else
-#define ahd_next_queued_scb_addr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "NEXT_QUEUED_SCB_ADDR", 0x124, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_complete_scb_head_print;
-#else
-#define ahd_complete_scb_head_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "COMPLETE_SCB_HEAD", 0x128, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_complete_scb_dmainprog_head_print;
-#else
-#define ahd_complete_scb_dmainprog_head_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "COMPLETE_SCB_DMAINPROG_HEAD", 0x12a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_complete_dma_scb_head_print;
-#else
-#define ahd_complete_dma_scb_head_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "COMPLETE_DMA_SCB_HEAD", 0x12c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_qfreeze_count_print;
-#else
-#define ahd_qfreeze_count_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "QFREEZE_COUNT", 0x12e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_saved_mode_print;
-#else
-#define ahd_saved_mode_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SAVED_MODE", 0x130, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_msg_out_print;
-#else
-#define ahd_msg_out_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "MSG_OUT", 0x131, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_dmaparams_print;
-#else
-#define ahd_dmaparams_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "DMAPARAMS", 0x132, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seq_flags_print;
-#else
-#define ahd_seq_flags_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEQ_FLAGS", 0x133, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_saved_scsiid_print;
-#else
-#define ahd_saved_scsiid_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SAVED_SCSIID", 0x134, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_saved_lun_print;
-#else
-#define ahd_saved_lun_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SAVED_LUN", 0x135, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_lastphase_print;
-#else
-#define ahd_lastphase_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LASTPHASE", 0x136, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_qoutfifo_entry_valid_tag_print;
-#else
-#define ahd_qoutfifo_entry_valid_tag_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "QOUTFIFO_ENTRY_VALID_TAG", 0x137, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_shared_data_addr_print;
-#else
-#define ahd_shared_data_addr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SHARED_DATA_ADDR", 0x138, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_qoutfifo_next_addr_print;
-#else
-#define ahd_qoutfifo_next_addr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "QOUTFIFO_NEXT_ADDR", 0x13c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_kernel_tqinpos_print;
-#else
-#define ahd_kernel_tqinpos_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "KERNEL_TQINPOS", 0x140, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_tqinpos_print;
-#else
-#define ahd_tqinpos_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "TQINPOS", 0x141, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_arg_1_print;
-#else
-#define ahd_arg_1_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ARG_1", 0x142, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_arg_2_print;
-#else
-#define ahd_arg_2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ARG_2", 0x143, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_last_msg_print;
-#else
-#define ahd_last_msg_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LAST_MSG", 0x144, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scsiseq_template_print;
-#else
-#define ahd_scsiseq_template_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCSISEQ_TEMPLATE", 0x145, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_initiator_tag_print;
-#else
-#define ahd_initiator_tag_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "INITIATOR_TAG", 0x146, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_seq_flags2_print;
-#else
-#define ahd_seq_flags2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SEQ_FLAGS2", 0x147, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_allocfifo_scbptr_print;
-#else
-#define ahd_allocfifo_scbptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "ALLOCFIFO_SCBPTR", 0x148, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_int_coalessing_timer_print;
-#else
-#define ahd_int_coalessing_timer_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "INT_COALESSING_TIMER", 0x14a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_int_coalessing_maxcmds_print;
-#else
-#define ahd_int_coalessing_maxcmds_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "INT_COALESSING_MAXCMDS", 0x14c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_int_coalessing_mincmds_print;
-#else
-#define ahd_int_coalessing_mincmds_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "INT_COALESSING_MINCMDS", 0x14d, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmds_pending_print;
-#else
-#define ahd_cmds_pending_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMDS_PENDING", 0x14e, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_int_coalessing_cmdcount_print;
-#else
-#define ahd_int_coalessing_cmdcount_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "INT_COALESSING_CMDCOUNT", 0x150, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_local_hs_mailbox_print;
-#else
-#define ahd_local_hs_mailbox_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "LOCAL_HS_MAILBOX", 0x151, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_cmdsize_table_print;
-#else
-#define ahd_cmdsize_table_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "CMDSIZE_TABLE", 0x152, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_base_print;
-#else
-#define ahd_scb_base_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_BASE", 0x180, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_residual_datacnt_print;
-#else
-#define ahd_scb_residual_datacnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_RESIDUAL_DATACNT", 0x180, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_residual_sgptr_print;
-#else
-#define ahd_scb_residual_sgptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_RESIDUAL_SGPTR", 0x184, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_scsi_status_print;
-#else
-#define ahd_scb_scsi_status_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_SCSI_STATUS", 0x188, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_target_phases_print;
-#else
-#define ahd_scb_target_phases_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_TARGET_PHASES", 0x189, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_target_data_dir_print;
-#else
-#define ahd_scb_target_data_dir_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_TARGET_DATA_DIR", 0x18a, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_target_itag_print;
-#else
-#define ahd_scb_target_itag_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_TARGET_ITAG", 0x18b, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_sense_busaddr_print;
-#else
-#define ahd_scb_sense_busaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_SENSE_BUSADDR", 0x18c, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_tag_print;
-#else
-#define ahd_scb_tag_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_TAG", 0x190, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_cdb_len_print;
-#else
-#define ahd_scb_cdb_len_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_CDB_LEN", 0x192, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_task_management_print;
-#else
-#define ahd_scb_task_management_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_TASK_MANAGEMENT", 0x193, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_next_print;
-#else
-#define ahd_scb_next_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_NEXT", 0x194, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_next2_print;
-#else
-#define ahd_scb_next2_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_NEXT2", 0x196, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_dataptr_print;
-#else
-#define ahd_scb_dataptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_DATAPTR", 0x198, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_datacnt_print;
-#else
-#define ahd_scb_datacnt_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_DATACNT", 0x1a0, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_sgptr_print;
-#else
-#define ahd_scb_sgptr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_SGPTR", 0x1a4, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_control_print;
-#else
-#define ahd_scb_control_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_CONTROL", 0x1a8, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_scsiid_print;
-#else
-#define ahd_scb_scsiid_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_SCSIID", 0x1a9, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_lun_print;
-#else
-#define ahd_scb_lun_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_LUN", 0x1aa, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_task_attribute_print;
-#else
-#define ahd_scb_task_attribute_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_TASK_ATTRIBUTE", 0x1ab, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_busaddr_print;
-#else
-#define ahd_scb_busaddr_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_BUSADDR", 0x1ac, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_spare_print;
-#else
-#define ahd_scb_spare_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_SPARE", 0x1b0, regvalue, cur_col, wrap)
-#endif
-
-#if AIC_DEBUG_REGISTERS
-ahd_reg_print_t ahd_scb_disconnected_lists_print;
-#else
-#define ahd_scb_disconnected_lists_print(regvalue, cur_col, wrap) \
-    ahd_print_register(NULL, 0, "SCB_DISCONNECTED_LISTS", 0x1b8, regvalue, cur_col, wrap)
-#endif
-
-
-#define	MODE_PTR        		0x00
-#define		DST_MODE        	0x70
-#define		SRC_MODE        	0x07
-
-#define	INTSTAT         		0x01
-#define		INT_PEND        	0xff
-#define		HWERRINT        	0x80
-#define		BRKADRINT       	0x40
-#define		SWTMINT         	0x20
-#define		PCIINT          	0x10
-#define		SCSIINT         	0x08
-#define		SEQINT          	0x04
-#define		CMDCMPLT        	0x02
-#define		SPLTINT         	0x01
-
-#define	SEQINTCODE      		0x02
-#define		SAW_HWERR       	0x19
-#define		TRACEPOINT3     	0x18
-#define		TRACEPOINT2     	0x17
-#define		TRACEPOINT1     	0x16
-#define		TRACEPOINT0     	0x15
-#define		TASKMGMT_CMD_CMPLT_OKAY	0x14
-#define		TASKMGMT_FUNC_COMPLETE	0x13
-#define		ENTERING_NONPACK	0x12
-#define		CFG4OVERRUN     	0x11
-#define		STATUS_OVERRUN  	0x10
-#define		CFG4ISTAT_INTR  	0x0f
-#define		INVALID_SEQINT  	0x0e
-#define		ILLEGAL_PHASE   	0x0d
-#define		DUMP_CARD_STATE 	0x0c
-#define		MISSED_BUSFREE  	0x0b
-#define		MKMSG_FAILED    	0x0a
-#define		DATA_OVERRUN    	0x09
-#define		BAD_STATUS      	0x08
-#define		HOST_MSG_LOOP   	0x07
-#define		PDATA_REINIT    	0x06
-#define		IGN_WIDE_RES    	0x05
-#define		NO_MATCH        	0x04
-#define		PROTO_VIOLATION 	0x03
-#define		SEND_REJECT     	0x02
-#define		BAD_PHASE       	0x01
-#define		NO_SEQINT       	0x00
-
-#define	CLRINT          		0x03
-#define		CLRHWERRINT     	0x80
-#define		CLRBRKADRINT    	0x40
-#define		CLRSWTMINT      	0x20
-#define		CLRPCIINT       	0x10
-#define		CLRSCSIINT      	0x08
-#define		CLRSEQINT       	0x04
-#define		CLRCMDINT       	0x02
-#define		CLRSPLTINT      	0x01
-
-#define	ERROR           		0x04
-#define		CIOPARERR       	0x80
-#define		CIOACCESFAIL    	0x40
-#define		MPARERR         	0x20
-#define		DPARERR         	0x10
-#define		SQPARERR        	0x08
-#define		ILLOPCODE       	0x04
-#define		DSCTMOUT        	0x02
-
-#define	CLRERR          		0x04
-#define		CLRCIOPARERR    	0x80
-#define		CLRCIOACCESFAIL 	0x40
-#define		CLRMPARERR      	0x20
-#define		CLRDPARERR      	0x10
-#define		CLRSQPARERR     	0x08
-#define		CLRILLOPCODE    	0x04
-#define		CLRDSCTMOUT     	0x02
-
-#define	HCNTRL          		0x05
-#define		SEQ_RESET       	0x80
-#define		POWRDN          	0x40
-#define		SWINT           	0x10
-#define		SWTIMER_START_B 	0x08
-#define		PAUSE           	0x04
-#define		INTEN           	0x02
-#define		CHIPRST         	0x01
-#define		CHIPRSTACK      	0x01
-
-#define	HNSCB_QOFF      		0x06
-
-#define	HESCB_QOFF      		0x08
-
-#define	HS_MAILBOX      		0x0b
-#define		HOST_TQINPOS    	0x80
-#define		ENINT_COALESS   	0x40
-
-#define	CLRSEQINTSTAT   		0x0c
-#define		CLRSEQ_SWTMRTO  	0x10
-#define		CLRSEQ_SEQINT   	0x08
-#define		CLRSEQ_SCSIINT  	0x04
-#define		CLRSEQ_PCIINT   	0x02
-#define		CLRSEQ_SPLTINT  	0x01
-
-#define	SEQINTSTAT      		0x0c
-#define		SEQ_SWTMRTO     	0x10
-#define		SEQ_SEQINT      	0x08
-#define		SEQ_SCSIINT     	0x04
-#define		SEQ_PCIINT      	0x02
-#define		SEQ_SPLTINT     	0x01
-
-#define	SWTIMER         		0x0e
-
-#define	SNSCB_QOFF      		0x10
-
-#define	SESCB_QOFF      		0x12
-
-#define	SDSCB_QOFF      		0x14
-
-#define	QOFF_CTLSTA     		0x16
-#define		EMPTY_SCB_AVAIL 	0x80
-#define		NEW_SCB_AVAIL   	0x40
-#define		SDSCB_ROLLOVR   	0x20
-#define		HS_MAILBOX_ACT  	0x10
-#define		SCB_QSIZE       	0x0f
-#define		SCB_QSIZE_16384 	0x0c
-#define		SCB_QSIZE_8192  	0x0b
-#define		SCB_QSIZE_4096  	0x0a
-#define		SCB_QSIZE_2048  	0x09
-#define		SCB_QSIZE_1024  	0x08
-#define		SCB_QSIZE_512   	0x07
-#define		SCB_QSIZE_256   	0x06
-#define		SCB_QSIZE_128   	0x05
-#define		SCB_QSIZE_64    	0x04
-#define		SCB_QSIZE_32    	0x03
-#define		SCB_QSIZE_16    	0x02
-#define		SCB_QSIZE_8     	0x01
-#define		SCB_QSIZE_4     	0x00
-
-#define	INTCTL          		0x18
-#define		SWTMINTMASK     	0x80
-#define		SWTMINTEN       	0x40
-#define		SWTIMER_START   	0x20
-#define		AUTOCLRCMDINT   	0x10
-#define		PCIINTEN        	0x08
-#define		SCSIINTEN       	0x04
-#define		SEQINTEN        	0x02
-#define		SPLTINTEN       	0x01
-
-#define	DFCNTRL         		0x19
-#define		SCSIENWRDIS     	0x40
-#define		SCSIENACK       	0x20
-#define		DIRECTIONACK    	0x04
-#define		FIFOFLUSHACK    	0x02
-#define		DIRECTIONEN     	0x01
-
-#define	DSCOMMAND0      		0x19
-#define		CACHETHEN       	0x80
-#define		DPARCKEN        	0x40
-#define		MPARCKEN        	0x20
-#define		EXTREQLCK       	0x10
-#define		DISABLE_TWATE   	0x02
-#define		CIOPARCKEN      	0x01
-
-#define	DFSTATUS        		0x1a
-#define		PRELOAD_AVAIL   	0x80
-#define		PKT_PRELOAD_AVAIL	0x40
-#define		MREQPEND        	0x10
-#define		HDONE           	0x08
-#define		DFTHRESH        	0x04
-#define		FIFOFULL        	0x02
-#define		FIFOEMP         	0x01
-
-#define	SG_CACHE_SHADOW 		0x1b
-#define		ODD_SEG         	0x04
-#define		LAST_SEG        	0x02
-#define		LAST_SEG_DONE   	0x01
-
-#define	ARBCTL          		0x1b
-#define		RESET_HARB      	0x80
-#define		RETRY_SWEN      	0x08
-#define		USE_TIME        	0x07
-
-#define	SG_CACHE_PRE    		0x1b
-
-#define	LQIN            		0x20
-
-#define	TYPEPTR         		0x20
-
-#define	TAGPTR          		0x21
-
-#define	LUNPTR          		0x22
-
-#define	DATALENPTR      		0x23
-
-#define	STATLENPTR      		0x24
-
-#define	CMDLENPTR       		0x25
-
-#define	ATTRPTR         		0x26
-
-#define	FLAGPTR         		0x27
-
-#define	CMDPTR          		0x28
-
-#define	QNEXTPTR        		0x29
-
-#define	IDPTR           		0x2a
-
-#define	ABRTBYTEPTR     		0x2b
-
-#define	ABRTBITPTR      		0x2c
-
-#define	MAXCMDBYTES     		0x2d
-
-#define	MAXCMD2RCV      		0x2e
-
-#define	SHORTTHRESH     		0x2f
-
-#define	LUNLEN          		0x30
-
-#define	CDBLIMIT        		0x31
-
-#define	MAXCMD          		0x32
-
-#define	MAXCMDCNT       		0x33
-
-#define	LQRSVD01        		0x34
-
-#define	LQRSVD16        		0x35
-
-#define	LQRSVD17        		0x36
-
-#define	CMDRSVD0        		0x37
-
-#define	LQCTL0          		0x38
-#define		LQITARGCLT      	0xc0
-#define		LQIINITGCLT     	0x30
-#define		LQ0TARGCLT      	0x0c
-#define		LQ0INITGCLT     	0x03
-
-#define	LQCTL1          		0x38
-#define		PCI2PCI         	0x04
-#define		SINGLECMD       	0x02
-#define		ABORTPENDING    	0x01
-
-#define	SCSBIST0        		0x39
-#define		GSBISTERR       	0x40
-#define		GSBISTDONE      	0x20
-#define		GSBISTRUN       	0x10
-#define		OSBISTERR       	0x04
-#define		OSBISTDONE      	0x02
-#define		OSBISTRUN       	0x01
-
-#define	LQCTL2          		0x39
-#define		LQIRETRY        	0x80
-#define		LQICONTINUE     	0x40
-#define		LQITOIDLE       	0x20
-#define		LQIPAUSE        	0x10
-#define		LQORETRY        	0x08
-#define		LQOCONTINUE     	0x04
-#define		LQOTOIDLE       	0x02
-#define		LQOPAUSE        	0x01
-
-#define	SCSBIST1        		0x3a
-#define		NTBISTERR       	0x04
-#define		NTBISTDONE      	0x02
-#define		NTBISTRUN       	0x01
-
-#define	SCSISEQ0        		0x3a
-#define		TEMODEO         	0x80
-#define		ENSELO          	0x40
-#define		ENARBO          	0x20
-#define		FORCEBUSFREE    	0x10
-#define		SCSIRSTO        	0x01
-
-#define	SCSISEQ1        		0x3b
-
-#define	SXFRCTL0        		0x3c
-#define		DFON            	0x80
-#define		DFPEXP          	0x40
-#define		BIOSCANCELEN    	0x10
-#define		SPIOEN          	0x08
-
-#define	BUSINITID       		0x3c
-
-#define	DLCOUNT         		0x3c
-
-#define	SXFRCTL1        		0x3d
-#define		BITBUCKET       	0x80
-#define		ENSACHK         	0x40
-#define		ENSPCHK         	0x20
-#define		STIMESEL        	0x18
-#define		ENSTIMER        	0x04
-#define		ACTNEGEN        	0x02
-#define		STPWEN          	0x01
-
-#define	BUSTARGID       		0x3e
-
-#define	SXFRCTL2        		0x3e
-#define		AUTORSTDIS      	0x10
-#define		CMDDMAEN        	0x08
-#define		ASU             	0x07
-
-#define	DFFSTAT         		0x3f
-#define		CURRFIFO        	0x03
-#define		FIFO1FREE       	0x20
-#define		FIFO0FREE       	0x10
-#define		CURRFIFO_NONE   	0x03
-#define		CURRFIFO_1      	0x01
-#define		CURRFIFO_0      	0x00
-
-#define	SCSISIGO        		0x40
-#define		CDO             	0x80
-#define		IOO             	0x40
-#define		MSGO            	0x20
-#define		ATNO            	0x10
-#define		SELO            	0x08
-#define		BSYO            	0x04
-#define		REQO            	0x02
-#define		ACKO            	0x01
-
-#define	MULTARGID       		0x40
-
-#define	SCSISIGI        		0x41
-#define		ATNI            	0x10
-#define		SELI            	0x08
-#define		BSYI            	0x04
-#define		REQI            	0x02
-#define		ACKI            	0x01
-
-#define	SCSIPHASE       		0x42
-#define		STATUS_PHASE    	0x20
-#define		COMMAND_PHASE   	0x10
-#define		MSG_IN_PHASE    	0x08
-#define		MSG_OUT_PHASE   	0x04
-#define		DATA_PHASE_MASK 	0x03
-#define		DATA_IN_PHASE   	0x02
-#define		DATA_OUT_PHASE  	0x01
-
-#define	SCSIDAT0_IMG    		0x43
-
-#define	SCSIDAT         		0x44
-
-#define	SCSIBUS         		0x46
-
-#define	TARGIDIN        		0x48
-#define		CLKOUT          	0x80
-#define		TARGID          	0x0f
-
-#define	SELID           		0x49
-#define		SELID_MASK      	0xf0
-#define		ONEBIT          	0x08
-
-#define	SBLKCTL         		0x4a
-#define		DIAGLEDEN       	0x80
-#define		DIAGLEDON       	0x40
-#define		ENAB40          	0x08
-#define		ENAB20          	0x04
-#define		SELWIDE         	0x02
-
-#define	OPTIONMODE      		0x4a
-#define		OPTIONMODE_DEFAULTS	0x02
-#define		BIOSCANCTL      	0x80
-#define		AUTOACKEN       	0x40
-#define		BIASCANCTL      	0x20
-#define		BUSFREEREV      	0x10
-#define		ENDGFORMCHK     	0x04
-#define		AUTO_MSGOUT_DE  	0x02
-
-#define	SSTAT0          		0x4b
-#define		TARGET          	0x80
-#define		SELDO           	0x40
-#define		SELDI           	0x20
-#define		SELINGO         	0x10
-#define		IOERR           	0x08
-#define		OVERRUN         	0x04
-#define		SPIORDY         	0x02
-#define		ARBDO           	0x01
-
-#define	CLRSINT0        		0x4b
-#define		CLRSELDO        	0x40
-#define		CLRSELDI        	0x20
-#define		CLRSELINGO      	0x10
-#define		CLRIOERR        	0x08
-#define		CLROVERRUN      	0x04
-#define		CLRSPIORDY      	0x02
-#define		CLRARBDO        	0x01
-
-#define	SIMODE0         		0x4b
-#define		ENSELDO         	0x40
-#define		ENSELDI         	0x20
-#define		ENSELINGO       	0x10
-#define		ENIOERR         	0x08
-#define		ENOVERRUN       	0x04
-#define		ENSPIORDY       	0x02
-#define		ENARBDO         	0x01
-
-#define	CLRSINT1        		0x4c
-#define		CLRSELTIMEO     	0x80
-#define		CLRATNO         	0x40
-#define		CLRSCSIRSTI     	0x20
-#define		CLRBUSFREE      	0x08
-#define		CLRSCSIPERR     	0x04
-#define		CLRSTRB2FAST    	0x02
-#define		CLRREQINIT      	0x01
-
-#define	SSTAT1          		0x4c
-#define		SELTO           	0x80
-#define		ATNTARG         	0x40
-#define		SCSIRSTI        	0x20
-#define		PHASEMIS        	0x10
-#define		BUSFREE         	0x08
-#define		SCSIPERR        	0x04
-#define		STRB2FAST       	0x02
-#define		REQINIT         	0x01
-
-#define	SSTAT2          		0x4d
-#define		BUSFREETIME     	0xc0
-#define		NONPACKREQ      	0x20
-#define		EXP_ACTIVE      	0x10
-#define		BSYX            	0x08
-#define		WIDE_RES        	0x04
-#define		SDONE           	0x02
-#define		DMADONE         	0x01
-#define		BUSFREE_DFF1    	0xc0
-#define		BUSFREE_DFF0    	0x80
-#define		BUSFREE_LQO     	0x40
-
-#define	CLRSINT2        		0x4d
-#define		CLRNONPACKREQ   	0x20
-#define		CLRWIDE_RES     	0x04
-#define		CLRSDONE        	0x02
-#define		CLRDMADONE      	0x01
-
-#define	SIMODE2         		0x4d
-#define		ENWIDE_RES      	0x04
-#define		ENSDONE         	0x02
-#define		ENDMADONE       	0x01
-
-#define	PERRDIAG        		0x4e
-#define		HIZERO          	0x80
-#define		HIPERR          	0x40
-#define		PREVPHASE       	0x20
-#define		PARITYERR       	0x10
-#define		AIPERR          	0x08
-#define		CRCERR          	0x04
-#define		DGFORMERR       	0x02
-#define		DTERR           	0x01
-
-#define	LQISTATE        		0x4e
-
-#define	SOFFCNT         		0x4f
-
-#define	LQOSTATE        		0x4f
-
-#define	LQISTAT0        		0x50
-#define		LQIATNQAS       	0x20
-#define		LQICRCT1        	0x10
-#define		LQICRCT2        	0x08
-#define		LQIBADLQT       	0x04
-#define		LQIATNLQ        	0x02
-#define		LQIATNCMD       	0x01
-
-#define	CLRLQIINT0      		0x50
-#define		CLRLQIATNQAS    	0x20
-#define		CLRLQICRCT1     	0x10
-#define		CLRLQICRCT2     	0x08
-#define		CLRLQIBADLQT    	0x04
-#define		CLRLQIATNLQ     	0x02
-#define		CLRLQIATNCMD    	0x01
-
-#define	LQIMODE0        		0x50
-#define		ENLQIATNQASK    	0x20
-#define		ENLQICRCT1      	0x10
-#define		ENLQICRCT2      	0x08
-#define		ENLQIBADLQT     	0x04
-#define		ENLQIATNLQ      	0x02
-#define		ENLQIATNCMD     	0x01
-
-#define	LQIMODE1        		0x51
-#define		ENLQIPHASE_LQ   	0x80
-#define		ENLQIPHASE_NLQ  	0x40
-#define		ENLIQABORT      	0x20
-#define		ENLQICRCI_LQ    	0x10
-#define		ENLQICRCI_NLQ   	0x08
-#define		ENLQIBADLQI     	0x04
-#define		ENLQIOVERI_LQ   	0x02
-#define		ENLQIOVERI_NLQ  	0x01
-
-#define	LQISTAT1        		0x51
-#define		LQIPHASE_LQ     	0x80
-#define		LQIPHASE_NLQ    	0x40
-#define		LQIABORT        	0x20
-#define		LQICRCI_LQ      	0x10
-#define		LQICRCI_NLQ     	0x08
-#define		LQIBADLQI       	0x04
-#define		LQIOVERI_LQ     	0x02
-#define		LQIOVERI_NLQ    	0x01
-
-#define	CLRLQIINT1      		0x51
-#define		CLRLQIPHASE_LQ  	0x80
-#define		CLRLQIPHASE_NLQ 	0x40
-#define		CLRLIQABORT     	0x20
-#define		CLRLQICRCI_LQ   	0x10
-#define		CLRLQICRCI_NLQ  	0x08
-#define		CLRLQIBADLQI    	0x04
-#define		CLRLQIOVERI_LQ  	0x02
-#define		CLRLQIOVERI_NLQ 	0x01
-
-#define	LQISTAT2        		0x52
-#define		PACKETIZED      	0x80
-#define		LQIPHASE_OUTPKT 	0x40
-#define		LQIWORKONLQ     	0x20
-#define		LQIWAITFIFO     	0x10
-#define		LQISTOPPKT      	0x08
-#define		LQISTOPLQ       	0x04
-#define		LQISTOPCMD      	0x02
-#define		LQIGSAVAIL      	0x01
-
-#define	SSTAT3          		0x53
-#define		NTRAMPERR       	0x02
-#define		OSRAMPERR       	0x01
-
-#define	SIMODE3         		0x53
-#define		ENNTRAMPERR     	0x02
-#define		ENOSRAMPERR     	0x01
-
-#define	CLRSINT3        		0x53
-#define		CLRNTRAMPERR    	0x02
-#define		CLROSRAMPERR    	0x01
-
-#define	LQOMODE0        		0x54
-#define		ENLQOTARGSCBPERR	0x10
-#define		ENLQOSTOPT2     	0x08
-#define		ENLQOATNLQ      	0x04
-#define		ENLQOATNPKT     	0x02
-#define		ENLQOTCRC       	0x01
-
-#define	LQOSTAT0        		0x54
-#define		LQOTARGSCBPERR  	0x10
-#define		LQOSTOPT2       	0x08
-#define		LQOATNLQ        	0x04
-#define		LQOATNPKT       	0x02
-#define		LQOTCRC         	0x01
-
-#define	CLRLQOINT0      		0x54
-#define		CLRLQOTARGSCBPERR	0x10
-#define		CLRLQOSTOPT2    	0x08
-#define		CLRLQOATNLQ     	0x04
-#define		CLRLQOATNPKT    	0x02
-#define		CLRLQOTCRC      	0x01
-
-#define	LQOSTAT1        		0x55
-#define		LQOINITSCBPERR  	0x10
-#define		LQOSTOPI2       	0x08
-#define		LQOBADQAS       	0x04
-#define		LQOBUSFREE      	0x02
-#define		LQOPHACHGINPKT  	0x01
-
-#define	CLRLQOINT1      		0x55
-#define		CLRLQOINITSCBPERR	0x10
-#define		CLRLQOSTOPI2    	0x08
-#define		CLRLQOBADQAS    	0x04
-#define		CLRLQOBUSFREE   	0x02
-#define		CLRLQOPHACHGINPKT	0x01
-
-#define	LQOMODE1        		0x55
-#define		ENLQOINITSCBPERR	0x10
-#define		ENLQOSTOPI2     	0x08
-#define		ENLQOBADQAS     	0x04
-#define		ENLQOBUSFREE    	0x02
-#define		ENLQOPHACHGINPKT	0x01
-
-#define	LQOSTAT2        		0x56
-#define		LQOPKT          	0xe0
-#define		LQOWAITFIFO     	0x10
-#define		LQOPHACHGOUTPKT 	0x02
-#define		LQOSTOP0        	0x01
-
-#define	OS_SPACE_CNT    		0x56
-
-#define	SIMODE1         		0x57
-#define		ENSELTIMO       	0x80
-#define		ENATNTARG       	0x40
-#define		ENSCSIRST       	0x20
-#define		ENPHASEMIS      	0x10
-#define		ENBUSFREE       	0x08
-#define		ENSCSIPERR      	0x04
-#define		ENSTRB2FAST     	0x02
-#define		ENREQINIT       	0x01
-
-#define	GSFIFO          		0x58
-
-#define	DFFSXFRCTL      		0x5a
-#define		DFFBITBUCKET    	0x08
-#define		CLRSHCNT        	0x04
-#define		CLRCHN          	0x02
-#define		RSTCHN          	0x01
-
-#define	LQOSCSCTL       		0x5a
-#define		LQOH2A_VERSION  	0x80
-#define		LQONOCHKOVER    	0x01
-
-#define	NEXTSCB         		0x5a
-
-#define	CLRSEQINTSRC    		0x5b
-#define		CLRCTXTDONE     	0x40
-#define		CLRSAVEPTRS     	0x20
-#define		CLRCFG4DATA     	0x10
-#define		CLRCFG4ISTAT    	0x08
-#define		CLRCFG4TSTAT    	0x04
-#define		CLRCFG4ICMD     	0x02
-#define		CLRCFG4TCMD     	0x01
-
-#define	SEQINTSRC       		0x5b
-#define		CTXTDONE        	0x40
-#define		SAVEPTRS        	0x20
-#define		CFG4DATA        	0x10
-#define		CFG4ISTAT       	0x08
-#define		CFG4TSTAT       	0x04
-#define		CFG4ICMD        	0x02
-#define		CFG4TCMD        	0x01
-
-#define	CURRSCB         		0x5c
-
-#define	SEQIMODE        		0x5c
-#define		ENCTXTDONE      	0x40
-#define		ENSAVEPTRS      	0x20
-#define		ENCFG4DATA      	0x10
-#define		ENCFG4ISTAT     	0x08
-#define		ENCFG4TSTAT     	0x04
-#define		ENCFG4ICMD      	0x02
-#define		ENCFG4TCMD      	0x01
-
-#define	MDFFSTAT        		0x5d
-#define		SHCNTNEGATIVE   	0x40
-#define		SHCNTMINUS1     	0x20
-#define		LASTSDONE       	0x10
-#define		SHVALID         	0x08
-#define		DLZERO          	0x04
-#define		DATAINFIFO      	0x02
-#define		FIFOFREE        	0x01
-
-#define	CRCCONTROL      		0x5d
-#define		CRCVALCHKEN     	0x40
-
-#define	DFFTAG          		0x5e
-
-#define	LASTSCB         		0x5e
-
-#define	SCSITEST        		0x5e
-#define		CNTRTEST        	0x08
-#define		SEL_TXPLL_DEBUG 	0x04
-
-#define	IOPDNCTL        		0x5f
-#define		DISABLE_OE      	0x80
-#define		PDN_IDIST       	0x04
-#define		PDN_DIFFSENSE   	0x01
-
-#define	SHADDR          		0x60
-
-#define	NEGOADDR        		0x60
-
-#define	DGRPCRCI        		0x60
-
-#define	NEGPERIOD       		0x61
-
-#define	PACKCRCI        		0x62
-
-#define	NEGOFFSET       		0x62
-
-#define	NEGPPROPTS      		0x63
-#define		PPROPT_PACE     	0x08
-#define		PPROPT_QAS      	0x04
-#define		PPROPT_DT       	0x02
-#define		PPROPT_IUT      	0x01
-
-#define	NEGCONOPTS      		0x64
-#define		ENSNAPSHOT      	0x40
-#define		RTI_WRTDIS      	0x20
-#define		RTI_OVRDTRN     	0x10
-#define		ENSLOWCRC       	0x08
-#define		ENAUTOATNI      	0x04
-#define		ENAUTOATNO      	0x02
-#define		WIDEXFER        	0x01
-
-#define	ANNEXCOL        		0x65
-
-#define	SCSCHKN         		0x66
-#define		STSELSKIDDIS    	0x40
-#define		CURRFIFODEF     	0x20
-#define		WIDERESEN       	0x10
-#define		SDONEMSKDIS     	0x08
-#define		DFFACTCLR       	0x04
-#define		SHVALIDSTDIS    	0x02
-#define		LSTSGCLRDIS     	0x01
-
-#define	ANNEXDAT        		0x66
-
-#define	IOWNID          		0x67
-
-#define	PLL960CTL0      		0x68
-
-#define	SHCNT           		0x68
-
-#define	TOWNID          		0x69
-
-#define	PLL960CTL1      		0x69
-
-#define	PLL960CNT0      		0x6a
-
-#define	XSIG            		0x6a
-
-#define	SELOID          		0x6b
-
-#define	PLL400CTL0      		0x6c
-#define		PLL_VCOSEL      	0x80
-#define		PLL_PWDN        	0x40
-#define		PLL_NS          	0x30
-#define		PLL_ENLUD       	0x08
-#define		PLL_ENLPF       	0x04
-#define		PLL_DLPF        	0x02
-#define		PLL_ENFBM       	0x01
-
-#define	FAIRNESS        		0x6c
-
-#define	PLL400CTL1      		0x6d
-#define		PLL_CNTEN       	0x80
-#define		PLL_CNTCLR      	0x40
-#define		PLL_RST         	0x01
-
-#define	PLL400CNT0      		0x6e
-
-#define	UNFAIRNESS      		0x6e
-
-#define	HADDR           		0x70
-
-#define	PLLDELAY        		0x70
-#define		SPLIT_DROP_REQ  	0x80
-
-#define	HODMAADR        		0x70
-
-#define	HODMACNT        		0x78
-
-#define	HCNT            		0x78
-
-#define	HODMAEN         		0x7a
-
-#define	SGHADDR         		0x7c
-
-#define	SCBHADDR        		0x7c
-
-#define	SGHCNT          		0x84
-
-#define	SCBHCNT         		0x84
-
-#define	DFF_THRSH       		0x88
-#define		WR_DFTHRSH      	0x70
-#define		RD_DFTHRSH      	0x07
-#define		WR_DFTHRSH_MAX  	0x70
-#define		WR_DFTHRSH_90   	0x60
-#define		WR_DFTHRSH_85   	0x50
-#define		WR_DFTHRSH_75   	0x40
-#define		WR_DFTHRSH_63   	0x30
-#define		WR_DFTHRSH_50   	0x20
-#define		WR_DFTHRSH_25   	0x10
-#define		RD_DFTHRSH_MAX  	0x07
-#define		RD_DFTHRSH_90   	0x06
-#define		RD_DFTHRSH_85   	0x05
-#define		RD_DFTHRSH_75   	0x04
-#define		RD_DFTHRSH_63   	0x03
-#define		RD_DFTHRSH_50   	0x02
-#define		RD_DFTHRSH_25   	0x01
-#define		WR_DFTHRSH_MIN  	0x00
-#define		RD_DFTHRSH_MIN  	0x00
-
-#define	ROMADDR         		0x8a
-
-#define	ROMCNTRL        		0x8d
-#define		ROMOP           	0xe0
-#define		ROMSPD          	0x18
-#define		REPEAT          	0x02
-#define		RDY             	0x01
-
-#define	ROMDATA         		0x8e
-
-#define	CMCRXMSG0       		0x90
-
-#define	ROENABLE        		0x90
-#define		MSIROEN         	0x20
-#define		OVLYROEN        	0x10
-#define		CMCROEN         	0x08
-#define		SGROEN          	0x04
-#define		DCH1ROEN        	0x02
-#define		DCH0ROEN        	0x01
-
-#define	OVLYRXMSG0      		0x90
-
-#define	DCHRXMSG0       		0x90
-
-#define	OVLYRXMSG1      		0x91
-
-#define	NSENABLE        		0x91
-#define		MSINSEN         	0x20
-#define		OVLYNSEN        	0x10
-#define		CMCNSEN         	0x08
-#define		SGNSEN          	0x04
-#define		DCH1NSEN        	0x02
-#define		DCH0NSEN        	0x01
-
-#define	DCHRXMSG1       		0x91
-
-#define	CMCRXMSG1       		0x91
-
-#define	DCHRXMSG2       		0x92
-
-#define	OVLYRXMSG2      		0x92
-
-#define	CMCRXMSG2       		0x92
-
-#define	OST             		0x92
-
-#define	DCHRXMSG3       		0x93
-
-#define	CMCRXMSG3       		0x93
-
-#define	PCIXCTL         		0x93
-#define		SERRPULSE       	0x80
-#define		UNEXPSCIEN      	0x20
-#define		SPLTSMADIS      	0x10
-#define		SPLTSTADIS      	0x08
-#define		SRSPDPEEN       	0x04
-#define		TSCSERREN       	0x02
-#define		CMPABCDIS       	0x01
-
-#define	OVLYRXMSG3      		0x93
-
-#define	OVLYSEQBCNT     		0x94
-
-#define	CMCSEQBCNT      		0x94
-
-#define	DCHSEQBCNT      		0x94
-
-#define	CMCSPLTSTAT0    		0x96
-
-#define	OVLYSPLTSTAT0   		0x96
-
-#define	DCHSPLTSTAT0    		0x96
-
-#define	DCHSPLTSTAT1    		0x97
-
-#define	CMCSPLTSTAT1    		0x97
-
-#define	OVLYSPLTSTAT1   		0x97
-
-#define	SGRXMSG0        		0x98
-#define		CDNUM           	0xf8
-#define		CFNUM           	0x07
-
-#define	SLVSPLTOUTADR0  		0x98
-#define		LOWER_ADDR      	0x7f
-
-#define	SGRXMSG1        		0x99
-#define		CBNUM           	0xff
-
-#define	SLVSPLTOUTADR1  		0x99
-#define		REQ_DNUM        	0xf8
-#define		REQ_FNUM        	0x07
-
-#define	SGRXMSG2        		0x9a
-#define		MINDEX          	0xff
-
-#define	SLVSPLTOUTADR2  		0x9a
-#define		REQ_BNUM        	0xff
-
-#define	SGRXMSG3        		0x9b
-#define		MCLASS          	0x0f
-
-#define	SLVSPLTOUTADR3  		0x9b
-#define		TAG_NUM         	0x1f
-#define		RLXORD          	0x10
-
-#define	SGSEQBCNT       		0x9c
-
-#define	SLVSPLTOUTATTR0 		0x9c
-#define		LOWER_BCNT      	0xff
-
-#define	SLVSPLTOUTATTR1 		0x9d
-#define		CMPLT_DNUM      	0xf8
-#define		CMPLT_FNUM      	0x07
-
-#define	SLVSPLTOUTATTR2 		0x9e
-#define		CMPLT_BNUM      	0xff
-
-#define	SGSPLTSTAT0     		0x9e
-#define		STAETERM        	0x80
-#define		SCBCERR         	0x40
-#define		SCADERR         	0x20
-#define		SCDATBUCKET     	0x10
-#define		CNTNOTCMPLT     	0x08
-#define		RXOVRUN         	0x04
-#define		RXSCEMSG        	0x02
-#define		RXSPLTRSP       	0x01
-
-#define	SFUNCT          		0x9f
-#define		TEST_GROUP      	0xf0
-#define		TEST_NUM        	0x0f
-
-#define	SGSPLTSTAT1     		0x9f
-#define		RXDATABUCKET    	0x01
-
-#define	DF0PCISTAT      		0xa0
-
-#define	REG0            		0xa0
-
-#define	DF1PCISTAT      		0xa1
-
-#define	SGPCISTAT       		0xa2
-
-#define	REG1            		0xa2
-
-#define	CMCPCISTAT      		0xa3
-
-#define	OVLYPCISTAT     		0xa4
-#define		SCAAPERR        	0x08
-#define		RDPERR          	0x04
-
-#define	REG_ISR         		0xa4
-
-#define	SG_STATE        		0xa6
-#define		FETCH_INPROG    	0x04
-#define		LOADING_NEEDED  	0x02
-#define		SEGS_AVAIL      	0x01
-
-#define	MSIPCISTAT      		0xa6
-#define		RMA             	0x20
-#define		RTA             	0x10
-#define		CLRPENDMSI      	0x08
-#define		DPR             	0x01
-
-#define	TARGPCISTAT     		0xa7
-#define		DPE             	0x80
-#define		SSE             	0x40
-#define		STA             	0x08
-#define		TWATERR         	0x02
-
-#define	DATA_COUNT_ODD  		0xa7
-
-#define	SCBPTR          		0xa8
-
-#define	CCSCBACNT       		0xab
-
-#define	SCBAUTOPTR      		0xab
-#define		AUSCBPTR_EN     	0x80
-#define		SCBPTR_ADDR     	0x38
-#define		SCBPTR_OFF      	0x07
-
-#define	CCSGADDR        		0xac
-
-#define	CCSCBADDR       		0xac
-
-#define	CCSCBADR_BK     		0xac
-
-#define	CMC_RAMBIST     		0xad
-#define		SG_ELEMENT_SIZE 	0x80
-#define		SCBRAMBIST_FAIL 	0x40
-#define		SG_BIST_FAIL    	0x20
-#define		SG_BIST_EN      	0x10
-#define		CMC_BUFFER_BIST_FAIL	0x02
-#define		CMC_BUFFER_BIST_EN	0x01
-
-#define	CCSGCTL         		0xad
-#define		CCSGEN          	0x0c
-#define		CCSGDONE        	0x80
-#define		SG_CACHE_AVAIL  	0x10
-#define		CCSGENACK       	0x08
-#define		SG_FETCH_REQ    	0x02
-#define		CCSGRESET       	0x01
-
-#define	CCSCBCTL        		0xad
-#define		CCSCBDONE       	0x80
-#define		ARRDONE         	0x40
-#define		CCARREN         	0x10
-#define		CCSCBEN         	0x08
-#define		CCSCBDIR        	0x04
-#define		CCSCBRESET      	0x01
-
-#define	CCSGRAM         		0xb0
-
-#define	FLEXADR         		0xb0
-
-#define	CCSCBRAM        		0xb0
-
-#define	FLEXCNT         		0xb3
-
-#define	FLEXDMASTAT     		0xb5
-#define		FLEXDMAERR      	0x02
-#define		FLEXDMADONE     	0x01
-
-#define	FLEXDATA        		0xb6
-
-#define	BRDDAT          		0xb8
-
-#define	BRDCTL          		0xb9
-#define		FLXARBACK       	0x80
-#define		FLXARBREQ       	0x40
-#define		BRDADDR         	0x38
-#define		BRDEN           	0x04
-#define		BRDRW           	0x02
-#define		BRDSTB          	0x01
-
-#define	SEEADR          		0xba
-
-#define	SEEDAT          		0xbc
-
-#define	SEECTL          		0xbe
-#define		SEEOP_EWEN      	0x40
-#define		SEEOP_WALL      	0x40
-#define		SEEOP_EWDS      	0x40
-#define		SEEOPCODE       	0x70
-#define		SEERST          	0x02
-#define		SEESTART        	0x01
-#define		SEEOP_ERASE     	0x70
-#define		SEEOP_READ      	0x60
-#define		SEEOP_WRITE     	0x50
-#define		SEEOP_ERAL      	0x40
-
-#define	SEESTAT         		0xbe
-#define		INIT_DONE       	0x80
-#define		LDALTID_L       	0x08
-#define		SEEARBACK       	0x04
-#define		SEEBUSY         	0x02
-
-#define	SCBCNT          		0xbf
-
-#define	DFWADDR         		0xc0
-
-#define	DSPFLTRCTL      		0xc0
-#define		FLTRDISABLE     	0x20
-#define		EDGESENSE       	0x10
-#define		DSPFCNTSEL      	0x0f
-
-#define	DSPDATACTL      		0xc1
-#define		BYPASSENAB      	0x80
-#define		DESQDIS         	0x10
-#define		RCVROFFSTDIS    	0x04
-#define		XMITOFFSTDIS    	0x02
-
-#define	DFRADDR         		0xc2
-
-#define	DSPREQCTL       		0xc2
-#define		MANREQCTL       	0xc0
-#define		MANREQDLY       	0x3f
-
-#define	DSPACKCTL       		0xc3
-#define		MANACKCTL       	0xc0
-#define		MANACKDLY       	0x3f
-
-#define	DFDAT           		0xc4
-
-#define	DSPSELECT       		0xc4
-#define		AUTOINCEN       	0x80
-#define		DSPSEL          	0x1f
-
-#define	WRTBIASCTL      		0xc5
-#define		AUTOXBCDIS      	0x80
-#define		XMITMANVAL      	0x3f
-
-#define	RCVRBIOSCTL     		0xc6
-#define		AUTORBCDIS      	0x80
-#define		RCVRMANVAL      	0x3f
-
-#define	WRTBIASCALC     		0xc7
-
-#define	DFPTRS          		0xc8
-
-#define	RCVRBIASCALC    		0xc8
-
-#define	DFBKPTR         		0xc9
-
-#define	SKEWCALC        		0xc9
-
-#define	DFDBCTL         		0xcb
-#define		DFF_CIO_WR_RDY  	0x20
-#define		DFF_CIO_RD_RDY  	0x10
-#define		DFF_DIR_ERR     	0x08
-#define		DFF_RAMBIST_FAIL	0x04
-#define		DFF_RAMBIST_DONE	0x02
-#define		DFF_RAMBIST_EN  	0x01
-
-#define	DFSCNT          		0xcc
-
-#define	DFBCNT          		0xce
-
-#define	OVLYADDR        		0xd4
-
-#define	SEQCTL0         		0xd6
-#define		PERRORDIS       	0x80
-#define		PAUSEDIS        	0x40
-#define		FAILDIS         	0x20
-#define		FASTMODE        	0x10
-#define		BRKADRINTEN     	0x08
-#define		STEP            	0x04
-#define		SEQRESET        	0x02
-#define		LOADRAM         	0x01
-
-#define	SEQCTL1         		0xd7
-#define		OVRLAY_DATA_CHK 	0x08
-#define		RAMBIST_DONE    	0x04
-#define		RAMBIST_FAIL    	0x02
-#define		RAMBIST_EN      	0x01
-
-#define	FLAGS           		0xd8
-#define		ZERO            	0x02
-#define		CARRY           	0x01
-
-#define	SEQINTCTL       		0xd9
-#define		INTVEC1DSL      	0x80
-#define		INT1_CONTEXT    	0x20
-#define		SCS_SEQ_INT1M1  	0x10
-#define		SCS_SEQ_INT1M0  	0x08
-#define		INTMASK2        	0x04
-#define		INTMASK1        	0x02
-#define		IRET            	0x01
-
-#define	SEQRAM          		0xda
-
-#define	PRGMCNT         		0xde
-
-#define	ACCUM           		0xe0
-
-#define	SINDEX          		0xe2
-
-#define	DINDEX          		0xe4
-
-#define	BRKADDR1        		0xe6
-#define		BRKDIS          	0x80
-
-#define	BRKADDR0        		0xe6
-
-#define	ALLONES         		0xe8
-
-#define	ALLZEROS        		0xea
-
-#define	NONE            		0xea
-
-#define	SINDIR          		0xec
-
-#define	DINDIR          		0xed
-
-#define	FUNCTION1       		0xf0
-
-#define	STACK           		0xf2
-
-#define	CURADDR         		0xf4
-
-#define	INTVEC1_ADDR    		0xf4
-
-#define	INTVEC2_ADDR    		0xf6
-
-#define	LASTADDR        		0xf6
-
-#define	LONGJMP_ADDR    		0xf8
-
-#define	LONGJMP_SCB     		0xfa
-
-#define	ACCUM_SAVE      		0xfc
-
-#define	WAITING_SCB_TAILS		0x100
-
-#define	AHD_PCI_CONFIG_BASE		0x100
-
-#define	SRAM_BASE       		0x100
-
-#define	WAITING_TID_HEAD		0x120
-
-#define	WAITING_TID_TAIL		0x122
-
-#define	NEXT_QUEUED_SCB_ADDR		0x124
-
-#define	COMPLETE_SCB_HEAD		0x128
-
-#define	COMPLETE_SCB_DMAINPROG_HEAD		0x12a
-
-#define	COMPLETE_DMA_SCB_HEAD		0x12c
-
-#define	QFREEZE_COUNT   		0x12e
-
-#define	SAVED_MODE      		0x130
-
-#define	MSG_OUT         		0x131
-
-#define	DMAPARAMS       		0x132
-#define		PRELOADEN       	0x80
-#define		WIDEODD         	0x40
-#define		SCSIEN          	0x20
-#define		SDMAEN          	0x10
-#define		SDMAENACK       	0x10
-#define		HDMAENACK       	0x08
-#define		HDMAEN          	0x08
-#define		DIRECTION       	0x04
-#define		FIFOFLUSH       	0x02
-#define		FIFORESET       	0x01
-
-#define	SEQ_FLAGS       		0x133
-#define		NOT_IDENTIFIED  	0x80
-#define		NO_CDB_SENT     	0x40
-#define		TARGET_CMD_IS_TAGGED	0x40
-#define		DPHASE          	0x20
-#define		TARG_CMD_PENDING	0x10
-#define		CMDPHASE_PENDING	0x08
-#define		DPHASE_PENDING  	0x04
-#define		SPHASE_PENDING  	0x02
-#define		NO_DISCONNECT   	0x01
-
-#define	SAVED_SCSIID    		0x134
-
-#define	SAVED_LUN       		0x135
-
-#define	LASTPHASE       		0x136
-#define		PHASE_MASK      	0xe0
-#define		CDI             	0x80
-#define		IOI             	0x40
-#define		MSGI            	0x20
-#define		P_BUSFREE       	0x01
-#define		P_MESGIN        	0xe0
-#define		P_STATUS        	0xc0
-#define		P_MESGOUT       	0xa0
-#define		P_COMMAND       	0x80
-#define		P_DATAIN_DT     	0x60
-#define		P_DATAIN        	0x40
-#define		P_DATAOUT_DT    	0x20
-#define		P_DATAOUT       	0x00
-
-#define	QOUTFIFO_ENTRY_VALID_TAG		0x137
-
-#define	SHARED_DATA_ADDR		0x138
-
-#define	QOUTFIFO_NEXT_ADDR		0x13c
-
-#define	KERNEL_TQINPOS  		0x140
-
-#define	TQINPOS         		0x141
-
-#define	ARG_1           		0x142
-#define	RETURN_1        		0x142
-#define		SEND_MSG        	0x80
-#define		SEND_SENSE      	0x40
-#define		SEND_REJ        	0x20
-#define		MSGOUT_PHASEMIS 	0x10
-#define		EXIT_MSG_LOOP   	0x08
-#define		CONT_MSG_LOOP_WRITE	0x04
-#define		CONT_MSG_LOOP_READ	0x03
-#define		CONT_MSG_LOOP_TARG	0x02
-
-#define	ARG_2           		0x143
-#define	RETURN_2        		0x143
-
-#define	LAST_MSG        		0x144
-
-#define	SCSISEQ_TEMPLATE		0x145
-#define		MANUALCTL       	0x40
-#define		ENSELI          	0x20
-#define		ENRSELI         	0x10
-#define		MANUALP         	0x0c
-#define		ENAUTOATNP      	0x02
-#define		ALTSTIM         	0x01
-
-#define	INITIATOR_TAG   		0x146
-
-#define	SEQ_FLAGS2      		0x147
-#define		SELECTOUT_QFROZEN	0x04
-#define		TARGET_MSG_PENDING	0x02
-
-#define	ALLOCFIFO_SCBPTR		0x148
-
-#define	INT_COALESSING_TIMER		0x14a
-
-#define	INT_COALESSING_MAXCMDS		0x14c
-
-#define	INT_COALESSING_MINCMDS		0x14d
-
-#define	CMDS_PENDING    		0x14e
-
-#define	INT_COALESSING_CMDCOUNT		0x150
-
-#define	LOCAL_HS_MAILBOX		0x151
-
-#define	CMDSIZE_TABLE   		0x152
-
-#define	SCB_BASE        		0x180
-
-#define	SCB_RESIDUAL_DATACNT		0x180
-#define	SCB_CDB_STORE   		0x180
-
-#define	SCB_RESIDUAL_SGPTR		0x184
-#define	SCB_CDB_PTR     		0x184
-#define		SG_ADDR_MASK    	0xf8
-#define		SG_OVERRUN_RESID	0x02
-
-#define	SCB_SCSI_STATUS 		0x188
-
-#define	SCB_TARGET_PHASES		0x189
-
-#define	SCB_TARGET_DATA_DIR		0x18a
-
-#define	SCB_TARGET_ITAG 		0x18b
-
-#define	SCB_SENSE_BUSADDR		0x18c
-#define	SCB_NEXT_COMPLETE		0x18c
-
-#define	SCB_TAG         		0x190
-
-#define	SCB_CDB_LEN     		0x192
-#define		SCB_CDB_LEN_PTR 	0x80
-
-#define	SCB_TASK_MANAGEMENT		0x193
-
-#define	SCB_NEXT        		0x194
-#define	SCB_NEXT_SCB_BUSADDR		0x194
-
-#define	SCB_NEXT2       		0x196
-
-#define	SCB_DATAPTR     		0x198
-
-#define	SCB_DATACNT     		0x1a0
-#define		SG_LAST_SEG     	0x80
-#define		SG_HIGH_ADDR_BITS	0x7f
-
-#define	SCB_SGPTR       		0x1a4
-#define		SG_STATUS_VALID 	0x04
-#define		SG_FULL_RESID   	0x02
-#define		SG_LIST_NULL    	0x01
-
-#define	SCB_CONTROL     		0x1a8
-#define		TARGET_SCB      	0x80
-#define		DISCENB         	0x40
-#define		TAG_ENB         	0x20
-#define		MK_MESSAGE      	0x10
-#define		STATUS_RCVD     	0x08
-#define		DISCONNECTED    	0x04
-#define		SCB_TAG_TYPE    	0x03
-
-#define	SCB_SCSIID      		0x1a9
-#define		TID             	0xf0
-#define		OID             	0x0f
-
-#define	SCB_LUN         		0x1aa
-#define		LID             	0xff
-
-#define	SCB_TASK_ATTRIBUTE		0x1ab
-
-#define	SCB_BUSADDR     		0x1ac
-
-#define	SCB_SPARE       		0x1b0
-#define	SCB_PKT_LUN     		0x1b0
-
-#define	SCB_DISCONNECTED_LISTS		0x1b8
-
-
-#define	AHD_TIMER_US_PER_TICK	0x19
-#define	SCB_TRANSFER_SIZE_FULL_LUN	0x38
-#define	STATUS_QUEUE_FULL	0x28
-#define	STATUS_BUSY	0x08
-#define	MAX_OFFSET_NON_PACED	0x7f
-#define	MAX_OFFSET_PACED	0xfe
-#define	BUS_32_BIT	0x02
-#define	CCSGADDR_MAX	0x80
-#define	TID_SHIFT	0x04
-#define	MK_MESSAGE_BIT_OFFSET	0x04
-#define	WRTBIASCTL_HP_DEFAULT	0x00
-#define	SEEOP_EWDS_ADDR	0x00
-#define	AHD_AMPLITUDE_SHIFT	0x00
-#define	AHD_AMPLITUDE_MASK	0x07
-#define	AHD_ANNEXCOL_AMPLITUDE	0x06
-#define	AHD_SLEWRATE_DEF_REVA	0x01
-#define	AHD_SLEWRATE_SHIFT	0x03
-#define	AHD_SLEWRATE_MASK	0x78
-#define	AHD_PRECOMP_CUTBACK_29	0x06
-#define	AHD_NUM_PER_DEV_ANNEXCOLS	0x04
-#define	B_CURRFIFO_0	0x02
-#define	NVRAM_SCB_OFFSET	0x2c
-#define	AHD_TIMER_MAX_US	0x18ffe7
-#define	AHD_TIMER_MAX_TICKS	0xffff
-#define	STATUS_PKT_SENSE	0xff
-#define	CMD_GROUP_CODE_SHIFT	0x05
-#define	AHD_SENSE_BUFSIZE	0x100
-#define	MAX_OFFSET_PACED_BUG	0x7f
-#define	BUS_8_BIT	0x00
-#define	STIMESEL_BUG_ADJ	0x08
-#define	STIMESEL_MIN	0x18
-#define	STIMESEL_SHIFT	0x03
-#define	CCSGRAM_MAXSEGS	0x10
-#define	INVALID_ADDR	0x80
-#define	TARGET_CMD_CMPLT	0xfe
-#define	SEEOP_WRAL_ADDR	0x40
-#define	SEEOP_ERAL_ADDR	0x80
-#define	AHD_AMPLITUDE_DEF	0x07
-#define	AHD_SLEWRATE_DEF_REVB	0x08
-#define	AHD_PRECOMP_CUTBACK_37	0x07
-#define	AHD_PRECOMP_CUTBACK_17	0x04
-#define	AHD_PRECOMP_SHIFT	0x00
-#define	AHD_PRECOMP_MASK	0x07
-#define	AHD_ANNEXCOL_PRECOMP_SLEW	0x04
-#define	SRC_MODE_SHIFT	0x00
-#define	PKT_OVERRUN_BUFSIZE	0x200
-#define	SCB_TRANSFER_SIZE_1BYTE_LUN	0x30
-#define	TARGET_DATA_IN	0x01
-#define	HOST_MSG	0xff
-#define	MAX_OFFSET	0xfe
-#define	BUS_16_BIT	0x01
-#define	CCSCBADDR_MAX	0x80
-#define	NUMDSPS 	0x14
-#define	SEEOP_EWEN_ADDR	0xc0
-#define	AHD_ANNEXCOL_PER_DEV0	0x04
-#define	DST_MODE_SHIFT	0x04
-
-
-/* Downloaded Constant Definitions */
-#define	SCB_TRANSFER_SIZE	0x06
-#define	PKT_OVERRUN_BUFOFFSET	0x05
-#define	SG_SIZEOF	0x04
-#define	SG_PREFETCH_ADDR_MASK	0x03
-#define	SG_PREFETCH_ALIGN_MASK	0x02
-#define	SG_PREFETCH_CNT_LIMIT	0x01
-#define	SG_PREFETCH_CNT	0x00
-#define	DOWNLOAD_CONST_COUNT	0x07
-
-
-/* Exported Labels */
-#define	LABEL_seq_isr 	0x263
-#define	LABEL_timer_isr	0x25f
diff -urNp linux-5720/drivers/scsi/aic79xx/aic79xx_reg_print.c linux-5730/drivers/scsi/aic79xx/aic79xx_reg_print.c
--- linux-5720/drivers/scsi/aic79xx/aic79xx_reg_print.c
+++ linux-5730/drivers/scsi/aic79xx/aic79xx_reg_print.c
@@ -1,3632 +0,0 @@
-/*
- * DO NOT EDIT - This file is automatically generated
- *		 from the following source files:
- *
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#78 $
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#60 $
- */
-
-#include "aic79xx_osm.h"
-
-static ahd_reg_parse_entry_t MODE_PTR_parse_table[] = {
-	{ "SRC_MODE",		0x07, 0x07 },
-	{ "DST_MODE",		0x70, 0x70 }
-};
-
-int
-ahd_mode_ptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(MODE_PTR_parse_table, 2, "MODE_PTR",
-	    0x00, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t INTSTAT_parse_table[] = {
-	{ "SPLTINT",		0x01, 0x01 },
-	{ "CMDCMPLT",		0x02, 0x02 },
-	{ "SEQINT",		0x04, 0x04 },
-	{ "SCSIINT",		0x08, 0x08 },
-	{ "PCIINT",		0x10, 0x10 },
-	{ "SWTMINT",		0x20, 0x20 },
-	{ "BRKADRINT",		0x40, 0x40 },
-	{ "HWERRINT",		0x80, 0x80 },
-	{ "INT_PEND",		0xff, 0xff }
-};
-
-int
-ahd_intstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(INTSTAT_parse_table, 9, "INTSTAT",
-	    0x01, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SEQINTCODE_parse_table[] = {
-	{ "NO_SEQINT",		0x00, 0xff },
-	{ "BAD_PHASE",		0x01, 0xff },
-	{ "SEND_REJECT",	0x02, 0xff },
-	{ "PROTO_VIOLATION",	0x03, 0xff },
-	{ "NO_MATCH",		0x04, 0xff },
-	{ "IGN_WIDE_RES",	0x05, 0xff },
-	{ "PDATA_REINIT",	0x06, 0xff },
-	{ "HOST_MSG_LOOP",	0x07, 0xff },
-	{ "BAD_STATUS",		0x08, 0xff },
-	{ "DATA_OVERRUN",	0x09, 0xff },
-	{ "MKMSG_FAILED",	0x0a, 0xff },
-	{ "MISSED_BUSFREE",	0x0b, 0xff },
-	{ "DUMP_CARD_STATE",	0x0c, 0xff },
-	{ "ILLEGAL_PHASE",	0x0d, 0xff },
-	{ "INVALID_SEQINT",	0x0e, 0xff },
-	{ "CFG4ISTAT_INTR",	0x0f, 0xff },
-	{ "STATUS_OVERRUN",	0x10, 0xff },
-	{ "CFG4OVERRUN",	0x11, 0xff },
-	{ "ENTERING_NONPACK",	0x12, 0xff },
-	{ "TASKMGMT_FUNC_COMPLETE",0x13, 0xff },
-	{ "TASKMGMT_CMD_CMPLT_OKAY",0x14, 0xff },
-	{ "TRACEPOINT0",	0x15, 0xff },
-	{ "TRACEPOINT1",	0x16, 0xff },
-	{ "TRACEPOINT2",	0x17, 0xff },
-	{ "TRACEPOINT3",	0x18, 0xff },
-	{ "SAW_HWERR",		0x19, 0xff }
-};
-
-int
-ahd_seqintcode_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SEQINTCODE_parse_table, 26, "SEQINTCODE",
-	    0x02, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CLRINT_parse_table[] = {
-	{ "CLRSPLTINT",		0x01, 0x01 },
-	{ "CLRCMDINT",		0x02, 0x02 },
-	{ "CLRSEQINT",		0x04, 0x04 },
-	{ "CLRSCSIINT",		0x08, 0x08 },
-	{ "CLRPCIINT",		0x10, 0x10 },
-	{ "CLRSWTMINT",		0x20, 0x20 },
-	{ "CLRBRKADRINT",	0x40, 0x40 },
-	{ "CLRHWERRINT",	0x80, 0x80 }
-};
-
-int
-ahd_clrint_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CLRINT_parse_table, 8, "CLRINT",
-	    0x03, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t ERROR_parse_table[] = {
-	{ "DSCTMOUT",		0x02, 0x02 },
-	{ "ILLOPCODE",		0x04, 0x04 },
-	{ "SQPARERR",		0x08, 0x08 },
-	{ "DPARERR",		0x10, 0x10 },
-	{ "MPARERR",		0x20, 0x20 },
-	{ "CIOACCESFAIL",	0x40, 0x40 },
-	{ "CIOPARERR",		0x80, 0x80 }
-};
-
-int
-ahd_error_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(ERROR_parse_table, 7, "ERROR",
-	    0x04, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CLRERR_parse_table[] = {
-	{ "CLRDSCTMOUT",	0x02, 0x02 },
-	{ "CLRILLOPCODE",	0x04, 0x04 },
-	{ "CLRSQPARERR",	0x08, 0x08 },
-	{ "CLRDPARERR",		0x10, 0x10 },
-	{ "CLRMPARERR",		0x20, 0x20 },
-	{ "CLRCIOACCESFAIL",	0x40, 0x40 },
-	{ "CLRCIOPARERR",	0x80, 0x80 }
-};
-
-int
-ahd_clrerr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CLRERR_parse_table, 7, "CLRERR",
-	    0x04, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t HCNTRL_parse_table[] = {
-	{ "CHIPRST",		0x01, 0x01 },
-	{ "CHIPRSTACK",		0x01, 0x01 },
-	{ "INTEN",		0x02, 0x02 },
-	{ "PAUSE",		0x04, 0x04 },
-	{ "SWTIMER_START_B",	0x08, 0x08 },
-	{ "SWINT",		0x10, 0x10 },
-	{ "POWRDN",		0x40, 0x40 },
-	{ "SEQ_RESET",		0x80, 0x80 }
-};
-
-int
-ahd_hcntrl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(HCNTRL_parse_table, 8, "HCNTRL",
-	    0x05, regvalue, cur_col, wrap));
-}
-
-int
-ahd_hnscb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "HNSCB_QOFF",
-	    0x06, regvalue, cur_col, wrap));
-}
-
-int
-ahd_hescb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "HESCB_QOFF",
-	    0x08, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t HS_MAILBOX_parse_table[] = {
-	{ "ENINT_COALESS",	0x40, 0x40 },
-	{ "HOST_TQINPOS",	0x80, 0x80 }
-};
-
-int
-ahd_hs_mailbox_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(HS_MAILBOX_parse_table, 2, "HS_MAILBOX",
-	    0x0b, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CLRSEQINTSTAT_parse_table[] = {
-	{ "CLRSEQ_SPLTINT",	0x01, 0x01 },
-	{ "CLRSEQ_PCIINT",	0x02, 0x02 },
-	{ "CLRSEQ_SCSIINT",	0x04, 0x04 },
-	{ "CLRSEQ_SEQINT",	0x08, 0x08 },
-	{ "CLRSEQ_SWTMRTO",	0x10, 0x10 }
-};
-
-int
-ahd_clrseqintstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CLRSEQINTSTAT_parse_table, 5, "CLRSEQINTSTAT",
-	    0x0c, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SEQINTSTAT_parse_table[] = {
-	{ "SEQ_SPLTINT",	0x01, 0x01 },
-	{ "SEQ_PCIINT",		0x02, 0x02 },
-	{ "SEQ_SCSIINT",	0x04, 0x04 },
-	{ "SEQ_SEQINT",		0x08, 0x08 },
-	{ "SEQ_SWTMRTO",	0x10, 0x10 }
-};
-
-int
-ahd_seqintstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SEQINTSTAT_parse_table, 5, "SEQINTSTAT",
-	    0x0c, regvalue, cur_col, wrap));
-}
-
-int
-ahd_swtimer_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SWTIMER",
-	    0x0e, regvalue, cur_col, wrap));
-}
-
-int
-ahd_snscb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SNSCB_QOFF",
-	    0x10, regvalue, cur_col, wrap));
-}
-
-int
-ahd_sescb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SESCB_QOFF",
-	    0x12, regvalue, cur_col, wrap));
-}
-
-int
-ahd_sdscb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SDSCB_QOFF",
-	    0x14, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t QOFF_CTLSTA_parse_table[] = {
-	{ "SCB_QSIZE_4",	0x00, 0x0f },
-	{ "SCB_QSIZE_8",	0x01, 0x0f },
-	{ "SCB_QSIZE_16",	0x02, 0x0f },
-	{ "SCB_QSIZE_32",	0x03, 0x0f },
-	{ "SCB_QSIZE_64",	0x04, 0x0f },
-	{ "SCB_QSIZE_128",	0x05, 0x0f },
-	{ "SCB_QSIZE_256",	0x06, 0x0f },
-	{ "SCB_QSIZE_512",	0x07, 0x0f },
-	{ "SCB_QSIZE_1024",	0x08, 0x0f },
-	{ "SCB_QSIZE_2048",	0x09, 0x0f },
-	{ "SCB_QSIZE_4096",	0x0a, 0x0f },
-	{ "SCB_QSIZE_8192",	0x0b, 0x0f },
-	{ "SCB_QSIZE_16384",	0x0c, 0x0f },
-	{ "SCB_QSIZE",		0x0f, 0x0f },
-	{ "HS_MAILBOX_ACT",	0x10, 0x10 },
-	{ "SDSCB_ROLLOVR",	0x20, 0x20 },
-	{ "NEW_SCB_AVAIL",	0x40, 0x40 },
-	{ "EMPTY_SCB_AVAIL",	0x80, 0x80 }
-};
-
-int
-ahd_qoff_ctlsta_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(QOFF_CTLSTA_parse_table, 18, "QOFF_CTLSTA",
-	    0x16, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t INTCTL_parse_table[] = {
-	{ "SPLTINTEN",		0x01, 0x01 },
-	{ "SEQINTEN",		0x02, 0x02 },
-	{ "SCSIINTEN",		0x04, 0x04 },
-	{ "PCIINTEN",		0x08, 0x08 },
-	{ "AUTOCLRCMDINT",	0x10, 0x10 },
-	{ "SWTIMER_START",	0x20, 0x20 },
-	{ "SWTMINTEN",		0x40, 0x40 },
-	{ "SWTMINTMASK",	0x80, 0x80 }
-};
-
-int
-ahd_intctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(INTCTL_parse_table, 8, "INTCTL",
-	    0x18, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DFCNTRL_parse_table[] = {
-	{ "DIRECTIONEN",	0x01, 0x01 },
-	{ "FIFOFLUSH",		0x02, 0x02 },
-	{ "FIFOFLUSHACK",	0x02, 0x02 },
-	{ "DIRECTION",		0x04, 0x04 },
-	{ "DIRECTIONACK",	0x04, 0x04 },
-	{ "HDMAEN",		0x08, 0x08 },
-	{ "HDMAENACK",		0x08, 0x08 },
-	{ "SCSIEN",		0x20, 0x20 },
-	{ "SCSIENACK",		0x20, 0x20 },
-	{ "SCSIENWRDIS",	0x40, 0x40 },
-	{ "PRELOADEN",		0x80, 0x80 }
-};
-
-int
-ahd_dfcntrl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DFCNTRL_parse_table, 11, "DFCNTRL",
-	    0x19, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DSCOMMAND0_parse_table[] = {
-	{ "CIOPARCKEN",		0x01, 0x01 },
-	{ "DISABLE_TWATE",	0x02, 0x02 },
-	{ "EXTREQLCK",		0x10, 0x10 },
-	{ "MPARCKEN",		0x20, 0x20 },
-	{ "DPARCKEN",		0x40, 0x40 },
-	{ "CACHETHEN",		0x80, 0x80 }
-};
-
-int
-ahd_dscommand0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DSCOMMAND0_parse_table, 6, "DSCOMMAND0",
-	    0x19, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DFSTATUS_parse_table[] = {
-	{ "FIFOEMP",		0x01, 0x01 },
-	{ "FIFOFULL",		0x02, 0x02 },
-	{ "DFTHRESH",		0x04, 0x04 },
-	{ "HDONE",		0x08, 0x08 },
-	{ "MREQPEND",		0x10, 0x10 },
-	{ "PKT_PRELOAD_AVAIL",	0x40, 0x40 },
-	{ "PRELOAD_AVAIL",	0x80, 0x80 }
-};
-
-int
-ahd_dfstatus_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DFSTATUS_parse_table, 7, "DFSTATUS",
-	    0x1a, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SG_CACHE_SHADOW_parse_table[] = {
-	{ "LAST_SEG_DONE",	0x01, 0x01 },
-	{ "LAST_SEG",		0x02, 0x02 },
-	{ "ODD_SEG",		0x04, 0x04 },
-	{ "SG_ADDR_MASK",	0xf8, 0xf8 }
-};
-
-int
-ahd_sg_cache_shadow_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SG_CACHE_SHADOW_parse_table, 4, "SG_CACHE_SHADOW",
-	    0x1b, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t ARBCTL_parse_table[] = {
-	{ "USE_TIME",		0x07, 0x07 },
-	{ "RETRY_SWEN",		0x08, 0x08 },
-	{ "RESET_HARB",		0x80, 0x80 }
-};
-
-int
-ahd_arbctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(ARBCTL_parse_table, 3, "ARBCTL",
-	    0x1b, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SG_CACHE_PRE_parse_table[] = {
-	{ "LAST_SEG",		0x02, 0x02 },
-	{ "ODD_SEG",		0x04, 0x04 },
-	{ "SG_ADDR_MASK",	0xf8, 0xf8 }
-};
-
-int
-ahd_sg_cache_pre_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SG_CACHE_PRE_parse_table, 3, "SG_CACHE_PRE",
-	    0x1b, regvalue, cur_col, wrap));
-}
-
-int
-ahd_lqin_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "LQIN",
-	    0x20, regvalue, cur_col, wrap));
-}
-
-int
-ahd_typeptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "TYPEPTR",
-	    0x20, regvalue, cur_col, wrap));
-}
-
-int
-ahd_tagptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "TAGPTR",
-	    0x21, regvalue, cur_col, wrap));
-}
-
-int
-ahd_lunptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "LUNPTR",
-	    0x22, regvalue, cur_col, wrap));
-}
-
-int
-ahd_datalenptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "DATALENPTR",
-	    0x23, regvalue, cur_col, wrap));
-}
-
-int
-ahd_statlenptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "STATLENPTR",
-	    0x24, regvalue, cur_col, wrap));
-}
-
-int
-ahd_cmdlenptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "CMDLENPTR",
-	    0x25, regvalue, cur_col, wrap));
-}
-
-int
-ahd_attrptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "ATTRPTR",
-	    0x26, regvalue, cur_col, wrap));
-}
-
-int
-ahd_flagptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "FLAGPTR",
-	    0x27, regvalue, cur_col, wrap));
-}
-
-int
-ahd_cmdptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "CMDPTR",
-	    0x28, regvalue, cur_col, wrap));
-}
-
-int
-ahd_qnextptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "QNEXTPTR",
-	    0x29, regvalue, cur_col, wrap));
-}
-
-int
-ahd_idptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "IDPTR",
-	    0x2a, regvalue, cur_col, wrap));
-}
-
-int
-ahd_abrtbyteptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "ABRTBYTEPTR",
-	    0x2b, regvalue, cur_col, wrap));
-}
-
-int
-ahd_abrtbitptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "ABRTBITPTR",
-	    0x2c, regvalue, cur_col, wrap));
-}
-
-int
-ahd_maxcmdbytes_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "MAXCMDBYTES",
-	    0x2d, regvalue, cur_col, wrap));
-}
-
-int
-ahd_maxcmd2rcv_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "MAXCMD2RCV",
-	    0x2e, regvalue, cur_col, wrap));
-}
-
-int
-ahd_shortthresh_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SHORTTHRESH",
-	    0x2f, regvalue, cur_col, wrap));
-}
-
-int
-ahd_lunlen_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "LUNLEN",
-	    0x30, regvalue, cur_col, wrap));
-}
-
-int
-ahd_cdblimit_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "CDBLIMIT",
-	    0x31, regvalue, cur_col, wrap));
-}
-
-int
-ahd_maxcmd_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "MAXCMD",
-	    0x32, regvalue, cur_col, wrap));
-}
-
-int
-ahd_maxcmdcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "MAXCMDCNT",
-	    0x33, regvalue, cur_col, wrap));
-}
-
-int
-ahd_lqrsvd01_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "LQRSVD01",
-	    0x34, regvalue, cur_col, wrap));
-}
-
-int
-ahd_lqrsvd16_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "LQRSVD16",
-	    0x35, regvalue, cur_col, wrap));
-}
-
-int
-ahd_lqrsvd17_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "LQRSVD17",
-	    0x36, regvalue, cur_col, wrap));
-}
-
-int
-ahd_cmdrsvd0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "CMDRSVD0",
-	    0x37, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t LQCTL0_parse_table[] = {
-	{ "LQ0INITGCLT",	0x03, 0x03 },
-	{ "LQ0TARGCLT",		0x0c, 0x0c },
-	{ "LQIINITGCLT",	0x30, 0x30 },
-	{ "LQITARGCLT",		0xc0, 0xc0 }
-};
-
-int
-ahd_lqctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQCTL0_parse_table, 4, "LQCTL0",
-	    0x38, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t LQCTL1_parse_table[] = {
-	{ "ABORTPENDING",	0x01, 0x01 },
-	{ "SINGLECMD",		0x02, 0x02 },
-	{ "PCI2PCI",		0x04, 0x04 }
-};
-
-int
-ahd_lqctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQCTL1_parse_table, 3, "LQCTL1",
-	    0x38, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCSBIST0_parse_table[] = {
-	{ "OSBISTRUN",		0x01, 0x01 },
-	{ "OSBISTDONE",		0x02, 0x02 },
-	{ "OSBISTERR",		0x04, 0x04 },
-	{ "GSBISTRUN",		0x10, 0x10 },
-	{ "GSBISTDONE",		0x20, 0x20 },
-	{ "GSBISTERR",		0x40, 0x40 }
-};
-
-int
-ahd_scsbist0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCSBIST0_parse_table, 6, "SCSBIST0",
-	    0x39, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t LQCTL2_parse_table[] = {
-	{ "LQOPAUSE",		0x01, 0x01 },
-	{ "LQOTOIDLE",		0x02, 0x02 },
-	{ "LQOCONTINUE",	0x04, 0x04 },
-	{ "LQORETRY",		0x08, 0x08 },
-	{ "LQIPAUSE",		0x10, 0x10 },
-	{ "LQITOIDLE",		0x20, 0x20 },
-	{ "LQICONTINUE",	0x40, 0x40 },
-	{ "LQIRETRY",		0x80, 0x80 }
-};
-
-int
-ahd_lqctl2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQCTL2_parse_table, 8, "LQCTL2",
-	    0x39, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCSBIST1_parse_table[] = {
-	{ "NTBISTRUN",		0x01, 0x01 },
-	{ "NTBISTDONE",		0x02, 0x02 },
-	{ "NTBISTERR",		0x04, 0x04 }
-};
-
-int
-ahd_scsbist1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCSBIST1_parse_table, 3, "SCSBIST1",
-	    0x3a, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCSISEQ0_parse_table[] = {
-	{ "SCSIRSTO",		0x01, 0x01 },
-	{ "FORCEBUSFREE",	0x10, 0x10 },
-	{ "ENARBO",		0x20, 0x20 },
-	{ "ENSELO",		0x40, 0x40 },
-	{ "TEMODEO",		0x80, 0x80 }
-};
-
-int
-ahd_scsiseq0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCSISEQ0_parse_table, 5, "SCSISEQ0",
-	    0x3a, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCSISEQ1_parse_table[] = {
-	{ "ALTSTIM",		0x01, 0x01 },
-	{ "ENAUTOATNP",		0x02, 0x02 },
-	{ "MANUALP",		0x0c, 0x0c },
-	{ "ENRSELI",		0x10, 0x10 },
-	{ "ENSELI",		0x20, 0x20 },
-	{ "MANUALCTL",		0x40, 0x40 }
-};
-
-int
-ahd_scsiseq1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCSISEQ1_parse_table, 6, "SCSISEQ1",
-	    0x3b, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SXFRCTL0_parse_table[] = {
-	{ "SPIOEN",		0x08, 0x08 },
-	{ "BIOSCANCELEN",	0x10, 0x10 },
-	{ "DFPEXP",		0x40, 0x40 },
-	{ "DFON",		0x80, 0x80 }
-};
-
-int
-ahd_sxfrctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SXFRCTL0_parse_table, 4, "SXFRCTL0",
-	    0x3c, regvalue, cur_col, wrap));
-}
-
-int
-ahd_businitid_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "BUSINITID",
-	    0x3c, regvalue, cur_col, wrap));
-}
-
-int
-ahd_dlcount_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "DLCOUNT",
-	    0x3c, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SXFRCTL1_parse_table[] = {
-	{ "STPWEN",		0x01, 0x01 },
-	{ "ACTNEGEN",		0x02, 0x02 },
-	{ "ENSTIMER",		0x04, 0x04 },
-	{ "STIMESEL",		0x18, 0x18 },
-	{ "ENSPCHK",		0x20, 0x20 },
-	{ "ENSACHK",		0x40, 0x40 },
-	{ "BITBUCKET",		0x80, 0x80 }
-};
-
-int
-ahd_sxfrctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SXFRCTL1_parse_table, 7, "SXFRCTL1",
-	    0x3d, regvalue, cur_col, wrap));
-}
-
-int
-ahd_bustargid_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "BUSTARGID",
-	    0x3e, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SXFRCTL2_parse_table[] = {
-	{ "ASU",		0x07, 0x07 },
-	{ "CMDDMAEN",		0x08, 0x08 },
-	{ "AUTORSTDIS",		0x10, 0x10 }
-};
-
-int
-ahd_sxfrctl2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SXFRCTL2_parse_table, 3, "SXFRCTL2",
-	    0x3e, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DFFSTAT_parse_table[] = {
-	{ "CURRFIFO_0",		0x00, 0x03 },
-	{ "CURRFIFO_1",		0x01, 0x03 },
-	{ "CURRFIFO_NONE",	0x03, 0x03 },
-	{ "FIFO0FREE",		0x10, 0x10 },
-	{ "FIFO1FREE",		0x20, 0x20 },
-	{ "CURRFIFO",		0x03, 0x03 }
-};
-
-int
-ahd_dffstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DFFSTAT_parse_table, 6, "DFFSTAT",
-	    0x3f, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCSISIGO_parse_table[] = {
-	{ "P_DATAOUT",		0x00, 0xe0 },
-	{ "P_DATAOUT_DT",	0x20, 0xe0 },
-	{ "P_DATAIN",		0x40, 0xe0 },
-	{ "P_DATAIN_DT",	0x60, 0xe0 },
-	{ "P_COMMAND",		0x80, 0xe0 },
-	{ "P_MESGOUT",		0xa0, 0xe0 },
-	{ "P_STATUS",		0xc0, 0xe0 },
-	{ "P_MESGIN",		0xe0, 0xe0 },
-	{ "ACKO",		0x01, 0x01 },
-	{ "REQO",		0x02, 0x02 },
-	{ "BSYO",		0x04, 0x04 },
-	{ "SELO",		0x08, 0x08 },
-	{ "ATNO",		0x10, 0x10 },
-	{ "MSGO",		0x20, 0x20 },
-	{ "IOO",		0x40, 0x40 },
-	{ "CDO",		0x80, 0x80 },
-	{ "PHASE_MASK",		0xe0, 0xe0 }
-};
-
-int
-ahd_scsisigo_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCSISIGO_parse_table, 17, "SCSISIGO",
-	    0x40, regvalue, cur_col, wrap));
-}
-
-int
-ahd_multargid_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "MULTARGID",
-	    0x40, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCSISIGI_parse_table[] = {
-	{ "P_DATAOUT",		0x00, 0xe0 },
-	{ "P_DATAOUT_DT",	0x20, 0xe0 },
-	{ "P_DATAIN",		0x40, 0xe0 },
-	{ "P_DATAIN_DT",	0x60, 0xe0 },
-	{ "P_COMMAND",		0x80, 0xe0 },
-	{ "P_MESGOUT",		0xa0, 0xe0 },
-	{ "P_STATUS",		0xc0, 0xe0 },
-	{ "P_MESGIN",		0xe0, 0xe0 },
-	{ "ACKI",		0x01, 0x01 },
-	{ "REQI",		0x02, 0x02 },
-	{ "BSYI",		0x04, 0x04 },
-	{ "SELI",		0x08, 0x08 },
-	{ "ATNI",		0x10, 0x10 },
-	{ "MSGI",		0x20, 0x20 },
-	{ "IOI",		0x40, 0x40 },
-	{ "CDI",		0x80, 0x80 },
-	{ "PHASE_MASK",		0xe0, 0xe0 }
-};
-
-int
-ahd_scsisigi_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCSISIGI_parse_table, 17, "SCSISIGI",
-	    0x41, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCSIPHASE_parse_table[] = {
-	{ "DATA_OUT_PHASE",	0x01, 0x03 },
-	{ "DATA_IN_PHASE",	0x02, 0x03 },
-	{ "DATA_PHASE_MASK",	0x03, 0x03 },
-	{ "MSG_OUT_PHASE",	0x04, 0x04 },
-	{ "MSG_IN_PHASE",	0x08, 0x08 },
-	{ "COMMAND_PHASE",	0x10, 0x10 },
-	{ "STATUS_PHASE",	0x20, 0x20 }
-};
-
-int
-ahd_scsiphase_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCSIPHASE_parse_table, 7, "SCSIPHASE",
-	    0x42, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scsidat0_img_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCSIDAT0_IMG",
-	    0x43, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scsidat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCSIDAT",
-	    0x44, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scsibus_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCSIBUS",
-	    0x46, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t TARGIDIN_parse_table[] = {
-	{ "TARGID",		0x0f, 0x0f },
-	{ "CLKOUT",		0x80, 0x80 }
-};
-
-int
-ahd_targidin_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(TARGIDIN_parse_table, 2, "TARGIDIN",
-	    0x48, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SELID_parse_table[] = {
-	{ "ONEBIT",		0x08, 0x08 },
-	{ "SELID_MASK",		0xf0, 0xf0 }
-};
-
-int
-ahd_selid_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SELID_parse_table, 2, "SELID",
-	    0x49, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SBLKCTL_parse_table[] = {
-	{ "SELWIDE",		0x02, 0x02 },
-	{ "ENAB20",		0x04, 0x04 },
-	{ "ENAB40",		0x08, 0x08 },
-	{ "DIAGLEDON",		0x40, 0x40 },
-	{ "DIAGLEDEN",		0x80, 0x80 }
-};
-
-int
-ahd_sblkctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SBLKCTL_parse_table, 5, "SBLKCTL",
-	    0x4a, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t OPTIONMODE_parse_table[] = {
-	{ "AUTO_MSGOUT_DE",	0x02, 0x02 },
-	{ "ENDGFORMCHK",	0x04, 0x04 },
-	{ "BUSFREEREV",		0x10, 0x10 },
-	{ "BIASCANCTL",		0x20, 0x20 },
-	{ "AUTOACKEN",		0x40, 0x40 },
-	{ "BIOSCANCTL",		0x80, 0x80 },
-	{ "OPTIONMODE_DEFAULTS",0x02, 0x02 }
-};
-
-int
-ahd_optionmode_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(OPTIONMODE_parse_table, 7, "OPTIONMODE",
-	    0x4a, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SSTAT0_parse_table[] = {
-	{ "ARBDO",		0x01, 0x01 },
-	{ "SPIORDY",		0x02, 0x02 },
-	{ "OVERRUN",		0x04, 0x04 },
-	{ "IOERR",		0x08, 0x08 },
-	{ "SELINGO",		0x10, 0x10 },
-	{ "SELDI",		0x20, 0x20 },
-	{ "SELDO",		0x40, 0x40 },
-	{ "TARGET",		0x80, 0x80 }
-};
-
-int
-ahd_sstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SSTAT0_parse_table, 8, "SSTAT0",
-	    0x4b, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CLRSINT0_parse_table[] = {
-	{ "CLRARBDO",		0x01, 0x01 },
-	{ "CLRSPIORDY",		0x02, 0x02 },
-	{ "CLROVERRUN",		0x04, 0x04 },
-	{ "CLRIOERR",		0x08, 0x08 },
-	{ "CLRSELINGO",		0x10, 0x10 },
-	{ "CLRSELDI",		0x20, 0x20 },
-	{ "CLRSELDO",		0x40, 0x40 }
-};
-
-int
-ahd_clrsint0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CLRSINT0_parse_table, 7, "CLRSINT0",
-	    0x4b, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SIMODE0_parse_table[] = {
-	{ "ENARBDO",		0x01, 0x01 },
-	{ "ENSPIORDY",		0x02, 0x02 },
-	{ "ENOVERRUN",		0x04, 0x04 },
-	{ "ENIOERR",		0x08, 0x08 },
-	{ "ENSELINGO",		0x10, 0x10 },
-	{ "ENSELDI",		0x20, 0x20 },
-	{ "ENSELDO",		0x40, 0x40 }
-};
-
-int
-ahd_simode0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SIMODE0_parse_table, 7, "SIMODE0",
-	    0x4b, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CLRSINT1_parse_table[] = {
-	{ "CLRREQINIT",		0x01, 0x01 },
-	{ "CLRSTRB2FAST",	0x02, 0x02 },
-	{ "CLRSCSIPERR",	0x04, 0x04 },
-	{ "CLRBUSFREE",		0x08, 0x08 },
-	{ "CLRSCSIRSTI",	0x20, 0x20 },
-	{ "CLRATNO",		0x40, 0x40 },
-	{ "CLRSELTIMEO",	0x80, 0x80 }
-};
-
-int
-ahd_clrsint1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CLRSINT1_parse_table, 7, "CLRSINT1",
-	    0x4c, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SSTAT1_parse_table[] = {
-	{ "REQINIT",		0x01, 0x01 },
-	{ "STRB2FAST",		0x02, 0x02 },
-	{ "SCSIPERR",		0x04, 0x04 },
-	{ "BUSFREE",		0x08, 0x08 },
-	{ "PHASEMIS",		0x10, 0x10 },
-	{ "SCSIRSTI",		0x20, 0x20 },
-	{ "ATNTARG",		0x40, 0x40 },
-	{ "SELTO",		0x80, 0x80 }
-};
-
-int
-ahd_sstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SSTAT1_parse_table, 8, "SSTAT1",
-	    0x4c, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SSTAT2_parse_table[] = {
-	{ "BUSFREE_LQO",	0x40, 0xc0 },
-	{ "BUSFREE_DFF0",	0x80, 0xc0 },
-	{ "BUSFREE_DFF1",	0xc0, 0xc0 },
-	{ "DMADONE",		0x01, 0x01 },
-	{ "SDONE",		0x02, 0x02 },
-	{ "WIDE_RES",		0x04, 0x04 },
-	{ "BSYX",		0x08, 0x08 },
-	{ "EXP_ACTIVE",		0x10, 0x10 },
-	{ "NONPACKREQ",		0x20, 0x20 },
-	{ "BUSFREETIME",	0xc0, 0xc0 }
-};
-
-int
-ahd_sstat2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SSTAT2_parse_table, 10, "SSTAT2",
-	    0x4d, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CLRSINT2_parse_table[] = {
-	{ "CLRDMADONE",		0x01, 0x01 },
-	{ "CLRSDONE",		0x02, 0x02 },
-	{ "CLRWIDE_RES",	0x04, 0x04 },
-	{ "CLRNONPACKREQ",	0x20, 0x20 }
-};
-
-int
-ahd_clrsint2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CLRSINT2_parse_table, 4, "CLRSINT2",
-	    0x4d, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SIMODE2_parse_table[] = {
-	{ "ENDMADONE",		0x01, 0x01 },
-	{ "ENSDONE",		0x02, 0x02 },
-	{ "ENWIDE_RES",		0x04, 0x04 }
-};
-
-int
-ahd_simode2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SIMODE2_parse_table, 3, "SIMODE2",
-	    0x4d, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t PERRDIAG_parse_table[] = {
-	{ "DTERR",		0x01, 0x01 },
-	{ "DGFORMERR",		0x02, 0x02 },
-	{ "CRCERR",		0x04, 0x04 },
-	{ "AIPERR",		0x08, 0x08 },
-	{ "PARITYERR",		0x10, 0x10 },
-	{ "PREVPHASE",		0x20, 0x20 },
-	{ "HIPERR",		0x40, 0x40 },
-	{ "HIZERO",		0x80, 0x80 }
-};
-
-int
-ahd_perrdiag_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(PERRDIAG_parse_table, 8, "PERRDIAG",
-	    0x4e, regvalue, cur_col, wrap));
-}
-
-int
-ahd_lqistate_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "LQISTATE",
-	    0x4e, regvalue, cur_col, wrap));
-}
-
-int
-ahd_soffcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SOFFCNT",
-	    0x4f, regvalue, cur_col, wrap));
-}
-
-int
-ahd_lqostate_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "LQOSTATE",
-	    0x4f, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t LQISTAT0_parse_table[] = {
-	{ "LQIATNCMD",		0x01, 0x01 },
-	{ "LQIATNLQ",		0x02, 0x02 },
-	{ "LQIBADLQT",		0x04, 0x04 },
-	{ "LQICRCT2",		0x08, 0x08 },
-	{ "LQICRCT1",		0x10, 0x10 },
-	{ "LQIATNQAS",		0x20, 0x20 }
-};
-
-int
-ahd_lqistat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQISTAT0_parse_table, 6, "LQISTAT0",
-	    0x50, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CLRLQIINT0_parse_table[] = {
-	{ "CLRLQIATNCMD",	0x01, 0x01 },
-	{ "CLRLQIATNLQ",	0x02, 0x02 },
-	{ "CLRLQIBADLQT",	0x04, 0x04 },
-	{ "CLRLQICRCT2",	0x08, 0x08 },
-	{ "CLRLQICRCT1",	0x10, 0x10 },
-	{ "CLRLQIATNQAS",	0x20, 0x20 }
-};
-
-int
-ahd_clrlqiint0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CLRLQIINT0_parse_table, 6, "CLRLQIINT0",
-	    0x50, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t LQIMODE0_parse_table[] = {
-	{ "ENLQIATNCMD",	0x01, 0x01 },
-	{ "ENLQIATNLQ",		0x02, 0x02 },
-	{ "ENLQIBADLQT",	0x04, 0x04 },
-	{ "ENLQICRCT2",		0x08, 0x08 },
-	{ "ENLQICRCT1",		0x10, 0x10 },
-	{ "ENLQIATNQASK",	0x20, 0x20 }
-};
-
-int
-ahd_lqimode0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQIMODE0_parse_table, 6, "LQIMODE0",
-	    0x50, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t LQIMODE1_parse_table[] = {
-	{ "ENLQIOVERI_NLQ",	0x01, 0x01 },
-	{ "ENLQIOVERI_LQ",	0x02, 0x02 },
-	{ "ENLQIBADLQI",	0x04, 0x04 },
-	{ "ENLQICRCI_NLQ",	0x08, 0x08 },
-	{ "ENLQICRCI_LQ",	0x10, 0x10 },
-	{ "ENLIQABORT",		0x20, 0x20 },
-	{ "ENLQIPHASE_NLQ",	0x40, 0x40 },
-	{ "ENLQIPHASE_LQ",	0x80, 0x80 }
-};
-
-int
-ahd_lqimode1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQIMODE1_parse_table, 8, "LQIMODE1",
-	    0x51, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t LQISTAT1_parse_table[] = {
-	{ "LQIOVERI_NLQ",	0x01, 0x01 },
-	{ "LQIOVERI_LQ",	0x02, 0x02 },
-	{ "LQIBADLQI",		0x04, 0x04 },
-	{ "LQICRCI_NLQ",	0x08, 0x08 },
-	{ "LQICRCI_LQ",		0x10, 0x10 },
-	{ "LQIABORT",		0x20, 0x20 },
-	{ "LQIPHASE_NLQ",	0x40, 0x40 },
-	{ "LQIPHASE_LQ",	0x80, 0x80 }
-};
-
-int
-ahd_lqistat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQISTAT1_parse_table, 8, "LQISTAT1",
-	    0x51, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CLRLQIINT1_parse_table[] = {
-	{ "CLRLQIOVERI_NLQ",	0x01, 0x01 },
-	{ "CLRLQIOVERI_LQ",	0x02, 0x02 },
-	{ "CLRLQIBADLQI",	0x04, 0x04 },
-	{ "CLRLQICRCI_NLQ",	0x08, 0x08 },
-	{ "CLRLQICRCI_LQ",	0x10, 0x10 },
-	{ "CLRLIQABORT",	0x20, 0x20 },
-	{ "CLRLQIPHASE_NLQ",	0x40, 0x40 },
-	{ "CLRLQIPHASE_LQ",	0x80, 0x80 }
-};
-
-int
-ahd_clrlqiint1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CLRLQIINT1_parse_table, 8, "CLRLQIINT1",
-	    0x51, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t LQISTAT2_parse_table[] = {
-	{ "LQIGSAVAIL",		0x01, 0x01 },
-	{ "LQISTOPCMD",		0x02, 0x02 },
-	{ "LQISTOPLQ",		0x04, 0x04 },
-	{ "LQISTOPPKT",		0x08, 0x08 },
-	{ "LQIWAITFIFO",	0x10, 0x10 },
-	{ "LQIWORKONLQ",	0x20, 0x20 },
-	{ "LQIPHASE_OUTPKT",	0x40, 0x40 },
-	{ "PACKETIZED",		0x80, 0x80 }
-};
-
-int
-ahd_lqistat2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQISTAT2_parse_table, 8, "LQISTAT2",
-	    0x52, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SSTAT3_parse_table[] = {
-	{ "OSRAMPERR",		0x01, 0x01 },
-	{ "NTRAMPERR",		0x02, 0x02 }
-};
-
-int
-ahd_sstat3_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SSTAT3_parse_table, 2, "SSTAT3",
-	    0x53, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SIMODE3_parse_table[] = {
-	{ "ENOSRAMPERR",	0x01, 0x01 },
-	{ "ENNTRAMPERR",	0x02, 0x02 }
-};
-
-int
-ahd_simode3_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SIMODE3_parse_table, 2, "SIMODE3",
-	    0x53, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CLRSINT3_parse_table[] = {
-	{ "CLROSRAMPERR",	0x01, 0x01 },
-	{ "CLRNTRAMPERR",	0x02, 0x02 }
-};
-
-int
-ahd_clrsint3_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CLRSINT3_parse_table, 2, "CLRSINT3",
-	    0x53, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t LQOMODE0_parse_table[] = {
-	{ "ENLQOTCRC",		0x01, 0x01 },
-	{ "ENLQOATNPKT",	0x02, 0x02 },
-	{ "ENLQOATNLQ",		0x04, 0x04 },
-	{ "ENLQOSTOPT2",	0x08, 0x08 },
-	{ "ENLQOTARGSCBPERR",	0x10, 0x10 }
-};
-
-int
-ahd_lqomode0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQOMODE0_parse_table, 5, "LQOMODE0",
-	    0x54, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t LQOSTAT0_parse_table[] = {
-	{ "LQOTCRC",		0x01, 0x01 },
-	{ "LQOATNPKT",		0x02, 0x02 },
-	{ "LQOATNLQ",		0x04, 0x04 },
-	{ "LQOSTOPT2",		0x08, 0x08 },
-	{ "LQOTARGSCBPERR",	0x10, 0x10 }
-};
-
-int
-ahd_lqostat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQOSTAT0_parse_table, 5, "LQOSTAT0",
-	    0x54, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CLRLQOINT0_parse_table[] = {
-	{ "CLRLQOTCRC",		0x01, 0x01 },
-	{ "CLRLQOATNPKT",	0x02, 0x02 },
-	{ "CLRLQOATNLQ",	0x04, 0x04 },
-	{ "CLRLQOSTOPT2",	0x08, 0x08 },
-	{ "CLRLQOTARGSCBPERR",	0x10, 0x10 }
-};
-
-int
-ahd_clrlqoint0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CLRLQOINT0_parse_table, 5, "CLRLQOINT0",
-	    0x54, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t LQOSTAT1_parse_table[] = {
-	{ "LQOPHACHGINPKT",	0x01, 0x01 },
-	{ "LQOBUSFREE",		0x02, 0x02 },
-	{ "LQOBADQAS",		0x04, 0x04 },
-	{ "LQOSTOPI2",		0x08, 0x08 },
-	{ "LQOINITSCBPERR",	0x10, 0x10 }
-};
-
-int
-ahd_lqostat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQOSTAT1_parse_table, 5, "LQOSTAT1",
-	    0x55, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CLRLQOINT1_parse_table[] = {
-	{ "CLRLQOPHACHGINPKT",	0x01, 0x01 },
-	{ "CLRLQOBUSFREE",	0x02, 0x02 },
-	{ "CLRLQOBADQAS",	0x04, 0x04 },
-	{ "CLRLQOSTOPI2",	0x08, 0x08 },
-	{ "CLRLQOINITSCBPERR",	0x10, 0x10 }
-};
-
-int
-ahd_clrlqoint1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CLRLQOINT1_parse_table, 5, "CLRLQOINT1",
-	    0x55, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t LQOMODE1_parse_table[] = {
-	{ "ENLQOPHACHGINPKT",	0x01, 0x01 },
-	{ "ENLQOBUSFREE",	0x02, 0x02 },
-	{ "ENLQOBADQAS",	0x04, 0x04 },
-	{ "ENLQOSTOPI2",	0x08, 0x08 },
-	{ "ENLQOINITSCBPERR",	0x10, 0x10 }
-};
-
-int
-ahd_lqomode1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQOMODE1_parse_table, 5, "LQOMODE1",
-	    0x55, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t LQOSTAT2_parse_table[] = {
-	{ "LQOSTOP0",		0x01, 0x01 },
-	{ "LQOPHACHGOUTPKT",	0x02, 0x02 },
-	{ "LQOWAITFIFO",	0x10, 0x10 },
-	{ "LQOPKT",		0xe0, 0xe0 }
-};
-
-int
-ahd_lqostat2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQOSTAT2_parse_table, 4, "LQOSTAT2",
-	    0x56, regvalue, cur_col, wrap));
-}
-
-int
-ahd_os_space_cnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "OS_SPACE_CNT",
-	    0x56, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SIMODE1_parse_table[] = {
-	{ "ENREQINIT",		0x01, 0x01 },
-	{ "ENSTRB2FAST",	0x02, 0x02 },
-	{ "ENSCSIPERR",		0x04, 0x04 },
-	{ "ENBUSFREE",		0x08, 0x08 },
-	{ "ENPHASEMIS",		0x10, 0x10 },
-	{ "ENSCSIRST",		0x20, 0x20 },
-	{ "ENATNTARG",		0x40, 0x40 },
-	{ "ENSELTIMO",		0x80, 0x80 }
-};
-
-int
-ahd_simode1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SIMODE1_parse_table, 8, "SIMODE1",
-	    0x57, regvalue, cur_col, wrap));
-}
-
-int
-ahd_gsfifo_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "GSFIFO",
-	    0x58, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DFFSXFRCTL_parse_table[] = {
-	{ "RSTCHN",		0x01, 0x01 },
-	{ "CLRCHN",		0x02, 0x02 },
-	{ "CLRSHCNT",		0x04, 0x04 },
-	{ "DFFBITBUCKET",	0x08, 0x08 }
-};
-
-int
-ahd_dffsxfrctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DFFSXFRCTL_parse_table, 4, "DFFSXFRCTL",
-	    0x5a, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t LQOSCSCTL_parse_table[] = {
-	{ "LQONOCHKOVER",	0x01, 0x01 },
-	{ "LQOH2A_VERSION",	0x80, 0x80 }
-};
-
-int
-ahd_lqoscsctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LQOSCSCTL_parse_table, 2, "LQOSCSCTL",
-	    0x5a, regvalue, cur_col, wrap));
-}
-
-int
-ahd_nextscb_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "NEXTSCB",
-	    0x5a, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CLRSEQINTSRC_parse_table[] = {
-	{ "CLRCFG4TCMD",	0x01, 0x01 },
-	{ "CLRCFG4ICMD",	0x02, 0x02 },
-	{ "CLRCFG4TSTAT",	0x04, 0x04 },
-	{ "CLRCFG4ISTAT",	0x08, 0x08 },
-	{ "CLRCFG4DATA",	0x10, 0x10 },
-	{ "CLRSAVEPTRS",	0x20, 0x20 },
-	{ "CLRCTXTDONE",	0x40, 0x40 }
-};
-
-int
-ahd_clrseqintsrc_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CLRSEQINTSRC_parse_table, 7, "CLRSEQINTSRC",
-	    0x5b, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SEQINTSRC_parse_table[] = {
-	{ "CFG4TCMD",		0x01, 0x01 },
-	{ "CFG4ICMD",		0x02, 0x02 },
-	{ "CFG4TSTAT",		0x04, 0x04 },
-	{ "CFG4ISTAT",		0x08, 0x08 },
-	{ "CFG4DATA",		0x10, 0x10 },
-	{ "SAVEPTRS",		0x20, 0x20 },
-	{ "CTXTDONE",		0x40, 0x40 }
-};
-
-int
-ahd_seqintsrc_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SEQINTSRC_parse_table, 7, "SEQINTSRC",
-	    0x5b, regvalue, cur_col, wrap));
-}
-
-int
-ahd_currscb_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "CURRSCB",
-	    0x5c, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SEQIMODE_parse_table[] = {
-	{ "ENCFG4TCMD",		0x01, 0x01 },
-	{ "ENCFG4ICMD",		0x02, 0x02 },
-	{ "ENCFG4TSTAT",	0x04, 0x04 },
-	{ "ENCFG4ISTAT",	0x08, 0x08 },
-	{ "ENCFG4DATA",		0x10, 0x10 },
-	{ "ENSAVEPTRS",		0x20, 0x20 },
-	{ "ENCTXTDONE",		0x40, 0x40 }
-};
-
-int
-ahd_seqimode_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SEQIMODE_parse_table, 7, "SEQIMODE",
-	    0x5c, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t MDFFSTAT_parse_table[] = {
-	{ "FIFOFREE",		0x01, 0x01 },
-	{ "DATAINFIFO",		0x02, 0x02 },
-	{ "DLZERO",		0x04, 0x04 },
-	{ "SHVALID",		0x08, 0x08 },
-	{ "LASTSDONE",		0x10, 0x10 },
-	{ "SHCNTMINUS1",	0x20, 0x20 },
-	{ "SHCNTNEGATIVE",	0x40, 0x40 }
-};
-
-int
-ahd_mdffstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(MDFFSTAT_parse_table, 7, "MDFFSTAT",
-	    0x5d, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CRCCONTROL_parse_table[] = {
-	{ "CRCVALCHKEN",	0x40, 0x40 }
-};
-
-int
-ahd_crccontrol_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CRCCONTROL_parse_table, 1, "CRCCONTROL",
-	    0x5d, regvalue, cur_col, wrap));
-}
-
-int
-ahd_dfftag_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "DFFTAG",
-	    0x5e, regvalue, cur_col, wrap));
-}
-
-int
-ahd_lastscb_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "LASTSCB",
-	    0x5e, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCSITEST_parse_table[] = {
-	{ "SEL_TXPLL_DEBUG",	0x04, 0x04 },
-	{ "CNTRTEST",		0x08, 0x08 }
-};
-
-int
-ahd_scsitest_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCSITEST_parse_table, 2, "SCSITEST",
-	    0x5e, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t IOPDNCTL_parse_table[] = {
-	{ "PDN_DIFFSENSE",	0x01, 0x01 },
-	{ "PDN_IDIST",		0x04, 0x04 },
-	{ "DISABLE_OE",		0x80, 0x80 }
-};
-
-int
-ahd_iopdnctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(IOPDNCTL_parse_table, 3, "IOPDNCTL",
-	    0x5f, regvalue, cur_col, wrap));
-}
-
-int
-ahd_shaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SHADDR",
-	    0x60, regvalue, cur_col, wrap));
-}
-
-int
-ahd_negoaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "NEGOADDR",
-	    0x60, regvalue, cur_col, wrap));
-}
-
-int
-ahd_dgrpcrci_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "DGRPCRCI",
-	    0x60, regvalue, cur_col, wrap));
-}
-
-int
-ahd_negperiod_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "NEGPERIOD",
-	    0x61, regvalue, cur_col, wrap));
-}
-
-int
-ahd_packcrci_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "PACKCRCI",
-	    0x62, regvalue, cur_col, wrap));
-}
-
-int
-ahd_negoffset_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "NEGOFFSET",
-	    0x62, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t NEGPPROPTS_parse_table[] = {
-	{ "PPROPT_IUT",		0x01, 0x01 },
-	{ "PPROPT_DT",		0x02, 0x02 },
-	{ "PPROPT_QAS",		0x04, 0x04 },
-	{ "PPROPT_PACE",	0x08, 0x08 }
-};
-
-int
-ahd_negppropts_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NEGPPROPTS_parse_table, 4, "NEGPPROPTS",
-	    0x63, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t NEGCONOPTS_parse_table[] = {
-	{ "WIDEXFER",		0x01, 0x01 },
-	{ "ENAUTOATNO",		0x02, 0x02 },
-	{ "ENAUTOATNI",		0x04, 0x04 },
-	{ "ENSLOWCRC",		0x08, 0x08 },
-	{ "RTI_OVRDTRN",	0x10, 0x10 },
-	{ "RTI_WRTDIS",		0x20, 0x20 },
-	{ "ENSNAPSHOT",		0x40, 0x40 }
-};
-
-int
-ahd_negconopts_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NEGCONOPTS_parse_table, 7, "NEGCONOPTS",
-	    0x64, regvalue, cur_col, wrap));
-}
-
-int
-ahd_annexcol_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "ANNEXCOL",
-	    0x65, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCSCHKN_parse_table[] = {
-	{ "LSTSGCLRDIS",	0x01, 0x01 },
-	{ "SHVALIDSTDIS",	0x02, 0x02 },
-	{ "DFFACTCLR",		0x04, 0x04 },
-	{ "SDONEMSKDIS",	0x08, 0x08 },
-	{ "WIDERESEN",		0x10, 0x10 },
-	{ "CURRFIFODEF",	0x20, 0x20 },
-	{ "STSELSKIDDIS",	0x40, 0x40 }
-};
-
-int
-ahd_scschkn_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCSCHKN_parse_table, 7, "SCSCHKN",
-	    0x66, regvalue, cur_col, wrap));
-}
-
-int
-ahd_annexdat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "ANNEXDAT",
-	    0x66, regvalue, cur_col, wrap));
-}
-
-int
-ahd_iownid_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "IOWNID",
-	    0x67, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t PLL960CTL0_parse_table[] = {
-	{ "PLL_ENFBM",		0x01, 0x01 },
-	{ "PLL_DLPF",		0x02, 0x02 },
-	{ "PLL_ENLPF",		0x04, 0x04 },
-	{ "PLL_ENLUD",		0x08, 0x08 },
-	{ "PLL_NS",		0x30, 0x30 },
-	{ "PLL_PWDN",		0x40, 0x40 },
-	{ "PLL_VCOSEL",		0x80, 0x80 }
-};
-
-int
-ahd_pll960ctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(PLL960CTL0_parse_table, 7, "PLL960CTL0",
-	    0x68, regvalue, cur_col, wrap));
-}
-
-int
-ahd_shcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SHCNT",
-	    0x68, regvalue, cur_col, wrap));
-}
-
-int
-ahd_townid_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "TOWNID",
-	    0x69, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t PLL960CTL1_parse_table[] = {
-	{ "PLL_RST",		0x01, 0x01 },
-	{ "PLL_CNTCLR",		0x40, 0x40 },
-	{ "PLL_CNTEN",		0x80, 0x80 }
-};
-
-int
-ahd_pll960ctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(PLL960CTL1_parse_table, 3, "PLL960CTL1",
-	    0x69, regvalue, cur_col, wrap));
-}
-
-int
-ahd_pll960cnt0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "PLL960CNT0",
-	    0x6a, regvalue, cur_col, wrap));
-}
-
-int
-ahd_xsig_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "XSIG",
-	    0x6a, regvalue, cur_col, wrap));
-}
-
-int
-ahd_seloid_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SELOID",
-	    0x6b, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t PLL400CTL0_parse_table[] = {
-	{ "PLL_ENFBM",		0x01, 0x01 },
-	{ "PLL_DLPF",		0x02, 0x02 },
-	{ "PLL_ENLPF",		0x04, 0x04 },
-	{ "PLL_ENLUD",		0x08, 0x08 },
-	{ "PLL_NS",		0x30, 0x30 },
-	{ "PLL_PWDN",		0x40, 0x40 },
-	{ "PLL_VCOSEL",		0x80, 0x80 }
-};
-
-int
-ahd_pll400ctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(PLL400CTL0_parse_table, 7, "PLL400CTL0",
-	    0x6c, regvalue, cur_col, wrap));
-}
-
-int
-ahd_fairness_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "FAIRNESS",
-	    0x6c, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t PLL400CTL1_parse_table[] = {
-	{ "PLL_RST",		0x01, 0x01 },
-	{ "PLL_CNTCLR",		0x40, 0x40 },
-	{ "PLL_CNTEN",		0x80, 0x80 }
-};
-
-int
-ahd_pll400ctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(PLL400CTL1_parse_table, 3, "PLL400CTL1",
-	    0x6d, regvalue, cur_col, wrap));
-}
-
-int
-ahd_pll400cnt0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "PLL400CNT0",
-	    0x6e, regvalue, cur_col, wrap));
-}
-
-int
-ahd_unfairness_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "UNFAIRNESS",
-	    0x6e, regvalue, cur_col, wrap));
-}
-
-int
-ahd_haddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "HADDR",
-	    0x70, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t PLLDELAY_parse_table[] = {
-	{ "SPLIT_DROP_REQ",	0x80, 0x80 }
-};
-
-int
-ahd_plldelay_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(PLLDELAY_parse_table, 1, "PLLDELAY",
-	    0x70, regvalue, cur_col, wrap));
-}
-
-int
-ahd_hodmaadr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "HODMAADR",
-	    0x70, regvalue, cur_col, wrap));
-}
-
-int
-ahd_hodmacnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "HODMACNT",
-	    0x78, regvalue, cur_col, wrap));
-}
-
-int
-ahd_hcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "HCNT",
-	    0x78, regvalue, cur_col, wrap));
-}
-
-int
-ahd_hodmaen_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "HODMAEN",
-	    0x7a, regvalue, cur_col, wrap));
-}
-
-int
-ahd_sghaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SGHADDR",
-	    0x7c, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scbhaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCBHADDR",
-	    0x7c, regvalue, cur_col, wrap));
-}
-
-int
-ahd_sghcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SGHCNT",
-	    0x84, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scbhcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCBHCNT",
-	    0x84, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DFF_THRSH_parse_table[] = {
-	{ "WR_DFTHRSH_MIN",	0x00, 0x70 },
-	{ "RD_DFTHRSH_MIN",	0x00, 0x07 },
-	{ "RD_DFTHRSH_25",	0x01, 0x07 },
-	{ "RD_DFTHRSH_50",	0x02, 0x07 },
-	{ "RD_DFTHRSH_63",	0x03, 0x07 },
-	{ "RD_DFTHRSH_75",	0x04, 0x07 },
-	{ "RD_DFTHRSH_85",	0x05, 0x07 },
-	{ "RD_DFTHRSH_90",	0x06, 0x07 },
-	{ "RD_DFTHRSH_MAX",	0x07, 0x07 },
-	{ "WR_DFTHRSH_25",	0x10, 0x70 },
-	{ "WR_DFTHRSH_50",	0x20, 0x70 },
-	{ "WR_DFTHRSH_63",	0x30, 0x70 },
-	{ "WR_DFTHRSH_75",	0x40, 0x70 },
-	{ "WR_DFTHRSH_85",	0x50, 0x70 },
-	{ "WR_DFTHRSH_90",	0x60, 0x70 },
-	{ "WR_DFTHRSH_MAX",	0x70, 0x70 },
-	{ "RD_DFTHRSH",		0x07, 0x07 },
-	{ "WR_DFTHRSH",		0x70, 0x70 }
-};
-
-int
-ahd_dff_thrsh_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DFF_THRSH_parse_table, 18, "DFF_THRSH",
-	    0x88, regvalue, cur_col, wrap));
-}
-
-int
-ahd_romaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "ROMADDR",
-	    0x8a, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t ROMCNTRL_parse_table[] = {
-	{ "RDY",		0x01, 0x01 },
-	{ "REPEAT",		0x02, 0x02 },
-	{ "ROMSPD",		0x18, 0x18 },
-	{ "ROMOP",		0xe0, 0xe0 }
-};
-
-int
-ahd_romcntrl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(ROMCNTRL_parse_table, 4, "ROMCNTRL",
-	    0x8d, regvalue, cur_col, wrap));
-}
-
-int
-ahd_romdata_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "ROMDATA",
-	    0x8e, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CMCRXMSG0_parse_table[] = {
-	{ "CFNUM",		0x07, 0x07 },
-	{ "CDNUM",		0xf8, 0xf8 }
-};
-
-int
-ahd_cmcrxmsg0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CMCRXMSG0_parse_table, 2, "CMCRXMSG0",
-	    0x90, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t ROENABLE_parse_table[] = {
-	{ "DCH0ROEN",		0x01, 0x01 },
-	{ "DCH1ROEN",		0x02, 0x02 },
-	{ "SGROEN",		0x04, 0x04 },
-	{ "CMCROEN",		0x08, 0x08 },
-	{ "OVLYROEN",		0x10, 0x10 },
-	{ "MSIROEN",		0x20, 0x20 }
-};
-
-int
-ahd_roenable_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(ROENABLE_parse_table, 6, "ROENABLE",
-	    0x90, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t OVLYRXMSG0_parse_table[] = {
-	{ "CFNUM",		0x07, 0x07 },
-	{ "CDNUM",		0xf8, 0xf8 }
-};
-
-int
-ahd_ovlyrxmsg0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(OVLYRXMSG0_parse_table, 2, "OVLYRXMSG0",
-	    0x90, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DCHRXMSG0_parse_table[] = {
-	{ "CFNUM",		0x07, 0x07 },
-	{ "CDNUM",		0xf8, 0xf8 }
-};
-
-int
-ahd_dchrxmsg0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DCHRXMSG0_parse_table, 2, "DCHRXMSG0",
-	    0x90, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t OVLYRXMSG1_parse_table[] = {
-	{ "CBNUM",		0xff, 0xff }
-};
-
-int
-ahd_ovlyrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(OVLYRXMSG1_parse_table, 1, "OVLYRXMSG1",
-	    0x91, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t NSENABLE_parse_table[] = {
-	{ "DCH0NSEN",		0x01, 0x01 },
-	{ "DCH1NSEN",		0x02, 0x02 },
-	{ "SGNSEN",		0x04, 0x04 },
-	{ "CMCNSEN",		0x08, 0x08 },
-	{ "OVLYNSEN",		0x10, 0x10 },
-	{ "MSINSEN",		0x20, 0x20 }
-};
-
-int
-ahd_nsenable_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NSENABLE_parse_table, 6, "NSENABLE",
-	    0x91, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DCHRXMSG1_parse_table[] = {
-	{ "CBNUM",		0xff, 0xff }
-};
-
-int
-ahd_dchrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DCHRXMSG1_parse_table, 1, "DCHRXMSG1",
-	    0x91, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CMCRXMSG1_parse_table[] = {
-	{ "CBNUM",		0xff, 0xff }
-};
-
-int
-ahd_cmcrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CMCRXMSG1_parse_table, 1, "CMCRXMSG1",
-	    0x91, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DCHRXMSG2_parse_table[] = {
-	{ "MINDEX",		0xff, 0xff }
-};
-
-int
-ahd_dchrxmsg2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DCHRXMSG2_parse_table, 1, "DCHRXMSG2",
-	    0x92, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t OVLYRXMSG2_parse_table[] = {
-	{ "MINDEX",		0xff, 0xff }
-};
-
-int
-ahd_ovlyrxmsg2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(OVLYRXMSG2_parse_table, 1, "OVLYRXMSG2",
-	    0x92, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CMCRXMSG2_parse_table[] = {
-	{ "MINDEX",		0xff, 0xff }
-};
-
-int
-ahd_cmcrxmsg2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CMCRXMSG2_parse_table, 1, "CMCRXMSG2",
-	    0x92, regvalue, cur_col, wrap));
-}
-
-int
-ahd_ost_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "OST",
-	    0x92, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DCHRXMSG3_parse_table[] = {
-	{ "MCLASS",		0x0f, 0x0f }
-};
-
-int
-ahd_dchrxmsg3_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DCHRXMSG3_parse_table, 1, "DCHRXMSG3",
-	    0x93, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CMCRXMSG3_parse_table[] = {
-	{ "MCLASS",		0x0f, 0x0f }
-};
-
-int
-ahd_cmcrxmsg3_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CMCRXMSG3_parse_table, 1, "CMCRXMSG3",
-	    0x93, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t PCIXCTL_parse_table[] = {
-	{ "CMPABCDIS",		0x01, 0x01 },
-	{ "TSCSERREN",		0x02, 0x02 },
-	{ "SRSPDPEEN",		0x04, 0x04 },
-	{ "SPLTSTADIS",		0x08, 0x08 },
-	{ "SPLTSMADIS",		0x10, 0x10 },
-	{ "UNEXPSCIEN",		0x20, 0x20 },
-	{ "SERRPULSE",		0x80, 0x80 }
-};
-
-int
-ahd_pcixctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(PCIXCTL_parse_table, 7, "PCIXCTL",
-	    0x93, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t OVLYRXMSG3_parse_table[] = {
-	{ "MCLASS",		0x0f, 0x0f }
-};
-
-int
-ahd_ovlyrxmsg3_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(OVLYRXMSG3_parse_table, 1, "OVLYRXMSG3",
-	    0x93, regvalue, cur_col, wrap));
-}
-
-int
-ahd_ovlyseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "OVLYSEQBCNT",
-	    0x94, regvalue, cur_col, wrap));
-}
-
-int
-ahd_cmcseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "CMCSEQBCNT",
-	    0x94, regvalue, cur_col, wrap));
-}
-
-int
-ahd_dchseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "DCHSEQBCNT",
-	    0x94, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CMCSPLTSTAT0_parse_table[] = {
-	{ "RXSPLTRSP",		0x01, 0x01 },
-	{ "RXSCEMSG",		0x02, 0x02 },
-	{ "RXOVRUN",		0x04, 0x04 },
-	{ "CNTNOTCMPLT",	0x08, 0x08 },
-	{ "SCDATBUCKET",	0x10, 0x10 },
-	{ "SCADERR",		0x20, 0x20 },
-	{ "SCBCERR",		0x40, 0x40 },
-	{ "STAETERM",		0x80, 0x80 }
-};
-
-int
-ahd_cmcspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CMCSPLTSTAT0_parse_table, 8, "CMCSPLTSTAT0",
-	    0x96, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t OVLYSPLTSTAT0_parse_table[] = {
-	{ "RXSPLTRSP",		0x01, 0x01 },
-	{ "RXSCEMSG",		0x02, 0x02 },
-	{ "RXOVRUN",		0x04, 0x04 },
-	{ "CNTNOTCMPLT",	0x08, 0x08 },
-	{ "SCDATBUCKET",	0x10, 0x10 },
-	{ "SCADERR",		0x20, 0x20 },
-	{ "SCBCERR",		0x40, 0x40 },
-	{ "STAETERM",		0x80, 0x80 }
-};
-
-int
-ahd_ovlyspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(OVLYSPLTSTAT0_parse_table, 8, "OVLYSPLTSTAT0",
-	    0x96, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DCHSPLTSTAT0_parse_table[] = {
-	{ "RXSPLTRSP",		0x01, 0x01 },
-	{ "RXSCEMSG",		0x02, 0x02 },
-	{ "RXOVRUN",		0x04, 0x04 },
-	{ "CNTNOTCMPLT",	0x08, 0x08 },
-	{ "SCDATBUCKET",	0x10, 0x10 },
-	{ "SCADERR",		0x20, 0x20 },
-	{ "SCBCERR",		0x40, 0x40 },
-	{ "STAETERM",		0x80, 0x80 }
-};
-
-int
-ahd_dchspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DCHSPLTSTAT0_parse_table, 8, "DCHSPLTSTAT0",
-	    0x96, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DCHSPLTSTAT1_parse_table[] = {
-	{ "RXDATABUCKET",	0x01, 0x01 }
-};
-
-int
-ahd_dchspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DCHSPLTSTAT1_parse_table, 1, "DCHSPLTSTAT1",
-	    0x97, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CMCSPLTSTAT1_parse_table[] = {
-	{ "RXDATABUCKET",	0x01, 0x01 }
-};
-
-int
-ahd_cmcspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CMCSPLTSTAT1_parse_table, 1, "CMCSPLTSTAT1",
-	    0x97, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t OVLYSPLTSTAT1_parse_table[] = {
-	{ "RXDATABUCKET",	0x01, 0x01 }
-};
-
-int
-ahd_ovlyspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(OVLYSPLTSTAT1_parse_table, 1, "OVLYSPLTSTAT1",
-	    0x97, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SGRXMSG0_parse_table[] = {
-	{ "CFNUM",		0x07, 0x07 },
-	{ "CDNUM",		0xf8, 0xf8 }
-};
-
-int
-ahd_sgrxmsg0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SGRXMSG0_parse_table, 2, "SGRXMSG0",
-	    0x98, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SLVSPLTOUTADR0_parse_table[] = {
-	{ "LOWER_ADDR",		0x7f, 0x7f }
-};
-
-int
-ahd_slvspltoutadr0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SLVSPLTOUTADR0_parse_table, 1, "SLVSPLTOUTADR0",
-	    0x98, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SGRXMSG1_parse_table[] = {
-	{ "CBNUM",		0xff, 0xff }
-};
-
-int
-ahd_sgrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SGRXMSG1_parse_table, 1, "SGRXMSG1",
-	    0x99, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SLVSPLTOUTADR1_parse_table[] = {
-	{ "REQ_FNUM",		0x07, 0x07 },
-	{ "REQ_DNUM",		0xf8, 0xf8 }
-};
-
-int
-ahd_slvspltoutadr1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SLVSPLTOUTADR1_parse_table, 2, "SLVSPLTOUTADR1",
-	    0x99, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SGRXMSG2_parse_table[] = {
-	{ "MINDEX",		0xff, 0xff }
-};
-
-int
-ahd_sgrxmsg2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SGRXMSG2_parse_table, 1, "SGRXMSG2",
-	    0x9a, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SLVSPLTOUTADR2_parse_table[] = {
-	{ "REQ_BNUM",		0xff, 0xff }
-};
-
-int
-ahd_slvspltoutadr2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SLVSPLTOUTADR2_parse_table, 1, "SLVSPLTOUTADR2",
-	    0x9a, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SGRXMSG3_parse_table[] = {
-	{ "MCLASS",		0x0f, 0x0f }
-};
-
-int
-ahd_sgrxmsg3_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SGRXMSG3_parse_table, 1, "SGRXMSG3",
-	    0x9b, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SLVSPLTOUTADR3_parse_table[] = {
-	{ "RLXORD",		0x10, 0x10 },
-	{ "TAG_NUM",		0x1f, 0x1f }
-};
-
-int
-ahd_slvspltoutadr3_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SLVSPLTOUTADR3_parse_table, 2, "SLVSPLTOUTADR3",
-	    0x9b, regvalue, cur_col, wrap));
-}
-
-int
-ahd_sgseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SGSEQBCNT",
-	    0x9c, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SLVSPLTOUTATTR0_parse_table[] = {
-	{ "LOWER_BCNT",		0xff, 0xff }
-};
-
-int
-ahd_slvspltoutattr0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SLVSPLTOUTATTR0_parse_table, 1, "SLVSPLTOUTATTR0",
-	    0x9c, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SLVSPLTOUTATTR1_parse_table[] = {
-	{ "CMPLT_FNUM",		0x07, 0x07 },
-	{ "CMPLT_DNUM",		0xf8, 0xf8 }
-};
-
-int
-ahd_slvspltoutattr1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SLVSPLTOUTATTR1_parse_table, 2, "SLVSPLTOUTATTR1",
-	    0x9d, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SLVSPLTOUTATTR2_parse_table[] = {
-	{ "CMPLT_BNUM",		0xff, 0xff }
-};
-
-int
-ahd_slvspltoutattr2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SLVSPLTOUTATTR2_parse_table, 1, "SLVSPLTOUTATTR2",
-	    0x9e, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SGSPLTSTAT0_parse_table[] = {
-	{ "RXSPLTRSP",		0x01, 0x01 },
-	{ "RXSCEMSG",		0x02, 0x02 },
-	{ "RXOVRUN",		0x04, 0x04 },
-	{ "CNTNOTCMPLT",	0x08, 0x08 },
-	{ "SCDATBUCKET",	0x10, 0x10 },
-	{ "SCADERR",		0x20, 0x20 },
-	{ "SCBCERR",		0x40, 0x40 },
-	{ "STAETERM",		0x80, 0x80 }
-};
-
-int
-ahd_sgspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SGSPLTSTAT0_parse_table, 8, "SGSPLTSTAT0",
-	    0x9e, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SFUNCT_parse_table[] = {
-	{ "TEST_NUM",		0x0f, 0x0f },
-	{ "TEST_GROUP",		0xf0, 0xf0 }
-};
-
-int
-ahd_sfunct_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SFUNCT_parse_table, 2, "SFUNCT",
-	    0x9f, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SGSPLTSTAT1_parse_table[] = {
-	{ "RXDATABUCKET",	0x01, 0x01 }
-};
-
-int
-ahd_sgspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SGSPLTSTAT1_parse_table, 1, "SGSPLTSTAT1",
-	    0x9f, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DF0PCISTAT_parse_table[] = {
-	{ "DPR",		0x01, 0x01 },
-	{ "TWATERR",		0x02, 0x02 },
-	{ "RDPERR",		0x04, 0x04 },
-	{ "SCAAPERR",		0x08, 0x08 },
-	{ "RTA",		0x10, 0x10 },
-	{ "RMA",		0x20, 0x20 },
-	{ "SSE",		0x40, 0x40 },
-	{ "DPE",		0x80, 0x80 }
-};
-
-int
-ahd_df0pcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DF0PCISTAT_parse_table, 8, "DF0PCISTAT",
-	    0xa0, regvalue, cur_col, wrap));
-}
-
-int
-ahd_reg0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "REG0",
-	    0xa0, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DF1PCISTAT_parse_table[] = {
-	{ "DPR",		0x01, 0x01 },
-	{ "TWATERR",		0x02, 0x02 },
-	{ "RDPERR",		0x04, 0x04 },
-	{ "SCAAPERR",		0x08, 0x08 },
-	{ "RTA",		0x10, 0x10 },
-	{ "RMA",		0x20, 0x20 },
-	{ "SSE",		0x40, 0x40 },
-	{ "DPE",		0x80, 0x80 }
-};
-
-int
-ahd_df1pcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DF1PCISTAT_parse_table, 8, "DF1PCISTAT",
-	    0xa1, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SGPCISTAT_parse_table[] = {
-	{ "DPR",		0x01, 0x01 },
-	{ "RDPERR",		0x04, 0x04 },
-	{ "SCAAPERR",		0x08, 0x08 },
-	{ "RTA",		0x10, 0x10 },
-	{ "RMA",		0x20, 0x20 },
-	{ "SSE",		0x40, 0x40 },
-	{ "DPE",		0x80, 0x80 }
-};
-
-int
-ahd_sgpcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SGPCISTAT_parse_table, 7, "SGPCISTAT",
-	    0xa2, regvalue, cur_col, wrap));
-}
-
-int
-ahd_reg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "REG1",
-	    0xa2, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CMCPCISTAT_parse_table[] = {
-	{ "DPR",		0x01, 0x01 },
-	{ "TWATERR",		0x02, 0x02 },
-	{ "RDPERR",		0x04, 0x04 },
-	{ "SCAAPERR",		0x08, 0x08 },
-	{ "RTA",		0x10, 0x10 },
-	{ "RMA",		0x20, 0x20 },
-	{ "SSE",		0x40, 0x40 },
-	{ "DPE",		0x80, 0x80 }
-};
-
-int
-ahd_cmcpcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CMCPCISTAT_parse_table, 8, "CMCPCISTAT",
-	    0xa3, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t OVLYPCISTAT_parse_table[] = {
-	{ "DPR",		0x01, 0x01 },
-	{ "RDPERR",		0x04, 0x04 },
-	{ "SCAAPERR",		0x08, 0x08 },
-	{ "RTA",		0x10, 0x10 },
-	{ "RMA",		0x20, 0x20 },
-	{ "SSE",		0x40, 0x40 },
-	{ "DPE",		0x80, 0x80 }
-};
-
-int
-ahd_ovlypcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(OVLYPCISTAT_parse_table, 7, "OVLYPCISTAT",
-	    0xa4, regvalue, cur_col, wrap));
-}
-
-int
-ahd_reg_isr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "REG_ISR",
-	    0xa4, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SG_STATE_parse_table[] = {
-	{ "SEGS_AVAIL",		0x01, 0x01 },
-	{ "LOADING_NEEDED",	0x02, 0x02 },
-	{ "FETCH_INPROG",	0x04, 0x04 }
-};
-
-int
-ahd_sg_state_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SG_STATE_parse_table, 3, "SG_STATE",
-	    0xa6, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t MSIPCISTAT_parse_table[] = {
-	{ "DPR",		0x01, 0x01 },
-	{ "TWATERR",		0x02, 0x02 },
-	{ "CLRPENDMSI",		0x08, 0x08 },
-	{ "RTA",		0x10, 0x10 },
-	{ "RMA",		0x20, 0x20 },
-	{ "SSE",		0x40, 0x40 }
-};
-
-int
-ahd_msipcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(MSIPCISTAT_parse_table, 6, "MSIPCISTAT",
-	    0xa6, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t TARGPCISTAT_parse_table[] = {
-	{ "TWATERR",		0x02, 0x02 },
-	{ "STA",		0x08, 0x08 },
-	{ "SSE",		0x40, 0x40 },
-	{ "DPE",		0x80, 0x80 }
-};
-
-int
-ahd_targpcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(TARGPCISTAT_parse_table, 4, "TARGPCISTAT",
-	    0xa7, regvalue, cur_col, wrap));
-}
-
-int
-ahd_data_count_odd_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "DATA_COUNT_ODD",
-	    0xa7, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scbptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCBPTR",
-	    0xa8, regvalue, cur_col, wrap));
-}
-
-int
-ahd_ccscbacnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "CCSCBACNT",
-	    0xab, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCBAUTOPTR_parse_table[] = {
-	{ "SCBPTR_OFF",		0x07, 0x07 },
-	{ "SCBPTR_ADDR",	0x38, 0x38 },
-	{ "AUSCBPTR_EN",	0x80, 0x80 }
-};
-
-int
-ahd_scbautoptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCBAUTOPTR_parse_table, 3, "SCBAUTOPTR",
-	    0xab, regvalue, cur_col, wrap));
-}
-
-int
-ahd_ccsgaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "CCSGADDR",
-	    0xac, regvalue, cur_col, wrap));
-}
-
-int
-ahd_ccscbaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "CCSCBADDR",
-	    0xac, regvalue, cur_col, wrap));
-}
-
-int
-ahd_ccscbadr_bk_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "CCSCBADR_BK",
-	    0xac, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CMC_RAMBIST_parse_table[] = {
-	{ "CMC_BUFFER_BIST_EN",	0x01, 0x01 },
-	{ "CMC_BUFFER_BIST_FAIL",0x02, 0x02 },
-	{ "SG_BIST_EN",		0x10, 0x10 },
-	{ "SG_BIST_FAIL",	0x20, 0x20 },
-	{ "SCBRAMBIST_FAIL",	0x40, 0x40 },
-	{ "SG_ELEMENT_SIZE",	0x80, 0x80 }
-};
-
-int
-ahd_cmc_rambist_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CMC_RAMBIST_parse_table, 6, "CMC_RAMBIST",
-	    0xad, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CCSGCTL_parse_table[] = {
-	{ "CCSGRESET",		0x01, 0x01 },
-	{ "SG_FETCH_REQ",	0x02, 0x02 },
-	{ "CCSGENACK",		0x08, 0x08 },
-	{ "SG_CACHE_AVAIL",	0x10, 0x10 },
-	{ "CCSGDONE",		0x80, 0x80 },
-	{ "CCSGEN",		0x0c, 0x0c }
-};
-
-int
-ahd_ccsgctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CCSGCTL_parse_table, 6, "CCSGCTL",
-	    0xad, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t CCSCBCTL_parse_table[] = {
-	{ "CCSCBRESET",		0x01, 0x01 },
-	{ "CCSCBDIR",		0x04, 0x04 },
-	{ "CCSCBEN",		0x08, 0x08 },
-	{ "CCARREN",		0x10, 0x10 },
-	{ "ARRDONE",		0x40, 0x40 },
-	{ "CCSCBDONE",		0x80, 0x80 }
-};
-
-int
-ahd_ccscbctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(CCSCBCTL_parse_table, 6, "CCSCBCTL",
-	    0xad, regvalue, cur_col, wrap));
-}
-
-int
-ahd_ccsgram_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "CCSGRAM",
-	    0xb0, regvalue, cur_col, wrap));
-}
-
-int
-ahd_flexadr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "FLEXADR",
-	    0xb0, regvalue, cur_col, wrap));
-}
-
-int
-ahd_ccscbram_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "CCSCBRAM",
-	    0xb0, regvalue, cur_col, wrap));
-}
-
-int
-ahd_flexcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "FLEXCNT",
-	    0xb3, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t FLEXDMASTAT_parse_table[] = {
-	{ "FLEXDMADONE",	0x01, 0x01 },
-	{ "FLEXDMAERR",		0x02, 0x02 }
-};
-
-int
-ahd_flexdmastat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(FLEXDMASTAT_parse_table, 2, "FLEXDMASTAT",
-	    0xb5, regvalue, cur_col, wrap));
-}
-
-int
-ahd_flexdata_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "FLEXDATA",
-	    0xb6, regvalue, cur_col, wrap));
-}
-
-int
-ahd_brddat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "BRDDAT",
-	    0xb8, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t BRDCTL_parse_table[] = {
-	{ "BRDSTB",		0x01, 0x01 },
-	{ "BRDRW",		0x02, 0x02 },
-	{ "BRDEN",		0x04, 0x04 },
-	{ "BRDADDR",		0x38, 0x38 },
-	{ "FLXARBREQ",		0x40, 0x40 },
-	{ "FLXARBACK",		0x80, 0x80 }
-};
-
-int
-ahd_brdctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(BRDCTL_parse_table, 6, "BRDCTL",
-	    0xb9, regvalue, cur_col, wrap));
-}
-
-int
-ahd_seeadr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SEEADR",
-	    0xba, regvalue, cur_col, wrap));
-}
-
-int
-ahd_seedat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SEEDAT",
-	    0xbc, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SEECTL_parse_table[] = {
-	{ "SEEOP_ERAL",		0x40, 0x70 },
-	{ "SEEOP_WRITE",	0x50, 0x70 },
-	{ "SEEOP_READ",		0x60, 0x70 },
-	{ "SEEOP_ERASE",	0x70, 0x70 },
-	{ "SEESTART",		0x01, 0x01 },
-	{ "SEERST",		0x02, 0x02 },
-	{ "SEEOPCODE",		0x70, 0x70 },
-	{ "SEEOP_EWEN",		0x40, 0x40 },
-	{ "SEEOP_WALL",		0x40, 0x40 },
-	{ "SEEOP_EWDS",		0x40, 0x40 }
-};
-
-int
-ahd_seectl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SEECTL_parse_table, 10, "SEECTL",
-	    0xbe, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SEESTAT_parse_table[] = {
-	{ "SEESTART",		0x01, 0x01 },
-	{ "SEEBUSY",		0x02, 0x02 },
-	{ "SEEARBACK",		0x04, 0x04 },
-	{ "LDALTID_L",		0x08, 0x08 },
-	{ "SEEOPCODE",		0x70, 0x70 },
-	{ "INIT_DONE",		0x80, 0x80 }
-};
-
-int
-ahd_seestat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SEESTAT_parse_table, 6, "SEESTAT",
-	    0xbe, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCBCNT",
-	    0xbf, regvalue, cur_col, wrap));
-}
-
-int
-ahd_dfwaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "DFWADDR",
-	    0xc0, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DSPFLTRCTL_parse_table[] = {
-	{ "DSPFCNTSEL",		0x0f, 0x0f },
-	{ "EDGESENSE",		0x10, 0x10 },
-	{ "FLTRDISABLE",	0x20, 0x20 }
-};
-
-int
-ahd_dspfltrctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DSPFLTRCTL_parse_table, 3, "DSPFLTRCTL",
-	    0xc0, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DSPDATACTL_parse_table[] = {
-	{ "XMITOFFSTDIS",	0x02, 0x02 },
-	{ "RCVROFFSTDIS",	0x04, 0x04 },
-	{ "DESQDIS",		0x10, 0x10 },
-	{ "BYPASSENAB",		0x80, 0x80 }
-};
-
-int
-ahd_dspdatactl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DSPDATACTL_parse_table, 4, "DSPDATACTL",
-	    0xc1, regvalue, cur_col, wrap));
-}
-
-int
-ahd_dfraddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "DFRADDR",
-	    0xc2, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DSPREQCTL_parse_table[] = {
-	{ "MANREQDLY",		0x3f, 0x3f },
-	{ "MANREQCTL",		0xc0, 0xc0 }
-};
-
-int
-ahd_dspreqctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DSPREQCTL_parse_table, 2, "DSPREQCTL",
-	    0xc2, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DSPACKCTL_parse_table[] = {
-	{ "MANACKDLY",		0x3f, 0x3f },
-	{ "MANACKCTL",		0xc0, 0xc0 }
-};
-
-int
-ahd_dspackctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DSPACKCTL_parse_table, 2, "DSPACKCTL",
-	    0xc3, regvalue, cur_col, wrap));
-}
-
-int
-ahd_dfdat_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "DFDAT",
-	    0xc4, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DSPSELECT_parse_table[] = {
-	{ "DSPSEL",		0x1f, 0x1f },
-	{ "AUTOINCEN",		0x80, 0x80 }
-};
-
-int
-ahd_dspselect_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DSPSELECT_parse_table, 2, "DSPSELECT",
-	    0xc4, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t WRTBIASCTL_parse_table[] = {
-	{ "XMITMANVAL",		0x3f, 0x3f },
-	{ "AUTOXBCDIS",		0x80, 0x80 }
-};
-
-int
-ahd_wrtbiasctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(WRTBIASCTL_parse_table, 2, "WRTBIASCTL",
-	    0xc5, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t RCVRBIOSCTL_parse_table[] = {
-	{ "RCVRMANVAL",		0x3f, 0x3f },
-	{ "AUTORBCDIS",		0x80, 0x80 }
-};
-
-int
-ahd_rcvrbiosctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(RCVRBIOSCTL_parse_table, 2, "RCVRBIOSCTL",
-	    0xc6, regvalue, cur_col, wrap));
-}
-
-int
-ahd_wrtbiascalc_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "WRTBIASCALC",
-	    0xc7, regvalue, cur_col, wrap));
-}
-
-int
-ahd_dfptrs_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "DFPTRS",
-	    0xc8, regvalue, cur_col, wrap));
-}
-
-int
-ahd_rcvrbiascalc_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "RCVRBIASCALC",
-	    0xc8, regvalue, cur_col, wrap));
-}
-
-int
-ahd_dfbkptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "DFBKPTR",
-	    0xc9, regvalue, cur_col, wrap));
-}
-
-int
-ahd_skewcalc_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SKEWCALC",
-	    0xc9, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DFDBCTL_parse_table[] = {
-	{ "DFF_RAMBIST_EN",	0x01, 0x01 },
-	{ "DFF_RAMBIST_DONE",	0x02, 0x02 },
-	{ "DFF_RAMBIST_FAIL",	0x04, 0x04 },
-	{ "DFF_DIR_ERR",	0x08, 0x08 },
-	{ "DFF_CIO_RD_RDY",	0x10, 0x10 },
-	{ "DFF_CIO_WR_RDY",	0x20, 0x20 }
-};
-
-int
-ahd_dfdbctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DFDBCTL_parse_table, 6, "DFDBCTL",
-	    0xcb, regvalue, cur_col, wrap));
-}
-
-int
-ahd_dfscnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "DFSCNT",
-	    0xcc, regvalue, cur_col, wrap));
-}
-
-int
-ahd_dfbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "DFBCNT",
-	    0xce, regvalue, cur_col, wrap));
-}
-
-int
-ahd_ovlyaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "OVLYADDR",
-	    0xd4, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SEQCTL0_parse_table[] = {
-	{ "LOADRAM",		0x01, 0x01 },
-	{ "SEQRESET",		0x02, 0x02 },
-	{ "STEP",		0x04, 0x04 },
-	{ "BRKADRINTEN",	0x08, 0x08 },
-	{ "FASTMODE",		0x10, 0x10 },
-	{ "FAILDIS",		0x20, 0x20 },
-	{ "PAUSEDIS",		0x40, 0x40 },
-	{ "PERRORDIS",		0x80, 0x80 }
-};
-
-int
-ahd_seqctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SEQCTL0_parse_table, 8, "SEQCTL0",
-	    0xd6, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SEQCTL1_parse_table[] = {
-	{ "RAMBIST_EN",		0x01, 0x01 },
-	{ "RAMBIST_FAIL",	0x02, 0x02 },
-	{ "RAMBIST_DONE",	0x04, 0x04 },
-	{ "OVRLAY_DATA_CHK",	0x08, 0x08 }
-};
-
-int
-ahd_seqctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SEQCTL1_parse_table, 4, "SEQCTL1",
-	    0xd7, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t FLAGS_parse_table[] = {
-	{ "CARRY",		0x01, 0x01 },
-	{ "ZERO",		0x02, 0x02 }
-};
-
-int
-ahd_flags_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(FLAGS_parse_table, 2, "FLAGS",
-	    0xd8, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SEQINTCTL_parse_table[] = {
-	{ "IRET",		0x01, 0x01 },
-	{ "INTMASK1",		0x02, 0x02 },
-	{ "INTMASK2",		0x04, 0x04 },
-	{ "SCS_SEQ_INT1M0",	0x08, 0x08 },
-	{ "SCS_SEQ_INT1M1",	0x10, 0x10 },
-	{ "INT1_CONTEXT",	0x20, 0x20 },
-	{ "INTVEC1DSL",		0x80, 0x80 }
-};
-
-int
-ahd_seqintctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SEQINTCTL_parse_table, 7, "SEQINTCTL",
-	    0xd9, regvalue, cur_col, wrap));
-}
-
-int
-ahd_seqram_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SEQRAM",
-	    0xda, regvalue, cur_col, wrap));
-}
-
-int
-ahd_prgmcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "PRGMCNT",
-	    0xde, regvalue, cur_col, wrap));
-}
-
-int
-ahd_accum_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "ACCUM",
-	    0xe0, regvalue, cur_col, wrap));
-}
-
-int
-ahd_sindex_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SINDEX",
-	    0xe2, regvalue, cur_col, wrap));
-}
-
-int
-ahd_dindex_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "DINDEX",
-	    0xe4, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t BRKADDR1_parse_table[] = {
-	{ "BRKDIS",		0x80, 0x80 }
-};
-
-int
-ahd_brkaddr1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(BRKADDR1_parse_table, 1, "BRKADDR1",
-	    0xe6, regvalue, cur_col, wrap));
-}
-
-int
-ahd_brkaddr0_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "BRKADDR0",
-	    0xe6, regvalue, cur_col, wrap));
-}
-
-int
-ahd_allones_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "ALLONES",
-	    0xe8, regvalue, cur_col, wrap));
-}
-
-int
-ahd_allzeros_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "ALLZEROS",
-	    0xea, regvalue, cur_col, wrap));
-}
-
-int
-ahd_none_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "NONE",
-	    0xea, regvalue, cur_col, wrap));
-}
-
-int
-ahd_sindir_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SINDIR",
-	    0xec, regvalue, cur_col, wrap));
-}
-
-int
-ahd_dindir_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "DINDIR",
-	    0xed, regvalue, cur_col, wrap));
-}
-
-int
-ahd_function1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "FUNCTION1",
-	    0xf0, regvalue, cur_col, wrap));
-}
-
-int
-ahd_stack_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "STACK",
-	    0xf2, regvalue, cur_col, wrap));
-}
-
-int
-ahd_curaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "CURADDR",
-	    0xf4, regvalue, cur_col, wrap));
-}
-
-int
-ahd_intvec1_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "INTVEC1_ADDR",
-	    0xf4, regvalue, cur_col, wrap));
-}
-
-int
-ahd_intvec2_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "INTVEC2_ADDR",
-	    0xf6, regvalue, cur_col, wrap));
-}
-
-int
-ahd_lastaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "LASTADDR",
-	    0xf6, regvalue, cur_col, wrap));
-}
-
-int
-ahd_longjmp_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "LONGJMP_ADDR",
-	    0xf8, regvalue, cur_col, wrap));
-}
-
-int
-ahd_longjmp_scb_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "LONGJMP_SCB",
-	    0xfa, regvalue, cur_col, wrap));
-}
-
-int
-ahd_accum_save_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "ACCUM_SAVE",
-	    0xfc, regvalue, cur_col, wrap));
-}
-
-int
-ahd_waiting_scb_tails_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "WAITING_SCB_TAILS",
-	    0x100, regvalue, cur_col, wrap));
-}
-
-int
-ahd_ahd_pci_config_base_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "AHD_PCI_CONFIG_BASE",
-	    0x100, regvalue, cur_col, wrap));
-}
-
-int
-ahd_sram_base_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SRAM_BASE",
-	    0x100, regvalue, cur_col, wrap));
-}
-
-int
-ahd_waiting_tid_head_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "WAITING_TID_HEAD",
-	    0x120, regvalue, cur_col, wrap));
-}
-
-int
-ahd_waiting_tid_tail_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "WAITING_TID_TAIL",
-	    0x122, regvalue, cur_col, wrap));
-}
-
-int
-ahd_next_queued_scb_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "NEXT_QUEUED_SCB_ADDR",
-	    0x124, regvalue, cur_col, wrap));
-}
-
-int
-ahd_complete_scb_head_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "COMPLETE_SCB_HEAD",
-	    0x128, regvalue, cur_col, wrap));
-}
-
-int
-ahd_complete_scb_dmainprog_head_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "COMPLETE_SCB_DMAINPROG_HEAD",
-	    0x12a, regvalue, cur_col, wrap));
-}
-
-int
-ahd_complete_dma_scb_head_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "COMPLETE_DMA_SCB_HEAD",
-	    0x12c, regvalue, cur_col, wrap));
-}
-
-int
-ahd_qfreeze_count_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "QFREEZE_COUNT",
-	    0x12e, regvalue, cur_col, wrap));
-}
-
-int
-ahd_saved_mode_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SAVED_MODE",
-	    0x130, regvalue, cur_col, wrap));
-}
-
-int
-ahd_msg_out_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "MSG_OUT",
-	    0x131, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t DMAPARAMS_parse_table[] = {
-	{ "FIFORESET",		0x01, 0x01 },
-	{ "FIFOFLUSH",		0x02, 0x02 },
-	{ "DIRECTION",		0x04, 0x04 },
-	{ "HDMAEN",		0x08, 0x08 },
-	{ "HDMAENACK",		0x08, 0x08 },
-	{ "SDMAEN",		0x10, 0x10 },
-	{ "SDMAENACK",		0x10, 0x10 },
-	{ "SCSIEN",		0x20, 0x20 },
-	{ "WIDEODD",		0x40, 0x40 },
-	{ "PRELOADEN",		0x80, 0x80 }
-};
-
-int
-ahd_dmaparams_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(DMAPARAMS_parse_table, 10, "DMAPARAMS",
-	    0x132, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SEQ_FLAGS_parse_table[] = {
-	{ "NO_DISCONNECT",	0x01, 0x01 },
-	{ "SPHASE_PENDING",	0x02, 0x02 },
-	{ "DPHASE_PENDING",	0x04, 0x04 },
-	{ "CMDPHASE_PENDING",	0x08, 0x08 },
-	{ "TARG_CMD_PENDING",	0x10, 0x10 },
-	{ "DPHASE",		0x20, 0x20 },
-	{ "NO_CDB_SENT",	0x40, 0x40 },
-	{ "TARGET_CMD_IS_TAGGED",0x40, 0x40 },
-	{ "NOT_IDENTIFIED",	0x80, 0x80 }
-};
-
-int
-ahd_seq_flags_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SEQ_FLAGS_parse_table, 9, "SEQ_FLAGS",
-	    0x133, regvalue, cur_col, wrap));
-}
-
-int
-ahd_saved_scsiid_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SAVED_SCSIID",
-	    0x134, regvalue, cur_col, wrap));
-}
-
-int
-ahd_saved_lun_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SAVED_LUN",
-	    0x135, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t LASTPHASE_parse_table[] = {
-	{ "P_DATAOUT",		0x00, 0xe0 },
-	{ "P_DATAOUT_DT",	0x20, 0xe0 },
-	{ "P_DATAIN",		0x40, 0xe0 },
-	{ "P_DATAIN_DT",	0x60, 0xe0 },
-	{ "P_COMMAND",		0x80, 0xe0 },
-	{ "P_MESGOUT",		0xa0, 0xe0 },
-	{ "P_STATUS",		0xc0, 0xe0 },
-	{ "P_MESGIN",		0xe0, 0xe0 },
-	{ "P_BUSFREE",		0x01, 0x01 },
-	{ "MSGI",		0x20, 0x20 },
-	{ "IOI",		0x40, 0x40 },
-	{ "CDI",		0x80, 0x80 },
-	{ "PHASE_MASK",		0xe0, 0xe0 }
-};
-
-int
-ahd_lastphase_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(LASTPHASE_parse_table, 13, "LASTPHASE",
-	    0x136, regvalue, cur_col, wrap));
-}
-
-int
-ahd_qoutfifo_entry_valid_tag_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "QOUTFIFO_ENTRY_VALID_TAG",
-	    0x137, regvalue, cur_col, wrap));
-}
-
-int
-ahd_shared_data_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SHARED_DATA_ADDR",
-	    0x138, regvalue, cur_col, wrap));
-}
-
-int
-ahd_qoutfifo_next_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "QOUTFIFO_NEXT_ADDR",
-	    0x13c, regvalue, cur_col, wrap));
-}
-
-int
-ahd_kernel_tqinpos_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "KERNEL_TQINPOS",
-	    0x140, regvalue, cur_col, wrap));
-}
-
-int
-ahd_tqinpos_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "TQINPOS",
-	    0x141, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t ARG_1_parse_table[] = {
-	{ "CONT_MSG_LOOP_TARG",	0x02, 0x02 },
-	{ "CONT_MSG_LOOP_READ",	0x03, 0x03 },
-	{ "CONT_MSG_LOOP_WRITE",0x04, 0x04 },
-	{ "EXIT_MSG_LOOP",	0x08, 0x08 },
-	{ "MSGOUT_PHASEMIS",	0x10, 0x10 },
-	{ "SEND_REJ",		0x20, 0x20 },
-	{ "SEND_SENSE",		0x40, 0x40 },
-	{ "SEND_MSG",		0x80, 0x80 }
-};
-
-int
-ahd_arg_1_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(ARG_1_parse_table, 8, "ARG_1",
-	    0x142, regvalue, cur_col, wrap));
-}
-
-int
-ahd_arg_2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "ARG_2",
-	    0x143, regvalue, cur_col, wrap));
-}
-
-int
-ahd_last_msg_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "LAST_MSG",
-	    0x144, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCSISEQ_TEMPLATE_parse_table[] = {
-	{ "ALTSTIM",		0x01, 0x01 },
-	{ "ENAUTOATNP",		0x02, 0x02 },
-	{ "MANUALP",		0x0c, 0x0c },
-	{ "ENRSELI",		0x10, 0x10 },
-	{ "ENSELI",		0x20, 0x20 },
-	{ "MANUALCTL",		0x40, 0x40 }
-};
-
-int
-ahd_scsiseq_template_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCSISEQ_TEMPLATE_parse_table, 6, "SCSISEQ_TEMPLATE",
-	    0x145, regvalue, cur_col, wrap));
-}
-
-int
-ahd_initiator_tag_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "INITIATOR_TAG",
-	    0x146, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SEQ_FLAGS2_parse_table[] = {
-	{ "TARGET_MSG_PENDING",	0x02, 0x02 },
-	{ "SELECTOUT_QFROZEN",	0x04, 0x04 }
-};
-
-int
-ahd_seq_flags2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SEQ_FLAGS2_parse_table, 2, "SEQ_FLAGS2",
-	    0x147, regvalue, cur_col, wrap));
-}
-
-int
-ahd_allocfifo_scbptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "ALLOCFIFO_SCBPTR",
-	    0x148, regvalue, cur_col, wrap));
-}
-
-int
-ahd_int_coalessing_timer_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "INT_COALESSING_TIMER",
-	    0x14a, regvalue, cur_col, wrap));
-}
-
-int
-ahd_int_coalessing_maxcmds_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "INT_COALESSING_MAXCMDS",
-	    0x14c, regvalue, cur_col, wrap));
-}
-
-int
-ahd_int_coalessing_mincmds_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "INT_COALESSING_MINCMDS",
-	    0x14d, regvalue, cur_col, wrap));
-}
-
-int
-ahd_cmds_pending_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "CMDS_PENDING",
-	    0x14e, regvalue, cur_col, wrap));
-}
-
-int
-ahd_int_coalessing_cmdcount_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "INT_COALESSING_CMDCOUNT",
-	    0x150, regvalue, cur_col, wrap));
-}
-
-int
-ahd_local_hs_mailbox_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "LOCAL_HS_MAILBOX",
-	    0x151, regvalue, cur_col, wrap));
-}
-
-int
-ahd_cmdsize_table_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "CMDSIZE_TABLE",
-	    0x152, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_base_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_BASE",
-	    0x180, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_residual_datacnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_RESIDUAL_DATACNT",
-	    0x180, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCB_RESIDUAL_SGPTR_parse_table[] = {
-	{ "SG_LIST_NULL",	0x01, 0x01 },
-	{ "SG_OVERRUN_RESID",	0x02, 0x02 },
-	{ "SG_ADDR_MASK",	0xf8, 0xf8 }
-};
-
-int
-ahd_scb_residual_sgptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCB_RESIDUAL_SGPTR_parse_table, 3, "SCB_RESIDUAL_SGPTR",
-	    0x184, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_scsi_status_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_SCSI_STATUS",
-	    0x188, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_target_phases_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_TARGET_PHASES",
-	    0x189, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_target_data_dir_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_TARGET_DATA_DIR",
-	    0x18a, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_target_itag_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_TARGET_ITAG",
-	    0x18b, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_sense_busaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_SENSE_BUSADDR",
-	    0x18c, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_tag_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_TAG",
-	    0x190, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCB_CDB_LEN_parse_table[] = {
-	{ "SCB_CDB_LEN_PTR",	0x80, 0x80 }
-};
-
-int
-ahd_scb_cdb_len_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCB_CDB_LEN_parse_table, 1, "SCB_CDB_LEN",
-	    0x192, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_task_management_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_TASK_MANAGEMENT",
-	    0x193, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_next_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_NEXT",
-	    0x194, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_next2_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_NEXT2",
-	    0x196, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_dataptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_DATAPTR",
-	    0x198, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCB_DATACNT_parse_table[] = {
-	{ "SG_HIGH_ADDR_BITS",	0x7f, 0x7f },
-	{ "SG_LAST_SEG",	0x80, 0x80 }
-};
-
-int
-ahd_scb_datacnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCB_DATACNT_parse_table, 2, "SCB_DATACNT",
-	    0x1a0, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCB_SGPTR_parse_table[] = {
-	{ "SG_LIST_NULL",	0x01, 0x01 },
-	{ "SG_FULL_RESID",	0x02, 0x02 },
-	{ "SG_STATUS_VALID",	0x04, 0x04 }
-};
-
-int
-ahd_scb_sgptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCB_SGPTR_parse_table, 3, "SCB_SGPTR",
-	    0x1a4, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCB_CONTROL_parse_table[] = {
-	{ "SCB_TAG_TYPE",	0x03, 0x03 },
-	{ "DISCONNECTED",	0x04, 0x04 },
-	{ "STATUS_RCVD",	0x08, 0x08 },
-	{ "MK_MESSAGE",		0x10, 0x10 },
-	{ "TAG_ENB",		0x20, 0x20 },
-	{ "DISCENB",		0x40, 0x40 },
-	{ "TARGET_SCB",		0x80, 0x80 }
-};
-
-int
-ahd_scb_control_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCB_CONTROL_parse_table, 7, "SCB_CONTROL",
-	    0x1a8, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCB_SCSIID_parse_table[] = {
-	{ "OID",		0x0f, 0x0f },
-	{ "TID",		0xf0, 0xf0 }
-};
-
-int
-ahd_scb_scsiid_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCB_SCSIID_parse_table, 2, "SCB_SCSIID",
-	    0x1a9, regvalue, cur_col, wrap));
-}
-
-static ahd_reg_parse_entry_t SCB_LUN_parse_table[] = {
-	{ "LID",		0xff, 0xff }
-};
-
-int
-ahd_scb_lun_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(SCB_LUN_parse_table, 1, "SCB_LUN",
-	    0x1aa, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_task_attribute_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_TASK_ATTRIBUTE",
-	    0x1ab, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_busaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_BUSADDR",
-	    0x1ac, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_spare_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_SPARE",
-	    0x1b0, regvalue, cur_col, wrap));
-}
-
-int
-ahd_scb_disconnected_lists_print(u_int regvalue, u_int *cur_col, u_int wrap)
-{
-	return (ahd_print_register(NULL, 0, "SCB_DISCONNECTED_LISTS",
-	    0x1b8, regvalue, cur_col, wrap));
-}
-
diff -urNp linux-5720/drivers/scsi/aic79xx/aic79xx_seq.h linux-5730/drivers/scsi/aic79xx/aic79xx_seq.h
--- linux-5720/drivers/scsi/aic79xx/aic79xx_seq.h
+++ linux-5730/drivers/scsi/aic79xx/aic79xx_seq.h
@@ -1,1085 +0,0 @@
-/*
- * DO NOT EDIT - This file is automatically generated
- *		 from the following source files:
- *
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#78 $
- * $Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#60 $
- */
-static uint8_t seqprog[] = {
-	0xff, 0x02, 0x06, 0x78,
-	0x00, 0xea, 0x46, 0x59,
-	0x01, 0xea, 0x04, 0x30,
-	0xff, 0x04, 0x0c, 0x78,
-	0x19, 0xea, 0x46, 0x59,
-	0x19, 0xea, 0x04, 0x00,
-	0x33, 0xea, 0x3a, 0x59,
-	0x33, 0xea, 0x00, 0x00,
-	0x60, 0x3a, 0x1a, 0x68,
-	0x04, 0x47, 0x1b, 0x68,
-	0xff, 0x21, 0x1b, 0x70,
-	0x40, 0x4b, 0x88, 0x69,
-	0x00, 0xe2, 0x4a, 0x59,
-	0x40, 0x4b, 0x88, 0x69,
-	0x20, 0x4b, 0x78, 0x69,
-	0xfc, 0x42, 0x24, 0x78,
-	0x10, 0x40, 0x24, 0x78,
-	0x00, 0xe2, 0xa4, 0x5d,
-	0x20, 0x4d, 0x28, 0x78,
-	0x00, 0xe2, 0xa4, 0x5d,
-	0x00, 0xe2, 0x34, 0x58,
-	0x00, 0xe2, 0x66, 0x58,
-	0x00, 0xe2, 0x76, 0x58,
-	0x00, 0xe2, 0x06, 0x40,
-	0x33, 0xea, 0x3a, 0x59,
-	0x33, 0xea, 0x00, 0x00,
-	0x01, 0x52, 0x66, 0x7d,
-	0x02, 0x58, 0x50, 0x31,
-	0xff, 0xea, 0x10, 0x0b,
-	0xff, 0x93, 0x45, 0x78,
-	0x50, 0x4b, 0x40, 0x68,
-	0xbf, 0x3a, 0x74, 0x08,
-	0x14, 0xea, 0x46, 0x59,
-	0x14, 0xea, 0x04, 0x00,
-	0x08, 0xa8, 0x51, 0x03,
-	0x01, 0xa4, 0x4d, 0x78,
-	0x00, 0xe2, 0x44, 0x5b,
-	0x00, 0xe2, 0x34, 0x40,
-	0xff, 0xea, 0xd4, 0x19,
-	0x02, 0xa8, 0x84, 0x32,
-	0x00, 0xea, 0x3a, 0x59,
-	0x01, 0xea, 0x00, 0x30,
-	0x00, 0xe2, 0x98, 0x5d,
-	0x00, 0xe2, 0x66, 0x4d,
-	0x11, 0xea, 0x3a, 0x59,
-	0x11, 0xea, 0x00, 0x00,
-	0x00, 0xe2, 0x98, 0x5d,
-	0x00, 0xe2, 0x66, 0x4d,
-	0x33, 0xea, 0x3a, 0x59,
-	0x33, 0xea, 0x00, 0x00,
-	0x00, 0xe2, 0x3a, 0x43,
-	0x00, 0xea, 0x3a, 0x59,
-	0x01, 0xea, 0x00, 0x30,
-	0x80, 0xf9, 0x6e, 0x68,
-	0x00, 0xe2, 0x38, 0x59,
-	0x11, 0xea, 0x3a, 0x59,
-	0x11, 0xea, 0x00, 0x00,
-	0x80, 0xf9, 0x38, 0x79,
-	0xff, 0xea, 0xd4, 0x0d,
-	0x22, 0xea, 0x3a, 0x59,
-	0x22, 0xea, 0x00, 0x00,
-	0x10, 0x16, 0x80, 0x78,
-	0x01, 0x0b, 0xa2, 0x32,
-	0x10, 0x16, 0x2c, 0x00,
-	0x18, 0xad, 0xee, 0x78,
-	0x04, 0xad, 0xbc, 0x68,
-	0x80, 0xad, 0x66, 0x7d,
-	0x10, 0xad, 0x8a, 0x78,
-	0xe7, 0xad, 0x5a, 0x0d,
-	0xe7, 0xad, 0x5a, 0x09,
-	0x00, 0xe2, 0x98, 0x58,
-	0xff, 0xea, 0x56, 0x02,
-	0x04, 0x7c, 0x78, 0x32,
-	0x20, 0x16, 0x66, 0x7d,
-	0x04, 0x38, 0x79, 0x32,
-	0x80, 0x37, 0x6f, 0x16,
-	0xff, 0x2d, 0xa7, 0x60,
-	0xff, 0x29, 0xa7, 0x60,
-	0x40, 0x51, 0xb7, 0x78,
-	0xff, 0x4f, 0xa7, 0x68,
-	0xff, 0x4d, 0xc1, 0x19,
-	0x00, 0x4e, 0xd5, 0x19,
-	0x00, 0xe2, 0xb6, 0x50,
-	0x01, 0x4c, 0xc1, 0x31,
-	0x00, 0x50, 0xd5, 0x19,
-	0x00, 0xe2, 0xb6, 0x48,
-	0x80, 0x18, 0x66, 0x7d,
-	0x02, 0x4a, 0x1d, 0x30,
-	0x10, 0xea, 0x18, 0x00,
-	0x60, 0x18, 0x30, 0x00,
-	0x7f, 0x18, 0x30, 0x0c,
-	0x02, 0xea, 0x02, 0x00,
-	0xff, 0xea, 0xa0, 0x0a,
-	0x80, 0x18, 0x30, 0x04,
-	0x40, 0xad, 0x66, 0x7d,
-	0xe7, 0xad, 0x5a, 0x09,
-	0x02, 0xa8, 0x40, 0x31,
-	0xff, 0xea, 0xc0, 0x09,
-	0x01, 0x4e, 0x9d, 0x1a,
-	0x00, 0x4f, 0x9f, 0x22,
-	0x04, 0x94, 0x49, 0x32,
-	0xff, 0xea, 0x2a, 0x03,
-	0xff, 0xea, 0x2e, 0x03,
-	0x01, 0x10, 0xd4, 0x31,
-	0x10, 0xa8, 0xe3, 0x68,
-	0x3d, 0xa9, 0xc5, 0x29,
-	0xfe, 0xe2, 0xc4, 0x09,
-	0x01, 0xea, 0xc6, 0x01,
-	0x02, 0xe2, 0xc8, 0x31,
-	0x02, 0xec, 0x50, 0x31,
-	0x02, 0xa0, 0xda, 0x31,
-	0xff, 0xa9, 0xe2, 0x70,
-	0x02, 0xa0, 0x28, 0x37,
-	0xff, 0x21, 0xeb, 0x70,
-	0x02, 0x22, 0x51, 0x31,
-	0x02, 0xa0, 0x2c, 0x33,
-	0x02, 0xa0, 0x44, 0x36,
-	0x02, 0xa0, 0x40, 0x32,
-	0x02, 0xa0, 0x44, 0x36,
-	0x04, 0x47, 0xf3, 0x68,
-	0x40, 0x16, 0x1e, 0x69,
-	0xff, 0x2d, 0x23, 0x61,
-	0xff, 0x29, 0x67, 0x75,
-	0x01, 0x37, 0xc1, 0x31,
-	0x02, 0x28, 0x55, 0x32,
-	0x01, 0xea, 0x5a, 0x01,
-	0x04, 0x3c, 0xf9, 0x30,
-	0x02, 0x28, 0x51, 0x31,
-	0x01, 0xa8, 0x60, 0x31,
-	0x00, 0xa9, 0x60, 0x01,
-	0x01, 0x14, 0xd4, 0x31,
-	0x01, 0x50, 0xa1, 0x1a,
-	0xff, 0x4e, 0x9d, 0x1a,
-	0xff, 0x4f, 0x9f, 0x22,
-	0xff, 0x8d, 0x17, 0x71,
-	0x80, 0xac, 0x16, 0x71,
-	0x20, 0x16, 0x16, 0x69,
-	0x02, 0x8c, 0x51, 0x31,
-	0x00, 0xe2, 0x00, 0x41,
-	0x01, 0xac, 0x08, 0x31,
-	0x09, 0xea, 0x5a, 0x01,
-	0x02, 0x8c, 0x51, 0x32,
-	0xff, 0xea, 0x1a, 0x07,
-	0x04, 0x24, 0xf9, 0x30,
-	0x1d, 0xea, 0x2e, 0x41,
-	0x02, 0x2c, 0x51, 0x31,
-	0x04, 0xac, 0xf9, 0x30,
-	0x19, 0xea, 0x2e, 0x59,
-	0x02, 0x8c, 0x59, 0x32,
-	0x02, 0x28, 0x19, 0x33,
-	0x02, 0xa8, 0x50, 0x36,
-	0x06, 0xea, 0x08, 0x81,
-	0x01, 0xe2, 0x5a, 0x35,
-	0x02, 0xa8, 0xf4, 0x31,
-	0x02, 0xf2, 0xf0, 0x35,
-	0x02, 0xf2, 0xf0, 0x31,
-	0x02, 0xf8, 0xe4, 0x35,
-	0x80, 0xea, 0xb2, 0x01,
-	0x01, 0xe2, 0x00, 0x30,
-	0xff, 0xea, 0xb2, 0x0d,
-	0x80, 0xea, 0xb2, 0x01,
-	0x11, 0x00, 0x00, 0x10,
-	0xff, 0xea, 0xb2, 0x0d,
-	0x01, 0xe2, 0x04, 0x30,
-	0x01, 0xea, 0x04, 0x34,
-	0x02, 0x20, 0xbd, 0x30,
-	0x02, 0x20, 0xb9, 0x30,
-	0x02, 0x20, 0x51, 0x31,
-	0x4c, 0xa9, 0xd7, 0x28,
-	0x10, 0xa8, 0x59, 0x79,
-	0x01, 0x6b, 0xc0, 0x30,
-	0x02, 0x64, 0xc8, 0x00,
-	0x40, 0x3a, 0x74, 0x04,
-	0x00, 0xe2, 0x66, 0x58,
-	0x33, 0xea, 0x3a, 0x59,
-	0x33, 0xea, 0x00, 0x00,
-	0x30, 0x3f, 0xc0, 0x09,
-	0x30, 0xe0, 0x5a, 0x61,
-	0x20, 0x3f, 0x70, 0x69,
-	0x10, 0x3f, 0x5a, 0x79,
-	0x02, 0xea, 0x7e, 0x00,
-	0x00, 0xea, 0x3a, 0x59,
-	0x01, 0xea, 0x00, 0x30,
-	0x02, 0x48, 0x51, 0x35,
-	0x01, 0xea, 0x7e, 0x00,
-	0x11, 0xea, 0x3a, 0x59,
-	0x11, 0xea, 0x00, 0x00,
-	0x02, 0x48, 0x51, 0x35,
-	0x08, 0xea, 0x98, 0x00,
-	0x08, 0x57, 0xae, 0x00,
-	0x08, 0x3c, 0x78, 0x00,
-	0xf0, 0x49, 0x68, 0x0a,
-	0x0f, 0x67, 0xc0, 0x09,
-	0x00, 0x34, 0x69, 0x02,
-	0x20, 0xea, 0x96, 0x00,
-	0x00, 0xe2, 0xee, 0x41,
-	0x40, 0x3a, 0xa4, 0x69,
-	0x02, 0x55, 0x06, 0x68,
-	0x02, 0x56, 0xa4, 0x69,
-	0xff, 0x5b, 0xa4, 0x61,
-	0x02, 0x20, 0x51, 0x31,
-	0x80, 0xea, 0xb2, 0x01,
-	0x44, 0xea, 0x00, 0x00,
-	0x01, 0x33, 0xc0, 0x31,
-	0x33, 0xea, 0x00, 0x00,
-	0xff, 0xea, 0xb2, 0x09,
-	0xff, 0xe0, 0xc0, 0x19,
-	0xff, 0xe0, 0xa6, 0x79,
-	0x02, 0x94, 0x51, 0x31,
-	0x00, 0xe2, 0x9c, 0x41,
-	0x02, 0x5e, 0x50, 0x31,
-	0x02, 0xa8, 0xb8, 0x30,
-	0x02, 0x5c, 0x50, 0x31,
-	0xff, 0x95, 0xb7, 0x71,
-	0x02, 0x94, 0x41, 0x31,
-	0x02, 0x22, 0x51, 0x31,
-	0x02, 0xa0, 0x2c, 0x33,
-	0x02, 0xa0, 0x44, 0x32,
-	0x00, 0xe2, 0xc0, 0x41,
-	0x10, 0xa8, 0xc1, 0x69,
-	0x3d, 0xa9, 0xc9, 0x29,
-	0x01, 0xe4, 0xc8, 0x01,
-	0x01, 0xea, 0xca, 0x01,
-	0xff, 0xea, 0xda, 0x01,
-	0x02, 0x20, 0x51, 0x31,
-	0x02, 0x96, 0x41, 0x32,
-	0xff, 0x21, 0xc9, 0x61,
-	0xff, 0xea, 0x46, 0x02,
-	0x02, 0x5c, 0x50, 0x31,
-	0x40, 0xea, 0x96, 0x00,
-	0x02, 0x56, 0xac, 0x6d,
-	0x01, 0x55, 0xac, 0x6d,
-	0x10, 0xa8, 0xd5, 0x79,
-	0x10, 0x40, 0xde, 0x69,
-	0x01, 0x56, 0xde, 0x79,
-	0xff, 0x93, 0x07, 0x78,
-	0x13, 0xea, 0x46, 0x59,
-	0x13, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0x06, 0x40,
-	0xbf, 0x3a, 0x74, 0x08,
-	0x08, 0xea, 0x98, 0x00,
-	0x08, 0x57, 0xae, 0x00,
-	0x01, 0xa9, 0x69, 0x32,
-	0x01, 0xaa, 0x6b, 0x32,
-	0x40, 0xea, 0x66, 0x02,
-	0x08, 0x3c, 0x78, 0x00,
-	0x80, 0xea, 0x62, 0x02,
-	0x00, 0xe2, 0xa4, 0x5b,
-	0x01, 0x36, 0xc1, 0x31,
-	0x9f, 0xe0, 0x38, 0x7c,
-	0x80, 0xe0, 0x02, 0x72,
-	0xa0, 0xe0, 0x3a, 0x72,
-	0xc0, 0xe0, 0x30, 0x72,
-	0xe0, 0xe0, 0x6a, 0x72,
-	0x01, 0xea, 0x46, 0x59,
-	0x01, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xee, 0x41,
-	0x80, 0x33, 0x09, 0x7a,
-	0x03, 0xea, 0x46, 0x59,
-	0x03, 0xea, 0x04, 0x00,
-	0xee, 0x00, 0x10, 0x6a,
-	0x05, 0xea, 0xb4, 0x00,
-	0x33, 0xea, 0x3a, 0x59,
-	0x33, 0xea, 0x00, 0x00,
-	0x02, 0xa8, 0x90, 0x32,
-	0x00, 0xe2, 0x60, 0x59,
-	0xef, 0x92, 0xd5, 0x19,
-	0x00, 0xe2, 0x20, 0x52,
-	0x0b, 0x84, 0xe1, 0x30,
-	0x02, 0xea, 0x36, 0x00,
-	0xa8, 0xea, 0x32, 0x00,
-	0x00, 0xe2, 0x26, 0x42,
-	0x01, 0x92, 0xd1, 0x30,
-	0x10, 0x80, 0x89, 0x31,
-	0x20, 0xea, 0x32, 0x00,
-	0xbf, 0x33, 0x67, 0x0a,
-	0x20, 0x19, 0x28, 0x6a,
-	0x02, 0x4d, 0xee, 0x69,
-	0x40, 0x33, 0x67, 0x02,
-	0x00, 0xe2, 0xee, 0x41,
-	0x80, 0x33, 0xa7, 0x6a,
-	0x01, 0x44, 0x10, 0x33,
-	0x08, 0xa8, 0x51, 0x03,
-	0x00, 0xe2, 0xee, 0x41,
-	0x10, 0xea, 0x80, 0x00,
-	0x01, 0x31, 0xc5, 0x31,
-	0x80, 0xe2, 0x56, 0x62,
-	0x10, 0xa8, 0x7b, 0x6a,
-	0xc0, 0xaa, 0xc5, 0x01,
-	0x40, 0xa8, 0x47, 0x6a,
-	0xbf, 0xe2, 0xc4, 0x09,
-	0x20, 0xa8, 0x5b, 0x7a,
-	0x01, 0xe2, 0x88, 0x30,
-	0x00, 0xe2, 0xa4, 0x5b,
-	0xa0, 0x36, 0x63, 0x62,
-	0x23, 0xa8, 0x89, 0x08,
-	0x00, 0xe2, 0xa4, 0x5b,
-	0xa0, 0x36, 0x63, 0x62,
-	0x00, 0xa8, 0x5a, 0x42,
-	0xff, 0xe2, 0x5a, 0x62,
-	0x00, 0xe2, 0x7a, 0x42,
-	0x40, 0xea, 0x98, 0x00,
-	0x01, 0xe2, 0x88, 0x30,
-	0x00, 0xe2, 0xa4, 0x5b,
-	0xa0, 0x36, 0x39, 0x72,
-	0x40, 0xea, 0x98, 0x00,
-	0x01, 0x31, 0x89, 0x32,
-	0x08, 0xea, 0x62, 0x02,
-	0x00, 0xe2, 0xee, 0x41,
-	0xe0, 0xea, 0xb4, 0x5b,
-	0x80, 0xe0, 0xb2, 0x6a,
-	0x04, 0xe0, 0x52, 0x73,
-	0x02, 0xe0, 0x82, 0x73,
-	0x00, 0xea, 0x10, 0x73,
-	0x03, 0xe0, 0x92, 0x73,
-	0x23, 0xe0, 0x8c, 0x72,
-	0x08, 0xe0, 0xae, 0x72,
-	0x00, 0xe2, 0xa4, 0x5b,
-	0x07, 0xea, 0x46, 0x59,
-	0x07, 0xea, 0x04, 0x00,
-	0x08, 0x42, 0xef, 0x71,
-	0x04, 0x42, 0x89, 0x62,
-	0x01, 0x43, 0x89, 0x30,
-	0x00, 0xe2, 0x7a, 0x42,
-	0x01, 0x44, 0xd4, 0x31,
-	0x00, 0xe2, 0x7a, 0x42,
-	0x01, 0x00, 0x60, 0x32,
-	0x33, 0xea, 0x3a, 0x59,
-	0x33, 0xea, 0x00, 0x00,
-	0x4c, 0x34, 0xc1, 0x28,
-	0x01, 0x64, 0xc0, 0x31,
-	0x00, 0x30, 0x3b, 0x59,
-	0x01, 0x30, 0x01, 0x30,
-	0x01, 0xe0, 0xac, 0x7a,
-	0xa0, 0xea, 0xaa, 0x5b,
-	0x01, 0xa0, 0xac, 0x62,
-	0x01, 0x84, 0xa5, 0x7a,
-	0x01, 0xa7, 0xae, 0x7a,
-	0x00, 0xe2, 0xae, 0x42,
-	0x03, 0xea, 0x46, 0x59,
-	0x03, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xae, 0x42,
-	0x07, 0xea, 0xbc, 0x5b,
-	0x01, 0x44, 0xd4, 0x31,
-	0x00, 0xe2, 0xee, 0x41,
-	0x3f, 0xe0, 0x6a, 0x0a,
-	0xc0, 0x34, 0xc1, 0x09,
-	0x00, 0x35, 0x51, 0x01,
-	0xff, 0xea, 0x52, 0x09,
-	0x30, 0x34, 0xc5, 0x09,
-	0x3d, 0xe2, 0xc4, 0x29,
-	0xb8, 0xe2, 0xc4, 0x19,
-	0x01, 0xea, 0xc6, 0x01,
-	0x02, 0xe2, 0xc8, 0x31,
-	0x02, 0xec, 0x40, 0x31,
-	0xff, 0xa1, 0xce, 0x72,
-	0x02, 0xe8, 0xda, 0x31,
-	0x02, 0xa0, 0x50, 0x31,
-	0x00, 0xe2, 0xf0, 0x42,
-	0x80, 0x33, 0x67, 0x02,
-	0x01, 0x44, 0xd4, 0x31,
-	0x00, 0xe2, 0xa4, 0x5b,
-	0x01, 0x33, 0x67, 0x02,
-	0xe0, 0x36, 0x0b, 0x63,
-	0x02, 0x33, 0x67, 0x02,
-	0x20, 0x46, 0x04, 0x63,
-	0xff, 0xea, 0x52, 0x09,
-	0xa8, 0xea, 0xaa, 0x5b,
-	0x04, 0xa8, 0xeb, 0x7a,
-	0x01, 0x34, 0xc1, 0x31,
-	0x00, 0xa9, 0xeb, 0x62,
-	0x01, 0x35, 0xc1, 0x31,
-	0x00, 0xaa, 0xf5, 0x72,
-	0x01, 0xa9, 0x52, 0x11,
-	0xff, 0xa9, 0xe0, 0x6a,
-	0x00, 0xe2, 0x04, 0x43,
-	0x10, 0x33, 0x67, 0x02,
-	0x04, 0xa8, 0x05, 0x7b,
-	0xfb, 0xa8, 0x51, 0x0b,
-	0xff, 0xea, 0x66, 0x0a,
-	0x01, 0xa4, 0xff, 0x6a,
-	0x02, 0xa8, 0x90, 0x32,
-	0x00, 0xe2, 0x60, 0x59,
-	0x10, 0xa8, 0xaf, 0x7a,
-	0xff, 0xea, 0xbc, 0x5b,
-	0x00, 0xe2, 0xae, 0x42,
-	0x04, 0xea, 0x46, 0x59,
-	0x04, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xae, 0x42,
-	0x04, 0xea, 0x46, 0x59,
-	0x04, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xee, 0x41,
-	0x08, 0xa8, 0xa7, 0x7a,
-	0xc0, 0x33, 0x1b, 0x7b,
-	0x80, 0x33, 0xa7, 0x6a,
-	0xff, 0x88, 0x1b, 0x6b,
-	0x40, 0x33, 0xa7, 0x6a,
-	0x10, 0xa8, 0x21, 0x7b,
-	0x0a, 0xea, 0x46, 0x59,
-	0x0a, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0x3a, 0x5b,
-	0x00, 0xe2, 0x6e, 0x43,
-	0x50, 0x4b, 0x28, 0x6b,
-	0xbf, 0x3a, 0x74, 0x08,
-	0x01, 0xe0, 0xf8, 0x31,
-	0xff, 0xea, 0xc0, 0x09,
-	0x01, 0x2e, 0x5d, 0x1a,
-	0x00, 0x2f, 0x5f, 0x22,
-	0x04, 0x47, 0x8f, 0x02,
-	0x01, 0xfc, 0xc0, 0x35,
-	0x33, 0xea, 0x3a, 0x59,
-	0x33, 0xea, 0x00, 0x00,
-	0x02, 0x42, 0x51, 0x31,
-	0x10, 0xa8, 0x51, 0x03,
-	0xff, 0x88, 0x49, 0x6b,
-	0x01, 0xa4, 0x45, 0x6b,
-	0x02, 0xa4, 0x4d, 0x6b,
-	0x01, 0x84, 0x4d, 0x7b,
-	0x02, 0x28, 0x19, 0x33,
-	0x02, 0xa8, 0x50, 0x36,
-	0xff, 0x88, 0x4d, 0x73,
-	0x00, 0xe2, 0x24, 0x5b,
-	0x02, 0x2c, 0x19, 0x33,
-	0x02, 0xa8, 0x58, 0x32,
-	0x04, 0xa4, 0x49, 0x07,
-	0xc0, 0x33, 0xa7, 0x6a,
-	0x04, 0xa8, 0x51, 0x03,
-	0x20, 0xa8, 0x6f, 0x6b,
-	0x02, 0xa8, 0x40, 0x31,
-	0xc0, 0x34, 0xc1, 0x09,
-	0x00, 0x35, 0x51, 0x01,
-	0xff, 0xea, 0x52, 0x09,
-	0x30, 0x34, 0xc5, 0x09,
-	0x3d, 0xe2, 0xc4, 0x29,
-	0xb8, 0xe2, 0xc4, 0x19,
-	0x01, 0xea, 0xc6, 0x01,
-	0x02, 0xe2, 0xc8, 0x31,
-	0x02, 0xa0, 0xda, 0x31,
-	0x02, 0xa0, 0x50, 0x31,
-	0xf7, 0x57, 0xae, 0x08,
-	0x08, 0xea, 0x98, 0x00,
-	0x01, 0x44, 0xd4, 0x31,
-	0xee, 0x00, 0x78, 0x6b,
-	0x02, 0xea, 0xb4, 0x00,
-	0x00, 0xe2, 0xa0, 0x5b,
-	0x09, 0x4c, 0x7a, 0x7b,
-	0x08, 0x4c, 0x06, 0x68,
-	0x0b, 0xea, 0x46, 0x59,
-	0x0b, 0xea, 0x04, 0x00,
-	0x01, 0x44, 0xd4, 0x31,
-	0x20, 0x33, 0xef, 0x79,
-	0x00, 0xe2, 0x8a, 0x5b,
-	0x00, 0xe2, 0xee, 0x41,
-	0x01, 0x84, 0x8f, 0x7b,
-	0x01, 0xa4, 0x49, 0x07,
-	0x08, 0x60, 0x30, 0x33,
-	0x08, 0x80, 0x41, 0x37,
-	0xdf, 0x33, 0x67, 0x0a,
-	0xee, 0x00, 0x9c, 0x6b,
-	0x05, 0xea, 0xb4, 0x00,
-	0x33, 0xea, 0x3a, 0x59,
-	0x33, 0xea, 0x00, 0x00,
-	0x00, 0xe2, 0x60, 0x59,
-	0x00, 0xe2, 0xae, 0x42,
-	0x01, 0xea, 0x6c, 0x02,
-	0xc0, 0xea, 0x66, 0x06,
-	0xff, 0x42, 0xa4, 0x7b,
-	0x04, 0x4c, 0xa4, 0x6b,
-	0xe0, 0x41, 0x6c, 0x0e,
-	0x01, 0x44, 0xd4, 0x31,
-	0xff, 0x42, 0xac, 0x7b,
-	0x04, 0x4c, 0xac, 0x6b,
-	0xe0, 0x41, 0x6c, 0x0a,
-	0xe0, 0x36, 0xef, 0x61,
-	0xff, 0xea, 0xca, 0x09,
-	0x01, 0xe2, 0xc8, 0x31,
-	0x01, 0x46, 0xda, 0x35,
-	0x01, 0x44, 0xd4, 0x35,
-	0x10, 0xea, 0x80, 0x00,
-	0x01, 0xe2, 0x62, 0x36,
-	0x04, 0xa6, 0xc4, 0x7b,
-	0xff, 0xea, 0x5a, 0x09,
-	0xff, 0xea, 0x4c, 0x0d,
-	0x01, 0xa6, 0xe2, 0x6b,
-	0x10, 0xad, 0x66, 0x7d,
-	0x80, 0xad, 0xda, 0x6b,
-	0x08, 0xad, 0x66, 0x6d,
-	0x04, 0x84, 0xf9, 0x30,
-	0x00, 0xea, 0x08, 0x81,
-	0xff, 0xea, 0xd4, 0x09,
-	0x02, 0x84, 0xf9, 0x88,
-	0x1d, 0xea, 0x5a, 0x01,
-	0x04, 0xa6, 0x4c, 0x05,
-	0x04, 0xa6, 0x66, 0x7d,
-	0xff, 0xea, 0x5a, 0x09,
-	0x03, 0x84, 0x59, 0x89,
-	0x03, 0xea, 0x4c, 0x01,
-	0x80, 0x1a, 0x66, 0x7d,
-	0x08, 0xb0, 0xe0, 0x30,
-	0x04, 0xb0, 0xe0, 0x30,
-	0x03, 0xb0, 0xf0, 0x30,
-	0x01, 0x78, 0xee, 0x7b,
-	0x01, 0xa7, 0x4e, 0x11,
-	0x01, 0xb0, 0x06, 0x33,
-	0x7f, 0x83, 0xe9, 0x08,
-	0x04, 0xac, 0x58, 0x19,
-	0xff, 0xea, 0xc0, 0x09,
-	0x04, 0x84, 0x09, 0x9b,
-	0x00, 0x85, 0x0b, 0x23,
-	0x00, 0x86, 0x0d, 0x23,
-	0x00, 0x87, 0x0f, 0x23,
-	0x01, 0x84, 0xc5, 0x31,
-	0x01, 0xa7, 0x04, 0x7c,
-	0x04, 0xe2, 0xc4, 0x01,
-	0x80, 0x83, 0x0b, 0x7c,
-	0x02, 0xe2, 0xc4, 0x01,
-	0xff, 0xea, 0x4c, 0x09,
-	0x01, 0xe2, 0x36, 0x30,
-	0xc8, 0x19, 0x32, 0x00,
-	0x88, 0x19, 0x32, 0x00,
-	0x01, 0xac, 0xd4, 0x99,
-	0x00, 0xe2, 0x66, 0x55,
-	0xfe, 0xa6, 0x4c, 0x0d,
-	0x0b, 0x98, 0xe1, 0x30,
-	0x01, 0xa0, 0x4f, 0x09,
-	0xfd, 0xa4, 0x49, 0x09,
-	0x80, 0xa3, 0x21, 0x7c,
-	0x02, 0xa4, 0x48, 0x01,
-	0x01, 0xa7, 0x24, 0x7c,
-	0x04, 0xa4, 0x48, 0x01,
-	0x01, 0xa4, 0x36, 0x30,
-	0xa8, 0xea, 0x32, 0x00,
-	0xfd, 0xa4, 0x49, 0x0b,
-	0x05, 0xa3, 0x07, 0x33,
-	0x80, 0x83, 0x31, 0x6c,
-	0x02, 0xea, 0x4c, 0x05,
-	0xff, 0xea, 0x4c, 0x0d,
-	0x00, 0xe2, 0x32, 0x59,
-	0x02, 0xa6, 0xc6, 0x6b,
-	0x80, 0xf9, 0xf2, 0x05,
-	0xc0, 0x33, 0x3f, 0x7c,
-	0x03, 0xea, 0x46, 0x59,
-	0x03, 0xea, 0x04, 0x00,
-	0x20, 0x33, 0x63, 0x7c,
-	0x01, 0x84, 0x49, 0x6c,
-	0x06, 0xea, 0x46, 0x59,
-	0x06, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0x66, 0x44,
-	0x01, 0x00, 0x60, 0x32,
-	0xee, 0x00, 0x52, 0x6c,
-	0x05, 0xea, 0xb4, 0x00,
-	0x33, 0xea, 0x3a, 0x59,
-	0x33, 0xea, 0x00, 0x00,
-	0x80, 0x3d, 0x7a, 0x00,
-	0xfc, 0x42, 0x54, 0x7c,
-	0x7f, 0x3d, 0x7a, 0x08,
-	0x00, 0x30, 0x3b, 0x59,
-	0x01, 0x30, 0x01, 0x30,
-	0x09, 0xea, 0x46, 0x59,
-	0x09, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xee, 0x41,
-	0x01, 0xa4, 0x49, 0x6c,
-	0x00, 0xe2, 0x16, 0x5c,
-	0x20, 0x33, 0x67, 0x02,
-	0x01, 0x00, 0x60, 0x32,
-	0x02, 0xa6, 0x6e, 0x7c,
-	0x00, 0xe2, 0x32, 0x5c,
-	0x00, 0xe2, 0x66, 0x58,
-	0x00, 0xe2, 0x76, 0x58,
-	0x00, 0xe2, 0x30, 0x58,
-	0x00, 0x30, 0x3b, 0x59,
-	0x01, 0x30, 0x01, 0x30,
-	0x20, 0x19, 0x6e, 0x6c,
-	0x00, 0xe2, 0x96, 0x5c,
-	0x04, 0x19, 0x88, 0x6c,
-	0x02, 0x19, 0x32, 0x00,
-	0x01, 0x84, 0x89, 0x7c,
-	0x01, 0x1b, 0x82, 0x7c,
-	0x01, 0x1a, 0x88, 0x6c,
-	0x00, 0xe2, 0x38, 0x44,
-	0x80, 0x4b, 0x8e, 0x6c,
-	0x01, 0x4c, 0x8a, 0x7c,
-	0x03, 0x42, 0x38, 0x6c,
-	0x00, 0xe2, 0xc0, 0x5b,
-	0x80, 0xf9, 0xf2, 0x01,
-	0x04, 0x33, 0xef, 0x79,
-	0x00, 0xe2, 0xee, 0x41,
-	0x02, 0x1b, 0x9e, 0x7c,
-	0x08, 0x5d, 0x9c, 0x7c,
-	0x03, 0x68, 0x00, 0x37,
-	0x01, 0x84, 0x09, 0x07,
-	0x08, 0x5d, 0xa8, 0x6c,
-	0x00, 0xe2, 0x66, 0x58,
-	0x00, 0x30, 0x3b, 0x59,
-	0x01, 0x30, 0x01, 0x30,
-	0x00, 0xe2, 0x96, 0x44,
-	0x80, 0x1b, 0xb2, 0x7c,
-	0x80, 0x84, 0xb3, 0x6c,
-	0xff, 0x85, 0x0b, 0x1b,
-	0xff, 0x86, 0x0d, 0x23,
-	0xff, 0x87, 0x0f, 0x23,
-	0xf8, 0x1b, 0x08, 0x0b,
-	0xff, 0xea, 0x4e, 0x09,
-	0x04, 0x1b, 0xba, 0x7c,
-	0x01, 0xa7, 0x4e, 0x01,
-	0xff, 0xea, 0x06, 0x0b,
-	0x03, 0x68, 0x00, 0x37,
-	0x00, 0xe2, 0xb6, 0x58,
-	0x10, 0xea, 0x18, 0x00,
-	0xf9, 0xd9, 0xb2, 0x0d,
-	0x01, 0xd9, 0xb2, 0x05,
-	0xff, 0xea, 0xd4, 0x09,
-	0x10, 0x5b, 0xde, 0x6c,
-	0x08, 0x5b, 0xe6, 0x6c,
-	0x20, 0x5b, 0xd4, 0x6c,
-	0x02, 0x5b, 0xfa, 0x6d,
-	0x0e, 0xea, 0x46, 0x59,
-	0x0e, 0xea, 0x04, 0x00,
-	0x08, 0x19, 0xda, 0x7c,
-	0xdf, 0x5c, 0xb8, 0x08,
-	0x01, 0xd9, 0xb2, 0x05,
-	0x02, 0xea, 0xb4, 0x00,
-	0x01, 0xd9, 0xb2, 0x05,
-	0x01, 0xa4, 0xc3, 0x6d,
-	0x00, 0xe2, 0x16, 0x5c,
-	0x00, 0xe2, 0x06, 0x5d,
-	0x01, 0xd9, 0xb2, 0x05,
-	0x00, 0xe2, 0x24, 0x5b,
-	0xf3, 0x92, 0xd5, 0x19,
-	0x00, 0xe2, 0xf4, 0x54,
-	0x80, 0x92, 0xf5, 0x6c,
-	0x0f, 0xea, 0x46, 0x59,
-	0x0f, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xfc, 0x44,
-	0x04, 0x8c, 0xe1, 0x30,
-	0x01, 0xea, 0xf2, 0x00,
-	0x02, 0xea, 0x36, 0x00,
-	0xa8, 0xea, 0x32, 0x00,
-	0xff, 0x93, 0x03, 0x7d,
-	0x14, 0xea, 0x46, 0x59,
-	0x14, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0x88, 0x5d,
-	0x01, 0xd9, 0xb2, 0x05,
-	0x02, 0xa8, 0xf4, 0x31,
-	0x02, 0xa6, 0x18, 0x7d,
-	0x00, 0xe2, 0x34, 0x59,
-	0x20, 0x5b, 0x26, 0x6d,
-	0xfc, 0x42, 0x12, 0x7d,
-	0x10, 0x40, 0x14, 0x6d,
-	0x20, 0x4d, 0x16, 0x7d,
-	0x08, 0x5d, 0x26, 0x6d,
-	0x02, 0xa6, 0xc6, 0x6b,
-	0x00, 0xe2, 0x34, 0x59,
-	0x20, 0x5b, 0x26, 0x6d,
-	0x01, 0x1b, 0x46, 0x6d,
-	0xfc, 0x42, 0x22, 0x7d,
-	0x10, 0x40, 0x24, 0x6d,
-	0x20, 0x4d, 0x66, 0x7d,
-	0x08, 0x5d, 0x66, 0x7d,
-	0x02, 0x19, 0x32, 0x00,
-	0x01, 0x5b, 0x40, 0x31,
-	0x00, 0xe2, 0x96, 0x5c,
-	0x00, 0xe2, 0x8a, 0x5b,
-	0x20, 0xea, 0xb6, 0x00,
-	0x00, 0xe2, 0xc0, 0x5b,
-	0x20, 0x5c, 0xb8, 0x00,
-	0x04, 0x19, 0x3c, 0x6d,
-	0x01, 0x1a, 0x3c, 0x6d,
-	0x00, 0xe2, 0x34, 0x59,
-	0x01, 0x1a, 0x66, 0x7d,
-	0x80, 0xf9, 0xf2, 0x01,
-	0x20, 0xa0, 0xac, 0x7d,
-	0x08, 0xa8, 0x45, 0x7d,
-	0x00, 0xe2, 0x58, 0x45,
-	0x02, 0xea, 0xb4, 0x04,
-	0x02, 0x19, 0x32, 0x00,
-	0x08, 0xa8, 0x69, 0x7d,
-	0x04, 0x5d, 0xc2, 0x7d,
-	0x01, 0x1a, 0xc2, 0x7d,
-	0x01, 0xa4, 0x49, 0x03,
-	0x80, 0xf9, 0xf2, 0x01,
-	0x02, 0xa8, 0x84, 0x32,
-	0x02, 0xea, 0xb4, 0x00,
-	0x00, 0xe2, 0x34, 0x43,
-	0x02, 0xa8, 0x84, 0x32,
-	0x02, 0xea, 0xb4, 0x00,
-	0xff, 0xea, 0xd4, 0x19,
-	0x00, 0xe2, 0x40, 0x59,
-	0x11, 0x00, 0x00, 0x10,
-	0x00, 0xe2, 0x98, 0x5d,
-	0x00, 0xe2, 0x34, 0x53,
-	0xff, 0xea, 0xd4, 0x0d,
-	0x00, 0xe2, 0x34, 0x59,
-	0x40, 0x5b, 0x74, 0x6d,
-	0x04, 0x5d, 0xc2, 0x7d,
-	0x01, 0x1a, 0xc2, 0x7d,
-	0x20, 0x4d, 0x66, 0x7d,
-	0x40, 0x5b, 0xac, 0x7d,
-	0x04, 0x5d, 0xc2, 0x7d,
-	0x01, 0x1a, 0xc2, 0x7d,
-	0x80, 0xf9, 0xf2, 0x01,
-	0x01, 0xa4, 0x49, 0x03,
-	0x08, 0xa8, 0x59, 0x6d,
-	0x02, 0xea, 0xb4, 0x04,
-	0xff, 0x6a, 0x8e, 0x7d,
-	0x10, 0xea, 0x46, 0x59,
-	0x10, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0x8e, 0x45,
-	0x00, 0xe2, 0x32, 0x59,
-	0x10, 0x5d, 0x80, 0x6d,
-	0x40, 0x5b, 0x66, 0x7d,
-	0x02, 0x19, 0x32, 0x00,
-	0x80, 0xf9, 0xf2, 0x01,
-	0xff, 0xea, 0x10, 0x03,
-	0x08, 0xa8, 0x51, 0x03,
-	0x00, 0xe2, 0x58, 0x45,
-	0x80, 0xf9, 0x66, 0x6d,
-	0x01, 0x43, 0xc1, 0x31,
-	0x00, 0xfb, 0x66, 0x65,
-	0x01, 0x42, 0xc1, 0x31,
-	0x00, 0xfa, 0x66, 0x65,
-	0x01, 0xe8, 0xd4, 0x1d,
-	0x30, 0x3f, 0xc0, 0x09,
-	0x30, 0xe0, 0x66, 0x65,
-	0x40, 0x4b, 0x66, 0x6d,
-	0xff, 0xea, 0x52, 0x01,
-	0xee, 0x00, 0xb2, 0x6d,
-	0x80, 0xf9, 0xf2, 0x01,
-	0x02, 0xea, 0xb4, 0x00,
-	0x20, 0xea, 0x9a, 0x00,
-	0xf3, 0x42, 0xbc, 0x6d,
-	0x12, 0xea, 0x46, 0x59,
-	0x12, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xee, 0x41,
-	0x0d, 0xea, 0x46, 0x59,
-	0x0d, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0xee, 0x41,
-	0x11, 0xea, 0x46, 0x59,
-	0x11, 0xea, 0x04, 0x00,
-	0x00, 0xe2, 0x24, 0x5b,
-	0x08, 0x5a, 0xb4, 0x00,
-	0x00, 0xe2, 0xe4, 0x5d,
-	0xa8, 0xea, 0x32, 0x00,
-	0x00, 0xe2, 0x34, 0x59,
-	0x80, 0x1a, 0xd6, 0x7d,
-	0x00, 0xe2, 0xe4, 0x5d,
-	0x80, 0x19, 0x32, 0x00,
-	0x40, 0x5b, 0xdc, 0x6d,
-	0x08, 0x5a, 0xdc, 0x7d,
-	0x20, 0x4d, 0x66, 0x7d,
-	0x02, 0x84, 0x09, 0x03,
-	0x40, 0x5b, 0xac, 0x7d,
-	0x08, 0xa8, 0x51, 0x6d,
-	0x02, 0xea, 0xb4, 0x04,
-	0x01, 0x38, 0xe1, 0x30,
-	0x05, 0x39, 0xe3, 0x98,
-	0x01, 0xe0, 0xf8, 0x31,
-	0xff, 0xea, 0xc0, 0x09,
-	0x00, 0x3a, 0xe5, 0x20,
-	0x00, 0x3b, 0xe7, 0x20,
-	0x01, 0xfc, 0xc0, 0x31,
-	0x04, 0xea, 0xe8, 0x30,
-	0xff, 0xea, 0xf0, 0x08,
-	0x02, 0xea, 0xf2, 0x00,
-	0xff, 0xea, 0xf4, 0x0c
-};
-
-typedef int ahd_patch_func_t (struct ahd_softc *ahd);
-static ahd_patch_func_t ahd_patch18_func;
-
-static int
-ahd_patch18_func(struct ahd_softc *ahd)
-{
-	return ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0);
-}
-
-static ahd_patch_func_t ahd_patch17_func;
-
-static int
-ahd_patch17_func(struct ahd_softc *ahd)
-{
-	return ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) == 0);
-}
-
-static ahd_patch_func_t ahd_patch16_func;
-
-static int
-ahd_patch16_func(struct ahd_softc *ahd)
-{
-	return ((ahd->flags & AHD_INITIATORROLE) != 0);
-}
-
-static ahd_patch_func_t ahd_patch15_func;
-
-static int
-ahd_patch15_func(struct ahd_softc *ahd)
-{
-	return ((ahd->flags & AHD_TARGETROLE) != 0);
-}
-
-static ahd_patch_func_t ahd_patch14_func;
-
-static int
-ahd_patch14_func(struct ahd_softc *ahd)
-{
-	return ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0);
-}
-
-static ahd_patch_func_t ahd_patch13_func;
-
-static int
-ahd_patch13_func(struct ahd_softc *ahd)
-{
-	return ((ahd->features & AHD_NEW_DFCNTRL_OPTS) != 0);
-}
-
-static ahd_patch_func_t ahd_patch12_func;
-
-static int
-ahd_patch12_func(struct ahd_softc *ahd)
-{
-	return ((ahd->flags & AHD_39BIT_ADDRESSING) != 0);
-}
-
-static ahd_patch_func_t ahd_patch11_func;
-
-static int
-ahd_patch11_func(struct ahd_softc *ahd)
-{
-	return ((ahd->flags & AHD_64BIT_ADDRESSING) != 0);
-}
-
-static ahd_patch_func_t ahd_patch10_func;
-
-static int
-ahd_patch10_func(struct ahd_softc *ahd)
-{
-	return ((ahd->bugs & AHD_REG_SLOW_SETTLE_BUG) != 0);
-}
-
-static ahd_patch_func_t ahd_patch9_func;
-
-static int
-ahd_patch9_func(struct ahd_softc *ahd)
-{
-	return ((ahd->bugs & AHD_BUSFREEREV_BUG) == 0);
-}
-
-static ahd_patch_func_t ahd_patch8_func;
-
-static int
-ahd_patch8_func(struct ahd_softc *ahd)
-{
-	return ((ahd->bugs & AHD_ABORT_LQI_BUG) == 0);
-}
-
-static ahd_patch_func_t ahd_patch7_func;
-
-static int
-ahd_patch7_func(struct ahd_softc *ahd)
-{
-	return ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0);
-}
-
-static ahd_patch_func_t ahd_patch6_func;
-
-static int
-ahd_patch6_func(struct ahd_softc *ahd)
-{
-	return ((ahd->bugs & AHD_LQO_ATNO_BUG) != 0);
-}
-
-static ahd_patch_func_t ahd_patch5_func;
-
-static int
-ahd_patch5_func(struct ahd_softc *ahd)
-{
-	return ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0);
-}
-
-static ahd_patch_func_t ahd_patch4_func;
-
-static int
-ahd_patch4_func(struct ahd_softc *ahd)
-{
-	return ((ahd->bugs & AHD_NONPACKFIFO_BUG) != 0);
-}
-
-static ahd_patch_func_t ahd_patch3_func;
-
-static int
-ahd_patch3_func(struct ahd_softc *ahd)
-{
-	return ((ahd->bugs & AHD_SENT_SCB_UPDATE_BUG) != 0);
-}
-
-static ahd_patch_func_t ahd_patch2_func;
-
-static int
-ahd_patch2_func(struct ahd_softc *ahd)
-{
-	return ((ahd->bugs & AHD_SET_MODE_BUG) != 0);
-}
-
-static ahd_patch_func_t ahd_patch1_func;
-
-static int
-ahd_patch1_func(struct ahd_softc *ahd)
-{
-	return ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0);
-}
-
-static ahd_patch_func_t ahd_patch0_func;
-
-static int
-ahd_patch0_func(struct ahd_softc *ahd)
-{
-	return (0);
-}
-
-static struct patch {
-	ahd_patch_func_t		*patch_func;
-	uint32_t		 begin		:10,
-				 skip_instr	:10,
-				 skip_patch	:12;
-} patches[] = {
-	{ ahd_patch1_func, 0, 3, 3 },
-	{ ahd_patch1_func, 1, 1, 2 },
-	{ ahd_patch0_func, 2, 1, 1 },
-	{ ahd_patch1_func, 3, 3, 3 },
-	{ ahd_patch1_func, 4, 1, 2 },
-	{ ahd_patch0_func, 5, 1, 1 },
-	{ ahd_patch2_func, 6, 1, 2 },
-	{ ahd_patch0_func, 7, 1, 1 },
-	{ ahd_patch2_func, 24, 1, 2 },
-	{ ahd_patch0_func, 25, 1, 1 },
-	{ ahd_patch1_func, 32, 1, 2 },
-	{ ahd_patch0_func, 33, 1, 1 },
-	{ ahd_patch2_func, 40, 1, 2 },
-	{ ahd_patch0_func, 41, 1, 1 },
-	{ ahd_patch2_func, 44, 1, 2 },
-	{ ahd_patch0_func, 45, 1, 1 },
-	{ ahd_patch2_func, 48, 1, 2 },
-	{ ahd_patch0_func, 49, 1, 1 },
-	{ ahd_patch2_func, 51, 1, 2 },
-	{ ahd_patch0_func, 52, 1, 1 },
-	{ ahd_patch2_func, 55, 1, 2 },
-	{ ahd_patch0_func, 56, 1, 1 },
-	{ ahd_patch2_func, 59, 1, 2 },
-	{ ahd_patch0_func, 60, 1, 1 },
-	{ ahd_patch2_func, 157, 6, 1 },
-	{ ahd_patch1_func, 163, 2, 1 },
-	{ ahd_patch3_func, 165, 1, 1 },
-	{ ahd_patch2_func, 174, 1, 2 },
-	{ ahd_patch0_func, 175, 1, 1 },
-	{ ahd_patch4_func, 176, 2, 2 },
-	{ ahd_patch0_func, 178, 6, 3 },
-	{ ahd_patch2_func, 181, 1, 2 },
-	{ ahd_patch0_func, 182, 1, 1 },
-	{ ahd_patch2_func, 185, 1, 2 },
-	{ ahd_patch0_func, 186, 1, 1 },
-	{ ahd_patch5_func, 188, 2, 1 },
-	{ ahd_patch3_func, 196, 16, 2 },
-	{ ahd_patch0_func, 212, 1, 1 },
-	{ ahd_patch6_func, 232, 2, 1 },
-	{ ahd_patch1_func, 236, 1, 2 },
-	{ ahd_patch0_func, 237, 1, 1 },
-	{ ahd_patch5_func, 240, 2, 1 },
-	{ ahd_patch1_func, 254, 1, 2 },
-	{ ahd_patch0_func, 255, 1, 1 },
-	{ ahd_patch1_func, 258, 1, 2 },
-	{ ahd_patch0_func, 259, 1, 1 },
-	{ ahd_patch2_func, 262, 1, 2 },
-	{ ahd_patch0_func, 263, 1, 1 },
-	{ ahd_patch1_func, 318, 1, 2 },
-	{ ahd_patch0_func, 319, 1, 1 },
-	{ ahd_patch2_func, 327, 1, 2 },
-	{ ahd_patch0_func, 328, 1, 1 },
-	{ ahd_patch2_func, 331, 1, 2 },
-	{ ahd_patch0_func, 332, 1, 1 },
-	{ ahd_patch1_func, 339, 1, 2 },
-	{ ahd_patch0_func, 340, 1, 1 },
-	{ ahd_patch7_func, 359, 1, 1 },
-	{ ahd_patch7_func, 362, 1, 1 },
-	{ ahd_patch7_func, 364, 1, 1 },
-	{ ahd_patch7_func, 376, 1, 1 },
-	{ ahd_patch1_func, 386, 1, 2 },
-	{ ahd_patch0_func, 387, 1, 1 },
-	{ ahd_patch1_func, 389, 1, 2 },
-	{ ahd_patch0_func, 390, 1, 1 },
-	{ ahd_patch1_func, 398, 1, 2 },
-	{ ahd_patch0_func, 399, 1, 1 },
-	{ ahd_patch2_func, 410, 1, 2 },
-	{ ahd_patch0_func, 411, 1, 1 },
-	{ ahd_patch8_func, 413, 1, 1 },
-	{ ahd_patch9_func, 440, 1, 1 },
-	{ ahd_patch1_func, 447, 1, 2 },
-	{ ahd_patch0_func, 448, 1, 1 },
-	{ ahd_patch2_func, 460, 1, 2 },
-	{ ahd_patch0_func, 461, 1, 1 },
-	{ ahd_patch10_func, 489, 1, 1 },
-	{ ahd_patch11_func, 498, 1, 2 },
-	{ ahd_patch0_func, 499, 1, 1 },
-	{ ahd_patch12_func, 504, 1, 1 },
-	{ ahd_patch11_func, 505, 1, 1 },
-	{ ahd_patch13_func, 518, 1, 2 },
-	{ ahd_patch0_func, 519, 1, 1 },
-	{ ahd_patch1_func, 541, 1, 2 },
-	{ ahd_patch0_func, 542, 1, 1 },
-	{ ahd_patch1_func, 545, 1, 2 },
-	{ ahd_patch0_func, 546, 1, 1 },
-	{ ahd_patch2_func, 551, 1, 2 },
-	{ ahd_patch0_func, 552, 1, 1 },
-	{ ahd_patch2_func, 556, 1, 2 },
-	{ ahd_patch0_func, 557, 1, 1 },
-	{ ahd_patch1_func, 558, 1, 2 },
-	{ ahd_patch0_func, 559, 1, 1 },
-	{ ahd_patch2_func, 570, 1, 2 },
-	{ ahd_patch0_func, 571, 1, 1 },
-	{ ahd_patch14_func, 575, 1, 1 },
-	{ ahd_patch15_func, 580, 1, 1 },
-	{ ahd_patch16_func, 581, 2, 1 },
-	{ ahd_patch15_func, 585, 1, 2 },
-	{ ahd_patch0_func, 586, 1, 1 },
-	{ ahd_patch2_func, 593, 1, 2 },
-	{ ahd_patch0_func, 594, 1, 1 },
-	{ ahd_patch2_func, 609, 1, 2 },
-	{ ahd_patch0_func, 610, 1, 1 },
-	{ ahd_patch1_func, 616, 1, 2 },
-	{ ahd_patch0_func, 617, 1, 1 },
-	{ ahd_patch1_func, 631, 1, 2 },
-	{ ahd_patch0_func, 632, 1, 1 },
-	{ ahd_patch1_func, 639, 1, 2 },
-	{ ahd_patch0_func, 640, 1, 1 },
-	{ ahd_patch14_func, 659, 1, 1 },
-	{ ahd_patch14_func, 675, 1, 1 },
-	{ ahd_patch2_func, 687, 1, 2 },
-	{ ahd_patch0_func, 688, 1, 1 },
-	{ ahd_patch1_func, 705, 1, 2 },
-	{ ahd_patch0_func, 706, 1, 1 },
-	{ ahd_patch14_func, 711, 1, 1 },
-	{ ahd_patch1_func, 731, 1, 2 },
-	{ ahd_patch0_func, 732, 1, 1 },
-	{ ahd_patch1_func, 734, 1, 2 },
-	{ ahd_patch0_func, 735, 1, 1 },
-	{ ahd_patch1_func, 737, 1, 2 },
-	{ ahd_patch0_func, 738, 1, 1 },
-	{ ahd_patch17_func, 740, 1, 2 },
-	{ ahd_patch0_func, 741, 2, 1 },
-	{ ahd_patch18_func, 744, 4, 2 },
-	{ ahd_patch0_func, 748, 1, 1 },
-	{ ahd_patch18_func, 754, 11, 1 }
-};
-
-static struct cs {
-	uint16_t	begin;
-	uint16_t	end;
-} critical_sections[] = {
-	{ 11, 12 },
-	{ 13, 14 },
-	{ 24, 37 },
-	{ 38, 51 },
-	{ 64, 67 },
-	{ 94, 119 },
-	{ 120, 151 },
-	{ 153, 157 },
-	{ 165, 173 },
-	{ 196, 245 },
-	{ 659, 675 },
-	{ 675, 693 },
-	{ 698, 704 },
-	{ 711, 716 },
-	{ 716, 722 }
-};
-
-static const int num_critical_sections = sizeof(critical_sections)
-				       / sizeof(*critical_sections);
diff -urNp linux-5720/drivers/scsi/aic79xx/aicasm/Makefile linux-5730/drivers/scsi/aic79xx/aicasm/Makefile
--- linux-5720/drivers/scsi/aic79xx/aicasm/Makefile
+++ linux-5730/drivers/scsi/aic79xx/aicasm/Makefile
@@ -1,65 +0,0 @@
-PROG=	aicasm
-
-.SUFFIXES= .l .y .c .h
-
-CSRCS=	aicasm.c aicasm_symbol.c
-YSRCS=	aicasm_gram.y aicasm_macro_gram.y
-LSRCS=	aicasm_scan.l aicasm_macro_scan.l
-
-GENHDRS=	aicdb.h $(YSRCS:.y=.h)
-GENSRCS=	$(YSRCS:.y=.c) $(LSRCS:.l=.c)
-
-SRCS=	${CSRCS} ${GENSRCS}
-CLEANFILES= ${GENSRCS} ${GENHDRS} $(YSRCS:.y=.output)
-# Override default kernel CFLAGS.  This is a userland app.
-AICASM_CFLAGS:= -I/usr/include -I. -ldb
-YFLAGS= -d
-
-NOMAN=	noman
-
-ifneq ($(HOSTCC),)
-AICASM_CC= $(HOSTCC)
-else
-AICASM_CC= $(CC)
-endif
-
-ifdef DEBUG
-CFLAGS+= -DDEBUG -g
-YFLAGS+= -t -v
-LFLAGS= -d
-endif
-
-$(PROG):  ${GENHDRS} $(SRCS)
-	$(AICASM_CC) $(AICASM_CFLAGS) $(SRCS) -o $(PROG)
-
-aicdb.h:
-	@if [ -e "/usr/include/db3/db_185.h" ]; then		\
-		echo "#include <db3/db_185.h>" > aicdb.h;	\
-	 elif [ -e "/usr/include/db2/db_185.h" ]; then		\
-		echo "#include <db2/db_185.h>" > aicdb.h;	\
-	 elif [ -e "/usr/include/db/db_185.h" ]; then		\
-		echo "#include <db/db_185.h>" > aicdb.h;	\
-	 elif [ -e "/usr/include/db_185.h" ]; then		\
-		echo "#include <db_185.h>" > aicdb.h;		\
-	 else							\
-		echo "*** Install db development libraries";	\
-	 fi
-
-clean:
-	rm -f $(CLEANFILES) $(PROG)
-
-aicasm_gram.c aicasm_gram.h: aicasm_gram.y
-	$(YACC) $(YFLAGS) -b $(<:.y=) $<
-	mv $(<:.y=).tab.c $(<:.y=.c)
-	mv $(<:.y=).tab.h $(<:.y=.h)
-
-aicasm_macro_gram.c aicasm_macro_gram.h: aicasm_macro_gram.y
-	$(YACC) $(YFLAGS) -b $(<:.y=) -p mm $<
-	mv $(<:.y=).tab.c $(<:.y=.c)
-	mv $(<:.y=).tab.h $(<:.y=.h)
-
-aicasm_scan.c: aicasm_scan.l
-	$(LEX) $(LFLAGS) -o$@ $<
-
-aicasm_macro_scan.c: aicasm_macro_scan.l
-	$(LEX) $(LFLAGS) -Pmm -o$@ $<
diff -urNp linux-5720/drivers/scsi/aic79xx/aicasm/aicasm.c linux-5730/drivers/scsi/aic79xx/aicasm/aicasm.c
--- linux-5720/drivers/scsi/aic79xx/aicasm/aicasm.c
+++ linux-5730/drivers/scsi/aic79xx/aicasm/aicasm.c
@@ -1,835 +0,0 @@
-/*
- * Aic7xxx SCSI host adapter firmware asssembler
- *
- * Copyright (c) 1997, 1998, 2000, 2001 Justin T. Gibbs.
- * Copyright (c) 2001, 2002 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#22 $
- *
- * $FreeBSD$
- */
-#include <sys/types.h>
-#include <sys/mman.h>
-
-#include <ctype.h>
-#include <inttypes.h>
-#include <regex.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sysexits.h>
-#include <unistd.h>
-
-#if linux
-#include <endian.h>
-#else
-#include <machine/endian.h>
-#endif
-
-#include "aicasm.h"
-#include "aicasm_symbol.h"
-#include "aicasm_insformat.h"
-
-typedef struct patch {
-	STAILQ_ENTRY(patch) links;
-	int		patch_func;
-	u_int		begin;
-	u_int		skip_instr;
-	u_int		skip_patch;
-} patch_t;
-
-STAILQ_HEAD(patch_list, patch) patches;
-
-static void usage(void);
-static void back_patch(void);
-static void output_code(void);
-static void output_listing(char *ifilename);
-static void dump_scope(scope_t *scope);
-static void emit_patch(scope_t *scope, int patch);
-static int check_patch(patch_t **start_patch, int start_instr,
-		       int *skip_addr, int *func_vals);
-
-struct path_list search_path;
-int includes_search_curdir;
-char *appname;
-char *stock_include_file;
-FILE *ofile;
-char *ofilename;
-char *regfilename;
-FILE *regfile;
-char *listfilename;
-FILE *listfile;
-char *regdiagfilename;
-FILE *regdiagfile;
-int   src_mode;
-int   dst_mode;
-
-static STAILQ_HEAD(,instruction) seq_program;
-struct cs_tailq cs_tailq;
-struct scope_list scope_stack;
-symlist_t patch_functions;
-
-#if DEBUG
-extern int yy_flex_debug;
-extern int mm_flex_debug;
-extern int yydebug;
-extern int mmdebug;
-#endif
-extern FILE *yyin;
-extern int yyparse(void);
-
-int main(int argc, char *argv[]);
-
-int
-main(int argc, char *argv[])
-{
-	extern char *optarg;
-	extern int optind;
-	int  ch;
-	int  retval;
-	char *inputfilename;
-	scope_t *sentinal;
-
-	STAILQ_INIT(&patches);
-	SLIST_INIT(&search_path);
-	STAILQ_INIT(&seq_program);
-	TAILQ_INIT(&cs_tailq);
-	SLIST_INIT(&scope_stack);
-
-	/* Set Sentinal scope node */
-	sentinal = scope_alloc();
-	sentinal->type = SCOPE_ROOT;
-	
-	includes_search_curdir = 1;
-	appname = *argv;
-	regfile = NULL;
-	listfile = NULL;
-#if DEBUG
-	yy_flex_debug = 0;
-	mm_flex_debug = 0;
-	yydebug = 0;
-	mmdebug = 0;
-#endif
-	while ((ch = getopt(argc, argv, "d:i:l:n:o:p:r:I:")) != -1) {
-		switch(ch) {
-		case 'd':
-#if DEBUG
-			if (strcmp(optarg, "s") == 0) {
-				yy_flex_debug = 1;
-				mm_flex_debug = 1;
-			} else if (strcmp(optarg, "p") == 0) {
-				yydebug = 1;
-				mmdebug = 1;
-			} else {
-				fprintf(stderr, "%s: -d Requires either an "
-					"'s' or 'p' argument\n", appname);
-				usage();
-			}
-#else
-			stop("-d: Assembler not built with debugging "
-			     "information", EX_SOFTWARE);
-#endif
-			break;
-		case 'i':
-			stock_include_file = optarg;
-			break;
-		case 'l':
-			/* Create a program listing */
-			if ((listfile = fopen(optarg, "w")) == NULL) {
-				perror(optarg);
-				stop(NULL, EX_CANTCREAT);
-			}
-			listfilename = optarg;
-			break;
-		case 'n':
-			/* Don't complain about the -nostdinc directrive */
-			if (strcmp(optarg, "ostdinc")) {
-				fprintf(stderr, "%s: Unknown option -%c%s\n",
-					appname, ch, optarg);
-				usage();
-				/* NOTREACHED */
-			}
-			break;
-		case 'o':
-			if ((ofile = fopen(optarg, "w")) == NULL) {
-				perror(optarg);
-				stop(NULL, EX_CANTCREAT);
-			}
-			ofilename = optarg;
-			break;
-		case 'p':
-			/* Create Register Diagnostic "printing" Functions */
-			if ((regdiagfile = fopen(optarg, "w")) == NULL) {
-				perror(optarg);
-				stop(NULL, EX_CANTCREAT);
-			}
-			regdiagfilename = optarg;
-			break;
-		case 'r':
-			if ((regfile = fopen(optarg, "w")) == NULL) {
-				perror(optarg);
-				stop(NULL, EX_CANTCREAT);
-			}
-			regfilename = optarg;
-			break;
-		case 'I':
-		{
-			path_entry_t include_dir;
-
-			if (strcmp(optarg, "-") == 0) {
-				if (includes_search_curdir == 0) {
-					fprintf(stderr, "%s: Warning - '-I-' "
-							"specified multiple "
-							"times\n", appname);
-				}
-				includes_search_curdir = 0;
-				for (include_dir = SLIST_FIRST(&search_path);
-				     include_dir != NULL;
-				     include_dir = SLIST_NEXT(include_dir,
-							      links))
-					/*
-					 * All entries before a '-I-' only
-					 * apply to includes specified with
-					 * quotes instead of "<>".
-					 */
-					include_dir->quoted_includes_only = 1;
-			} else {
-				include_dir =
-				    (path_entry_t)malloc(sizeof(*include_dir));
-				if (include_dir == NULL) {
-					perror(optarg);
-					stop(NULL, EX_OSERR);
-				}
-				include_dir->directory = strdup(optarg);
-				if (include_dir->directory == NULL) {
-					perror(optarg);
-					stop(NULL, EX_OSERR);
-				}
-				include_dir->quoted_includes_only = 0;
-				SLIST_INSERT_HEAD(&search_path, include_dir,
-						  links);
-			}
-			break;
-		}
-		case '?':
-		default:
-			usage();
-			/* NOTREACHED */
-		}
-	}
-	argc -= optind;
-	argv += optind;
-
-	if (argc != 1) {
-		fprintf(stderr, "%s: No input file specifiled\n", appname);
-		usage();
-		/* NOTREACHED */
-	}
-
-	if (regdiagfile != NULL
-	 && (regfile == NULL || stock_include_file == NULL)) {
-		fprintf(stderr,
-			"%s: The -p option requires the -r and -i options.\n",
-			appname);
-		usage();
-		/* NOTREACHED */
-	}
-	symtable_open();
-	inputfilename = *argv;
-	include_file(*argv, SOURCE_FILE);
-	retval = yyparse();
-	if (retval == 0) {
-		if (SLIST_FIRST(&scope_stack) == NULL
-		 || SLIST_FIRST(&scope_stack)->type != SCOPE_ROOT) {
-			stop("Unterminated conditional expression", EX_DATAERR);
-			/* NOTREACHED */
-		}
-
-		/* Process outmost scope */
-		process_scope(SLIST_FIRST(&scope_stack));
-		/*
-		 * Decend the tree of scopes and insert/emit
-		 * patches as appropriate.  We perform a depth first
-		 * tranversal, recursively handling each scope.
-		 */
-		/* start at the root scope */
-		dump_scope(SLIST_FIRST(&scope_stack));
-
-		/* Patch up forward jump addresses */
-		back_patch();
-
-		if (ofile != NULL)
-			output_code();
-		if (regfile != NULL)
-			symtable_dump(regfile, regdiagfile);
-		if (listfile != NULL)
-			output_listing(inputfilename);
-	}
-
-	stop(NULL, 0);
-	/* NOTREACHED */
-	return (0);
-}
-
-static void
-usage()
-{
-
-	(void)fprintf(stderr,
-"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]\n"
-"	[-r register_output_file [-p register_diag_file -i includefile]]\n"
-"	[-l program_list_file]\n"
-"	input_file\n", appname);
-	exit(EX_USAGE);
-}
-
-static void
-back_patch()
-{
-	struct instruction *cur_instr;
-
-	for (cur_instr = STAILQ_FIRST(&seq_program);
-	     cur_instr != NULL;
-	     cur_instr = STAILQ_NEXT(cur_instr, links)) {
-		if (cur_instr->patch_label != NULL) {
-			struct ins_format3 *f3_instr;
-			u_int address;
-
-			if (cur_instr->patch_label->type != LABEL) {
-				char buf[255];
-
-				snprintf(buf, sizeof(buf),
-					 "Undefined label %s",
-					 cur_instr->patch_label->name);
-				stop(buf, EX_DATAERR);
-				/* NOTREACHED */
-			}
-			f3_instr = &cur_instr->format.format3;
-			address = f3_instr->address;
-			address += cur_instr->patch_label->info.linfo->address;
-			f3_instr->address = address;
-		}
-	}
-}
-
-static void
-output_code()
-{
-	struct instruction *cur_instr;
-	patch_t *cur_patch;
-	critical_section_t *cs;
-	symbol_node_t *cur_node;
-	int instrcount;
-
-	instrcount = 0;
-	fprintf(ofile,
-"/*\n"
-" * DO NOT EDIT - This file is automatically generated\n"
-" *		 from the following source files:\n"
-" *\n"
-"%s */\n", versions);
-
-	fprintf(ofile, "static uint8_t seqprog[] = {\n");
-	for (cur_instr = STAILQ_FIRST(&seq_program);
-	     cur_instr != NULL;
-	     cur_instr = STAILQ_NEXT(cur_instr, links)) {
-
-		fprintf(ofile, "%s\t0x%02x, 0x%02x, 0x%02x, 0x%02x",
-			cur_instr == STAILQ_FIRST(&seq_program) ? "" : ",\n",
-#if BYTE_ORDER == LITTLE_ENDIAN
-			cur_instr->format.bytes[0],
-			cur_instr->format.bytes[1],
-			cur_instr->format.bytes[2],
-			cur_instr->format.bytes[3]);
-#else
-			cur_instr->format.bytes[3],
-			cur_instr->format.bytes[2],
-			cur_instr->format.bytes[1],
-			cur_instr->format.bytes[0]);
-#endif
-		instrcount++;
-	}
-	fprintf(ofile, "\n};\n\n");
-
-	if (patch_arg_list == NULL)
-		stop("Patch argument list not defined",
-		     EX_DATAERR);
-
-	/*
-	 *  Output patch information.  Patch functions first.
-	 */
-	fprintf(ofile,
-"typedef int %spatch_func_t (%s);\n", prefix, patch_arg_list);
-
-	for (cur_node = SLIST_FIRST(&patch_functions);
-	     cur_node != NULL;
-	     cur_node = SLIST_NEXT(cur_node,links)) {
-		fprintf(ofile,
-"static %spatch_func_t %spatch%d_func;\n"
-"\n"
-"static int\n"
-"%spatch%d_func(%s)\n"
-"{\n"
-"	return (%s);\n"
-"}\n\n",
-			prefix,
-			prefix,
-			cur_node->symbol->info.condinfo->func_num,
-			prefix,
-			cur_node->symbol->info.condinfo->func_num,
-			patch_arg_list,
-			cur_node->symbol->name);
-	}
-
-	fprintf(ofile,
-"static struct patch {\n"
-"	%spatch_func_t		*patch_func;\n"
-"	uint32_t		 begin		:10,\n"
-"				 skip_instr	:10,\n"
-"				 skip_patch	:12;\n"
-"} patches[] = {\n", prefix);
-
-	for (cur_patch = STAILQ_FIRST(&patches);
-	     cur_patch != NULL;
-	     cur_patch = STAILQ_NEXT(cur_patch,links)) {
-		fprintf(ofile, "%s\t{ %spatch%d_func, %d, %d, %d }",
-			cur_patch == STAILQ_FIRST(&patches) ? "" : ",\n",
-			prefix,
-			cur_patch->patch_func, cur_patch->begin,
-			cur_patch->skip_instr, cur_patch->skip_patch);
-	}
-
-	fprintf(ofile, "\n};\n\n");
-
-	fprintf(ofile,
-"static struct cs {\n"
-"	uint16_t	begin;\n"
-"	uint16_t	end;\n"
-"} critical_sections[] = {\n");
-
-	for (cs = TAILQ_FIRST(&cs_tailq);
-	     cs != NULL;
-	     cs = TAILQ_NEXT(cs, links)) {
-		fprintf(ofile, "%s\t{ %d, %d }",
-			cs == TAILQ_FIRST(&cs_tailq) ? "" : ",\n",
-			cs->begin_addr, cs->end_addr);
-	}
-
-	fprintf(ofile, "\n};\n\n");
-
-	fprintf(ofile,
-"static const int num_critical_sections = sizeof(critical_sections)\n"
-"				       / sizeof(*critical_sections);\n");
-
-	fprintf(stderr, "%s: %d instructions used\n", appname, instrcount);
-}
-
-static void
-dump_scope(scope_t *scope)
-{
-	scope_t *cur_scope;
-
-	/*
-	 * Emit the first patch for this scope
-	 */
-	emit_patch(scope, 0);
-
-	/*
-	 * Dump each scope within this one.
-	 */
-	cur_scope = TAILQ_FIRST(&scope->inner_scope);
-
-	while (cur_scope != NULL) {
-
-		dump_scope(cur_scope);
-
-		cur_scope = TAILQ_NEXT(cur_scope, scope_links);
-	}
-
-	/*
-	 * Emit the second, closing, patch for this scope
-	 */
-	emit_patch(scope, 1);
-}
-
-void
-emit_patch(scope_t *scope, int patch)
-{
-	patch_info_t *pinfo;
-	patch_t *new_patch;
-
-	pinfo = &scope->patches[patch];
-
-	if (pinfo->skip_instr == 0)
-		/* No-Op patch */
-		return;
-
-	new_patch = (patch_t *)malloc(sizeof(*new_patch));
-
-	if (new_patch == NULL)
-		stop("Could not malloc patch structure", EX_OSERR);
-
-	memset(new_patch, 0, sizeof(*new_patch));
-
-	if (patch == 0) {
-		new_patch->patch_func = scope->func_num;
-		new_patch->begin = scope->begin_addr;
-	} else {
-		new_patch->patch_func = 0;
-		new_patch->begin = scope->end_addr;
-	}
-	new_patch->skip_instr = pinfo->skip_instr;
-	new_patch->skip_patch = pinfo->skip_patch;
-	STAILQ_INSERT_TAIL(&patches, new_patch, links);
-}
-
-void
-output_listing(char *ifilename)
-{
-	char buf[1024];
-	FILE *ifile;
-	struct instruction *cur_instr;
-	patch_t *cur_patch;
-	symbol_node_t *cur_func;
-	int *func_values;
-	int instrcount;
-	int instrptr;
-	int line;
-	int func_count;
-	int skip_addr;
-
-	instrcount = 0;
-	instrptr = 0;
-	line = 1;
-	skip_addr = 0;
-	if ((ifile = fopen(ifilename, "r")) == NULL) {
-		perror(ifilename);
-		stop(NULL, EX_DATAERR);
-	}
-
-	/*
-	 * Determine which options to apply to this listing.
-	 */
-	for (func_count = 0, cur_func = SLIST_FIRST(&patch_functions);
-	    cur_func != NULL;
-	    cur_func = SLIST_NEXT(cur_func, links))
-		func_count++;
-
-	func_values = NULL;
-	if (func_count != 0) {
-		func_values = (int *)malloc(func_count * sizeof(int));
-
-		if (func_values == NULL)
-			stop("Could not malloc", EX_OSERR);
-		
-		func_values[0] = 0; /* FALSE func */
-		func_count--;
-
-		/*
-		 * Ask the user to fill in the return values for
-		 * the rest of the functions.
-		 */
-		
-		
-		for (cur_func = SLIST_FIRST(&patch_functions);
-		     cur_func != NULL && SLIST_NEXT(cur_func, links) != NULL;
-		     cur_func = SLIST_NEXT(cur_func, links), func_count--) {
-			int input;
-			
-			fprintf(stdout, "\n(%s)\n", cur_func->symbol->name);
-			fprintf(stdout,
-				"Enter the return value for "
-				"this expression[T/F]:");
-
-			while (1) {
-
-				input = getchar();
-				input = toupper(input);
-
-				if (input == 'T') {
-					func_values[func_count] = 1;
-					break;
-				} else if (input == 'F') {
-					func_values[func_count] = 0;
-					break;
-				}
-			}
-			if (isatty(fileno(stdin)) == 0)
-				putchar(input);
-		}
-		fprintf(stdout, "\nThanks!\n");
-	}
-
-	/* Now output the listing */
-	cur_patch = STAILQ_FIRST(&patches);
-	for (cur_instr = STAILQ_FIRST(&seq_program);
-	     cur_instr != NULL;
-	     cur_instr = STAILQ_NEXT(cur_instr, links), instrcount++) {
-
-		if (check_patch(&cur_patch, instrcount,
-				&skip_addr, func_values) == 0) {
-			/* Don't count this instruction as it is in a patch
-			 * that was removed.
-			 */
-                        continue;
-		}
-
-		while (line < cur_instr->srcline) {
-			fgets(buf, sizeof(buf), ifile);
-				fprintf(listfile, "\t\t%s", buf);
-				line++;
-		}
-		fprintf(listfile, "%03x %02x%02x%02x%02x", instrptr,
-#if BYTE_ORDER == LITTLE_ENDIAN
-			cur_instr->format.bytes[0],
-			cur_instr->format.bytes[1],
-			cur_instr->format.bytes[2],
-			cur_instr->format.bytes[3]);
-#else
-			cur_instr->format.bytes[3],
-			cur_instr->format.bytes[2],
-			cur_instr->format.bytes[1],
-			cur_instr->format.bytes[0]);
-#endif
-		fgets(buf, sizeof(buf), ifile);
-		fprintf(listfile, "\t%s", buf);
-		line++;
-		instrptr++;
-	}
-	/* Dump the remainder of the file */
-	while(fgets(buf, sizeof(buf), ifile) != NULL)
-		fprintf(listfile, "\t\t%s", buf);
-
-	fclose(ifile);
-}
-
-static int
-check_patch(patch_t **start_patch, int start_instr,
-	    int *skip_addr, int *func_vals)
-{
-	patch_t *cur_patch;
-
-	cur_patch = *start_patch;
-
-	while (cur_patch != NULL && start_instr == cur_patch->begin) {
-		if (func_vals[cur_patch->patch_func] == 0) {
-			int skip;
-
-			/* Start rejecting code */
-			*skip_addr = start_instr + cur_patch->skip_instr;
-			for (skip = cur_patch->skip_patch;
-			     skip > 0 && cur_patch != NULL;
-			     skip--)
-				cur_patch = STAILQ_NEXT(cur_patch, links);
-		} else {
-			/* Accepted this patch.  Advance to the next
-			 * one and wait for our intruction pointer to
-			 * hit this point.
-			 */
-			cur_patch = STAILQ_NEXT(cur_patch, links);
-		}
-	}
-
-	*start_patch = cur_patch;
-	if (start_instr < *skip_addr)
-		/* Still skipping */
-		return (0);
-
-	return (1);
-}
-
-/*
- * Print out error information if appropriate, and clean up before
- * terminating the program.
- */
-void
-stop(const char *string, int err_code)
-{
-	if (string != NULL) {
-		fprintf(stderr, "%s: ", appname);
-		if (yyfilename != NULL) {
-			fprintf(stderr, "Stopped at file %s, line %d - ",
-				yyfilename, yylineno);
-		}
-		fprintf(stderr, "%s\n", string);
-	}
-
-	if (ofile != NULL) {
-		fclose(ofile);
-		if (err_code != 0) {
-			fprintf(stderr, "%s: Removing %s due to error\n",
-				appname, ofilename);
-			unlink(ofilename);
-		}
-	}
-
-	if (regfile != NULL) {
-		fclose(regfile);
-		if (err_code != 0) {
-			fprintf(stderr, "%s: Removing %s due to error\n",
-				appname, regfilename);
-			unlink(regfilename);
-		}
-	}
-
-	if (listfile != NULL) {
-		fclose(listfile);
-		if (err_code != 0) {
-			fprintf(stderr, "%s: Removing %s due to error\n",
-				appname, listfilename);
-			unlink(listfilename);
-		}
-	}
-
-	symlist_free(&patch_functions);
-	symtable_close();
-
-	exit(err_code);
-}
-
-struct instruction *
-seq_alloc()
-{
-	struct instruction *new_instr;
-
-	new_instr = (struct instruction *)malloc(sizeof(struct instruction));
-	if (new_instr == NULL)
-		stop("Unable to malloc instruction object", EX_SOFTWARE);
-	memset(new_instr, 0, sizeof(*new_instr));
-	STAILQ_INSERT_TAIL(&seq_program, new_instr, links);
-	new_instr->srcline = yylineno;
-	return new_instr;
-}
-
-critical_section_t *
-cs_alloc()
-{
-	critical_section_t *new_cs;
-
-	new_cs= (critical_section_t *)malloc(sizeof(critical_section_t));
-	if (new_cs == NULL)
-		stop("Unable to malloc critical_section object", EX_SOFTWARE);
-	memset(new_cs, 0, sizeof(*new_cs));
-	
-	TAILQ_INSERT_TAIL(&cs_tailq, new_cs, links);
-	return new_cs;
-}
-
-scope_t *
-scope_alloc()
-{
-	scope_t *new_scope;
-
-	new_scope = (scope_t *)malloc(sizeof(scope_t));
-	if (new_scope == NULL)
-		stop("Unable to malloc scope object", EX_SOFTWARE);
-	memset(new_scope, 0, sizeof(*new_scope));
-	TAILQ_INIT(&new_scope->inner_scope);
-	
-	if (SLIST_FIRST(&scope_stack) != NULL) {
-		TAILQ_INSERT_TAIL(&SLIST_FIRST(&scope_stack)->inner_scope,
-				  new_scope, scope_links);
-	}
-	/* This patch is now the current scope */
-	SLIST_INSERT_HEAD(&scope_stack, new_scope, scope_stack_links);
-	return new_scope;
-}
-
-void
-process_scope(scope_t *scope)
-{
-	/*
-	 * We are "leaving" this scope.  We should now have
-	 * enough information to process the lists of scopes
-	 * we encapsulate.
-	 */
-	scope_t *cur_scope;
-	u_int skip_patch_count;
-	u_int skip_instr_count;
-
-	cur_scope = TAILQ_LAST(&scope->inner_scope, scope_tailq);
-	skip_patch_count = 0;
-	skip_instr_count = 0;
-	while (cur_scope != NULL) {
-		u_int patch0_patch_skip;
-
-		patch0_patch_skip = 0;
-		switch (cur_scope->type) {
-		case SCOPE_IF:
-		case SCOPE_ELSE_IF:
-			if (skip_instr_count != 0) {
-				/* Create a tail patch */
-				patch0_patch_skip++;
-				cur_scope->patches[1].skip_patch =
-				    skip_patch_count + 1;
-				cur_scope->patches[1].skip_instr =
-				    skip_instr_count;
-			}
-
-			/* Count Head patch */
-			patch0_patch_skip++;
-
-			/* Count any patches contained in our inner scope */
-			patch0_patch_skip += cur_scope->inner_scope_patches;
-
-			cur_scope->patches[0].skip_patch = patch0_patch_skip;
-			cur_scope->patches[0].skip_instr =
-			    cur_scope->end_addr - cur_scope->begin_addr;
-
-			skip_instr_count += cur_scope->patches[0].skip_instr;
-
-			skip_patch_count += patch0_patch_skip;
-			if (cur_scope->type == SCOPE_IF) {
-				scope->inner_scope_patches += skip_patch_count;
-				skip_patch_count = 0;
-			        skip_instr_count = 0;
-			}
-			break;
-		case SCOPE_ELSE:
-			/* Count any patches contained in our innter scope */
-			skip_patch_count += cur_scope->inner_scope_patches;
-
-			skip_instr_count += cur_scope->end_addr
-					  - cur_scope->begin_addr;
-			break;
-		case SCOPE_ROOT:
-			stop("Unexpected scope type encountered", EX_SOFTWARE);
-			/* NOTREACHED */
-		}
-
-		cur_scope = TAILQ_PREV(cur_scope, scope_tailq, scope_links);
-	}
-}
diff -urNp linux-5720/drivers/scsi/aic79xx/aicasm/aicasm.h linux-5730/drivers/scsi/aic79xx/aicasm/aicasm.h
--- linux-5720/drivers/scsi/aic79xx/aicasm/aicasm.h
+++ linux-5730/drivers/scsi/aic79xx/aicasm/aicasm.h
@@ -1,95 +0,0 @@
-/*
- * Assembler for the sequencer program downloaded to Aic7xxx SCSI host adapters
- *
- * Copyright (c) 1997 Justin T. Gibbs.
- * Copyright (c) 2001, 2002 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#14 $
- *
- * $FreeBSD$
- */
-
-#ifdef __linux__
-#include "../queue.h"
-#else
-#include <sys/queue.h>
-#endif
-
-#ifndef TRUE
-#define TRUE 1
-#endif
-
-#ifndef FALSE
-#define FALSE 0
-#endif
-
-typedef struct path_entry {
-	char	*directory;
-	int	quoted_includes_only;
-	SLIST_ENTRY(path_entry) links;
-} *path_entry_t;
-
-typedef enum {  
-	QUOTED_INCLUDE,
-	BRACKETED_INCLUDE,
-	SOURCE_FILE
-} include_type;
-
-SLIST_HEAD(path_list, path_entry);
-
-extern struct path_list search_path;
-extern struct cs_tailq cs_tailq;
-extern struct scope_list scope_stack;
-extern struct symlist patch_functions;
-extern int includes_search_curdir;		/* False if we've seen -I- */
-extern char *appname;
-extern char *stock_include_file;
-extern int yylineno;
-extern char *yyfilename;
-extern char *prefix;
-extern char *patch_arg_list;
-extern char *versions;
-extern int   src_mode;
-extern int   dst_mode;
-struct symbol;
-
-void stop(const char *errstring, int err_code);
-void include_file(char *file_name, include_type type);
-void expand_macro(struct symbol *macro_symbol);
-struct instruction *seq_alloc(void);
-struct critical_section *cs_alloc(void);
-struct scope *scope_alloc(void);
-void process_scope(struct scope *);
diff -urNp linux-5720/drivers/scsi/aic79xx/aicasm/aicasm_gram.y linux-5730/drivers/scsi/aic79xx/aicasm/aicasm_gram.y
--- linux-5720/drivers/scsi/aic79xx/aicasm/aicasm_gram.y
+++ linux-5730/drivers/scsi/aic79xx/aicasm/aicasm_gram.y
@@ -1,1945 +0,0 @@
-%{
-/*
- * Parser for the Aic7xxx SCSI Host adapter sequencer assembler.
- *
- * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
- * Copyright (c) 2001, 2002 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#29 $
- *
- * $FreeBSD$
- */
-
-#include <sys/types.h>
-
-#include <inttypes.h>
-#include <regex.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sysexits.h>
-
-#ifdef __linux__
-#include "../queue.h"
-#else
-#include <sys/queue.h>
-#endif
-
-#include "aicasm.h"
-#include "aicasm_symbol.h"
-#include "aicasm_insformat.h"
-
-int yylineno;
-char *yyfilename;
-char stock_prefix[] = "aic_";
-char *prefix = stock_prefix;
-char *patch_arg_list;
-char *versions;
-static char errbuf[255];
-static char regex_pattern[255];
-static symbol_t *cur_symbol;
-static symbol_t *field_symbol;
-static symbol_t *scb_or_sram_symbol;
-static symtype cur_symtype;
-static symbol_ref_t accumulator;
-static symbol_ref_t mode_ptr;
-static symbol_ref_t allones;
-static symbol_ref_t allzeros;
-static symbol_ref_t none;
-static symbol_ref_t sindex;
-static int instruction_ptr;
-static int num_srams;
-static int sram_or_scb_offset;
-static int download_constant_count;
-static int in_critical_section;
-static u_int enum_increment;
-static u_int enum_next_value;
-
-static void process_field(int field_type, symbol_t *sym, int mask);
-static void initialize_symbol(symbol_t *symbol);
-static void add_macro_arg(const char *argtext, int position);
-static void add_macro_body(const char *bodytext);
-static void process_register(symbol_t **p_symbol);
-static void format_1_instr(int opcode, symbol_ref_t *dest,
-			   expression_t *immed, symbol_ref_t *src, int ret);
-static void format_2_instr(int opcode, symbol_ref_t *dest,
-			   expression_t *places, symbol_ref_t *src, int ret);
-static void format_3_instr(int opcode, symbol_ref_t *src,
-			   expression_t *immed, symbol_ref_t *address);
-static void test_readable_symbol(symbol_t *symbol);
-static void test_writable_symbol(symbol_t *symbol);
-static void type_check(symbol_t *symbol, expression_t *expression, int and_op);
-static void make_expression(expression_t *immed, int value);
-static void add_conditional(symbol_t *symbol);
-static void add_version(const char *verstring);
-static int  is_download_const(expression_t *immed);
-
-#define SRAM_SYMNAME "SRAM_BASE"
-#define SCB_SYMNAME "SCB_BASE"
-%}
-
-%union {
-	u_int		value;
-	char		*str;
-	symbol_t	*sym;
-	symbol_ref_t	sym_ref;
-	expression_t	expression;
-}
-
-%token T_REGISTER
-
-%token <value> T_CONST
-
-%token T_EXPORT
-
-%token T_DOWNLOAD
-
-%token T_SCB
-
-%token T_SRAM
-
-%token T_ALIAS
-
-%token T_SIZE
-
-%token T_EXPR_LSHIFT
-
-%token T_EXPR_RSHIFT
-
-%token <value> T_ADDRESS
-
-%token T_ACCESS_MODE
-
-%token T_MODES
-
-%token T_DEFINE
-
-%token T_SET_SRC_MODE
-
-%token T_SET_DST_MODE
-
-%token <value> T_MODE
-
-%token T_BEGIN_CS
-
-%token T_END_CS
-
-%token T_FIELD
-
-%token T_ENUM
-
-%token T_MASK
-
-%token <value> T_NUMBER
-
-%token <str> T_PATH T_STRING T_ARG T_MACROBODY
-
-%token <sym> T_CEXPR
-
-%token T_EOF T_INCLUDE T_VERSION T_PREFIX T_PATCH_ARG_LIST
-
-%token <value> T_SHR T_SHL T_ROR T_ROL
-
-%token <value> T_MVI T_MOV T_CLR T_BMOV
-
-%token <value> T_JMP T_JC T_JNC T_JE T_JNE T_JNZ T_JZ T_CALL
-
-%token <value> T_ADD T_ADC
-
-%token <value> T_INC T_DEC
-
-%token <value> T_STC T_CLC
-
-%token <value> T_CMP T_NOT T_XOR
-
-%token <value> T_TEST T_AND
-
-%token <value> T_OR
-
-%token T_RET
-
-%token T_NOP
-
-%token T_ACCUM T_ALLONES T_ALLZEROS T_NONE T_SINDEX T_MODE_PTR
-
-%token T_A
-
-%token <sym> T_SYMBOL
-
-%token T_NL
-
-%token T_IF T_ELSE T_ELSE_IF T_ENDIF
-
-%type <sym_ref> reg_symbol address destination source opt_source
-
-%type <expression> expression immediate immediate_or_a
-
-%type <value> export ret f1_opcode f2_opcode jmp_jc_jnc_call jz_jnz je_jne
-
-%type <value> mode_value mode_list macro_arglist
-
-%left '|'
-%left '&'
-%left T_EXPR_LSHIFT T_EXPR_RSHIFT
-%left '+' '-'
-%left '*' '/'
-%right '~'
-%nonassoc UMINUS
-%%
-
-program:
-	include
-|	program include
-|	prefix
-|	program prefix
-|	patch_arg_list
-|	program patch_arg_list
-|	version
-|	program version
-|	register
-|	program register
-|	constant
-|	program constant
-|	macrodefn
-|	program macrodefn
-|	scratch_ram
-|	program scratch_ram
-|	scb
-|	program scb
-|	label
-|	program label
-|	set_src_mode
-|	program set_src_mode
-|	set_dst_mode
-|	program set_dst_mode
-|	critical_section_start
-|	program critical_section_start
-|	critical_section_end
-|	program critical_section_end
-|	conditional
-|	program conditional
-|	code
-|	program code
-;
-
-include:
-	T_INCLUDE '<' T_PATH '>'
-	{
-		include_file($3, BRACKETED_INCLUDE);
-	}
-|	T_INCLUDE '"' T_PATH '"'
-	{
-		include_file($3, QUOTED_INCLUDE);
-	}
-;
-
-prefix:
-	T_PREFIX '=' T_STRING
-	{
-		if (prefix != stock_prefix)
-			stop("Prefix multiply defined",
-			     EX_DATAERR);
-		prefix = strdup($3);
-		if (prefix == NULL)
-			stop("Unable to record prefix", EX_SOFTWARE);
-	}
-;
-
-patch_arg_list:
-	T_PATCH_ARG_LIST '=' T_STRING
-	{
-		if (patch_arg_list != NULL)
-			stop("Patch argument list multiply defined",
-			     EX_DATAERR);
-		patch_arg_list = strdup($3);
-		if (patch_arg_list == NULL)
-			stop("Unable to record patch arg list", EX_SOFTWARE);
-	}
-;
-
-version:
-	T_VERSION '=' T_STRING
-	{ add_version($3); }
-;
-
-register:
-	T_REGISTER { cur_symtype = REGISTER; } reg_definition
-;
-
-reg_definition:
-	T_SYMBOL '{'
-		{
-			if ($1->type != UNINITIALIZED) {
-				stop("Register multiply defined", EX_DATAERR);
-				/* NOTREACHED */
-			}
-			cur_symbol = $1; 
-			cur_symbol->type = cur_symtype;
-			initialize_symbol(cur_symbol);
-		}
-		reg_attribute_list
-	'}'
-		{                    
-			/*
-			 * Default to allowing everything in for registers
-			 * with no bit or mask definitions.
-			 */
-			if (cur_symbol->info.rinfo->valid_bitmask == 0)
-				cur_symbol->info.rinfo->valid_bitmask = 0xFF;
-
-			if (cur_symbol->info.rinfo->size == 0)
-				cur_symbol->info.rinfo->size = 1;
-
-			/*
-			 * This might be useful for registers too.
-			 */
-			if (cur_symbol->type != REGISTER) {
-				if (cur_symbol->info.rinfo->address == 0)
-					cur_symbol->info.rinfo->address =
-					    sram_or_scb_offset;
-				sram_or_scb_offset +=
-				    cur_symbol->info.rinfo->size;
-			}
-			cur_symbol = NULL;
-		}
-;
-
-reg_attribute_list:
-	reg_attribute
-|	reg_attribute_list reg_attribute
-;
-
-reg_attribute:		
-	reg_address
-|	size
-|	access_mode
-|	modes
-|	field_defn
-|	enum_defn
-|	mask_defn
-|	alias
-|	accumulator
-|	mode_pointer
-|	allones
-|	allzeros
-|	none
-|	sindex
-;
-
-reg_address:
-	T_ADDRESS T_NUMBER
-	{
-		cur_symbol->info.rinfo->address = $2;
-	}
-;
-
-size:
-	T_SIZE T_NUMBER
-	{
-		cur_symbol->info.rinfo->size = $2;
-		if (scb_or_sram_symbol != NULL) {
-			u_int max_addr;
-			u_int sym_max_addr;
-
-			max_addr = scb_or_sram_symbol->info.rinfo->address
-				 + scb_or_sram_symbol->info.rinfo->size;
-			sym_max_addr = cur_symbol->info.rinfo->address
-				     + cur_symbol->info.rinfo->size;
-
-			if (sym_max_addr > max_addr)
-				stop("SCB or SRAM space exhausted", EX_DATAERR);
-		}
-	}
-;
-
-access_mode:
-	T_ACCESS_MODE T_MODE
-	{
-		cur_symbol->info.rinfo->mode = $2;
-	}
-;
-
-modes:
-	T_MODES mode_list
-	{
-		cur_symbol->info.rinfo->modes = $2;
-	}
-;
-
-mode_list:
-	mode_value
-	{
-		$$ = $1;
-	}
-|	mode_list ',' mode_value
-	{
-		$$ = $1 | $3;
-	}
-;
-
-mode_value:
-	T_NUMBER
-	{
-		if ($1 > 4) {
-			stop("Valid register modes range between 0 and 4.",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-
-		$$ = (0x1 << $1);
-	}
-|	T_SYMBOL
-	{
-		symbol_t *symbol;
-
-		symbol = $1;
-		if (symbol->type != CONST) {
-			stop("Only \"const\" symbols allowed in "
-			     "mode definitions.", EX_DATAERR);
-			/* NOTREACHED */
-		}
-		if (symbol->info.cinfo->value > 4) {
-			stop("Valid register modes range between 0 and 4.",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		$$ = (0x1 << symbol->info.cinfo->value);
-	}
-;
-
-field_defn:
-	T_FIELD
-		{
-			field_symbol = NULL;
-			enum_next_value = 0;
-			enum_increment = 1;
-		}
-	'{' enum_entry_list '}'
-|	T_FIELD T_SYMBOL expression
-		{
-			process_field(FIELD, $2, $3.value);
-			field_symbol = $2;
-			enum_next_value = 0;
-			enum_increment = 0x01 << (ffs($3.value) - 1);
-		}
-	'{' enum_entry_list '}'
-|	T_FIELD T_SYMBOL expression
-	{
-		process_field(FIELD, $2, $3.value);
-	}
-;
-
-enum_defn:
-	T_ENUM
-		{
-			field_symbol = NULL;
-			enum_next_value = 0;
-			enum_increment = 1;
-		}
-	'{' enum_entry_list '}'
-|	T_ENUM T_SYMBOL expression
-		{
-			process_field(ENUM, $2, $3.value);
-			field_symbol = $2;
-			enum_next_value = 0;
-			enum_increment = 0x01 << (ffs($3.value) - 1);
-		}
-	'{' enum_entry_list '}'
-;
-
-enum_entry_list:
-	enum_entry
-|	enum_entry_list ',' enum_entry
-;
-
-enum_entry:
-	T_SYMBOL
-	{
-		process_field(ENUM_ENTRY, $1, enum_next_value);
-		enum_next_value += enum_increment;
-	}
-|	T_SYMBOL expression
-	{
-		process_field(ENUM_ENTRY, $1, $2.value);
-		enum_next_value = $2.value + enum_increment;
-	}
-;
-
-mask_defn:
-	T_MASK T_SYMBOL expression
-	{
-		process_field(MASK, $2, $3.value);
-	}
-;
-
-alias:
-	T_ALIAS	T_SYMBOL
-	{
-		if ($2->type != UNINITIALIZED) {
-			stop("Re-definition of register alias",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		$2->type = ALIAS;
-		initialize_symbol($2);
-		$2->info.ainfo->parent = cur_symbol;
-	}
-;
-
-accumulator:
-	T_ACCUM
-	{
-		if (accumulator.symbol != NULL) {
-			stop("Only one accumulator definition allowed",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		accumulator.symbol = cur_symbol;
-	}
-;
-
-mode_pointer:
-	T_MODE_PTR
-	{
-		if (mode_ptr.symbol != NULL) {
-			stop("Only one mode pointer definition allowed",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		mode_ptr.symbol = cur_symbol;
-	}
-;
-
-allones:
-	T_ALLONES
-	{
-		if (allones.symbol != NULL) {
-			stop("Only one definition of allones allowed",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		allones.symbol = cur_symbol;
-	}
-;
-
-allzeros:
-	T_ALLZEROS
-	{
-		if (allzeros.symbol != NULL) {
-			stop("Only one definition of allzeros allowed",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		allzeros.symbol = cur_symbol;
-	}
-;
-
-none:
-	T_NONE
-	{
-		if (none.symbol != NULL) {
-			stop("Only one definition of none allowed",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		none.symbol = cur_symbol;
-	}
-;
-
-sindex:
-	T_SINDEX
-	{
-		if (sindex.symbol != NULL) {
-			stop("Only one definition of sindex allowed",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		sindex.symbol = cur_symbol;
-	}
-;
-
-expression:
-	expression '|' expression
-	{
-		 $$.value = $1.value | $3.value;
-		 symlist_merge(&$$.referenced_syms,
-			       &$1.referenced_syms,
-			       &$3.referenced_syms);
-	}
-|	expression '&' expression
-	{
-		$$.value = $1.value & $3.value;
-		symlist_merge(&$$.referenced_syms,
-			       &$1.referenced_syms,
-			       &$3.referenced_syms);
-	}
-|	expression '+' expression
-	{
-		$$.value = $1.value + $3.value;
-		symlist_merge(&$$.referenced_syms,
-			       &$1.referenced_syms,
-			       &$3.referenced_syms);
-	}
-|	expression '-' expression
-	{
-		$$.value = $1.value - $3.value;
-		symlist_merge(&($$.referenced_syms),
-			       &($1.referenced_syms),
-			       &($3.referenced_syms));
-	}
-|	expression '*' expression
-	{
-		$$.value = $1.value * $3.value;
-		symlist_merge(&($$.referenced_syms),
-			       &($1.referenced_syms),
-			       &($3.referenced_syms));
-	}
-|	expression '/' expression
-	{
-		$$.value = $1.value / $3.value;
-		symlist_merge(&($$.referenced_syms),
-			       &($1.referenced_syms),
-			       &($3.referenced_syms));
-	}
-| 	expression T_EXPR_LSHIFT expression
-	{
-		$$.value = $1.value << $3.value;
-		symlist_merge(&$$.referenced_syms,
-			       &$1.referenced_syms,
-			       &$3.referenced_syms);
-	}
-| 	expression T_EXPR_RSHIFT expression
-	{
-		$$.value = $1.value >> $3.value;
-		symlist_merge(&$$.referenced_syms,
-			       &$1.referenced_syms,
-			       &$3.referenced_syms);
-	}
-|	'(' expression ')'
-	{
-		$$ = $2;
-	}
-|	'~' expression
-	{
-		$$ = $2;
-		$$.value = (~$$.value) & 0xFF;
-	}
-|	'-' expression %prec UMINUS
-	{
-		$$ = $2;
-		$$.value = -$$.value;
-	}
-|	T_NUMBER
-	{
-		$$.value = $1;
-		SLIST_INIT(&$$.referenced_syms);
-	}
-|	T_SYMBOL
-	{
-		symbol_t *symbol;
-
-		symbol = $1;
-		switch (symbol->type) {
-		case ALIAS:
-			symbol = $1->info.ainfo->parent;
-		case REGISTER:
-		case SCBLOC:
-		case SRAMLOC:
-			$$.value = symbol->info.rinfo->address;
-			break;
-		case MASK:
-		case FIELD:
-		case ENUM:
-		case ENUM_ENTRY:
-			$$.value = symbol->info.finfo->value;
-			break;
-		case DOWNLOAD_CONST:
-		case CONST:
-			$$.value = symbol->info.cinfo->value;
-			break;
-		case UNINITIALIZED:
-		default:
-		{
-			snprintf(errbuf, sizeof(errbuf),
-				 "Undefined symbol %s referenced",
-				 symbol->name);
-			stop(errbuf, EX_DATAERR);
-			/* NOTREACHED */
-			break;
-		}
-		}
-		SLIST_INIT(&$$.referenced_syms);
-		symlist_add(&$$.referenced_syms, symbol, SYMLIST_INSERT_HEAD);
-	}
-;
-
-constant:
-	T_CONST T_SYMBOL expression 
-	{
-		if ($2->type != UNINITIALIZED) {
-			stop("Re-definition of symbol as a constant",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		$2->type = CONST;
-		initialize_symbol($2);
-		$2->info.cinfo->value = $3.value;
-	}
-|	T_CONST T_SYMBOL T_DOWNLOAD
-	{
-		if ($1) {
-			stop("Invalid downloaded constant declaration",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		if ($2->type != UNINITIALIZED) {
-			stop("Re-definition of symbol as a downloaded constant",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		$2->type = DOWNLOAD_CONST;
-		initialize_symbol($2);
-		$2->info.cinfo->value = download_constant_count++;
-	}
-;
-
-macrodefn_prologue:
-	T_DEFINE T_SYMBOL
-	{
-		if ($2->type != UNINITIALIZED) {
-			stop("Re-definition of symbol as a macro",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		cur_symbol = $2;
-		cur_symbol->type = MACRO;
-		initialize_symbol(cur_symbol);
-	}
-;
-
-macrodefn:
-	macrodefn_prologue T_MACROBODY
-	{
-		add_macro_body($2);
-	}
-|	macrodefn_prologue '(' macro_arglist ')' T_MACROBODY
-	{
-		add_macro_body($5);
-		cur_symbol->info.macroinfo->narg = $3;
-	}
-;
-
-macro_arglist:
-	{
-		/* Macros can take no arguments */
-		$$ = 0;
-	}
-|	T_ARG
-	{
-		$$ = 1;
-		add_macro_arg($1, 0);
-	}
-|	macro_arglist ',' T_ARG
-	{
-		if ($1 == 0) {
-			stop("Comma without preceeding argument in arg list",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		$$ = $1 + 1;
-		add_macro_arg($3, $1);
-	}
-;
-
-scratch_ram:
-	T_SRAM '{'
-		{
-			snprintf(errbuf, sizeof(errbuf), "%s%d", SRAM_SYMNAME,
-				 num_srams);
-			cur_symbol = symtable_get(SRAM_SYMNAME);
-			cur_symtype = SRAMLOC;
-			cur_symbol->type = SRAMLOC;
-			initialize_symbol(cur_symbol);
-		}
-		reg_address
-		{
-			sram_or_scb_offset = cur_symbol->info.rinfo->address;
-		}
-		size
-		{
-			scb_or_sram_symbol = cur_symbol;
-		}
-		scb_or_sram_attributes
-	'}'
-		{
-			cur_symbol = NULL;
-			scb_or_sram_symbol = NULL;
-		}
-;
-
-scb:
-	T_SCB '{'
-		{
-			cur_symbol = symtable_get(SCB_SYMNAME);
-			cur_symtype = SCBLOC;
-			if (cur_symbol->type != UNINITIALIZED) {
-				stop("Only one SRAM definition allowed",
-				     EX_SOFTWARE);
-				/* NOTREACHED */
-			}
-			cur_symbol->type = SCBLOC;
-			initialize_symbol(cur_symbol);
-			/* 64 bytes of SCB space */
-			cur_symbol->info.rinfo->size = 64;
-		}
-		reg_address
-		{
-			sram_or_scb_offset = cur_symbol->info.rinfo->address;
-		}
-		size
-		{
-			scb_or_sram_symbol = cur_symbol;
-		}
-		scb_or_sram_attributes
-	'}'
-		{
-			cur_symbol = NULL;
-			scb_or_sram_symbol = NULL;
-		}
-;
-
-scb_or_sram_attributes:
-	/* NULL definition is okay */
-|	modes
-|	scb_or_sram_reg_list
-|	modes scb_or_sram_reg_list
-;
-
-scb_or_sram_reg_list:
-	reg_definition
-|	scb_or_sram_reg_list reg_definition
-;
-
-reg_symbol:
-	T_SYMBOL
-	{
-		process_register(&$1);
-		$$.symbol = $1;
-		$$.offset = 0;
-	}
-|	T_SYMBOL '[' T_SYMBOL ']'
-	{
-		process_register(&$1);
-		if ($3->type != CONST) {
-			stop("register offset must be a constant", EX_DATAERR);
-			/* NOTREACHED */
-		}
-		if (($3->info.cinfo->value + 1) > $1->info.rinfo->size) {
-			stop("Accessing offset beyond range of register",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		$$.symbol = $1;
-		$$.offset = $3->info.cinfo->value;
-	}
-|	T_SYMBOL '[' T_NUMBER ']'
-	{
-		process_register(&$1);
-		if (($3 + 1) > $1->info.rinfo->size) {
-			stop("Accessing offset beyond range of register",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		$$.symbol = $1;
-		$$.offset = $3;
-	}
-|	T_A
-	{
-		if (accumulator.symbol == NULL) {
-			stop("No accumulator has been defined", EX_DATAERR);
-			/* NOTREACHED */
-		}
-		$$.symbol = accumulator.symbol;
-		$$.offset = 0;
-	}
-;
-
-destination:
-	reg_symbol
-	{
-		test_writable_symbol($1.symbol);
-		$$ = $1;
-	}
-;
-
-immediate:
-	expression
-	{ $$ = $1; }
-;
-
-immediate_or_a:
-	expression
-	{
-		if ($1.value == 0 && is_download_const(&$1) == 0) {
-			snprintf(errbuf, sizeof(errbuf),
-				 "\nExpression evaluates to 0 and thus "
-				 "references the accumulator.\n "
-				 "If this is the desired effect, use 'A' "
-				 "instead.\n");
-			stop(errbuf, EX_DATAERR);
-		}
-		$$ = $1;
-	}
-|	T_A
-	{
-		SLIST_INIT(&$$.referenced_syms);
-		symlist_add(&$$.referenced_syms, accumulator.symbol,
-			    SYMLIST_INSERT_HEAD);
-		$$.value = 0;
-	}
-;
-
-source:
-	reg_symbol
-	{
-		test_readable_symbol($1.symbol);
-		$$ = $1;
-	}
-;
-
-opt_source:
-	{
-		$$.symbol = NULL;
-		$$.offset = 0;
-	}
-|	',' source
-	{ $$ = $2; }
-;
-
-ret:
-	{ $$ = 0; }
-|	T_RET
-	{ $$ = 1; }
-;
-
-set_src_mode:
-	T_SET_SRC_MODE T_NUMBER ';'
-	{
-		src_mode = $2;
-	}
-;
-
-set_dst_mode:
-	T_SET_DST_MODE T_NUMBER ';'
-	{
-		dst_mode = $2;
-	}
-;
-
-critical_section_start:
-	T_BEGIN_CS ';'
-	{
-		critical_section_t *cs;
-
-		if (in_critical_section != FALSE) {
-			stop("Critical Section within Critical Section",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		cs = cs_alloc();
-		cs->begin_addr = instruction_ptr;
-		in_critical_section = TRUE;
-	}
-;
-
-critical_section_end:
-	T_END_CS ';'
-	{
-		critical_section_t *cs;
-
-		if (in_critical_section == FALSE) {
-			stop("Unballanced 'end_cs'", EX_DATAERR);
-			/* NOTREACHED */
-		}
-		cs = TAILQ_LAST(&cs_tailq, cs_tailq);
-		cs->end_addr = instruction_ptr;
-		in_critical_section = FALSE;
-	}
-;
-
-export:
-	{ $$ = 0; }
-|	T_EXPORT
-	{ $$ = 1; }
-;
-
-label:
-	export T_SYMBOL ':'
-	{
-		if ($2->type != UNINITIALIZED) {
-			stop("Program label multiply defined", EX_DATAERR);
-			/* NOTREACHED */
-		}
-		$2->type = LABEL;
-		initialize_symbol($2);
-		$2->info.linfo->address = instruction_ptr;
-		$2->info.linfo->exported = $1;
-	}
-;
-
-address:
-	T_SYMBOL
-	{
-		$$.symbol = $1;
-		$$.offset = 0;
-	}
-|	T_SYMBOL '+' T_NUMBER
-	{
-		$$.symbol = $1;
-		$$.offset = $3;
-	}
-|	T_SYMBOL '-' T_NUMBER
-	{
-		$$.symbol = $1;
-		$$.offset = -$3;
-	}
-|	'.'
-	{
-		$$.symbol = NULL;
-		$$.offset = 0;
-	}
-|	'.' '+' T_NUMBER
-	{
-		$$.symbol = NULL;
-		$$.offset = $3;
-	}
-|	'.' '-' T_NUMBER
-	{
-		$$.symbol = NULL;
-		$$.offset = -$3;
-	}
-;
-
-conditional:
-	T_IF T_CEXPR '{'
-	{
-		scope_t *new_scope;
-
-		add_conditional($2);
-		new_scope = scope_alloc();
-		new_scope->type = SCOPE_IF;
-		new_scope->begin_addr = instruction_ptr;
-		new_scope->func_num = $2->info.condinfo->func_num;
-	}
-|	T_ELSE T_IF T_CEXPR '{'
-	{
-		scope_t *new_scope;
-		scope_t *scope_context;
-		scope_t *last_scope;
-
-		/*
-		 * Ensure that the previous scope is either an
-		 * if or and else if.
-		 */
-		scope_context = SLIST_FIRST(&scope_stack);
-		last_scope = TAILQ_LAST(&scope_context->inner_scope,
-					scope_tailq);
-		if (last_scope == NULL
-		 || last_scope->type == T_ELSE) {
-
-			stop("'else if' without leading 'if'", EX_DATAERR);
-			/* NOTREACHED */
-		}
-		add_conditional($3);
-		new_scope = scope_alloc();
-		new_scope->type = SCOPE_ELSE_IF;
-		new_scope->begin_addr = instruction_ptr;
-		new_scope->func_num = $3->info.condinfo->func_num;
-	}
-|	T_ELSE '{'
-	{
-		scope_t *new_scope;
-		scope_t *scope_context;
-		scope_t *last_scope;
-
-		/*
-		 * Ensure that the previous scope is either an
-		 * if or and else if.
-		 */
-		scope_context = SLIST_FIRST(&scope_stack);
-		last_scope = TAILQ_LAST(&scope_context->inner_scope,
-					scope_tailq);
-		if (last_scope == NULL
-		 || last_scope->type == SCOPE_ELSE) {
-
-			stop("'else' without leading 'if'", EX_DATAERR);
-			/* NOTREACHED */
-		}
-		new_scope = scope_alloc();
-		new_scope->type = SCOPE_ELSE;
-		new_scope->begin_addr = instruction_ptr;
-	}
-;
-
-conditional:
-	'}'
-	{
-		scope_t *scope_context;
-
-		scope_context = SLIST_FIRST(&scope_stack);
-		if (scope_context->type == SCOPE_ROOT) {
-			stop("Unexpected '}' encountered", EX_DATAERR);
-			/* NOTREACHED */
-		}
-
-		scope_context->end_addr = instruction_ptr;
-
-		/* Pop the scope */
-		SLIST_REMOVE_HEAD(&scope_stack, scope_stack_links);
-
-		process_scope(scope_context);
-
-		if (SLIST_FIRST(&scope_stack) == NULL) {
-			stop("Unexpected '}' encountered", EX_DATAERR);
-			/* NOTREACHED */
-		}
-	}
-;
-
-f1_opcode:
-	T_AND { $$ = AIC_OP_AND; }
-|	T_XOR { $$ = AIC_OP_XOR; }
-|	T_ADD { $$ = AIC_OP_ADD; }
-|	T_ADC { $$ = AIC_OP_ADC; }
-;
-
-code:
-	f1_opcode destination ',' immediate_or_a opt_source ret ';'
-	{
-		format_1_instr($1, &$2, &$4, &$5, $6);
-	}
-;
-
-code:
-	T_OR reg_symbol ',' immediate_or_a opt_source ret ';'
-	{
-		format_1_instr(AIC_OP_OR, &$2, &$4, &$5, $6);
-	}
-;
-
-code:
-	T_INC destination opt_source ret ';'
-	{
-		expression_t immed;
-
-		make_expression(&immed, 1);
-		format_1_instr(AIC_OP_ADD, &$2, &immed, &$3, $4);
-	}
-;
-
-code:
-	T_DEC destination opt_source ret ';'
-	{
-		expression_t immed;
-
-		make_expression(&immed, -1);
-		format_1_instr(AIC_OP_ADD, &$2, &immed, &$3, $4);
-	}
-;
-
-code:
-	T_CLC ret ';'
-	{
-		expression_t immed;
-
-		make_expression(&immed, -1);
-		format_1_instr(AIC_OP_ADD, &none, &immed, &allzeros, $2);
-	}
-|	T_CLC T_MVI destination ',' immediate_or_a ret ';'
-	{
-		format_1_instr(AIC_OP_ADD, &$3, &$5, &allzeros, $6);
-	}
-;
-
-code:
-	T_STC ret ';'
-	{
-		expression_t immed;
-
-		make_expression(&immed, 1);
-		format_1_instr(AIC_OP_ADD, &none, &immed, &allones, $2);
-	}
-|	T_STC destination ret ';'
-	{
-		expression_t immed;
-
-		make_expression(&immed, 1);
-		format_1_instr(AIC_OP_ADD, &$2, &immed, &allones, $3);
-	}
-;
-
-code:
-	T_BMOV destination ',' source ',' immediate ret ';'
-	{
-		format_1_instr(AIC_OP_BMOV, &$2, &$6, &$4, $7);
-	}
-;
-
-code:
-	T_MOV destination ',' source ret ';'
-	{
-		expression_t immed;
-
-		make_expression(&immed, 1);
-		format_1_instr(AIC_OP_BMOV, &$2, &immed, &$4, $5);
-	}
-;
-
-code:
-	T_MVI destination ',' immediate ret ';'
-	{
-		if ($4.value == 0
-		 && is_download_const(&$4) == 0) {
-			expression_t immed;
-
-			/*
-			 * Allow move immediates of 0 so that macros,
-			 * that can't know the immediate's value and
-			 * otherwise compensate, still work.
-			 */
-			make_expression(&immed, 1);
-			format_1_instr(AIC_OP_BMOV, &$2, &immed, &allzeros, $5);
-		} else {
-			format_1_instr(AIC_OP_OR, &$2, &$4, &allzeros, $5);
-		}
-	}
-;
-
-code:
-	T_NOT destination opt_source ret ';'
-	{
-		expression_t immed;
-
-		make_expression(&immed, 0xff);
-		format_1_instr(AIC_OP_XOR, &$2, &immed, &$3, $4);
-	}
-;
-
-code:
-	T_CLR destination ret ';'
-	{
-		expression_t immed;
-
-		make_expression(&immed, 0xff);
-		format_1_instr(AIC_OP_AND, &$2, &immed, &allzeros, $3);
-	}
-;
-
-code:
-	T_NOP ret ';'
-	{
-		expression_t immed;
-
-		make_expression(&immed, 0xff);
-		format_1_instr(AIC_OP_AND, &none, &immed, &allzeros, $2);
-	}
-;
-
-code:
-	T_RET ';'
-	{
-		expression_t immed;
-
-		make_expression(&immed, 0xff);
-		format_1_instr(AIC_OP_AND, &none, &immed, &allzeros, TRUE);
-	}
-;
-
-	/*
-	 * This grammer differs from the one in the aic7xxx
-	 * reference manual since the grammer listed there is
-	 * ambiguous and causes a shift/reduce conflict.
-	 * It also seems more logical as the "immediate"
-	 * argument is listed as the second arg like the
-	 * other formats.
-	 */
-
-f2_opcode:
-	T_SHL { $$ = AIC_OP_SHL; }
-|	T_SHR { $$ = AIC_OP_SHR; }
-|	T_ROL { $$ = AIC_OP_ROL; }
-|	T_ROR { $$ = AIC_OP_ROR; }
-;
-
-code:
-	f2_opcode destination ',' expression opt_source ret ';'
-	{
-		format_2_instr($1, &$2, &$4, &$5, $6);
-	}
-;
-
-jmp_jc_jnc_call:
-	T_JMP	{ $$ = AIC_OP_JMP; }
-|	T_JC	{ $$ = AIC_OP_JC; }
-|	T_JNC	{ $$ = AIC_OP_JNC; }
-|	T_CALL	{ $$ = AIC_OP_CALL; }
-;
-
-jz_jnz:
-	T_JZ	{ $$ = AIC_OP_JZ; }
-|	T_JNZ	{ $$ = AIC_OP_JNZ; }
-;
-
-je_jne:
-	T_JE	{ $$ = AIC_OP_JE; }
-|	T_JNE	{ $$ = AIC_OP_JNE; }
-;
-
-code:
-	jmp_jc_jnc_call address ';'
-	{
-		expression_t immed;
-
-		make_expression(&immed, 0);
-		format_3_instr($1, &sindex, &immed, &$2);
-	}
-;
-
-code:
-	T_OR reg_symbol ',' immediate jmp_jc_jnc_call address ';'
-	{
-		format_3_instr($5, &$2, &$4, &$6);
-	}
-;
-
-code:
-	T_TEST source ',' immediate_or_a jz_jnz address ';'
-	{
-		format_3_instr($5, &$2, &$4, &$6);
-	}
-;
-
-code:
-	T_CMP source ',' immediate_or_a je_jne address ';'
-	{
-		format_3_instr($5, &$2, &$4, &$6);
-	}
-;
-
-code:
-	T_MOV source jmp_jc_jnc_call address ';'
-	{
-		expression_t immed;
-
-		make_expression(&immed, 0);
-		format_3_instr($3, &$2, &immed, &$4);
-	}
-;
-
-code:
-	T_MVI immediate jmp_jc_jnc_call address ';'
-	{
-		format_3_instr($3, &allzeros, &$2, &$4);
-	}
-;
-
-%%
-
-static void
-process_field(int field_type, symbol_t *sym, int value)
-{
-	/*
-	 * Add the current register to its
-	 * symbol list, if it already exists,
-	 * warn if we are setting it to a
-	 * different value, or in the bit to
-	 * the "allowed bits" of this register.
-	 */
-	if (sym->type == UNINITIALIZED) {
-		sym->type = field_type;
-		initialize_symbol(sym);
-		sym->info.finfo->value = value;
-		if (field_type != ENUM_ENTRY) {
-			if (field_type != MASK && value == 0) {
-				stop("Empty Field, or Enum", EX_DATAERR);
-				/* NOTREACHED */
-			}
-			sym->info.finfo->value = value;
-			sym->info.finfo->mask = value;
-		} else if (field_symbol != NULL) {
-			sym->info.finfo->mask = field_symbol->info.finfo->value;
-		} else {
-			sym->info.finfo->mask = 0xFF;
-		}
-	} else if (sym->type != field_type) {
-		stop("Field definition mirrors a definition of the same "
-		     " name, but a different type", EX_DATAERR);
-		/* NOTREACHED */
-	} else if (value != sym->info.finfo->value) {
-		stop("Field redefined with a conflicting value", EX_DATAERR);
-		/* NOTREACHED */
-	}
-	/* Fail if this symbol is already listed */
-	if (symlist_search(&(sym->info.finfo->symrefs),
-			   cur_symbol->name) != NULL) {
-		stop("Field defined multiple times for register", EX_DATAERR);
-		/* NOTREACHED */
-	}
-	symlist_add(&(sym->info.finfo->symrefs), cur_symbol,
-		    SYMLIST_INSERT_HEAD);
-	cur_symbol->info.rinfo->valid_bitmask |= sym->info.finfo->mask;
-	cur_symbol->info.rinfo->typecheck_masks = TRUE;
-	symlist_add(&(cur_symbol->info.rinfo->fields), sym, SYMLIST_SORT);
-}
-
-static void
-initialize_symbol(symbol_t *symbol)
-{
-	switch (symbol->type) {
-	case UNINITIALIZED:
-		stop("Call to initialize_symbol with type field unset",
-		     EX_SOFTWARE);
-		/* NOTREACHED */
-		break;
-	case REGISTER:
-	case SRAMLOC:
-	case SCBLOC:
-		symbol->info.rinfo =
-		    (struct reg_info *)malloc(sizeof(struct reg_info));
-		if (symbol->info.rinfo == NULL) {
-			stop("Can't create register info", EX_SOFTWARE);
-			/* NOTREACHED */
-		}
-		memset(symbol->info.rinfo, 0,
-		       sizeof(struct reg_info));
-		SLIST_INIT(&(symbol->info.rinfo->fields));
-		/*
-		 * Default to allowing access in all register modes
-		 * or to the mode specified by the SCB or SRAM space
-		 * we are in.
-		 */
-		if (scb_or_sram_symbol != NULL)
-			symbol->info.rinfo->modes =
-			    scb_or_sram_symbol->info.rinfo->modes;
-		else
-			symbol->info.rinfo->modes = ~0;
-		break;
-	case ALIAS:
-		symbol->info.ainfo =
-		    (struct alias_info *)malloc(sizeof(struct alias_info));
-		if (symbol->info.ainfo == NULL) {
-			stop("Can't create alias info", EX_SOFTWARE);
-			/* NOTREACHED */
-		}
-		memset(symbol->info.ainfo, 0,
-		       sizeof(struct alias_info));
-		break;
-	case MASK:
-	case FIELD:
-	case ENUM:
-	case ENUM_ENTRY:
-		symbol->info.finfo =
-		    (struct field_info *)malloc(sizeof(struct field_info));
-		if (symbol->info.finfo == NULL) {
-			stop("Can't create field info", EX_SOFTWARE);
-			/* NOTREACHED */
-		}
-		memset(symbol->info.finfo, 0, sizeof(struct field_info));
-		SLIST_INIT(&(symbol->info.finfo->symrefs));
-		break;
-	case CONST:
-	case DOWNLOAD_CONST:
-		symbol->info.cinfo =
-		    (struct const_info *)malloc(sizeof(struct const_info));
-		if (symbol->info.cinfo == NULL) {
-			stop("Can't create alias info", EX_SOFTWARE);
-			/* NOTREACHED */
-		}
-		memset(symbol->info.cinfo, 0,
-		       sizeof(struct const_info));
-		break;
-	case LABEL:
-		symbol->info.linfo =
-		    (struct label_info *)malloc(sizeof(struct label_info));
-		if (symbol->info.linfo == NULL) {
-			stop("Can't create label info", EX_SOFTWARE);
-			/* NOTREACHED */
-		}
-		memset(symbol->info.linfo, 0,
-		       sizeof(struct label_info));
-		break;
-	case CONDITIONAL:
-		symbol->info.condinfo =
-		    (struct cond_info *)malloc(sizeof(struct cond_info));
-		if (symbol->info.condinfo == NULL) {
-			stop("Can't create conditional info", EX_SOFTWARE);
-			/* NOTREACHED */
-		}
-		memset(symbol->info.condinfo, 0,
-		       sizeof(struct cond_info));
-		break;
-	case MACRO:
-		symbol->info.macroinfo = 
-		    (struct macro_info *)malloc(sizeof(struct macro_info));
-		if (symbol->info.macroinfo == NULL) {
-			stop("Can't create macro info", EX_SOFTWARE);
-			/* NOTREACHED */
-		}
-		memset(symbol->info.macroinfo, 0,
-		       sizeof(struct macro_info));
-		STAILQ_INIT(&symbol->info.macroinfo->args);
-		break;
-	default:
-		stop("Call to initialize_symbol with invalid symbol type",
-		     EX_SOFTWARE);
-		/* NOTREACHED */
-		break;
-	}
-}
-
-static void
-add_macro_arg(const char *argtext, int argnum)
-{
-	struct macro_arg *marg;
-	int i;
-	int retval;
-		
-
-	if (cur_symbol == NULL || cur_symbol->type != MACRO) {
-		stop("Invalid current symbol for adding macro arg",
-		     EX_SOFTWARE);
-		/* NOTREACHED */
-	}
-
-	marg = (struct macro_arg *)malloc(sizeof(*marg));
-	if (marg == NULL) {
-		stop("Can't create macro_arg structure", EX_SOFTWARE);
-		/* NOTREACHED */
-	}
-	marg->replacement_text = NULL;
-	retval = snprintf(regex_pattern, sizeof(regex_pattern),
-			  "[^-/A-Za-z0-9_](%s)([^-/A-Za-z0-9_]|$)",
-			  argtext);
-	if (retval >= sizeof(regex_pattern)) {
-		stop("Regex text buffer too small for arg",
-		     EX_SOFTWARE);
-		/* NOTREACHED */
-	}
-	retval = regcomp(&marg->arg_regex, regex_pattern, REG_EXTENDED);
-	if (retval != 0) {
-		stop("Regex compilation failed", EX_SOFTWARE);
-		/* NOTREACHED */
-	}
-	STAILQ_INSERT_TAIL(&cur_symbol->info.macroinfo->args, marg, links);
-}
-
-static void
-add_macro_body(const char *bodytext)
-{
-	if (cur_symbol == NULL || cur_symbol->type != MACRO) {
-		stop("Invalid current symbol for adding macro arg",
-		     EX_SOFTWARE);
-		/* NOTREACHED */
-	}
-	cur_symbol->info.macroinfo->body = strdup(bodytext);
-	if (cur_symbol->info.macroinfo->body == NULL) {
-		stop("Can't duplicate macro body text", EX_SOFTWARE);
-		/* NOTREACHED */
-	}
-}
-
-static void
-process_register(symbol_t **p_symbol)
-{
-	symbol_t *symbol = *p_symbol;
-
-	if (symbol->type == UNINITIALIZED) {
-		snprintf(errbuf, sizeof(errbuf), "Undefined register %s",
-			 symbol->name);
-		stop(errbuf, EX_DATAERR);
-		/* NOTREACHED */
-	} else if (symbol->type == ALIAS) {
-		*p_symbol = symbol->info.ainfo->parent;
-	} else if ((symbol->type != REGISTER)
-		&& (symbol->type != SCBLOC)
-		&& (symbol->type != SRAMLOC)) {
-		snprintf(errbuf, sizeof(errbuf),
-			 "Specified symbol %s is not a register",
-			 symbol->name);
-		stop(errbuf, EX_DATAERR);
-	}
-}
-
-static void
-format_1_instr(int opcode, symbol_ref_t *dest, expression_t *immed,
-	       symbol_ref_t *src, int ret)
-{
-	struct instruction *instr;
-	struct ins_format1 *f1_instr;
-
-	if (src->symbol == NULL)
-		src = dest;
-
-	/* Test register permissions */
-	test_writable_symbol(dest->symbol);
-	test_readable_symbol(src->symbol);
-
-	/* Ensure that immediate makes sense for this destination */
-	type_check(dest->symbol, immed, opcode);
-
-	/* Allocate sequencer space for the instruction and fill it out */
-	instr = seq_alloc();
-	f1_instr = &instr->format.format1;
-	f1_instr->ret = ret ? 1 : 0;
-	f1_instr->opcode = opcode;
-	f1_instr->destination = dest->symbol->info.rinfo->address
-			      + dest->offset;
-	f1_instr->source = src->symbol->info.rinfo->address
-			 + src->offset;
-	f1_instr->immediate = immed->value;
-
-	if (is_download_const(immed))
-		f1_instr->parity = 1;
-	else if (dest->symbol == mode_ptr.symbol) {
-		u_int src_value;
-		u_int dst_value;
-
-		/*
-		 * Attempt to update mode information if
-		 * we are operating on the mode register.
-		 */
-		if (src->symbol == allones.symbol)
-			src_value = 0xFF;
-		else if (src->symbol == allzeros.symbol)
-			src_value = 0;
-		else if (src->symbol == mode_ptr.symbol)
-			src_value = (dst_mode << 4) | src_mode;
-		else
-			goto cant_update;
-
-		switch (opcode) {
-		case AIC_OP_AND:
-			dst_value = src_value & immed->value;
-			break;
-		case AIC_OP_XOR:
-			dst_value = src_value ^ immed->value;
-			break;
-		case AIC_OP_ADD:
-			dst_value = (src_value + immed->value) & 0xFF;
-			break;
-		case AIC_OP_OR:
-			dst_value = src_value | immed->value;
-			break;
-		case AIC_OP_BMOV:
-			dst_value = src_value;
-			break;
-		default:
-			goto cant_update;
-		}
-		src_mode = dst_value & 0xF;
-		dst_mode = (dst_value >> 4) & 0xF;
-	}
-
-cant_update:
-	symlist_free(&immed->referenced_syms);
-	instruction_ptr++;
-}
-
-static void
-format_2_instr(int opcode, symbol_ref_t *dest, expression_t *places,
-	       symbol_ref_t *src, int ret)
-{
-	struct instruction *instr;
-	struct ins_format2 *f2_instr;
-	uint8_t shift_control;
-
-	if (src->symbol == NULL)
-		src = dest;
-
-	/* Test register permissions */
-	test_writable_symbol(dest->symbol);
-	test_readable_symbol(src->symbol);
-
-	/* Allocate sequencer space for the instruction and fill it out */
-	instr = seq_alloc();
-	f2_instr = &instr->format.format2;
-	f2_instr->ret = ret ? 1 : 0;
-	f2_instr->opcode = AIC_OP_ROL;
-	f2_instr->destination = dest->symbol->info.rinfo->address
-			      + dest->offset;
-	f2_instr->source = src->symbol->info.rinfo->address
-			 + src->offset;
-	if (places->value > 8 || places->value <= 0) {
-		stop("illegal shift value", EX_DATAERR);
-		/* NOTREACHED */
-	}
-	switch (opcode) {
-	case AIC_OP_SHL:
-		if (places->value == 8)
-			shift_control = 0xf0;
-		else
-			shift_control = (places->value << 4) | places->value;
-		break;
-	case AIC_OP_SHR:
-		if (places->value == 8) {
-			shift_control = 0xf8;
-		} else {
-			shift_control = (places->value << 4)
-				      | (8 - places->value)
-				      | 0x08;
-		}
-		break;
-	case AIC_OP_ROL:
-		shift_control = places->value & 0x7;
-		break;
-	case AIC_OP_ROR:
-		shift_control = (8 - places->value) | 0x08;
-		break;
-	default:
-		shift_control = 0; /* Quiet Compiler */
-		stop("Invalid shift operation specified", EX_SOFTWARE);
-		/* NOTREACHED */
-		break;
-	};
-	f2_instr->shift_control = shift_control;
-	symlist_free(&places->referenced_syms);
-	instruction_ptr++;
-}
-
-static void
-format_3_instr(int opcode, symbol_ref_t *src,
-	       expression_t *immed, symbol_ref_t *address)
-{
-	struct instruction *instr;
-	struct ins_format3 *f3_instr;
-	int addr;
-
-	/* Test register permissions */
-	test_readable_symbol(src->symbol);
-
-	/* Ensure that immediate makes sense for this source */
-	type_check(src->symbol, immed, opcode);
-
-	/* Allocate sequencer space for the instruction and fill it out */
-	instr = seq_alloc();
-	f3_instr = &instr->format.format3;
-	if (address->symbol == NULL) {
-		/* 'dot' referrence.  Use the current instruction pointer */
-		addr = instruction_ptr + address->offset;
-	} else if (address->symbol->type == UNINITIALIZED) {
-		/* forward reference */
-		addr = address->offset;
-		instr->patch_label = address->symbol;
-	} else
-		addr = address->symbol->info.linfo->address + address->offset;
-	f3_instr->opcode = opcode;
-	f3_instr->address = addr;
-	f3_instr->source = src->symbol->info.rinfo->address
-			 + src->offset;
-	f3_instr->immediate = immed->value;
-
-	if (is_download_const(immed))
-		f3_instr->parity = 1;
-
-	symlist_free(&immed->referenced_syms);
-	instruction_ptr++;
-}
-
-static void
-test_readable_symbol(symbol_t *symbol)
-{
-	
-	if ((symbol->info.rinfo->modes & (0x1 << src_mode)) == 0) {
-		snprintf(errbuf, sizeof(errbuf),
-			"Register %s unavailable in source reg mode %d",
-			symbol->name, src_mode);
-		stop(errbuf, EX_DATAERR);
-	}
-
-	if (symbol->info.rinfo->mode == WO) {
-		stop("Write Only register specified as source",
-		     EX_DATAERR);
-		/* NOTREACHED */
-	}
-}
-
-static void
-test_writable_symbol(symbol_t *symbol)
-{
-	
-	if ((symbol->info.rinfo->modes & (0x1 << dst_mode)) == 0) {
-		snprintf(errbuf, sizeof(errbuf),
-			"Register %s unavailable in destination reg mode %d",
-			symbol->name, dst_mode);
-		stop(errbuf, EX_DATAERR);
-	}
-
-	if (symbol->info.rinfo->mode == RO) {
-		stop("Read Only register specified as destination",
-		     EX_DATAERR);
-		/* NOTREACHED */
-	}
-}
-
-static void
-type_check(symbol_t *symbol, expression_t *expression, int opcode)
-{
-	symbol_node_t *node;
-	int and_op;
-
-	and_op = FALSE;
-	if (opcode == AIC_OP_AND || opcode == AIC_OP_JNZ || AIC_OP_JZ)
-		and_op = TRUE;
-
-	/*
-	 * Make sure that we aren't attempting to write something
-	 * that hasn't been defined.  If this is an and operation,
-	 * this is a mask, so "undefined" bits are okay.
-	 */
-	if (and_op == FALSE
-	 && (expression->value & ~symbol->info.rinfo->valid_bitmask) != 0) {
-		snprintf(errbuf, sizeof(errbuf),
-			 "Invalid bit(s) 0x%x in immediate written to %s",
-			 expression->value & ~symbol->info.rinfo->valid_bitmask,
-			 symbol->name);
-		stop(errbuf, EX_DATAERR);
-		/* NOTREACHED */
-	}
-
-	/*
-	 * Now make sure that all of the symbols referenced by the
-	 * expression are defined for this register.
-	 */
-	if (symbol->info.rinfo->typecheck_masks != FALSE) {
-		for(node = expression->referenced_syms.slh_first;
-		    node != NULL;
-		    node = node->links.sle_next) {
-			if ((node->symbol->type == MASK
-			  || node->symbol->type == FIELD
-			  || node->symbol->type == ENUM
-			  || node->symbol->type == ENUM_ENTRY)
-			 && symlist_search(&node->symbol->info.finfo->symrefs,
-					   symbol->name) == NULL) {
-				snprintf(errbuf, sizeof(errbuf),
-					 "Invalid field or mask %s "
-					 "for register %s",
-					 node->symbol->name, symbol->name);
-				stop(errbuf, EX_DATAERR);
-				/* NOTREACHED */
-			}
-		}
-	}
-}
-
-static void
-make_expression(expression_t *immed, int value)
-{
-	SLIST_INIT(&immed->referenced_syms);
-	immed->value = value & 0xff;
-}
-
-static void
-add_conditional(symbol_t *symbol)
-{
-	static int numfuncs;
-
-	if (numfuncs == 0) {
-		/* add a special conditional, "0" */
-		symbol_t *false_func;
-
-		false_func = symtable_get("0");
-		if (false_func->type != UNINITIALIZED) {
-			stop("Conditional expression '0' "
-			     "conflicts with a symbol", EX_DATAERR);
-			/* NOTREACHED */
-		}
-		false_func->type = CONDITIONAL;
-		initialize_symbol(false_func);
-		false_func->info.condinfo->func_num = numfuncs++;
-		symlist_add(&patch_functions, false_func, SYMLIST_INSERT_HEAD);
-	}
-
-	/* This condition has occurred before */
-	if (symbol->type == CONDITIONAL)
-		return;
-
-	if (symbol->type != UNINITIALIZED) {
-		stop("Conditional expression conflicts with a symbol",
-		     EX_DATAERR);
-		/* NOTREACHED */
-	}
-
-	symbol->type = CONDITIONAL;
-	initialize_symbol(symbol);
-	symbol->info.condinfo->func_num = numfuncs++;
-	symlist_add(&patch_functions, symbol, SYMLIST_INSERT_HEAD);
-}
-
-static void
-add_version(const char *verstring)
-{
-	const char prefix[] = " * ";
-	int newlen;
-	int oldlen;
-
-	newlen = strlen(verstring) + strlen(prefix);
-	oldlen = 0;
-	if (versions != NULL)
-		oldlen = strlen(versions);
-	versions = realloc(versions, newlen + oldlen + 2);
-	if (versions == NULL)
-		stop("Can't allocate version string", EX_SOFTWARE);
-	strcpy(&versions[oldlen], prefix);
-	strcpy(&versions[oldlen + strlen(prefix)], verstring);
-	versions[newlen + oldlen] = '\n';
-	versions[newlen + oldlen + 1] = '\0';
-}
-
-void
-yyerror(const char *string)
-{
-	stop(string, EX_DATAERR);
-}
-
-static int
-is_download_const(expression_t *immed)
-{
-	if ((immed->referenced_syms.slh_first != NULL)
-	 && (immed->referenced_syms.slh_first->symbol->type == DOWNLOAD_CONST))
-		return (TRUE);
-
-	return (FALSE);
-}
diff -urNp linux-5720/drivers/scsi/aic79xx/aicasm/aicasm_insformat.h linux-5730/drivers/scsi/aic79xx/aicasm/aicasm_insformat.h
--- linux-5720/drivers/scsi/aic79xx/aicasm/aicasm_insformat.h
+++ linux-5730/drivers/scsi/aic79xx/aicasm/aicasm_insformat.h
@@ -1,131 +0,0 @@
-/*
- * Instruction formats for the sequencer program downloaded to
- * Aic7xxx SCSI host adapters
- *
- * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#11 $
- *
- * $FreeBSD$
- */
-
-struct ins_format1 {
-#if BYTE_ORDER == LITTLE_ENDIAN
-	uint32_t	immediate	: 8,
-			source		: 9,
-			destination	: 9,
-			ret		: 1,
-			opcode		: 4,
-			parity		: 1;
-#else
-	uint32_t	parity		: 1,
-			opcode		: 4,
-			ret		: 1,
-			destination	: 9,
-			source		: 9,
-			immediate	: 8;
-#endif
-};
-
-struct ins_format2 {
-#if BYTE_ORDER == LITTLE_ENDIAN
-	uint32_t	shift_control	: 8,
-			source		: 9,
-			destination	: 9,
-			ret		: 1,
-			opcode		: 4,
-			parity		: 1;
-#else
-	uint32_t	parity		: 1,
-			opcode		: 4,
-			ret		: 1,
-			destination	: 9,
-			source		: 9,
-			shift_control	: 8;
-#endif
-};
-
-struct ins_format3 {
-#if BYTE_ORDER == LITTLE_ENDIAN
-	uint32_t	immediate	: 8,
-			source		: 9,
-			address		: 10,
-			opcode		: 4,
-			parity		: 1;
-#else
-	uint32_t	parity		: 1,
-			opcode		: 4,
-			address		: 10,
-			source		: 9,
-			immediate	: 8;
-#endif
-};
-
-union ins_formats {
-		struct ins_format1 format1;
-		struct ins_format2 format2;
-		struct ins_format3 format3;
-		uint8_t		   bytes[4];
-		uint32_t	   integer;
-};
-struct instruction {
-	union	ins_formats format;
-	u_int	srcline;
-	struct symbol *patch_label;
-	STAILQ_ENTRY(instruction) links;
-};
-
-#define	AIC_OP_OR	0x0
-#define	AIC_OP_AND	0x1
-#define AIC_OP_XOR	0x2
-#define	AIC_OP_ADD	0x3
-#define	AIC_OP_ADC	0x4
-#define	AIC_OP_ROL	0x5
-#define	AIC_OP_BMOV	0x6
-
-#define	AIC_OP_JMP	0x8
-#define AIC_OP_JC	0x9
-#define AIC_OP_JNC	0xa
-#define AIC_OP_CALL	0xb
-#define	AIC_OP_JNE	0xc
-#define	AIC_OP_JNZ	0xd
-#define	AIC_OP_JE	0xe
-#define	AIC_OP_JZ	0xf
-
-/* Pseudo Ops */
-#define	AIC_OP_SHL	0x10
-#define	AIC_OP_SHR	0x20
-#define	AIC_OP_ROR	0x30
diff -urNp linux-5720/drivers/scsi/aic79xx/aicasm/aicasm_macro_gram.y linux-5730/drivers/scsi/aic79xx/aicasm/aicasm_macro_gram.y
--- linux-5720/drivers/scsi/aic79xx/aicasm/aicasm_macro_gram.y
+++ linux-5730/drivers/scsi/aic79xx/aicasm/aicasm_macro_gram.y
@@ -1,164 +0,0 @@
-%{
-/*
- * Sub-parser for macro invocation in the Aic7xxx SCSI
- * Host adapter sequencer assembler.
- *
- * Copyright (c) 2001 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_gram.y#5 $
- *
- * $FreeBSD$
- */
-
-#include <sys/types.h>
-
-#include <inttypes.h>
-#include <regex.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sysexits.h>
-
-#ifdef __linux__
-#include "../queue.h"
-#else
-#include <sys/queue.h>
-#endif
-
-#include "aicasm.h"
-#include "aicasm_symbol.h"
-#include "aicasm_insformat.h"
-
-static symbol_t *macro_symbol;
-
-static void add_macro_arg(const char *argtext, int position);
-
-%}
-
-%union {
-	int		value;
-	char		*str;
-	symbol_t	*sym;
-}
-
-
-%token <str> T_ARG
-
-%token <sym> T_SYMBOL
-
-%type <value> macro_arglist
-
-%%
-
-macrocall:
-	T_SYMBOL '('
-	{
-		macro_symbol = $1;
-	}
-	macro_arglist ')'
-	{
-		if (macro_symbol->info.macroinfo->narg != $4) {
-			printf("Narg == %d", macro_symbol->info.macroinfo->narg);
-			stop("Too few arguments for macro invocation",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		macro_symbol = NULL;
-		YYACCEPT;
-	}
-;
-
-macro_arglist:
-	{
-		/* Macros can take 0 arguments */
-		$$ = 0;
-	}
-|	T_ARG
-	{
-		$$ = 1;
-		add_macro_arg($1, 1);
-	}
-|	macro_arglist ',' T_ARG
-	{
-		if ($1 == 0) {
-			stop("Comma without preceeding argument in arg list",
-			     EX_DATAERR);
-			/* NOTREACHED */
-		}
-		$$ = $1 + 1;
-		add_macro_arg($3, $$);
-	}
-;
-
-%%
-
-static void
-add_macro_arg(const char *argtext, int argnum)
-{
-	struct macro_arg *marg;
-	int i;
-
-	if (macro_symbol == NULL || macro_symbol->type != MACRO) {
-		stop("Invalid current symbol for adding macro arg",
-		     EX_SOFTWARE);
-		/* NOTREACHED */
-	}
-	/*
-	 * Macro Invocation.  Find the appropriate argument and fill
-	 * in the replace ment text for this call.
-	 */
-	i = 0;
-	STAILQ_FOREACH(marg, &macro_symbol->info.macroinfo->args, links) {
-		i++;
-		if (i == argnum)
-			break;
-	}
-	if (marg == NULL) {
-		stop("Too many arguments for macro invocation", EX_DATAERR);
-		/* NOTREACHED */
-	}
-	marg->replacement_text = strdup(argtext);
-	if (marg->replacement_text == NULL) {
-		stop("Unable to replicate replacement text", EX_SOFTWARE);
-		/* NOTREACHED */
-	}
-}
-
-void
-mmerror(const char *string)
-{
-	stop(string, EX_DATAERR);
-}
diff -urNp linux-5720/drivers/scsi/aic79xx/aicasm/aicasm_macro_scan.l linux-5730/drivers/scsi/aic79xx/aicasm/aicasm_macro_scan.l
--- linux-5720/drivers/scsi/aic79xx/aicasm/aicasm_macro_scan.l
+++ linux-5730/drivers/scsi/aic79xx/aicasm/aicasm_macro_scan.l
@@ -1,155 +0,0 @@
-%{
-/*
- * Sub-Lexical Analyzer for macro invokation in 
- * the Aic7xxx SCSI Host adapter sequencer assembler.
- *
- * Copyright (c) 2001 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_scan.l#7 $
- *
- * $FreeBSD$
- */
-
-#include <sys/types.h>
-
-#include <inttypes.h>
-#include <limits.h>
-#include <regex.h>
-#include <stdio.h>
-#include <string.h>
-#include <sysexits.h>
-#ifdef __linux__
-#include "../queue.h"
-#else
-#include <sys/queue.h>
-#endif
-
-#include "aicasm.h"
-#include "aicasm_symbol.h"
-#include "aicasm_macro_gram.h"
-
-#define MAX_STR_CONST 4096
-static char string_buf[MAX_STR_CONST];
-static char *string_buf_ptr;
-static int  parren_count;
-static char buf[255];
-%}
-
-WORD		[A-Za-z_][-A-Za-z_0-9]*
-SPACE		[ \t]+
-MCARG		[^(), \t]+
-
-%x ARGLIST
-
-%%
-\n			{
-				++yylineno;
-			}
-<ARGLIST>{SPACE}	;
-<ARGLIST>\(		{
-				parren_count++;
-				if (parren_count == 1) {
-					string_buf_ptr = string_buf;
-					return ('(');
-				}
-				*string_buf_ptr++ = '(';
-			}
-<ARGLIST>\)		{
-				if (parren_count == 1) {
-					if (string_buf_ptr != string_buf) {
-						/*
-						 * Return an argument and
-						 * rescan this parren so we
-						 * can return it as well.
-						 */
-						*string_buf_ptr = '\0';
-						mmlval.str = string_buf;
-						string_buf_ptr = string_buf;
-						unput(')');
-						return T_ARG;
-					}
-					BEGIN INITIAL;
-					return (')');
-				}
-				parren_count--;
-				*string_buf_ptr++ = ')';
-			}
-<ARGLIST>{MCARG}	{
-				char *yptr;
-
-				yptr = mmtext;
-				while (*yptr)
-					*string_buf_ptr++ = *yptr++;
-			}
-<ARGLIST>\,		{
-				if (string_buf_ptr != string_buf) {
-					/*
-					 * Return an argument and
-					 * rescan this comma so we
-					 * can return it as well.
-					 */
-					*string_buf_ptr = '\0';
-					mmlval.str = string_buf;
-					string_buf_ptr = string_buf;
-					unput(',');
-					return T_ARG;
-				}
-				return ',';
-			}
-{WORD}[(]		{
-				/* May be a symbol or a macro invocation. */
-				mmlval.sym = symtable_get(mmtext);
-				if (mmlval.sym->type != MACRO) {
-					stop("Expecting Macro Name",
-					     EX_DATAERR);
-				}
-				unput('(');
-				parren_count = 0;
-				BEGIN ARGLIST;
-				return T_SYMBOL;
-			}
-.			{ 
-				snprintf(buf, sizeof(buf), "Invalid character "
-					 "'%c'", mmtext[0]);
-				stop(buf, EX_DATAERR);
-			}
-%%
-
-int
-mmwrap()
-{
-	stop("EOF encountered in macro call", EX_DATAERR);
-}
diff -urNp linux-5720/drivers/scsi/aic79xx/aicasm/aicasm_scan.l linux-5730/drivers/scsi/aic79xx/aicasm/aicasm_scan.l
--- linux-5720/drivers/scsi/aic79xx/aicasm/aicasm_scan.l
+++ linux-5730/drivers/scsi/aic79xx/aicasm/aicasm_scan.l
@@ -1,597 +0,0 @@
-%{
-/*
- * Lexical Analyzer for the Aic7xxx SCSI Host adapter sequencer assembler.
- *
- * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
- * Copyright (c) 2001, 2002 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#18 $
- *
- * $FreeBSD$
- */
-
-#include <sys/types.h>
-
-#include <inttypes.h>
-#include <limits.h>
-#include <regex.h>
-#include <stdio.h>
-#include <string.h>
-#include <sysexits.h>
-#ifdef __linux__
-#include "../queue.h"
-#else
-#include <sys/queue.h>
-#endif
-
-#include "aicasm.h"
-#include "aicasm_symbol.h"
-#include "aicasm_gram.h"
-
-/* This is used for macro body capture too, so err on the large size. */
-#define MAX_STR_CONST 4096
-static char string_buf[MAX_STR_CONST];
-static char *string_buf_ptr;
-static int  parren_count;
-static int  quote_count;
-static char buf[255];
-%}
-
-PATH		([/]*[-A-Za-z0-9_.])+
-WORD		[A-Za-z_][-A-Za-z_0-9]*
-SPACE		[ \t]+
-MCARG		[^(), \t]+
-MBODY		((\\[^\n])*[^\n\\]*)+
-
-%x COMMENT
-%x CEXPR
-%x INCLUDE
-%x STRING
-%x MACRODEF
-%x MACROARGLIST
-%x MACROCALLARGS
-%x MACROBODY
-
-%%
-\n			{ ++yylineno; }
-"/*"			{ BEGIN COMMENT;  /* Enter comment eating state */ }
-<COMMENT>"/*"		{ fprintf(stderr, "Warning! Comment within comment."); }
-<COMMENT>\n		{ ++yylineno; }
-<COMMENT>[^*/\n]*	;
-<COMMENT>"*"+[^*/\n]*	;
-<COMMENT>"/"+[^*/\n]*	;
-<COMMENT>"*"+"/"	{ BEGIN INITIAL; }
-if[ \t]*\(		{
-				string_buf_ptr = string_buf;
-				parren_count = 1;
-				BEGIN CEXPR;
-				return T_IF;
-			}
-<CEXPR>\(		{	*string_buf_ptr++ = '('; parren_count++; }
-<CEXPR>\)		{
-				parren_count--;
-				if (parren_count == 0) {
-					/* All done */
-					BEGIN INITIAL;
-					*string_buf_ptr = '\0';
-					yylval.sym = symtable_get(string_buf);
-					return T_CEXPR;
-				} else {
-					*string_buf_ptr++ = ')';
-				}
-			}
-<CEXPR>\n		{ ++yylineno; }
-<CEXPR>[^()\n]+	{
-				char *yptr;
-
-				yptr = yytext;
-				while (*yptr != '\0') {
-					/* Remove duplicate spaces */
-					if (*yptr == '\t')
-						*yptr = ' ';
-					if (*yptr == ' '
-					 && string_buf_ptr != string_buf
-					 && string_buf_ptr[-1] == ' ')
-						yptr++;
-					else 
-						*string_buf_ptr++ = *yptr++;
-				}
-			}
-
-VERSION			{ return T_VERSION; }
-PREFIX			{ return T_PREFIX; }
-PATCH_ARG_LIST		{ return T_PATCH_ARG_LIST; }
-\"			{
-				string_buf_ptr = string_buf;
-				BEGIN STRING;
-			}
-<STRING>[^"]+		{
-				char *yptr;
-
-				yptr = yytext;
-				while (*yptr)
-					*string_buf_ptr++ = *yptr++;
-			}
-<STRING>\"		{
-				/* All done */
-				BEGIN INITIAL;
-				*string_buf_ptr = '\0';
-				yylval.str = string_buf;
-				return T_STRING;
-			}
-{SPACE}			 ;
-
-	/* Register/SCB/SRAM definition keywords */
-export			{ return T_EXPORT; }
-register		{ return T_REGISTER; }
-const			{ yylval.value = FALSE; return T_CONST; }
-download		{ return T_DOWNLOAD; }
-address			{ return T_ADDRESS; }
-access_mode		{ return T_ACCESS_MODE; }
-modes			{ return T_MODES; }
-RW|RO|WO		{
-				 if (strcmp(yytext, "RW") == 0)
-					yylval.value = RW;
-				 else if (strcmp(yytext, "RO") == 0)
-					yylval.value = RO;
-				 else
-					yylval.value = WO;
-				 return T_MODE;
-			}
-BEGIN_CRITICAL		{ return T_BEGIN_CS; }
-END_CRITICAL		{ return T_END_CS; }
-SET_SRC_MODE		{ return T_SET_SRC_MODE; }
-SET_DST_MODE		{ return T_SET_DST_MODE; }
-field			{ return T_FIELD; }
-enum			{ return T_ENUM; }
-mask			{ return T_MASK; }
-alias			{ return T_ALIAS; }
-size			{ return T_SIZE; }
-scb			{ return T_SCB; }
-scratch_ram		{ return T_SRAM; }
-accumulator		{ return T_ACCUM; }
-mode_pointer		{ return T_MODE_PTR; }
-allones			{ return T_ALLONES; }
-allzeros		{ return T_ALLZEROS; }
-none			{ return T_NONE; }
-sindex			{ return T_SINDEX; }
-A			{ return T_A; }
-
-	/* Opcodes */
-shl			{ return T_SHL; }
-shr			{ return T_SHR; }
-ror			{ return T_ROR; }
-rol			{ return T_ROL; }
-mvi			{ return T_MVI; }
-mov			{ return T_MOV; }
-clr			{ return T_CLR; }
-jmp			{ return T_JMP; }
-jc			{ return T_JC;	}
-jnc			{ return T_JNC;	}
-je			{ return T_JE;	}
-jne			{ return T_JNE;	}
-jz			{ return T_JZ;	}
-jnz			{ return T_JNZ;	}
-call			{ return T_CALL; }
-add			{ return T_ADD; }
-adc			{ return T_ADC; }
-bmov			{ return T_BMOV; }
-inc			{ return T_INC; }
-dec			{ return T_DEC; }
-stc			{ return T_STC;	}
-clc			{ return T_CLC; }
-cmp			{ return T_CMP;	}
-not			{ return T_NOT;	}
-xor			{ return T_XOR;	}
-test			{ return T_TEST;}
-and			{ return T_AND;	}
-or			{ return T_OR;	}
-ret			{ return T_RET; }
-nop			{ return T_NOP; }
-else			{ return T_ELSE; }
-
-	/* Allowed Symbols */
-\<\<			{ return T_EXPR_LSHIFT; }
-\>\>			{ return T_EXPR_RSHIFT; }
-[-+,:()~|&."{};<>[\]/*!=] { return yytext[0]; }
-
-	/* Number processing */
-0[0-7]*			{
-				yylval.value = strtol(yytext, NULL, 8);
-				return T_NUMBER;
-			}
-
-0[xX][0-9a-fA-F]+	{
-				yylval.value = strtoul(yytext + 2, NULL, 16);
-				return T_NUMBER;
-			}
-
-[1-9][0-9]*		{
-				yylval.value = strtol(yytext, NULL, 10);
-				return T_NUMBER;
-			}
-	/* Include Files */
-#include{SPACE}		{
-				BEGIN INCLUDE;
-				quote_count = 0;
-				return T_INCLUDE;
-			}
-<INCLUDE>[<]		{ return yytext[0]; }
-<INCLUDE>[>]		{ BEGIN INITIAL; return yytext[0]; }
-<INCLUDE>[\"]		{
-				if (quote_count != 0)
-					BEGIN INITIAL;
-				quote_count++;
-				return yytext[0];
-			}
-<INCLUDE>{PATH}		{
-				char *yptr;
-
-				yptr = yytext;
-				string_buf_ptr = string_buf;
-				while (*yptr)
-					*string_buf_ptr++ = *yptr++;
-				yylval.str = string_buf;
-				*string_buf_ptr = '\0';
-				return T_PATH;
-			}
-<INCLUDE>.		{ stop("Invalid include line", EX_DATAERR); }
-#define{SPACE}		{
-				BEGIN MACRODEF;
-				return T_DEFINE;
-			}
-<MACRODEF>{WORD}{SPACE}	{ 
-				char *yptr;
-
-				/* Strip space and return as a normal symbol */
-				yptr = yytext;
-				while (*yptr != ' ' && *yptr != '\t')
-					yptr++;
-				*yptr = '\0';
-				yylval.sym = symtable_get(yytext);
-				string_buf_ptr = string_buf;
-				BEGIN MACROBODY;
-				return T_SYMBOL;
-			}
-<MACRODEF>{WORD}\(	{
-				/*
-				 * We store the symbol with its opening
-				 * parren so we can differentiate macros
-				 * that take args from macros with the
-				 * same name that do not take args as
-				 * is allowed in C.
-				 */
-				BEGIN MACROARGLIST;
-				yylval.sym = symtable_get(yytext);
-				unput('(');
-				return T_SYMBOL;
-			}
-<MACROARGLIST>{WORD}	{
-				yylval.str = yytext;
-				return T_ARG;
-			}
-<MACROARGLIST>{SPACE}   ;
-<MACROARGLIST>[(,]	{
-				return yytext[0];
-			}
-<MACROARGLIST>[)]	{
-				string_buf_ptr = string_buf;
-				BEGIN MACROBODY;
-				return ')';
-			}
-<MACROARGLIST>.		{
-				snprintf(buf, sizeof(buf), "Invalid character "
-					 "'%c' in macro argument list",
-					 yytext[0]);
-				stop(buf, EX_DATAERR);
-			}
-<MACROCALLARGS>{SPACE}  ;
-<MACROCALLARGS>\(	{
-				parren_count++;
-				if (parren_count == 1)
-					return ('(');
-				*string_buf_ptr++ = '(';
-			}
-<MACROCALLARGS>\)	{
-				parren_count--;
-				if (parren_count == 0) {
-					BEGIN INITIAL;
-					return (')');
-				}
-				*string_buf_ptr++ = ')';
-			}
-<MACROCALLARGS>{MCARG}	{
-				char *yptr;
-
-				yptr = yytext;
-				while (*yptr)
-					*string_buf_ptr++ = *yptr++;
-			}
-<MACROCALLARGS>\,	{
-				if (string_buf_ptr != string_buf) {
-					/*
-					 * Return an argument and
-					 * rescan this comma so we
-					 * can return it as well.
-					 */
-					*string_buf_ptr = '\0';
-					yylval.str = string_buf;
-					string_buf_ptr = string_buf;
-					unput(',');
-					return T_ARG;
-				}
-				return ',';
-			}
-<MACROBODY>\\\n		{
-				/* Eat escaped newlines. */
-				++yylineno;
-			}
-<MACROBODY>\n		{
-				/* Macros end on the first unescaped newline. */
-				BEGIN INITIAL;
-				*string_buf_ptr = '\0';
-				yylval.str = string_buf;
-				++yylineno;
-				return T_MACROBODY;
-			}
-<MACROBODY>{MBODY}	{
-				char *yptr;
-
-				yptr = yytext;
-				while (*yptr)
-					*string_buf_ptr++ = *yptr++;
-			}
-{WORD}\(		{
-				char *yptr;
-				char *ycopy;
-
-				/* May be a symbol or a macro invocation. */
-				yylval.sym = symtable_get(yytext);
-				if (yylval.sym->type == MACRO) {
-					YY_BUFFER_STATE old_state;
-					YY_BUFFER_STATE temp_state;
-
-					ycopy = strdup(yytext);
-					yptr = ycopy + yyleng;
-					while (yptr > ycopy)
-						unput(*--yptr);
-					old_state = YY_CURRENT_BUFFER;
-					temp_state =
-					    yy_create_buffer(stdin,
-							     YY_BUF_SIZE);
-					yy_switch_to_buffer(temp_state);
-					mm_switch_to_buffer(old_state);
-					mmparse();
-					mm_switch_to_buffer(temp_state);
-					yy_switch_to_buffer(old_state);
-					mm_delete_buffer(temp_state);
-					expand_macro(yylval.sym);
-				} else {
-					if (yylval.sym->type == UNINITIALIZED) {
-						/* Try without the '(' */
-						symbol_delete(yylval.sym);
-						yytext[yyleng-1] = '\0';
-						yylval.sym =
-						    symtable_get(yytext);
-					}
-					unput('(');
-					return T_SYMBOL;
-				}
-			}
-{WORD}			{
-				yylval.sym = symtable_get(yytext);
-				if (yylval.sym->type == MACRO) {
-					expand_macro(yylval.sym);
-				} else {
-					return T_SYMBOL;
-				}
-			}
-.			{ 
-				snprintf(buf, sizeof(buf), "Invalid character "
-					 "'%c'", yytext[0]);
-				stop(buf, EX_DATAERR);
-			}
-%%
-
-typedef struct include {
-        YY_BUFFER_STATE  buffer;
-        int              lineno;
-        char            *filename;
-	SLIST_ENTRY(include) links;
-}include_t;
-
-SLIST_HEAD(, include) include_stack;
-
-void
-include_file(char *file_name, include_type type)
-{
-	FILE *newfile;
-	include_t *include;
-
-	newfile = NULL;
-	/* Try the current directory first */
-	if (includes_search_curdir != 0 || type == SOURCE_FILE)
-		newfile = fopen(file_name, "r");
-
-	if (newfile == NULL && type != SOURCE_FILE) {
-                path_entry_t include_dir;
-                for (include_dir = search_path.slh_first;
-                     include_dir != NULL;                
-                     include_dir = include_dir->links.sle_next) {
-			char fullname[PATH_MAX];
-
-			if ((include_dir->quoted_includes_only == TRUE)
-			 && (type != QUOTED_INCLUDE))
-				continue;
-
-			snprintf(fullname, sizeof(fullname),
-				 "%s/%s", include_dir->directory, file_name);
-
-			if ((newfile = fopen(fullname, "r")) != NULL)
-				break;
-                }
-        }
-
-	if (newfile == NULL) {
-		perror(file_name);
-		stop("Unable to open input file", EX_SOFTWARE);
-		/* NOTREACHED */
-	}
-
-	if (type != SOURCE_FILE) {
-		include = (include_t *)malloc(sizeof(include_t));
-		if (include == NULL) {
-			stop("Unable to allocate include stack entry",
-			     EX_SOFTWARE);
-			/* NOTREACHED */
-		}
-		include->buffer = YY_CURRENT_BUFFER;
-		include->lineno = yylineno;
-		include->filename = yyfilename;
-		SLIST_INSERT_HEAD(&include_stack, include, links);
-	}
-	yy_switch_to_buffer(yy_create_buffer(newfile, YY_BUF_SIZE));
-	yylineno = 1;
-	yyfilename = strdup(file_name);
-}
-
-static void next_substitution(struct symbol *mac_symbol, const char *body_pos,
-			      const char **next_match,
-			      struct macro_arg **match_marg, regmatch_t *match);
-
-void
-expand_macro(struct symbol *macro_symbol)
-{
-	struct macro_arg *marg;
-	struct macro_arg *match_marg;
-	const char *body_head;
-	const char *body_pos;
-	const char *next_match;
-
-	/*
-	 * Due to the nature of unput, we must work
-	 * backwards through the macro body performing
-	 * any expansions.
-	 */
-	body_head = macro_symbol->info.macroinfo->body;
-	body_pos = body_head + strlen(body_head);
-	while (body_pos > body_head) {
-		regmatch_t match;
-
-		next_match = body_head;
-		match_marg = NULL;
-		next_substitution(macro_symbol, body_pos, &next_match,
-				  &match_marg, &match);
-
-		/* Put back everything up until the replacement. */
-		while (body_pos > next_match)
-			unput(*--body_pos);
-
-		/* Perform the replacement. */
-		if (match_marg != NULL) {
-			const char *strp;
-
-			next_match = match_marg->replacement_text;
-			strp = next_match + strlen(next_match);
-			while (strp > next_match)
-				unput(*--strp);
-
-			/* Skip past the unexpanded macro arg. */
-			body_pos -= match.rm_eo - match.rm_so;
-		}
-	}
-
-	/* Cleanup replacement text. */
-	STAILQ_FOREACH(marg, &macro_symbol->info.macroinfo->args, links) {
-		free(marg->replacement_text);
-	}
-}
-
-/*
- * Find the next substitution in the macro working backwards from
- * body_pos until the beginning of the macro buffer.  next_match
- * should be initialized to the beginning of the macro buffer prior
- * to calling this routine.
- */
-static void
-next_substitution(struct symbol *mac_symbol, const char *body_pos,
-		  const char **next_match, struct macro_arg **match_marg,
-		  regmatch_t *match)
-{
-	regmatch_t	  matches[2];
-	struct macro_arg *marg;
-	const char	 *search_pos;
-	int		  retval;
-
-	do {
-		search_pos = *next_match;
-
-		STAILQ_FOREACH(marg, &mac_symbol->info.macroinfo->args, links) {
-
-			retval = regexec(&marg->arg_regex, search_pos, 2,
-					 matches, 0);
-			if (retval == 0
-			 && (matches[1].rm_eo + search_pos) <= body_pos
-			 && (matches[1].rm_eo + search_pos) > *next_match) {
-				*match = matches[1];
-				*next_match = match->rm_eo + search_pos;
-				*match_marg = marg;
-			}
-		}
-	} while (search_pos != *next_match);
-}
-
-int
-yywrap()
-{
-	include_t *include;
-
-	yy_delete_buffer(YY_CURRENT_BUFFER);
-	(void)fclose(yyin);
-	if (yyfilename != NULL)
-		free(yyfilename);
-	yyfilename = NULL;
-	include = include_stack.slh_first;
-	if (include != NULL) {
-		yy_switch_to_buffer(include->buffer);
-		yylineno = include->lineno;
-		yyfilename = include->filename;
-		SLIST_REMOVE_HEAD(&include_stack, links);
-		free(include);
-		return (0);
-	}
-	return (1);
-}
diff -urNp linux-5720/drivers/scsi/aic79xx/aicasm/aicasm_symbol.c linux-5730/drivers/scsi/aic79xx/aicasm/aicasm_symbol.c
--- linux-5720/drivers/scsi/aic79xx/aicasm/aicasm_symbol.c
+++ linux-5730/drivers/scsi/aic79xx/aicasm/aicasm_symbol.c
@@ -1,677 +0,0 @@
-/*
- * Aic7xxx SCSI host adapter firmware asssembler symbol table implementation
- *
- * Copyright (c) 1997 Justin T. Gibbs.
- * Copyright (c) 2002 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#24 $
- *
- * $FreeBSD$
- */
-
-#include <sys/types.h>
-
-#ifdef __linux__
-#include "aicdb.h"
-#else
-#include <db.h>
-#endif
-#include <fcntl.h>
-#include <inttypes.h>
-#include <regex.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sysexits.h>
-
-#include "aicasm_symbol.h"
-#include "aicasm.h"
-
-static DB *symtable;
-
-symbol_t *
-symbol_create(char *name)
-{
-	symbol_t *new_symbol;
-
-	new_symbol = (symbol_t *)malloc(sizeof(symbol_t));
-	if (new_symbol == NULL) {
-		perror("Unable to create new symbol");
-		exit(EX_SOFTWARE);
-	}
-	memset(new_symbol, 0, sizeof(*new_symbol));
-	new_symbol->name = strdup(name);
-	if (new_symbol->name == NULL)
-		 stop("Unable to strdup symbol name", EX_SOFTWARE);
-	new_symbol->type = UNINITIALIZED;
-	return (new_symbol);
-}
-
-void
-symbol_delete(symbol_t *symbol)
-{
-	if (symtable != NULL) {
-		DBT	 key;
-
-		key.data = symbol->name;
-		key.size = strlen(symbol->name);
-		symtable->del(symtable, &key, /*flags*/0);
-	}
-	switch(symbol->type) {
-	case SCBLOC:
-	case SRAMLOC:
-	case REGISTER:
-		if (symbol->info.rinfo != NULL)
-			free(symbol->info.rinfo);
-		break;
-	case ALIAS:
-		if (symbol->info.ainfo != NULL)
-			free(symbol->info.ainfo);
-		break;
-	case MASK:
-	case FIELD:
-	case ENUM:
-	case ENUM_ENTRY:
-		if (symbol->info.finfo != NULL) {
-			symlist_free(&symbol->info.finfo->symrefs);
-			free(symbol->info.finfo);
-		}
-		break;
-	case DOWNLOAD_CONST:
-	case CONST:
-		if (symbol->info.cinfo != NULL)
-			free(symbol->info.cinfo);
-		break;
-	case LABEL:
-		if (symbol->info.linfo != NULL)
-			free(symbol->info.linfo);
-		break;
-	case UNINITIALIZED:
-	default:
-		break;
-	}
-	free(symbol->name);
-	free(symbol);
-}
-
-void
-symtable_open()
-{
-	symtable = dbopen(/*filename*/NULL,
-			  O_CREAT | O_NONBLOCK | O_RDWR, /*mode*/0, DB_HASH,
-			  /*openinfo*/NULL);
-
-	if (symtable == NULL) {
-		perror("Symbol table creation failed");
-		exit(EX_SOFTWARE);
-		/* NOTREACHED */
-	}
-}
-
-void
-symtable_close()
-{
-	if (symtable != NULL) {
-		DBT	 key;
-		DBT	 data;
-
-		while (symtable->seq(symtable, &key, &data, R_FIRST) == 0) {
-			symbol_t *stored_ptr;
-
-			memcpy(&stored_ptr, data.data, sizeof(stored_ptr));
-			symbol_delete(stored_ptr);
-		}
-		symtable->close(symtable);
-	}
-}
-
-/*
- * The semantics of get is to return an uninitialized symbol entry
- * if a lookup fails.
- */
-symbol_t *
-symtable_get(char *name)
-{
-	symbol_t *stored_ptr;
-	DBT	  key;
-	DBT	  data;
-	int	  retval;
-
-	key.data = (void *)name;
-	key.size = strlen(name);
-
-	if ((retval = symtable->get(symtable, &key, &data, /*flags*/0)) != 0) {
-		if (retval == -1) {
-			perror("Symbol table get operation failed");
-			exit(EX_SOFTWARE);
-			/* NOTREACHED */
-		} else if (retval == 1) {
-			/* Symbol wasn't found, so create a new one */
-			symbol_t *new_symbol;
-
-			new_symbol = symbol_create(name);
-			data.data = &new_symbol;
-			data.size = sizeof(new_symbol);
-			if (symtable->put(symtable, &key, &data,
-					  /*flags*/0) !=0) {
-				perror("Symtable put failed");
-				exit(EX_SOFTWARE);
-			}
-			return (new_symbol);
-		} else {
-			perror("Unexpected return value from db get routine");
-			exit(EX_SOFTWARE);
-			/* NOTREACHED */
-		}
-	}
-	memcpy(&stored_ptr, data.data, sizeof(stored_ptr));
-	return (stored_ptr);
-}
-
-symbol_node_t *
-symlist_search(symlist_t *symlist, char *symname)
-{
-	symbol_node_t *curnode;
-
-	curnode = SLIST_FIRST(symlist);
-	while(curnode != NULL) {
-		if (strcmp(symname, curnode->symbol->name) == 0)
-			break;
-		curnode = SLIST_NEXT(curnode, links);
-	}
-	return (curnode);
-}
-
-void
-symlist_add(symlist_t *symlist, symbol_t *symbol, int how)
-{
-	symbol_node_t *newnode;
-
-	newnode = (symbol_node_t *)malloc(sizeof(symbol_node_t));
-	if (newnode == NULL) {
-		stop("symlist_add: Unable to malloc symbol_node", EX_SOFTWARE);
-		/* NOTREACHED */
-	}
-	newnode->symbol = symbol;
-	if (how == SYMLIST_SORT) {
-		symbol_node_t *curnode;
-		int field;
-
-		field = FALSE;
-		switch(symbol->type) {
-		case REGISTER:
-		case SCBLOC:
-		case SRAMLOC:
-			break;
-		case FIELD:
-		case MASK:
-		case ENUM:
-		case ENUM_ENTRY:
-			field = TRUE;
-			break;
-		default:
-			stop("symlist_add: Invalid symbol type for sorting",
-			     EX_SOFTWARE);
-			/* NOTREACHED */
-		}
-
-		curnode = SLIST_FIRST(symlist);
-		if (curnode == NULL
-		 || (field
-		  && (curnode->symbol->type > newnode->symbol->type
-		   || (curnode->symbol->type == newnode->symbol->type
-		    && (curnode->symbol->info.finfo->value >
-			newnode->symbol->info.finfo->value))))
-		 || (!field && (curnode->symbol->info.rinfo->address >
-		               newnode->symbol->info.rinfo->address))) {
-			SLIST_INSERT_HEAD(symlist, newnode, links);
-			return;
-		}
-
-		while (1) {
-			if (SLIST_NEXT(curnode, links) == NULL) {
-				SLIST_INSERT_AFTER(curnode, newnode,
-						   links);
-				break;
-			} else {
-				symbol_t *cursymbol;
-
-				cursymbol = SLIST_NEXT(curnode, links)->symbol;
-				if ((field
-		  		  && (cursymbol->type > symbol->type
-				   || (cursymbol->type == symbol->type
-				    && (cursymbol->info.finfo->value >
-					symbol->info.finfo->value))))
-				 || (!field
-				   && (cursymbol->info.rinfo->address >
-				       symbol->info.rinfo->address))) {
-					SLIST_INSERT_AFTER(curnode, newnode,
-							   links);
-					break;
-				}
-			}
-			curnode = SLIST_NEXT(curnode, links);
-		}
-	} else {
-		SLIST_INSERT_HEAD(symlist, newnode, links);
-	}
-}
-
-void
-symlist_free(symlist_t *symlist)
-{
-	symbol_node_t *node1, *node2;
-
-	node1 = SLIST_FIRST(symlist);
-	while (node1 != NULL) {
-		node2 = SLIST_NEXT(node1, links);
-		free(node1);
-		node1 = node2;
-	}
-	SLIST_INIT(symlist);
-}
-
-void
-symlist_merge(symlist_t *symlist_dest, symlist_t *symlist_src1,
-	      symlist_t *symlist_src2)
-{
-	symbol_node_t *node;
-
-	*symlist_dest = *symlist_src1;
-	while((node = SLIST_FIRST(symlist_src2)) != NULL) {
-		SLIST_REMOVE_HEAD(symlist_src2, links);
-		SLIST_INSERT_HEAD(symlist_dest, node, links);
-	}
-
-	/* These are now empty */
-	SLIST_INIT(symlist_src1);
-	SLIST_INIT(symlist_src2);
-}
-
-void
-aic_print_file_prologue(FILE *ofile)
-{
-
-	if (ofile == NULL)
-		return;
-
-	fprintf(ofile,
-"/*\n"
-" * DO NOT EDIT - This file is automatically generated\n"
-" *		 from the following source files:\n"
-" *\n"
-"%s */\n",
-		versions);
-}
-
-void
-aic_print_include(FILE *dfile, char *include_file)
-{
-
-	if (dfile == NULL)
-		return;
-	fprintf(dfile, "\n#include \"%s\"\n\n", include_file);
-}
-
-void
-aic_print_reg_dump_types(FILE *ofile)
-{
-	if (ofile == NULL)
-		return;
-		
-	fprintf(ofile,
-"typedef int (%sreg_print_t)(u_int, u_int *, u_int);\n"
-"typedef struct %sreg_parse_entry {\n"
-"	char	*name;\n"
-"	uint8_t	 value;\n"
-"	uint8_t	 mask;\n"
-"} %sreg_parse_entry_t;\n"
-"\n",
-		prefix, prefix, prefix);
-}
-
-static void
-aic_print_reg_dump_start(FILE *dfile, symbol_node_t *regnode)
-{
-	if (dfile == NULL)
-		return;
-
-	fprintf(dfile,
-"static %sreg_parse_entry_t %s_parse_table[] = {\n",
-		prefix,
-		regnode->symbol->name);
-}
-
-static void
-aic_print_reg_dump_end(FILE *ofile, FILE *dfile,
-		       symbol_node_t *regnode, u_int num_entries)
-{
-	char *lower_name;
-	char *letter;
-
-	lower_name = strdup(regnode->symbol->name);
-	if (lower_name == NULL)
-		 stop("Unable to strdup symbol name", EX_SOFTWARE);
-	
-	for (letter = lower_name; *letter != '\0'; letter++)
-		*letter = tolower(*letter);
-
-	if (dfile != NULL) {
-		if (num_entries != 0)
-			fprintf(dfile,
-"\n"
-"};\n"
-"\n");
-
-		fprintf(dfile,
-"int\n"
-"%s%s_print(u_int regvalue, u_int *cur_col, u_int wrap)\n"
-"{\n"
-"	return (%sprint_register(%s%s, %d, \"%s\",\n"
-"	    0x%02x, regvalue, cur_col, wrap));\n"
-"}\n"
-"\n",
-			prefix,
-			lower_name,
-			prefix,
-			num_entries != 0 ? regnode->symbol->name : "NULL",
-			num_entries != 0 ? "_parse_table" : "",
-			num_entries,
-			regnode->symbol->name,
-			regnode->symbol->info.rinfo->address);
-	}
-
-	fprintf(ofile,
-"#if AIC_DEBUG_REGISTERS\n"
-"%sreg_print_t %s%s_print;\n"
-"#else\n"
-"#define %s%s_print(regvalue, cur_col, wrap) \\\n"
-"    %sprint_register(NULL, 0, \"%s\", 0x%02x, regvalue, cur_col, wrap)\n"
-"#endif\n"
-"\n",
-		prefix,
-		prefix,
-		lower_name,
-		prefix,
-		lower_name,
-		prefix,
-		regnode->symbol->name,
-		regnode->symbol->info.rinfo->address);
-}
-
-static void
-aic_print_reg_dump_entry(FILE *dfile, symbol_node_t *curnode)
-{
-	int num_tabs;
-
-	if (dfile == NULL)
-		return;
-
-	fprintf(dfile,
-"	{ \"%s\",",
-		curnode->symbol->name);
-
-	num_tabs = 3 - (strlen(curnode->symbol->name) + 5) / 8;
-
-	while (num_tabs-- > 0)
-		fputc('\t', dfile);
-	fprintf(dfile, "0x%02x, 0x%02x }",
-		curnode->symbol->info.finfo->value,
-		curnode->symbol->info.finfo->mask);
-}
-
-void
-symtable_dump(FILE *ofile, FILE *dfile)
-{
-	/*
-	 * Sort the registers by address with a simple insertion sort.
-	 * Put bitmasks next to the first register that defines them.
-	 * Put constants at the end.
-	 */
-	symlist_t	 registers;
-	symlist_t	 masks;
-	symlist_t	 constants;
-	symlist_t	 download_constants;
-	symlist_t	 aliases;
-	symlist_t	 exported_labels;
-	symbol_node_t	*curnode;
-	symbol_node_t	*regnode;
-	DBT		 key;
-	DBT		 data;
-	int		 flag;
-	u_int		 i;
-
-	if (symtable == NULL)
-		return;
-
-	SLIST_INIT(&registers);
-	SLIST_INIT(&masks);
-	SLIST_INIT(&constants);
-	SLIST_INIT(&download_constants);
-	SLIST_INIT(&aliases);
-	SLIST_INIT(&exported_labels);
-	flag = R_FIRST;
-	while (symtable->seq(symtable, &key, &data, flag) == 0) {
-		symbol_t *cursym;
-
-		memcpy(&cursym, data.data, sizeof(cursym));
-		switch(cursym->type) {
-		case REGISTER:
-		case SCBLOC:
-		case SRAMLOC:
-			symlist_add(&registers, cursym, SYMLIST_SORT);
-			break;
-		case MASK:
-		case FIELD:
-		case ENUM:
-		case ENUM_ENTRY:
-			symlist_add(&masks, cursym, SYMLIST_SORT);
-			break;
-		case CONST:
-			symlist_add(&constants, cursym,
-				    SYMLIST_INSERT_HEAD);
-			break;
-		case DOWNLOAD_CONST:
-			symlist_add(&download_constants, cursym,
-				    SYMLIST_INSERT_HEAD);
-			break;
-		case ALIAS:
-			symlist_add(&aliases, cursym,
-				    SYMLIST_INSERT_HEAD);
-			break;
-		case LABEL:
-			if (cursym->info.linfo->exported == 0)
-				break;
-			symlist_add(&exported_labels, cursym,
-				    SYMLIST_INSERT_HEAD);
-			break;
-		default:
-			break;
-		}
-		flag = R_NEXT;
-	}
-
-	/* Register dianostic functions/declarations first. */
-	aic_print_file_prologue(ofile);
-	aic_print_reg_dump_types(ofile);
-	aic_print_file_prologue(dfile);
-	aic_print_include(dfile, stock_include_file);
-	SLIST_FOREACH(curnode, &registers, links) {
-
-		switch(curnode->symbol->type) {
-		case REGISTER:
-		case SCBLOC:
-		case SRAMLOC:
-		{
-			symlist_t	*fields;
-			symbol_node_t	*fieldnode;
-			int		 num_entries;
-
-			num_entries = 0;
-			fields = &curnode->symbol->info.rinfo->fields;
-			SLIST_FOREACH(fieldnode, fields, links) {
-				if (num_entries == 0)
-					aic_print_reg_dump_start(dfile,
-								 curnode);
-				else if (dfile != NULL)
-					fputs(",\n", dfile);
-				num_entries++;
-				aic_print_reg_dump_entry(dfile, fieldnode);
-			}
-			aic_print_reg_dump_end(ofile, dfile,
-					       curnode, num_entries);
-		}
-		default:
-			break;
-		}
-	}
-
-	/* Fold in the masks and bits */
-	while (SLIST_FIRST(&masks) != NULL) {
-		char *regname;
-
-		curnode = SLIST_FIRST(&masks);
-		SLIST_REMOVE_HEAD(&masks, links);
-
-		regnode = SLIST_FIRST(&curnode->symbol->info.finfo->symrefs);
-		regname = regnode->symbol->name;
-		regnode = symlist_search(&registers, regname);
-		SLIST_INSERT_AFTER(regnode, curnode, links);
-	}
-
-	/* Add the aliases */
-	while (SLIST_FIRST(&aliases) != NULL) {
-		char *regname;
-
-		curnode = SLIST_FIRST(&aliases);
-		SLIST_REMOVE_HEAD(&aliases, links);
-
-		regname = curnode->symbol->info.ainfo->parent->name;
-		regnode = symlist_search(&registers, regname);
-		SLIST_INSERT_AFTER(regnode, curnode, links);
-	}
-
-	/* Output generated #defines. */
-	while (SLIST_FIRST(&registers) != NULL) {
-		symbol_node_t *curnode;
-		u_int value;
-		char *tab_str;
-		char *tab_str2;
-
-		curnode = SLIST_FIRST(&registers);
-		SLIST_REMOVE_HEAD(&registers, links);
-		switch(curnode->symbol->type) {
-		case REGISTER:
-		case SCBLOC:
-		case SRAMLOC:
-			fprintf(ofile, "\n");
-			value = curnode->symbol->info.rinfo->address;
-			tab_str = "\t";
-			tab_str2 = "\t\t";
-			break;
-		case ALIAS:
-		{
-			symbol_t *parent;
-
-			parent = curnode->symbol->info.ainfo->parent;
-			value = parent->info.rinfo->address;
-			tab_str = "\t";
-			tab_str2 = "\t\t";
-			break;
-		}
-		case MASK:
-		case FIELD:
-		case ENUM:
-		case ENUM_ENTRY:
-			value = curnode->symbol->info.finfo->value;
-			tab_str = "\t\t";
-			tab_str2 = "\t";
-			break;
-		default:
-			value = 0; /* Quiet compiler */
-			tab_str = NULL;
-			tab_str2 = NULL;
-			stop("symtable_dump: Invalid symbol type "
-			     "encountered", EX_SOFTWARE);
-			break;
-		}
-		fprintf(ofile, "#define%s%-16s%s0x%02x\n",
-			tab_str, curnode->symbol->name, tab_str2,
-			value);
-		free(curnode);
-	}
-	fprintf(ofile, "\n\n");
-
-	while (SLIST_FIRST(&constants) != NULL) {
-		symbol_node_t *curnode;
-
-		curnode = SLIST_FIRST(&constants);
-		SLIST_REMOVE_HEAD(&constants, links);
-		fprintf(ofile, "#define\t%-8s\t0x%02x\n",
-			curnode->symbol->name,
-			curnode->symbol->info.cinfo->value);
-		free(curnode);
-	}
-
-	
-	fprintf(ofile, "\n\n/* Downloaded Constant Definitions */\n");
-
-	for (i = 0; SLIST_FIRST(&download_constants) != NULL; i++) {
-		symbol_node_t *curnode;
-
-		curnode = SLIST_FIRST(&download_constants);
-		SLIST_REMOVE_HEAD(&download_constants, links);
-		fprintf(ofile, "#define\t%-8s\t0x%02x\n",
-			curnode->symbol->name,
-			curnode->symbol->info.cinfo->value);
-		free(curnode);
-	}
-	fprintf(ofile, "#define\tDOWNLOAD_CONST_COUNT\t0x%02x\n", i);
-
-	fprintf(ofile, "\n\n/* Exported Labels */\n");
-
-	while (SLIST_FIRST(&exported_labels) != NULL) {
-		symbol_node_t *curnode;
-
-		curnode = SLIST_FIRST(&exported_labels);
-		SLIST_REMOVE_HEAD(&exported_labels, links);
-		fprintf(ofile, "#define\tLABEL_%-8s\t0x%02x\n",
-			curnode->symbol->name,
-			curnode->symbol->info.linfo->address);
-		free(curnode);
-	}
-}
-
diff -urNp linux-5720/drivers/scsi/aic79xx/aicasm/aicasm_symbol.h linux-5730/drivers/scsi/aic79xx/aicasm/aicasm_symbol.h
--- linux-5720/drivers/scsi/aic79xx/aicasm/aicasm_symbol.h
+++ linux-5730/drivers/scsi/aic79xx/aicasm/aicasm_symbol.h
@@ -1,207 +0,0 @@
-/*
- * Aic7xxx SCSI host adapter firmware asssembler symbol table definitions
- *
- * Copyright (c) 1997 Justin T. Gibbs.
- * Copyright (c) 2002 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#17 $
- *
- * $FreeBSD$
- */
-
-#ifdef __linux__
-#include "../queue.h"
-#else
-#include <sys/queue.h>
-#endif
-
-typedef enum {
-	UNINITIALIZED,
-	REGISTER,
-	ALIAS,
-	SCBLOC,
-	SRAMLOC,
-	ENUM_ENTRY,
-	FIELD,
-	MASK,
-	ENUM,
-	CONST,
-	DOWNLOAD_CONST,
-	LABEL,
-	CONDITIONAL,
-	MACRO
-} symtype;
-
-typedef enum {
-	RO = 0x01,
-	WO = 0x02,
-	RW = 0x03
-}amode_t;
-
-typedef SLIST_HEAD(symlist, symbol_node) symlist_t;
-
-struct reg_info {
-	u_int	  address;
-	int	  size;
-	amode_t	  mode;
-	symlist_t fields;
-	uint8_t	  valid_bitmask;
-	uint8_t	  modes;
-	int	  typecheck_masks;
-};
-
-struct field_info {
-	symlist_t symrefs;
-	uint8_t	  value;
-	uint8_t	  mask;
-};
-
-struct const_info {
-	u_int	value;
-	int	define;
-};
-
-struct alias_info {
-	struct symbol *parent;
-};
-
-struct label_info {
-	int	address;
-	int	exported;
-};
-
-struct cond_info {
-	int	func_num;
-};
-
-struct macro_arg {
-	STAILQ_ENTRY(macro_arg)	links;
-	regex_t	arg_regex;
-	char   *replacement_text;
-};
-STAILQ_HEAD(macro_arg_list, macro_arg) args;
-
-struct macro_info {
-	struct macro_arg_list args;
-	int   narg;
-	const char* body;
-};
-
-typedef struct expression_info {
-        symlist_t       referenced_syms;
-        int             value;
-} expression_t;
-
-typedef struct symbol {
-	char	*name;
-	symtype	type;
-	union	{
-		struct reg_info	  *rinfo;
-		struct field_info *finfo;
-		struct const_info *cinfo;
-		struct alias_info *ainfo;
-		struct label_info *linfo;
-		struct cond_info  *condinfo;
-		struct macro_info *macroinfo;
-	}info;
-} symbol_t;
-
-typedef struct symbol_ref {
-	symbol_t *symbol;
-	int	 offset;
-} symbol_ref_t;
-
-typedef struct symbol_node {
-	SLIST_ENTRY(symbol_node) links;
-	symbol_t *symbol;
-} symbol_node_t;
-
-typedef struct critical_section {
-	TAILQ_ENTRY(critical_section) links;
-	int begin_addr;
-	int end_addr;
-} critical_section_t;
-
-typedef enum {
-	SCOPE_ROOT,
-	SCOPE_IF,
-	SCOPE_ELSE_IF,
-	SCOPE_ELSE
-} scope_type;
-
-typedef struct patch_info {
-	int skip_patch;
-	int skip_instr;
-} patch_info_t;
-
-typedef struct scope {
-	SLIST_ENTRY(scope) scope_stack_links;
-	TAILQ_ENTRY(scope) scope_links;
-	TAILQ_HEAD(, scope) inner_scope;
-	scope_type type;
-	int inner_scope_patches;
-	int begin_addr;
-        int end_addr;
-	patch_info_t patches[2];
-	int func_num;
-} scope_t;
-
-TAILQ_HEAD(cs_tailq, critical_section);
-SLIST_HEAD(scope_list, scope);
-TAILQ_HEAD(scope_tailq, scope);
-
-void	symbol_delete(symbol_t *symbol);
-
-void	symtable_open(void);
-
-void	symtable_close(void);
-
-symbol_t *
-	symtable_get(char *name);
-
-symbol_node_t *
-	symlist_search(symlist_t *symlist, char *symname);
-
-void
-	symlist_add(symlist_t *symlist, symbol_t *symbol, int how);
-#define SYMLIST_INSERT_HEAD	0x00
-#define SYMLIST_SORT		0x01
-
-void	symlist_free(symlist_t *symlist);
-
-void	symlist_merge(symlist_t *symlist_dest, symlist_t *symlist_src1,
-		      symlist_t *symlist_src2);
-void	symtable_dump(FILE *ofile, FILE *dfile);
diff -urNp linux-5720/drivers/scsi/aic79xx/aiclib.c linux-5730/drivers/scsi/aic79xx/aiclib.c
--- linux-5720/drivers/scsi/aic79xx/aiclib.c
+++ linux-5730/drivers/scsi/aic79xx/aiclib.c
@@ -1,1335 +0,0 @@
-/*
- * Implementation of Utility functions for all SCSI device types.
- *
- * Copyright (c) 1997, 1998, 1999 Justin T. Gibbs.
- * Copyright (c) 1997, 1998 Kenneth D. Merry.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification, immediately at the beginning of the file.
- * 2. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $FreeBSD: src/sys/cam/scsi/scsi_all.c,v 1.38 2002/09/23 04:56:35 mjacob Exp $
- * $Id$
- */
-
-#include <linux/blk.h>
-#include <linux/blkdev.h>
-#include <linux/delay.h>
-#include <linux/version.h>
-
-/* Core SCSI definitions */
-#include "scsi.h"
-#include "hosts.h"
-#include "aiclib.h"
-#include "cam.h"
-
-#ifndef FALSE
-#define FALSE   0
-#endif /* FALSE */
-#ifndef TRUE
-#define TRUE    1
-#endif /* TRUE */
-#ifndef ERESTART
-#define ERESTART        -1              /* restart syscall */
-#endif
-#ifndef EJUSTRETURN
-#define EJUSTRETURN     -2              /* don't modify regs, just return */
-#endif
-
-static int	ascentrycomp(const void *key, const void *member);
-static int	senseentrycomp(const void *key, const void *member);
-static void	fetchtableentries(int sense_key, int asc, int ascq,
-				  struct scsi_inquiry_data *,
-				  const struct sense_key_table_entry **,
-				  const struct asc_table_entry **);
-static void *	scsibsearch(const void *key, const void *base, size_t nmemb,
-			    size_t size,
-			    int (*compar)(const void *, const void *));
-typedef int (cam_quirkmatch_t)(caddr_t, caddr_t);
-static int	cam_strmatch(const u_int8_t *str, const u_int8_t *pattern,
-			     int str_len);
-static caddr_t	cam_quirkmatch(caddr_t target, caddr_t quirk_table,
-			       int num_entries, int entry_size,
-			       cam_quirkmatch_t *comp_func);
-
-#define SCSI_NO_SENSE_STRINGS 1
-#if !defined(SCSI_NO_SENSE_STRINGS)
-#define SST(asc, ascq, action, desc) \
-	asc, ascq, action, desc
-#else 
-static const char empty_string[] = "";
-
-#define SST(asc, ascq, action, desc) \
-	asc, ascq, action, empty_string
-#endif 
-
-static const struct sense_key_table_entry sense_key_table[] = 
-{
-	{ SSD_KEY_NO_SENSE, SS_NOP, "NO SENSE" },
-	{ SSD_KEY_RECOVERED_ERROR, SS_NOP|SSQ_PRINT_SENSE, "RECOVERED ERROR" },
-	{
-	  SSD_KEY_NOT_READY, SS_TUR|SSQ_MANY|SSQ_DECREMENT_COUNT|EBUSY,
-	  "NOT READY"
-	},
-	{ SSD_KEY_MEDIUM_ERROR, SS_RDEF, "MEDIUM ERROR" },
-	{ SSD_KEY_HARDWARE_ERROR, SS_RDEF, "HARDWARE FAILURE" },
-	{ SSD_KEY_ILLEGAL_REQUEST, SS_FATAL|EINVAL, "ILLEGAL REQUEST" },
-	{ SSD_KEY_UNIT_ATTENTION, SS_FATAL|ENXIO, "UNIT ATTENTION" },
-	{ SSD_KEY_DATA_PROTECT, SS_FATAL|EACCES, "DATA PROTECT" },
-	{ SSD_KEY_BLANK_CHECK, SS_FATAL|ENOSPC, "BLANK CHECK" },
-	{ SSD_KEY_Vendor_Specific, SS_FATAL|EIO, "Vendor Specific" },
-	{ SSD_KEY_COPY_ABORTED, SS_FATAL|EIO, "COPY ABORTED" },
-	{ SSD_KEY_ABORTED_COMMAND, SS_RDEF, "ABORTED COMMAND" },
-	{ SSD_KEY_EQUAL, SS_NOP, "EQUAL" },
-	{ SSD_KEY_VOLUME_OVERFLOW, SS_FATAL|EIO, "VOLUME OVERFLOW" },
-	{ SSD_KEY_MISCOMPARE, SS_NOP, "MISCOMPARE" },
-	{ SSD_KEY_RESERVED, SS_FATAL|EIO, "RESERVED" }
-};
-
-static const int sense_key_table_size =
-    sizeof(sense_key_table)/sizeof(sense_key_table[0]);
-
-static struct asc_table_entry quantum_fireball_entries[] = {
-	{SST(0x04, 0x0b, SS_START|SSQ_DECREMENT_COUNT|ENXIO, 
-	     "Logical unit not ready, initializing cmd. required")}
-};
-
-static struct asc_table_entry sony_mo_entries[] = {
-	{SST(0x04, 0x00, SS_START|SSQ_DECREMENT_COUNT|ENXIO,
-	     "Logical unit not ready, cause not reportable")}
-};
-
-static struct scsi_sense_quirk_entry sense_quirk_table[] = {
-	{
-		/*
-		 * The Quantum Fireball ST and SE like to return 0x04 0x0b when
-		 * they really should return 0x04 0x02.  0x04,0x0b isn't
-		 * defined in any SCSI spec, and it isn't mentioned in the
-		 * hardware manual for these drives.
-		 */
-		{T_DIRECT, SIP_MEDIA_FIXED, "QUANTUM", "FIREBALL S*", "*"},
-		/*num_sense_keys*/0,
-		sizeof(quantum_fireball_entries)/sizeof(struct asc_table_entry),
-		/*sense key entries*/NULL,
-		quantum_fireball_entries
-	},
-	{
-		/*
-		 * This Sony MO drive likes to return 0x04, 0x00 when it
-		 * isn't spun up.
-		 */
-		{T_DIRECT, SIP_MEDIA_REMOVABLE, "SONY", "SMO-*", "*"},
-		/*num_sense_keys*/0,
-		sizeof(sony_mo_entries)/sizeof(struct asc_table_entry),
-		/*sense key entries*/NULL,
-		sony_mo_entries
-	}
-};
-
-static const int sense_quirk_table_size =
-    sizeof(sense_quirk_table)/sizeof(sense_quirk_table[0]);
-
-static struct asc_table_entry asc_table[] = {
-/*
- * From File: ASC-NUM.TXT
- * SCSI ASC/ASCQ Assignments
- * Numeric Sorted Listing
- * as of  5/12/97
- *
- * D - DIRECT ACCESS DEVICE (SBC)                     device column key
- * .T - SEQUENTIAL ACCESS DEVICE (SSC)               -------------------
- * . L - PRINTER DEVICE (SSC)                           blank = reserved
- * .  P - PROCESSOR DEVICE (SPC)                     not blank = allowed
- * .  .W - WRITE ONCE READ MULTIPLE DEVICE (SBC)
- * .  . R - CD DEVICE (MMC)
- * .  .  S - SCANNER DEVICE (SGC)
- * .  .  .O - OPTICAL MEMORY DEVICE (SBC)
- * .  .  . M - MEDIA CHANGER DEVICE (SMC)
- * .  .  .  C - COMMUNICATION DEVICE (SSC)
- * .  .  .  .A - STORAGE ARRAY DEVICE (SCC)
- * .  .  .  . E - ENCLOSURE SERVICES DEVICE (SES)
- * DTLPWRSOMCAE        ASC   ASCQ  Action  Description
- * ------------        ----  ----  ------  -----------------------------------*/
-/* DTLPWRSOMCAE */{SST(0x00, 0x00, SS_NOP,
-			"No additional sense information") },
-/*  T    S      */{SST(0x00, 0x01, SS_RDEF,
-			"Filemark detected") },
-/*  T    S      */{SST(0x00, 0x02, SS_RDEF,
-			"End-of-partition/medium detected") },
-/*  T           */{SST(0x00, 0x03, SS_RDEF,
-			"Setmark detected") },
-/*  T    S      */{SST(0x00, 0x04, SS_RDEF,
-			"Beginning-of-partition/medium detected") },
-/*  T    S      */{SST(0x00, 0x05, SS_RDEF,
-			"End-of-data detected") },
-/* DTLPWRSOMCAE */{SST(0x00, 0x06, SS_RDEF,
-			"I/O process terminated") },
-/*      R       */{SST(0x00, 0x11, SS_FATAL|EBUSY,
-			"Audio play operation in progress") },
-/*      R       */{SST(0x00, 0x12, SS_NOP,
-			"Audio play operation paused") },
-/*      R       */{SST(0x00, 0x13, SS_NOP,
-			"Audio play operation successfully completed") },
-/*      R       */{SST(0x00, 0x14, SS_RDEF,
-			"Audio play operation stopped due to error") },
-/*      R       */{SST(0x00, 0x15, SS_NOP,
-			"No current audio status to return") },
-/* DTLPWRSOMCAE */{SST(0x00, 0x16, SS_FATAL|EBUSY,
-			"Operation in progress") },
-/* DTL WRSOM AE */{SST(0x00, 0x17, SS_RDEF,
-			"Cleaning requested") },
-/* D   W  O     */{SST(0x01, 0x00, SS_RDEF,
-			"No index/sector signal") },
-/* D   WR OM    */{SST(0x02, 0x00, SS_RDEF,
-			"No seek complete") },
-/* DTL W SO     */{SST(0x03, 0x00, SS_RDEF,
-			"Peripheral device write fault") },
-/*  T           */{SST(0x03, 0x01, SS_RDEF,
-			"No write current") },
-/*  T           */{SST(0x03, 0x02, SS_RDEF,
-			"Excessive write errors") },
-/* DTLPWRSOMCAE */{SST(0x04, 0x00,
-			SS_TUR|SSQ_DELAY|SSQ_MANY|SSQ_DECREMENT_COUNT|EIO,
-			"Logical unit not ready, cause not reportable") },
-/* DTLPWRSOMCAE */{SST(0x04, 0x01,
-			SS_TUR|SSQ_DELAY|SSQ_MANY|SSQ_DECREMENT_COUNT|EBUSY,
-			"Logical unit is in process of becoming ready") },
-/* DTLPWRSOMCAE */{SST(0x04, 0x02, SS_START|SSQ_DECREMENT_COUNT|ENXIO,
-			"Logical unit not ready, initializing cmd. required") },
-/* DTLPWRSOMCAE */{SST(0x04, 0x03, SS_FATAL|ENXIO,
-			"Logical unit not ready, manual intervention required")},
-/* DTL    O     */{SST(0x04, 0x04, SS_FATAL|EBUSY,
-			"Logical unit not ready, format in progress") },
-/* DT  W  OMCA  */{SST(0x04, 0x05, SS_FATAL|EBUSY,
-			"Logical unit not ready, rebuild in progress") },
-/* DT  W  OMCA  */{SST(0x04, 0x06, SS_FATAL|EBUSY,
-			"Logical unit not ready, recalculation in progress") },
-/* DTLPWRSOMCAE */{SST(0x04, 0x07, SS_FATAL|EBUSY,
-			"Logical unit not ready, operation in progress") },
-/*      R       */{SST(0x04, 0x08, SS_FATAL|EBUSY,
-			"Logical unit not ready, long write in progress") },
-/* DTL WRSOMCAE */{SST(0x05, 0x00, SS_RDEF,
-			"Logical unit does not respond to selection") },
-/* D   WR OM    */{SST(0x06, 0x00, SS_RDEF,
-			"No reference position found") },
-/* DTL WRSOM    */{SST(0x07, 0x00, SS_RDEF,
-			"Multiple peripheral devices selected") },
-/* DTL WRSOMCAE */{SST(0x08, 0x00, SS_RDEF,
-			"Logical unit communication failure") },
-/* DTL WRSOMCAE */{SST(0x08, 0x01, SS_RDEF,
-			"Logical unit communication time-out") },
-/* DTL WRSOMCAE */{SST(0x08, 0x02, SS_RDEF,
-			"Logical unit communication parity error") },
-/* DT   R OM    */{SST(0x08, 0x03, SS_RDEF,
-			"Logical unit communication crc error (ultra-dma/32)")},
-/* DT  WR O     */{SST(0x09, 0x00, SS_RDEF,
-			"Track following error") },
-/*     WR O     */{SST(0x09, 0x01, SS_RDEF,
-			"Tracking servo failure") },
-/*     WR O     */{SST(0x09, 0x02, SS_RDEF,
-			"Focus servo failure") },
-/*     WR O     */{SST(0x09, 0x03, SS_RDEF,
-			"Spindle servo failure") },
-/* DT  WR O     */{SST(0x09, 0x04, SS_RDEF,
-			"Head select fault") },
-/* DTLPWRSOMCAE */{SST(0x0A, 0x00, SS_FATAL|ENOSPC,
-			"Error log overflow") },
-/* DTLPWRSOMCAE */{SST(0x0B, 0x00, SS_RDEF,
-			"Warning") },
-/* DTLPWRSOMCAE */{SST(0x0B, 0x01, SS_RDEF,
-			"Specified temperature exceeded") },
-/* DTLPWRSOMCAE */{SST(0x0B, 0x02, SS_RDEF,
-			"Enclosure degraded") },
-/*  T   RS      */{SST(0x0C, 0x00, SS_RDEF,
-			"Write error") },
-/* D   W  O     */{SST(0x0C, 0x01, SS_NOP|SSQ_PRINT_SENSE,
-			"Write error - recovered with auto reallocation") },
-/* D   W  O     */{SST(0x0C, 0x02, SS_RDEF,
-			"Write error - auto reallocation failed") },
-/* D   W  O     */{SST(0x0C, 0x03, SS_RDEF,
-			"Write error - recommend reassignment") },
-/* DT  W  O     */{SST(0x0C, 0x04, SS_RDEF,
-			"Compression check miscompare error") },
-/* DT  W  O     */{SST(0x0C, 0x05, SS_RDEF,
-			"Data expansion occurred during compression") },
-/* DT  W  O     */{SST(0x0C, 0x06, SS_RDEF,
-			"Block not compressible") },
-/*      R       */{SST(0x0C, 0x07, SS_RDEF,
-			"Write error - recovery needed") },
-/*      R       */{SST(0x0C, 0x08, SS_RDEF,
-			"Write error - recovery failed") },
-/*      R       */{SST(0x0C, 0x09, SS_RDEF,
-			"Write error - loss of streaming") },
-/*      R       */{SST(0x0C, 0x0A, SS_RDEF,
-			"Write error - padding blocks added") },
-/* D   W  O     */{SST(0x10, 0x00, SS_RDEF,
-			"ID CRC or ECC error") },
-/* DT  WRSO     */{SST(0x11, 0x00, SS_RDEF,
-			"Unrecovered read error") },
-/* DT  W SO     */{SST(0x11, 0x01, SS_RDEF,
-			"Read retries exhausted") },
-/* DT  W SO     */{SST(0x11, 0x02, SS_RDEF,
-			"Error too long to correct") },
-/* DT  W SO     */{SST(0x11, 0x03, SS_RDEF,
-			"Multiple read errors") },
-/* D   W  O     */{SST(0x11, 0x04, SS_RDEF,
-			"Unrecovered read error - auto reallocate failed") },
-/*     WR O     */{SST(0x11, 0x05, SS_RDEF,
-			"L-EC uncorrectable error") },
-/*     WR O     */{SST(0x11, 0x06, SS_RDEF,
-			"CIRC unrecovered error") },
-/*     W  O     */{SST(0x11, 0x07, SS_RDEF,
-			"Data re-synchronization error") },
-/*  T           */{SST(0x11, 0x08, SS_RDEF,
-			"Incomplete block read") },
-/*  T           */{SST(0x11, 0x09, SS_RDEF,
-			"No gap found") },
-/* DT     O     */{SST(0x11, 0x0A, SS_RDEF,
-			"Miscorrected error") },
-/* D   W  O     */{SST(0x11, 0x0B, SS_RDEF,
-			"Unrecovered read error - recommend reassignment") },
-/* D   W  O     */{SST(0x11, 0x0C, SS_RDEF,
-			"Unrecovered read error - recommend rewrite the data")},
-/* DT  WR O     */{SST(0x11, 0x0D, SS_RDEF,
-			"De-compression CRC error") },
-/* DT  WR O     */{SST(0x11, 0x0E, SS_RDEF,
-			"Cannot decompress using declared algorithm") },
-/*      R       */{SST(0x11, 0x0F, SS_RDEF,
-			"Error reading UPC/EAN number") },
-/*      R       */{SST(0x11, 0x10, SS_RDEF,
-			"Error reading ISRC number") },
-/*      R       */{SST(0x11, 0x11, SS_RDEF,
-			"Read error - loss of streaming") },
-/* D   W  O     */{SST(0x12, 0x00, SS_RDEF,
-			"Address mark not found for id field") },
-/* D   W  O     */{SST(0x13, 0x00, SS_RDEF,
-			"Address mark not found for data field") },
-/* DTL WRSO     */{SST(0x14, 0x00, SS_RDEF,
-			"Recorded entity not found") },
-/* DT  WR O     */{SST(0x14, 0x01, SS_RDEF,
-			"Record not found") },
-/*  T           */{SST(0x14, 0x02, SS_RDEF,
-			"Filemark or setmark not found") },
-/*  T           */{SST(0x14, 0x03, SS_RDEF,
-			"End-of-data not found") },
-/*  T           */{SST(0x14, 0x04, SS_RDEF,
-			"Block sequence error") },
-/* DT  W  O     */{SST(0x14, 0x05, SS_RDEF,
-			"Record not found - recommend reassignment") },
-/* DT  W  O     */{SST(0x14, 0x06, SS_RDEF,
-			"Record not found - data auto-reallocated") },
-/* DTL WRSOM    */{SST(0x15, 0x00, SS_RDEF,
-			"Random positioning error") },
-/* DTL WRSOM    */{SST(0x15, 0x01, SS_RDEF,
-			"Mechanical positioning error") },
-/* DT  WR O     */{SST(0x15, 0x02, SS_RDEF,
-			"Positioning error detected by read of medium") },
-/* D   W  O     */{SST(0x16, 0x00, SS_RDEF,
-			"Data synchronization mark error") },
-/* D   W  O     */{SST(0x16, 0x01, SS_RDEF,
-			"Data sync error - data rewritten") },
-/* D   W  O     */{SST(0x16, 0x02, SS_RDEF,
-			"Data sync error - recommend rewrite") },
-/* D   W  O     */{SST(0x16, 0x03, SS_NOP|SSQ_PRINT_SENSE,
-			"Data sync error - data auto-reallocated") },
-/* D   W  O     */{SST(0x16, 0x04, SS_RDEF,
-			"Data sync error - recommend reassignment") },
-/* DT  WRSO     */{SST(0x17, 0x00, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data with no error correction applied") },
-/* DT  WRSO     */{SST(0x17, 0x01, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data with retries") },
-/* DT  WR O     */{SST(0x17, 0x02, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data with positive head offset") },
-/* DT  WR O     */{SST(0x17, 0x03, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data with negative head offset") },
-/*     WR O     */{SST(0x17, 0x04, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data with retries and/or CIRC applied") },
-/* D   WR O     */{SST(0x17, 0x05, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data using previous sector id") },
-/* D   W  O     */{SST(0x17, 0x06, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data without ECC - data auto-reallocated") },
-/* D   W  O     */{SST(0x17, 0x07, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data without ECC - recommend reassignment")},
-/* D   W  O     */{SST(0x17, 0x08, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data without ECC - recommend rewrite") },
-/* D   W  O     */{SST(0x17, 0x09, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data without ECC - data rewritten") },
-/* D   W  O     */{SST(0x18, 0x00, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data with error correction applied") },
-/* D   WR O     */{SST(0x18, 0x01, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data with error corr. & retries applied") },
-/* D   WR O     */{SST(0x18, 0x02, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data - data auto-reallocated") },
-/*      R       */{SST(0x18, 0x03, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data with CIRC") },
-/*      R       */{SST(0x18, 0x04, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data with L-EC") },
-/* D   WR O     */{SST(0x18, 0x05, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data - recommend reassignment") },
-/* D   WR O     */{SST(0x18, 0x06, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data - recommend rewrite") },
-/* D   W  O     */{SST(0x18, 0x07, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered data with ECC - data rewritten") },
-/* D      O     */{SST(0x19, 0x00, SS_RDEF,
-			"Defect list error") },
-/* D      O     */{SST(0x19, 0x01, SS_RDEF,
-			"Defect list not available") },
-/* D      O     */{SST(0x19, 0x02, SS_RDEF,
-			"Defect list error in primary list") },
-/* D      O     */{SST(0x19, 0x03, SS_RDEF,
-			"Defect list error in grown list") },
-/* DTLPWRSOMCAE */{SST(0x1A, 0x00, SS_RDEF,
-			"Parameter list length error") },
-/* DTLPWRSOMCAE */{SST(0x1B, 0x00, SS_RDEF,
-			"Synchronous data transfer error") },
-/* D      O     */{SST(0x1C, 0x00, SS_RDEF,
-			"Defect list not found") },
-/* D      O     */{SST(0x1C, 0x01, SS_RDEF,
-			"Primary defect list not found") },
-/* D      O     */{SST(0x1C, 0x02, SS_RDEF,
-			"Grown defect list not found") },
-/* D   W  O     */{SST(0x1D, 0x00, SS_FATAL,
-			"Miscompare during verify operation" )},
-/* D   W  O     */{SST(0x1E, 0x00, SS_NOP|SSQ_PRINT_SENSE,
-			"Recovered id with ecc correction") },
-/* D      O     */{SST(0x1F, 0x00, SS_RDEF,
-			"Partial defect list transfer") },
-/* DTLPWRSOMCAE */{SST(0x20, 0x00, SS_FATAL|EINVAL,
-			"Invalid command operation code") },
-/* DT  WR OM    */{SST(0x21, 0x00, SS_FATAL|EINVAL,
-			"Logical block address out of range" )},
-/* DT  WR OM    */{SST(0x21, 0x01, SS_FATAL|EINVAL,
-			"Invalid element address") },
-/* D            */{SST(0x22, 0x00, SS_FATAL|EINVAL,
-			"Illegal function") }, /* Deprecated. Use 20 00, 24 00, or 26 00 instead */
-/* DTLPWRSOMCAE */{SST(0x24, 0x00, SS_FATAL|EINVAL,
-			"Invalid field in CDB") },
-/* DTLPWRSOMCAE */{SST(0x25, 0x00, SS_FATAL|ENXIO,
-			"Logical unit not supported") },
-/* DTLPWRSOMCAE */{SST(0x26, 0x00, SS_FATAL|EINVAL,
-			"Invalid field in parameter list") },
-/* DTLPWRSOMCAE */{SST(0x26, 0x01, SS_FATAL|EINVAL,
-			"Parameter not supported") },
-/* DTLPWRSOMCAE */{SST(0x26, 0x02, SS_FATAL|EINVAL,
-			"Parameter value invalid") },
-/* DTLPWRSOMCAE */{SST(0x26, 0x03, SS_FATAL|EINVAL,
-			"Threshold parameters not supported") },
-/* DTLPWRSOMCAE */{SST(0x26, 0x04, SS_FATAL|EINVAL,
-			"Invalid release of active persistent reservation") },
-/* DT  W  O     */{SST(0x27, 0x00, SS_FATAL|EACCES,
-			"Write protected") },
-/* DT  W  O     */{SST(0x27, 0x01, SS_FATAL|EACCES,
-			"Hardware write protected") },
-/* DT  W  O     */{SST(0x27, 0x02, SS_FATAL|EACCES,
-			"Logical unit software write protected") },
-/*  T           */{SST(0x27, 0x03, SS_FATAL|EACCES,
-			"Associated write protect") },
-/*  T           */{SST(0x27, 0x04, SS_FATAL|EACCES,
-			"Persistent write protect") },
-/*  T           */{SST(0x27, 0x05, SS_FATAL|EACCES,
-			"Permanent write protect") },
-/* DTLPWRSOMCAE */{SST(0x28, 0x00, SS_RDEF,
-			"Not ready to ready change, medium may have changed") },
-/* DTLPWRSOMCAE */{SST(0x28, 0x01, SS_FATAL|ENXIO,
-			"Import or export element accessed") },
-/*
- * XXX JGibbs - All of these should use the same errno, but I don't think
- * ENXIO is the correct choice.  Should we borrow from the networking
- * errnos?  ECONNRESET anyone?
- */
-/* DTLPWRSOMCAE */{SST(0x29, 0x00, SS_RDEF,
-			"Power on, reset, or bus device reset occurred") },
-/* DTLPWRSOMCAE */{SST(0x29, 0x01, SS_RDEF,
-			"Power on occurred") },
-/* DTLPWRSOMCAE */{SST(0x29, 0x02, SS_RDEF,
-			"Scsi bus reset occurred") },
-/* DTLPWRSOMCAE */{SST(0x29, 0x03, SS_RDEF,
-			"Bus device reset function occurred") },
-/* DTLPWRSOMCAE */{SST(0x29, 0x04, SS_RDEF,
-			"Device internal reset") },
-/* DTLPWRSOMCAE */{SST(0x29, 0x05, SS_RDEF,
-			"Transceiver mode changed to single-ended") },
-/* DTLPWRSOMCAE */{SST(0x29, 0x06, SS_RDEF,
-			"Transceiver mode changed to LVD") },
-/* DTL WRSOMCAE */{SST(0x2A, 0x00, SS_RDEF,
-			"Parameters changed") },
-/* DTL WRSOMCAE */{SST(0x2A, 0x01, SS_RDEF,
-			"Mode parameters changed") },
-/* DTL WRSOMCAE */{SST(0x2A, 0x02, SS_RDEF,
-			"Log parameters changed") },
-/* DTLPWRSOMCAE */{SST(0x2A, 0x03, SS_RDEF,
-			"Reservations preempted") },
-/* DTLPWRSO C   */{SST(0x2B, 0x00, SS_RDEF,
-			"Copy cannot execute since host cannot disconnect") },
-/* DTLPWRSOMCAE */{SST(0x2C, 0x00, SS_RDEF,
-			"Command sequence error") },
-/*       S      */{SST(0x2C, 0x01, SS_RDEF,
-			"Too many windows specified") },
-/*       S      */{SST(0x2C, 0x02, SS_RDEF,
-			"Invalid combination of windows specified") },
-/*      R       */{SST(0x2C, 0x03, SS_RDEF,
-			"Current program area is not empty") },
-/*      R       */{SST(0x2C, 0x04, SS_RDEF,
-			"Current program area is empty") },
-/*  T           */{SST(0x2D, 0x00, SS_RDEF,
-			"Overwrite error on update in place") },
-/* DTLPWRSOMCAE */{SST(0x2F, 0x00, SS_RDEF,
-			"Commands cleared by another initiator") },
-/* DT  WR OM    */{SST(0x30, 0x00, SS_RDEF,
-			"Incompatible medium installed") },
-/* DT  WR O     */{SST(0x30, 0x01, SS_RDEF,
-			"Cannot read medium - unknown format") },
-/* DT  WR O     */{SST(0x30, 0x02, SS_RDEF,
-			"Cannot read medium - incompatible format") },
-/* DT           */{SST(0x30, 0x03, SS_RDEF,
-			"Cleaning cartridge installed") },
-/* DT  WR O     */{SST(0x30, 0x04, SS_RDEF,
-			"Cannot write medium - unknown format") },
-/* DT  WR O     */{SST(0x30, 0x05, SS_RDEF,
-			"Cannot write medium - incompatible format") },
-/* DT  W  O     */{SST(0x30, 0x06, SS_RDEF,
-			"Cannot format medium - incompatible medium") },
-/* DTL WRSOM AE */{SST(0x30, 0x07, SS_RDEF,
-			"Cleaning failure") },
-/*      R       */{SST(0x30, 0x08, SS_RDEF,
-			"Cannot write - application code mismatch") },
-/*      R       */{SST(0x30, 0x09, SS_RDEF,
-			"Current session not fixated for append") },
-/* DT  WR O     */{SST(0x31, 0x00, SS_RDEF,
-			"Medium format corrupted") },
-/* D L  R O     */{SST(0x31, 0x01, SS_RDEF,
-			"Format command failed") },
-/* D   W  O     */{SST(0x32, 0x00, SS_RDEF,
-			"No defect spare location available") },
-/* D   W  O     */{SST(0x32, 0x01, SS_RDEF,
-			"Defect list update failure") },
-/*  T           */{SST(0x33, 0x00, SS_RDEF,
-			"Tape length error") },
-/* DTLPWRSOMCAE */{SST(0x34, 0x00, SS_RDEF,
-			"Enclosure failure") },
-/* DTLPWRSOMCAE */{SST(0x35, 0x00, SS_RDEF,
-			"Enclosure services failure") },
-/* DTLPWRSOMCAE */{SST(0x35, 0x01, SS_RDEF,
-			"Unsupported enclosure function") },
-/* DTLPWRSOMCAE */{SST(0x35, 0x02, SS_RDEF,
-			"Enclosure services unavailable") },
-/* DTLPWRSOMCAE */{SST(0x35, 0x03, SS_RDEF,
-			"Enclosure services transfer failure") },
-/* DTLPWRSOMCAE */{SST(0x35, 0x04, SS_RDEF,
-			"Enclosure services transfer refused") },
-/*   L          */{SST(0x36, 0x00, SS_RDEF,
-			"Ribbon, ink, or toner failure") },
-/* DTL WRSOMCAE */{SST(0x37, 0x00, SS_RDEF,
-			"Rounded parameter") },
-/* DTL WRSOMCAE */{SST(0x39, 0x00, SS_RDEF,
-			"Saving parameters not supported") },
-/* DTL WRSOM    */{SST(0x3A, 0x00, SS_NOP,
-			"Medium not present") },
-/* DT  WR OM    */{SST(0x3A, 0x01, SS_NOP,
-			"Medium not present - tray closed") },
-/* DT  WR OM    */{SST(0x3A, 0x01, SS_NOP,
-			"Medium not present - tray open") },
-/* DT  WR OM    */{SST(0x3A, 0x03, SS_NOP,
-			"Medium not present - Loadable") },
-/* DT  WR OM    */{SST(0x3A, 0x04, SS_NOP,
-			"Medium not present - medium auxiliary "
-			"memory accessible") },
-/* DT  WR OM    */{SST(0x3A, 0xFF, SS_NOP, NULL) },/* Range 0x05->0xFF */
-/*  TL          */{SST(0x3B, 0x00, SS_RDEF,
-			"Sequential positioning error") },
-/*  T           */{SST(0x3B, 0x01, SS_RDEF,
-			"Tape position error at beginning-of-medium") },
-/*  T           */{SST(0x3B, 0x02, SS_RDEF,
-			"Tape position error at end-of-medium") },
-/*   L          */{SST(0x3B, 0x03, SS_RDEF,
-			"Tape or electronic vertical forms unit not ready") },
-/*   L          */{SST(0x3B, 0x04, SS_RDEF,
-			"Slew failure") },
-/*   L          */{SST(0x3B, 0x05, SS_RDEF,
-			"Paper jam") },
-/*   L          */{SST(0x3B, 0x06, SS_RDEF,
-			"Failed to sense top-of-form") },
-/*   L          */{SST(0x3B, 0x07, SS_RDEF,
-			"Failed to sense bottom-of-form") },
-/*  T           */{SST(0x3B, 0x08, SS_RDEF,
-			"Reposition error") },
-/*       S      */{SST(0x3B, 0x09, SS_RDEF,
-			"Read past end of medium") },
-/*       S      */{SST(0x3B, 0x0A, SS_RDEF,
-			"Read past beginning of medium") },
-/*       S      */{SST(0x3B, 0x0B, SS_RDEF,
-			"Position past end of medium") },
-/*  T    S      */{SST(0x3B, 0x0C, SS_RDEF,
-			"Position past beginning of medium") },
-/* DT  WR OM    */{SST(0x3B, 0x0D, SS_FATAL|ENOSPC,
-			"Medium destination element full") },
-/* DT  WR OM    */{SST(0x3B, 0x0E, SS_RDEF,
-			"Medium source element empty") },
-/*      R       */{SST(0x3B, 0x0F, SS_RDEF,
-			"End of medium reached") },
-/* DT  WR OM    */{SST(0x3B, 0x11, SS_RDEF,
-			"Medium magazine not accessible") },
-/* DT  WR OM    */{SST(0x3B, 0x12, SS_RDEF,
-			"Medium magazine removed") },
-/* DT  WR OM    */{SST(0x3B, 0x13, SS_RDEF,
-			"Medium magazine inserted") },
-/* DT  WR OM    */{SST(0x3B, 0x14, SS_RDEF,
-			"Medium magazine locked") },
-/* DT  WR OM    */{SST(0x3B, 0x15, SS_RDEF,
-			"Medium magazine unlocked") },
-/* DTLPWRSOMCAE */{SST(0x3D, 0x00, SS_RDEF,
-			"Invalid bits in identify message") },
-/* DTLPWRSOMCAE */{SST(0x3E, 0x00, SS_RDEF,
-			"Logical unit has not self-configured yet") },
-/* DTLPWRSOMCAE */{SST(0x3E, 0x01, SS_RDEF,
-			"Logical unit failure") },
-/* DTLPWRSOMCAE */{SST(0x3E, 0x02, SS_RDEF,
-			"Timeout on logical unit") },
-/* DTLPWRSOMCAE */{SST(0x3F, 0x00, SS_RDEF,
-			"Target operating conditions have changed") },
-/* DTLPWRSOMCAE */{SST(0x3F, 0x01, SS_RDEF,
-			"Microcode has been changed") },
-/* DTLPWRSOMC   */{SST(0x3F, 0x02, SS_RDEF,
-			"Changed operating definition") },
-/* DTLPWRSOMCAE */{SST(0x3F, 0x03, SS_INQ_REFRESH|SSQ_DECREMENT_COUNT,
-			"Inquiry data has changed") },
-/* DT  WR OMCAE */{SST(0x3F, 0x04, SS_RDEF,
-			"Component device attached") },
-/* DT  WR OMCAE */{SST(0x3F, 0x05, SS_RDEF,
-			"Device identifier changed") },
-/* DT  WR OMCAE */{SST(0x3F, 0x06, SS_RDEF,
-			"Redundancy group created or modified") },
-/* DT  WR OMCAE */{SST(0x3F, 0x07, SS_RDEF,
-			"Redundancy group deleted") },
-/* DT  WR OMCAE */{SST(0x3F, 0x08, SS_RDEF,
-			"Spare created or modified") },
-/* DT  WR OMCAE */{SST(0x3F, 0x09, SS_RDEF,
-			"Spare deleted") },
-/* DT  WR OMCAE */{SST(0x3F, 0x0A, SS_RDEF,
-			"Volume set created or modified") },
-/* DT  WR OMCAE */{SST(0x3F, 0x0B, SS_RDEF,
-			"Volume set deleted") },
-/* DT  WR OMCAE */{SST(0x3F, 0x0C, SS_RDEF,
-			"Volume set deassigned") },
-/* DT  WR OMCAE */{SST(0x3F, 0x0D, SS_RDEF,
-			"Volume set reassigned") },
-/* DTLPWRSOMCAE */{SST(0x3F, 0x0E, SS_RDEF,
-			"Reported luns data has changed") },
-/* DTLPWRSOMCAE */{SST(0x3F, 0x0F, SS_RETRY|SSQ_DECREMENT_COUNT
-				 | SSQ_DELAY_RANDOM|EBUSY,
-			"Echo buffer overwritten") },
-/* DT  WR OM   B*/{SST(0x3F, 0x0F, SS_RDEF, "Medium Loadable") },
-/* DT  WR OM   B*/{SST(0x3F, 0x0F, SS_RDEF,
-			"Medium auxiliary memory accessible") },
-/* D            */{SST(0x40, 0x00, SS_RDEF,
-			"Ram failure") }, /* deprecated - use 40 NN instead */
-/* DTLPWRSOMCAE */{SST(0x40, 0x80, SS_RDEF,
-			"Diagnostic failure: ASCQ = Component ID") },
-/* DTLPWRSOMCAE */{SST(0x40, 0xFF, SS_RDEF|SSQ_RANGE,
-			NULL) },/* Range 0x80->0xFF */
-/* D            */{SST(0x41, 0x00, SS_RDEF,
-			"Data path failure") }, /* deprecated - use 40 NN instead */
-/* D            */{SST(0x42, 0x00, SS_RDEF,
-			"Power-on or self-test failure") }, /* deprecated - use 40 NN instead */
-/* DTLPWRSOMCAE */{SST(0x43, 0x00, SS_RDEF,
-			"Message error") },
-/* DTLPWRSOMCAE */{SST(0x44, 0x00, SS_RDEF,
-			"Internal target failure") },
-/* DTLPWRSOMCAE */{SST(0x45, 0x00, SS_RDEF,
-			"Select or reselect failure") },
-/* DTLPWRSOMC   */{SST(0x46, 0x00, SS_RDEF,
-			"Unsuccessful soft reset") },
-/* DTLPWRSOMCAE */{SST(0x47, 0x00, SS_RDEF|SSQ_FALLBACK,
-			"SCSI parity error") },
-/* DTLPWRSOMCAE */{SST(0x47, 0x01, SS_RDEF|SSQ_FALLBACK,
-			"Data Phase CRC error detected") },
-/* DTLPWRSOMCAE */{SST(0x47, 0x02, SS_RDEF|SSQ_FALLBACK,
-			"SCSI parity error detected during ST data phase") },
-/* DTLPWRSOMCAE */{SST(0x47, 0x03, SS_RDEF|SSQ_FALLBACK,
-			"Information Unit iuCRC error") },
-/* DTLPWRSOMCAE */{SST(0x47, 0x04, SS_RDEF|SSQ_FALLBACK,
-			"Asynchronous information protection error detected") },
-/* DTLPWRSOMCAE */{SST(0x47, 0x05, SS_RDEF|SSQ_FALLBACK,
-			"Protocol server CRC error") },
-/* DTLPWRSOMCAE */{SST(0x48, 0x00, SS_RDEF|SSQ_FALLBACK,
-			"Initiator detected error message received") },
-/* DTLPWRSOMCAE */{SST(0x49, 0x00, SS_RDEF,
-			"Invalid message error") },
-/* DTLPWRSOMCAE */{SST(0x4A, 0x00, SS_RDEF,
-			"Command phase error") },
-/* DTLPWRSOMCAE */{SST(0x4B, 0x00, SS_RDEF,
-			"Data phase error") },
-/* DTLPWRSOMCAE */{SST(0x4C, 0x00, SS_RDEF,
-			"Logical unit failed self-configuration") },
-/* DTLPWRSOMCAE */{SST(0x4D, 0x00, SS_RDEF,
-			"Tagged overlapped commands: ASCQ = Queue tag ID") },
-/* DTLPWRSOMCAE */{SST(0x4D, 0xFF, SS_RDEF|SSQ_RANGE,
-			NULL)}, /* Range 0x00->0xFF */
-/* DTLPWRSOMCAE */{SST(0x4E, 0x00, SS_RDEF,
-			"Overlapped commands attempted") },
-/*  T           */{SST(0x50, 0x00, SS_RDEF,
-			"Write append error") },
-/*  T           */{SST(0x50, 0x01, SS_RDEF,
-			"Write append position error") },
-/*  T           */{SST(0x50, 0x02, SS_RDEF,
-			"Position error related to timing") },
-/*  T     O     */{SST(0x51, 0x00, SS_RDEF,
-			"Erase failure") },
-/*  T           */{SST(0x52, 0x00, SS_RDEF,
-			"Cartridge fault") },
-/* DTL WRSOM    */{SST(0x53, 0x00, SS_RDEF,
-			"Media load or eject failed") },
-/*  T           */{SST(0x53, 0x01, SS_RDEF,
-			"Unload tape failure") },
-/* DT  WR OM    */{SST(0x53, 0x02, SS_RDEF,
-			"Medium removal prevented") },
-/*    P         */{SST(0x54, 0x00, SS_RDEF,
-			"Scsi to host system interface failure") },
-/*    P         */{SST(0x55, 0x00, SS_RDEF,
-			"System resource failure") },
-/* D      O     */{SST(0x55, 0x01, SS_FATAL|ENOSPC,
-			"System buffer full") },
-/*      R       */{SST(0x57, 0x00, SS_RDEF,
-			"Unable to recover table-of-contents") },
-/*        O     */{SST(0x58, 0x00, SS_RDEF,
-			"Generation does not exist") },
-/*        O     */{SST(0x59, 0x00, SS_RDEF,
-			"Updated block read") },
-/* DTLPWRSOM    */{SST(0x5A, 0x00, SS_RDEF,
-			"Operator request or state change input") },
-/* DT  WR OM    */{SST(0x5A, 0x01, SS_RDEF,
-			"Operator medium removal request") },
-/* DT  W  O     */{SST(0x5A, 0x02, SS_RDEF,
-			"Operator selected write protect") },
-/* DT  W  O     */{SST(0x5A, 0x03, SS_RDEF,
-			"Operator selected write permit") },
-/* DTLPWRSOM    */{SST(0x5B, 0x00, SS_RDEF,
-			"Log exception") },
-/* DTLPWRSOM    */{SST(0x5B, 0x01, SS_RDEF,
-			"Threshold condition met") },
-/* DTLPWRSOM    */{SST(0x5B, 0x02, SS_RDEF,
-			"Log counter at maximum") },
-/* DTLPWRSOM    */{SST(0x5B, 0x03, SS_RDEF,
-			"Log list codes exhausted") },
-/* D      O     */{SST(0x5C, 0x00, SS_RDEF,
-			"RPL status change") },
-/* D      O     */{SST(0x5C, 0x01, SS_NOP|SSQ_PRINT_SENSE,
-			"Spindles synchronized") },
-/* D      O     */{SST(0x5C, 0x02, SS_RDEF,
-			"Spindles not synchronized") },
-/* DTLPWRSOMCAE */{SST(0x5D, 0x00, SS_RDEF,
-			"Failure prediction threshold exceeded") },
-/* DTLPWRSOMCAE */{SST(0x5D, 0xFF, SS_RDEF,
-			"Failure prediction threshold exceeded (false)") },
-/* DTLPWRSO CA  */{SST(0x5E, 0x00, SS_RDEF,
-			"Low power condition on") },
-/* DTLPWRSO CA  */{SST(0x5E, 0x01, SS_RDEF,
-			"Idle condition activated by timer") },
-/* DTLPWRSO CA  */{SST(0x5E, 0x02, SS_RDEF,
-			"Standby condition activated by timer") },
-/* DTLPWRSO CA  */{SST(0x5E, 0x03, SS_RDEF,
-			"Idle condition activated by command") },
-/* DTLPWRSO CA  */{SST(0x5E, 0x04, SS_RDEF,
-			"Standby condition activated by command") },
-/*       S      */{SST(0x60, 0x00, SS_RDEF,
-			"Lamp failure") },
-/*       S      */{SST(0x61, 0x00, SS_RDEF,
-			"Video acquisition error") },
-/*       S      */{SST(0x61, 0x01, SS_RDEF,
-			"Unable to acquire video") },
-/*       S      */{SST(0x61, 0x02, SS_RDEF,
-			"Out of focus") },
-/*       S      */{SST(0x62, 0x00, SS_RDEF,
-			"Scan head positioning error") },
-/*      R       */{SST(0x63, 0x00, SS_RDEF,
-			"End of user area encountered on this track") },
-/*      R       */{SST(0x63, 0x01, SS_FATAL|ENOSPC,
-			"Packet does not fit in available space") },
-/*      R       */{SST(0x64, 0x00, SS_RDEF,
-			"Illegal mode for this track") },
-/*      R       */{SST(0x64, 0x01, SS_RDEF,
-			"Invalid packet size") },
-/* DTLPWRSOMCAE */{SST(0x65, 0x00, SS_RDEF,
-			"Voltage fault") },
-/*       S      */{SST(0x66, 0x00, SS_RDEF,
-			"Automatic document feeder cover up") },
-/*       S      */{SST(0x66, 0x01, SS_RDEF,
-			"Automatic document feeder lift up") },
-/*       S      */{SST(0x66, 0x02, SS_RDEF,
-			"Document jam in automatic document feeder") },
-/*       S      */{SST(0x66, 0x03, SS_RDEF,
-			"Document miss feed automatic in document feeder") },
-/*           A  */{SST(0x67, 0x00, SS_RDEF,
-			"Configuration failure") },
-/*           A  */{SST(0x67, 0x01, SS_RDEF,
-			"Configuration of incapable logical units failed") },
-/*           A  */{SST(0x67, 0x02, SS_RDEF,
-			"Add logical unit failed") },
-/*           A  */{SST(0x67, 0x03, SS_RDEF,
-			"Modification of logical unit failed") },
-/*           A  */{SST(0x67, 0x04, SS_RDEF,
-			"Exchange of logical unit failed") },
-/*           A  */{SST(0x67, 0x05, SS_RDEF,
-			"Remove of logical unit failed") },
-/*           A  */{SST(0x67, 0x06, SS_RDEF,
-			"Attachment of logical unit failed") },
-/*           A  */{SST(0x67, 0x07, SS_RDEF,
-			"Creation of logical unit failed") },
-/*           A  */{SST(0x68, 0x00, SS_RDEF,
-			"Logical unit not configured") },
-/*           A  */{SST(0x69, 0x00, SS_RDEF,
-			"Data loss on logical unit") },
-/*           A  */{SST(0x69, 0x01, SS_RDEF,
-			"Multiple logical unit failures") },
-/*           A  */{SST(0x69, 0x02, SS_RDEF,
-			"Parity/data mismatch") },
-/*           A  */{SST(0x6A, 0x00, SS_RDEF,
-			"Informational, refer to log") },
-/*           A  */{SST(0x6B, 0x00, SS_RDEF,
-			"State change has occurred") },
-/*           A  */{SST(0x6B, 0x01, SS_RDEF,
-			"Redundancy level got better") },
-/*           A  */{SST(0x6B, 0x02, SS_RDEF,
-			"Redundancy level got worse") },
-/*           A  */{SST(0x6C, 0x00, SS_RDEF,
-			"Rebuild failure occurred") },
-/*           A  */{SST(0x6D, 0x00, SS_RDEF,
-			"Recalculate failure occurred") },
-/*           A  */{SST(0x6E, 0x00, SS_RDEF,
-			"Command to logical unit failed") },
-/*  T           */{SST(0x70, 0x00, SS_RDEF,
-			"Decompression exception short: ASCQ = Algorithm ID") },
-/*  T           */{SST(0x70, 0xFF, SS_RDEF|SSQ_RANGE,
-			NULL) }, /* Range 0x00 -> 0xFF */
-/*  T           */{SST(0x71, 0x00, SS_RDEF,
-			"Decompression exception long: ASCQ = Algorithm ID") },
-/*  T           */{SST(0x71, 0xFF, SS_RDEF|SSQ_RANGE,
-			NULL) }, /* Range 0x00 -> 0xFF */	
-/*      R       */{SST(0x72, 0x00, SS_RDEF,
-			"Session fixation error") },
-/*      R       */{SST(0x72, 0x01, SS_RDEF,
-			"Session fixation error writing lead-in") },
-/*      R       */{SST(0x72, 0x02, SS_RDEF,
-			"Session fixation error writing lead-out") },
-/*      R       */{SST(0x72, 0x03, SS_RDEF,
-			"Session fixation error - incomplete track in session") },
-/*      R       */{SST(0x72, 0x04, SS_RDEF,
-			"Empty or partially written reserved track") },
-/*      R       */{SST(0x73, 0x00, SS_RDEF,
-			"CD control error") },
-/*      R       */{SST(0x73, 0x01, SS_RDEF,
-			"Power calibration area almost full") },
-/*      R       */{SST(0x73, 0x02, SS_FATAL|ENOSPC,
-			"Power calibration area is full") },
-/*      R       */{SST(0x73, 0x03, SS_RDEF,
-			"Power calibration area error") },
-/*      R       */{SST(0x73, 0x04, SS_RDEF,
-			"Program memory area update failure") },
-/*      R       */{SST(0x73, 0x05, SS_RDEF,
-			"program memory area is full") }
-};
-
-static const int asc_table_size = sizeof(asc_table)/sizeof(asc_table[0]);
-
-struct asc_key
-{
-	int asc;
-	int ascq;
-};
-
-static int
-ascentrycomp(const void *key, const void *member)
-{
-	int asc;
-	int ascq;
-	const struct asc_table_entry *table_entry;
-
-	asc = ((const struct asc_key *)key)->asc;
-	ascq = ((const struct asc_key *)key)->ascq;
-	table_entry = (const struct asc_table_entry *)member;
-
-	if (asc >= table_entry->asc) {
-
-		if (asc > table_entry->asc)
-			return (1);
-
-		if (ascq <= table_entry->ascq) {
-			/* Check for ranges */
-			if (ascq == table_entry->ascq
-		 	 || ((table_entry->action & SSQ_RANGE) != 0
-		  	   && ascq >= (table_entry - 1)->ascq))
-				return (0);
-			return (-1);
-		}
-		return (1);
-	}
-	return (-1);
-}
-
-static int
-senseentrycomp(const void *key, const void *member)
-{
-	int sense_key;
-	const struct sense_key_table_entry *table_entry;
-
-	sense_key = *((const int *)key);
-	table_entry = (const struct sense_key_table_entry *)member;
-
-	if (sense_key >= table_entry->sense_key) {
-		if (sense_key == table_entry->sense_key)
-			return (0);
-		return (1);
-	}
-	return (-1);
-}
-
-static void
-fetchtableentries(int sense_key, int asc, int ascq,
-		  struct scsi_inquiry_data *inq_data,
-		  const struct sense_key_table_entry **sense_entry,
-		  const struct asc_table_entry **asc_entry)
-{
-	void *match;
-	const struct asc_table_entry *asc_tables[2];
-	const struct sense_key_table_entry *sense_tables[2];
-	struct asc_key asc_ascq;
-	size_t asc_tables_size[2];
-	size_t sense_tables_size[2];
-	int num_asc_tables;
-	int num_sense_tables;
-	int i;
-
-	/* Default to failure */
-	*sense_entry = NULL;
-	*asc_entry = NULL;
-	match = NULL;
-	if (inq_data != NULL)
-		match = cam_quirkmatch((void *)inq_data,
-				       (void *)sense_quirk_table,
-				       sense_quirk_table_size,
-				       sizeof(*sense_quirk_table),
-				       aic_inquiry_match);
-
-	if (match != NULL) {
-		struct scsi_sense_quirk_entry *quirk;
-
-		quirk = (struct scsi_sense_quirk_entry *)match;
-		asc_tables[0] = quirk->asc_info;
-		asc_tables_size[0] = quirk->num_ascs;
-		asc_tables[1] = asc_table;
-		asc_tables_size[1] = asc_table_size;
-		num_asc_tables = 2;
-		sense_tables[0] = quirk->sense_key_info;
-		sense_tables_size[0] = quirk->num_sense_keys;
-		sense_tables[1] = sense_key_table;
-		sense_tables_size[1] = sense_key_table_size;
-		num_sense_tables = 2;
-	} else {
-		asc_tables[0] = asc_table;
-		asc_tables_size[0] = asc_table_size;
-		num_asc_tables = 1;
-		sense_tables[0] = sense_key_table;
-		sense_tables_size[0] = sense_key_table_size;
-		num_sense_tables = 1;
-	}
-
-	asc_ascq.asc = asc;
-	asc_ascq.ascq = ascq;
-	for (i = 0; i < num_asc_tables; i++) {
-		void *found_entry;
-
-		found_entry = scsibsearch(&asc_ascq, asc_tables[i],
-					  asc_tables_size[i],
-					  sizeof(**asc_tables),
-					  ascentrycomp);
-
-		if (found_entry) {
-			*asc_entry = (struct asc_table_entry *)found_entry;
-			break;
-		}
-	}
-
-	for (i = 0; i < num_sense_tables; i++) {
-		void *found_entry;
-
-		found_entry = scsibsearch(&sense_key, sense_tables[i],
-					  sense_tables_size[i],
-					  sizeof(**sense_tables),
-					  senseentrycomp);
-
-		if (found_entry) {
-			*sense_entry =
-			    (struct sense_key_table_entry *)found_entry;
-			break;
-		}
-	}
-}
-
-static void *
-scsibsearch(const void *key, const void *base, size_t nmemb, size_t size,
-		 int (*compar)(const void *, const void *))
-{
-	const void *entry;
-	u_int l;
-	u_int u;
-	u_int m;
-
-	l = -1;
-	u = nmemb;
-	while (l + 1 != u) {
-		m = (l + u) / 2;
-		entry = base + m * size;
-		if (compar(key, entry) > 0)
-			l = m;
-		else
-			u = m;
-	}
-
-	entry = base + u * size;
-	if (u == nmemb
-	 || compar(key, entry) != 0)
-		return (NULL);
-
-	return ((void *)entry);
-}
-
-/*
- * Compare string with pattern, returning 0 on match.
- * Short pattern matches trailing blanks in name,
- * wildcard '*' in pattern matches rest of name,
- * wildcard '?' matches a single non-space character.
- */
-static int
-cam_strmatch(const uint8_t *str, const uint8_t *pattern, int str_len)
-{
-
-	while (*pattern != '\0'&& str_len > 0) {  
-
-		if (*pattern == '*') {
-			return (0);
-		}
-		if ((*pattern != *str)
-		 && (*pattern != '?' || *str == ' ')) {
-			return (1);
-		}
-		pattern++;
-		str++;
-		str_len--;
-	}
-	while (str_len > 0 && *str++ == ' ')
-		str_len--;
-
-	return (str_len);
-}
-
-static caddr_t
-cam_quirkmatch(caddr_t target, caddr_t quirk_table, int num_entries,
-	       int entry_size, cam_quirkmatch_t *comp_func)
-{
-	for (; num_entries > 0; num_entries--, quirk_table += entry_size) {
-		if ((*comp_func)(target, quirk_table) == 0)
-			return (quirk_table);
-	}
-	return (NULL);
-}
-
-void
-aic_sense_desc(int sense_key, int asc, int ascq,
-	       struct scsi_inquiry_data *inq_data,
-	       const char **sense_key_desc, const char **asc_desc)
-{
-	const struct asc_table_entry *asc_entry;
-	const struct sense_key_table_entry *sense_entry;
-
-	fetchtableentries(sense_key, asc, ascq,
-			  inq_data,
-			  &sense_entry,
-			  &asc_entry);
-
-	*sense_key_desc = sense_entry->desc;
-
-	if (asc_entry != NULL)
-		*asc_desc = asc_entry->desc;
-	else if (asc >= 0x80 && asc <= 0xff)
-		*asc_desc = "Vendor Specific ASC";
-	else if (ascq >= 0x80 && ascq <= 0xff)
-		*asc_desc = "Vendor Specific ASCQ";
-	else
-		*asc_desc = "Reserved ASC/ASCQ pair";
-}
-
-/*
- * Given sense and device type information, return the appropriate action.
- * If we do not understand the specific error as identified by the ASC/ASCQ
- * pair, fall back on the more generic actions derived from the sense key.
- */
-aic_sense_action
-aic_sense_error_action(struct scsi_sense_data *sense_data,
-		       struct scsi_inquiry_data *inq_data, uint32_t sense_flags)
-{
-	const struct asc_table_entry *asc_entry;
-	const struct sense_key_table_entry *sense_entry;
-	int error_code, sense_key, asc, ascq;
-	aic_sense_action action;
-
-	scsi_extract_sense(sense_data, &error_code, &sense_key, &asc, &ascq);
-
-	if (error_code == SSD_DEFERRED_ERROR) {
-		/*
-		 * XXX dufault@FreeBSD.org
-		 * This error doesn't relate to the command associated
-		 * with this request sense.  A deferred error is an error
-		 * for a command that has already returned GOOD status
-		 * (see SCSI2 8.2.14.2).
-		 *
-		 * By my reading of that section, it looks like the current
-		 * command has been cancelled, we should now clean things up
-		 * (hopefully recovering any lost data) and then retry the
-		 * current command.  There are two easy choices, both wrong:
-		 *
-		 * 1. Drop through (like we had been doing), thus treating
-		 *    this as if the error were for the current command and
-		 *    return and stop the current command.
-		 * 
-		 * 2. Issue a retry (like I made it do) thus hopefully
-		 *    recovering the current transfer, and ignoring the
-		 *    fact that we've dropped a command.
-		 *
-		 * These should probably be handled in a device specific
-		 * sense handler or punted back up to a user mode daemon
-		 */
-		action = SS_RETRY|SSQ_DECREMENT_COUNT|SSQ_PRINT_SENSE;
-	} else {
-		fetchtableentries(sense_key, asc, ascq,
-				  inq_data,
-				  &sense_entry,
-				  &asc_entry);
-
-		/*
-		 * Override the 'No additional Sense' entry (0,0)
-		 * with the error action of the sense key.
-		 */
-		if (asc_entry != NULL
-		 && (asc != 0 || ascq != 0))
-			action = asc_entry->action;
-		else
-			action = sense_entry->action;
-
-		if (sense_key == SSD_KEY_RECOVERED_ERROR) {
-			/*
-			 * The action succeeded but the device wants
-			 * the user to know that some recovery action
-			 * was required.
-			 */
-			action &= ~(SS_MASK|SSQ_MASK|SS_ERRMASK);
-			action |= SS_NOP|SSQ_PRINT_SENSE;
-		} else if (sense_key == SSD_KEY_ILLEGAL_REQUEST) {
-			if ((sense_flags & SF_QUIET_IR) != 0)
-				action &= ~SSQ_PRINT_SENSE;
-		} else if (sense_key == SSD_KEY_UNIT_ATTENTION) {
-			if ((sense_flags & SF_RETRY_UA) != 0
-			 && (action & SS_MASK) == SS_FAIL) {
-				action &= ~(SS_MASK|SSQ_MASK);
-				action |= SS_RETRY|SSQ_DECREMENT_COUNT|
-					  SSQ_PRINT_SENSE;
-			}
-		}
-	}
-
-	if ((sense_flags & SF_PRINT_ALWAYS) != 0)
-		action |= SSQ_PRINT_SENSE;
-	else if ((sense_flags & SF_NO_PRINT) != 0)
-		action &= ~SSQ_PRINT_SENSE;
-
-	return (action);
-}
-
-/*      
- * Try make as good a match as possible with
- * available sub drivers
- */
-int
-aic_inquiry_match(caddr_t inqbuffer, caddr_t table_entry)
-{
-	struct scsi_inquiry_pattern *entry;
-	struct scsi_inquiry_data *inq;
- 
-	entry = (struct scsi_inquiry_pattern *)table_entry;
-	inq = (struct scsi_inquiry_data *)inqbuffer;
-
-	if (((SID_TYPE(inq) == entry->type)
-	  || (entry->type == T_ANY))
-	 && (SID_IS_REMOVABLE(inq) ? entry->media_type & SIP_MEDIA_REMOVABLE
-				   : entry->media_type & SIP_MEDIA_FIXED)
-	 && (cam_strmatch(inq->vendor, entry->vendor, sizeof(inq->vendor)) == 0)
-	 && (cam_strmatch(inq->product, entry->product,
-			  sizeof(inq->product)) == 0)
-	 && (cam_strmatch(inq->revision, entry->revision,
-			  sizeof(inq->revision)) == 0)) {
-		return (0);
-	}
-        return (-1);
-}
-
-/*
- * Table of syncrates that don't follow the "divisible by 4"
- * rule. This table will be expanded in future SCSI specs.
- */
-static struct {
-	u_int period_factor;
-	u_int period;	/* in 100ths of ns */
-} scsi_syncrates[] = {
-	{ 0x08, 625 },	/* FAST-160 */
-	{ 0x09, 1250 },	/* FAST-80 */
-	{ 0x0a, 2500 },	/* FAST-40 40MHz */
-	{ 0x0b, 3030 },	/* FAST-40 33MHz */
-	{ 0x0c, 5000 }	/* FAST-20 */
-};
-
-/*
- * Return the frequency in kHz corresponding to the given
- * sync period factor.
- */
-u_int
-aic_calc_syncsrate(u_int period_factor)
-{
-	int i;
-	int num_syncrates;
-
-	num_syncrates = sizeof(scsi_syncrates) / sizeof(scsi_syncrates[0]);
-	/* See if the period is in the "exception" table */
-	for (i = 0; i < num_syncrates; i++) {
-
-		if (period_factor == scsi_syncrates[i].period_factor) {
-			/* Period in kHz */
-			return (100000000 / scsi_syncrates[i].period);
-		}
-	}
-
-	/*
-	 * Wasn't in the table, so use the standard
-	 * 4 times conversion.
-	 */
-	return (10000000 / (period_factor * 4 * 10));
-}
-
-/*
- * Return speed in KB/s.
- */
-u_int
-aic_calc_speed(u_int width, u_int period, u_int offset, u_int min_rate)
-{
-	u_int freq;
-
-	if (offset != 0 && period < min_rate)
-		freq  = aic_calc_syncsrate(period);
-	else
-		/* Roughly 3.3MB/s for async */
-		freq  = 3300;
-	freq <<= width;
-	return (freq);
-}
-
-uint32_t
-aic_error_action(struct scsi_cmnd *cmd, struct scsi_inquiry_data *inq_data,
-		 cam_status status, u_int scsi_status)
-{
-	aic_sense_action  err_action;
-	int		  sense;
-
-	sense  = (cmd->result >> 24) == DRIVER_SENSE;
-
-	switch (status) {
-	case CAM_REQ_CMP:
-		err_action = SS_NOP;
-		break;
-	case CAM_AUTOSENSE_FAIL:
-	case CAM_SCSI_STATUS_ERROR:
-
-		switch (scsi_status) {
-		case SCSI_STATUS_OK:
-		case SCSI_STATUS_COND_MET:
-		case SCSI_STATUS_INTERMED:
-		case SCSI_STATUS_INTERMED_COND_MET:
-			err_action = SS_NOP;
-			break;
-		case SCSI_STATUS_CMD_TERMINATED:
-		case SCSI_STATUS_CHECK_COND:
-			if (sense != 0) {
-				struct scsi_sense_data *sense;
-
-				sense = (struct scsi_sense_data *)
-				    &cmd->sense_buffer;
-				err_action =
-				    aic_sense_error_action(sense, inq_data, 0);
-
-			} else {
-				err_action = SS_RETRY|SSQ_FALLBACK
-					   | SSQ_DECREMENT_COUNT|EIO;
-			}
-			break;
-		case SCSI_STATUS_QUEUE_FULL:
-		case SCSI_STATUS_BUSY:
-			err_action = SS_RETRY|SSQ_DELAY|SSQ_MANY
-				   | SSQ_DECREMENT_COUNT|EBUSY;
-			break;
-		case SCSI_STATUS_RESERV_CONFLICT:
-		default:
-			err_action = SS_FAIL|EBUSY;
-			break;
-		}
-		break;
-	case CAM_CMD_TIMEOUT:
-	case CAM_REQ_CMP_ERR:
-	case CAM_UNEXP_BUSFREE:
-	case CAM_UNCOR_PARITY:
-	case CAM_DATA_RUN_ERR:
-		err_action = SS_RETRY|SSQ_FALLBACK|EIO;
-		break;
-	case CAM_UA_ABORT:
-	case CAM_UA_TERMIO:
-	case CAM_MSG_REJECT_REC:
-	case CAM_SEL_TIMEOUT:
-		err_action = SS_FAIL|EIO;
-		break;
-	case CAM_REQ_INVALID:
-	case CAM_PATH_INVALID:
-	case CAM_DEV_NOT_THERE:
-	case CAM_NO_HBA:
-	case CAM_PROVIDE_FAIL:
-	case CAM_REQ_TOO_BIG:		
-	case CAM_RESRC_UNAVAIL:
-	case CAM_BUSY:
-	default:
-		/* panic??  These should never occur in our application. */
-		err_action = SS_FAIL|EIO;
-		break;
-	case CAM_SCSI_BUS_RESET:
-	case CAM_BDR_SENT:		
-	case CAM_REQUEUE_REQ:
-		/* Unconditional requeue */
-		err_action = SS_RETRY;
-		break;
-	}
-
-	return (err_action);
-}
-
diff -urNp linux-5720/drivers/scsi/aic79xx/aiclib.h linux-5730/drivers/scsi/aic79xx/aiclib.h
--- linux-5720/drivers/scsi/aic79xx/aiclib.h
+++ linux-5730/drivers/scsi/aic79xx/aiclib.h
@@ -1,1001 +0,0 @@
-/*
- * Largely written by Julian Elischer (julian@tfs.com)
- * for TRW Financial Systems.
- *
- * TRW Financial Systems, in accordance with their agreement with Carnegie
- * Mellon University, makes this software available to CMU to distribute
- * or use in any manner that they see fit as long as this message is kept with
- * the software. For this reason TFS also grants any other persons or
- * organisations permission to use or modify this software.
- *
- * TFS supplies this software to be publicly redistributed
- * on the understanding that TFS is not responsible for the correct
- * functioning of this software in any circumstances.
- *
- * Ported to run under 386BSD by Julian Elischer (julian@tfs.com) Sept 1992
- *
- * $FreeBSD: src/sys/cam/scsi/scsi_all.h,v 1.21 2002/10/08 17:12:44 ken Exp $
- * $Id$
- */
-
-/*
- * SCSI general  interface description
- */
-
-#ifndef	_SCSI_SCSI_ALL_H
-#define _SCSI_SCSI_ALL_H 1
-
-/*
- * SCSI command format
- */
-
-/*
- * Define dome bits that are in ALL (or a lot of) scsi commands
- */
-#define SCSI_CTL_LINK		0x01
-#define SCSI_CTL_FLAG		0x02
-#define SCSI_CTL_VENDOR		0xC0
-#define	SCSI_CMD_LUN		0xA0	/* these two should not be needed */
-#define	SCSI_CMD_LUN_SHIFT	5	/* LUN in the cmd is no longer SCSI */
-
-#define SCSI_MAX_CDBLEN		16	/* 
-					 * 16 byte commands are in the 
-					 * SCSI-3 spec 
-					 */
-/* 6byte CDBs special case 0 length to be 256 */
-#define SCSI_CDB6_LEN(len)	((len) == 0 ? 256 : len)
-
-/*
- * This type defines actions to be taken when a particular sense code is
- * received.  Right now, these flags are only defined to take up 16 bits,
- * but can be expanded in the future if necessary.
- */
-typedef enum {
-	SS_NOP		= 0x000000, /* Do nothing */
-	SS_RETRY	= 0x010000, /* Retry the command */
-	SS_FAIL		= 0x020000, /* Bail out */
-	SS_START	= 0x030000, /* Send a Start Unit command to the device,
-				     * then retry the original command.
-				     */
-	SS_TUR		= 0x040000, /* Send a Test Unit Ready command to the
-				     * device, then retry the original command.
-				     */
-	SS_REQSENSE	= 0x050000, /* Send a RequestSense command to the
-				     * device, then retry the original command.
-				     */
-	SS_INQ_REFRESH	= 0x060000,
-	SS_MASK		= 0xff0000
-} aic_sense_action;
-
-typedef enum {
-	SSQ_NONE		= 0x0000,
-	SSQ_DECREMENT_COUNT	= 0x0100,  /* Decrement the retry count */
-	SSQ_MANY		= 0x0200,  /* send lots of recovery commands */
-	SSQ_RANGE		= 0x0400,  /*
-					    * This table entry represents the
-					    * end of a range of ASCQs that
-					    * have identical error actions
-					    * and text.
-					    */
-	SSQ_PRINT_SENSE		= 0x0800,
-	SSQ_DELAY		= 0x1000,  /* Delay before retry. */
-	SSQ_DELAY_RANDOM	= 0x2000,  /* Randomized delay before retry. */
-	SSQ_FALLBACK		= 0x4000,  /* Do a speed fallback to recover */
-	SSQ_MASK		= 0xff00
-} aic_sense_action_qualifier;
-
-/* Mask for error status values */
-#define SS_ERRMASK	0xff
-
-/* The default, retyable, error action */
-#define SS_RDEF		SS_RETRY|SSQ_DECREMENT_COUNT|SSQ_PRINT_SENSE|EIO
-
-/* The retyable, error action, with table specified error code */
-#define SS_RET		SS_RETRY|SSQ_DECREMENT_COUNT|SSQ_PRINT_SENSE
-
-/* Fatal error action, with table specified error code */
-#define SS_FATAL	SS_FAIL|SSQ_PRINT_SENSE
-
-struct scsi_generic
-{
-	uint8_t opcode;
-	uint8_t bytes[11];
-};
-
-struct scsi_request_sense
-{
-	uint8_t opcode;
-	uint8_t byte2;
-	uint8_t unused[2];
-	uint8_t length;
-	uint8_t control;
-};
-
-struct scsi_test_unit_ready
-{
-	uint8_t opcode;
-	uint8_t byte2;
-	uint8_t unused[3];
-	uint8_t control;
-};
-
-struct scsi_send_diag
-{
-	uint8_t opcode;
-	uint8_t byte2;
-#define	SSD_UOL		0x01
-#define	SSD_DOL		0x02
-#define	SSD_SELFTEST	0x04
-#define	SSD_PF		0x10
-	uint8_t unused[1];
-	uint8_t paramlen[2];
-	uint8_t control;
-};
-
-struct scsi_sense
-{
-	uint8_t opcode;
-	uint8_t byte2;
-	uint8_t unused[2];
-	uint8_t length;
-	uint8_t control;
-};
-
-struct scsi_inquiry
-{
-	uint8_t opcode;
-	uint8_t byte2;
-#define	SI_EVPD 0x01
-	uint8_t page_code;
-	uint8_t reserved;
-	uint8_t length;
-	uint8_t control;
-};
-
-struct scsi_mode_sense_6
-{
-	uint8_t opcode;
-	uint8_t byte2;
-#define	SMS_DBD				0x08
-	uint8_t page;
-#define	SMS_PAGE_CODE 			0x3F
-#define SMS_VENDOR_SPECIFIC_PAGE	0x00
-#define SMS_DISCONNECT_RECONNECT_PAGE	0x02
-#define SMS_PERIPHERAL_DEVICE_PAGE	0x09
-#define SMS_CONTROL_MODE_PAGE		0x0A
-#define SMS_ALL_PAGES_PAGE		0x3F
-#define	SMS_PAGE_CTRL_MASK		0xC0
-#define	SMS_PAGE_CTRL_CURRENT 		0x00
-#define	SMS_PAGE_CTRL_CHANGEABLE 	0x40
-#define	SMS_PAGE_CTRL_DEFAULT 		0x80
-#define	SMS_PAGE_CTRL_SAVED 		0xC0
-	uint8_t unused;
-	uint8_t length;
-	uint8_t control;
-};
-
-struct scsi_mode_sense_10
-{
-	uint8_t opcode;
-	uint8_t byte2;		/* same bits as small version */
-	uint8_t page; 		/* same bits as small version */
-	uint8_t unused[4];
-	uint8_t length[2];
-	uint8_t control;
-};
-
-struct scsi_mode_select_6
-{
-	uint8_t opcode;
-	uint8_t byte2;
-#define	SMS_SP	0x01
-#define	SMS_PF	0x10
-	uint8_t unused[2];
-	uint8_t length;
-	uint8_t control;
-};
-
-struct scsi_mode_select_10
-{
-	uint8_t opcode;
-	uint8_t byte2;		/* same bits as small version */
-	uint8_t unused[5];
-	uint8_t length[2];
-	uint8_t control;
-};
-
-/*
- * When sending a mode select to a tape drive, the medium type must be 0.
- */
-struct scsi_mode_hdr_6
-{
-	uint8_t datalen;
-	uint8_t medium_type;
-	uint8_t dev_specific;
-	uint8_t block_descr_len;
-};
-
-struct scsi_mode_hdr_10
-{
-	uint8_t datalen[2];
-	uint8_t medium_type;
-	uint8_t dev_specific;
-	uint8_t reserved[2];
-	uint8_t block_descr_len[2];
-};
-
-struct scsi_mode_block_descr
-{
-	uint8_t density_code;
-	uint8_t num_blocks[3];
-	uint8_t reserved;
-	uint8_t block_len[3];
-};
-
-struct scsi_log_sense
-{
-	uint8_t opcode;
-	uint8_t byte2;
-#define	SLS_SP				0x01
-#define	SLS_PPC				0x02
-	uint8_t page;
-#define	SLS_PAGE_CODE 			0x3F
-#define	SLS_ALL_PAGES_PAGE		0x00
-#define	SLS_OVERRUN_PAGE		0x01
-#define	SLS_ERROR_WRITE_PAGE		0x02
-#define	SLS_ERROR_READ_PAGE		0x03
-#define	SLS_ERROR_READREVERSE_PAGE	0x04
-#define	SLS_ERROR_VERIFY_PAGE		0x05
-#define	SLS_ERROR_NONMEDIUM_PAGE	0x06
-#define	SLS_ERROR_LASTN_PAGE		0x07
-#define	SLS_PAGE_CTRL_MASK		0xC0
-#define	SLS_PAGE_CTRL_THRESHOLD		0x00
-#define	SLS_PAGE_CTRL_CUMULATIVE	0x40
-#define	SLS_PAGE_CTRL_THRESH_DEFAULT	0x80
-#define	SLS_PAGE_CTRL_CUMUL_DEFAULT	0xC0
-	uint8_t reserved[2];
-	uint8_t paramptr[2];
-	uint8_t length[2];
-	uint8_t control;
-};
-
-struct scsi_log_select
-{
-	uint8_t opcode;
-	uint8_t byte2;
-/*	SLS_SP				0x01 */
-#define	SLS_PCR				0x02
-	uint8_t page;
-/*	SLS_PAGE_CTRL_MASK		0xC0 */
-/*	SLS_PAGE_CTRL_THRESHOLD		0x00 */
-/*	SLS_PAGE_CTRL_CUMULATIVE	0x40 */
-/*	SLS_PAGE_CTRL_THRESH_DEFAULT	0x80 */
-/*	SLS_PAGE_CTRL_CUMUL_DEFAULT	0xC0 */
-	uint8_t reserved[4];
-	uint8_t length[2];
-	uint8_t control;
-};
-
-struct scsi_log_header
-{
-	uint8_t page;
-	uint8_t reserved;
-	uint8_t datalen[2];
-};
-
-struct scsi_log_param_header {
-	uint8_t param_code[2];
-	uint8_t param_control;
-#define	SLP_LP				0x01
-#define	SLP_LBIN			0x02
-#define	SLP_TMC_MASK			0x0C
-#define	SLP_TMC_ALWAYS			0x00
-#define	SLP_TMC_EQUAL			0x04
-#define	SLP_TMC_NOTEQUAL		0x08
-#define	SLP_TMC_GREATER			0x0C
-#define	SLP_ETC				0x10
-#define	SLP_TSD				0x20
-#define	SLP_DS				0x40
-#define	SLP_DU				0x80
-	uint8_t param_len;
-};
-
-struct scsi_control_page {
-	uint8_t page_code;
-	uint8_t page_length;
-	uint8_t rlec;
-#define SCB_RLEC			0x01	/*Report Log Exception Cond*/
-	uint8_t queue_flags;
-#define SCP_QUEUE_ALG_MASK		0xF0
-#define SCP_QUEUE_ALG_RESTRICTED	0x00
-#define SCP_QUEUE_ALG_UNRESTRICTED	0x10
-#define SCP_QUEUE_ERR			0x02	/*Queued I/O aborted for CACs*/
-#define SCP_QUEUE_DQUE			0x01	/*Queued I/O disabled*/
-	uint8_t eca_and_aen;
-#define SCP_EECA			0x80	/*Enable Extended CA*/
-#define SCP_RAENP			0x04	/*Ready AEN Permission*/
-#define SCP_UAAENP			0x02	/*UA AEN Permission*/
-#define SCP_EAENP			0x01	/*Error AEN Permission*/
-	uint8_t reserved;
-	uint8_t aen_holdoff_period[2];
-};
-
-struct scsi_reserve
-{
-	uint8_t opcode;
-	uint8_t byte2;
-	uint8_t unused[2];
-	uint8_t length;
-	uint8_t control;
-};
-
-struct scsi_release
-{
-	uint8_t opcode;
-	uint8_t byte2;
-	uint8_t unused[2];
-	uint8_t length;
-	uint8_t control;
-};
-
-struct scsi_prevent
-{
-	uint8_t opcode;
-	uint8_t byte2;
-	uint8_t unused[2];
-	uint8_t how;
-	uint8_t control;
-};
-#define	PR_PREVENT 0x01
-#define PR_ALLOW   0x00
-
-struct scsi_sync_cache
-{
-	uint8_t opcode;
-	uint8_t byte2;
-	uint8_t begin_lba[4];
-	uint8_t reserved;
-	uint8_t lb_count[2];
-	uint8_t control;	
-};
-
-
-struct scsi_changedef
-{
-	uint8_t opcode;
-	uint8_t byte2;
-	uint8_t unused1;
-	uint8_t how;
-	uint8_t unused[4];
-	uint8_t datalen;
-	uint8_t control;
-};
-
-struct scsi_read_buffer
-{
-	uint8_t opcode;
-	uint8_t byte2;
-#define	RWB_MODE		0x07
-#define	RWB_MODE_HDR_DATA	0x00
-#define	RWB_MODE_DATA		0x02
-#define	RWB_MODE_DOWNLOAD	0x04
-#define	RWB_MODE_DOWNLOAD_SAVE	0x05
-        uint8_t buffer_id;
-        uint8_t offset[3];
-        uint8_t length[3];
-        uint8_t control;
-};
-
-struct scsi_write_buffer
-{
-	uint8_t opcode;
-	uint8_t byte2;
-	uint8_t buffer_id;
-	uint8_t offset[3];
-	uint8_t length[3];
-	uint8_t control;
-};
-
-struct scsi_rw_6
-{
-	uint8_t opcode;
-	uint8_t addr[3];
-/* only 5 bits are valid in the MSB address byte */
-#define	SRW_TOPADDR	0x1F
-	uint8_t length;
-	uint8_t control;
-};
-
-struct scsi_rw_10
-{
-	uint8_t opcode;
-#define	SRW10_RELADDR	0x01
-#define SRW10_FUA	0x08
-#define	SRW10_DPO	0x10
-	uint8_t byte2;
-	uint8_t addr[4];
-	uint8_t reserved;
-	uint8_t length[2];
-	uint8_t control;
-};
-
-struct scsi_rw_12
-{
-	uint8_t opcode;
-#define	SRW12_RELADDR	0x01
-#define SRW12_FUA	0x08
-#define	SRW12_DPO	0x10
-	uint8_t byte2;
-	uint8_t addr[4];
-	uint8_t length[4];
-	uint8_t reserved;
-	uint8_t control;
-};
-
-struct scsi_start_stop_unit
-{
-	uint8_t opcode;
-	uint8_t byte2;
-#define	SSS_IMMED		0x01
-	uint8_t reserved[2];
-	uint8_t how;
-#define	SSS_START		0x01
-#define	SSS_LOEJ		0x02
-	uint8_t control;
-};
-
-#define SC_SCSI_1 0x01
-#define SC_SCSI_2 0x03
-
-/*
- * Opcodes
- */
-
-#define	TEST_UNIT_READY		0x00
-#define REQUEST_SENSE		0x03
-#define	READ_6			0x08
-#define WRITE_6			0x0a
-#define INQUIRY			0x12
-#define MODE_SELECT_6		0x15
-#define MODE_SENSE_6		0x1a
-#define START_STOP_UNIT		0x1b
-#define START_STOP		0x1b
-#define RESERVE      		0x16
-#define RELEASE      		0x17
-#define	RECEIVE_DIAGNOSTIC	0x1c
-#define	SEND_DIAGNOSTIC		0x1d
-#define PREVENT_ALLOW		0x1e
-#define	READ_CAPACITY		0x25
-#define	READ_10			0x28
-#define WRITE_10		0x2a
-#define POSITION_TO_ELEMENT	0x2b
-#define	SYNCHRONIZE_CACHE	0x35
-#define	WRITE_BUFFER            0x3b
-#define	READ_BUFFER             0x3c
-#define	CHANGE_DEFINITION	0x40
-#define	LOG_SELECT		0x4c
-#define	LOG_SENSE		0x4d
-#ifdef XXXCAM
-#define	MODE_SENSE_10		0x5A
-#endif
-#define	MODE_SELECT_10		0x55
-#define MOVE_MEDIUM     	0xa5
-#define READ_12			0xa8
-#define WRITE_12		0xaa
-#define READ_ELEMENT_STATUS	0xb8
-
-
-/*
- * Device Types
- */
-#define T_DIRECT	0x00
-#define T_SEQUENTIAL	0x01
-#define T_PRINTER	0x02
-#define T_PROCESSOR	0x03
-#define T_WORM		0x04
-#define T_CDROM		0x05
-#define T_SCANNER 	0x06
-#define T_OPTICAL 	0x07
-#define T_CHANGER	0x08
-#define T_COMM		0x09
-#define T_ASC0		0x0a
-#define T_ASC1		0x0b
-#define	T_STORARRAY	0x0c
-#define	T_ENCLOSURE	0x0d
-#define	T_RBC		0x0e
-#define	T_OCRW		0x0f
-#define T_NODEVICE	0x1F
-#define	T_ANY		0xFF	/* Used in Quirk table matches */
-
-#define T_REMOV		1
-#define	T_FIXED		0
-
-/*
- * This length is the initial inquiry length used by the probe code, as    
- * well as the legnth necessary for aic_print_inquiry() to function 
- * correctly.  If either use requires a different length in the future, 
- * the two values should be de-coupled.
- */
-#define	SHORT_INQUIRY_LENGTH	36
-
-struct scsi_inquiry_data
-{
-	uint8_t device;
-#define	SID_TYPE(inq_data) ((inq_data)->device & 0x1f)
-#define	SID_QUAL(inq_data) (((inq_data)->device & 0xE0) >> 5)
-#define	SID_QUAL_LU_CONNECTED	0x00	/*
-					 * The specified peripheral device
-					 * type is currently connected to
-					 * logical unit.  If the target cannot
-					 * determine whether or not a physical
-					 * device is currently connected, it
-					 * shall also use this peripheral
-					 * qualifier when returning the INQUIRY
-					 * data.  This peripheral qualifier
-					 * does not mean that the device is
-					 * ready for access by the initiator.
-					 */
-#define	SID_QUAL_LU_OFFLINE	0x01	/*
-					 * The target is capable of supporting
-					 * the specified peripheral device type
-					 * on this logical unit; however, the
-					 * physical device is not currently
-					 * connected to this logical unit.
-					 */
-#define SID_QUAL_RSVD		0x02
-#define	SID_QUAL_BAD_LU		0x03	/*
-					 * The target is not capable of
-					 * supporting a physical device on
-					 * this logical unit. For this
-					 * peripheral qualifier the peripheral
-					 * device type shall be set to 1Fh to
-					 * provide compatibility with previous
-					 * versions of SCSI. All other
-					 * peripheral device type values are
-					 * reserved for this peripheral
-					 * qualifier.
-					 */
-#define	SID_QUAL_IS_VENDOR_UNIQUE(inq_data) ((SID_QUAL(inq_data) & 0x08) != 0)
-	uint8_t dev_qual2;
-#define	SID_QUAL2	0x7F
-#define	SID_IS_REMOVABLE(inq_data) (((inq_data)->dev_qual2 & 0x80) != 0)
-	uint8_t version;
-#define SID_ANSI_REV(inq_data) ((inq_data)->version & 0x07)
-#define		SCSI_REV_0		0
-#define		SCSI_REV_CCS		1
-#define		SCSI_REV_2		2
-#define		SCSI_REV_SPC		3
-#define		SCSI_REV_SPC2		4
-
-#define SID_ECMA	0x38
-#define SID_ISO		0xC0
-	uint8_t response_format;
-#define SID_AENC	0x80
-#define SID_TrmIOP	0x40
-	uint8_t additional_length;
-	uint8_t reserved[2];
-	uint8_t flags;
-#define	SID_SftRe	0x01
-#define	SID_CmdQue	0x02
-#define	SID_Linked	0x08
-#define	SID_Sync	0x10
-#define	SID_WBus16	0x20
-#define	SID_WBus32	0x40
-#define	SID_RelAdr	0x80
-#define SID_VENDOR_SIZE   8
-	char	 vendor[SID_VENDOR_SIZE];
-#define SID_PRODUCT_SIZE  16
-	char	 product[SID_PRODUCT_SIZE];
-#define SID_REVISION_SIZE 4
-	char	 revision[SID_REVISION_SIZE];
-	/*
-	 * The following fields were taken from SCSI Primary Commands - 2
-	 * (SPC-2) Revision 14, Dated 11 November 1999
-	 */
-#define	SID_VENDOR_SPECIFIC_0_SIZE	20
-	uint8_t vendor_specific0[SID_VENDOR_SPECIFIC_0_SIZE];
-	/*
-	 * An extension of SCSI Parallel Specific Values
-	 */
-#define	SID_SPI_IUS		0x01
-#define	SID_SPI_QAS		0x02
-#define	SID_SPI_CLOCK_ST	0x00
-#define	SID_SPI_CLOCK_DT	0x04
-#define	SID_SPI_CLOCK_DT_ST	0x0C
-#define	SID_SPI_MASK		0x0F
-	uint8_t spi3data;
-	uint8_t reserved2;
-	/*
-	 * Version Descriptors, stored 2 byte values.
-	 */
-	uint8_t version1[2];
-	uint8_t version2[2];
-	uint8_t version3[2];
-	uint8_t version4[2];
-	uint8_t version5[2];
-	uint8_t version6[2];
-	uint8_t version7[2];
-	uint8_t version8[2];
-
-	uint8_t reserved3[22];
-
-#define	SID_VENDOR_SPECIFIC_1_SIZE	160
-	uint8_t vendor_specific1[SID_VENDOR_SPECIFIC_1_SIZE];
-};
-
-struct scsi_vpd_unit_serial_number
-{
-	uint8_t device;
-	uint8_t page_code;
-#define SVPD_UNIT_SERIAL_NUMBER	0x80
-	uint8_t reserved;
-	uint8_t length; /* serial number length */
-#define SVPD_SERIAL_NUM_SIZE 251
-	uint8_t serial_num[SVPD_SERIAL_NUM_SIZE];
-};
-
-struct scsi_read_capacity
-{
-	uint8_t opcode;
-	uint8_t byte2;
-	uint8_t addr[4];
-	uint8_t unused[3];
-	uint8_t control;
-};
-
-struct scsi_read_capacity_data
-{
-	uint8_t addr[4];
-	uint8_t length[4];
-};
-
-struct scsi_report_luns
-{
-	uint8_t opcode;
-	uint8_t byte2;
-	uint8_t unused[3];
-	uint8_t addr[4];
-	uint8_t control;
-};
-
-struct scsi_report_luns_data {
-	uint8_t length[4];	/* length of LUN inventory, in bytes */
-	uint8_t reserved[4];	/* unused */
-	/*
-	 * LUN inventory- we only support the type zero form for now.
-	 */
-	struct {
-		uint8_t lundata[8];
-	} luns[1];
-};
-#define	RPL_LUNDATA_ATYP_MASK	0xc0	/* MBZ for type 0 lun */
-#define	RPL_LUNDATA_T0LUN	1	/* @ lundata[1] */
-
-
-struct scsi_sense_data
-{
-	uint8_t error_code;
-#define	SSD_ERRCODE			0x7F
-#define		SSD_CURRENT_ERROR	0x70
-#define		SSD_DEFERRED_ERROR	0x71
-#define	SSD_ERRCODE_VALID	0x80	
-	uint8_t segment;
-	uint8_t flags;
-#define	SSD_KEY				0x0F
-#define		SSD_KEY_NO_SENSE	0x00
-#define		SSD_KEY_RECOVERED_ERROR	0x01
-#define		SSD_KEY_NOT_READY	0x02
-#define		SSD_KEY_MEDIUM_ERROR	0x03
-#define		SSD_KEY_HARDWARE_ERROR	0x04
-#define		SSD_KEY_ILLEGAL_REQUEST	0x05
-#define		SSD_KEY_UNIT_ATTENTION	0x06
-#define		SSD_KEY_DATA_PROTECT	0x07
-#define		SSD_KEY_BLANK_CHECK	0x08
-#define		SSD_KEY_Vendor_Specific	0x09
-#define		SSD_KEY_COPY_ABORTED	0x0a
-#define		SSD_KEY_ABORTED_COMMAND	0x0b		
-#define		SSD_KEY_EQUAL		0x0c
-#define		SSD_KEY_VOLUME_OVERFLOW	0x0d
-#define		SSD_KEY_MISCOMPARE	0x0e
-#define		SSD_KEY_RESERVED	0x0f			
-#define	SSD_ILI		0x20
-#define	SSD_EOM		0x40
-#define	SSD_FILEMARK	0x80
-	uint8_t info[4];
-	uint8_t extra_len;
-	uint8_t cmd_spec_info[4];
-	uint8_t add_sense_code;
-	uint8_t add_sense_code_qual;
-	uint8_t fru;
-	uint8_t sense_key_spec[3];
-#define	SSD_SCS_VALID		0x80
-#define SSD_FIELDPTR_CMD	0x40
-#define SSD_BITPTR_VALID	0x08
-#define SSD_BITPTR_VALUE	0x07
-#define SSD_MIN_SIZE 18
-	uint8_t extra_bytes[14];
-#define SSD_FULL_SIZE sizeof(struct scsi_sense_data)
-};
-
-struct scsi_mode_header_6
-{
-	uint8_t data_length;	/* Sense data length */
-	uint8_t medium_type;
-	uint8_t dev_spec;
-	uint8_t blk_desc_len;
-};
-
-struct scsi_mode_header_10
-{
-	uint8_t data_length[2];/* Sense data length */
-	uint8_t medium_type;
-	uint8_t dev_spec;
-	uint8_t unused[2];
-	uint8_t blk_desc_len[2];
-};
-
-struct scsi_mode_page_header
-{
-	uint8_t page_code;
-	uint8_t page_length;
-};
-
-struct scsi_mode_blk_desc
-{
-	uint8_t density;
-	uint8_t nblocks[3];
-	uint8_t reserved;
-	uint8_t blklen[3];
-};
-
-#define	SCSI_DEFAULT_DENSITY	0x00	/* use 'default' density */
-#define	SCSI_SAME_DENSITY	0x7f	/* use 'same' density- >= SCSI-2 only */
-
-
-/*
- * Status Byte
- */
-#define	SCSI_STATUS_OK			0x00
-#define	SCSI_STATUS_CHECK_COND		0x02
-#define	SCSI_STATUS_COND_MET		0x04
-#define	SCSI_STATUS_BUSY		0x08
-#define SCSI_STATUS_INTERMED		0x10
-#define SCSI_STATUS_INTERMED_COND_MET	0x14
-#define SCSI_STATUS_RESERV_CONFLICT	0x18
-#define SCSI_STATUS_CMD_TERMINATED	0x22	/* Obsolete in SAM-2 */
-#define SCSI_STATUS_QUEUE_FULL		0x28
-#define SCSI_STATUS_ACA_ACTIVE		0x30
-#define SCSI_STATUS_TASK_ABORTED	0x40
-
-struct scsi_inquiry_pattern {
-	uint8_t   type;
-	uint8_t   media_type;
-#define	SIP_MEDIA_REMOVABLE	0x01
-#define	SIP_MEDIA_FIXED		0x02
-	const char *vendor;
-	const char *product;
-	const char *revision;
-}; 
-
-struct scsi_static_inquiry_pattern {
-	uint8_t   type;
-	uint8_t   media_type;
-	char       vendor[SID_VENDOR_SIZE+1];
-	char       product[SID_PRODUCT_SIZE+1];
-	char       revision[SID_REVISION_SIZE+1];
-};
-
-struct scsi_sense_quirk_entry {
-	struct scsi_inquiry_pattern	inq_pat;
-	int				num_sense_keys;
-	int				num_ascs;
-	struct sense_key_table_entry	*sense_key_info;
-	struct asc_table_entry		*asc_info;
-};
-
-struct sense_key_table_entry {
-	uint8_t    sense_key;
-	uint32_t   action;
-	const char *desc;
-};
-
-struct asc_table_entry {
-	uint8_t    asc;
-	uint8_t    ascq;
-	uint32_t   action;
-	const char *desc;
-};
-
-struct op_table_entry {
-	uint8_t    opcode;
-	uint16_t   opmask;
-	const char  *desc;
-};
-
-struct scsi_op_quirk_entry {
-	struct scsi_inquiry_pattern	inq_pat;
-	int				num_ops;
-	struct op_table_entry		*op_table;
-};
-
-typedef enum {
-	SSS_FLAG_NONE		= 0x00,
-	SSS_FLAG_PRINT_COMMAND	= 0x01
-} scsi_sense_string_flags;
-
-extern const char *scsi_sense_key_text[];
-
-/************************* Large Disk Handling ********************************/
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-static __inline int aic_sector_div(u_long capacity, int heads, int sectors);
-
-static __inline int
-aic_sector_div(u_long capacity, int heads, int sectors)
-{
-	return (capacity / (heads * sectors));
-}
-#else
-static __inline int aic_sector_div(sector_t capacity, int heads, int sectors);
-
-static __inline int
-aic_sector_div(sector_t capacity, int heads, int sectors)
-{
-	/* ugly, ugly sector_div calling convention.. */
-	sector_div(capacity, (heads * sectors));
-	return (int)capacity;
-}
-#endif
-
-/**************************** Module Library Hack *****************************/
-/*
- * What we'd like to do is have a single "scsi library" module that both the
- * aic7xxx and aic79xx drivers could load and depend on.  A cursory examination
- * of implementing module dependencies in Linux (handling the install and
- * initrd cases) does not look promissing.  For now, we just duplicate this
- * code in both drivers using a simple symbol renaming scheme that hides this
- * hack from the drivers.
- */
-#define AIC_LIB_ENTRY_CONCAT(x, prefix)	prefix ## x
-#define	AIC_LIB_ENTRY_EXPAND(x, prefix) AIC_LIB_ENTRY_CONCAT(x, prefix)
-#define AIC_LIB_ENTRY(x)		AIC_LIB_ENTRY_EXPAND(x, AIC_LIB_PREFIX)
-
-#define	aic_sense_desc			AIC_LIB_ENTRY(_sense_desc)
-#define	aic_sense_error_action		AIC_LIB_ENTRY(_sense_error_action)
-#define	aic_error_action		AIC_LIB_ENTRY(_error_action)
-#define	aic_op_desc			AIC_LIB_ENTRY(_op_desc)
-#define	aic_cdb_string			AIC_LIB_ENTRY(_cdb_string)
-#define aic_print_inquiry		AIC_LIB_ENTRY(_print_inquiry)
-#define aic_calc_syncsrate		AIC_LIB_ENTRY(_calc_syncrate)
-#define	aic_calc_syncparam		AIC_LIB_ENTRY(_calc_syncparam)
-#define	aic_calc_speed			AIC_LIB_ENTRY(_calc_speed)
-#define	aic_inquiry_match		AIC_LIB_ENTRY(_inquiry_match)
-#define	aic_static_inquiry_match	AIC_LIB_ENTRY(_static_inquiry_match)
-
-/******************************************************************************/
-
-void			aic_sense_desc(int /*sense_key*/, int /*asc*/,
-				       int /*ascq*/, struct scsi_inquiry_data*,
-				       const char** /*sense_key_desc*/,
-				       const char** /*asc_desc*/);
-aic_sense_action	aic_sense_error_action(struct scsi_sense_data*,
-					       struct scsi_inquiry_data*,
-					       uint32_t /*sense_flags*/);
-uint32_t		aic_error_action(struct scsi_cmnd *,
-					 struct scsi_inquiry_data *,
-					 cam_status, u_int);
-
-#define	SF_RETRY_UA	0x01
-#define SF_NO_PRINT	0x02
-#define SF_QUIET_IR	0x04	/* Be quiet about Illegal Request reponses */
-#define SF_PRINT_ALWAYS	0x08
-
-
-const char *	aic_op_desc(uint16_t /*opcode*/, struct scsi_inquiry_data*);
-char *		aic_cdb_string(uint8_t* /*cdb_ptr*/, char* /*cdb_string*/,
-			       size_t /*len*/);
-void		aic_print_inquiry(struct scsi_inquiry_data*);
-
-u_int		aic_calc_syncsrate(u_int /*period_factor*/);
-u_int		aic_calc_syncparam(u_int /*period*/);
-u_int		aic_calc_speed(u_int width, u_int period, u_int offset,
-			       u_int min_rate);
-	
-int		aic_inquiry_match(caddr_t /*inqbuffer*/,
-				  caddr_t /*table_entry*/);
-int		aic_static_inquiry_match(caddr_t /*inqbuffer*/,
-					 caddr_t /*table_entry*/);
-
-
-static __inline void	 scsi_extract_sense(struct scsi_sense_data *sense,
-					    int *error_code, int *sense_key,
-					    int *asc, int *ascq);
-static __inline void	 scsi_ulto2b(uint32_t val, uint8_t *bytes);
-static __inline void	 scsi_ulto3b(uint32_t val, uint8_t *bytes);
-static __inline void	 scsi_ulto4b(uint32_t val, uint8_t *bytes);
-static __inline uint32_t scsi_2btoul(uint8_t *bytes);
-static __inline uint32_t scsi_3btoul(uint8_t *bytes);
-static __inline int32_t	 scsi_3btol(uint8_t *bytes);
-static __inline uint32_t scsi_4btoul(uint8_t *bytes);
-
-static __inline void scsi_extract_sense(struct scsi_sense_data *sense,
-				       int *error_code, int *sense_key,
-				       int *asc, int *ascq)
-{
-	*error_code = sense->error_code & SSD_ERRCODE;
-	*sense_key = sense->flags & SSD_KEY;
-	*asc = (sense->extra_len >= 5) ? sense->add_sense_code : 0;
-	*ascq = (sense->extra_len >= 6) ? sense->add_sense_code_qual : 0;
-}
-
-static __inline void
-scsi_ulto2b(uint32_t val, uint8_t *bytes)
-{
-
-	bytes[0] = (val >> 8) & 0xff;
-	bytes[1] = val & 0xff;
-}
-
-static __inline void
-scsi_ulto3b(uint32_t val, uint8_t *bytes)
-{
-
-	bytes[0] = (val >> 16) & 0xff;
-	bytes[1] = (val >> 8) & 0xff;
-	bytes[2] = val & 0xff;
-}
-
-static __inline void
-scsi_ulto4b(uint32_t val, uint8_t *bytes)
-{
-
-	bytes[0] = (val >> 24) & 0xff;
-	bytes[1] = (val >> 16) & 0xff;
-	bytes[2] = (val >> 8) & 0xff;
-	bytes[3] = val & 0xff;
-}
-
-static __inline uint32_t
-scsi_2btoul(uint8_t *bytes)
-{
-	uint32_t rv;
-
-	rv = (bytes[0] << 8) |
-	     bytes[1];
-	return (rv);
-}
-
-static __inline uint32_t
-scsi_3btoul(uint8_t *bytes)
-{
-	uint32_t rv;
-
-	rv = (bytes[0] << 16) |
-	     (bytes[1] << 8) |
-	     bytes[2];
-	return (rv);
-}
-
-static __inline int32_t 
-scsi_3btol(uint8_t *bytes)
-{
-	uint32_t rc = scsi_3btoul(bytes);
- 
-	if (rc & 0x00800000)
-		rc |= 0xff000000;
-
-	return (int32_t) rc;
-}
-
-static __inline uint32_t
-scsi_4btoul(uint8_t *bytes)
-{
-	uint32_t rv;
-
-	rv = (bytes[0] << 24) |
-	     (bytes[1] << 16) |
-	     (bytes[2] << 8) |
-	     bytes[3];
-	return (rv);
-}
-
-#endif /*_SCSI_SCSI_ALL_H*/
diff -urNp linux-5720/drivers/scsi/aic79xx/cam.h linux-5730/drivers/scsi/aic79xx/cam.h
--- linux-5720/drivers/scsi/aic79xx/cam.h
+++ linux-5730/drivers/scsi/aic79xx/cam.h
@@ -1,117 +0,0 @@
-/*
- * Data structures and definitions for the CAM system.
- *
- * Copyright (c) 1997 Justin T. Gibbs.
- * Copyright (c) 2000 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL").
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#15 $
- */
-
-#ifndef _AIC7XXX_CAM_H
-#define _AIC7XXX_CAM_H 1
-
-#include <linux/types.h>
-
-#define	CAM_BUS_WILDCARD ((u_int)~0)
-#define	CAM_TARGET_WILDCARD ((u_int)~0)
-#define	CAM_LUN_WILDCARD ((u_int)~0)
-
-/* CAM Status field values */
-typedef enum {
-	CAM_REQ_INPROG,		/* CCB request is in progress */
-	CAM_REQ_CMP,		/* CCB request completed without error */
-	CAM_REQ_ABORTED,	/* CCB request aborted by the host */
-	CAM_UA_ABORT,		/* Unable to abort CCB request */
-	CAM_REQ_CMP_ERR,	/* CCB request completed with an error */
-	CAM_BUSY,		/* CAM subsytem is busy */
-	CAM_REQ_INVALID,	/* CCB request was invalid */
-	CAM_PATH_INVALID,	/* Supplied Path ID is invalid */
-	CAM_SEL_TIMEOUT,	/* Target Selection Timeout */
-	CAM_CMD_TIMEOUT,	/* Command timeout */
-	CAM_SCSI_STATUS_ERROR,	/* SCSI error, look at error code in CCB */
-	CAM_SCSI_BUS_RESET,	/* SCSI Bus Reset Sent/Received */
-	CAM_UNCOR_PARITY,	/* Uncorrectable parity error occurred */
-	CAM_AUTOSENSE_FAIL,	/* Autosense: request sense cmd fail */
-	CAM_NO_HBA,		/* No HBA Detected Error */
-	CAM_DATA_RUN_ERR,	/* Data Overrun error */
-	CAM_UNEXP_BUSFREE,	/* Unexpected Bus Free */
-	CAM_SEQUENCE_FAIL,	/* Protocol Violation */
-	CAM_CCB_LEN_ERR,	/* CCB length supplied is inadequate */
-	CAM_PROVIDE_FAIL,	/* Unable to provide requested capability */
-	CAM_BDR_SENT,		/* A SCSI BDR msg was sent to target */
-	CAM_REQ_TERMIO,		/* CCB request terminated by the host */
-	CAM_UNREC_HBA_ERROR,	/* Unrecoverable Host Bus Adapter Error */
-	CAM_REQ_TOO_BIG,	/* The request was too large for this host */
-	CAM_UA_TERMIO,		/* Unable to terminate I/O CCB request */
-	CAM_MSG_REJECT_REC,	/* Message Reject Received */
-	CAM_DEV_NOT_THERE,	/* SCSI Device Not Installed/there */
-	CAM_RESRC_UNAVAIL,	/* Resource Unavailable */
-	/*
-	 * This request should be requeued to preserve
-	 * transaction ordering.  This typically occurs
-	 * when the SIM recognizes an error that should
-	 * freeze the queue and must place additional
-	 * requests for the target at the sim level
-	 * back into the XPT queue.
-	 */
-	CAM_REQUEUE_REQ,
-	CAM_DEV_QFRZN		= 0x40,
-
-	CAM_STATUS_MASK		= 0x3F
-} cam_status;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
-#define	SCSI_DATA_READ	1
-#define	SCSI_DATA_WRITE 2
-#define SCSI_DATA_NONE  3
-#endif
-
-/*
- * Definitions for the asynchronous callback CCB fields.
- */
-typedef enum {
-	AC_GETDEV_CHANGED	= 0x800,/* Getdev info might have changed */
-	AC_INQ_CHANGED		= 0x400,/* Inquiry info might have changed */
-	AC_TRANSFER_NEG		= 0x200,/* New transfer settings in effect */
-	AC_LOST_DEVICE		= 0x100,/* A device went away */
-	AC_FOUND_DEVICE		= 0x080,/* A new device was found */
-	AC_PATH_DEREGISTERED	= 0x040,/* A path has de-registered */
-	AC_PATH_REGISTERED	= 0x020,/* A new path has been registered */
-	AC_SENT_BDR		= 0x010,/* A BDR message was sent to target */
-	AC_SCSI_AEN		= 0x008,/* A SCSI AEN has been received */
-	AC_UNSOL_RESEL		= 0x002,/* Unsolicited reselection occurred */
-	AC_BUS_RESET		= 0x001 /* A SCSI bus reset occurred */
-} ac_code;
-
-typedef enum {
-	CAM_DIR_IN		= SCSI_DATA_READ,
-	CAM_DIR_OUT		= SCSI_DATA_WRITE,
-	CAM_DIR_NONE		= SCSI_DATA_NONE
-} ccb_flags;
-
-#endif /* _AIC7XXX_CAM_H */
diff -urNp linux-5720/drivers/scsi/aic79xx/queue.h linux-5730/drivers/scsi/aic79xx/queue.h
--- linux-5720/drivers/scsi/aic79xx/queue.h
+++ linux-5730/drivers/scsi/aic79xx/queue.h
@@ -1,501 +0,0 @@
-/*
- * Copyright (c) 1991, 1993
- *	The Regents of the University of California.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@(#)queue.h	8.5 (Berkeley) 8/20/94
- * $FreeBSD: src/sys/sys/queue.h,v 1.38 2000/05/26 02:06:56 jake Exp $
- */
-
-#ifndef _SYS_QUEUE_H_
-#define	_SYS_QUEUE_H_
-
-/*
- * This file defines five types of data structures: singly-linked lists,
- * singly-linked tail queues, lists, tail queues, and circular queues.
- *
- * A singly-linked list is headed by a single forward pointer. The elements
- * are singly linked for minimum space and pointer manipulation overhead at
- * the expense of O(n) removal for arbitrary elements. New elements can be
- * added to the list after an existing element or at the head of the list.
- * Elements being removed from the head of the list should use the explicit
- * macro for this purpose for optimum efficiency. A singly-linked list may
- * only be traversed in the forward direction.  Singly-linked lists are ideal
- * for applications with large datasets and few or no removals or for
- * implementing a LIFO queue.
- *
- * A singly-linked tail queue is headed by a pair of pointers, one to the
- * head of the list and the other to the tail of the list. The elements are
- * singly linked for minimum space and pointer manipulation overhead at the
- * expense of O(n) removal for arbitrary elements. New elements can be added
- * to the list after an existing element, at the head of the list, or at the
- * end of the list. Elements being removed from the head of the tail queue
- * should use the explicit macro for this purpose for optimum efficiency.
- * A singly-linked tail queue may only be traversed in the forward direction.
- * Singly-linked tail queues are ideal for applications with large datasets
- * and few or no removals or for implementing a FIFO queue.
- *
- * A list is headed by a single forward pointer (or an array of forward
- * pointers for a hash table header). The elements are doubly linked
- * so that an arbitrary element can be removed without a need to
- * traverse the list. New elements can be added to the list before
- * or after an existing element or at the head of the list. A list
- * may only be traversed in the forward direction.
- *
- * A tail queue is headed by a pair of pointers, one to the head of the
- * list and the other to the tail of the list. The elements are doubly
- * linked so that an arbitrary element can be removed without a need to
- * traverse the list. New elements can be added to the list before or
- * after an existing element, at the head of the list, or at the end of
- * the list. A tail queue may be traversed in either direction.
- *
- * A circle queue is headed by a pair of pointers, one to the head of the
- * list and the other to the tail of the list. The elements are doubly
- * linked so that an arbitrary element can be removed without a need to
- * traverse the list. New elements can be added to the list before or after
- * an existing element, at the head of the list, or at the end of the list.
- * A circle queue may be traversed in either direction, but has a more
- * complex end of list detection.
- *
- * For details on the use of these macros, see the queue(3) manual page.
- *
- *
- *			SLIST	LIST	STAILQ	TAILQ	CIRCLEQ
- * _HEAD		+	+	+	+	+
- * _HEAD_INITIALIZER	+	+	+	+	+
- * _ENTRY		+	+	+	+	+
- * _INIT		+	+	+	+	+
- * _EMPTY		+	+	+	+	+
- * _FIRST		+	+	+	+	+
- * _NEXT		+	+	+	+	+
- * _PREV		-	-	-	+	+
- * _LAST		-	-	+	+	+
- * _FOREACH		+	+	+	+	+
- * _FOREACH_REVERSE	-	-	-	+	+
- * _INSERT_HEAD		+	+	+	+	+
- * _INSERT_BEFORE	-	+	-	+	+
- * _INSERT_AFTER	+	+	+	+	+
- * _INSERT_TAIL		-	-	+	+	+
- * _REMOVE_HEAD		+	-	+	-	-
- * _REMOVE		+	+	+	+	+
- *
- */
-
-/*
- * Singly-linked List declarations.
- */
-#define	SLIST_HEAD(name, type)						\
-struct name {								\
-	struct type *slh_first;	/* first element */			\
-}
-
-#define	SLIST_HEAD_INITIALIZER(head)					\
-	{ NULL }
- 
-#define	SLIST_ENTRY(type)						\
-struct {								\
-	struct type *sle_next;	/* next element */			\
-}
- 
-/*
- * Singly-linked List functions.
- */
-#define	SLIST_EMPTY(head)	((head)->slh_first == NULL)
-
-#define	SLIST_FIRST(head)	((head)->slh_first)
-
-#define	SLIST_FOREACH(var, head, field)					\
-	for ((var) = SLIST_FIRST((head));				\
-	    (var);							\
-	    (var) = SLIST_NEXT((var), field))
-
-#define	SLIST_INIT(head) do {						\
-	SLIST_FIRST((head)) = NULL;					\
-} while (0)
-
-#define	SLIST_INSERT_AFTER(slistelm, elm, field) do {			\
-	SLIST_NEXT((elm), field) = SLIST_NEXT((slistelm), field);	\
-	SLIST_NEXT((slistelm), field) = (elm);				\
-} while (0)
-
-#define	SLIST_INSERT_HEAD(head, elm, field) do {			\
-	SLIST_NEXT((elm), field) = SLIST_FIRST((head));			\
-	SLIST_FIRST((head)) = (elm);					\
-} while (0)
-
-#define	SLIST_NEXT(elm, field)	((elm)->field.sle_next)
-
-#define	SLIST_REMOVE(head, elm, type, field) do {			\
-	if (SLIST_FIRST((head)) == (elm)) {				\
-		SLIST_REMOVE_HEAD((head), field);			\
-	}								\
-	else {								\
-		struct type *curelm = SLIST_FIRST((head));		\
-		while (SLIST_NEXT(curelm, field) != (elm))		\
-			curelm = SLIST_NEXT(curelm, field);		\
-		SLIST_NEXT(curelm, field) =				\
-		    SLIST_NEXT(SLIST_NEXT(curelm, field), field);	\
-	}								\
-} while (0)
-
-#define	SLIST_REMOVE_HEAD(head, field) do {				\
-	SLIST_FIRST((head)) = SLIST_NEXT(SLIST_FIRST((head)), field);	\
-} while (0)
-
-/*
- * Singly-linked Tail queue declarations.
- */
-#define	STAILQ_HEAD(name, type)						\
-struct name {								\
-	struct type *stqh_first;/* first element */			\
-	struct type **stqh_last;/* addr of last next element */		\
-}
-
-#define	STAILQ_HEAD_INITIALIZER(head)					\
-	{ NULL, &(head).stqh_first }
-
-#define	STAILQ_ENTRY(type)						\
-struct {								\
-	struct type *stqe_next;	/* next element */			\
-}
-
-/*
- * Singly-linked Tail queue functions.
- */
-#define	STAILQ_EMPTY(head)	((head)->stqh_first == NULL)
-
-#define	STAILQ_FIRST(head)	((head)->stqh_first)
-
-#define	STAILQ_FOREACH(var, head, field)				\
-	for((var) = STAILQ_FIRST((head));				\
-	   (var);							\
-	   (var) = STAILQ_NEXT((var), field))
-
-#define	STAILQ_INIT(head) do {						\
-	STAILQ_FIRST((head)) = NULL;					\
-	(head)->stqh_last = &STAILQ_FIRST((head));			\
-} while (0)
-
-#define	STAILQ_INSERT_AFTER(head, tqelm, elm, field) do {		\
-	if ((STAILQ_NEXT((elm), field) = STAILQ_NEXT((tqelm), field)) == NULL)\
-		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
-	STAILQ_NEXT((tqelm), field) = (elm);				\
-} while (0)
-
-#define	STAILQ_INSERT_HEAD(head, elm, field) do {			\
-	if ((STAILQ_NEXT((elm), field) = STAILQ_FIRST((head))) == NULL)	\
-		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
-	STAILQ_FIRST((head)) = (elm);					\
-} while (0)
-
-#define	STAILQ_INSERT_TAIL(head, elm, field) do {			\
-	STAILQ_NEXT((elm), field) = NULL;				\
-	STAILQ_LAST((head)) = (elm);					\
-	(head)->stqh_last = &STAILQ_NEXT((elm), field);			\
-} while (0)
-
-#define	STAILQ_LAST(head)	(*(head)->stqh_last)
-
-#define	STAILQ_NEXT(elm, field)	((elm)->field.stqe_next)
-
-#define	STAILQ_REMOVE(head, elm, type, field) do {			\
-	if (STAILQ_FIRST((head)) == (elm)) {				\
-		STAILQ_REMOVE_HEAD(head, field);			\
-	}								\
-	else {								\
-		struct type *curelm = STAILQ_FIRST((head));		\
-		while (STAILQ_NEXT(curelm, field) != (elm))		\
-			curelm = STAILQ_NEXT(curelm, field);		\
-		if ((STAILQ_NEXT(curelm, field) =			\
-		     STAILQ_NEXT(STAILQ_NEXT(curelm, field), field)) == NULL)\
-			(head)->stqh_last = &STAILQ_NEXT((curelm), field);\
-	}								\
-} while (0)
-
-#define	STAILQ_REMOVE_HEAD(head, field) do {				\
-	if ((STAILQ_FIRST((head)) =					\
-	     STAILQ_NEXT(STAILQ_FIRST((head)), field)) == NULL)		\
-		(head)->stqh_last = &STAILQ_FIRST((head));		\
-} while (0)
-
-#define	STAILQ_REMOVE_HEAD_UNTIL(head, elm, field) do {			\
-	if ((STAILQ_FIRST((head)) = STAILQ_NEXT((elm), field)) == NULL)	\
-		(head)->stqh_last = &STAILQ_FIRST((head));		\
-} while (0)
-
-/*
- * List declarations.
- */
-#define	LIST_HEAD(name, type)						\
-struct name {								\
-	struct type *lh_first;	/* first element */			\
-}
-
-#define	LIST_HEAD_INITIALIZER(head)					\
-	{ NULL }
-
-#define	LIST_ENTRY(type)						\
-struct {								\
-	struct type *le_next;	/* next element */			\
-	struct type **le_prev;	/* address of previous next element */	\
-}
-
-/*
- * List functions.
- */
-
-#define	LIST_EMPTY(head)	((head)->lh_first == NULL)
-
-#define	LIST_FIRST(head)	((head)->lh_first)
-
-#define	LIST_FOREACH(var, head, field)					\
-	for ((var) = LIST_FIRST((head));				\
-	    (var);							\
-	    (var) = LIST_NEXT((var), field))
-
-#define	LIST_INIT(head) do {						\
-	LIST_FIRST((head)) = NULL;					\
-} while (0)
-
-#define	LIST_INSERT_AFTER(listelm, elm, field) do {			\
-	if ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL)\
-		LIST_NEXT((listelm), field)->field.le_prev =		\
-		    &LIST_NEXT((elm), field);				\
-	LIST_NEXT((listelm), field) = (elm);				\
-	(elm)->field.le_prev = &LIST_NEXT((listelm), field);		\
-} while (0)
-
-#define	LIST_INSERT_BEFORE(listelm, elm, field) do {			\
-	(elm)->field.le_prev = (listelm)->field.le_prev;		\
-	LIST_NEXT((elm), field) = (listelm);				\
-	*(listelm)->field.le_prev = (elm);				\
-	(listelm)->field.le_prev = &LIST_NEXT((elm), field);		\
-} while (0)
-
-#define	LIST_INSERT_HEAD(head, elm, field) do {				\
-	if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL)	\
-		LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field);\
-	LIST_FIRST((head)) = (elm);					\
-	(elm)->field.le_prev = &LIST_FIRST((head));			\
-} while (0)
-
-#define	LIST_NEXT(elm, field)	((elm)->field.le_next)
-
-#define	LIST_REMOVE(elm, field) do {					\
-	if (LIST_NEXT((elm), field) != NULL)				\
-		LIST_NEXT((elm), field)->field.le_prev = 		\
-		    (elm)->field.le_prev;				\
-	*(elm)->field.le_prev = LIST_NEXT((elm), field);		\
-} while (0)
-
-/*
- * Tail queue declarations.
- */
-#define	TAILQ_HEAD(name, type)						\
-struct name {								\
-	struct type *tqh_first;	/* first element */			\
-	struct type **tqh_last;	/* addr of last next element */		\
-}
-
-#define	TAILQ_HEAD_INITIALIZER(head)					\
-	{ NULL, &(head).tqh_first }
-
-#define	TAILQ_ENTRY(type)						\
-struct {								\
-	struct type *tqe_next;	/* next element */			\
-	struct type **tqe_prev;	/* address of previous next element */	\
-}
-
-/*
- * Tail queue functions.
- */
-#define	TAILQ_EMPTY(head)	((head)->tqh_first == NULL)
-
-#define	TAILQ_FIRST(head)	((head)->tqh_first)
-
-#define	TAILQ_FOREACH(var, head, field)					\
-	for ((var) = TAILQ_FIRST((head));				\
-	    (var);							\
-	    (var) = TAILQ_NEXT((var), field))
-
-#define	TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
-	for ((var) = TAILQ_LAST((head), headname);			\
-	    (var);							\
-	    (var) = TAILQ_PREV((var), headname, field))
-
-#define	TAILQ_INIT(head) do {						\
-	TAILQ_FIRST((head)) = NULL;					\
-	(head)->tqh_last = &TAILQ_FIRST((head));			\
-} while (0)
-
-#define	TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
-	if ((TAILQ_NEXT((elm), field) = TAILQ_NEXT((listelm), field)) != NULL)\
-		TAILQ_NEXT((elm), field)->field.tqe_prev = 		\
-		    &TAILQ_NEXT((elm), field);				\
-	else								\
-		(head)->tqh_last = &TAILQ_NEXT((elm), field);		\
-	TAILQ_NEXT((listelm), field) = (elm);				\
-	(elm)->field.tqe_prev = &TAILQ_NEXT((listelm), field);		\
-} while (0)
-
-#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\
-	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\
-	TAILQ_NEXT((elm), field) = (listelm);				\
-	*(listelm)->field.tqe_prev = (elm);				\
-	(listelm)->field.tqe_prev = &TAILQ_NEXT((elm), field);		\
-} while (0)
-
-#define	TAILQ_INSERT_HEAD(head, elm, field) do {			\
-	if ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL)	\
-		TAILQ_FIRST((head))->field.tqe_prev =			\
-		    &TAILQ_NEXT((elm), field);				\
-	else								\
-		(head)->tqh_last = &TAILQ_NEXT((elm), field);		\
-	TAILQ_FIRST((head)) = (elm);					\
-	(elm)->field.tqe_prev = &TAILQ_FIRST((head));			\
-} while (0)
-
-#define	TAILQ_INSERT_TAIL(head, elm, field) do {			\
-	TAILQ_NEXT((elm), field) = NULL;				\
-	(elm)->field.tqe_prev = (head)->tqh_last;			\
-	*(head)->tqh_last = (elm);					\
-	(head)->tqh_last = &TAILQ_NEXT((elm), field);			\
-} while (0)
-
-#define	TAILQ_LAST(head, headname)					\
-	(*(((struct headname *)((head)->tqh_last))->tqh_last))
-
-#define	TAILQ_NEXT(elm, field) ((elm)->field.tqe_next)
-
-#define	TAILQ_PREV(elm, headname, field)				\
-	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
-
-#define	TAILQ_REMOVE(head, elm, field) do {				\
-	if ((TAILQ_NEXT((elm), field)) != NULL)				\
-		TAILQ_NEXT((elm), field)->field.tqe_prev = 		\
-		    (elm)->field.tqe_prev;				\
-	else								\
-		(head)->tqh_last = (elm)->field.tqe_prev;		\
-	*(elm)->field.tqe_prev = TAILQ_NEXT((elm), field);		\
-} while (0)
-
-/*
- * Circular queue declarations.
- */
-#define	CIRCLEQ_HEAD(name, type)					\
-struct name {								\
-	struct type *cqh_first;		/* first element */		\
-	struct type *cqh_last;		/* last element */		\
-}
-
-#define	CIRCLEQ_HEAD_INITIALIZER(head)					\
-	{ (void *)&(head), (void *)&(head) }
-
-#define	CIRCLEQ_ENTRY(type)						\
-struct {								\
-	struct type *cqe_next;		/* next element */		\
-	struct type *cqe_prev;		/* previous element */		\
-}
-
-/*
- * Circular queue functions.
- */
-#define	CIRCLEQ_EMPTY(head)	((head)->cqh_first == (void *)(head))
-
-#define	CIRCLEQ_FIRST(head)	((head)->cqh_first)
-
-#define	CIRCLEQ_FOREACH(var, head, field)				\
-	for ((var) = CIRCLEQ_FIRST((head));				\
-	    (var) != (void *)(head);					\
-	    (var) = CIRCLEQ_NEXT((var), field))
-
-#define	CIRCLEQ_FOREACH_REVERSE(var, head, field)			\
-	for ((var) = CIRCLEQ_LAST((head));				\
-	    (var) != (void *)(head);					\
-	    (var) = CIRCLEQ_PREV((var), field))
-
-#define	CIRCLEQ_INIT(head) do {						\
-	CIRCLEQ_FIRST((head)) = (void *)(head);				\
-	CIRCLEQ_LAST((head)) = (void *)(head);				\
-} while (0)
-
-#define	CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
-	CIRCLEQ_NEXT((elm), field) = CIRCLEQ_NEXT((listelm), field);	\
-	CIRCLEQ_PREV((elm), field) = (listelm);				\
-	if (CIRCLEQ_NEXT((listelm), field) == (void *)(head))		\
-		CIRCLEQ_LAST((head)) = (elm);				\
-	else								\
-		CIRCLEQ_PREV(CIRCLEQ_NEXT((listelm), field), field) = (elm);\
-	CIRCLEQ_NEXT((listelm), field) = (elm);				\
-} while (0)
-
-#define	CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do {		\
-	CIRCLEQ_NEXT((elm), field) = (listelm);				\
-	CIRCLEQ_PREV((elm), field) = CIRCLEQ_PREV((listelm), field);	\
-	if (CIRCLEQ_PREV((listelm), field) == (void *)(head))		\
-		CIRCLEQ_FIRST((head)) = (elm);				\
-	else								\
-		CIRCLEQ_NEXT(CIRCLEQ_PREV((listelm), field), field) = (elm);\
-	CIRCLEQ_PREV((listelm), field) = (elm);				\
-} while (0)
-
-#define	CIRCLEQ_INSERT_HEAD(head, elm, field) do {			\
-	CIRCLEQ_NEXT((elm), field) = CIRCLEQ_FIRST((head));		\
-	CIRCLEQ_PREV((elm), field) = (void *)(head);			\
-	if (CIRCLEQ_LAST((head)) == (void *)(head))			\
-		CIRCLEQ_LAST((head)) = (elm);				\
-	else								\
-		CIRCLEQ_PREV(CIRCLEQ_FIRST((head)), field) = (elm);	\
-	CIRCLEQ_FIRST((head)) = (elm);					\
-} while (0)
-
-#define	CIRCLEQ_INSERT_TAIL(head, elm, field) do {			\
-	CIRCLEQ_NEXT((elm), field) = (void *)(head);			\
-	CIRCLEQ_PREV((elm), field) = CIRCLEQ_LAST((head));		\
-	if (CIRCLEQ_FIRST((head)) == (void *)(head))			\
-		CIRCLEQ_FIRST((head)) = (elm);				\
-	else								\
-		CIRCLEQ_NEXT(CIRCLEQ_LAST((head)), field) = (elm);	\
-	CIRCLEQ_LAST((head)) = (elm);					\
-} while (0)
-
-#define	CIRCLEQ_LAST(head)	((head)->cqh_last)
-
-#define	CIRCLEQ_NEXT(elm,field)	((elm)->field.cqe_next)
-
-#define	CIRCLEQ_PREV(elm,field)	((elm)->field.cqe_prev)
-
-#define	CIRCLEQ_REMOVE(head, elm, field) do {				\
-	if (CIRCLEQ_NEXT((elm), field) == (void *)(head))		\
-		CIRCLEQ_LAST((head)) = CIRCLEQ_PREV((elm), field);	\
-	else								\
-		CIRCLEQ_PREV(CIRCLEQ_NEXT((elm), field), field) =	\
-		    CIRCLEQ_PREV((elm), field);				\
-	if (CIRCLEQ_PREV((elm), field) == (void *)(head))		\
-		CIRCLEQ_FIRST((head)) = CIRCLEQ_NEXT((elm), field);	\
-	else								\
-		CIRCLEQ_NEXT(CIRCLEQ_PREV((elm), field), field) =	\
-		    CIRCLEQ_NEXT((elm), field);				\
-} while (0)
-
-#endif /* !_SYS_QUEUE_H_ */
diff -urNp linux-5720/drivers/scsi/aic79xx/scsi_iu.h linux-5730/drivers/scsi/aic79xx/scsi_iu.h
--- linux-5720/drivers/scsi/aic79xx/scsi_iu.h
+++ linux-5730/drivers/scsi/aic79xx/scsi_iu.h
@@ -1,39 +0,0 @@
-/*
- * This file is in the public domain.
- */
-#ifndef	_SCSI_SCSI_IU_H
-#define _SCSI_SCSI_IU_H 1
-
-struct scsi_status_iu_header
-{
-	u_int8_t reserved[2];
-	u_int8_t flags;
-#define	SIU_SNSVALID 0x2
-#define	SIU_RSPVALID 0x1
-	u_int8_t status;
-	u_int8_t sense_length[4];
-	u_int8_t pkt_failures_length[4];
-	u_int8_t pkt_failures[1];
-};
-
-#define SIU_PKTFAIL_OFFSET(siu) 12
-#define SIU_PKTFAIL_CODE(siu) (scsi_4btoul((siu)->pkt_failures) & 0xFF)
-#define		SIU_PFC_NONE			0
-#define		SIU_PFC_CIU_FIELDS_INVALID	2
-#define		SIU_PFC_TMF_NOT_SUPPORTED	4
-#define		SIU_PFC_TMF_FAILED		5
-#define		SIU_PFC_INVALID_TYPE_CODE	6
-#define		SIU_PFC_ILLEGAL_REQUEST		7
-#define SIU_SENSE_OFFSET(siu)				\
-    (12 + (((siu)->flags & SIU_RSPVALID)		\
-	? scsi_4btoul((siu)->pkt_failures_length)	\
-	: 0))
-
-#define	SIU_TASKMGMT_NONE		0x00
-#define	SIU_TASKMGMT_ABORT_TASK		0x01
-#define	SIU_TASKMGMT_ABORT_TASK_SET	0x02
-#define	SIU_TASKMGMT_CLEAR_TASK_SET	0x04
-#define	SIU_TASKMGMT_LUN_RESET		0x08
-#define	SIU_TASKMGMT_TARGET_RESET	0x20
-#define	SIU_TASKMGMT_CLEAR_ACA		0x40
-#endif /*_SCSI_SCSI_IU_H*/
diff -urNp linux-5720/drivers/scsi/aic79xx/scsi_message.h linux-5730/drivers/scsi/aic79xx/scsi_message.h
--- linux-5720/drivers/scsi/aic79xx/scsi_message.h
+++ linux-5730/drivers/scsi/aic79xx/scsi_message.h
@@ -1,70 +0,0 @@
-/*
- * This file is in the public domain.
- * $FreeBSD: src/sys/cam/scsi/scsi_message.h,v 1.2 2000/05/01 20:21:29 peter Exp $
- */
-
-/* Messages (1 byte) */		     /* I/T (M)andatory or (O)ptional */
-#define MSG_CMDCOMPLETE		0x00 /* M/M */
-#define MSG_TASK_COMPLETE	0x00 /* M/M */ /* SPI3 Terminology */
-#define MSG_EXTENDED		0x01 /* O/O */
-#define MSG_SAVEDATAPOINTER	0x02 /* O/O */
-#define MSG_RESTOREPOINTERS	0x03 /* O/O */
-#define MSG_DISCONNECT		0x04 /* O/O */
-#define MSG_INITIATOR_DET_ERR	0x05 /* M/M */
-#define MSG_ABORT		0x06 /* O/M */
-#define MSG_ABORT_TASK_SET	0x06 /* O/M */ /* SPI3 Terminology */
-#define MSG_MESSAGE_REJECT	0x07 /* M/M */
-#define MSG_NOOP		0x08 /* M/M */
-#define MSG_PARITY_ERROR	0x09 /* M/M */
-#define MSG_LINK_CMD_COMPLETE	0x0a /* O/O */
-#define MSG_LINK_CMD_COMPLETEF	0x0b /* O/O */
-#define MSG_BUS_DEV_RESET	0x0c /* O/M */
-#define MSG_TARGET_RESET	0x0c /* O/M */ /* SPI3 Terminology */
-#define MSG_ABORT_TAG		0x0d /* O/O */
-#define MSG_ABORT_TASK		0x0d /* O/O */ /* SPI3 Terminology */
-#define MSG_CLEAR_QUEUE		0x0e /* O/O */
-#define MSG_CLEAR_TASK_SET	0x0e /* O/O */ /* SPI3 Terminology */
-#define MSG_INIT_RECOVERY	0x0f /* O/O */ /* Deprecated in SPI3 */
-#define MSG_REL_RECOVERY	0x10 /* O/O */ /* Deprecated in SPI3 */
-#define MSG_TERM_IO_PROC	0x11 /* O/O */ /* Deprecated in SPI3 */
-#define MSG_CLEAR_ACA		0x16 /* O/O */ /* SPI3 */
-#define MSG_LOGICAL_UNIT_RESET	0x17 /* O/O */ /* SPI3 */
-#define MSG_QAS_REQUEST		0x55 /* O/O */ /* SPI3 */
-
-/* Messages (2 byte) */
-#define MSG_SIMPLE_Q_TAG	0x20 /* O/O */
-#define MSG_SIMPLE_TASK		0x20 /* O/O */ /* SPI3 Terminology */
-#define MSG_HEAD_OF_Q_TAG	0x21 /* O/O */
-#define MSG_HEAD_OF_QUEUE_TASK	0x21 /* O/O */ /* SPI3 Terminology */
-#define MSG_ORDERED_Q_TAG	0x22 /* O/O */
-#define MSG_ORDERED_TASK	0x22 /* O/O */ /* SPI3 Terminology */
-#define MSG_IGN_WIDE_RESIDUE	0x23 /* O/O */
-#define MSG_ACA_TASK		0x24 /* 0/0 */ /* SPI3 */
-
-/* Identify message */		     /* M/M */	
-#define MSG_IDENTIFYFLAG	0x80 
-#define MSG_IDENTIFY_DISCFLAG	0x40 
-#define MSG_IDENTIFY(lun, disc)	(((disc) ? 0xc0 : MSG_IDENTIFYFLAG) | (lun))
-#define MSG_ISIDENTIFY(m)	((m) & MSG_IDENTIFYFLAG)
-#define MSG_IDENTIFY_LUNMASK	0x3F 
-
-/* Extended messages (opcode and length) */
-#define MSG_EXT_SDTR		0x01
-#define MSG_EXT_SDTR_LEN	0x03
-
-#define MSG_EXT_WDTR		0x03
-#define MSG_EXT_WDTR_LEN	0x02
-#define MSG_EXT_WDTR_BUS_8_BIT	0x00
-#define MSG_EXT_WDTR_BUS_16_BIT	0x01
-#define MSG_EXT_WDTR_BUS_32_BIT	0x02 /* Deprecated in SPI3 */
-
-#define MSG_EXT_PPR		0x04 /* SPI3 */
-#define MSG_EXT_PPR_LEN		0x06
-#define	MSG_EXT_PPR_PCOMP_EN	0x80
-#define	MSG_EXT_PPR_RTI		0x40
-#define	MSG_EXT_PPR_RD_STRM	0x20
-#define	MSG_EXT_PPR_WR_FLOW	0x10
-#define	MSG_EXT_PPR_HOLD_MCS	0x08
-#define	MSG_EXT_PPR_QAS_REQ	0x04
-#define	MSG_EXT_PPR_DT_REQ	0x02
-#define MSG_EXT_PPR_IU_REQ	0x01
diff -urNp linux-5720/drivers/scsi/aic7xxx/Config.in linux-5730/drivers/scsi/aic7xxx/Config.in
--- linux-5720/drivers/scsi/aic7xxx/Config.in
+++ linux-5730/drivers/scsi/aic7xxx/Config.in
@@ -2,12 +2,35 @@ if [ "$CONFIG_SCSI_AIC7XXX_OLD" != "y" ]
    dep_tristate 'Adaptec AIC7xxx support' CONFIG_SCSI_AIC7XXX $CONFIG_SCSI
    if [ "$CONFIG_SCSI_AIC7XXX" != "n" ]; then
       int  '  Maximum number of TCQ commands per device' \
-	CONFIG_AIC7XXX_CMDS_PER_DEVICE 253
+	CONFIG_AIC7XXX_CMDS_PER_DEVICE 32
       int  '  Initial bus reset delay in milli-seconds' \
 	CONFIG_AIC7XXX_RESET_DELAY_MS 15000
       bool  '  Probe for EISA and VL AIC7XXX Adapters' \
 	CONFIG_AIC7XXX_PROBE_EISA_VL
       bool  '  Build Adapter Firmware with Kernel Build' \
 	CONFIG_AIC7XXX_BUILD_FIRMWARE
+      bool  '  Compile in Debugging Code' \
+	CONFIG_AIC7XXX_DEBUG_ENABLE
+      int  '  Debug code enable mask (2048 for all debugging)' \
+	CONFIG_AIC7XXX_DEBUG_MASK 0
+      bool  '  Decode registers during diagnostics' \
+	CONFIG_AIC7XXX_REG_PRETTY_PRINT
    fi
 fi
+dep_tristate 'Adaptec AIC79xx support' CONFIG_SCSI_AIC79XX $CONFIG_SCSI
+if [ "$CONFIG_SCSI_AIC79XX" != "n" ]; then
+   int  '  Maximum number of TCQ commands per device' \
+	CONFIG_AIC79XX_CMDS_PER_DEVICE 32
+   int  '  Initial bus reset delay in milli-seconds' \
+	CONFIG_AIC79XX_RESET_DELAY_MS 15000
+   bool  '  Build Adapter Firmware with Kernel Build' \
+	CONFIG_AIC79XX_BUILD_FIRMWARE
+   bool  '  Enable Read Streaming for All Targets' \
+	CONFIG_AIC79XX_ENABLE_RD_STRM
+   bool  '  Compile in Debugging Code' \
+	CONFIG_AIC79XX_DEBUG_ENABLE
+   int  '  Debug code enable mask (16384 for all debugging)' \
+	CONFIG_AIC79XX_DEBUG_MASK 0
+   bool  '  Decode registers during diagnostics' \
+	CONFIG_AIC79XX_REG_PRETTY_PRINT
+fi
diff -urNp linux-5720/drivers/scsi/aic7xxx/Makefile linux-5730/drivers/scsi/aic7xxx/Makefile
--- linux-5720/drivers/scsi/aic7xxx/Makefile
+++ linux-5730/drivers/scsi/aic7xxx/Makefile
@@ -6,23 +6,46 @@
 
 O_TARGET := aic7xxx_drv.o
 
-list-multi	:= aic7xxx.o
+list-multi	:= aic7xxx.o aic79xx.o
 
 obj-$(CONFIG_SCSI_AIC7XXX)	+= aic7xxx.o
+ifeq ($(CONFIG_PCI),y)
+obj-$(CONFIG_SCSI_AIC79XX)	+= aic79xx.o
+endif
 
+EXTRA_CFLAGS += -I$(TOPDIR)/drivers/scsi -Werror
 #EXTRA_CFLAGS += -g
 
 # Platform Specific Files
-obj-aic7xxx = aic7xxx_osm.o aic7xxx_proc.o aic7770_osm.o
-#PCI Specific Platform Files
+obj-aic7xxx = aic7xxx_osm.o aic7xxx_proc.o
+
+# Core Files
+obj-aic7xxx += aic7xxx_core.o aic7xxx_93cx6.o
+ifeq ($(CONFIG_AIC7XXX_REG_PRETTY_PRINT),y)
+obj-aic7xxx += aic7xxx_reg_print.o
+endif
+
+#EISA Specific Files
+AIC7XXX_EISA_ARCH = $(filter i386 alpha,$(ARCH))
+ifneq ($(AIC7XXX_EISA_ARCH),)
+obj-aic7xxx += aic7770.o
+# Platform Specific EISA Files
+obj-aic7xxx += aic7770_osm.o
+endif
+
+#PCI Specific Files
 ifeq ($(CONFIG_PCI),y)
+obj-aic7xxx += aic7xxx_pci.o
+# Platform Specific PCI Files
 obj-aic7xxx += aic7xxx_osm_pci.o
 endif
+
+# Platform Specific U320 Files
+obj-aic79xx = aic79xx_osm.o aic79xx_proc.o aic79xx_osm_pci.o
 # Core Files
-obj-aic7xxx += aic7xxx_core.o aic7xxx_93cx6.o aic7770.o
-#PCI Specific Core Files
-ifeq ($(CONFIG_PCI),y)
-obj-aic7xxx += aic7xxx_pci.o
+obj-aic79xx += aic79xx_core.o aic79xx_pci.o
+ifeq ($(CONFIG_AIC79XX_REG_PRETTY_PRINT),y)
+obj-aic79xx += aic79xx_reg_print.o
 endif
 
 # Override our module desitnation
@@ -35,9 +58,39 @@ $(obj-aic7xxx): aic7xxx_reg.h
 aic7xxx.o: aic7xxx_seq.h aic7xxx_reg.h $(obj-aic7xxx)
 	$(LD) $(LD_RFLAG) -r -o $@ $(obj-aic7xxx)
 
+aic79xx_core.o: aic79xx_seq.h
+$(obj-aic79xx): aic79xx_reg.h
+aic79xx.o: aic79xx_seq.h aic79xx_reg.h $(obj-aic79xx)
+	$(LD) $(LD_RFLAG) -r -o $@ $(obj-aic79xx)
+
 ifeq ($(CONFIG_AIC7XXX_BUILD_FIRMWARE),y)
-aic7xxx_seq.h aic7xxx_reg.h: aic7xxx.seq aic7xxx.reg aicasm/aicasm
-	aicasm/aicasm -I. -r aic7xxx_reg.h -o aic7xxx_seq.h aic7xxx.seq
+aic7xxx_gen = aic7xxx_seq.h aic7xxx_reg.h
+ifeq ($(CONFIG_AIC7XXX_REG_PRETTY_PRINT),y)
+aic7xxx_gen += aic7xxx_reg_print.c
+aic7xxx_asm_cmd = aicasm/aicasm -I. -r aic7xxx_reg.h		\
+		 -p aic7xxx_reg_print.c -i aic7xxx_osm.h	\
+		 -o aic7xxx_seq.h aic7xxx.seq
+else
+aic7xxx_asm_cmd = aicasm/aicasm -I. -r aic7xxx_reg.h		\
+		 -o aic7xxx_seq.h aic7xxx.seq
+endif
+$(aic7xxx_gen): aic7xxx.seq aic7xxx.reg aicasm/aicasm
+	$(aic7xxx_asm_cmd)
+endif
+
+ifeq ($(CONFIG_AIC79XX_BUILD_FIRMWARE),y)
+aic79xx_gen = aic79xx_seq.h aic79xx_reg.h
+ifeq ($(CONFIG_AIC79XX_REG_PRETTY_PRINT),y)
+aic79xx_gen += aic79xx_reg_print.c
+aic79xx_asm_cmd = aicasm/aicasm -I. -r aic79xx_reg.h		\
+		 -p aic79xx_reg_print.c -i aic79xx_osm.h	\
+		 -o aic79xx_seq.h aic79xx.seq
+else
+aic79xx_asm_cmd = aicasm/aicasm -I. -r aic79xx_reg.h \
+		 -o aic79xx_seq.h aic79xx.seq
+endif
+$(aic79xx_gen): aic79xx.seq aic79xx.reg aicasm/aicasm
+	$(aic79xx_asm_cmd)
 endif
 
 aicasm/aicasm: aicasm/*.[chyl]
diff -urNp linux-5720/drivers/scsi/aic7xxx/README.aic79xx linux-5730/drivers/scsi/aic7xxx/README.aic79xx
--- linux-5720/drivers/scsi/aic7xxx/README.aic79xx
+++ linux-5730/drivers/scsi/aic7xxx/README.aic79xx
@@ -0,0 +1,496 @@
+====================================================================
+=             Adaptec Ultra320 Family Manager Set v1.3.0           =
+=                                                                  =
+=                            README for                            =
+=                    The Linux Operating System                    =
+====================================================================
+
+The following information is available in this file:
+
+  1. Supported Hardware
+  2. Version History
+  3. Command Line Options
+  4. Additional Notes
+  5. Contacting Adaptec
+
+
+1. Supported Hardware
+
+   The following Adaptec SCSI Host Adapters are supported by this 
+   driver set. 
+
+   Ultra320 Adapters         Description
+   ----------------------------------------------------------------
+   Adaptec SCSI Card 39320   Dual Channel 64-bit PCI-X 133MHz to
+                             Ultra320 SCSI Card (one external 
+                             68-pin, two internal 68-pin)
+   Adaptec SCSI Card 39320D  Dual Channel 64-bit PCI-X 133MHz to
+                             Ultra320 SCSI Card (two external VHDC
+                             and one internal 68-pin)
+   Adaptec SCSI Card 39320D  Dual Channel 64-bit PCI-X 133MHz to
+                             Ultra320 SCSI Card (two external VHDC
+                             and one internal 68-pin) based on the
+                             AIC-7902B ASIC
+   Adaptec SCSI Card 29320   Single Channel 64-bit PCI-X 133MHz to
+                             Ultra320 SCSI Card (one external 
+                             68-pin, two internal 68-pin, one
+                             internal 50-pin)
+   Adaptec SCSI Card 29320LP Single Channel 64-bit Low Profile
+                             PCI-X 133MHz to Ultra320 SCSI Card
+                             (One external VHDC, one internal
+                             68-pin)
+   AIC-7901A                 Single Channel 64-bit PCI-X 133MHz to 
+                             Ultra320 SCSI ASIC
+   AIC-7902A4                Dual Channel 64-bit PCI-X 133MHz to 
+                             Ultra320 SCSI ASIC
+   AIC-7902B                 Dual Channel 64-bit PCI-X 133MHz to
+                             Ultra320 SCSI ASIC
+
+2. Version History
+   1.3.10 (June 3rd, 2003)
+        - Align the SCB_TAG field on a 16byte boundary.  This avoids
+          SCB corruption on some PCI-33 busses.
+        - Correct non-zero luns on Rev B. hardware.
+        - Update for change in 2.5.X SCSI proc FS interface.
+        - When negotiation async via an 8bit WDTR message, send
+          an SDTR with an offset of 0 to be sure the target
+          knows we are async.  This works around a firmware defect
+          in the Quantum Atlas 10K.
+        - Implement controller susupend and resume.
+        - Clear PCI error state during driver attach so that we
+          don't disable memory mapped I/O due to a stray write
+          by some other driver probe that occurred before we
+          claimed the controller.
+
+   1.3.9 (May 22nd, 2003)
+        - Fix compiler errors.
+        - Remove S/G splitting for segments that cross a 4GB boundary.
+          This is guaranteed not to happen in Linux.
+        - Add support for scsi_report_device_reset() found in
+          2.5.X kernels.
+        - Add 7901B support.
+        - Simplify handling of the packtized lun Rev A workaround.
+        - Correct and simplify handling of the ignore wide residue
+          message.  The previous code would fail to report a residual
+          if the transaction data length was even and we received
+          an IWR message.
+
+   1.3.8 (April 29th, 2003)
+        - Fix types accessed via the command line interface code.
+        - Perform a few firmware optimizations.
+        - Fix "Unexpected PKT busfree" errors.
+        - Use a sequencer interrupt to notify the host of
+          commands with bad status.  We defer the notification
+          until there are no outstanding selections to ensure
+          that the host is interrupted for as short a time as
+          possible.
+        - Remove pre-2.2.X support.
+        - Add support for new 2.5.X interrupt API.
+        - Correct big-endian architecture support.
+
+   1.3.7 (April 16th, 2003)
+        - Use del_timer_sync() to ensure that no timeouts
+          are pending during controller shutdown.
+        - For pre-2.5.X kernels, carefully adjust our segment
+          list size to avoid SCSI malloc pool fragmentation.
+        - Cleanup channel display in our /proc output.
+        - Workaround duplicate device entries in the mid-layer
+          devlice list during add-single-device.
+
+   1.3.6 (March 28th, 2003)
+        - Correct a double free in the Domain Validation code.
+        - Correct a reference to free'ed memory during controller
+          shutdown.
+        - Reset the bus on an SE->LVD change.  This is required
+          to reset our transcievers.
+
+   1.3.5 (March 24th, 2003)
+        - Fix a few register window mode bugs.
+        - Include read streaming in the PPR flags we display in
+          diagnostics as well as /proc.
+        - Add PCI hot plug support for 2.5.X kernels.
+        - Correct default precompensation value for RevA hardware.
+        - Fix Domain Validation thread shutdown.
+        - Add a firmware workaround to make the LED blink
+          brighter during packetized operations on the H2A4.
+        - Correct /proc display of user read streaming settings.
+        - Simplify driver locking by releasing the io_request_lock
+          upon driver entry from the mid-layer.
+        - Cleanup command line parsing and move much of this code
+          to aiclib.
+
+   1.3.4 (February 28th, 2003)
+        - Correct a race condition in our error recovery handler.
+        - Allow Test Unit Ready commands to take a full 5 seconds
+          during Domain Validation.
+
+   1.3.2 (February 19th, 2003)
+        - Correct a Rev B. regression due to the GEM318
+          compatibility fix included in 1.3.1.
+          
+   1.3.1 (February 11th, 2003)
+        - Add support for the 39320A.
+        - Improve recovery for certain PCI-X errors.
+        - Fix handling of LQ/DATA/LQ/DATA for the
+          same write transaction that can occur without
+          interveining training.
+        - Correct compatibility issues with the GEM318
+          enclosure services device.
+        - Correct data corruption issue that occurred under
+          high tag depth write loads.
+        - Adapt to a change in the 2.5.X daemonize() API.
+        - Correct a "Missing case in ahd_handle_scsiint" panic.
+
+   1.3.0 (January 21st, 2003)
+        - Full regression testing for all U320 products completed.
+        - Added abort and target/lun reset error recovery handler and
+          interrupt coalessing.
+
+   1.2.0 (November 14th, 2002)
+        - Added support for Domain Validation
+        - Add support for the Hewlett-Packard version of the 39320D
+          and AIC-7902 adapters.
+        Support for previous adapters has not been fully tested and should
+        only be used at the customer's own risk.
+
+   1.1.1 (September 24th, 2002)
+        - Added support for the Linux 2.5.X kernel series
+
+   1.1.0 (September 17th, 2002)
+        - Added support for four additional SCSI products:
+          ASC-39320, ASC-29320, ASC-29320LP, AIC-7901.
+
+   1.0.0 (May 30th, 2002)
+        - Initial driver release.
+
+   2.1. Software/Hardware Features
+        - Support for the SPI-4 "Ultra320" standard:
+          - 320MB/s transfer rates
+          - Packetized SCSI Protocol at 160MB/s and 320MB/s
+          - Quick Arbitration Selection (QAS)
+          - Retained Training Information (Rev B. ASIC only)
+        - Interrupt Coalessing
+        - Initiator Mode (target mode not currently 
+          supported)
+        - Support for the PCI-X standard up to 133MHz
+        - Support for the PCI v2.2 standard
+	- Domain Validation
+
+   2.2. Operating System Support:
+        - Redhat Linux 7.2, 7.3, 8.0, Advanced Server 2.1
+        - SuSE Linux 7.3, 8.0, 8.1, Enterprise Server 7
+        - only Intel and AMD x86 supported at this time
+        - >4GB memory configurations supported.
+
+     Refer to the User's Guide for more details on this.
+
+3. Command Line Options
+
+        WARNING: ALTERING OR ADDING THESE DRIVER PARAMETERS
+                 INCORRECTLY CAN RENDER YOUR SYSTEM INOPERABLE.
+                 USE THEM WITH CAUTION. 
+
+   Edit the file "modules.conf" in the directory /etc and add/edit a
+   line containing 'options aic79xx aic79xx=[command[,command...]]' where
+   'command' is one or more of the following:
+   -----------------------------------------------------------------
+              Option: verbose
+          Definition: enable additional informative messages during
+                      driver operation.
+     Possible Values: This option is a flag
+       Default Value: disabled
+   -----------------------------------------------------------------
+              Option: debug:[value]
+          Definition: Enables various levels of debugging information
+                      The bit definitions for the debugging mask can
+                      be found in drivers/scsi/aic7xxx/aic79xx.h under
+                      the "Debug" heading.
+     Possible Values: 0x0000 = no debugging, 0xffff = full debugging
+       Default Value: 0x0000
+   -----------------------------------------------------------------
+              Option: no_reset
+          Definition: Do not reset the bus during the initial probe
+                      phase
+     Possible Values: This option is a flag
+       Default Value: disabled
+   -----------------------------------------------------------------
+              Option: extended
+          Definition: Force extended translation on the controller
+     Possible Values: This option is a flag
+       Default Value: disabled
+   -----------------------------------------------------------------
+              Option: periodic_otag
+          Definition: Send an ordered tag periodically to prevent
+                      tag starvation.  Needed for some older devices
+     Possible Values: This option is a flag
+       Default Value: disabled
+   -----------------------------------------------------------------
+              Option: reverse_scan
+          Definition: Probe the scsi bus in reverse order, starting
+                      with target 15
+     Possible Values: This option is a flag
+       Default Value: disabled
+   -----------------------------------------------------------------
+              Option: global_tag_depth
+          Definition: Global tag depth for all targets on all busses.
+                      This option sets the default tag depth which
+                      may be selectively overridden vi the tag_info
+                      option.
+     Possible Values: 1 - 253
+       Default Value: 32
+   -----------------------------------------------------------------
+              Option: tag_info:{{value[,value...]}[,{value[,value...]}...]}
+          Definition: Set the per-target tagged queue depth on a
+                      per controller basis.  Both controllers and targets
+                      may be ommitted indicating that they should retain
+                      the default tag depth.
+            Examples: tag_info:{{16,32,32,64,8,8,,32,32,32,32,32,32,32,32,32}
+                        On Controller 0
+                          specifies a tag depth of 16 for target 0
+                          specifies a tag depth of 64 for target 3
+                          specifies a tag depth of 8 for targets 4 and 5
+                          leaves target 6 at the default
+                          specifies a tag depth of 32 for targets 1,2,7-15
+                        All other targets retain the default depth.
+
+                      tag_info:{{},{32,,32}}
+                        On Controller 1
+                          specifies a tag depth of 32 for targets 0 and 2
+                        All other targets retain the default depth.
+                        
+     Possible Values: 1 - 253
+       Default Value: 32
+   -----------------------------------------------------------------
+              Option: rd_strm: {rd_strm_bitmask[,rd_strm_bitmask...]}
+          Definition: Enable read streaming on a per target basis.
+                      The rd_strm_bitmask is a 16 bit hex value in which
+                      each bit represents a target.  Setting the target's
+                      bit to '1' enables read streaming for that
+                      target.  Controllers may be ommitted indicating that
+                      they should retain the default read streaming setting.
+             Example: rd_strm:{0x0041}
+                        On Controller 0
+                          enables read streaming for targets 0 and 6.
+                          disables read streaming for targets 1-5,7-15.
+                        All other targets retain the default read
+                        streaming setting.
+             Example: rd_strm:{0x0023,,0xFFFF}
+                        On Controller 0
+                          enables read streaming for targets 1,2, and 5.
+                          disables read streaming for targets 3,4,6-15.
+                        On Controller 2
+                          enables read streaming for all targets.
+                        All other targets retain the default read
+                        streaming setting.
+                      
+     Possible Values: 0x0000 - 0xffff
+       Default Value: 0x0000
+   -----------------------------------------------------------------
+              Option: dv: {value[,value...]}
+          Definition: Set Domain Validation Policy on a per-controller basis.
+                      Controllers may be ommitted indicating that
+                      they should retain the default read streaming setting.
+             Example: dv:{-1,0,,1,1,0}
+                        On Controller 0 leave DV at its default setting.
+                        On Controller 1 disable DV.
+                        Skip configuration on Controller 2.
+                        On Controllers 3 and 4 enable DV.
+                        On Controller 5 disable DV.
+
+     Possible Values: < 0 Use setting from serial EEPROM.
+                      0 Disable DV
+                      > 0 Enable DV
+       Default Value: DV Serial EEPROM configuration setting.
+   -----------------------------------------------------------------
+              Option: seltime:[value]
+          Definition: Specifies the selection timeout value
+     Possible Values: 0 = 256ms, 1 = 128ms, 2 = 64ms, 3 = 32ms
+       Default Value: 0
+   -----------------------------------------------------------------
+
+   *** The following three options should only be changed at ***
+   *** the direction of a technical support representative.  ***
+
+   -----------------------------------------------------------------
+              Option: precomp: {value[,value...]}
+          Definition: Set IO Cell precompensation value on a per-controller
+                      basis.
+                      Controllers may be ommitted indicating that
+                      they should retain the default precompensation setting.
+             Example: precomp:{0x1}
+                        On Controller 0 set precompensation to 1.
+             Example: precomp:{1,,7}
+                        On Controller 0 set precompensation to 1.
+                        On Controller 2 set precompensation to 8.
+                      
+     Possible Values: 0 - 7
+       Default Value: Varies based on chip revision
+   -----------------------------------------------------------------
+              Option: slewrate: {value[,value...]}
+          Definition: Set IO Cell slew rate on a per-controller basis.
+                      Controllers may be ommitted indicating that
+                      they should retain the default slew rate setting.
+             Example: slewrate:{0x1}
+                        On Controller 0 set slew rate to 1.
+             Example: slewrate :{1,,8}
+                        On Controller 0 set slew rate to 1.
+                        On Controller 2 set slew rate to 8.
+                      
+     Possible Values: 0 - 15
+       Default Value: Varies based on chip revision
+   -----------------------------------------------------------------
+              Option: amplitude: {value[,value...]}
+          Definition: Set IO Cell signal amplitude on a per-controller basis.
+                      Controllers may be ommitted indicating that
+                      they should retain the default read streaming setting.
+             Example: amplitude:{0x1}
+                        On Controller 0 set amplitude to 1.
+             Example: amplitude :{1,,7}
+                        On Controller 0 set amplitude to 1.
+                        On Controller 2 set amplitude to 7.
+                      
+     Possible Values: 1 - 7
+       Default Value: Varies based on chip revision
+   -----------------------------------------------------------------
+
+   Example: 'options aic79xx aic79xx=verbose,rd_strm:{{0x0041}}'
+        enables verbose output in the driver and turns read streaming on
+        for targets 0 and 6 of Controller 0.
+
+4. Additional Notes
+
+   4.1. Known/Unresolved or FYI Issues
+
+        * Under SuSE Linux Enterprise 7, the driver may fail to operate
+          correctly due to a problem with PCI interrupt routing in the
+          Linux kernel.  Please contact SuSE for an updated Linux
+          kernel.
+
+   4.2. Third-Party Compatibility Issues
+
+        * Adaptec only supports Ultra320 hard drives running
+          the latest firmware available. Please check with
+          your hard drive manufacturer to ensure you have the
+          latest version.
+
+   4.3. Operating System or Technology Limitations
+        
+        * PCI Hot Plug is untested and may cause the operating system 
+          to stop responding.
+        * Luns that are not numbered contiguously starting with 0 might not
+          be automatically probed during system startup.  This is a limitation
+          of the OS.  Please contact your Linux vendor for instructions on
+          manually probing non-contiguous luns.
+        * Using the Driver Update Disk version of this package during OS
+          installation under RedHat might result in two versions of this
+          driver being installed into the system module directory.  This
+          might cause problems with the /sbin/mkinitrd program and/or
+          other RPM packages that try to install system modules.  The best
+          way to correct this once the system is running is to install
+          the latest RPM package version of this driver, available from
+          http://www.adaptec.com.
+
+
+5. Contacting Adaptec
+
+   A Technical Support Identification (TSID) Number is required for 
+   Adaptec technical support.
+    - The 12-digit TSID can be found on the white barcode-type label
+      included inside the box with your product. The TSID helps us 
+      provide more efficient service by accurately identifying your 
+      product and support status.
+   Support Options
+    - Search the Adaptec Support Knowledgebase (ASK) at
+      http://ask.adaptec.com for articles, troubleshooting tips, and
+      frequently asked questions for your product.
+    - For support via Email, submit your question to Adaptec's 
+      Technical Support Specialists at http://ask.adaptec.com.
+     
+   North America
+    - Visit our Web site at http://www.adaptec.com.
+    - To speak with a Fibre Channel/RAID/External Storage Technical
+      Support Specialist, call 1-321-207-2000,
+      Hours: Monday-Friday, 3:00 A.M. to 5:00 P.M., PST.
+      (Not open on holidays)
+    - For Technical Support in all other technologies including 
+      SCSI, call 1-408-934-7274,
+      Hours: Monday-Friday, 6:00 A.M. to 5:00 P.M., PST.
+      (Not open on holidays)
+    - For after hours support, call 1-800-416-8066 ($99/call, 
+      $149/call on holidays)
+    - To order Adaptec products including software and cables, call
+      1-800-442-7274 or 1-408-957-7274. You can also visit our 
+      online store at http://www.adaptecstore.com
+
+   Europe
+    - Visit our Web site at http://www.adaptec-europe.com.
+    - English and French: To speak with a Technical Support 
+      Specialist, call one of the following numbers:
+        - English: +32-2-352-3470
+        - French:  +32-2-352-3460
+      Hours: Monday-Thursday, 10:00 to 12:30, 13:30 to 17:30 CET 
+             Friday, 10:00 to 12:30, 13:30 to 16:30 CET
+    - German: To speak with a Technical Support Specialist,
+      call +49-89-456-40660
+      Hours: Monday-Thursday, 09:30 to 12:30, 13:30 to 16:30 CET
+             Friday, 09:30 to 12:30, 13:30 to 15:00 CET
+    - To order Adaptec products, including accessories and cables:
+        - UK: +0800-96-65-26 or fax +0800-731-02-95
+        - Other European countries: +32-11-300-379
+
+   Australia and New Zealand
+    - Visit our Web site at http://www.adaptec.com.au.
+    - To speak with a Technical Support Specialist, call 
+      +612-9416-0698
+      Hours: Monday-Friday, 10:00 A.M. to 4:30 P.M., EAT
+      (Not open on holidays)
+
+   Japan
+    - To speak with a Technical Support Specialist, call 
+      +81-3-5308-6120 
+      Hours: Monday-Friday, 9:00 a.m. to 12:00 p.m., 1:00 p.m. to
+      6:00 p.m. TSC
+
+   Hong Kong and China
+    - To speak with a Technical Support Specialist, call 
+      +852-2869-7200
+      Hours: Monday-Friday, 10:00 to 17:00.
+    - Fax Technical Support at +852-2869-7100.
+
+   Singapore
+    - To speak with a Technical Support Specialist, call 
+      +65-245-7470
+      Hours: Monday-Friday, 10:00 to 17:00.
+    - Fax Technical Support at +852-2869-7100
+
+-------------------------------------------------------------------
+/*
+ * Copyright (c) 2003 Adaptec Inc. 691 S. Milpitas Blvd., Milpitas CA 95035 USA.
+ * All rights reserved.
+ *
+ * You are permitted to redistribute, use and modify this README file in whole
+ * or in part in conjunction with redistribution of software governed by the
+ * General Public License, provided that the following conditions are met:
+ * 1. Redistributions of README file must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ * 3. Modifications or new contributions must be attributed in a copyright
+ *    notice identifying the author ("Contributor") and added below the
+ *    original copyright notice. The copyright notice is for purposes of
+ *    identifying contributors and should not be deemed as permission to alter
+ *    the permissions given by Adaptec.
+ *
+ * THIS README FILE IS PROVIDED BY ADAPTEC AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, ANY
+ * WARRANTIES OF NON-INFRINGEMENT OR THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+ * ADAPTEC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS README
+ * FILE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
diff -urNp linux-5720/drivers/scsi/aic7xxx/README.aic7xxx linux-5730/drivers/scsi/aic7xxx/README.aic7xxx
--- linux-5720/drivers/scsi/aic7xxx/README.aic7xxx
+++ linux-5730/drivers/scsi/aic7xxx/README.aic7xxx
@@ -0,0 +1,414 @@
+====================================================================
+=    Adaptec Aic7xxx Fast -> Ultra160 Family Manager Set v6.2.28   =
+=                            README for                            =
+=                     The Linux Operating System                   =
+====================================================================
+
+The following information is available in this file:
+
+  1. Supported Hardware
+  2. Version History
+  3. Command Line Options
+  4. Contacting Adaptec
+
+1. Supported Hardware
+
+   The following Adaptec SCSI Chips and Host Adapters are supported by
+   the aic7xxx driver. 
+
+   Chip    MIPS  Host Bus  MaxSync  MaxWidth  SCBs  Notes
+   ---------------------------------------------------------------
+   aic7770  10    EISA/VL   10MHz    16Bit      4   1
+   aic7850  10    PCI/32    10MHz    8Bit       3
+   aic7855  10    PCI/32    10MHz    8Bit       3
+   aic7856  10    PCI/32    10MHz    8Bit       3
+   aic7859  10    PCI/32    20MHz    8Bit       3
+   aic7860  10    PCI/32    20MHz    8Bit       3
+   aic7870  10    PCI/32    10MHz    16Bit      16
+   aic7880  10    PCI/32    20MHz    16Bit      16
+   aic7890  20    PCI/32    40MHz    16Bit      16      3 4 5 6 7 8
+   aic7891  20    PCI/64    40MHz    16Bit      16      3 4 5 6 7 8
+   aic7892  20   PCI/64-66  80MHz    16Bit      16      3 4 5 6 7 8
+   aic7895  15    PCI/32    20MHz    16Bit      16    2 3 4 5
+   aic7895C 15    PCI/32    20MHz    16Bit      16    2 3 4 5     8
+   aic7896  20    PCI/32    40MHz    16Bit      16    2 3 4 5 6 7 8
+   aic7897  20    PCI/64    40MHz    16Bit      16    2 3 4 5 6 7 8
+   aic7899  20   PCI/64-66  80MHz    16Bit      16    2 3 4 5 6 7 8
+
+   1.   Multiplexed Twin Channel Device - One controller servicing two
+        busses.
+   2.   Multi-function Twin Channel Device - Two controllers on one chip.
+   3.   Command Channel Secondary DMA Engine - Allows scatter gather list
+        and SCB prefetch.
+   4.   64 Byte SCB Support - Allows disconnected, unttagged request table
+        for all possible target/lun combinations.
+   5.   Block Move Instruction Support - Doubles the speed of certain
+        sequencer operations.
+   6.   `Bayonet' style Scatter Gather Engine - Improves S/G prefetch
+        performance.
+   7.   Queuing Registers - Allows queuing of new transactions without
+        pausing the sequencer.
+   8.   Multiple Target IDs - Allows the controller to respond to selection
+        as a target on multiple SCSI IDs.
+
+   Controller      Chip   Host-Bus    Int-Connectors  Ext-Connectors  Notes
+   --------------------------------------------------------------------------
+   AHA-274X[A]    aic7770   EISA         SE-50M         SE-HD50F
+   AHA-274X[A]W   aic7770   EISA         SE-HD68F       SE-HD68F
+                                         SE-50M
+   AHA-274X[A]T   aic7770   EISA       2 X SE-50M       SE-HD50F
+   AHA-2842       aic7770    VL          SE-50M         SE-HD50F
+   AHA-2940AU     aic7860   PCI/32       SE-50M         SE-HD50F
+   AVA-2902I      aic7860   PCI/32       SE-50M
+   AVA-2902E      aic7860   PCI/32       SE-50M
+   AVA-2906       aic7856   PCI/32       SE-50M         SE-DB25F
+   APC-7850       aic7850   PCI/32       SE-50M                       1
+   AVA-2940       aic7860   PCI/32       SE-50M
+   AHA-2920B      aic7860   PCI/32       SE-50M
+   AHA-2930B      aic7860   PCI/32       SE-50M
+   AHA-2920C      aic7856   PCI/32       SE-50M         SE-HD50F
+   AHA-2930C      aic7860   PCI/32       SE-50M
+   AHA-2930C      aic7860   PCI/32       SE-50M
+   AHA-2910C      aic7860   PCI/32       SE-50M
+   AHA-2915C      aic7860   PCI/32       SE-50M
+   AHA-2940AU/CN  aic7860   PCI/32       SE-50M         SE-HD50F
+   AHA-2944W      aic7870   PCI/32     HVD-HD68F        HVD-HD68F
+                                        HVD-50M
+   AHA-3940W      aic7870   PCI/32     2 X SE-HD68F     SE-HD68F        2
+   AHA-2940UW     aic7880   PCI/32       SE-HD68F
+                                         SE-50M         SE-HD68F
+   AHA-2940U      aic7880   PCI/32       SE-50M         SE-HD50F
+   AHA-2940D      aic7880   PCI/32
+   aHA-2940 A/T   aic7880   PCI/32
+   AHA-2940D A/T  aic7880   PCI/32
+   AHA-3940UW     aic7880   PCI/32     2 X SE-HD68F     SE-HD68F          3
+   AHA-3940UWD    aic7880   PCI/32     2 X SE-HD68F   2 X SE-VHD68F       3
+   AHA-3940U      aic7880   PCI/32     2 X SE-50M       SE-HD50F          3
+   AHA-2944UW     aic7880   PCI/32      HVD-HD68F       HVD-HD68F
+                                         HVD-50M
+   AHA-3944UWD    aic7880   PCI/32     2 X HVD-HD68F  2 X HVD-VHD68F      3
+   AHA-4944UW     aic7880   PCI/32
+   AHA-2930UW     aic7880   PCI/32
+   AHA-2940UW Pro aic7880   PCI/32      SE-HD68F        SE-HD68F            4
+                                         SE-50M
+   AHA-2940UW/CN  aic7880   PCI/32
+   AHA-2940UDual  aic7895   PCI/32
+   AHA-2940UWDual aic7895   PCI/32
+   AHA-3940UWD    aic7895   PCI/32
+   AHA-3940AUW    aic7895   PCI/32
+   AHA-3940AUWD   aic7895   PCI/32
+   AHA-3940AU     aic7895   PCI/32
+   AHA-3944AUWD   aic7895   PCI/32     2 X HVD-HD68F  2 X HVD-VHD68F
+   AHA-2940U2B    aic7890   PCI/32      LVD-HD68F       LVD-HD68F
+   AHA-2940U2 OEM aic7891   PCI/64
+   AHA-2940U2W    aic7890   PCI/32      LVD-HD68F       LVD-HD68F
+                                        SE-HD68F 
+                                         SE-50M
+   AHA-2950U2B    aic7891   PCI/64      LVD-HD68F       LVD-HD68F
+   AHA-2930U2     aic7890   PCI/32      LVD-HD68F       SE-HD50F
+                                         SE-50M 
+   AHA-3950U2B    aic7897   PCI/64
+   AHA-3950U2D    aic7897   PCI/64
+   AHA-29160      aic7892   PCI/64-66
+   AHA-29160 CPQ  aic7892   PCI/64-66
+   AHA-29160N     aic7892   PCI/32      LVD-HD68F       SE-HD50F
+                                         SE-50M
+   AHA-29160LP    aic7892   PCI/64-66
+   AHA-19160      aic7892   PCI/64-66
+   AHA-29150LP    aic7892   PCI/64-66
+   AHA-29130LP    aic7892   PCI/64-66
+   AHA-3960D      aic7899   PCI/64-66  2 X LVD-HD68F  2 X LVD-VHD68F
+                                         LVD-50M
+   AHA-3960D CPQ  aic7899   PCI/64-66  2 X LVD-HD68F  2 X LVD-VHD68F
+                                         LVD-50M
+   AHA-39160      aic7899   PCI/64-66  2 X LVD-HD68F  2 X LVD-VHD68F
+                                         LVD-50M
+
+   1. No BIOS support
+   2. DEC21050 PCI-PCI bridge with multiple controller chips on secondary bus
+   3. DEC2115X PCI-PCI bridge with multiple controller chips on secondary bus
+   4. All three SCSI connectors may be used simultaneously without
+      SCSI "stub" effects.
+
+2. Version History
+   6.2.36 (June 3rd, 2003)
+        - Correct code that disables PCI parity error checking.
+        - Correct and simplify handling of the ignore wide residue
+          message.  The previous code would fail to report a residual
+          if the transaction data length was even and we received
+          an IWR message.
+        - Add support for the 2.5.X EISA framework.
+        - Update for change in 2.5.X SCSI proc FS interface.
+        - Correct Domain Validation command-line option parsing.
+        - When negotiation async via an 8bit WDTR message, send
+          an SDTR with an offset of 0 to be sure the target
+          knows we are async.  This works around a firmware defect
+          in the Quantum Atlas 10K.
+        - Clear PCI error state during driver attach so that we
+          don't disable memory mapped I/O due to a stray write
+          by some other driver probe that occurred before we
+          claimed the controller.
+
+   6.2.35 (May 14th, 2003)
+        - Fix a few GCC 3.3 compiler warnings.
+        - Correct operation on EISA Twin Channel controller.
+        - Add support for 2.5.X's scsi_report_device_reset().
+
+   6.2.34 (May 5th, 2003)
+        - Fix locking regression instroduced in 6.2.29 that
+          could cuase a lock order reversal between the io_request_lock
+          and our per-softc lock.  This was only possible on RH9,
+          SuSE, and kernel.org 2.4.X kernels.
+
+   6.2.33 (April 30th, 2003)
+        - Dynamically disable PCI parity error reporting after
+          10 errors are reported to the user.  These errors are
+          the result of some other device issuing PCI transactions
+          with bad parity.  Once the user has been informed of the
+          problem, continuing to report the errors just degrades
+          our performance.
+
+   6.2.32 (March 28th, 2003)
+        - Dynamically sized S/G lists to avoid SCSI malloc
+          pool fragmentation and SCSI mid-layer deadlock.
+
+   6.2.28 (January 20th, 2003)
+        - Domain Validation Fixes
+        - Add ability to disable PCI parity error checking.
+        - Enhanced Memory Mapped I/O probe
+
+   6.2.20 (November 7th, 2002)
+        - Added Domain Validation.
+
+3. Command Line Options
+
+        WARNING: ALTERING OR ADDING THESE DRIVER PARAMETERS
+                 INCORRECTLY CAN RENDER YOUR SYSTEM INOPERABLE.
+                 USE THEM WITH CAUTION. 
+
+   Edit the file "modules.conf" in the directory /etc and add/edit a
+   line containing 'options aic7xxx aic7xxx=[command[,command...]]' where
+   'command' is one or more of the following:
+   -----------------------------------------------------------------
+              Option: verbose
+          Definition: enable additional informative messages during
+                      driver operation.
+     Possible Values: This option is a flag
+       Default Value: disabled
+   -----------------------------------------------------------------
+              Option: debug:[value]
+          Definition: Enables various levels of debugging information
+     Possible Values: 0x0000 = no debugging, 0xffff = full debugging
+       Default Value: 0x0000
+   -----------------------------------------------------------------
+              Option: no_probe
+              Option: probe_eisa_vl
+          Definition: Do not probe for EISA/VLB controllers.
+                      This is a toggle.  If the driver is compiled
+                      to not probe EISA/VLB controllers by default,
+                      specifying "no_probe" will enable this probing.
+                      If the driver is compiled to probe EISA/VLB
+                      controllers by default, specifying "no_probe"
+                      will disable this probing.
+     Possible Values: This option is a toggle
+       Default Value: EISA/VLB probing is disabled by default.
+   -----------------------------------------------------------------
+              Option: pci_parity
+          Definition: Toggles the detection of PCI parity errors.
+                      On many motherboards with VIA chipsets,
+                      PCI parity is not generated correctly on the
+                      PCI bus.  It is impossible for the hardware to
+                      differentiate between these "spurious" parity
+                      errors and real parity errors.  The symptom of
+                      this problem is a stream of the message:
+    "scsi0: Data Parity Error Detected during address or write data phase"
+                      output by the driver.
+     Possible Values: This option is a toggle
+       Default Value: PCI Parity Error reporting is disabled
+   -----------------------------------------------------------------
+              Option: no_reset
+          Definition: Do not reset the bus during the initial probe
+                      phase
+     Possible Values: This option is a flag
+       Default Value: disabled
+   -----------------------------------------------------------------
+              Option: extended
+          Definition: Force extended translation on the controller
+     Possible Values: This option is a flag
+       Default Value: disabled
+   -----------------------------------------------------------------
+              Option: periodic_otag
+          Definition: Send an ordered tag periodically to prevent
+                      tag starvation.  Needed for some older devices
+     Possible Values: This option is a flag
+       Default Value: disabled
+   -----------------------------------------------------------------
+              Option: reverse_scan
+          Definition: Probe the scsi bus in reverse order, starting
+                      with target 15
+     Possible Values: This option is a flag
+       Default Value: disabled
+   -----------------------------------------------------------------
+              Option: global_tag_depth:[value]
+          Definition: Global tag depth for all targets on all busses.
+                      This option sets the default tag depth which
+                      may be selectively overridden vi the tag_info
+                      option.
+     Possible Values: 1 - 253
+       Default Value: 32
+   -----------------------------------------------------------------
+              Option: tag_info:{{value[,value...]}[,{value[,value...]}...]}
+          Definition: Set the per-target tagged queue depth on a
+                      per controller basis.  Both controllers and targets
+                      may be ommitted indicating that they should retain
+                      the default tag depth.
+            Examples: tag_info:{{16,32,32,64,8,8,,32,32,32,32,32,32,32,32,32}
+                        On Controller 0
+                          specifies a tag depth of 16 for target 0
+                          specifies a tag depth of 64 for target 3
+                          specifies a tag depth of 8 for targets 4 and 5
+                          leaves target 6 at the default
+                          specifies a tag depth of 32 for targets 1,2,7-15
+                        All other targets retain the default depth.
+
+                      tag_info:{{},{32,,32}}
+                        On Controller 1
+                          specifies a tag depth of 32 for targets 0 and 2
+                        All other targets retain the default depth.
+                        
+     Possible Values: 1 - 253
+       Default Value: 32
+   -----------------------------------------------------------------
+              Option: seltime:[value]
+          Definition: Specifies the selection timeout value
+     Possible Values: 0 = 256ms, 1 = 128ms, 2 = 64ms, 3 = 32ms
+       Default Value: 0
+   -----------------------------------------------------------------
+              Option: dv: {value[,value...]} 
+          Definition: Set Domain Validation Policy on a per-controller basis.
+                      Controllers may be ommitted indicating that
+                      they should retain the default read streaming setting.
+             Example: dv:{-1,0,,1,1,0}
+                        On Controller 0 leave DV at its default setting.
+                        On Controller 1 disable DV.
+                        Skip configuration on Controller 2.
+                        On Controllers 3 and 4 enable DV.
+                        On Controller 5 disable DV.
+
+     Possible Values: < 0 Use setting from serial EEPROM.
+                      0 Disable DV
+                      > 0 Enable DV
+
+       Default Value: SCSI-Select setting on controllers with a SCSI Select
+                      option for DV.  Otherwise, on for controllers supporting
+                      U160 speeds and off for all other controller types.
+   -----------------------------------------------------------------
+
+   Example:
+   'options aic7xxx aic7xxx=verbose,no_probe,tag_info:{{},{,,10}},seltime:1"
+        enables verbose logging, Disable EISA/VLB probing,
+        and set tag depth on Controller 1/Target 2 to 10 tags.
+
+3. Contacting Adaptec
+
+   A Technical Support Identification (TSID) Number is required for 
+   Adaptec technical support.
+    - The 12-digit TSID can be found on the white barcode-type label
+      included inside the box with your product. The TSID helps us 
+      provide more efficient service by accurately identifying your 
+      product and support status.
+   Support Options
+    - Search the Adaptec Support Knowledgebase (ASK) at
+      http://ask.adaptec.com for articles, troubleshooting tips, and
+      frequently asked questions for your product.
+    - For support via Email, submit your question to Adaptec's 
+      Technical Support Specialists at http://ask.adaptec.com.
+     
+   North America
+    - Visit our Web site at http://www.adaptec.com.
+    - To speak with a Fibre Channel/RAID/External Storage Technical
+      Support Specialist, call 1-321-207-2000,
+      Hours: Monday-Friday, 3:00 A.M. to 5:00 P.M., PST.
+      (Not open on holidays)
+    - For Technical Support in all other technologies including 
+      SCSI, call 1-408-934-7274,
+      Hours: Monday-Friday, 6:00 A.M. to 5:00 P.M., PST.
+      (Not open on holidays)
+    - For after hours support, call 1-800-416-8066 ($99/call, 
+      $149/call on holidays)
+    - To order Adaptec products including software and cables, call
+      1-800-442-7274 or 1-408-957-7274. You can also visit our 
+      online store at http://www.adaptecstore.com
+
+   Europe
+    - Visit our Web site at http://www.adaptec-europe.com.
+    - English and French: To speak with a Technical Support 
+      Specialist, call one of the following numbers:
+        - English: +32-2-352-3470
+        - French:  +32-2-352-3460
+      Hours: Monday-Thursday, 10:00 to 12:30, 13:30 to 17:30 CET 
+             Friday, 10:00 to 12:30, 13:30 to 16:30 CET
+    - German: To speak with a Technical Support Specialist,
+      call +49-89-456-40660
+      Hours: Monday-Thursday, 09:30 to 12:30, 13:30 to 16:30 CET
+             Friday, 09:30 to 12:30, 13:30 to 15:00 CET
+    - To order Adaptec products, including accessories and cables:
+        - UK: +0800-96-65-26 or fax +0800-731-02-95
+        - Other European countries: +32-11-300-379
+
+   Australia and New Zealand
+    - Visit our Web site at http://www.adaptec.com.au.
+    - To speak with a Technical Support Specialist, call 
+      +612-9416-0698
+      Hours: Monday-Friday, 10:00 A.M. to 4:30 P.M., EAT
+      (Not open on holidays)
+
+   Japan
+    - To speak with a Technical Support Specialist, call 
+      +81-3-5308-6120 
+      Hours: Monday-Friday, 9:00 a.m. to 12:00 p.m., 1:00 p.m. to
+      6:00 p.m. TSC
+
+   Hong Kong and China
+    - To speak with a Technical Support Specialist, call 
+      +852-2869-7200
+      Hours: Monday-Friday, 10:00 to 17:00.
+    - Fax Technical Support at +852-2869-7100.
+
+   Singapore
+    - To speak with a Technical Support Specialist, call 
+      +65-245-7470
+      Hours: Monday-Friday, 10:00 to 17:00.
+    - Fax Technical Support at +852-2869-7100
+
+-------------------------------------------------------------------
+/*
+ * Copyright (c) 2003 Adaptec Inc. 691 S. Milpitas Blvd., Milpitas CA 95035 USA.
+ * All rights reserved.
+ *
+ * You are permitted to redistribute, use and modify this README file in whole
+ * or in part in conjunction with redistribution of software governed by the
+ * General Public License, provided that the following conditions are met:
+ * 1. Redistributions of README file must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ * 3. Modifications or new contributions must be attributed in a copyright
+ *    notice identifying the author ("Contributor") and added below the
+ *    original copyright notice. The copyright notice is for purposes of
+ *    identifying contributors and should not be deemed as permission to alter
+ *    the permissions given by Adaptec.
+ *
+ * THIS README FILE IS PROVIDED BY ADAPTEC AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, ANY
+ * WARRANTIES OF NON-INFRINGEMENT OR THE IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+ * ADAPTEC OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+ * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS README
+ * FILE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7770.c linux-5730/drivers/scsi/aic7xxx/aic7770.c
--- linux-5720/drivers/scsi/aic7xxx/aic7770.c
+++ linux-5730/drivers/scsi/aic7xxx/aic7770.c
@@ -37,9 +37,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7770.c#21 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7770.c#32 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aic7770.c,v 1.1 2000/09/16 20:02:27 gibbs Exp $
+ * $FreeBSD$
  */
 
 #ifdef __linux__
@@ -56,14 +56,18 @@
 #define ID_AHA_274x	0x04907771
 #define ID_AHA_284xB	0x04907756 /* BIOS enabled */
 #define ID_AHA_284x	0x04907757 /* BIOS disabled*/
+#define	ID_OLV_274x	0x04907782 /* Olivetti OEM */
+#define	ID_OLV_274xD	0x04907783 /* Olivetti OEM (Differential) */
 
+static int aic7770_chip_init(struct ahc_softc *ahc);
+static int aic7770_suspend(struct ahc_softc *ahc);
+static int aic7770_resume(struct ahc_softc *ahc);
 static int aha2840_load_seeprom(struct ahc_softc *ahc);
 static ahc_device_setup_t ahc_aic7770_VL_setup;
 static ahc_device_setup_t ahc_aic7770_EISA_setup;;
 static ahc_device_setup_t ahc_aic7770_setup;
 
-
-struct aic7770_identity aic7770_ident_table [] =
+struct aic7770_identity aic7770_ident_table[] =
 {
 	{
 		ID_AHA_274x,
@@ -77,6 +81,24 @@ struct aic7770_identity aic7770_ident_ta
 		"Adaptec 284X SCSI adapter",
 		ahc_aic7770_VL_setup
 	},
+	{
+		ID_AHA_284x,
+		0xFFFFFFFE,
+		"Adaptec 284X SCSI adapter (BIOS Disabled)",
+		ahc_aic7770_VL_setup
+	},
+	{
+		ID_OLV_274x,
+		0xFFFFFFFF,
+		"Adaptec (Olivetti OEM) 274X SCSI adapter",
+		ahc_aic7770_EISA_setup
+	},
+	{
+		ID_OLV_274xD,
+		0xFFFFFFFF,
+		"Adaptec (Olivetti OEM) 274X Differential SCSI adapter",
+		ahc_aic7770_EISA_setup
+	},
 	/* Generic chip probes for devices we don't know 'exactly' */
 	{
 		ID_AIC7770,
@@ -105,7 +127,6 @@ int
 aic7770_config(struct ahc_softc *ahc, struct aic7770_identity *entry, u_int io)
 {
 	u_long	l;
-	u_long	s;
 	int	error;
 	int	have_seeprom;
 	u_int	hostconf;
@@ -131,8 +152,14 @@ aic7770_config(struct ahc_softc *ahc, st
 
 	ahc->description = entry->name;
 	error = ahc_softc_init(ahc);
+	if (error != 0)
+		return (error);
 
-	error = ahc_reset(ahc);
+	ahc->bus_chip_init = aic7770_chip_init;
+	ahc->bus_suspend = aic7770_suspend;
+	ahc->bus_resume = aic7770_resume;
+
+	error = ahc_reset(ahc, /*reinit*/FALSE);
 	if (error != 0)
 		return (error);
 
@@ -213,6 +240,9 @@ aic7770_config(struct ahc_softc *ahc, st
 	ahc_outb(ahc, BUSSPD, hostconf & DFTHRSH);
 	ahc_outb(ahc, BUSTIME, (hostconf << 2) & BOFF);
 
+	ahc->bus_softc.aic7770_softc.busspd = hostconf & DFTHRSH;
+	ahc->bus_softc.aic7770_softc.bustime = (hostconf << 2) & BOFF;
+
 	/*
 	 * Generic aic7xxx initialization.
 	 */
@@ -235,18 +265,33 @@ aic7770_config(struct ahc_softc *ahc, st
 	 */
 	ahc_outb(ahc, BCTL, ENABLE);
 
-	/*
-	 * Allow interrupts.
-	 */
-	ahc_lock(ahc, &s);
-	ahc_intr_enable(ahc, TRUE);
-	ahc_unlock(ahc, &s);
-
 	ahc_list_unlock(&l);
 
 	return (0);
 }
 
+static int
+aic7770_chip_init(struct ahc_softc *ahc)
+{
+	ahc_outb(ahc, BUSSPD, ahc->bus_softc.aic7770_softc.busspd);
+	ahc_outb(ahc, BUSTIME, ahc->bus_softc.aic7770_softc.bustime);
+	ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~AUTOFLUSHDIS);
+	ahc_outb(ahc, BCTL, ENABLE);
+	return (ahc_chip_init(ahc));
+}
+
+static int
+aic7770_suspend(struct ahc_softc *ahc)
+{
+	return (ahc_suspend(ahc));
+}
+
+static int
+aic7770_resume(struct ahc_softc *ahc)
+{
+	return (ahc_resume(ahc));
+}
+
 /*
  * Read the 284x SEEPROM.
  */
@@ -365,5 +410,6 @@ ahc_aic7770_setup(struct ahc_softc *ahc)
 	ahc->features = AHC_AIC7770_FE;
 	ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
 	ahc->flags |= AHC_PAGESCBS;
+	ahc->instruction_ram_size = 448;
 	return (0);
 }
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7770_osm.c linux-5730/drivers/scsi/aic7xxx/aic7770_osm.c
--- linux-5720/drivers/scsi/aic7xxx/aic7770_osm.c
+++ linux-5730/drivers/scsi/aic7xxx/aic7770_osm.c
@@ -1,7 +1,7 @@
 /*
  * Linux driver attachment glue for aic7770 based controllers.
  *
- * Copyright (c) 2000-2001 Adaptec Inc.
+ * Copyright (c) 2000-2003 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -36,33 +36,102 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#11 $
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#14 $
  */
 
 #include "aic7xxx_osm.h"
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#include <linux/device.h>
+#include <linux/eisa.h>
+
+#define EISA_MFCTR_CHAR0(ID) (char)(((ID>>26) & 0x1F) | '@')  /* Bits 26-30 */
+#define EISA_MFCTR_CHAR1(ID) (char)(((ID>>21) & 0x1F) | '@')  /* Bits 21-25 */
+#define EISA_MFCTR_CHAR2(ID) (char)(((ID>>16) & 0x1F) | '@')  /* Bits 16-20 */
+#define EISA_PRODUCT_ID(ID)  (short)((ID>>4)  & 0xFFF)        /* Bits  4-15 */
+#define EISA_REVISION_ID(ID) (uint8_t)(ID & 0x0F)             /* Bits  0-3  */
+
+static int aic7770_eisa_dev_probe(struct device *dev);
+static int aic7770_eisa_dev_remove(struct device *dev);
+static struct eisa_driver aic7770_driver = {
+	.driver = {
+		.name   = "aic7xxx",
+		.probe  = aic7770_eisa_dev_probe,
+		.remove = aic7770_eisa_dev_remove,
+	}
+};
+
+typedef  struct device *aic7770_dev_t;
+#else
 #define MINSLOT			1
 #define NUMSLOTS		16
 #define IDOFFSET		0x80
 
-int
-aic7770_linux_probe(Scsi_Host_Template *template)
+typedef void *aic7770_dev_t;
+#endif
+
+static int aic7770_linux_config(struct aic7770_identity *entry,
+				aic7770_dev_t dev, u_int eisaBase);
+
+void
+ahc_linux_eisa_init(void)
 {
-#if defined(__i386__) || defined(__alpha__)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	struct eisa_device_id *eid;
+	struct aic7770_identity *id;
+	int i;
+
+	if (aic7xxx_probe_eisa_vl == 0)
+		return;
+
+	/*
+	 * Linux requires the EISA IDs to be specified in
+	 * the EISA ID string format.  Perform the conversion
+	 * and setup a table with a NUL terminal entry.
+	 */
+	aic7770_driver.id_table = malloc(sizeof(struct eisa_device_id) *
+					 (ahc_num_aic7770_devs + 1),
+					 M_DEVBUF, M_NOWAIT);
+	if (aic7770_driver.id_table == NULL)
+		return;
+
+	for (eid = (struct eisa_device_id *)aic7770_driver.id_table,
+	     id = aic7770_ident_table, i = 0;
+	     i < ahc_num_aic7770_devs; eid++, id++, i++) {
+
+		sprintf(eid->sig, "%c%c%c%03X%01X",
+			EISA_MFCTR_CHAR0(id->full_id),
+			EISA_MFCTR_CHAR1(id->full_id),
+			EISA_MFCTR_CHAR2(id->full_id),
+			EISA_PRODUCT_ID(id->full_id),
+			EISA_REVISION_ID(id->full_id));
+		eid->driver_data = i;
+	}
+	eid->sig[0] = 0;
+
+	eisa_driver_register(&aic7770_driver);
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0) */
 	struct aic7770_identity *entry;
-	struct ahc_softc *ahc;
-	int i, slot;
-	int eisaBase;
-	int found;
+	u_int  slot;
+	u_int  eisaBase;
+	u_int  i;
+
+	if (aic7xxx_probe_eisa_vl == 0)
+		return;
 
 	eisaBase = 0x1000 + AHC_EISA_SLOT_OFFSET;
-	found = 0;
 	for (slot = 1; slot < NUMSLOTS; eisaBase+=0x1000, slot++) {
 		uint32_t eisa_id;
 		size_t	 id_size;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
 		if (check_region(eisaBase, AHC_EISA_IOSIZE) != 0)
 			continue;
+		request_region(eisaBase, AHC_EISA_IOSIZE, "aic7xxx");
+#else
+		if (request_region(eisaBase, AHC_EISA_IOSIZE, "aic7xxx") == 0)
+			continue;
+#endif
 
 		eisa_id = 0;
 		id_size = sizeof(eisa_id);
@@ -72,49 +141,69 @@ aic7770_linux_probe(Scsi_Host_Template *
 			eisa_id |= inb(eisaBase + IDOFFSET + i)
 				   << ((id_size-i-1) * 8);
 		}
+		release_region(eisaBase, AHC_EISA_IOSIZE);
 		if (eisa_id & 0x80000000)
 			continue;  /* no EISA card in slot */
 
 		entry = aic7770_find_device(eisa_id);
-		if (entry != NULL) {
-			char	 buf[80];
-			char	*name;
-			int	 error;
-
-			/*
-			 * Allocate a softc for this card and
-			 * set it up for attachment by our
-			 * common detect routine.
-			 */
-			sprintf(buf, "ahc_eisa:%d", slot);
-			name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
-			if (name == NULL)
-				break;
-			strcpy(name, buf);
-			ahc = ahc_alloc(template, name);
-			if (ahc == NULL) {
-				/*
-				 * If we can't allocate this one,
-				 * chances are we won't be able to
-				 * allocate future card structures.
-				 */
-				break;
-			}
-			error = aic7770_config(ahc, entry, eisaBase);
-			if (error != 0) {
-				ahc->bsh.ioport = 0;
-				ahc_free(ahc);
-				continue;
-			}
-			found++;
-		}
+		if (entry != NULL)
+			aic7770_linux_config(entry, NULL, eisaBase);
+	}
+#endif
+}
+
+void
+ahc_linux_eisa_exit(void)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	if (aic7xxx_probe_eisa_vl == 0)
+		return;
+
+	if (aic7770_driver.id_table != NULL) {
+		eisa_driver_unregister(&aic7770_driver);
+		free(aic7770_driver.id_table, M_DEVBUF);
 	}
-	return (found);
-#else
-	return (0);
 #endif
 }
 
+static int
+aic7770_linux_config(struct aic7770_identity *entry, aic7770_dev_t dev,
+		     u_int eisaBase)
+{
+	struct	ahc_softc *ahc;
+	char	buf[80];
+	char   *name;
+	int	error;
+
+	/*
+	 * Allocate a softc for this card and
+	 * set it up for attachment by our
+	 * common detect routine.
+	 */
+	sprintf(buf, "ahc_eisa:%d", eisaBase >> 12);
+	name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
+	if (name == NULL)
+		return (ENOMEM);
+	strcpy(name, buf);
+	ahc = ahc_alloc(&aic7xxx_driver_template, name);
+	if (ahc == NULL) {
+		free(name, M_DEVBUF);
+		return (ENOMEM);
+	}
+	error = aic7770_config(ahc, entry, eisaBase);
+	if (error != 0) {
+		ahc->bsh.ioport = 0;
+		ahc_free(ahc);
+		return (error);
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	dev->driver_data = (void *)ahc;
+	if (aic7xxx_detect_complete)
+		error = ahc_linux_register_host(ahc, &aic7xxx_driver_template);
+#endif
+	return (error);
+}
+
 int
 aic7770_map_registers(struct ahc_softc *ahc, u_int port)
 {
@@ -122,6 +211,8 @@ aic7770_map_registers(struct ahc_softc *
 	 * Lock out other contenders for our i/o space.
 	 */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+	if (check_region(port, AHC_EISA_IOSIZE) != 0)
+		return (ENOMEM);
 	request_region(port, AHC_EISA_IOSIZE, "aic7xxx");
 #else
 	if (request_region(port, AHC_EISA_IOSIZE, "aic7xxx") == 0)
@@ -148,3 +239,41 @@ aic7770_map_int(struct ahc_softc *ahc, u
 	
 	return (-error);
 }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static int
+aic7770_eisa_dev_probe(struct device *dev)
+{
+	struct eisa_device *edev;
+
+	edev = to_eisa_device(dev);
+	return (aic7770_linux_config(aic7770_ident_table + edev->id.driver_data,
+				    dev, edev->base_addr+AHC_EISA_SLOT_OFFSET));
+}
+
+static int
+aic7770_eisa_dev_remove(struct device *dev)
+{
+	struct ahc_softc *ahc;
+	u_long l;
+
+	/*
+	 * We should be able to just perform
+	 * the free directly, but check our
+	 * list for extra sanity.
+	 */
+	ahc_list_lock(&l);
+	ahc = ahc_find_softc((struct ahc_softc *)dev->driver_data);
+	if (ahc != NULL) {
+		u_long s;
+
+		ahc_lock(ahc, &s);
+		ahc_intr_enable(ahc, FALSE);
+		ahc_unlock(ahc, &s);
+		ahc_free(ahc);
+	}
+	ahc_list_unlock(&l);
+
+	return (0);
+}
+#endif
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic79xx.h linux-5730/drivers/scsi/aic7xxx/aic79xx.h
--- linux-5720/drivers/scsi/aic7xxx/aic79xx.h
+++ linux-5730/drivers/scsi/aic7xxx/aic79xx.h
@@ -0,0 +1,1537 @@
+/*
+ * Core definitions and data structures shareable across OS platforms.
+ *
+ * Copyright (c) 1994-2002 Justin T. Gibbs.
+ * Copyright (c) 2000-2002 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.h#92 $
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _AIC79XX_H_
+#define _AIC79XX_H_
+
+/* Register Definitions */
+#include "aic79xx_reg.h"
+
+/************************* Forward Declarations *******************************/
+struct ahd_platform_data;
+struct scb_platform_data;
+
+/****************************** Useful Macros *********************************/
+#ifndef MAX
+#define MAX(a,b) (((a) > (b)) ? (a) : (b))
+#endif
+
+#ifndef MIN
+#define MIN(a,b) (((a) < (b)) ? (a) : (b))
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#define NUM_ELEMENTS(array) (sizeof(array) / sizeof(*array))
+
+#define ALL_CHANNELS '\0'
+#define ALL_TARGETS_MASK 0xFFFF
+#define INITIATOR_WILDCARD	(~0)
+#define	SCB_LIST_NULL		0xFF00
+#define	SCB_LIST_NULL_LE	(ahd_htole16(SCB_LIST_NULL))
+#define QOUTFIFO_ENTRY_VALID 0x8000
+#define QOUTFIFO_ENTRY_VALID_LE (ahd_htole16(0x8000))
+#define SCBID_IS_NULL(scbid) (((scbid) & 0xFF00 ) == SCB_LIST_NULL)
+
+#define SCSIID_TARGET(ahd, scsiid)	\
+	(((scsiid) & TID) >> TID_SHIFT)
+#define SCSIID_OUR_ID(scsiid)		\
+	((scsiid) & OID)
+#define SCSIID_CHANNEL(ahd, scsiid) ('A')
+#define	SCB_IS_SCSIBUS_B(ahd, scb) (0)
+#define	SCB_GET_OUR_ID(scb) \
+	SCSIID_OUR_ID((scb)->hscb->scsiid)
+#define	SCB_GET_TARGET(ahd, scb) \
+	SCSIID_TARGET((ahd), (scb)->hscb->scsiid)
+#define	SCB_GET_CHANNEL(ahd, scb) \
+	SCSIID_CHANNEL(ahd, (scb)->hscb->scsiid)
+#define	SCB_GET_LUN(scb) \
+	((scb)->hscb->lun)
+#define SCB_GET_TARGET_OFFSET(ahd, scb)	\
+	SCB_GET_TARGET(ahd, scb)
+#define SCB_GET_TARGET_MASK(ahd, scb) \
+	(0x01 << (SCB_GET_TARGET_OFFSET(ahd, scb)))
+#ifdef AHD_DEBUG
+#define SCB_IS_SILENT(scb)					\
+	((ahd_debug & AHD_SHOW_MASKED_ERRORS) == 0		\
+      && (((scb)->flags & SCB_SILENT) != 0))
+#else
+#define SCB_IS_SILENT(scb)					\
+	(((scb)->flags & SCB_SILENT) != 0)
+#endif
+/*
+ * TCLs have the following format: TTTTLLLLLLLL
+ */
+#define TCL_TARGET_OFFSET(tcl) \
+	((((tcl) >> 4) & TID) >> 4)
+#define TCL_LUN(tcl) \
+	(tcl & (AHD_NUM_LUNS - 1))
+#define BUILD_TCL(scsiid, lun) \
+	((lun) | (((scsiid) & TID) << 4))
+#define BUILD_TCL_RAW(target, channel, lun) \
+	((lun) | ((target) << 8))
+
+#define SCB_GET_TAG(scb) \
+	ahd_le16toh(scb->hscb->tag)
+
+#ifndef	AHD_TARGET_MODE
+#undef	AHD_TMODE_ENABLE
+#define	AHD_TMODE_ENABLE 0
+#endif
+
+#define AHD_BUILD_COL_IDX(target, lun)				\
+	(((lun) << 4) | target)
+
+#define AHD_GET_SCB_COL_IDX(ahd, scb)				\
+	((SCB_GET_LUN(scb) << 4) | SCB_GET_TARGET(ahd, scb))
+
+#define AHD_SET_SCB_COL_IDX(scb, col_idx)				\
+do {									\
+	(scb)->hscb->scsiid = ((col_idx) << TID_SHIFT) & TID;		\
+	(scb)->hscb->lun = ((col_idx) >> 4) & (AHD_NUM_LUNS_NONPKT-1);	\
+} while (0)
+
+#define AHD_COPY_SCB_COL_IDX(dst, src)				\
+do {								\
+	dst->hscb->scsiid = src->hscb->scsiid;			\
+	dst->hscb->lun = src->hscb->lun;			\
+} while (0)
+
+#define	AHD_NEVER_COL_IDX 0xFFFF
+
+/**************************** Driver Constants ********************************/
+/*
+ * The maximum number of supported targets.
+ */
+#define AHD_NUM_TARGETS 16
+
+/*
+ * The maximum number of supported luns.
+ * The identify message only supports 64 luns in non-packetized transfers.
+ * You can have 2^64 luns when information unit transfers are enabled,
+ * but until we see a need to support that many, we support 256.
+ */
+#define AHD_NUM_LUNS_NONPKT 64
+#define AHD_NUM_LUNS 256
+
+/*
+ * The maximum transfer per S/G segment.
+ */
+#define AHD_MAXTRANSFER_SIZE	 0x00ffffff	/* limited by 24bit counter */
+
+/*
+ * The maximum amount of SCB storage in hardware on a controller.
+ * This value represents an upper bound.  Due to software design,
+ * we may not be able to use this number.
+ */
+#define AHD_SCB_MAX	512
+
+/*
+ * The maximum number of concurrent transactions supported per driver instance.
+ * Sequencer Control Blocks (SCBs) store per-transaction information.
+ */
+#define AHD_MAX_QUEUE	AHD_SCB_MAX
+
+/*
+ * Define the size of our QIN and QOUT FIFOs.  They must be a power of 2
+ * in size and accommodate as many transactions as can be queued concurrently.
+ */
+#define	AHD_QIN_SIZE	AHD_MAX_QUEUE
+#define	AHD_QOUT_SIZE	AHD_MAX_QUEUE
+
+#define AHD_QIN_WRAP(x) ((x) & (AHD_QIN_SIZE-1))
+/*
+ * The maximum amount of SCB storage we allocate in host memory.
+ */
+#define AHD_SCB_MAX_ALLOC AHD_MAX_QUEUE
+
+/*
+ * Ring Buffer of incoming target commands.
+ * We allocate 256 to simplify the logic in the sequencer
+ * by using the natural wrap point of an 8bit counter.
+ */
+#define AHD_TMODE_CMDS	256
+
+/* Reset line assertion time in us */
+#define AHD_BUSRESET_DELAY	25
+
+/******************* Chip Characteristics/Operating Settings  *****************/
+extern uint32_t ahd_attach_to_HostRAID_controllers;
+
+/*
+ * Chip Type
+ * The chip order is from least sophisticated to most sophisticated.
+ */
+typedef enum {
+	AHD_NONE	= 0x0000,
+	AHD_CHIPID_MASK	= 0x00FF,
+	AHD_AIC7901	= 0x0001,
+	AHD_AIC7902	= 0x0002,
+	AHD_AIC7901A	= 0x0003,
+	AHD_PCI		= 0x0100,	/* Bus type PCI */
+	AHD_PCIX	= 0x0200,	/* Bus type PCIX */
+	AHD_BUS_MASK	= 0x0F00
+} ahd_chip;
+
+/*
+ * Features available in each chip type.
+ */
+typedef enum {
+	AHD_FENONE		= 0x00000,
+	AHD_WIDE  		= 0x00001,/* Wide Channel */
+	AHD_MULTI_FUNC		= 0x00100,/* Multi-Function/Channel Device */
+	AHD_TARGETMODE		= 0x01000,/* Has tested target mode support */
+	AHD_MULTIROLE		= 0x02000,/* Space for two roles at a time */
+	AHD_RTI			= 0x04000,/* Retained Training Support */
+	AHD_NEW_IOCELL_OPTS	= 0x08000,/* More Signal knobs in the IOCELL */
+	AHD_NEW_DFCNTRL_OPTS	= 0x10000,/* SCSIENWRDIS bit */
+	AHD_REMOVABLE		= 0x00000,/* Hot-Swap supported - None so far*/
+	AHD_AIC7901_FE		= AHD_FENONE,
+	AHD_AIC7902_FE		= AHD_MULTI_FUNC
+} ahd_feature;
+
+/*
+ * Bugs in the silicon that we work around in software.
+ */
+typedef enum {
+	AHD_BUGNONE		= 0x0000,
+	/*
+	 * Rev A hardware fails to update LAST/CURR/NEXTSCB
+	 * correctly in certain packetized selection cases.
+	 */
+	AHD_SENT_SCB_UPDATE_BUG	= 0x0001,
+	/* The wrong SCB is accessed to check the abort pending bit. */
+	AHD_ABORT_LQI_BUG	= 0x0002,
+	/* Packetized bitbucket crosses packet boundaries. */
+	AHD_PKT_BITBUCKET_BUG	= 0x0004,
+	/* The selection timer runs twice as long as its setting. */
+	AHD_LONG_SETIMO_BUG	= 0x0008,
+	/* The Non-LQ CRC error status is delayed until phase change. */
+	AHD_NLQICRC_DELAYED_BUG	= 0x0010,
+	/* The chip must be reset for all outgoing bus resets.  */
+	AHD_SCSIRST_BUG		= 0x0020,
+	/* Some PCIX fields must be saved and restored across chip reset. */
+	AHD_PCIX_CHIPRST_BUG	= 0x0040,
+	/* MMAPIO is not functional in PCI-X mode.  */
+	AHD_PCIX_MMAPIO_BUG	= 0x0080,
+	/* Reads to SCBRAM fail to reset the discard timer. */
+	AHD_PCIX_SCBRAM_RD_BUG  = 0x0100,
+	/* Bug workarounds that can be disabled on non-PCIX busses. */
+	AHD_PCIX_BUG_MASK	= AHD_PCIX_CHIPRST_BUG
+				| AHD_PCIX_MMAPIO_BUG
+				| AHD_PCIX_SCBRAM_RD_BUG,
+	/*
+	 * LQOSTOP0 status set even for forced selections with ATN
+	 * to perform non-packetized message delivery.
+	 */
+	AHD_LQO_ATNO_BUG	= 0x0200,
+	/* FIFO auto-flush does not always trigger.  */
+	AHD_AUTOFLUSH_BUG	= 0x0400,
+	/* The CLRLQO registers are not self-clearing. */
+	AHD_CLRLQO_AUTOCLR_BUG	= 0x0800,
+	/* The PACKETIZED status bit refers to the previous connection. */
+	AHD_PKTIZED_STATUS_BUG  = 0x1000,
+	/* "Short Luns" are not placed into outgoing LQ packets correctly. */
+	AHD_PKT_LUN_BUG		= 0x2000,
+	/*
+	 * Only the FIFO allocated to the non-packetized connection may
+	 * be in use during a non-packetzied connection.
+	 */
+	AHD_NONPACKFIFO_BUG	= 0x4000,
+	/*
+	 * Writing to a DFF SCBPTR register may fail if concurent with
+	 * a hardware write to the other DFF SCBPTR register.  This is
+	 * not currently a concern in our sequencer since all chips with
+	 * this bug have the AHD_NONPACKFIFO_BUG and all writes of concern
+	 * occur in non-packetized connections.
+	 */
+	AHD_MDFF_WSCBPTR_BUG	= 0x8000,
+	/* SGHADDR updates are slow. */
+	AHD_REG_SLOW_SETTLE_BUG	= 0x10000,
+	/*
+	 * Changing the MODE_PTR coincident with an interrupt that
+	 * switches to a different mode will cause the interrupt to
+	 * be in the mode written outside of interrupt context.
+	 */
+	AHD_SET_MODE_BUG	= 0x20000,
+	/* Non-packetized busfree revision does not work. */
+	AHD_BUSFREEREV_BUG	= 0x40000,
+	/*
+	 * Paced transfers are indicated with a non-standard PPR
+	 * option bit in the neg table, 160MHz is indicated by
+	 * sync factor 0x7, and the offset if off by a factor of 2.
+	 */
+	AHD_PACED_NEGTABLE_BUG	= 0x80000,
+	/* LQOOVERRUN false positives. */
+	AHD_LQOOVERRUN_BUG	= 0x100000,
+	/*
+	 * Controller write to INTSTAT will lose to a host
+	 * write to CLRINT.
+	 */
+	AHD_INTCOLLISION_BUG	= 0x200000,
+	/*
+	 * The GEM318 violates the SCSI spec by not waiting
+	 * the mandated bus settle delay between phase changes
+	 * in some situations.  Some aic79xx chip revs. are more
+	 * strict in this regard and will treat REQ assertions
+	 * that fall within the bus settle delay window as
+	 * glitches.  This flag tells the firmware to tolerate
+	 * early REQ assertions.
+	 */
+	AHD_EARLY_REQ_BUG	= 0x400000,
+	/*
+	 * The LED does not stay on long enough in packetized modes.
+	 */
+	AHD_FAINT_LED_BUG	= 0x800000
+} ahd_bug;
+
+/*
+ * Configuration specific settings.
+ * The driver determines these settings by probing the
+ * chip/controller's configuration.
+ */
+typedef enum {
+	AHD_FNONE	      = 0x00000,
+	AHD_BOOT_CHANNEL      = 0x00001,/* We were set as the boot channel. */
+	AHD_USEDEFAULTS	      = 0x00004,/*
+					 * For cards without an seeprom
+					 * or a BIOS to initialize the chip's
+					 * SRAM, we use the default target
+					 * settings.
+					 */
+	AHD_SEQUENCER_DEBUG   = 0x00008,
+	AHD_RESET_BUS_A	      = 0x00010,
+	AHD_EXTENDED_TRANS_A  = 0x00020,
+	AHD_TERM_ENB_A	      = 0x00040,
+	AHD_SPCHK_ENB_A	      = 0x00080,
+	AHD_STPWLEVEL_A	      = 0x00100,
+	AHD_INITIATORROLE     = 0x00200,/*
+					 * Allow initiator operations on
+					 * this controller.
+					 */
+	AHD_TARGETROLE	      = 0x00400,/*
+					 * Allow target operations on this
+					 * controller.
+					 */
+	AHD_RESOURCE_SHORTAGE = 0x00800,
+	AHD_TQINFIFO_BLOCKED  = 0x01000,/* Blocked waiting for ATIOs */
+	AHD_INT50_SPEEDFLEX   = 0x02000,/*
+					 * Internal 50pin connector
+					 * sits behind an aic3860
+					 */
+	AHD_BIOS_ENABLED      = 0x04000,
+	AHD_ALL_INTERRUPTS    = 0x08000,
+	AHD_39BIT_ADDRESSING  = 0x10000,/* Use 39 bit addressing scheme. */
+	AHD_64BIT_ADDRESSING  = 0x20000,/* Use 64 bit addressing scheme. */
+	AHD_CURRENT_SENSING   = 0x40000,
+	AHD_SCB_CONFIG_USED   = 0x80000,/* No SEEPROM but SCB had info. */
+	AHD_HP_BOARD	      = 0x100000,
+	AHD_RESET_POLL_ACTIVE = 0x200000,
+	AHD_UPDATE_PEND_CMDS  = 0x400000,
+	AHD_RUNNING_QOUTFIFO  = 0x800000,
+	AHD_HOSTRAID_BOARD    = 0x1000000
+} ahd_flag;
+
+/************************* Hardware  SCB Definition ***************************/
+
+/*
+ * The driver keeps up to MAX_SCB scb structures per card in memory.  The SCB
+ * consists of a "hardware SCB" mirroring the fields available on the card
+ * and additional information the kernel stores for each transaction.
+ *
+ * To minimize space utilization, a portion of the hardware scb stores
+ * different data during different portions of a SCSI transaction.
+ * As initialized by the host driver for the initiator role, this area
+ * contains the SCSI cdb (or a pointer to the  cdb) to be executed.  After
+ * the cdb has been presented to the target, this area serves to store
+ * residual transfer information and the SCSI status byte.
+ * For the target role, the contents of this area do not change, but
+ * still serve a different purpose than for the initiator role.  See
+ * struct target_data for details.
+ */
+
+/*
+ * Status information embedded in the shared poriton of
+ * an SCB after passing the cdb to the target.  The kernel
+ * driver will only read this data for transactions that
+ * complete abnormally.
+ */
+struct initiator_status {
+	uint32_t residual_datacnt;	/* Residual in the current S/G seg */
+	uint32_t residual_sgptr;	/* The next S/G for this transfer */
+	uint8_t	 scsi_status;		/* Standard SCSI status byte */
+};
+
+struct target_status {
+	uint32_t residual_datacnt;	/* Residual in the current S/G seg */
+	uint32_t residual_sgptr;	/* The next S/G for this transfer */
+	uint8_t  scsi_status;		/* SCSI status to give to initiator */
+	uint8_t  target_phases;		/* Bitmap of phases to execute */
+	uint8_t  data_phase;		/* Data-In or Data-Out */
+	uint8_t  initiator_tag;		/* Initiator's transaction tag */
+};
+
+/*
+ * Initiator mode SCB shared data area.
+ * If the embedded CDB is 12 bytes or less, we embed
+ * the sense buffer address in the SCB.  This allows
+ * us to retrieve sense information without interrupting
+ * the host in packetized mode.
+ */
+typedef uint32_t sense_addr_t;
+#define MAX_CDB_LEN 16
+#define MAX_CDB_LEN_WITH_SENSE_ADDR (MAX_CDB_LEN - sizeof(sense_addr_t))
+union initiator_data {
+	struct {
+		uint64_t cdbptr;
+		uint8_t  cdblen;
+	} cdb_from_host;
+	uint8_t	 cdb[MAX_CDB_LEN];
+	struct {
+		uint8_t	 cdb[MAX_CDB_LEN_WITH_SENSE_ADDR];
+		sense_addr_t sense_addr;
+	} cdb_plus_saddr;
+};
+
+/*
+ * Target mode version of the shared data SCB segment.
+ */
+struct target_data {
+	uint32_t spare[2];	
+	uint8_t  scsi_status;		/* SCSI status to give to initiator */
+	uint8_t  target_phases;		/* Bitmap of phases to execute */
+	uint8_t  data_phase;		/* Data-In or Data-Out */
+	uint8_t  initiator_tag;		/* Initiator's transaction tag */
+};
+
+struct hardware_scb {
+/*0*/	union {
+		union	initiator_data idata;
+		struct	target_data tdata;
+		struct	initiator_status istatus;
+		struct	target_status tstatus;
+	} shared_data;
+/*
+ * A word about residuals.
+ * The scb is presented to the sequencer with the dataptr and datacnt
+ * fields initialized to the contents of the first S/G element to
+ * transfer.  The sgptr field is initialized to the bus address for
+ * the S/G element that follows the first in the in core S/G array
+ * or'ed with the SG_FULL_RESID flag.  Sgptr may point to an invalid
+ * S/G entry for this transfer (single S/G element transfer with the
+ * first elements address and length preloaded in the dataptr/datacnt
+ * fields).  If no transfer is to occur, sgptr is set to SG_LIST_NULL.
+ * The SG_FULL_RESID flag ensures that the residual will be correctly
+ * noted even if no data transfers occur.  Once the data phase is entered,
+ * the residual sgptr and datacnt are loaded from the sgptr and the
+ * datacnt fields.  After each S/G element's dataptr and length are
+ * loaded into the hardware, the residual sgptr is advanced.  After
+ * each S/G element is expired, its datacnt field is checked to see
+ * if the LAST_SEG flag is set.  If so, SG_LIST_NULL is set in the
+ * residual sg ptr and the transfer is considered complete.  If the
+ * sequencer determines that there is a residual in the tranfer, or
+ * there is non-zero status, it will set the SG_STATUS_VALID flag in
+ * sgptr and dma the scb back into host memory.  To sumarize:
+ *
+ * Sequencer:
+ *	o A residual has occurred if SG_FULL_RESID is set in sgptr,
+ *	  or residual_sgptr does not have SG_LIST_NULL set.
+ *
+ *	o We are transfering the last segment if residual_datacnt has
+ *	  the SG_LAST_SEG flag set.
+ *
+ * Host:
+ *	o A residual can only have occurred if a completed scb has the
+ *	  SG_STATUS_VALID flag set.  Inspection of the SCSI status field,
+ *	  the residual_datacnt, and the residual_sgptr field will tell
+ *	  for sure.
+ *
+ *	o residual_sgptr and sgptr refer to the "next" sg entry
+ *	  and so may point beyond the last valid sg entry for the
+ *	  transfer.
+ */ 
+#define SG_PTR_MASK	0xFFFFFFF8
+/*16*/	uint16_t tag;		/* Reused by Sequencer. */
+/*18*/	uint8_t  control;	/* See SCB_CONTROL in aic79xx.reg for details */
+/*19*/	uint8_t	 scsiid;	/*
+				 * Selection out Id
+				 * Our Id (bits 0-3) Their ID (bits 4-7)
+				 */
+/*20*/	uint8_t  lun;
+/*21*/	uint8_t  task_attribute;
+/*22*/	uint8_t  cdb_len;
+/*23*/	uint8_t  task_management;
+/*24*/	uint64_t dataptr;
+/*32*/	uint32_t datacnt;	/* Byte 3 is spare. */
+/*36*/	uint32_t sgptr;
+/*40*/	uint32_t hscb_busaddr;
+/*44*/	uint32_t next_hscb_busaddr;
+/********** Long lun field only downloaded for full 8 byte lun support ********/
+/*48*/  uint8_t	 pkt_long_lun[8];
+/******* Fields below are not Downloaded (Sequencer may use for scratch) ******/
+/*56*/  uint8_t	 spare[8];
+};
+
+/************************ Kernel SCB Definitions ******************************/
+/*
+ * Some fields of the SCB are OS dependent.  Here we collect the
+ * definitions for elements that all OS platforms need to include
+ * in there SCB definition.
+ */
+
+/*
+ * Definition of a scatter/gather element as transfered to the controller.
+ * The aic7xxx chips only support a 24bit length.  We use the top byte of
+ * the length to store additional address bits and a flag to indicate
+ * that a given segment terminates the transfer.  This gives us an
+ * addressable range of 512GB on machines with 64bit PCI or with chips
+ * that can support dual address cycles on 32bit PCI busses.
+ */
+struct ahd_dma_seg {
+	uint32_t	addr;
+	uint32_t	len;
+#define	AHD_DMA_LAST_SEG	0x80000000
+#define	AHD_SG_HIGH_ADDR_MASK	0x7F000000
+#define	AHD_SG_LEN_MASK		0x00FFFFFF
+};
+
+struct ahd_dma64_seg {
+	uint64_t	addr;
+	uint32_t	len;
+	uint32_t	pad;
+};
+
+struct map_node {
+	bus_dmamap_t		 dmamap;
+	bus_addr_t		 physaddr;
+	uint8_t			*vaddr;
+	SLIST_ENTRY(map_node)	 links;
+};
+
+/*
+ * The current state of this SCB.
+ */
+typedef enum {
+	SCB_FLAG_NONE		= 0x00000,
+	SCB_TRANSMISSION_ERROR	= 0x00001,/*
+					   * We detected a parity or CRC
+					   * error that has effected the
+					   * payload of the command.  This
+					   * flag is checked when normal
+					   * status is returned to catch
+					   * the case of a target not
+					   * responding to our attempt
+					   * to report the error.
+					   */
+	SCB_OTHERTCL_TIMEOUT	= 0x00002,/*
+					   * Another device was active
+					   * during the first timeout for
+					   * this SCB so we gave ourselves
+					   * an additional timeout period
+					   * in case it was hogging the
+					   * bus.
+				           */
+	SCB_DEVICE_RESET	= 0x00004,
+	SCB_SENSE		= 0x00008,
+	SCB_CDB32_PTR		= 0x00010,
+	SCB_RECOVERY_SCB	= 0x00020,
+	SCB_AUTO_NEGOTIATE	= 0x00040,/* Negotiate to achieve goal. */
+	SCB_NEGOTIATE		= 0x00080,/* Negotiation forced for command. */
+	SCB_ABORT		= 0x00100,
+	SCB_ACTIVE		= 0x00200,
+	SCB_TARGET_IMMEDIATE	= 0x00400,
+	SCB_PACKETIZED		= 0x00800,
+	SCB_EXPECT_PPR_BUSFREE	= 0x01000,
+	SCB_PKT_SENSE		= 0x02000,
+	SCB_CMDPHASE_ABORT	= 0x04000,
+	SCB_ON_COL_LIST		= 0x08000,
+	SCB_SILENT		= 0x10000 /*
+					   * Be quiet about transmission type
+					   * errors.  They are expected and we
+					   * don't want to upset the user.  This
+					   * flag is typically used during DV.
+					   */
+} scb_flag;
+
+struct scb {
+	struct	hardware_scb	 *hscb;
+	union {
+		SLIST_ENTRY(scb)  sle;
+		LIST_ENTRY(scb)	  le;
+		TAILQ_ENTRY(scb)  tqe;
+	} links;
+	union {
+		SLIST_ENTRY(scb)  sle;
+		LIST_ENTRY(scb)	  le;
+		TAILQ_ENTRY(scb)  tqe;
+	} links2;
+#define pending_links links2.le
+#define collision_links links2.le
+	struct scb		 *col_scb;
+	ahd_io_ctx_t		  io_ctx;
+	struct ahd_softc	 *ahd_softc;
+	scb_flag		  flags;
+#ifndef __linux__
+	bus_dmamap_t		  dmamap;
+#endif
+	struct scb_platform_data *platform_data;
+	struct map_node	 	 *hscb_map;
+	struct map_node	 	 *sg_map;
+	struct map_node	 	 *sense_map;
+	void			 *sg_list;
+	uint8_t			 *sense_data;
+	bus_addr_t		  sg_list_busaddr;
+	bus_addr_t		  sense_busaddr;
+	u_int			  sg_count;/* How full ahd_dma_seg is */
+#define	AHD_MAX_LQ_CRC_ERRORS 5
+	u_int			  crc_retry_count;
+};
+
+TAILQ_HEAD(scb_tailq, scb);
+LIST_HEAD(scb_list, scb);
+
+struct scb_data {
+	/*
+	 * TAILQ of lists of free SCBs grouped by device
+	 * collision domains.
+	 */
+	struct scb_tailq free_scbs;
+
+	/*
+	 * Per-device lists of SCBs whose tag ID would collide
+	 * with an already active tag on the device.
+	 */
+	struct scb_list free_scb_lists[AHD_NUM_TARGETS * AHD_NUM_LUNS_NONPKT];
+
+	/*
+	 * SCBs that will not collide with any active device.
+	 */
+	struct scb_list any_dev_free_scb_list;
+
+	/*
+	 * Mapping from tag to SCB.
+	 */
+	struct	scb *scbindex[AHD_SCB_MAX];
+
+	/*
+	 * "Bus" addresses of our data structures.
+	 */
+	bus_dma_tag_t	 hscb_dmat;	/* dmat for our hardware SCB array */
+	bus_dma_tag_t	 sg_dmat;	/* dmat for our sg segments */
+	bus_dma_tag_t	 sense_dmat;	/* dmat for our sense buffers */
+	SLIST_HEAD(, map_node) hscb_maps;
+	SLIST_HEAD(, map_node) sg_maps;
+	SLIST_HEAD(, map_node) sense_maps;
+	int		 scbs_left;	/* unallocated scbs in head map_node */
+	int		 sgs_left;	/* unallocated sgs in head map_node */
+	int		 sense_left;	/* unallocated sense in head map_node */
+	uint16_t	 numscbs;
+	uint16_t	 maxhscbs;	/* Number of SCBs on the card */
+	uint8_t		 init_level;	/*
+					 * How far we've initialized
+					 * this structure.
+					 */
+};
+
+/************************ Target Mode Definitions *****************************/
+
+/*
+ * Connection desciptor for select-in requests in target mode.
+ */
+struct target_cmd {
+	uint8_t scsiid;		/* Our ID and the initiator's ID */
+	uint8_t identify;	/* Identify message */
+	uint8_t bytes[22];	/* 
+				 * Bytes contains any additional message
+				 * bytes terminated by 0xFF.  The remainder
+				 * is the cdb to execute.
+				 */
+	uint8_t cmd_valid;	/*
+				 * When a command is complete, the firmware
+				 * will set cmd_valid to all bits set.
+				 * After the host has seen the command,
+				 * the bits are cleared.  This allows us
+				 * to just peek at host memory to determine
+				 * if more work is complete. cmd_valid is on
+				 * an 8 byte boundary to simplify setting
+				 * it on aic7880 hardware which only has
+				 * limited direct access to the DMA FIFO.
+				 */
+	uint8_t pad[7];
+};
+
+/*
+ * Number of events we can buffer up if we run out
+ * of immediate notify ccbs.
+ */
+#define AHD_TMODE_EVENT_BUFFER_SIZE 8
+struct ahd_tmode_event {
+	uint8_t initiator_id;
+	uint8_t event_type;	/* MSG type or EVENT_TYPE_BUS_RESET */
+#define	EVENT_TYPE_BUS_RESET 0xFF
+	uint8_t event_arg;
+};
+
+/*
+ * Per enabled lun target mode state.
+ * As this state is directly influenced by the host OS'es target mode
+ * environment, we let the OS module define it.  Forward declare the
+ * structure here so we can store arrays of them, etc. in OS neutral
+ * data structures.
+ */
+#ifdef AHD_TARGET_MODE 
+struct ahd_tmode_lstate {
+	struct cam_path *path;
+	struct ccb_hdr_slist accept_tios;
+	struct ccb_hdr_slist immed_notifies;
+	struct ahd_tmode_event event_buffer[AHD_TMODE_EVENT_BUFFER_SIZE];
+	uint8_t event_r_idx;
+	uint8_t event_w_idx;
+};
+#else
+struct ahd_tmode_lstate;
+#endif
+
+/******************** Transfer Negotiation Datastructures *********************/
+#define AHD_TRANS_CUR		0x01	/* Modify current neogtiation status */
+#define AHD_TRANS_ACTIVE	0x03	/* Assume this target is on the bus */
+#define AHD_TRANS_GOAL		0x04	/* Modify negotiation goal */
+#define AHD_TRANS_USER		0x08	/* Modify user negotiation settings */
+#define AHD_PERIOD_10MHz	0x19
+
+#define AHD_WIDTH_UNKNOWN	0xFF
+#define AHD_PERIOD_UNKNOWN	0xFF
+#define AHD_OFFSET_UNKNOWN	0xFF
+#define AHD_PPR_OPTS_UNKNOWN	0xFF
+
+/*
+ * Transfer Negotiation Information.
+ */
+struct ahd_transinfo {
+	uint8_t protocol_version;	/* SCSI Revision level */
+	uint8_t transport_version;	/* SPI Revision level */
+	uint8_t width;			/* Bus width */
+	uint8_t period;			/* Sync rate factor */
+	uint8_t offset;			/* Sync offset */
+	uint8_t ppr_options;		/* Parallel Protocol Request options */
+};
+
+/*
+ * Per-initiator current, goal and user transfer negotiation information. */
+struct ahd_initiator_tinfo {
+	struct ahd_transinfo curr;
+	struct ahd_transinfo goal;
+	struct ahd_transinfo user;
+};
+
+/*
+ * Per enabled target ID state.
+ * Pointers to lun target state as well as sync/wide negotiation information
+ * for each initiator<->target mapping.  For the initiator role we pretend
+ * that we are the target and the targets are the initiators since the
+ * negotiation is the same regardless of role.
+ */
+struct ahd_tmode_tstate {
+	struct ahd_tmode_lstate*	enabled_luns[AHD_NUM_LUNS];
+	struct ahd_initiator_tinfo	transinfo[AHD_NUM_TARGETS];
+
+	/*
+	 * Per initiator state bitmasks.
+	 */
+	uint16_t	 auto_negotiate;/* Auto Negotiation Required */
+	uint16_t	 discenable;	/* Disconnection allowed  */
+	uint16_t	 tagenable;	/* Tagged Queuing allowed */
+};
+
+/*
+ * Points of interest along the negotiated transfer scale.
+ */
+#define AHD_SYNCRATE_160	0x8
+#define AHD_SYNCRATE_PACED	0x8
+#define AHD_SYNCRATE_DT		0x9
+#define AHD_SYNCRATE_ULTRA2	0xa
+#define AHD_SYNCRATE_ULTRA	0xc
+#define AHD_SYNCRATE_FAST	0x19
+#define AHD_SYNCRATE_MIN_DT	AHD_SYNCRATE_FAST
+#define AHD_SYNCRATE_SYNC	0x32
+#define AHD_SYNCRATE_MIN	0x60
+#define	AHD_SYNCRATE_ASYNC	0xFF
+#define AHD_SYNCRATE_MAX	AHD_SYNCRATE_160
+
+/* Safe and valid period for async negotiations. */
+#define	AHD_ASYNC_XFER_PERIOD	0x44
+
+/*
+ * In RevA, the synctable uses a 120MHz rate for the period
+ * factor 8 and 160MHz for the period factor 7.  The 120MHz
+ * rate never made it into the official SCSI spec, so we must
+ * compensate when setting the negotiation table for Rev A
+ * parts.
+ */
+#define AHD_SYNCRATE_REVA_120	0x8
+#define AHD_SYNCRATE_REVA_160	0x7
+
+/***************************** Lookup Tables **********************************/
+/*
+ * Phase -> name and message out response
+ * to parity errors in each phase table. 
+ */
+struct ahd_phase_table_entry {
+        uint8_t phase;
+        uint8_t mesg_out; /* Message response to parity errors */
+	char *phasemsg;
+};
+
+/************************** Serial EEPROM Format ******************************/
+
+struct seeprom_config {
+/*
+ * Per SCSI ID Configuration Flags
+ */
+	uint16_t device_flags[16];	/* words 0-15 */
+#define		CFXFER		0x003F	/* synchronous transfer rate */
+#define			CFXFER_ASYNC	0x3F
+#define		CFQAS		0x0040	/* Negotiate QAS */
+#define		CFPACKETIZED	0x0080	/* Negotiate Packetized Transfers */
+#define		CFSTART		0x0100	/* send start unit SCSI command */
+#define		CFINCBIOS	0x0200	/* include in BIOS scan */
+#define		CFDISC		0x0400	/* enable disconnection */
+#define		CFMULTILUNDEV	0x0800	/* Probe multiple luns in BIOS scan */
+#define		CFWIDEB		0x1000	/* wide bus device */
+#define		CFHOSTMANAGED	0x8000	/* Managed by a RAID controller */
+
+/*
+ * BIOS Control Bits
+ */
+	uint16_t bios_control;		/* word 16 */
+#define		CFSUPREM	0x0001	/* support all removeable drives */
+#define		CFSUPREMB	0x0002	/* support removeable boot drives */
+#define		CFBIOSSTATE	0x000C	/* BIOS Action State */
+#define		    CFBS_DISABLED	0x00
+#define		    CFBS_ENABLED	0x04
+#define		    CFBS_DISABLED_SCAN	0x08
+#define		CFENABLEDV	0x0010	/* Perform Domain Validation */
+#define		CFCTRL_A	0x0020	/* BIOS displays Ctrl-A message */	
+#define		CFSPARITY	0x0040	/* SCSI parity */
+#define		CFEXTEND	0x0080	/* extended translation enabled */
+#define		CFBOOTCD	0x0100  /* Support Bootable CD-ROM */
+#define		CFMSG_LEVEL	0x0600	/* BIOS Message Level */
+#define			CFMSG_VERBOSE	0x0000
+#define			CFMSG_SILENT	0x0200
+#define			CFMSG_DIAG	0x0400
+#define		CFRESETB	0x0800	/* reset SCSI bus at boot */
+/*		UNUSED		0xf000	*/
+
+/*
+ * Host Adapter Control Bits
+ */
+	uint16_t adapter_control;	/* word 17 */	
+#define		CFAUTOTERM	0x0001	/* Perform Auto termination */
+#define		CFSTERM		0x0002	/* SCSI low byte termination */
+#define		CFWSTERM	0x0004	/* SCSI high byte termination */
+#define		CFSEAUTOTERM	0x0008	/* Ultra2 Perform secondary Auto Term*/
+#define		CFSELOWTERM	0x0010	/* Ultra2 secondary low term */
+#define		CFSEHIGHTERM	0x0020	/* Ultra2 secondary high term */
+#define		CFSTPWLEVEL	0x0040	/* Termination level control */
+#define		CFBIOSAUTOTERM	0x0080	/* Perform Auto termination */
+#define		CFTERM_MENU	0x0100	/* BIOS displays termination menu */	
+#define		CFCLUSTERENB	0x8000	/* Cluster Enable */
+
+/*
+ * Bus Release Time, Host Adapter ID
+ */
+	uint16_t brtime_id;		/* word 18 */
+#define		CFSCSIID	0x000f	/* host adapter SCSI ID */
+/*		UNUSED		0x00f0	*/
+#define		CFBRTIME	0xff00	/* bus release time/PCI Latency Time */
+
+/*
+ * Maximum targets
+ */
+	uint16_t max_targets;		/* word 19 */	
+#define		CFMAXTARG	0x00ff	/* maximum targets */
+#define		CFBOOTLUN	0x0f00	/* Lun to boot from */
+#define		CFBOOTID	0xf000	/* Target to boot from */
+	uint16_t res_1[10];		/* words 20-29 */
+	uint16_t signature;		/* BIOS Signature */
+#define		CFSIGNATURE	0x400
+	uint16_t checksum;		/* word 31 */
+};
+
+/*
+ * Vital Product Data used during POST and by the BIOS.
+ */
+struct vpd_config {
+	uint8_t  bios_flags;
+#define		VPDMASTERBIOS	0x0001
+#define		VPDBOOTHOST	0x0002
+	uint8_t  reserved_1[21];
+	uint8_t  resource_type;
+	uint8_t  resource_len[2];
+	uint8_t  resource_data[8];
+	uint8_t  vpd_tag;
+	uint16_t vpd_len;
+	uint8_t  vpd_keyword[2];
+	uint8_t  length;
+	uint8_t  revision;
+	uint8_t  device_flags;
+	uint8_t  termnation_menus[2];
+	uint8_t  fifo_threshold;
+	uint8_t  end_tag;
+	uint8_t  vpd_checksum;
+	uint16_t default_target_flags;
+	uint16_t default_bios_flags;
+	uint16_t default_ctrl_flags;
+	uint8_t  default_irq;
+	uint8_t  pci_lattime;
+	uint8_t  max_target;
+	uint8_t  boot_lun;
+	uint16_t signature;
+	uint8_t  reserved_2;
+	uint8_t  checksum;
+	uint8_t	 reserved_3[4];
+};
+
+/****************************** Flexport Logic ********************************/
+#define FLXADDR_TERMCTL			0x0
+#define		FLX_TERMCTL_ENSECHIGH	0x8
+#define		FLX_TERMCTL_ENSECLOW	0x4
+#define		FLX_TERMCTL_ENPRIHIGH	0x2
+#define		FLX_TERMCTL_ENPRILOW	0x1
+#define FLXADDR_ROMSTAT_CURSENSECTL	0x1
+#define		FLX_ROMSTAT_SEECFG	0xF0
+#define		FLX_ROMSTAT_EECFG	0x0F
+#define		FLX_ROMSTAT_SEE_93C66	0x00
+#define		FLX_ROMSTAT_SEE_NONE	0xF0
+#define		FLX_ROMSTAT_EE_512x8	0x0
+#define		FLX_ROMSTAT_EE_1MBx8	0x1
+#define		FLX_ROMSTAT_EE_2MBx8	0x2
+#define		FLX_ROMSTAT_EE_4MBx8	0x3
+#define		FLX_ROMSTAT_EE_16MBx8	0x4
+#define 		CURSENSE_ENB	0x1
+#define	FLXADDR_FLEXSTAT		0x2
+#define		FLX_FSTAT_BUSY		0x1
+#define FLXADDR_CURRENT_STAT		0x4
+#define		FLX_CSTAT_SEC_HIGH	0xC0
+#define		FLX_CSTAT_SEC_LOW	0x30
+#define		FLX_CSTAT_PRI_HIGH	0x0C
+#define		FLX_CSTAT_PRI_LOW	0x03
+#define		FLX_CSTAT_MASK		0x03
+#define		FLX_CSTAT_SHIFT		2
+#define		FLX_CSTAT_OKAY		0x0
+#define		FLX_CSTAT_OVER		0x1
+#define		FLX_CSTAT_UNDER		0x2
+#define		FLX_CSTAT_INVALID	0x3
+
+int		ahd_read_seeprom(struct ahd_softc *ahd, uint16_t *buf,
+				 u_int start_addr, u_int count, int bstream);
+
+int		ahd_write_seeprom(struct ahd_softc *ahd, uint16_t *buf,
+				  u_int start_addr, u_int count);
+int		ahd_wait_seeprom(struct ahd_softc *ahd);
+int		ahd_verify_vpd_cksum(struct vpd_config *vpd);
+int		ahd_verify_cksum(struct seeprom_config *sc);
+int		ahd_acquire_seeprom(struct ahd_softc *ahd);
+void		ahd_release_seeprom(struct ahd_softc *ahd);
+
+/****************************  Message Buffer *********************************/
+typedef enum {
+	MSG_FLAG_NONE			= 0x00,
+	MSG_FLAG_EXPECT_PPR_BUSFREE	= 0x01,
+	MSG_FLAG_IU_REQ_CHANGED		= 0x02,
+	MSG_FLAG_EXPECT_IDE_BUSFREE	= 0x04,
+	MSG_FLAG_EXPECT_QASREJ_BUSFREE	= 0x08,
+	MSG_FLAG_PACKETIZED		= 0x10
+} ahd_msg_flags;
+
+typedef enum {
+	MSG_TYPE_NONE			= 0x00,
+	MSG_TYPE_INITIATOR_MSGOUT	= 0x01,
+	MSG_TYPE_INITIATOR_MSGIN	= 0x02,
+	MSG_TYPE_TARGET_MSGOUT		= 0x03,
+	MSG_TYPE_TARGET_MSGIN		= 0x04
+} ahd_msg_type;
+
+typedef enum {
+	MSGLOOP_IN_PROG,
+	MSGLOOP_MSGCOMPLETE,
+	MSGLOOP_TERMINATED
+} msg_loop_stat;
+
+/*********************** Software Configuration Structure *********************/
+struct ahd_suspend_channel_state {
+	uint8_t	scsiseq;
+	uint8_t	sxfrctl0;
+	uint8_t	sxfrctl1;
+	uint8_t	simode0;
+	uint8_t	simode1;
+	uint8_t	seltimer;
+	uint8_t	seqctl;
+};
+
+struct ahd_suspend_state {
+	struct	ahd_suspend_channel_state channel[2];
+	uint8_t	optionmode;
+	uint8_t	dscommand0;
+	uint8_t	dspcistatus;
+	/* hsmailbox */
+	uint8_t	crccontrol1;
+	uint8_t	scbbaddr;
+	/* Host and sequencer SCB counts */
+	uint8_t	dff_thrsh;
+	uint8_t	*scratch_ram;
+	uint8_t	*btt;
+};
+
+typedef void (*ahd_bus_intr_t)(struct ahd_softc *);
+
+typedef enum {
+	AHD_MODE_DFF0,
+	AHD_MODE_DFF1,
+	AHD_MODE_CCHAN,
+	AHD_MODE_SCSI,
+	AHD_MODE_CFG,
+	AHD_MODE_UNKNOWN
+} ahd_mode;
+
+#define AHD_MK_MSK(x) (0x01 << (x))
+#define AHD_MODE_DFF0_MSK	AHD_MK_MSK(AHD_MODE_DFF0)
+#define AHD_MODE_DFF1_MSK	AHD_MK_MSK(AHD_MODE_DFF1)
+#define AHD_MODE_CCHAN_MSK	AHD_MK_MSK(AHD_MODE_CCHAN)
+#define AHD_MODE_SCSI_MSK	AHD_MK_MSK(AHD_MODE_SCSI)
+#define AHD_MODE_CFG_MSK	AHD_MK_MSK(AHD_MODE_CFG)
+#define AHD_MODE_UNKNOWN_MSK	AHD_MK_MSK(AHD_MODE_UNKNOWN)
+#define AHD_MODE_ANY_MSK (~0)
+
+typedef uint8_t ahd_mode_state;
+
+typedef void ahd_callback_t (void *);
+
+struct ahd_softc {
+	bus_space_tag_t           tags[2];
+	bus_space_handle_t        bshs[2];
+#ifndef __linux__
+	bus_dma_tag_t		  buffer_dmat;   /* dmat for buffer I/O */
+#endif
+	struct scb_data		  scb_data;
+
+	struct hardware_scb	 *next_queued_hscb;
+
+	/*
+	 * SCBs that have been sent to the controller
+	 */
+	LIST_HEAD(, scb)	  pending_scbs;
+
+	/*
+	 * Current register window mode information.
+	 */
+	ahd_mode		  dst_mode;
+	ahd_mode		  src_mode;
+
+	/*
+	 * Saved register window mode information
+	 * used for restore on next unpause.
+	 */
+	ahd_mode		  saved_dst_mode;
+	ahd_mode		  saved_src_mode;
+
+	/*
+	 * Platform specific data.
+	 */
+	struct ahd_platform_data *platform_data;
+
+	/*
+	 * Platform specific device information.
+	 */
+	ahd_dev_softc_t		  dev_softc;
+
+	/*
+	 * Bus specific device information.
+	 */
+	ahd_bus_intr_t		  bus_intr;
+
+	/*
+	 * Target mode related state kept on a per enabled lun basis.
+	 * Targets that are not enabled will have null entries.
+	 * As an initiator, we keep one target entry for our initiator
+	 * ID to store our sync/wide transfer settings.
+	 */
+	struct ahd_tmode_tstate  *enabled_targets[AHD_NUM_TARGETS];
+
+	/*
+	 * The black hole device responsible for handling requests for
+	 * disabled luns on enabled targets.
+	 */
+	struct ahd_tmode_lstate  *black_hole;
+
+	/*
+	 * Device instance currently on the bus awaiting a continue TIO
+	 * for a command that was not given the disconnect priveledge.
+	 */
+	struct ahd_tmode_lstate  *pending_device;
+
+	/*
+	 * Timer handles for timer driven callbacks.
+	 */
+	ahd_timer_t		  reset_timer;
+	ahd_timer_t		  stat_timer;
+
+	/*
+	 * Statistics.
+	 */
+#define	AHD_STAT_UPDATE_US	250000 /* 250ms */
+#define	AHD_STAT_BUCKETS	4
+	u_int			  cmdcmplt_bucket;
+	uint32_t		  cmdcmplt_counts[AHD_STAT_BUCKETS];
+	uint32_t		  cmdcmplt_total;
+
+	/*
+	 * Card characteristics
+	 */
+	ahd_chip		  chip;
+	ahd_feature		  features;
+	ahd_bug			  bugs;
+	ahd_flag		  flags;
+	struct seeprom_config	 *seep_config;
+
+	/* Values to store in the SEQCTL register for pause and unpause */
+	uint8_t			  unpause;
+	uint8_t			  pause;
+
+	/* Command Queues */
+	uint16_t		  qoutfifonext;
+	uint16_t		  qoutfifonext_valid_tag;
+	uint16_t		  qinfifonext;
+	uint16_t		  qinfifo[AHD_SCB_MAX];
+	uint16_t		 *qoutfifo;
+
+	/* Critical Section Data */
+	struct cs		 *critical_sections;
+	u_int			  num_critical_sections;
+
+	/* Buffer for handling packetized bitbucket. */
+	uint8_t			 *overrun_buf;
+
+	/* Links for chaining softcs */
+	TAILQ_ENTRY(ahd_softc)	  links;
+
+	/* Channel Names ('A', 'B', etc.) */
+	char			  channel;
+
+	/* Initiator Bus ID */
+	uint8_t			  our_id;
+
+	/*
+	 * Target incoming command FIFO.
+	 */
+	struct target_cmd	 *targetcmds;
+	uint8_t			  tqinfifonext;
+
+	/*
+	 * Cached verson of the hs_mailbox so we can avoid
+	 * pausing the sequencer during mailbox updates.
+	 */
+	uint8_t			  hs_mailbox;
+
+	/*
+	 * Incoming and outgoing message handling.
+	 */
+	uint8_t			  send_msg_perror;
+	ahd_msg_flags		  msg_flags;
+	ahd_msg_type		  msg_type;
+	uint8_t			  msgout_buf[12];/* Message we are sending */
+	uint8_t			  msgin_buf[12];/* Message we are receiving */
+	u_int			  msgout_len;	/* Length of message to send */
+	u_int			  msgout_index;	/* Current index in msgout */
+	u_int			  msgin_index;	/* Current index in msgin */
+
+	/*
+	 * Mapping information for data structures shared
+	 * between the sequencer and kernel.
+	 */
+	bus_dma_tag_t		  parent_dmat;
+	bus_dma_tag_t		  shared_data_dmat;
+	bus_dmamap_t		  shared_data_dmamap;
+	bus_addr_t		  shared_data_busaddr;
+
+	/* Information saved through suspend/resume cycles */
+	struct ahd_suspend_state  suspend_state;
+
+	/* Number of enabled target mode device on this card */
+	u_int			  enabled_luns;
+
+	/* Initialization level of this data structure */
+	u_int			  init_level;
+
+	/* PCI cacheline size. */
+	u_int			  pci_cachesize;
+
+	/* IO Cell Parameters */
+	uint8_t			  iocell_opts[AHD_NUM_PER_DEV_ANNEXCOLS];
+
+	u_int			  stack_size;
+	uint16_t		 *saved_stack;
+
+	/* Per-Unit descriptive information */
+	const char		 *description;
+	const char		 *bus_description;
+	char			 *name;
+	int			  unit;
+
+	/* Selection Timer settings */
+	int			  seltime;
+
+	/*
+	 * Interrupt coalescing settings.
+	 */
+#define	AHD_INT_COALESCING_TIMER_DEFAULT		250 /*us*/
+#define	AHD_INT_COALESCING_MAXCMDS_DEFAULT		10
+#define	AHD_INT_COALESCING_MAXCMDS_MAX			127
+#define	AHD_INT_COALESCING_MINCMDS_DEFAULT		5
+#define	AHD_INT_COALESCING_MINCMDS_MAX			127
+#define	AHD_INT_COALESCING_THRESHOLD_DEFAULT		2000
+#define	AHD_INT_COALESCING_STOP_THRESHOLD_DEFAULT	1000
+	u_int			  int_coalescing_timer;
+	u_int			  int_coalescing_maxcmds;
+	u_int			  int_coalescing_mincmds;
+	u_int			  int_coalescing_threshold;
+	u_int			  int_coalescing_stop_threshold;
+
+	uint16_t	 	  user_discenable;/* Disconnection allowed  */
+	uint16_t		  user_tagenable;/* Tagged Queuing allowed */
+};
+
+TAILQ_HEAD(ahd_softc_tailq, ahd_softc);
+extern struct ahd_softc_tailq ahd_tailq;
+
+/*************************** IO Cell Configuration ****************************/
+#define	AHD_PRECOMP_SLEW_INDEX						\
+    (AHD_ANNEXCOL_PRECOMP_SLEW - AHD_ANNEXCOL_PER_DEV0)
+
+#define	AHD_AMPLITUDE_INDEX						\
+    (AHD_ANNEXCOL_AMPLITUDE - AHD_ANNEXCOL_PER_DEV0)
+
+#define AHD_SET_SLEWRATE(ahd, new_slew)					\
+do {									\
+    (ahd)->iocell_opts[AHD_PRECOMP_SLEW_INDEX] &= ~AHD_SLEWRATE_MASK;	\
+    (ahd)->iocell_opts[AHD_PRECOMP_SLEW_INDEX] |=			\
+	(((new_slew) << AHD_SLEWRATE_SHIFT) & AHD_SLEWRATE_MASK);	\
+} while (0)
+
+#define AHD_SET_PRECOMP(ahd, new_pcomp)					\
+do {									\
+    (ahd)->iocell_opts[AHD_PRECOMP_SLEW_INDEX] &= ~AHD_PRECOMP_MASK;	\
+    (ahd)->iocell_opts[AHD_PRECOMP_SLEW_INDEX] |=			\
+	(((new_pcomp) << AHD_PRECOMP_SHIFT) & AHD_PRECOMP_MASK);	\
+} while (0)
+
+#define AHD_SET_AMPLITUDE(ahd, new_amp)					\
+do {									\
+    (ahd)->iocell_opts[AHD_AMPLITUDE_INDEX] &= ~AHD_AMPLITUDE_MASK;	\
+    (ahd)->iocell_opts[AHD_AMPLITUDE_INDEX] |=				\
+	(((new_amp) << AHD_AMPLITUDE_SHIFT) & AHD_AMPLITUDE_MASK);	\
+} while (0)
+
+/************************ Active Device Information ***************************/
+typedef enum {
+	ROLE_UNKNOWN,
+	ROLE_INITIATOR,
+	ROLE_TARGET
+} role_t;
+
+struct ahd_devinfo {
+	int	 our_scsiid;
+	int	 target_offset;
+	uint16_t target_mask;
+	u_int	 target;
+	u_int	 lun;
+	char	 channel;
+	role_t	 role;		/*
+				 * Only guaranteed to be correct if not
+				 * in the busfree state.
+				 */
+};
+
+/****************************** PCI Structures ********************************/
+#define AHD_PCI_IOADDR0	PCIR_MAPS	/* I/O BAR*/
+#define AHD_PCI_MEMADDR	(PCIR_MAPS + 4)	/* Memory BAR */
+#define AHD_PCI_IOADDR1	(PCIR_MAPS + 12)/* Second I/O BAR */
+
+typedef int (ahd_device_setup_t)(struct ahd_softc *);
+
+struct ahd_pci_identity {
+	uint64_t		 full_id;
+	uint64_t		 id_mask;
+	char			*name;
+	ahd_device_setup_t	*setup;
+};
+extern struct ahd_pci_identity ahd_pci_ident_table [];
+extern const u_int ahd_num_pci_devs;
+
+/***************************** VL/EISA Declarations ***************************/
+struct aic7770_identity {
+	uint32_t		 full_id;
+	uint32_t		 id_mask;
+	char			*name;
+	ahd_device_setup_t	*setup;
+};
+extern struct aic7770_identity aic7770_ident_table [];
+extern const int ahd_num_aic7770_devs;
+
+#define AHD_EISA_SLOT_OFFSET	0xc00
+#define AHD_EISA_IOSIZE		0x100
+
+/*************************** Function Declarations ****************************/
+/******************************************************************************/
+void			ahd_reset_cmds_pending(struct ahd_softc *ahd);
+u_int			ahd_find_busy_tcl(struct ahd_softc *ahd, u_int tcl);
+void			ahd_busy_tcl(struct ahd_softc *ahd,
+				     u_int tcl, u_int busyid);
+static __inline void	ahd_unbusy_tcl(struct ahd_softc *ahd, u_int tcl);
+static __inline void
+ahd_unbusy_tcl(struct ahd_softc *ahd, u_int tcl)
+{
+	ahd_busy_tcl(ahd, tcl, SCB_LIST_NULL);
+}
+
+/***************************** PCI Front End *********************************/
+struct	ahd_pci_identity *ahd_find_pci_device(ahd_dev_softc_t);
+int			  ahd_pci_config(struct ahd_softc *,
+					 struct ahd_pci_identity *);
+int	ahd_pci_test_register_access(struct ahd_softc *);
+
+/************************** SCB and SCB queue management **********************/
+int		ahd_probe_scbs(struct ahd_softc *);
+void		ahd_qinfifo_requeue_tail(struct ahd_softc *ahd,
+					 struct scb *scb);
+int		ahd_match_scb(struct ahd_softc *ahd, struct scb *scb,
+			      int target, char channel, int lun,
+			      u_int tag, role_t role);
+
+/****************************** Initialization ********************************/
+struct ahd_softc	*ahd_alloc(void *platform_arg, char *name);
+int			 ahd_softc_init(struct ahd_softc *);
+void			 ahd_controller_info(struct ahd_softc *ahd, char *buf);
+int			 ahd_init(struct ahd_softc *ahd);
+int			 ahd_default_config(struct ahd_softc *ahd);
+int			 ahd_parse_vpddata(struct ahd_softc *ahd,
+					   struct vpd_config *vpd);
+int			 ahd_parse_cfgdata(struct ahd_softc *ahd,
+					   struct seeprom_config *sc);
+void			 ahd_intr_enable(struct ahd_softc *ahd, int enable);
+void			 ahd_update_coalescing_values(struct ahd_softc *ahd,
+						      u_int timer,
+						      u_int maxcmds,
+						      u_int mincmds);
+void			 ahd_enable_coalescing(struct ahd_softc *ahd,
+					       int enable);
+void			 ahd_pause_and_flushwork(struct ahd_softc *ahd);
+int			 ahd_suspend(struct ahd_softc *ahd); 
+int			 ahd_resume(struct ahd_softc *ahd);
+void			 ahd_softc_insert(struct ahd_softc *);
+struct ahd_softc	*ahd_find_softc(struct ahd_softc *ahd);
+void			 ahd_set_unit(struct ahd_softc *, int);
+void			 ahd_set_name(struct ahd_softc *, char *);
+struct scb		*ahd_get_scb(struct ahd_softc *ahd, u_int col_idx);
+void			 ahd_free_scb(struct ahd_softc *ahd, struct scb *scb);
+void			 ahd_alloc_scbs(struct ahd_softc *ahd);
+void			 ahd_free(struct ahd_softc *ahd);
+int			 ahd_reset(struct ahd_softc *ahd, int reinit);
+void			 ahd_shutdown(void *arg);
+int			 ahd_write_flexport(struct ahd_softc *ahd,
+					    u_int addr, u_int value);
+int			 ahd_read_flexport(struct ahd_softc *ahd, u_int addr,
+					   uint8_t *value);
+int			 ahd_wait_flexport(struct ahd_softc *ahd);
+
+/*************************** Interrupt Services *******************************/
+void			ahd_pci_intr(struct ahd_softc *ahd);
+void			ahd_clear_intstat(struct ahd_softc *ahd);
+void			ahd_flush_qoutfifo(struct ahd_softc *ahd);
+void			ahd_run_qoutfifo(struct ahd_softc *ahd);
+#ifdef AHD_TARGET_MODE
+void			ahd_run_tqinfifo(struct ahd_softc *ahd, int paused);
+#endif
+void			ahd_handle_hwerrint(struct ahd_softc *ahd);
+void			ahd_handle_seqint(struct ahd_softc *ahd, u_int intstat);
+void			ahd_handle_scsiint(struct ahd_softc *ahd,
+					   u_int intstat);
+void			ahd_clear_critical_section(struct ahd_softc *ahd);
+
+/***************************** Error Recovery *********************************/
+typedef enum {
+	SEARCH_COMPLETE,
+	SEARCH_COUNT,
+	SEARCH_REMOVE,
+	SEARCH_PRINT
+} ahd_search_action;
+int			ahd_search_qinfifo(struct ahd_softc *ahd, int target,
+					   char channel, int lun, u_int tag,
+					   role_t role, uint32_t status,
+					   ahd_search_action action);
+int			ahd_search_disc_list(struct ahd_softc *ahd, int target,
+					     char channel, int lun, u_int tag,
+					     int stop_on_first, int remove,
+					     int save_state);
+void			ahd_freeze_devq(struct ahd_softc *ahd, struct scb *scb);
+int			ahd_reset_channel(struct ahd_softc *ahd, char channel,
+					  int initiate_reset);
+int			ahd_abort_scbs(struct ahd_softc *ahd, int target,
+				       char channel, int lun, u_int tag,
+				       role_t role, uint32_t status);
+void			ahd_restart(struct ahd_softc *ahd);
+void			ahd_clear_fifo(struct ahd_softc *ahd, u_int fifo);
+void			ahd_handle_scb_status(struct ahd_softc *ahd,
+					      struct scb *scb);
+void			ahd_handle_scsi_status(struct ahd_softc *ahd,
+					       struct scb *scb);
+void			ahd_calc_residual(struct ahd_softc *ahd,
+					  struct scb *scb);
+/*************************** Utility Functions ********************************/
+struct ahd_phase_table_entry*
+			ahd_lookup_phase_entry(int phase);
+void			ahd_compile_devinfo(struct ahd_devinfo *devinfo,
+					    u_int our_id, u_int target,
+					    u_int lun, char channel,
+					    role_t role);
+/************************** Transfer Negotiation ******************************/
+void			ahd_find_syncrate(struct ahd_softc *ahd, u_int *period,
+					  u_int *ppr_options, u_int maxsync);
+void			ahd_validate_offset(struct ahd_softc *ahd,
+					    struct ahd_initiator_tinfo *tinfo,
+					    u_int period, u_int *offset,
+					    int wide, role_t role);
+void			ahd_validate_width(struct ahd_softc *ahd,
+					   struct ahd_initiator_tinfo *tinfo,
+					   u_int *bus_width,
+					   role_t role);
+/*
+ * Negotiation types.  These are used to qualify if we should renegotiate
+ * even if our goal and current transport parameters are identical.
+ */
+typedef enum {
+	AHD_NEG_TO_GOAL,	/* Renegotiate only if goal and curr differ. */
+	AHD_NEG_IF_NON_ASYNC,	/* Renegotiate so long as goal is non-async. */
+	AHD_NEG_ALWAYS		/* Renegotiat even if goal is async. */
+} ahd_neg_type;
+int			ahd_update_neg_request(struct ahd_softc*,
+					       struct ahd_devinfo*,
+					       struct ahd_tmode_tstate*,
+					       struct ahd_initiator_tinfo*,
+					       ahd_neg_type);
+void			ahd_set_width(struct ahd_softc *ahd,
+				      struct ahd_devinfo *devinfo,
+				      u_int width, u_int type, int paused);
+void			ahd_set_syncrate(struct ahd_softc *ahd,
+					 struct ahd_devinfo *devinfo,
+					 u_int period, u_int offset,
+					 u_int ppr_options,
+					 u_int type, int paused);
+typedef enum {
+	AHD_QUEUE_NONE,
+	AHD_QUEUE_BASIC,
+	AHD_QUEUE_TAGGED
+} ahd_queue_alg;
+
+void			ahd_set_tags(struct ahd_softc *ahd,
+				     struct ahd_devinfo *devinfo,
+				     ahd_queue_alg alg);
+
+/**************************** Target Mode *************************************/
+#ifdef AHD_TARGET_MODE
+void		ahd_send_lstate_events(struct ahd_softc *,
+				       struct ahd_tmode_lstate *);
+void		ahd_handle_en_lun(struct ahd_softc *ahd,
+				  struct cam_sim *sim, union ccb *ccb);
+cam_status	ahd_find_tmode_devs(struct ahd_softc *ahd,
+				    struct cam_sim *sim, union ccb *ccb,
+				    struct ahd_tmode_tstate **tstate,
+				    struct ahd_tmode_lstate **lstate,
+				    int notfound_failure);
+#ifndef AHD_TMODE_ENABLE
+#define AHD_TMODE_ENABLE 0
+#endif
+#endif
+/******************************* Debug ***************************************/
+#ifdef AHD_DEBUG
+extern uint32_t ahd_debug;
+#define AHD_SHOW_MISC		0x00001
+#define AHD_SHOW_SENSE		0x00002
+#define AHD_SHOW_RECOVERY	0x00004
+#define AHD_DUMP_SEEPROM	0x00008
+#define AHD_SHOW_TERMCTL	0x00010
+#define AHD_SHOW_MEMORY		0x00020
+#define AHD_SHOW_MESSAGES	0x00040
+#define AHD_SHOW_MODEPTR	0x00080
+#define AHD_SHOW_SELTO		0x00100
+#define AHD_SHOW_FIFOS		0x00200
+#define AHD_SHOW_QFULL		0x00400
+#define	AHD_SHOW_DV		0x00800
+#define AHD_SHOW_MASKED_ERRORS	0x01000
+#define AHD_SHOW_QUEUE		0x02000
+#define AHD_SHOW_TQIN		0x04000
+#define AHD_SHOW_SG		0x08000
+#define AHD_SHOW_INT_COALESCING	0x10000
+#define AHD_DEBUG_SEQUENCER	0x20000
+#endif
+void			ahd_print_scb(struct scb *scb);
+void			ahd_print_devinfo(struct ahd_softc *ahd,
+					  struct ahd_devinfo *devinfo);
+void			ahd_dump_sglist(struct scb *scb);
+void			ahd_dump_all_cards_state(void);
+void			ahd_dump_card_state(struct ahd_softc *ahd);
+int			ahd_print_register(ahd_reg_parse_entry_t *table,
+					   u_int num_entries,
+					   const char *name,
+					   u_int address,
+					   u_int value,
+					   u_int *cur_column,
+					   u_int wrap_point);
+void			ahd_dump_scbs(struct ahd_softc *ahd);
+#endif /* _AIC79XX_H_ */
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic79xx.reg linux-5730/drivers/scsi/aic7xxx/aic79xx.reg
--- linux-5720/drivers/scsi/aic7xxx/aic79xx.reg
+++ linux-5730/drivers/scsi/aic7xxx/aic79xx.reg
@@ -0,0 +1,3958 @@
+/*
+ * Aic79xx register and scratch ram definitions.
+ *
+ * Copyright (c) 1994-2001 Justin T. Gibbs.
+ * Copyright (c) 2000-2002 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $FreeBSD$
+ */
+VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#70 $"
+
+/*
+ * This file is processed by the aic7xxx_asm utility for use in assembling
+ * firmware for the aic79xx family of SCSI host adapters as well as to generate
+ * a C header file for use in the kernel portion of the Aic79xx driver.
+ */
+
+/* Register window Modes */
+#define M_DFF0		0
+#define M_DFF1		1
+#define M_CCHAN		2
+#define M_SCSI		3
+#define M_CFG		4
+#define M_DST_SHIFT	4
+
+#define MK_MODE(src, dst) ((src) | ((dst) << M_DST_SHIFT))
+#define SET_MODE(src, dst)						\
+	SET_SRC_MODE	src;						\
+	SET_DST_MODE	dst;						\
+	if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {			\
+		mvi	MK_MODE(src, dst) call set_mode_work_around;	\
+	} else {							\
+		mvi	MODE_PTR, MK_MODE(src, dst);			\
+	}
+
+#define TOGGLE_DFF_MODE							\
+	if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {			\
+		call	toggle_dff_mode_work_around;			\
+	} else {							\
+		xor	MODE_PTR, MK_MODE(M_DFF1, M_DFF1);		\
+	}
+	
+#define RESTORE_MODE(mode)						\
+	if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {			\
+		mov	mode call set_mode_work_around;			\
+	} else {							\
+		mov	MODE_PTR, mode;					\
+	}
+
+#define SET_SEQINTCODE(code)						\
+	if ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {			\
+		mvi	code call set_seqint_work_around;		\
+	} else {							\
+		mvi	SEQINTCODE, code;				\
+	}
+
+/*
+ * Mode Pointer
+ * Controls which of the 5, 512byte, address spaces should be used
+ * as the source and destination of any register accesses in our
+ * register window.
+ */
+register MODE_PTR {
+	address			0x000
+	access_mode	RW
+	field	DST_MODE	0x70
+	field	SRC_MODE	0x07
+	mode_pointer
+}
+
+const SRC_MODE_SHIFT	0
+const DST_MODE_SHIFT	4
+
+/*
+ * Host Interrupt Status
+ */
+register INTSTAT {
+	address			0x001
+	access_mode	RW
+	field	HWERRINT	0x80
+	field	BRKADRINT	0x40
+	field	SWTMINT		0x20
+	field	PCIINT		0x10
+	field	SCSIINT		0x08
+	field	SEQINT		0x04
+	field	CMDCMPLT	0x02
+	field	SPLTINT		0x01
+	mask	INT_PEND 0xFF
+}
+
+/*
+ * Sequencer Interrupt Code
+ */
+register SEQINTCODE {
+	address			0x002
+	access_mode	RW
+	field {
+		NO_SEQINT,			/* No seqint pending. */
+		BAD_PHASE,			/* unknown scsi bus phase */
+		SEND_REJECT,			/* sending a message reject */
+		PROTO_VIOLATION, 		/* Protocol Violation */
+		NO_MATCH,			/* no cmd match for reconnect */
+		IGN_WIDE_RES,			/* Complex IGN Wide Res Msg */
+		PDATA_REINIT,			/*
+						 * Returned to data phase
+						 * that requires data
+						 * transfer pointers to be
+						 * recalculated from the
+						 * transfer residual.
+						 */
+		HOST_MSG_LOOP,			/*
+						 * The bus is ready for the
+						 * host to perform another
+						 * message transaction.  This
+						 * mechanism is used for things
+						 * like sync/wide negotiation
+						 * that require a kernel based
+						 * message state engine.
+						 */
+		BAD_STATUS,			/* Bad status from target */
+		DATA_OVERRUN,			/*
+						 * Target attempted to write
+						 * beyond the bounds of its
+						 * command.
+						 */
+		MKMSG_FAILED,			/*
+						 * Target completed command
+						 * without honoring our ATN
+						 * request to issue a message. 
+						 */
+		MISSED_BUSFREE,			/*
+						 * The sequencer never saw
+						 * the bus go free after
+						 * either a command complete
+						 * or disconnect message.
+						 */
+		DUMP_CARD_STATE,
+		ILLEGAL_PHASE,
+		INVALID_SEQINT,
+		CFG4ISTAT_INTR,
+		STATUS_OVERRUN,
+		CFG4OVERRUN,
+		ENTERING_NONPACK,
+		TASKMGMT_FUNC_COMPLETE,		/*
+						 * Task management function
+						 * request completed with
+						 * an expected busfree.
+						 */
+		TASKMGMT_CMD_CMPLT_OKAY,	/*
+						 * A command with a non-zero
+						 * task management function
+						 * has completed via the normal
+						 * command completion method
+						 * for commands with a zero
+						 * task management function.
+						 * This happens when an attempt
+						 * to abort a command loses
+						 * the race for the command to
+						 * complete normally.
+						 */
+		TRACEPOINT0,
+		TRACEPOINT1,
+		TRACEPOINT2,
+		TRACEPOINT3,
+		SAW_HWERR,
+		BAD_SCB_STATUS
+	}
+}
+
+/*
+ * Clear Host Interrupt
+ */
+register CLRINT {
+	address			0x003
+	access_mode	WO
+	field	CLRHWERRINT	0x80 /* Rev B or greater */
+	field	CLRBRKADRINT	0x40
+	field	CLRSWTMINT	0x20
+	field	CLRPCIINT	0x10
+	field	CLRSCSIINT	0x08
+	field	CLRSEQINT	0x04
+	field	CLRCMDINT	0x02
+	field	CLRSPLTINT	0x01
+}
+
+/*
+ * Error Register
+ */
+register ERROR {
+	address			0x004
+	access_mode	RO
+	field	CIOPARERR	0x80
+	field	CIOACCESFAIL	0x40 /* Rev B or greater */
+	field	MPARERR		0x20
+	field	DPARERR		0x10
+	field	SQPARERR	0x08
+	field	ILLOPCODE	0x04
+	field	DSCTMOUT	0x02
+}
+
+/*
+ * Clear Error
+ */
+register CLRERR {
+	address			0x004
+	access_mode 	WO
+	field	CLRCIOPARERR	0x80
+	field	CLRCIOACCESFAIL	0x40 /* Rev B or greater */
+	field	CLRMPARERR	0x20
+	field	CLRDPARERR	0x10
+	field	CLRSQPARERR	0x08
+	field	CLRILLOPCODE	0x04
+	field	CLRDSCTMOUT	0x02
+}
+
+/*
+ * Host Control Register
+ * Overall host control of the device.
+ */
+register HCNTRL {
+	address			0x005
+	access_mode	RW
+	field	SEQ_RESET	0x80 /* Rev B or greater */
+	field	POWRDN		0x40
+	field	SWINT		0x10
+	field	SWTIMER_START_B	0x08 /* Rev B or greater */
+	field	PAUSE		0x04
+	field	INTEN		0x02
+	field	CHIPRST		0x01
+	field	CHIPRSTACK	0x01
+}
+
+/*
+ * Host New SCB Queue Offset
+ */
+register HNSCB_QOFF {
+	address			0x006
+	access_mode	RW
+	size		2
+}
+
+/*
+ * Host Empty SCB Queue Offset
+ */
+register HESCB_QOFF {
+	address			0x008
+	access_mode	RW
+}
+
+/*
+ * Host Mailbox
+ */
+register HS_MAILBOX {
+	address			0x00B
+	access_mode	RW
+	mask	HOST_TQINPOS	0x80	/* Boundary at either 0 or 128 */
+	mask	ENINT_COALESCE	0x40	/* Perform interrupt coalescing */
+}
+
+/*
+ * Sequencer Interupt Status
+ */
+register SEQINTSTAT {
+	address			0x00C
+	access_mode	RO
+	field	SEQ_SWTMRTO	0x10
+	field	SEQ_SEQINT	0x08
+	field	SEQ_SCSIINT	0x04
+	field	SEQ_PCIINT	0x02
+	field	SEQ_SPLTINT	0x01
+}
+
+/*
+ * Clear SEQ Interrupt
+ */
+register CLRSEQINTSTAT {
+	address			0x00C
+	access_mode	WO
+	field	CLRSEQ_SWTMRTO	0x10
+	field	CLRSEQ_SEQINT	0x08
+	field	CLRSEQ_SCSIINT	0x04
+	field	CLRSEQ_PCIINT	0x02
+	field	CLRSEQ_SPLTINT	0x01
+}
+
+/*
+ * Software Timer
+ */
+register SWTIMER {
+	address			0x00E
+	access_mode	RW
+	size		2
+}
+
+/*
+ * SEQ New SCB Queue Offset
+ */
+register SNSCB_QOFF {
+	address			0x010
+	access_mode	RW
+	size		2
+	modes		M_CCHAN
+}
+
+/*
+ * SEQ Empty SCB Queue Offset
+ */
+register SESCB_QOFF {
+	address			0x012
+	access_mode	RW
+	modes		M_CCHAN
+}
+
+/*
+ * SEQ Done SCB Queue Offset
+ */
+register SDSCB_QOFF {
+	address			0x014
+	access_mode	RW
+	modes		M_CCHAN
+	size		2
+}
+
+/*
+ * Queue Offset Control & Status
+ */
+register QOFF_CTLSTA {
+	address			0x016
+	access_mode	RW
+	modes		M_CCHAN
+	field	EMPTY_SCB_AVAIL	0x80
+	field	NEW_SCB_AVAIL	0x40
+	field	SDSCB_ROLLOVR	0x20
+	field	HS_MAILBOX_ACT	0x10
+	field	SCB_QSIZE	0x0F {
+		SCB_QSIZE_4,
+		SCB_QSIZE_8,
+		SCB_QSIZE_16,
+		SCB_QSIZE_32,
+		SCB_QSIZE_64,
+		SCB_QSIZE_128,
+		SCB_QSIZE_256,
+		SCB_QSIZE_512,
+		SCB_QSIZE_1024,
+		SCB_QSIZE_2048,
+		SCB_QSIZE_4096,
+		SCB_QSIZE_8192,
+		SCB_QSIZE_16384
+	}
+}
+
+/*
+ * Interrupt Control
+ */
+register INTCTL {
+	address			0x018
+	access_mode	RW
+	field	SWTMINTMASK	0x80
+	field	SWTMINTEN	0x40
+	field	SWTIMER_START	0x20
+	field	AUTOCLRCMDINT	0x10
+	field	PCIINTEN	0x08
+	field	SCSIINTEN	0x04
+	field	SEQINTEN	0x02
+	field	SPLTINTEN	0x01
+}
+
+/*
+ * Data FIFO Control
+ */
+register DFCNTRL {
+	address			0x019
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	PRELOADEN	0x80
+	field	SCSIENWRDIS	0x40	/* Rev B only. */
+	field	SCSIEN		0x20
+	field	SCSIENACK	0x20
+	field	HDMAEN		0x08
+	field	HDMAENACK	0x08
+	field	DIRECTION	0x04
+	field	DIRECTIONACK	0x04
+	field	FIFOFLUSH	0x02
+	field	FIFOFLUSHACK	0x02
+	field	DIRECTIONEN	0x01
+}
+
+/*
+ * Device Space Command 0
+ */
+register DSCOMMAND0 {
+	address			0x019
+	access_mode	RW
+	modes		M_CFG
+	field	CACHETHEN	0x80	/* Cache Threshold enable */
+	field	DPARCKEN	0x40	/* Data Parity Check Enable */
+	field	MPARCKEN	0x20	/* Memory Parity Check Enable */
+	field	EXTREQLCK	0x10	/* External Request Lock */
+	field	DISABLE_TWATE	0x02	/* Rev B or greater */
+	field	CIOPARCKEN	0x01	/* Internal bus parity error enable */
+}
+
+/*
+ * Data FIFO Status
+ */
+register DFSTATUS {
+	address			0x01A
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	PRELOAD_AVAIL		0x80
+	field	PKT_PRELOAD_AVAIL	0x40
+	field	MREQPEND		0x10
+	field	HDONE			0x08
+	field	DFTHRESH		0x04
+	field	FIFOFULL		0x02
+	field	FIFOEMP			0x01
+}
+
+/*
+ * S/G Cache Pointer
+ */
+register SG_CACHE_PRE {
+	address			0x01B
+	access_mode	WO
+	modes		M_DFF0, M_DFF1
+	field	SG_ADDR_MASK	0xf8
+	field	ODD_SEG		0x04
+	field	LAST_SEG	0x02
+}
+
+register SG_CACHE_SHADOW {
+	address			0x01B
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	SG_ADDR_MASK	0xf8
+	field	ODD_SEG		0x04
+	field	LAST_SEG	0x02
+	field	LAST_SEG_DONE	0x01
+}
+
+/*
+ * Arbiter Control
+ */
+register ARBCTL {
+	address			0x01B
+	access_mode	RW
+	modes		M_CFG
+	field	RESET_HARB	0x80
+	field	RETRY_SWEN	0x08
+	field	USE_TIME	0x07
+}
+
+/*
+ * Data Channel Host Address
+ */
+register HADDR {
+	address			0x070
+	access_mode	RW
+	size		8
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Host Overlay DMA Address
+ */
+register HODMAADR {
+	address			0x070
+	access_mode	RW
+	size		8
+	modes		M_SCSI
+}
+
+/*
+ * PCI PLL Delay.
+ */
+register PLLDELAY {
+	address			0x070
+	access_mode	RW
+	size		1
+	modes		M_CFG
+	field	SPLIT_DROP_REQ	0x80
+}
+
+/*
+ * Data Channel Host Count
+ */
+register HCNT {
+	address			0x078
+	access_mode	RW
+	size		3
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Host Overlay DMA Count
+ */
+register HODMACNT {
+	address			0x078
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * Host Overlay DMA Enable
+ */
+register HODMAEN {
+	address			0x07A
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Scatter/Gather Host Address
+ */
+register SGHADDR {
+	address			0x07C
+	access_mode	RW
+	size		8
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * SCB Host Address
+ */
+register SCBHADDR {
+	address			0x07C
+	access_mode	RW
+	size		8
+	modes		M_CCHAN
+}
+
+/*
+ * Scatter/Gather Host Count
+ */
+register SGHCNT {
+	address			0x084
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * SCB Host Count
+ */
+register SCBHCNT {
+	address			0x084
+	access_mode	RW
+	modes		M_CCHAN
+}
+
+/*
+ * Data FIFO Threshold
+ */
+register DFF_THRSH {
+	address			0x088
+	access_mode	RW
+	modes		M_CFG
+	field	WR_DFTHRSH	0x70 {
+		WR_DFTHRSH_MIN,
+		WR_DFTHRSH_25,
+		WR_DFTHRSH_50,
+		WR_DFTHRSH_63,
+		WR_DFTHRSH_75,
+		WR_DFTHRSH_85,
+		WR_DFTHRSH_90,
+		WR_DFTHRSH_MAX
+	}
+	field	RD_DFTHRSH	0x07 {
+		RD_DFTHRSH_MIN,
+		RD_DFTHRSH_25,
+		RD_DFTHRSH_50,
+		RD_DFTHRSH_63,
+		RD_DFTHRSH_75,
+		RD_DFTHRSH_85,
+		RD_DFTHRSH_90,
+		RD_DFTHRSH_MAX
+	}
+}
+
+/*
+ * ROM Address
+ */
+register ROMADDR {
+	address			0x08A
+	access_mode	RW
+	size		3
+}
+
+/*
+ * ROM Control
+ */
+register ROMCNTRL {
+	address			0x08D
+	access_mode	RW
+	field	ROMOP		0xE0
+	field	ROMSPD		0x18
+	field	REPEAT		0x02
+	field	RDY		0x01
+}
+
+/*
+ * ROM Data
+ */
+register ROMDATA {
+	address			0x08E
+	access_mode	RW
+}
+
+/*
+ * Data Channel Receive Message 0
+ */
+register DCHRXMSG0 {
+	address			0x090
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field		CDNUM	0xF8
+	field		CFNUM	0x07
+}
+
+/*
+ * CMC Recieve Message 0
+ */
+register CMCRXMSG0 {
+	address			0x090
+	access_mode	RO
+	modes		M_CCHAN
+	field		CDNUM	0xF8
+	field		CFNUM	0x07
+}
+
+/*
+ * Overlay Recieve Message 0
+ */
+register OVLYRXMSG0 {
+	address			0x090
+	access_mode	RO
+	modes		M_SCSI
+	field		CDNUM	0xF8
+	field		CFNUM	0x07
+}
+
+/*
+ * Relaxed Order Enable
+ */
+register ROENABLE {
+	address			0x090
+	access_mode	RW
+	modes		M_CFG
+	field	MSIROEN		0x20
+	field	OVLYROEN	0x10
+	field	CMCROEN		0x08
+	field	SGROEN		0x04
+	field	DCH1ROEN	0x02
+	field	DCH0ROEN	0x01
+}
+
+/*
+ * Data Channel Receive Message 1
+ */
+register DCHRXMSG1 {
+	address			0x091
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	CBNUM		0xFF
+}
+
+/*
+ * CMC Recieve Message 1
+ */
+register CMCRXMSG1 {
+	address			0x091
+	access_mode	RO
+	modes		M_CCHAN
+	field	CBNUM		0xFF
+}
+
+/*
+ * Overlay Recieve Message 1
+ */
+register OVLYRXMSG1 {
+	address			0x091
+	access_mode	RO
+	modes		M_SCSI
+	field	CBNUM		0xFF
+}
+
+/*
+ * No Snoop Enable
+ */
+register NSENABLE {
+	address			0x091
+	access_mode	RW
+	modes		M_CFG
+	field	MSINSEN		0x20
+	field	OVLYNSEN	0x10
+	field	CMCNSEN		0x08
+	field	SGNSEN		0x04
+	field	DCH1NSEN	0x02
+	field	DCH0NSEN	0x01
+}
+
+/*
+ * Data Channel Receive Message 2
+ */
+register DCHRXMSG2 {
+	address			0x092
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	MINDEX		0xFF
+}
+
+/*
+ * CMC Recieve Message 2
+ */
+register CMCRXMSG2 {
+	address			0x092
+	access_mode	RO
+	modes		M_CCHAN
+	field	MINDEX		0xFF
+}
+
+/*
+ * Overlay Recieve Message 2
+ */
+register OVLYRXMSG2 {
+	address			0x092
+	access_mode	RO
+	modes		M_SCSI
+	field	MINDEX		0xFF
+}
+
+/*
+ * Outstanding Split Transactions
+ */
+register OST {
+	address			0x092
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Data Channel Receive Message 3
+ */
+register DCHRXMSG3 {
+	address			0x093
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	MCLASS		0x0F
+}
+
+/*
+ * CMC Recieve Message 3
+ */
+register CMCRXMSG3 {
+	address			0x093
+	access_mode	RO
+	modes		M_CCHAN
+	field	MCLASS		0x0F
+}
+
+/*
+ * Overlay Recieve Message 3
+ */
+register OVLYRXMSG3 {
+	address			0x093
+	access_mode	RO
+	modes		M_SCSI
+	field	MCLASS		0x0F
+}
+
+/*
+ * PCI-X Control
+ */
+register PCIXCTL {
+	address			0x093
+	access_mode	RW
+	modes		M_CFG
+	field	SERRPULSE	0x80
+	field	UNEXPSCIEN	0x20
+	field	SPLTSMADIS	0x10
+	field	SPLTSTADIS	0x08
+	field	SRSPDPEEN	0x04
+	field	TSCSERREN	0x02
+	field	CMPABCDIS	0x01
+}
+
+/*
+ * CMC Sequencer Byte Count
+ */
+register CMCSEQBCNT {
+	address			0x094
+	access_mode	RO
+	modes		M_CCHAN
+}
+
+/*
+ * Overlay Sequencer Byte Count
+ */
+register OVLYSEQBCNT {
+	address			0x094
+	access_mode	RO
+	modes		M_SCSI
+}
+
+/*
+ * Data Channel Sequencer Byte Count
+ */
+register DCHSEQBCNT {
+	address			0x094
+	access_mode	RO
+	size		2
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Data Channel Split Status 0
+ */
+register DCHSPLTSTAT0 {
+	address			0x096
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	STAETERM	0x80
+	field	SCBCERR		0x40
+	field	SCADERR		0x20
+	field	SCDATBUCKET	0x10
+	field	CNTNOTCMPLT	0x08
+	field	RXOVRUN		0x04
+	field	RXSCEMSG	0x02
+	field	RXSPLTRSP	0x01
+}
+
+/*
+ * CMC Split Status 0
+ */
+register CMCSPLTSTAT0 {
+	address			0x096
+	access_mode	RW
+	modes		M_CCHAN
+	field	STAETERM	0x80
+	field	SCBCERR		0x40
+	field	SCADERR		0x20
+	field	SCDATBUCKET	0x10
+	field	CNTNOTCMPLT	0x08
+	field	RXOVRUN		0x04
+	field	RXSCEMSG	0x02
+	field	RXSPLTRSP	0x01
+}
+
+/*
+ * Overlay Split Status 0
+ */
+register OVLYSPLTSTAT0 {
+	address			0x096
+	access_mode	RW
+	modes		M_SCSI
+	field	STAETERM	0x80
+	field	SCBCERR		0x40
+	field	SCADERR		0x20
+	field	SCDATBUCKET	0x10
+	field	CNTNOTCMPLT	0x08
+	field	RXOVRUN		0x04
+	field	RXSCEMSG	0x02
+	field	RXSPLTRSP	0x01
+}
+
+/*
+ * Data Channel Split Status 1
+ */
+register DCHSPLTSTAT1 {
+	address			0x097
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	RXDATABUCKET	0x01
+}
+
+/*
+ * CMC Split Status 1
+ */
+register CMCSPLTSTAT1 {
+	address			0x097
+	access_mode	RW
+	modes		M_CCHAN
+	field	RXDATABUCKET	0x01
+}
+
+/*
+ * Overlay Split Status 1
+ */
+register OVLYSPLTSTAT1 {
+	address			0x097
+	access_mode	RW
+	modes		M_SCSI
+	field	RXDATABUCKET	0x01
+}
+
+/*
+ * S/G Receive Message 0
+ */
+register SGRXMSG0 {
+	address			0x098
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field		CDNUM	0xF8
+	field		CFNUM	0x07
+}
+
+/*
+ * S/G Receive Message 1
+ */
+register SGRXMSG1 {
+	address			0x099
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	CBNUM		0xFF
+}
+
+/*
+ * S/G Receive Message 2
+ */
+register SGRXMSG2 {
+	address			0x09A
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	MINDEX		0xFF
+}
+
+/*
+ * S/G Receive Message 3
+ */
+register SGRXMSG3 {
+	address			0x09B
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	MCLASS		0x0F
+}
+
+/*
+ * Slave Split Out Address 0
+ */
+register SLVSPLTOUTADR0 {
+	address			0x098
+	access_mode	RO
+	modes		M_SCSI
+	field	LOWER_ADDR	0x7F
+}
+
+/*
+ * Slave Split Out Address 1
+ */
+register SLVSPLTOUTADR1 {
+	address			0x099
+	access_mode	RO
+	modes		M_SCSI
+	field	REQ_DNUM	0xF8
+	field	REQ_FNUM	0x07
+}
+
+/*
+ * Slave Split Out Address 2
+ */
+register SLVSPLTOUTADR2 {
+	address			0x09A
+	access_mode	RO
+	modes		M_SCSI
+	field	REQ_BNUM	0xFF
+}
+
+/*
+ * Slave Split Out Address 3
+ */
+register SLVSPLTOUTADR3 {
+	address			0x09B
+	access_mode	RO
+	modes		M_SCSI
+	field	RLXORD		020
+	field	TAG_NUM		0x1F
+}
+
+/*
+ * SG Sequencer Byte Count
+ */
+register SGSEQBCNT {
+	address			0x09C
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Slave Split Out Attribute 0
+ */
+register SLVSPLTOUTATTR0 {
+	address			0x09C
+	access_mode	RO
+	modes		M_SCSI
+	field	LOWER_BCNT	0xFF
+}
+
+/*
+ * Slave Split Out Attribute 1
+ */
+register SLVSPLTOUTATTR1 {
+	address			0x09D
+	access_mode	RO
+	modes		M_SCSI
+	field	CMPLT_DNUM	0xF8
+	field	CMPLT_FNUM	0x07
+}
+
+/*
+ * Slave Split Out Attribute 2
+ */
+register SLVSPLTOUTATTR2 {
+	address			0x09E
+	access_mode	RO
+	size		2
+	modes		M_SCSI
+	field	CMPLT_BNUM	0xFF
+}
+/*
+ * S/G Split Status 0
+ */
+register SGSPLTSTAT0 {
+	address			0x09E
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	STAETERM	0x80
+	field	SCBCERR		0x40
+	field	SCADERR		0x20
+	field	SCDATBUCKET	0x10
+	field	CNTNOTCMPLT	0x08
+	field	RXOVRUN		0x04
+	field	RXSCEMSG	0x02
+	field	RXSPLTRSP	0x01
+}
+
+/*
+ * S/G Split Status 1
+ */
+register SGSPLTSTAT1 {
+	address			0x09F
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	RXDATABUCKET	0x01
+}
+
+/*
+ * Special Function
+ */
+register SFUNCT {
+	address			0x09f
+	access_mode	RW
+	modes		M_CFG
+	field	TEST_GROUP	0xF0
+	field	TEST_NUM	0x0F
+}
+
+/*
+ * Data FIFO 0 PCI Status 
+ */
+register DF0PCISTAT {
+	address			0x0A0
+	access_mode	RW
+	modes		M_CFG
+	field	DPE		0x80
+	field	SSE		0x40
+	field	RMA		0x20
+	field	RTA		0x10
+	field	SCAAPERR	0x08
+	field	RDPERR		0x04
+	field	TWATERR		0x02
+	field	DPR		0x01
+}
+
+/*
+ * Data FIFO 1 PCI Status 
+ */
+register DF1PCISTAT {
+	address			0x0A1
+	access_mode	RW
+	modes		M_CFG
+	field	DPE		0x80
+	field	SSE		0x40
+	field	RMA		0x20
+	field	RTA		0x10
+	field	SCAAPERR	0x08
+	field	RDPERR		0x04
+	field	TWATERR		0x02
+	field	DPR		0x01
+}
+
+/*
+ * S/G PCI Status 
+ */
+register SGPCISTAT {
+	address			0x0A2
+	access_mode	RW
+	modes		M_CFG
+	field	DPE		0x80
+	field	SSE		0x40
+	field	RMA		0x20
+	field	RTA		0x10
+	field	SCAAPERR	0x08
+	field	RDPERR		0x04
+	field	DPR		0x01
+}
+
+/*
+ * CMC PCI Status 
+ */
+register CMCPCISTAT {
+	address			0x0A3
+	access_mode	RW
+	modes		M_CFG
+	field	DPE		0x80
+	field	SSE		0x40
+	field	RMA		0x20
+	field	RTA		0x10
+	field	SCAAPERR	0x08
+	field	RDPERR		0x04
+	field	TWATERR		0x02
+	field	DPR		0x01
+}
+
+/*
+ * Overlay PCI Status 
+ */
+register OVLYPCISTAT {
+	address			0x0A4
+	access_mode	RW
+	modes		M_CFG
+	field	DPE		0x80
+	field	SSE		0x40
+	field	RMA		0x20
+	field	RTA		0x10
+	field	SCAAPERR	0x08
+	field	RDPERR		0x04
+	field	DPR		0x01
+}
+
+/*
+ * PCI Status for MSI Master DMA Transfer
+ */
+register MSIPCISTAT {
+	address			0x0A6
+	access_mode	RW
+	modes		M_CFG
+	field	SSE		0x40
+	field	RMA		0x20
+	field	RTA		0x10
+	field	CLRPENDMSI	0x08
+	field	TWATERR		0x02
+	field	DPR		0x01
+}
+
+/*
+ * PCI Status for Target
+ */
+register TARGPCISTAT {
+	address			0x0A7
+	access_mode	RW
+	modes		M_CFG
+	field	DPE		0x80
+	field	SSE		0x40
+	field	STA		0x08
+	field	TWATERR		0x02
+}
+
+/*
+ * LQ Packet In
+ * The last LQ Packet recieved
+ */
+register LQIN {
+	address			0x020
+	access_mode	RW
+	size		20
+	modes		M_DFF0, M_DFF1, M_SCSI
+}
+
+/*
+ * SCB Type Pointer
+ * SCB offset for Target Mode SCB type information
+ */
+register TYPEPTR {
+	address			0x020
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Queue Tag Pointer
+ * SCB offset to the Two Byte tag identifier used for target mode.
+ */
+register TAGPTR {
+	address			0x021
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Logical Unit Number Pointer
+ * SCB offset to the LSB (little endian) of the lun field.
+ */
+register LUNPTR {
+	address			0x022
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Data Length Pointer
+ * SCB offset for the 4 byte data length field in target mode.
+ */
+register DATALENPTR {
+	address			0x023
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Status Length Pointer
+ * SCB offset to the two byte status field in target SCBs.
+ */
+register STATLENPTR {
+	address			0x024
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Command Length Pointer
+ * Scb offset for the CDB length field in initiator SCBs.
+ */
+register CMDLENPTR {
+	address			0x025
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Task Attribute Pointer
+ * Scb offset for the byte field specifying the attribute byte
+ * to be used in command packets.
+ */ 
+register ATTRPTR {
+	address			0x026
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Task Management Flags Pointer
+ * Scb offset for the byte field specifying the attribute flags
+ * byte to be used in command packets.
+ */ 
+register FLAGPTR {
+	address			0x027
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Command Pointer
+ * Scb offset for the first byte in the CDB for initiator SCBs.
+ */
+register CMDPTR {
+	address			0x028
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Queue Next Pointer
+ * Scb offset for the 2 byte "next scb link".
+ */
+register QNEXTPTR {
+	address			0x029
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * SCSI ID Pointer
+ * Scb offset to the value to place in the SCSIID register
+ * during target mode connections.
+ */
+register IDPTR {
+	address			0x02A
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Command Aborted Byte Pointer
+ * Offset to the SCB flags field that includes the
+ * "SCB aborted" status bit.
+ */
+register ABRTBYTEPTR {
+	address			0x02B
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Command Aborted Bit Pointer
+ * Bit offset in the SCB flags field for "SCB aborted" status.
+ */
+register ABRTBITPTR {
+	address			0x02C
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Rev B or greater.
+ */
+register MAXCMDBYTES {
+	address			0x02D
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Rev B or greater.
+ */
+register MAXCMD2RCV {
+	address			0x02E
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Rev B or greater.
+ */
+register SHORTTHRESH {
+	address			0x02F
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Logical Unit Number Length
+ * The length, in bytes, of the SCB lun field.
+ */
+register LUNLEN {
+	address			0x030
+	access_mode	RW
+	modes		M_CFG
+	mask		ILUNLEN	0x0F
+	mask		TLUNLEN	0xF0
+}
+const LUNLEN_SINGLE_LEVEL_LUN 0xF
+
+/*
+ * CDB Limit
+ * The size, in bytes, of the embedded CDB field in initator SCBs.
+ */
+register CDBLIMIT {
+	address			0x031
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Maximum Commands
+ * The maximum number of commands to issue during a
+ * single packetized connection.
+ */
+register MAXCMD {
+	address			0x032
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * Maximum Command Counter
+ * The number of commands already sent during this connection
+ */
+register MAXCMDCNT {
+	address			0x033
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * LQ Packet Reserved Bytes
+ * The bytes to be sent in the currently reserved fileds
+ * of all LQ packets.
+ */
+register LQRSVD01 {
+	address			0x034
+	access_mode	RW
+	modes		M_SCSI
+}
+register LQRSVD16 {
+	address			0x035
+	access_mode	RW
+	modes		M_SCSI
+}
+register LQRSVD17 {
+	address			0x036
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Command Reserved 0
+ * The byte to be sent for the reserved byte 0 of
+ * outgoing command packets.
+ */
+register CMDRSVD0 {
+	address			0x037
+	access_mode	RW
+	modes		M_CFG
+}
+
+/*
+ * LQ Manager Control 0
+ */
+register LQCTL0 {
+	address			0x038
+	access_mode	RW
+	modes		M_CFG
+	field	LQITARGCLT	0xC0
+	field	LQIINITGCLT	0x30
+	field	LQ0TARGCLT	0x0C
+	field	LQ0INITGCLT	0x03
+}
+
+/*
+ * LQ Manager Control 1
+ */
+register LQCTL1 {
+	address			0x038
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	PCI2PCI		0x04
+	field	SINGLECMD	0x02
+	field	ABORTPENDING	0x01
+}
+
+/*
+ * LQ Manager Control 2
+ */
+register LQCTL2 {
+	address			0x039
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	LQIRETRY	0x80
+	field	LQICONTINUE	0x40
+	field	LQITOIDLE	0x20
+	field	LQIPAUSE	0x10
+	field	LQORETRY	0x08
+	field	LQOCONTINUE	0x04
+	field	LQOTOIDLE	0x02
+	field	LQOPAUSE	0x01
+}
+
+/*
+ * SCSI RAM BIST0
+ */
+register SCSBIST0 {
+	address			0x039
+	access_mode	RW
+	modes		M_CFG
+	field	GSBISTERR	0x40
+	field	GSBISTDONE	0x20
+	field	GSBISTRUN	0x10
+	field	OSBISTERR	0x04
+	field	OSBISTDONE	0x02
+	field	OSBISTRUN	0x01
+}
+
+/*
+ * SCSI Sequence Control0
+ */
+register SCSISEQ0 {
+	address			0x03A
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	TEMODEO		0x80
+	field	ENSELO		0x40
+	field	ENARBO		0x20
+	field	FORCEBUSFREE	0x10
+	field	SCSIRSTO	0x01
+}
+
+/*
+ * SCSI RAM BIST 1
+ */
+register SCSBIST1 {
+	address			0x03A
+	access_mode	RW
+	modes		M_CFG
+	field	NTBISTERR	0x04
+	field	NTBISTDONE	0x02
+	field	NTBISTRUN	0x01
+}
+
+/*
+ * SCSI Sequence Control 1
+ */
+register SCSISEQ1 {
+	address			0x03B
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	MANUALCTL	0x40
+	field	ENSELI		0x20
+	field	ENRSELI		0x10
+	field	MANUALP		0x0C
+	field	ENAUTOATNP	0x02
+	field	ALTSTIM		0x01
+}
+
+/*
+ * SCSI Transfer Control 0
+ */
+register SXFRCTL0 {
+	address			0x03C
+	access_mode	RW
+	modes		M_SCSI
+	field	DFON		0x80
+	field	DFPEXP		0x40
+	field	BIOSCANCELEN	0x10
+	field	SPIOEN		0x08
+}
+
+/*
+ * SCSI Transfer Control 1
+ */
+register SXFRCTL1 {
+	address			0x03D
+	access_mode	RW
+	modes		M_SCSI
+	field	BITBUCKET	0x80
+	field	ENSACHK		0x40
+	field	ENSPCHK		0x20
+	field	STIMESEL	0x18
+	field	ENSTIMER	0x04
+	field	ACTNEGEN	0x02
+	field	STPWEN		0x01
+}
+
+/*
+ * SCSI Transfer Control 2
+ */
+register SXFRCTL2 {
+	address			0x03E
+	access_mode	RW
+	modes		M_SCSI
+	field	AUTORSTDIS	0x10
+	field	CMDDMAEN	0x08
+	field	ASU		0x07
+}
+
+/*
+ * SCSI Bus Initiator IDs
+ * Bitmask of observed initiators on the bus.
+ */
+register BUSINITID {
+	address			0x03C
+	access_mode	RW
+	modes		M_CFG
+	size		2
+}
+
+/*
+ * Data Length Counters
+ * Packet byte counter.
+ */
+register DLCOUNT {
+	address			0x03C
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	size		3
+}
+
+/*
+ * Data FIFO Status
+ */
+register DFFSTAT {
+	address			0x03F
+	access_mode	RW
+	modes		M_SCSI
+	field	FIFO1FREE	0x20
+	field	FIFO0FREE	0x10
+	/*
+	 * On the B, this enum only works
+	 * in the read direction.  For writes,
+	 * you must use the B version of the
+	 * CURRFIFO_0 definition which is defined
+	 * as a constant outside of this register
+	 * definition to avoid confusing the
+	 * register pretty printing code.
+	 */
+	enum	CURRFIFO	0x03 {
+		CURRFIFO_0,
+		CURRFIFO_1,
+		CURRFIFO_NONE	0x3
+	}
+}
+
+const B_CURRFIFO_0 0x2
+
+/*
+ * SCSI Bus Target IDs
+ * Bitmask of observed targets on the bus.
+ */
+register BUSTARGID {
+	address			0x03E
+	access_mode	RW
+	modes		M_CFG
+	size		2
+}
+
+/*
+ * SCSI Control Signal Out
+ */
+register SCSISIGO {
+	address			0x040
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CDO		0x80
+	field	IOO		0x40
+	field	MSGO		0x20
+	field	ATNO		0x10
+	field	SELO		0x08
+	field	BSYO		0x04
+	field	REQO		0x02
+	field	ACKO		0x01
+/*
+ * Possible phases to write into SCSISIG0
+ */
+	enum	PHASE_MASK  CDO|IOO|MSGO {
+		P_DATAOUT	0x0,
+		P_DATAIN	IOO,
+		P_DATAOUT_DT	P_DATAOUT|MSGO,
+		P_DATAIN_DT	P_DATAIN|MSGO,
+		P_COMMAND	CDO,
+		P_MESGOUT	CDO|MSGO,
+		P_STATUS	CDO|IOO,
+		P_MESGIN	CDO|IOO|MSGO
+	}
+}
+
+register SCSISIGI {
+	address			0x041
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CDI		0x80
+	field	IOI		0x40
+	field	MSGI		0x20
+	field	ATNI		0x10
+	field	SELI		0x08
+	field	BSYI		0x04
+	field	REQI		0x02
+	field	ACKI		0x01
+/*
+ * Possible phases in SCSISIGI
+ */
+	enum	PHASE_MASK  CDO|IOO|MSGO {
+		P_DATAOUT	0x0,
+		P_DATAIN	IOO,
+		P_DATAOUT_DT	P_DATAOUT|MSGO,
+		P_DATAIN_DT	P_DATAIN|MSGO,
+		P_COMMAND	CDO,
+		P_MESGOUT	CDO|MSGO,
+		P_STATUS	CDO|IOO,
+		P_MESGIN	CDO|IOO|MSGO
+	}
+}
+
+/*
+ * Multiple Target IDs
+ * Bitmask of ids to respond as a target.
+ */
+register MULTARGID {
+	address			0x040
+	access_mode	RW
+	modes		M_CFG
+	size		2
+}
+
+/*
+ * SCSI Phase
+ */
+register SCSIPHASE {
+	address			0x042
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	STATUS_PHASE	0x20
+	field	COMMAND_PHASE	0x10
+	field	MSG_IN_PHASE	0x08
+	field	MSG_OUT_PHASE	0x04
+	field	DATA_PHASE_MASK	0x03 {
+		DATA_OUT_PHASE	0x01,
+		DATA_IN_PHASE	0x02
+	}
+}
+
+/*
+ * SCSI Data 0 Image
+ */
+register SCSIDAT0_IMG {
+	address			0x043
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+}
+
+/*
+ * SCSI Latched Data
+ */
+register SCSIDAT {
+	address			0x044
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	size		2
+}
+
+/*
+ * SCSI Data Bus
+ */
+register SCSIBUS {
+	address			0x046
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	size		2
+}
+
+/*
+ * Target ID In
+ */
+register TARGIDIN {
+	address			0x048
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLKOUT		0x80
+	field	TARGID		0x0F
+}
+
+/*
+ * Selection/Reselection ID
+ * Upper four bits are the device id.  The ONEBIT is set when the re/selecting
+ * device did not set its own ID.
+ */
+register SELID {
+	address			0x049
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	SELID_MASK	0xf0
+	field	ONEBIT		0x08
+}
+
+/*
+ * SCSI Block Control
+ * Controls Bus type and channel selection.  SELWIDE allows for the
+ * coexistence of 8bit and 16bit devices on a wide bus.
+ */
+register SBLKCTL {
+	address			0x04A
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	DIAGLEDEN	0x80
+	field	DIAGLEDON	0x40
+	field	ENAB40		0x08	/* LVD transceiver active */
+	field	ENAB20		0x04	/* SE/HVD transceiver active */
+	field	SELWIDE		0x02
+}
+
+/*
+ * Option Mode
+ */
+register OPTIONMODE {
+	address			0x04A
+	access_mode	RW
+	modes		M_CFG
+	field	BIOSCANCTL		0x80
+	field	AUTOACKEN		0x40
+	field	BIASCANCTL		0x20
+	field	BUSFREEREV		0x10
+	field	ENDGFORMCHK		0x04
+	field	AUTO_MSGOUT_DE		0x02
+	mask	OPTIONMODE_DEFAULTS	AUTO_MSGOUT_DE
+}
+
+/*
+ * SCSI Status 0
+ */
+register SSTAT0	{
+	address			0x04B
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	TARGET		0x80	/* Board acting as target */
+	field	SELDO		0x40	/* Selection Done */
+	field	SELDI		0x20	/* Board has been selected */
+	field	SELINGO		0x10	/* Selection In Progress */
+	field	IOERR		0x08	/* LVD Tranceiver mode changed */
+	field	OVERRUN		0x04	/* SCSI Offset overrun detected */
+	field	SPIORDY		0x02	/* SCSI PIO Ready */
+	field	ARBDO		0x01	/* Arbitration Done Out */
+}
+
+/*
+ * Clear SCSI Interrupt 0
+ * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT0.
+ */
+register CLRSINT0 {
+	address			0x04B
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRSELDO	0x40
+	field	CLRSELDI	0x20
+	field	CLRSELINGO	0x10
+	field	CLRIOERR	0x08
+	field	CLROVERRUN	0x04
+	field	CLRSPIORDY	0x02
+	field	CLRARBDO	0x01
+}
+
+/*
+ * SCSI Interrupt Mode 0
+ * Setting any bit will enable the corresponding function
+ * in SIMODE0 to interrupt via the IRQ pin.
+ */
+register SIMODE0 {
+	address			0x04B
+	access_mode	RW
+	modes		M_CFG
+	field	ENSELDO		0x40
+	field	ENSELDI		0x20
+	field	ENSELINGO	0x10
+	field	ENIOERR		0x08
+	field	ENOVERRUN	0x04
+	field	ENSPIORDY	0x02
+	field	ENARBDO		0x01
+}
+
+/*
+ * SCSI Status 1
+ */
+register SSTAT1 {
+	address			0x04C
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	SELTO		0x80
+	field	ATNTARG 	0x40
+	field	SCSIRSTI	0x20
+	field	PHASEMIS	0x10
+	field	BUSFREE		0x08
+	field	SCSIPERR	0x04
+	field	STRB2FAST	0x02
+	field	REQINIT		0x01
+}
+
+/*
+ * Clear SCSI Interrupt 1
+ * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT1.
+ */
+register CLRSINT1 {
+	address			0x04C
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRSELTIMEO	0x80
+	field	CLRATNO		0x40
+	field	CLRSCSIRSTI	0x20
+	field	CLRBUSFREE	0x08
+	field	CLRSCSIPERR	0x04
+	field	CLRSTRB2FAST	0x02
+	field	CLRREQINIT	0x01
+}
+
+/*
+ * SCSI Status 2
+ */
+register SSTAT2 {
+	address			0x04d
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	BUSFREETIME	0xc0 {
+		BUSFREE_LQO	0x40,
+		BUSFREE_DFF0	0x80,
+		BUSFREE_DFF1	0xC0
+	}
+	field	NONPACKREQ	0x20
+	field	EXP_ACTIVE	0x10	/* SCSI Expander Active */
+	field	BSYX		0x08	/* Busy Expander */
+	field	WIDE_RES	0x04	/* Modes 0 and 1 only */
+	field	SDONE		0x02	/* Modes 0 and 1 only */
+	field	DMADONE		0x01	/* Modes 0 and 1 only */
+}
+
+/*
+ * Clear SCSI Interrupt 2
+ */
+register CLRSINT2 {
+	address			0x04D
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRNONPACKREQ	0x20
+	field	CLRWIDE_RES	0x04	/* Modes 0 and 1 only */
+	field	CLRSDONE	0x02	/* Modes 0 and 1 only */
+	field	CLRDMADONE	0x01	/* Modes 0 and 1 only */
+}
+
+/*
+ * SCSI Interrupt Mode 2
+ */
+register SIMODE2 {
+	address			0x04D
+	access_mode	RW
+	modes		M_CFG
+	field	ENWIDE_RES	0x04
+	field	ENSDONE		0x02
+	field	ENDMADONE	0x01
+}
+
+/*
+ * Physical Error Diagnosis
+ */
+register PERRDIAG {
+	address			0x04E
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	HIZERO		0x80
+	field	HIPERR		0x40
+	field	PREVPHASE	0x20
+	field	PARITYERR	0x10
+	field	AIPERR		0x08
+	field	CRCERR		0x04
+	field	DGFORMERR	0x02
+	field	DTERR		0x01
+}
+
+/*
+ * LQI Manager Current State
+ */
+register LQISTATE {
+	address			0x04E
+	access_mode	RO
+	modes		M_CFG
+}
+
+/*
+ * SCSI Offset Count
+ */
+register SOFFCNT {
+	address			0x04F
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+}
+
+/*
+ * LQO Manager Current State
+ */
+register LQOSTATE {
+	address			0x04F
+	access_mode	RO
+	modes		M_CFG
+}
+
+/*
+ * LQI Manager Status
+ */
+register LQISTAT0 {
+	address			0x050
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	LQIATNQAS	0x20
+	field	LQICRCT1	0x10
+	field	LQICRCT2	0x08
+	field	LQIBADLQT	0x04
+	field	LQIATNLQ	0x02
+	field	LQIATNCMD	0x01
+}
+
+/*
+ * Clear LQI Interrupts 0
+ */
+register CLRLQIINT0 {
+	address			0x050
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRLQIATNQAS	0x20
+	field	CLRLQICRCT1	0x10
+	field	CLRLQICRCT2	0x08
+	field	CLRLQIBADLQT	0x04
+	field	CLRLQIATNLQ	0x02
+	field	CLRLQIATNCMD	0x01
+}
+
+/*
+ * LQI Manager Interrupt Mode 0
+ */
+register LQIMODE0 {
+	address			0x050
+	access_mode	RW
+	modes		M_CFG
+	field	ENLQIATNQASK	0x20
+	field	ENLQICRCT1	0x10
+	field	ENLQICRCT2	0x08
+	field	ENLQIBADLQT	0x04
+	field	ENLQIATNLQ	0x02
+	field	ENLQIATNCMD	0x01
+}
+
+/*
+ * LQI Manager Status 1
+ */
+register LQISTAT1 {
+	address			0x051
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	LQIPHASE_LQ	0x80
+	field	LQIPHASE_NLQ	0x40
+	field	LQIABORT	0x20
+	field	LQICRCI_LQ	0x10
+	field	LQICRCI_NLQ	0x08
+	field	LQIBADLQI	0x04
+	field	LQIOVERI_LQ	0x02
+	field	LQIOVERI_NLQ	0x01
+}
+
+/*
+ * Clear LQI Manager Interrupts1
+ */
+register CLRLQIINT1 {
+	address			0x051
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRLQIPHASE_LQ	0x80
+	field	CLRLQIPHASE_NLQ	0x40
+	field	CLRLIQABORT	0x20
+	field	CLRLQICRCI_LQ	0x10
+	field	CLRLQICRCI_NLQ	0x08
+	field	CLRLQIBADLQI	0x04
+	field	CLRLQIOVERI_LQ	0x02
+	field	CLRLQIOVERI_NLQ	0x01
+}
+
+/*
+ * LQI Manager Interrupt Mode 1
+ */
+register LQIMODE1 {
+	address			0x051
+	access_mode	RW
+	modes		M_CFG
+	field	ENLQIPHASE_LQ	0x80	/* LQIPHASE1 */
+	field	ENLQIPHASE_NLQ	0x40	/* LQIPHASE2 */
+	field	ENLIQABORT	0x20
+	field	ENLQICRCI_LQ	0x10	/* LQICRCI1 */
+	field	ENLQICRCI_NLQ	0x08	/* LQICRCI2 */
+	field	ENLQIBADLQI	0x04
+	field	ENLQIOVERI_LQ	0x02	/* LQIOVERI1 */
+	field	ENLQIOVERI_NLQ	0x01	/* LQIOVERI2 */
+}
+
+/*
+ * LQI Manager Status 2
+ */
+register LQISTAT2 {
+	address			0x052
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	PACKETIZED	0x80
+	field	LQIPHASE_OUTPKT	0x40
+	field	LQIWORKONLQ	0x20
+	field	LQIWAITFIFO	0x10
+	field	LQISTOPPKT	0x08
+	field	LQISTOPLQ	0x04
+	field	LQISTOPCMD	0x02
+	field	LQIGSAVAIL	0x01
+}
+
+/*
+ * SCSI Status 3
+ */
+register SSTAT3 {
+	address			0x053
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	NTRAMPERR	0x02
+	field	OSRAMPERR	0x01
+}
+
+/*
+ * Clear SCSI Status 3
+ */
+register CLRSINT3 {
+	address			0x053
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRNTRAMPERR	0x02
+	field	CLROSRAMPERR	0x01
+}
+
+/*
+ * SCSI Interrupt Mode 3
+ */
+register SIMODE3 {
+	address			0x053
+	access_mode	RW
+	modes		M_CFG
+	field	ENNTRAMPERR	0x02
+	field	ENOSRAMPERR	0x01
+}
+
+/*
+ * LQO Manager Status 0
+ */
+register LQOSTAT0 {
+	address			0x054
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	LQOTARGSCBPERR	0x10
+	field	LQOSTOPT2	0x08
+	field	LQOATNLQ	0x04
+	field	LQOATNPKT	0x02
+	field	LQOTCRC		0x01
+}
+
+/*
+ * Clear LQO Manager interrupt 0
+ */
+register CLRLQOINT0 {
+	address			0x054
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRLQOTARGSCBPERR	0x10
+	field	CLRLQOSTOPT2		0x08
+	field	CLRLQOATNLQ		0x04
+	field	CLRLQOATNPKT		0x02
+	field	CLRLQOTCRC		0x01
+}
+
+/*
+ * LQO Manager Interrupt Mode 0
+ */
+register LQOMODE0 {
+	address			0x054
+	access_mode	RW
+	modes		M_CFG
+	field	ENLQOTARGSCBPERR	0x10
+	field	ENLQOSTOPT2		0x08
+	field	ENLQOATNLQ		0x04
+	field	ENLQOATNPKT		0x02
+	field	ENLQOTCRC		0x01
+}
+
+/*
+ * LQO Manager Status 1
+ */
+register LQOSTAT1 {
+	address			0x055
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	LQOINITSCBPERR	0x10
+	field	LQOSTOPI2	0x08
+	field	LQOBADQAS	0x04
+	field	LQOBUSFREE	0x02
+	field	LQOPHACHGINPKT	0x01
+}
+
+/*
+ * Clear LOQ Interrupt 1
+ */
+register CLRLQOINT1 {
+	address			0x055
+	access_mode	WO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	CLRLQOINITSCBPERR	0x10
+	field	CLRLQOSTOPI2		0x08
+	field	CLRLQOBADQAS		0x04
+	field	CLRLQOBUSFREE		0x02
+	field	CLRLQOPHACHGINPKT	0x01
+}
+
+/*
+ * LQO Manager Interrupt Mode 1
+ */
+register LQOMODE1 {
+	address			0x055
+	access_mode	RW
+	modes		M_CFG
+	field	ENLQOINITSCBPERR	0x10
+	field	ENLQOSTOPI2		0x08
+	field	ENLQOBADQAS		0x04
+	field	ENLQOBUSFREE		0x02
+	field	ENLQOPHACHGINPKT	0x01
+}
+
+/*
+ * LQO Manager Status 2
+ */
+register LQOSTAT2 {
+	address			0x056
+	access_mode	RO
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	LQOPKT		0xE0
+	field	LQOWAITFIFO	0x10
+	field	LQOPHACHGOUTPKT	0x02	/* outside of packet boundaries. */
+	field	LQOSTOP0	0x01	/* Stopped after sending all packets */
+}
+
+/*
+ * Output Synchronizer Space Count
+ */
+register OS_SPACE_CNT {
+	address			0x056
+	access_mode	RO
+	modes		M_CFG
+}
+
+/*
+ * SCSI Interrupt Mode 1
+ * Setting any bit will enable the corresponding function
+ * in SIMODE1 to interrupt via the IRQ pin.
+ */
+register SIMODE1 {
+	address			0x057
+	access_mode	RW
+	modes		M_DFF0, M_DFF1, M_SCSI
+	field	ENSELTIMO	0x80
+	field	ENATNTARG	0x40
+	field	ENSCSIRST	0x20
+	field	ENPHASEMIS	0x10
+	field	ENBUSFREE	0x08
+	field	ENSCSIPERR	0x04
+	field	ENSTRB2FAST	0x02
+	field	ENREQINIT	0x01
+}
+
+/*
+ * Good Status FIFO
+ */
+register GSFIFO {
+	address			0x058
+	access_mode	RO
+	size		2
+	modes		M_DFF0, M_DFF1, M_SCSI
+}
+
+/*
+ * Data FIFO SCSI Transfer Control
+ */
+register DFFSXFRCTL {
+	address			0x05A
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	DFFBITBUCKET	0x08
+	field	CLRSHCNT	0x04
+	field	CLRCHN		0x02
+	field	RSTCHN		0x01
+}
+
+/*
+ * Next SCSI Control Block
+ */
+register NEXTSCB {
+	address			0x05A
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/* Rev B only. */
+register LQOSCSCTL {
+	address			0x05A
+	access_mode	RW
+	size		1
+	modes		M_CFG
+	field		LQOH2A_VERSION	0x80
+	field		LQONOCHKOVER	0x01
+}
+
+/*
+ * SEQ Interrupts
+ */
+register SEQINTSRC {
+	address			0x05B
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	CTXTDONE	0x40
+	field	SAVEPTRS	0x20
+	field	CFG4DATA	0x10
+	field	CFG4ISTAT	0x08
+	field	CFG4TSTAT	0x04
+	field	CFG4ICMD	0x02
+	field	CFG4TCMD	0x01
+}
+
+/*
+ * Clear Arp Interrupts
+ */
+register CLRSEQINTSRC {
+	address			0x05B
+	access_mode	WO
+	modes		M_DFF0, M_DFF1
+	field	CLRCTXTDONE	0x40
+	field	CLRSAVEPTRS	0x20
+	field	CLRCFG4DATA	0x10
+	field	CLRCFG4ISTAT	0x08
+	field	CLRCFG4TSTAT	0x04
+	field	CLRCFG4ICMD	0x02
+	field	CLRCFG4TCMD	0x01
+}
+
+/*
+ * SEQ Interrupt Enabled (Shared)
+ */
+register SEQIMODE {
+	address			0x05C
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	ENCTXTDONE	0x40
+	field	ENSAVEPTRS	0x20
+	field	ENCFG4DATA	0x10
+	field	ENCFG4ISTAT	0x08
+	field	ENCFG4TSTAT	0x04
+	field	ENCFG4ICMD	0x02
+	field	ENCFG4TCMD	0x01
+}
+
+/*
+ * Current SCSI Control Block
+ */
+register CURRSCB {
+	address			0x05C
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * Data FIFO Status
+ */
+register MDFFSTAT {
+	address			0x05D
+	access_mode	RO
+	modes		M_DFF0, M_DFF1
+	field	SHCNTNEGATIVE	0x40 /* Rev B or higher */
+	field	SHCNTMINUS1	0x20 /* Rev B or higher */
+	field	LASTSDONE	0x10
+	field	SHVALID		0x08
+	field	DLZERO		0x04 /* FIFO data ends on packet boundary. */
+	field	DATAINFIFO	0x02
+	field	FIFOFREE	0x01
+}
+
+/*
+ * CRC Control
+ */
+register CRCCONTROL {
+	address			0x05d
+	access_mode	RW
+	modes		M_CFG
+	field	CRCVALCHKEN		0x40
+}
+
+/*
+ * SCSI Test Control
+ */
+register SCSITEST {
+	address			0x05E
+	access_mode	RW
+	modes		M_CFG
+	field	CNTRTEST	0x08
+	field	SEL_TXPLL_DEBUG	0x04
+}
+
+/*
+ * Data FIFO Queue Tag
+ */
+register DFFTAG {
+	address			0x05E
+	access_mode	RW
+	size		2
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Last SCSI Control Block
+ */
+register LASTSCB {
+	address			0x05E
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * SCSI I/O Cell Power-down Control
+ */
+register IOPDNCTL {
+	address			0x05F
+	access_mode	RW
+	modes		M_CFG
+	field	DISABLE_OE	0x80
+	field	PDN_IDIST	0x04
+	field	PDN_DIFFSENSE	0x01
+}
+
+/*
+ * Shaddow Host Address.
+ */
+register SHADDR {
+	address			0x060
+	access_mode	RO
+	size		8
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Data Group CRC Interval.
+ */
+register DGRPCRCI {
+	address			0x060
+	access_mode	RW
+	size		2
+	modes		M_CFG
+}
+
+/*
+ * Data Transfer Negotiation Address
+ */
+register NEGOADDR {
+	address			0x060
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Data Transfer Negotiation Data - Period Byte
+ */
+register NEGPERIOD {
+	address			0x061
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Packetized CRC Interval
+ */
+register PACKCRCI {
+	address			0x062
+	access_mode	RW
+	size		2
+	modes		M_CFG
+}
+
+/*
+ * Data Transfer Negotiation Data - Offset Byte
+ */
+register NEGOFFSET {
+	address			0x062
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Data Transfer Negotiation Data - PPR Options
+ */
+register NEGPPROPTS {
+	address			0x063
+	access_mode	RW
+	modes		M_SCSI
+	field	PPROPT_PACE	0x08
+	field	PPROPT_QAS	0x04
+	field	PPROPT_DT	0x02
+	field	PPROPT_IUT	0x01
+}
+
+/*
+ * Data Transfer Negotiation Data -  Connection Options
+ */
+register NEGCONOPTS {
+	address			0x064
+	access_mode	RW
+	modes		M_SCSI
+	field	ENSNAPSHOT	0x40
+	field	RTI_WRTDIS	0x20
+	field	RTI_OVRDTRN	0x10
+	field	ENSLOWCRC	0x08
+	field	ENAUTOATNI	0x04
+	field	ENAUTOATNO	0x02
+	field	WIDEXFER	0x01
+}
+
+/*
+ * Negotiation Table Annex Column Index.
+ */
+register ANNEXCOL {
+	address			0x065
+	access_mode	RW
+	modes		M_SCSI
+}
+
+register SCSCHKN {
+	address			0x066
+	access_mode	RW
+	modes		M_CFG
+	field	STSELSKIDDIS	0x40
+	field	CURRFIFODEF	0x20
+	field	WIDERESEN	0x10
+	field	SDONEMSKDIS	0x08
+	field	DFFACTCLR	0x04
+	field	SHVALIDSTDIS	0x02
+	field	LSTSGCLRDIS	0x01
+}
+
+const AHD_ANNEXCOL_PER_DEV0	4
+const AHD_NUM_PER_DEV_ANNEXCOLS	4
+const AHD_ANNEXCOL_PRECOMP_SLEW	4
+const	AHD_PRECOMP_MASK	0x07
+const	AHD_PRECOMP_SHIFT	0
+const	AHD_PRECOMP_CUTBACK_17	0x04
+const	AHD_PRECOMP_CUTBACK_29	0x06
+const	AHD_PRECOMP_CUTBACK_37	0x07
+const	AHD_SLEWRATE_MASK	0x78
+const	AHD_SLEWRATE_SHIFT	3
+/*
+ * Rev A has only a single bit (high bit of field) of slew adjustment.
+ * Rev B has 4 bits.  The current default happens to be the same for both.
+ */
+const	AHD_SLEWRATE_DEF_REVA	0x08
+const	AHD_SLEWRATE_DEF_REVB	0x08
+
+/* Rev A does not have any amplitude setting. */
+const AHD_ANNEXCOL_AMPLITUDE	6
+const	AHD_AMPLITUDE_MASK	0x7
+const	AHD_AMPLITUDE_SHIFT	0
+const	AHD_AMPLITUDE_DEF	0x7
+
+/*
+ * Negotiation Table Annex Data Port.
+ */
+register ANNEXDAT {
+	address			0x066
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Initiator's Own Id.
+ * The SCSI ID to use for Selection Out and seen during a reselection..
+ */
+register IOWNID {
+	address			0x067
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * 960MHz Phase-Locked Loop Control 0
+ */
+register PLL960CTL0 {
+	address			0x068
+	access_mode	RW
+	modes		M_CFG
+	field	PLL_VCOSEL	0x80
+	field	PLL_PWDN	0x40
+	field	PLL_NS		0x30
+	field	PLL_ENLUD	0x08
+	field	PLL_ENLPF	0x04
+	field	PLL_DLPF	0x02
+	field	PLL_ENFBM	0x01
+}
+
+/*
+ * Target Own Id
+ */
+register TOWNID {
+	address			0x069
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * 960MHz Phase-Locked Loop Control 1
+ */
+register PLL960CTL1 {
+	address			0x069
+	access_mode	RW
+	modes		M_CFG
+	field	PLL_CNTEN	0x80
+	field	PLL_CNTCLR	0x40
+	field	PLL_RST		0x01
+}
+
+/*
+ * Expander Signature
+ */
+register XSIG {
+	address			0x06A
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Shadow Byte Count
+ */
+register SHCNT {
+	address			0x068
+	access_mode	RW
+	size		3
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Selection Out ID
+ */
+register SELOID {
+	address			0x06B
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * 960-MHz Phase-Locked Loop Test Count
+ */
+register PLL960CNT0 {
+	address			0x06A
+	access_mode	RO
+	size		2
+	modes		M_CFG
+}
+
+/*
+ * 400-MHz Phase-Locked Loop Control 0
+ */
+register PLL400CTL0 {
+	address			0x06C
+	access_mode	RW
+	modes		M_CFG
+	field	PLL_VCOSEL	0x80
+	field	PLL_PWDN	0x40
+	field	PLL_NS		0x30
+	field	PLL_ENLUD	0x08
+	field	PLL_ENLPF	0x04
+	field	PLL_DLPF	0x02
+	field	PLL_ENFBM	0x01
+}
+
+/*
+ * Arbitration Fairness
+ */
+register FAIRNESS {
+	address			0x06C
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * 400-MHz Phase-Locked Loop Control 1
+ */
+register PLL400CTL1 {
+	address			0x06D
+	access_mode	RW
+	modes		M_CFG
+	field	PLL_CNTEN	0x80
+	field	PLL_CNTCLR	0x40
+	field	PLL_RST		0x01
+}
+
+/*
+ * Arbitration Unfairness
+ */
+register UNFAIRNESS {
+	address			0x06E
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * 400-MHz Phase-Locked Loop Test Count
+ */
+register PLL400CNT0 {
+	address			0x06E
+	access_mode	RO
+	size		2
+	modes		M_CFG
+}
+
+/*
+ * SCB Page Pointer
+ */
+register SCBPTR {
+	address			0x0A8
+	access_mode	RW
+	size		2
+	modes		M_DFF0, M_DFF1, M_CCHAN, M_SCSI
+}
+
+/*
+ * CMC SCB Array Count
+ * Number of bytes to transfer between CMC SCB memory and SCBRAM.
+ * Transfers must be 8byte aligned and sized.
+ */
+register CCSCBACNT {
+	address			0x0AB
+	access_mode	RW
+	modes		M_CCHAN
+}
+
+/*
+ * SCB Autopointer
+ * SCB-Next Address Snooping logic.  When an SCB is transferred to
+ * the card, the next SCB address to be used by the CMC array can
+ * be autoloaded from that transfer.
+ */
+register SCBAUTOPTR {
+	address			0x0AB
+	access_mode	RW
+	modes		M_CFG
+	field	AUSCBPTR_EN	0x80
+	field	SCBPTR_ADDR	0x38
+	field	SCBPTR_OFF	0x07
+}
+
+/*
+ * CMC SG Ram Address Pointer
+ */
+register CCSGADDR {
+	address			0x0AC
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * CMC SCB RAM Address Pointer
+ */
+register CCSCBADDR {
+	address			0x0AC
+	access_mode	RW
+	modes		M_CCHAN
+}
+
+/*
+ * CMC SCB Ram Back-up Address Pointer
+ * Indicates the true stop location of transfers halted prior
+ * to SCBHCNT going to 0.
+ */
+register CCSCBADR_BK {
+	address			0x0AC
+	access_mode	RO
+	modes		M_CFG
+}
+
+/*
+ * CMC SG Control
+ */
+register CCSGCTL {
+	address			0x0AD
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	CCSGDONE	0x80
+	field	SG_CACHE_AVAIL	0x10
+	field	CCSGENACK	0x08
+	mask	CCSGEN		0x0C
+	field	SG_FETCH_REQ	0x02
+	field	CCSGRESET	0x01
+}
+
+/*
+ * CMD SCB Control
+ */
+register CCSCBCTL {
+	address			0x0AD
+	access_mode	RW
+	modes		M_CCHAN
+	field	CCSCBDONE	0x80
+	field	ARRDONE		0x40
+	field	CCARREN		0x10
+	field	CCSCBEN		0x08
+	field	CCSCBDIR	0x04
+	field	CCSCBRESET	0x01
+}
+
+/*
+ * CMC Ram BIST
+ */
+register CMC_RAMBIST {
+	address			0x0AD
+	access_mode	RW
+	modes		M_CFG
+	field	SG_ELEMENT_SIZE		0x80
+	field	SCBRAMBIST_FAIL		0x40
+	field	SG_BIST_FAIL		0x20
+	field	SG_BIST_EN		0x10
+	field	CMC_BUFFER_BIST_FAIL	0x02
+	field	CMC_BUFFER_BIST_EN	0x01
+}
+
+/*
+ * CMC SG RAM Data Port
+ */
+register CCSGRAM {
+	address			0x0B0
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * CMC SCB RAM Data Port
+ */
+register CCSCBRAM {
+	address			0x0B0
+	access_mode	RW
+	modes		M_CCHAN
+}
+
+/*
+ * Flex DMA Address.
+ */
+register FLEXADR {
+	address			0x0B0
+	access_mode	RW
+	size		3
+	modes		M_SCSI
+}
+
+/*
+ * Flex DMA Byte Count
+ */
+register FLEXCNT {
+	address			0x0B3
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * Flex DMA Status
+ */
+register FLEXDMASTAT {
+	address			0x0B5
+	access_mode	RW
+	modes		M_SCSI
+	field	FLEXDMAERR	0x02
+	field	FLEXDMADONE	0x01
+}
+
+/*
+ * Flex DMA Data Port
+ */
+register FLEXDATA {
+	address			0x0B6
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Board Data
+ */
+register BRDDAT {
+	address			0x0B8
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Board Control
+ */
+register BRDCTL {
+	address			0x0B9
+	access_mode	RW
+	modes		M_SCSI
+	field	FLXARBACK	0x80
+	field	FLXARBREQ	0x40
+	field	BRDADDR		0x38
+	field	BRDEN		0x04
+	field	BRDRW		0x02
+	field	BRDSTB		0x01
+}
+
+/*
+ * Serial EEPROM Address
+ */
+register SEEADR {
+	address			0x0BA
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Serial EEPROM Data
+ */
+register SEEDAT {
+	address			0x0BC
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * Serial EEPROM Status
+ */
+register SEESTAT {
+	address			0x0BE
+	access_mode	RO
+	modes		M_SCSI
+	field	INIT_DONE	0x80
+	field	SEEOPCODE	0x70
+	field	LDALTID_L	0x08
+	field	SEEARBACK	0x04
+	field	SEEBUSY		0x02
+	field	SEESTART	0x01
+}
+
+/*
+ * Serial EEPROM Control
+ */
+register SEECTL {
+	address			0x0BE
+	access_mode	RW
+	modes		M_SCSI
+	field	SEEOPCODE	0x70 {
+		SEEOP_ERASE	0x70,
+		SEEOP_READ	0x60,
+		SEEOP_WRITE	0x50,
+	/*
+	 * The following four commands use special
+	 * addresses for differentiation.
+	 */
+		SEEOP_ERAL	0x40
+	}
+	mask	SEEOP_EWEN	0x40
+	mask	SEEOP_WALL	0x40
+	mask	SEEOP_EWDS	0x40
+	field	SEERST		0x02
+	field	SEESTART	0x01
+}
+
+const SEEOP_ERAL_ADDR	0x80
+const SEEOP_EWEN_ADDR	0xC0
+const SEEOP_WRAL_ADDR	0x40
+const SEEOP_EWDS_ADDR	0x00
+
+/*
+ * SCB Counter
+ */
+register SCBCNT {
+	address			0x0BF
+	access_mode	RW
+	modes		M_SCSI
+}
+
+/*
+ * Data FIFO Write Address
+ * Pointer to the next QWD location to be written to the data FIFO.
+ */
+register DFWADDR {
+	address			0x0C0
+	access_mode	RW
+	size		2
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * DSP Filter Control
+ */
+register DSPFLTRCTL {
+	address			0x0C0
+	access_mode	RW
+	modes		M_CFG
+	field	FLTRDISABLE	0x20
+	field	EDGESENSE	0x10
+	field	DSPFCNTSEL	0x0F
+}
+
+/*
+ * DSP Data Channel Control
+ */
+register DSPDATACTL {
+	address			0x0C1
+	access_mode	RW
+	modes		M_CFG
+	field	BYPASSENAB	0x80
+	field	DESQDIS		0x10
+	field	RCVROFFSTDIS	0x04
+	field	XMITOFFSTDIS	0x02
+}
+
+/*
+ * Data FIFO Read Address
+ * Pointer to the next QWD location to be read from the data FIFO.
+ */
+register DFRADDR {
+	address			0x0C2
+	access_mode	RW
+	size		2
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * DSP REQ Control
+ */
+register DSPREQCTL {
+	address			0x0C2
+	access_mode	RW
+	modes		M_CFG
+	field	MANREQCTL	0xC0
+	field	MANREQDLY	0x3F
+}
+
+/*
+ * DSP ACK Control
+ */
+register DSPACKCTL {
+	address			0x0C3
+	access_mode	RW
+	modes		M_CFG
+	field	MANACKCTL	0xC0
+	field	MANACKDLY	0x3F
+}
+
+/*
+ * Data FIFO Data
+ * Read/Write byte port into the data FIFO.  The read and write
+ * FIFO pointers increment with each read and write respectively
+ * to this port.
+ */
+register DFDAT {
+	address			0x0C4
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * DSP Channel Select
+ */
+register DSPSELECT {
+	address			0x0C4
+	access_mode	RW
+	modes		M_CFG
+	field	AUTOINCEN	0x80
+	field	DSPSEL		0x1F
+}
+
+const NUMDSPS 0x14
+
+/*
+ * Write Bias Control
+ */
+register WRTBIASCTL {
+	address			0x0C5
+	access_mode	WO
+	modes		M_CFG
+	field	AUTOXBCDIS	0x80
+	field	XMITMANVAL	0x3F
+}
+
+/*
+ * Currently the WRTBIASCTL is the same as the default.
+ */
+const WRTBIASCTL_HP_DEFAULT 0x0
+
+/*
+ * Receiver Bias Control
+ */
+register RCVRBIOSCTL {
+	address			0x0C6
+	access_mode	WO
+	modes		M_CFG
+	field	AUTORBCDIS	0x80
+	field	RCVRMANVAL	0x3F
+}
+
+/*
+ * Write Bias Calculator
+ */
+register WRTBIASCALC {
+	address			0x0C7
+	access_mode	RO
+	modes		M_CFG
+}
+
+/*
+ * Data FIFO Pointers
+ * Contains the byte offset from DFWADDR and DWRADDR to the current
+ * FIFO write/read locations.
+ */
+register DFPTRS {
+	address			0x0C8
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Receiver Bias Calculator
+ */
+register RCVRBIASCALC {
+	address			0x0C8
+	access_mode	RO
+	modes		M_CFG
+}
+
+/*
+ * Data FIFO Backup Read Pointer
+ * Contains the data FIFO address to be restored if the last
+ * data accessed from the data FIFO was not transferred successfully.
+ */
+register DFBKPTR {
+	address			0x0C9
+	access_mode	RW
+	size		2
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Skew Calculator
+ */
+register SKEWCALC {
+	address			0x0C9
+	access_mode	RO
+	modes		M_CFG
+}
+
+/*
+ * Data FIFO Debug Control
+ */
+register DFDBCTL {
+	address				0x0CB
+	access_mode	RW
+	modes		M_DFF0, M_DFF1
+	field	DFF_CIO_WR_RDY		0x20
+	field	DFF_CIO_RD_RDY		0x10
+	field	DFF_DIR_ERR		0x08
+	field	DFF_RAMBIST_FAIL	0x04
+	field	DFF_RAMBIST_DONE	0x02
+	field	DFF_RAMBIST_EN		0x01
+}
+
+/*
+ * Data FIFO Space Count
+ * Number of FIFO locations that are free.
+ */
+register DFSCNT {
+	address			0x0CC
+	access_mode	RO
+	size		2
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Data FIFO Byte Count
+ * Number of filled FIFO locations.
+ */
+register DFBCNT {
+	address			0x0CE
+	access_mode	RO
+	size		2
+	modes		M_DFF0, M_DFF1
+}
+
+/*
+ * Sequencer Program Overlay Address.
+ * Low address must be written prior to high address.
+ */
+register OVLYADDR {
+	address			0x0D4
+	modes		M_SCSI
+	size		2
+	access_mode	RW
+}
+
+/*
+ * Sequencer Control 0
+ * Error detection mode, speed configuration,
+ * single step, breakpoints and program load.
+ */
+register SEQCTL0 {
+	address			0x0D6
+	access_mode RW
+	field	PERRORDIS	0x80
+	field	PAUSEDIS	0x40
+	field	FAILDIS		0x20
+	field	FASTMODE	0x10
+	field	BRKADRINTEN	0x08
+	field	STEP		0x04
+	field	SEQRESET	0x02
+	field	LOADRAM		0x01
+}
+
+/*
+ * Sequencer Control 1
+ * Instruction RAM Diagnostics
+ */
+register SEQCTL1 {
+	address			0x0D7
+	access_mode RW
+	field	OVRLAY_DATA_CHK	0x08
+	field	RAMBIST_DONE	0x04
+	field	RAMBIST_FAIL	0x02
+	field	RAMBIST_EN	0x01
+}
+
+/*
+ * Sequencer Flags
+ * Zero and Carry state of the ALU.
+ */
+register FLAGS {
+	address			0x0D8
+	access_mode RO
+	field	ZERO		0x02
+	field	CARRY		0x01
+}
+
+/*
+ * Sequencer Interrupt Control
+ */ 
+register SEQINTCTL {
+	address			0x0D9
+	access_mode RW
+	field	INTVEC1DSL	0x80
+	field	INT1_CONTEXT	0x20
+	field	SCS_SEQ_INT1M1	0x10
+	field	SCS_SEQ_INT1M0	0x08
+	field	INTMASK2	0x04
+	field	INTMASK1	0x02
+	field	IRET		0x01
+}
+
+/*
+ * Sequencer RAM Data Port
+ * Single byte window into the Sequencer Instruction Ram area starting
+ * at the address specified by OVLYADDR.  To write a full instruction word,
+ * simply write four bytes in succession.  OVLYADDR will increment after the
+ * most significant instrution byte (the byte with the parity bit) is written.
+ */
+register SEQRAM {
+	address			0x0DA
+	access_mode RW
+}
+
+/*
+ * Sequencer Program Counter
+ * Low byte must be written prior to high byte.
+ */
+register PRGMCNT {
+	address			0x0DE
+	access_mode	RW
+	size		2
+}
+
+/*
+ * Accumulator
+ */
+register ACCUM {
+	address			0x0E0
+	access_mode RW
+	accumulator
+}
+
+/*
+ * Source Index Register
+ * Incrementing index for reads of SINDIR and the destination (low byte only)
+ * for any immediate operands passed in jmp, jc, jnc, call instructions.
+ * Example:
+ *		mvi	0xFF	call some_routine;
+ *
+ *  Will set SINDEX[0] to 0xFF and call the routine "some_routine.
+ */
+register SINDEX	{
+	address			0x0E2
+	access_mode	RW
+	size		2
+	sindex
+}
+
+/*
+ * Destination Index Register
+ * Incrementing index for writes to DINDIR.  Can be used as a scratch register.
+ */
+register DINDEX {
+	address			0x0E4
+	access_mode	RW
+	size		2
+}
+
+/*
+ * Break Address
+ * Sequencer instruction breakpoint address address.
+ */
+register BRKADDR0 {
+	address			0x0E6
+	access_mode	RW
+}
+
+register BRKADDR1 {
+	address			0x0E6
+	access_mode	RW
+	field	BRKDIS		0x80	/* Disable Breakpoint */
+}
+
+/*
+ * All Ones
+ * All reads to this register return the value 0xFF.
+ */
+register ALLONES {
+	address			0x0E8
+	access_mode RO
+	allones
+}
+
+/*
+ * All Zeros
+ * All reads to this register return the value 0.
+ */
+register ALLZEROS {
+	address			0x0EA
+	access_mode RO
+	allzeros
+}
+
+/*
+ * No Destination
+ * Writes to this register have no effect.
+ */
+register NONE {
+	address			0x0EA
+	access_mode WO
+	none
+}
+
+/*
+ * Source Index Indirect
+ * Reading this register is equivalent to reading (register_base + SINDEX) and
+ * incrementing SINDEX by 1.
+ */
+register SINDIR	{
+	address			0x0EC
+	access_mode RO
+}
+
+/*
+ * Destination Index Indirect
+ * Writing this register is equivalent to writing to (register_base + DINDEX)
+ * and incrementing DINDEX by 1.
+ */
+register DINDIR	 {
+	address			0x0ED
+	access_mode WO
+}
+
+/*
+ * Function One
+ * 2's complement to bit value conversion.  Write the 2's complement value
+ * (0-7 only) to the top nibble and retrieve the bit indexed by that value
+ * on the next read of this register. 
+ * Example:
+ *	Write	0x60
+ *	Read	0x40
+ */
+register FUNCTION1 {
+	address			0x0F0
+	access_mode RW
+}
+
+/*
+ * Stack
+ * Window into the stack.  Each stack location is 10 bits wide reported
+ * low byte followed by high byte.  There are 8 stack locations.
+ */
+register STACK {
+	address			0x0F2
+	access_mode RW
+}
+
+/*
+ * Interrupt Vector 1 Address
+ * Interrupt branch address for SCS SEQ_INT1 mode 0 and 1 interrupts.
+ */
+register INTVEC1_ADDR {
+	address			0x0F4
+	access_mode	RW
+	size		2
+	modes		M_CFG
+}
+
+/*
+ * Current Address
+ * Address of the SEQRAM instruction currently executing instruction.
+ */
+register CURADDR {
+	address			0x0F4
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+/*
+ * Interrupt Vector 2 Address
+ * Interrupt branch address for HST_SEQ_INT2 interrupts.
+ */
+register INTVEC2_ADDR {
+	address			0x0F6
+	access_mode	RW
+	size		2
+	modes		M_CFG
+}
+
+/*
+ * Last Address
+ * Address of the SEQRAM instruction executed prior to the current instruction.
+ */
+register LASTADDR {
+	address			0x0F6
+	access_mode	RW
+	size		2
+	modes		M_SCSI
+}
+
+register AHD_PCI_CONFIG_BASE {
+	address			0x100
+	access_mode	RW
+	size		256
+	modes		M_CFG
+}
+
+/* ---------------------- Scratch RAM Offsets ------------------------- */
+scratch_ram {
+	/* Mode Specific */
+	address			0x0A0
+	size	8
+	modes	0, 1, 2, 3
+	REG0 {
+		size		2
+	}
+	REG1 {
+		size		2
+	}
+	REG_ISR {
+		size		2
+	}
+	SG_STATE {
+		size		1
+		field	SEGS_AVAIL	0x01
+		field	LOADING_NEEDED	0x02
+		field	FETCH_INPROG	0x04
+	}
+	/*
+	 * Track whether the transfer byte count for
+	 * the current data phase is odd.
+	 */
+	DATA_COUNT_ODD {
+		size		1
+	}
+}
+
+scratch_ram {
+	/* Mode Specific */
+	address			0x0F8
+	size	8
+	modes	0, 1, 2, 3
+	LONGJMP_ADDR {
+		size		2
+	}
+	ACCUM_SAVE {
+		size		1
+	}
+}
+
+
+scratch_ram {
+	address			0x100
+	size	128
+	modes	0, 1, 2, 3
+	/*
+	 * Per "other-id" execution queues.  We use an array of
+	 * tail pointers into lists of SCBs sorted by "other-id".
+	 * The execution head pointer threads the head SCBs for
+	 * each list.
+	 */
+	WAITING_SCB_TAILS {
+		size		32
+	}
+	WAITING_TID_HEAD {
+		size		2
+	}
+	WAITING_TID_TAIL {
+		size		2
+	}
+	/*
+	 * SCBID of the next SCB in the new SCB queue.
+	 */
+	NEXT_QUEUED_SCB_ADDR {
+		size		4
+	}
+	/*
+	 * head of list of SCBs that have
+	 * completed but have not been
+	 * put into the qoutfifo.
+	 */
+	COMPLETE_SCB_HEAD {
+		size		2
+	}
+	/*
+	 * The list of completed SCBs in
+	 * the active DMA.
+	 */
+	COMPLETE_SCB_DMAINPROG_HEAD {
+		size		2
+	}
+	/*
+	 * head of list of SCBs that have
+	 * completed but need to be uploaded
+	 * to the host prior to being completed.
+	 */
+	COMPLETE_DMA_SCB_HEAD {
+		size		2
+	}
+	/* Counting semaphore to prevent new select-outs */
+	QFREEZE_COUNT {
+		size		2
+	}
+	/*
+	 * Mode to restore on legacy idle loop exit.
+	 */
+	SAVED_MODE {
+		size		1
+	}
+	/*
+	 * Single byte buffer used to designate the type or message
+	 * to send to a target.
+	 */
+	MSG_OUT {
+		size		1
+	}
+	/* Parameters for DMA Logic */
+	DMAPARAMS {
+		size		1
+		field	PRELOADEN	0x80
+		field	WIDEODD		0x40
+		field	SCSIEN		0x20
+		field	SDMAEN		0x10
+		field	SDMAENACK	0x10
+		field	HDMAEN		0x08
+		field	HDMAENACK	0x08
+		field	DIRECTION	0x04	/* Set indicates PCI->SCSI */
+		field	FIFOFLUSH	0x02
+		field	FIFORESET	0x01
+	}
+	SEQ_FLAGS {
+		size		1
+		field	NOT_IDENTIFIED		0x80
+		field	NO_CDB_SENT		0x40
+		field	TARGET_CMD_IS_TAGGED	0x40
+		field	DPHASE			0x20
+		/* Target flags */
+		field	TARG_CMD_PENDING	0x10
+		field	CMDPHASE_PENDING	0x08
+		field	DPHASE_PENDING		0x04
+		field	SPHASE_PENDING		0x02
+		field	NO_DISCONNECT		0x01
+	}
+	/*
+	 * Temporary storage for the
+	 * target/channel/lun of a
+	 * reconnecting target
+	 */
+	SAVED_SCSIID {
+		size		1
+	}
+	SAVED_LUN {
+		size		1
+	}
+	/*
+	 * The last bus phase as seen by the sequencer. 
+	 */
+	LASTPHASE {
+		size		1
+		field	CDI		0x80
+		field	IOI		0x40
+		field	MSGI		0x20
+		field	P_BUSFREE	0x01
+		enum	PHASE_MASK  CDO|IOO|MSGO {
+			P_DATAOUT	0x0,
+			P_DATAIN	IOO,
+			P_DATAOUT_DT	P_DATAOUT|MSGO,
+			P_DATAIN_DT	P_DATAIN|MSGO,
+			P_COMMAND	CDO,
+			P_MESGOUT	CDO|MSGO,
+			P_STATUS	CDO|IOO,
+			P_MESGIN	CDO|IOO|MSGO
+		}
+	}
+	/*
+	 * Value to "or" into the SCBPTR[1] value to
+	 * indicate that an entry in the QINFIFO is valid.
+	 */
+	QOUTFIFO_ENTRY_VALID_TAG {
+		size		1
+	}
+	/*
+	 * Base address of our shared data with the kernel driver in host
+	 * memory.  This includes the qoutfifo and target mode
+	 * incoming command queue.
+	 */
+	SHARED_DATA_ADDR {
+		size		4
+	}
+	/*
+	 * Pointer to location in host memory for next
+	 * position in the qoutfifo.
+	 */
+	QOUTFIFO_NEXT_ADDR {
+		size		4
+	}
+	/*
+	 * Kernel and sequencer offsets into the queue of
+	 * incoming target mode command descriptors.  The
+	 * queue is full when the KERNEL_TQINPOS == TQINPOS.
+	 */
+	KERNEL_TQINPOS {
+		size		1
+	}
+	TQINPOS {                
+		size		1
+	}
+	ARG_1 {
+		size		1
+		mask	SEND_MSG		0x80
+		mask	SEND_SENSE		0x40
+		mask	SEND_REJ		0x20
+		mask	MSGOUT_PHASEMIS		0x10
+		mask	EXIT_MSG_LOOP		0x08
+		mask	CONT_MSG_LOOP_WRITE	0x04
+		mask	CONT_MSG_LOOP_READ	0x03
+		mask	CONT_MSG_LOOP_TARG	0x02
+		alias	RETURN_1
+	}
+	ARG_2 {
+		size		1
+		alias	RETURN_2
+	}
+
+	/*
+	 * Snapshot of MSG_OUT taken after each message is sent.
+	 */
+	LAST_MSG {
+		size		1
+	}
+
+	/*
+	 * Sequences the kernel driver has okayed for us.  This allows
+	 * the driver to do things like prevent initiator or target
+	 * operations.
+	 */
+	SCSISEQ_TEMPLATE {
+		size		1
+		field	MANUALCTL	0x40
+		field	ENSELI		0x20
+		field	ENRSELI		0x10
+		field	MANUALP		0x0C
+		field	ENAUTOATNP	0x02
+		field	ALTSTIM		0x01
+	}
+
+	/*
+	 * The initiator specified tag for this target mode transaction.
+	 */
+	INITIATOR_TAG {
+		size		1
+	}
+
+	SEQ_FLAGS2 {
+		size		1
+		field	TARGET_MSG_PENDING	  0x02
+		field	SELECTOUT_QFROZEN	  0x04
+	}
+
+	ALLOCFIFO_SCBPTR {
+		size		2
+	}
+
+	/*
+	 * The maximum amount of time to wait, when interrupt coalescing
+	 * is enabled, before issueing a CMDCMPLT interrupt for a completed
+	 * command.
+	 */
+	INT_COALESCING_TIMER {
+		size		2
+	}
+
+	/*
+	 * The maximum number of commands to coalesce into a single interrupt.
+	 * Actually the 2's complement of that value to simplify sequencer
+	 * code.
+	 */
+	INT_COALESCING_MAXCMDS {
+		size		1
+	}
+
+	/*
+	 * The minimum number of commands still outstanding required
+	 * to continue coalescing (2's complement of value).
+	 */
+	INT_COALESCING_MINCMDS {
+		size		1
+	}
+
+	/*
+	 * Number of commands "in-flight".
+	 */
+	CMDS_PENDING {
+		size		2
+	}
+
+	/*
+	 * The count of commands that have been coalesced.
+	 */
+	INT_COALESCING_CMDCOUNT {
+		size		1
+	}
+
+	/*
+	 * Since the HS_MAIBOX is self clearing, copy its contents to
+	 * this position in scratch ram every time it changes.
+	 */
+	LOCAL_HS_MAILBOX {
+		size		1
+	}
+	/*
+	 * Target-mode CDB type to CDB length table used
+	 * in non-packetized operation.
+	 */
+	CMDSIZE_TABLE {
+		size		8
+	}
+}
+
+/************************* Hardware SCB Definition ****************************/
+scb {
+	address			0x180
+	size	64
+	modes	0, 1, 2, 3
+	SCB_RESIDUAL_DATACNT {
+		size	4
+		alias	SCB_CDB_STORE
+		alias	SCB_HOST_CDB_PTR
+	}
+	SCB_RESIDUAL_SGPTR {
+		size	4
+		field	SG_ADDR_MASK		0xf8	/* In the last byte */
+		field	SG_OVERRUN_RESID	0x02	/* In the first byte */
+		field	SG_LIST_NULL		0x01	/* In the first byte */
+	}
+	SCB_SCSI_STATUS {
+		size	1
+		alias	SCB_HOST_CDB_LEN
+	}
+	SCB_TARGET_PHASES {
+		size	1
+	}
+	SCB_TARGET_DATA_DIR {
+		size	1
+	}
+	SCB_TARGET_ITAG {
+		size	1
+	}
+	SCB_SENSE_BUSADDR {
+		/*
+		 * Only valid if CDB length is less than 13 bytes or
+		 * we are using a CDB pointer.  Otherwise contains
+		 * the last 4 bytes of embedded cdb information.
+		 */
+		size	4
+		alias	SCB_NEXT_COMPLETE
+	}
+	SCB_TAG {
+		alias	SCB_FIFO_USE_COUNT
+		size	2
+	}
+	SCB_CONTROL {
+		size	1
+		field	TARGET_SCB	0x80
+		field	DISCENB		0x40
+		field	TAG_ENB		0x20
+		field	MK_MESSAGE	0x10
+		field	STATUS_RCVD	0x08
+		field	DISCONNECTED	0x04
+		field	SCB_TAG_TYPE	0x03
+	}
+	SCB_SCSIID {
+		size	1
+		field	TID	0xF0
+		field	OID	0x0F
+	}
+	SCB_LUN {
+		size	1
+		field	LID	0xff
+	}
+	SCB_TASK_ATTRIBUTE {
+		size	1
+		/*
+		 * Overloaded field for non-packetized 
+		 * ignore wide residue message handling.
+		 */
+		field	SCB_XFERLEN_ODD	0x01
+	}
+	SCB_CDB_LEN {
+		size	1
+		field	SCB_CDB_LEN_PTR	0x80	/* CDB in host memory */
+	}
+	SCB_TASK_MANAGEMENT {
+		size	1
+	}
+	SCB_DATAPTR {
+		size	8
+	}
+	SCB_DATACNT {
+		/*
+		 * The last byte is really the high address bits for
+		 * the data address.
+		 */
+		size	4
+		field	SG_LAST_SEG		0x80	/* In the fourth byte */
+		field	SG_HIGH_ADDR_BITS	0x7F	/* In the fourth byte */
+	}
+	SCB_SGPTR {
+		size	4
+		field	SG_STATUS_VALID	0x04	/* In the first byte */
+		field	SG_FULL_RESID	0x02	/* In the first byte */
+		field	SG_LIST_NULL	0x01	/* In the first byte */
+	}
+	SCB_BUSADDR {
+		size	4
+	}
+	SCB_NEXT {
+		alias	SCB_NEXT_SCB_BUSADDR
+		size	2
+	}
+	SCB_NEXT2 {
+		size	2
+	}
+	SCB_SPARE {
+		size	8
+		alias	SCB_PKT_LUN
+	}
+	SCB_DISCONNECTED_LISTS {
+		size	8
+	}
+}
+
+/*********************************** Constants ********************************/
+const MK_MESSAGE_BIT_OFFSET	4
+const TID_SHIFT		4
+const TARGET_CMD_CMPLT	0xfe
+const INVALID_ADDR	0x80
+#define SCB_LIST_NULL	0xff
+#define QOUTFIFO_ENTRY_VALID_TOGGLE	0x80
+
+const CCSGADDR_MAX	0x80
+const CCSCBADDR_MAX	0x80
+const CCSGRAM_MAXSEGS	16
+
+/* Selection Timeout Timer Constants */
+const STIMESEL_SHIFT	3
+const STIMESEL_MIN	0x18
+const STIMESEL_BUG_ADJ	0x8
+
+/* WDTR Message values */
+const BUS_8_BIT			0x00
+const BUS_16_BIT		0x01
+const BUS_32_BIT		0x02
+
+/* Offset maximums */
+const MAX_OFFSET		0xfe
+const MAX_OFFSET_PACED		0xfe
+const MAX_OFFSET_PACED_BUG	0x7f
+/*
+ * Some 160 devices incorrectly accept 0xfe as a
+ * sync offset, but will overrun this value.  Limit
+ * to 0x7f for speed lower than U320 which will
+ * avoid the persistent sync offset overruns.
+ */
+const MAX_OFFSET_NON_PACED	0x7f
+const HOST_MSG			0xff
+
+/*
+ * The size of our sense buffers.
+ * Sense buffer mapping can be handled in either of two ways.
+ * The first is to allocate a dmamap for each transaction.
+ * Depending on the architecture, dmamaps can be costly. The
+ * alternative is to statically map the buffers in much the same
+ * way we handle our scatter gather lists.  The driver implements
+ * the later.
+ */
+const AHD_SENSE_BUFSIZE		256
+
+/* Target mode command processing constants */
+const CMD_GROUP_CODE_SHIFT	0x05
+
+const STATUS_BUSY		0x08
+const STATUS_QUEUE_FULL		0x28
+const STATUS_PKT_SENSE		0xFF
+const TARGET_DATA_IN		1
+
+const SCB_TRANSFER_SIZE_FULL_LUN	56
+const SCB_TRANSFER_SIZE_1BYTE_LUN	48
+/* PKT_OVERRUN_BUFSIZE must be a multiple of 256 less than 64K */
+const PKT_OVERRUN_BUFSIZE	512
+
+/*
+ * Timer parameters.
+ */
+const AHD_TIMER_US_PER_TICK	25
+const AHD_TIMER_MAX_TICKS	0xFFFF
+const AHD_TIMER_MAX_US		(AHD_TIMER_MAX_TICKS * AHD_TIMER_US_PER_TICK)
+
+/*
+ * Downloaded (kernel inserted) constants
+ */
+const SG_PREFETCH_CNT download
+const SG_PREFETCH_CNT_LIMIT download
+const SG_PREFETCH_ALIGN_MASK download
+const SG_PREFETCH_ADDR_MASK download
+const SG_SIZEOF download
+const PKT_OVERRUN_BUFOFFSET download
+const SCB_TRANSFER_SIZE	download
+
+/*
+ * BIOS SCB offsets
+ */
+const NVRAM_SCB_OFFSET	0x2C
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic79xx.seq linux-5730/drivers/scsi/aic7xxx/aic79xx.seq
--- linux-5720/drivers/scsi/aic7xxx/aic79xx.seq
+++ linux-5730/drivers/scsi/aic7xxx/aic79xx.seq
@@ -0,0 +1,2032 @@
+/*
+ * Adaptec U320 device driver firmware for Linux and FreeBSD.
+ *
+ * Copyright (c) 1994-2001 Justin T. Gibbs.
+ * Copyright (c) 2000-2002 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $FreeBSD$
+ */
+
+VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#94 $"
+PATCH_ARG_LIST = "struct ahd_softc *ahd"
+PREFIX = "ahd_"
+
+#include "aic79xx.reg"
+#include "scsi_message.h"
+
+restart:
+if ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {
+	test	SEQINTCODE, 0xFF jz idle_loop;
+	SET_SEQINTCODE(NO_SEQINT)
+}
+
+idle_loop:
+
+	if ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {
+		/*
+		 * Convert ERROR status into a sequencer
+		 * interrupt to handle the case of an
+		 * interrupt collision on the hardware
+		 * setting of HWERR.
+		 */
+		test	ERROR, 0xFF jz no_error_set;
+		SET_SEQINTCODE(SAW_HWERR)
+no_error_set:
+	}
+	SET_MODE(M_SCSI, M_SCSI)
+	test	SCSISEQ0, ENSELO|ENARBO jnz idle_loop_checkbus;
+	test	SEQ_FLAGS2, SELECTOUT_QFROZEN jnz idle_loop_checkbus;
+	cmp	WAITING_TID_HEAD[1], SCB_LIST_NULL je idle_loop_checkbus;
+	/*
+	 * ENSELO is cleared by a SELDO, so we must test for SELDO
+	 * one last time.
+	 */
+BEGIN_CRITICAL;
+	test	SSTAT0, SELDO jnz select_out;
+END_CRITICAL;
+	call	start_selection;
+idle_loop_checkbus:
+BEGIN_CRITICAL;
+	test	SSTAT0, SELDO jnz select_out;
+END_CRITICAL;
+	test	SSTAT0, SELDI jnz select_in;
+	test	SCSIPHASE, ~DATA_PHASE_MASK jz idle_loop_check_nonpackreq;
+	test	SCSISIGO, ATNO jz idle_loop_check_nonpackreq;
+	call	unexpected_nonpkt_phase_find_ctxt;
+idle_loop_check_nonpackreq:
+	test	SSTAT2, NONPACKREQ jz . + 2;
+	call	unexpected_nonpkt_phase_find_ctxt;
+	if ((ahd->bugs & AHD_FAINT_LED_BUG) != 0) {
+		and	A, FIFO0FREE|FIFO1FREE, DFFSTAT;
+		cmp	A, FIFO0FREE|FIFO1FREE jne . + 3;
+		and	SBLKCTL, ~DIAGLEDEN|DIAGLEDON;
+		jmp	. + 2;
+		or	SBLKCTL, DIAGLEDEN|DIAGLEDON;
+	}
+	call	idle_loop_gsfifo_in_scsi_mode;
+	call	idle_loop_service_fifos;
+	call	idle_loop_cchan;
+	jmp	idle_loop;
+
+BEGIN_CRITICAL;
+idle_loop_gsfifo:
+	SET_MODE(M_SCSI, M_SCSI)
+idle_loop_gsfifo_in_scsi_mode:
+	test	LQISTAT2, LQIGSAVAIL jz return;
+	/*
+	 * We have received good status for this transaction.  There may
+	 * still be data in our FIFOs draining to the host.  Complete
+	 * the SCB only if all data has transferred to the host.
+	 */
+good_status_IU_done:
+	bmov	SCBPTR, GSFIFO, 2;
+	clr	SCB_SCSI_STATUS;
+	/*
+	 * If a command completed before an attempted task management
+	 * function completed, notify the host after disabling any
+	 * pending select-outs.
+	 */
+	test	SCB_TASK_MANAGEMENT, 0xFF jz gsfifo_complete_normally;
+	test	SSTAT0, SELDO|SELINGO jnz . + 2;
+	and	SCSISEQ0, ~ENSELO;
+	SET_SEQINTCODE(TASKMGMT_CMD_CMPLT_OKAY)
+gsfifo_complete_normally:
+	or	SCB_CONTROL, STATUS_RCVD;
+
+	/*
+	 * Since this status did not consume a FIFO, we have to
+	 * be a bit more dilligent in how we check for FIFOs pertaining
+	 * to this transaction.  There are two states that a FIFO still
+	 * transferring data may be in.
+	 *
+	 * 1) Configured and draining to the host, with a FIFO handler.
+	 * 2) Pending cfg4data, fifo not empty.
+	 *
+	 * Case 1 can be detected by noticing a non-zero FIFO active
+	 * count in the SCB.  In this case, we allow the routine servicing
+	 * the FIFO to complete the SCB.
+	 * 
+	 * Case 2 implies either a pending or yet to occur save data
+	 * pointers for this same context in the other FIFO.  So, if
+	 * we detect case 1, we will properly defer the post of the SCB
+	 * and achieve the desired result.  The pending cfg4data will
+	 * notice that status has been received and complete the SCB.
+	 */
+	test	SCB_FIFO_USE_COUNT, 0xFF jnz idle_loop_gsfifo_in_scsi_mode;
+	call	complete;
+END_CRITICAL;
+	jmp	idle_loop_gsfifo_in_scsi_mode;
+
+idle_loop_service_fifos:
+	SET_MODE(M_DFF0, M_DFF0)
+	test	LONGJMP_ADDR[1], INVALID_ADDR jnz idle_loop_next_fifo;
+	call	longjmp;
+idle_loop_next_fifo:
+	SET_MODE(M_DFF1, M_DFF1)
+	test	LONGJMP_ADDR[1], INVALID_ADDR jz longjmp;
+return:
+	ret;
+
+idle_loop_cchan:
+	SET_MODE(M_CCHAN, M_CCHAN)
+	test	QOFF_CTLSTA, HS_MAILBOX_ACT jz	hs_mailbox_empty;
+	mov	LOCAL_HS_MAILBOX, HS_MAILBOX;
+	or	QOFF_CTLSTA, HS_MAILBOX_ACT;
+hs_mailbox_empty:
+BEGIN_CRITICAL;
+	test	CCSCBCTL, CCARREN|CCSCBEN jz scbdma_idle;
+	test	CCSCBCTL, CCSCBDIR jnz fetch_new_scb_inprog;
+	test	CCSCBCTL, CCSCBDONE jz return;
+END_CRITICAL;
+	/* FALLTHROUGH */
+scbdma_tohost_done:
+	test	CCSCBCTL, CCARREN jz fill_qoutfifo_dmadone;
+	/*
+	 * An SCB has been succesfully uploaded to the host.
+	 * If the SCB was uploaded for some reason other than
+	 * bad SCSI status (currently only for underruns), we
+	 * queue the SCB for normal completion.  Otherwise, we
+	 * wait until any select-out activity has halted, and
+	 * then notify the host so that the transaction can be
+	 * dealt with.
+	 */
+	test	SCB_SCSI_STATUS, 0xff jnz scbdma_notify_host;
+	and	CCSCBCTL, ~(CCARREN|CCSCBEN);
+	bmov	COMPLETE_DMA_SCB_HEAD, SCB_NEXT_COMPLETE, 2;
+	bmov	SCB_NEXT_COMPLETE, COMPLETE_SCB_HEAD, 2;
+	bmov	COMPLETE_SCB_HEAD, SCBPTR, 2 ret;
+scbdma_notify_host:
+	SET_MODE(M_SCSI, M_SCSI)
+	test	SCSISEQ0, ENSELO jnz return;
+	test	SSTAT0, (SELDO|SELINGO) jnz return;
+	SET_MODE(M_CCHAN, M_CCHAN)
+	/*
+	 * Remove SCB and notify host.
+	 */
+	and	CCSCBCTL, ~(CCARREN|CCSCBEN);
+	bmov	COMPLETE_DMA_SCB_HEAD, SCB_NEXT_COMPLETE, 2;
+	SET_SEQINTCODE(BAD_SCB_STATUS)
+	ret;
+fill_qoutfifo_dmadone:
+	and	CCSCBCTL, ~(CCARREN|CCSCBEN);
+	call	qoutfifo_updated;
+	mvi	COMPLETE_SCB_DMAINPROG_HEAD[1], SCB_LIST_NULL;
+	bmov	QOUTFIFO_NEXT_ADDR, SCBHADDR, 4;
+	test	QOFF_CTLSTA, SDSCB_ROLLOVR jz return;
+	bmov	QOUTFIFO_NEXT_ADDR, SHARED_DATA_ADDR, 4;
+	xor	QOUTFIFO_ENTRY_VALID_TAG, QOUTFIFO_ENTRY_VALID_TOGGLE ret;
+
+qoutfifo_updated:
+	/*
+	 * If there are more commands waiting to be dma'ed
+	 * to the host, always coalesce.  Otherwise honor the
+	 * host's wishes.
+	 */
+	cmp	COMPLETE_DMA_SCB_HEAD[1], SCB_LIST_NULL jne coalesce_by_count;
+	cmp	COMPLETE_SCB_HEAD[1], SCB_LIST_NULL jne coalesce_by_count;
+	test	LOCAL_HS_MAILBOX, ENINT_COALESCE jz issue_cmdcmplt;
+
+	/*
+	 * If we have relatively few commands outstanding, don't
+	 * bother waiting for another command to complete.
+	 */
+	test	CMDS_PENDING[1], 0xFF jnz coalesce_by_count;
+	/* Add -1 so that jnc means <= not just < */
+	add	A, -1, INT_COALESCING_MINCMDS;
+	add	NONE, A, CMDS_PENDING;
+	jnc	issue_cmdcmplt;
+	
+	/*
+	 * If coalescing, only coalesce up to the limit
+	 * provided by the host driver.
+	 */
+coalesce_by_count:
+	mov	A, INT_COALESCING_MAXCMDS;
+	add	NONE, A, INT_COALESCING_CMDCOUNT;
+	jc	issue_cmdcmplt;
+	/*
+	 * If the timer is not currently active,
+	 * fire it up.
+	 */
+	test	INTCTL, SWTMINTMASK jz return;
+	bmov	SWTIMER, INT_COALESCING_TIMER, 2;
+	mvi	CLRSEQINTSTAT, CLRSEQ_SWTMRTO;
+	or	INTCTL, SWTMINTEN|SWTIMER_START;
+	and	INTCTL, ~SWTMINTMASK ret;
+
+issue_cmdcmplt:
+	mvi	INTSTAT, CMDCMPLT;
+	clr	INT_COALESCING_CMDCOUNT;
+	or	INTCTL, SWTMINTMASK ret;
+
+BEGIN_CRITICAL;
+fetch_new_scb_inprog:
+	test	CCSCBCTL, ARRDONE jz return;
+fetch_new_scb_done:
+	and	CCSCBCTL, ~(CCARREN|CCSCBEN);
+	bmov	REG0, SCBPTR, 2;
+	clr	A;
+	add	CMDS_PENDING, 1;
+	adc	CMDS_PENDING[1], A;
+	if ((ahd->bugs & AHD_PKT_LUN_BUG) != 0) {
+		/*
+		 * "Short Luns" are not placed into outgoing LQ
+		 * packets in the correct byte order.  Use a full
+		 * sized lun field instead and fill it with the
+		 * one byte of lun information we support.
+		 */
+		mov	SCB_PKT_LUN[6], SCB_LUN;
+	}
+	/*
+	 * The FIFO use count field is shared with the
+	 * tag set by the host so that our SCB dma engine
+	 * knows the correct location to store the SCB.
+	 * Set it to zero before processing the SCB.
+	 */
+	mov	SCB_FIFO_USE_COUNT, ALLZEROS;
+	/* Update the next SCB address to download. */
+	bmov	NEXT_QUEUED_SCB_ADDR, SCB_NEXT_SCB_BUSADDR, 4;
+	mvi	SCB_NEXT[1], SCB_LIST_NULL;
+	mvi	SCB_NEXT2[1], SCB_LIST_NULL;
+	/* Increment our position in the QINFIFO. */
+	mov	NONE, SNSCB_QOFF;
+	/*
+	 * SCBs that want to send messages are always
+	 * queued independently.  This ensures that they
+	 * are at the head of the SCB list to select out
+	 * to a target and we will see the MK_MESSAGE flag.
+	 */
+	test	SCB_CONTROL, MK_MESSAGE jnz first_new_target_scb;
+	shr	SINDEX, 3, SCB_SCSIID;
+	and	SINDEX, ~0x1;
+	mvi	SINDEX[1], (WAITING_SCB_TAILS >> 8);
+	bmov	DINDEX, SINDEX, 2;
+	bmov	SCBPTR, SINDIR, 2;
+	bmov	DINDIR, REG0, 2;
+	cmp	SCBPTR[1], SCB_LIST_NULL je first_new_target_scb;
+	bmov	SCB_NEXT, REG0, 2 ret;
+first_new_target_scb:
+	cmp	WAITING_TID_HEAD[1], SCB_LIST_NULL je first_new_scb;
+	bmov	SCBPTR, WAITING_TID_TAIL, 2;
+	bmov	SCB_NEXT2, REG0, 2;
+	bmov	WAITING_TID_TAIL, REG0, 2 ret;
+first_new_scb:
+	bmov	WAITING_TID_HEAD, REG0, 2;
+	bmov	WAITING_TID_TAIL, REG0, 2 ret;
+END_CRITICAL;
+
+scbdma_idle:
+	/*
+	 * Give precedence to downloading new SCBs to execute
+	 * unless select-outs are currently frozen.
+	 */
+	test	SEQ_FLAGS2, SELECTOUT_QFROZEN jnz . + 2;
+BEGIN_CRITICAL;
+	test	QOFF_CTLSTA, NEW_SCB_AVAIL jnz fetch_new_scb;
+	cmp	COMPLETE_DMA_SCB_HEAD[1], SCB_LIST_NULL jne dma_complete_scb;
+	cmp	COMPLETE_SCB_HEAD[1], SCB_LIST_NULL je return;
+	/* FALLTHROUGH */
+fill_qoutfifo:
+	/*
+	 * Keep track of the SCBs we are dmaing just
+	 * in case the DMA fails or is aborted.
+	 */
+	mov	A, QOUTFIFO_ENTRY_VALID_TAG;
+	bmov	COMPLETE_SCB_DMAINPROG_HEAD, COMPLETE_SCB_HEAD, 2;
+	mvi	CCSCBCTL, CCSCBRESET;
+	bmov	SCBHADDR, QOUTFIFO_NEXT_ADDR, 4;
+	bmov	SCBPTR, COMPLETE_SCB_HEAD, 2;
+fill_qoutfifo_loop:
+	mov	CCSCBRAM, SCBPTR;
+	or	CCSCBRAM, A, SCBPTR[1];
+	mov	NONE, SDSCB_QOFF;
+	inc	INT_COALESCING_CMDCOUNT;
+	add	CMDS_PENDING, -1;
+	adc	CMDS_PENDING[1], -1;
+	cmp	SCB_NEXT_COMPLETE[1], SCB_LIST_NULL je fill_qoutfifo_done;
+	cmp	CCSCBADDR, CCSCBADDR_MAX je fill_qoutfifo_done;
+	test	QOFF_CTLSTA, SDSCB_ROLLOVR jnz fill_qoutfifo_done;
+	bmov	SCBPTR, SCB_NEXT_COMPLETE, 2;
+	jmp	fill_qoutfifo_loop;
+fill_qoutfifo_done:
+	mov	SCBHCNT, CCSCBADDR;
+	mvi	CCSCBCTL, CCSCBEN|CCSCBRESET;
+	bmov	COMPLETE_SCB_HEAD, SCB_NEXT_COMPLETE, 2;
+	mvi	SCB_NEXT_COMPLETE[1], SCB_LIST_NULL ret;
+
+fetch_new_scb:
+	bmov	SCBHADDR, NEXT_QUEUED_SCB_ADDR, 4;
+	mvi	CCARREN|CCSCBEN|CCSCBDIR|CCSCBRESET jmp dma_scb;
+dma_complete_scb:
+	bmov	SCBPTR, COMPLETE_DMA_SCB_HEAD, 2;
+	bmov	SCBHADDR, SCB_BUSADDR, 4;
+	mvi	CCARREN|CCSCBEN|CCSCBRESET jmp dma_scb;
+END_CRITICAL;
+
+/*
+ * Either post or fetch an SCB from host memory.  The caller
+ * is responsible for polling for transfer completion.
+ *
+ * Prerequisits: Mode == M_CCHAN
+ *		 SINDEX contains CCSCBCTL flags
+ *		 SCBHADDR set to Host SCB address
+ *		 SCBPTR set to SCB src location on "push" operations
+ */
+SET_SRC_MODE	M_CCHAN;
+SET_DST_MODE	M_CCHAN;
+dma_scb:
+	mvi	SCBHCNT, SCB_TRANSFER_SIZE;
+	mov	CCSCBCTL, SINDEX ret;
+
+BEGIN_CRITICAL;
+setjmp:
+	bmov	LONGJMP_ADDR, STACK, 2 ret;
+setjmp_inline:
+	bmov	LONGJMP_ADDR, STACK, 2;
+longjmp:
+	bmov	STACK, LONGJMP_ADDR, 2 ret;
+END_CRITICAL;
+
+/*************************** Chip Bug Work Arounds ****************************/
+/*
+ * Must disable interrupts when setting the mode pointer
+ * register as an interrupt occurring mid update will
+ * fail to store the new mode value for restoration on
+ * an iret.
+ */
+if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {
+set_mode_work_around:
+	mvi	SEQINTCTL, INTVEC1DSL;
+	mov	MODE_PTR, SINDEX;
+	clr	SEQINTCTL ret;
+
+toggle_dff_mode_work_around:
+	mvi	SEQINTCTL, INTVEC1DSL;
+	xor	MODE_PTR, MK_MODE(M_DFF1, M_DFF1);
+	clr	SEQINTCTL ret;
+}
+
+
+if ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {
+set_seqint_work_around:
+	mov	SEQINTCODE, SINDEX;
+	mvi	SEQINTCODE, NO_SEQINT ret;
+}
+
+/************************ Packetized LongJmp Routines *************************/
+SET_SRC_MODE	M_SCSI;
+SET_DST_MODE	M_SCSI;
+start_selection:
+BEGIN_CRITICAL;
+	if ((ahd->bugs & AHD_SENT_SCB_UPDATE_BUG) != 0) {
+		/*
+		 * Razor #494
+		 * Rev A hardware fails to update LAST/CURR/NEXTSCB
+		 * correctly after a packetized selection in several
+		 * situations:
+		 *
+		 * 1) If only one command existed in the queue, the
+		 *    LAST/CURR/NEXTSCB are unchanged.
+		 *
+		 * 2) In a non QAS, protocol allowed phase change,
+		 *    the queue is shifted 1 too far.  LASTSCB is
+		 *    the last SCB that was correctly processed.
+		 * 
+		 * 3) In the QAS case, if the full list of commands
+		 *    was successfully sent, NEXTSCB is NULL and neither
+		 *    CURRSCB nor LASTSCB can be trusted.  We must
+		 *    manually walk the list counting MAXCMDCNT elements
+		 *    to find the last SCB that was sent correctly.
+		 *
+		 * To simplify the workaround for this bug in SELDO
+		 * handling, we initialize LASTSCB prior to enabling
+		 * selection so we can rely on it even for case #1 above.
+		 */
+		bmov	LASTSCB, WAITING_TID_HEAD, 2;
+	}
+	bmov	CURRSCB, WAITING_TID_HEAD, 2;
+	bmov	SCBPTR, WAITING_TID_HEAD, 2;
+	shr	SELOID, 4, SCB_SCSIID;
+	/*
+	 * If we want to send a message to the device, ensure
+	 * we are selecting with atn irregardless of our packetized
+	 * agreement.  Since SPI4 only allows target reset or PPR
+	 * messages if this is a packetized connection, the change
+	 * to our negotiation table entry for this selection will
+	 * be cleared when the message is acted on.
+	 */
+	test	SCB_CONTROL, MK_MESSAGE jz . + 3;
+	mov	NEGOADDR, SELOID;
+	or	NEGCONOPTS, ENAUTOATNO;
+	or	SCSISEQ0, ENSELO ret;
+END_CRITICAL;
+
+/*
+ * Allocate a FIFO for a non-packetized transaction.
+ * In RevA hardware, both FIFOs must be free before we
+ * can allocate a FIFO for a non-packetized transaction.
+ */
+allocate_fifo_loop:
+	/*
+	 * Do whatever work is required to free a FIFO.
+	 */
+	call	idle_loop_service_fifos;
+	SET_MODE(M_SCSI, M_SCSI)
+allocate_fifo:
+	if ((ahd->bugs & AHD_NONPACKFIFO_BUG) != 0) {
+		and	A, FIFO0FREE|FIFO1FREE, DFFSTAT;
+		cmp	A, FIFO0FREE|FIFO1FREE jne allocate_fifo_loop;
+	} else {
+		test	DFFSTAT, FIFO1FREE jnz allocate_fifo1;
+		test	DFFSTAT, FIFO0FREE jz allocate_fifo_loop;
+		mvi	DFFSTAT, B_CURRFIFO_0;
+		SET_MODE(M_DFF0, M_DFF0)
+		bmov	SCBPTR, ALLOCFIFO_SCBPTR, 2 ret;
+	}
+SET_SRC_MODE	M_SCSI;
+SET_DST_MODE	M_SCSI;
+allocate_fifo1:
+	mvi	DFFSTAT, CURRFIFO_1;
+	SET_MODE(M_DFF1, M_DFF1)
+	bmov	SCBPTR, ALLOCFIFO_SCBPTR, 2 ret;
+
+/*
+ * We have been reselected as an initiator
+ * or selected as a target.
+ */
+SET_SRC_MODE	M_SCSI;
+SET_DST_MODE	M_SCSI;
+select_in:
+	if ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0) {
+		/*
+		 * This exposes a window whereby a
+		 * busfree just after a selection will
+		 * be missed, but there is no other safe
+		 * way to enable busfree detection if
+		 * the busfreerev function is broken.
+		 */
+		mvi	CLRSINT1,CLRBUSFREE;
+		or	SIMODE1, ENBUSFREE;
+	}
+	or	SXFRCTL0, SPIOEN;
+	and	SAVED_SCSIID, SELID_MASK, SELID;
+	and	A, OID, IOWNID;
+	or	SAVED_SCSIID, A;
+	mvi	CLRSINT0, CLRSELDI;
+	jmp	ITloop;
+
+/*
+ * We have successfully selected out.
+ *
+ * Clear SELDO.
+ * Dequeue all SCBs sent from the waiting queue
+ * Requeue all SCBs *not* sent to the tail of the waiting queue
+ * Take Razor #494 into account for above.
+ *
+ * In Packetized Mode:
+ *	Return to the idle loop.  Our interrupt handler will take
+ *	care of any incoming L_Qs.
+ *
+ * In Non-Packetize Mode:
+ *	Continue to our normal state machine.
+ */
+SET_SRC_MODE	M_SCSI;
+SET_DST_MODE	M_SCSI;
+select_out:
+BEGIN_CRITICAL;
+	/* Clear out all SCBs that have been successfully sent. */
+	if ((ahd->bugs & AHD_SENT_SCB_UPDATE_BUG) != 0) {
+		/*
+		 * For packetized, the LQO manager clears ENSELO on
+		 * the assertion of SELDO.  If we are non-packetized,
+		 * LASTSCB and CURRSCB are accurate.
+		 */
+		test	SCSISEQ0, ENSELO jnz use_lastscb;
+
+		/*
+		 * The update is correct for LQOSTAT1 errors.  All
+		 * but LQOBUSFREE are handled by kernel interrupts.
+		 * If we see LQOBUSFREE, return to the idle loop.
+		 * Once we are out of the select_out critical section,
+		 * the kernel will cleanup the LQOBUSFREE and we will
+		 * eventually restart the selection if appropriate.
+		 */
+		test	LQOSTAT1, LQOBUSFREE jnz idle_loop;
+
+		/*
+		 * On a phase change oustside of packet boundaries,
+		 * LASTSCB points to the currently active SCB context
+		 * on the bus.
+		 */
+		test	LQOSTAT2, LQOPHACHGOUTPKT jnz use_lastscb;
+
+		/*
+		 * If the hardware has traversed the whole list, NEXTSCB
+		 * will be NULL, CURRSCB and LASTSCB cannot be trusted,
+		 * but MAXCMDCNT is accurate.  If we stop part way through
+		 * the list or only had one command to issue, NEXTSCB[1] is
+		 * not NULL and LASTSCB is the last command to go out.
+		 */
+		cmp	NEXTSCB[1], SCB_LIST_NULL jne use_lastscb;
+
+		/*
+		 * Brute force walk.
+		 */
+		bmov	SCBPTR, WAITING_TID_HEAD, 2;
+		mvi	SEQINTCTL, INTVEC1DSL;
+		mvi	MODE_PTR, MK_MODE(M_CFG, M_CFG);
+		mov	A, MAXCMDCNT;
+		mvi	MODE_PTR, MK_MODE(M_SCSI, M_SCSI);
+		clr	SEQINTCTL;
+find_lastscb_loop:
+		dec	A;
+		test	A, 0xFF jz found_last_sent_scb;
+		bmov	SCBPTR, SCB_NEXT, 2;
+		jmp	find_lastscb_loop;
+use_lastscb:
+		bmov	SCBPTR, LASTSCB, 2;
+found_last_sent_scb:
+		bmov	CURRSCB, SCBPTR, 2;
+curscb_ww_done:
+	} else {
+		/*
+		 * Untested - Verify with Rev B.
+		 */
+		bmov	SCBPTR, CURRSCB, 2;
+	}
+
+	/*
+	 * Requeue any SCBs not sent, to the tail of the waiting Q.
+	 */
+	cmp	SCB_NEXT[1], SCB_LIST_NULL je select_out_list_done;
+
+	/*
+	 * We know that neither the per-TID list nor the list of
+	 * TIDs is empty.  Use this knowledge to our advantage.
+	 */
+	bmov	REG0, SCB_NEXT, 2;
+	bmov	SCBPTR, WAITING_TID_TAIL, 2;
+	bmov	SCB_NEXT2, REG0, 2;
+	bmov	WAITING_TID_TAIL, REG0, 2;
+	jmp	select_out_inc_tid_q;
+
+select_out_list_done:
+	/*
+	 * The whole list made it.  Just clear our TID's tail pointer
+	 * unless we were queued independently due to our need to
+	 * send a message.
+	 */
+	test	SCB_CONTROL, MK_MESSAGE jnz select_out_inc_tid_q;
+	shr	DINDEX, 3, SCB_SCSIID;
+	or	DINDEX, 1;	/* Want only the second byte */
+	mvi	DINDEX[1], ((WAITING_SCB_TAILS) >> 8);
+	mvi	DINDIR, SCB_LIST_NULL;
+select_out_inc_tid_q:
+	bmov	SCBPTR, WAITING_TID_HEAD, 2;
+	bmov	WAITING_TID_HEAD, SCB_NEXT2, 2;
+	cmp	WAITING_TID_HEAD[1], SCB_LIST_NULL jne . + 2;
+	mvi	WAITING_TID_TAIL[1], SCB_LIST_NULL;
+	bmov	SCBPTR, CURRSCB, 2;
+	mvi	CLRSINT0, CLRSELDO;
+	test	LQOSTAT2, LQOPHACHGOUTPKT jnz unexpected_nonpkt_phase;
+	test	LQOSTAT1, LQOPHACHGINPKT jnz unexpected_nonpkt_phase;
+
+	/*
+	 * If this is a packetized connection, return to our
+	 * idle_loop and let our interrupt handler deal with
+	 * any connection setup/teardown issues.  The only
+	 * exceptions are the case of MK_MESSAGE and task management
+	 * SCBs.
+	 */
+	if ((ahd->bugs & AHD_LQO_ATNO_BUG) != 0) {
+		/*
+		 * In the A, the LQO manager transitions to LQOSTOP0 even if
+		 * we have selected out with ATN asserted and the target
+		 * REQs in a non-packet phase.
+		 */
+		test 	SCB_CONTROL, MK_MESSAGE jz select_out_no_message;
+		test	SCSISIGO, ATNO jnz select_out_non_packetized;
+select_out_no_message:
+	}
+	test	LQOSTAT2, LQOSTOP0 jz select_out_non_packetized;
+	test	SCB_TASK_MANAGEMENT, 0xFF jz idle_loop;
+	SET_SEQINTCODE(TASKMGMT_FUNC_COMPLETE)
+	jmp	idle_loop;
+
+select_out_non_packetized:
+	/* Non packetized request. */
+	and     SCSISEQ0, ~ENSELO;
+	if ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0) {
+		/*
+		 * This exposes a window whereby a
+		 * busfree just after a selection will
+		 * be missed, but there is no other safe
+		 * way to enable busfree detection if
+		 * the busfreerev function is broken.
+		 */
+		mvi	CLRSINT1,CLRBUSFREE;
+		or	SIMODE1, ENBUSFREE;
+	}
+	mov	SAVED_SCSIID, SCB_SCSIID;
+	mov	SAVED_LUN, SCB_LUN;
+	mvi	SEQ_FLAGS, NO_CDB_SENT;
+END_CRITICAL;
+	or	SXFRCTL0, SPIOEN;
+
+	/*
+	 * As soon as we get a successful selection, the target
+	 * should go into the message out phase since we have ATN
+	 * asserted.
+	 */
+	mvi	MSG_OUT, MSG_IDENTIFYFLAG;
+
+	/*
+	 * Main loop for information transfer phases.  Wait for the
+	 * target to assert REQ before checking MSG, C/D and I/O for
+	 * the bus phase.
+	 */
+mesgin_phasemis:
+ITloop:
+	call	phase_lock;
+
+	mov	A, LASTPHASE;
+
+	test	A, ~P_DATAIN_DT	jz p_data;
+	cmp	A,P_COMMAND	je p_command;
+	cmp	A,P_MESGOUT	je p_mesgout;
+	cmp	A,P_STATUS	je p_status;
+	cmp	A,P_MESGIN	je p_mesgin;
+
+	SET_SEQINTCODE(BAD_PHASE)
+	jmp	ITloop;			/* Try reading the bus again. */
+
+/*
+ * Command phase.  Set up the DMA registers and let 'er rip.
+ */
+p_command:
+	test	SEQ_FLAGS, NOT_IDENTIFIED jz p_command_okay;
+	SET_SEQINTCODE(PROTO_VIOLATION)
+p_command_okay:
+	test	MODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1))
+		jnz p_command_allocate_fifo;
+	/*
+	 * Command retry.  Free our current FIFO and
+	 * re-allocate a FIFO so transfer state is
+	 * reset.
+	 */
+SET_SRC_MODE	M_DFF1;
+SET_DST_MODE	M_DFF1;
+	mvi	DFFSXFRCTL, RSTCHN|CLRSHCNT;
+	SET_MODE(M_SCSI, M_SCSI)
+p_command_allocate_fifo:
+	bmov	ALLOCFIFO_SCBPTR, SCBPTR, 2;
+	call	allocate_fifo;
+SET_SRC_MODE	M_DFF1;
+SET_DST_MODE	M_DFF1;
+	add	NONE, -17, SCB_CDB_LEN;
+	jnc	p_command_embedded;
+p_command_from_host:
+	bmov	HADDR[0], SCB_HOST_CDB_PTR, 9;
+	mvi	SG_CACHE_PRE, LAST_SEG;
+	mvi	DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN);
+	jmp	p_command_xfer;
+p_command_embedded:
+	bmov	SHCNT[0], SCB_CDB_LEN,  1;
+	bmov	DFDAT, SCB_CDB_STORE, 16; 
+	mvi	DFCNTRL, SCSIEN;
+p_command_xfer:
+	and	SEQ_FLAGS, ~NO_CDB_SENT;
+	test	DFCNTRL, SCSIEN jnz .;
+	/*
+	 * DMA Channel automatically disabled.
+	 * Don't allow a data phase if the command
+	 * was not fully transferred.
+	 */
+	test	SSTAT2, SDONE jnz ITloop;
+	or	SEQ_FLAGS, NO_CDB_SENT;
+	jmp	ITloop;
+
+
+/*
+ * Status phase.  Wait for the data byte to appear, then read it
+ * and store it into the SCB.
+ */
+SET_SRC_MODE	M_SCSI;
+SET_DST_MODE	M_SCSI;
+p_status:
+	test	SEQ_FLAGS,NOT_IDENTIFIED jnz mesgin_proto_violation;
+p_status_okay:
+	mov	SCB_SCSI_STATUS, SCSIDAT;
+	or	SCB_CONTROL, STATUS_RCVD;
+	jmp	ITloop;
+
+/*
+ * Message out phase.  If MSG_OUT is MSG_IDENTIFYFLAG, build a full
+ * indentify message sequence and send it to the target.  The host may
+ * override this behavior by setting the MK_MESSAGE bit in the SCB
+ * control byte.  This will cause us to interrupt the host and allow
+ * it to handle the message phase completely on its own.  If the bit
+ * associated with this target is set, we will also interrupt the host,
+ * thereby allowing it to send a message on the next selection regardless
+ * of the transaction being sent.
+ * 
+ * If MSG_OUT is == HOST_MSG, also interrupt the host and take a message.
+ * This is done to allow the host to send messages outside of an identify
+ * sequence while protecting the seqencer from testing the MK_MESSAGE bit
+ * on an SCB that might not be for the current nexus. (For example, a
+ * BDR message in responce to a bad reselection would leave us pointed to
+ * an SCB that doesn't have anything to do with the current target).
+ *
+ * Otherwise, treat MSG_OUT as a 1 byte message to send (abort, abort tag,
+ * bus device reset).
+ *
+ * When there are no messages to send, MSG_OUT should be set to MSG_NOOP,
+ * in case the target decides to put us in this phase for some strange
+ * reason.
+ */
+p_mesgout_retry:
+	/* Turn on ATN for the retry */
+	mvi	SCSISIGO, ATNO;
+p_mesgout:
+	mov	SINDEX, MSG_OUT;
+	cmp	SINDEX, MSG_IDENTIFYFLAG jne p_mesgout_from_host;
+	test	SCB_CONTROL,MK_MESSAGE	jnz host_message_loop;
+p_mesgout_identify:
+	or	SINDEX, MSG_IDENTIFYFLAG|DISCENB, SCB_LUN;
+	test	SCB_CONTROL, DISCENB jnz . + 2;
+	and	SINDEX, ~DISCENB;
+/*
+ * Send a tag message if TAG_ENB is set in the SCB control block.
+ * Use SCB_NONPACKET_TAG as the tag value.
+ */
+p_mesgout_tag:
+	test	SCB_CONTROL,TAG_ENB jz  p_mesgout_onebyte;
+	mov	SCSIDAT, SINDEX;	/* Send the identify message */
+	call	phase_lock;
+	cmp	LASTPHASE, P_MESGOUT	jne p_mesgout_done;
+	and	SCSIDAT,TAG_ENB|SCB_TAG_TYPE,SCB_CONTROL;
+	call	phase_lock;
+	cmp	LASTPHASE, P_MESGOUT	jne p_mesgout_done;
+	mov	SCBPTR jmp p_mesgout_onebyte;
+/*
+ * Interrupt the driver, and allow it to handle this message
+ * phase and any required retries.
+ */
+p_mesgout_from_host:
+	cmp	SINDEX, HOST_MSG	jne p_mesgout_onebyte;
+	jmp	host_message_loop;
+
+p_mesgout_onebyte:
+	mvi	CLRSINT1, CLRATNO;
+	mov	SCSIDAT, SINDEX;
+
+/*
+ * If the next bus phase after ATN drops is message out, it means
+ * that the target is requesting that the last message(s) be resent.
+ */
+	call	phase_lock;
+	cmp	LASTPHASE, P_MESGOUT	je p_mesgout_retry;
+
+p_mesgout_done:
+	mvi	CLRSINT1,CLRATNO;	/* Be sure to turn ATNO off */
+	mov	LAST_MSG, MSG_OUT;
+	mvi	MSG_OUT, MSG_NOOP;	/* No message left */
+	jmp	ITloop;
+
+/*
+ * Message in phase.  Bytes are read using Automatic PIO mode.
+ */
+p_mesgin:
+	/* read the 1st message byte */
+	mvi	ACCUM		call inb_first;
+
+	test	A,MSG_IDENTIFYFLAG	jnz mesgin_identify;
+	cmp	A,MSG_DISCONNECT	je mesgin_disconnect;
+	cmp	A,MSG_SAVEDATAPOINTER	je mesgin_sdptrs;
+	cmp	ALLZEROS,A		je mesgin_complete;
+	cmp	A,MSG_RESTOREPOINTERS	je mesgin_rdptrs;
+	cmp	A,MSG_IGN_WIDE_RESIDUE	je mesgin_ign_wide_residue;
+	cmp	A,MSG_NOOP		je mesgin_done;
+
+/*
+ * Pushed message loop to allow the kernel to
+ * run it's own message state engine.  To avoid an
+ * extra nop instruction after signaling the kernel,
+ * we perform the phase_lock before checking to see
+ * if we should exit the loop and skip the phase_lock
+ * in the ITloop.  Performing back to back phase_locks
+ * shouldn't hurt, but why do it twice...
+ */
+host_message_loop:
+	call	phase_lock;	/* Benign the first time through. */
+	SET_SEQINTCODE(HOST_MSG_LOOP)
+	cmp	RETURN_1, EXIT_MSG_LOOP	je ITloop;
+	cmp	RETURN_1, CONT_MSG_LOOP_WRITE	jne . + 3;
+	mov	SCSIDAT, RETURN_2;
+	jmp	host_message_loop;
+	/* Must be CONT_MSG_LOOP_READ */
+	mov	NONE, SCSIDAT;	/* ACK Byte */
+	jmp	host_message_loop;
+
+mesgin_ign_wide_residue:
+	mov	SAVED_MODE, MODE_PTR;
+	SET_MODE(M_SCSI, M_SCSI)
+	shr	NEGOADDR, 4, SAVED_SCSIID;
+	mov	A, NEGCONOPTS;
+	RESTORE_MODE(SAVED_MODE)
+	test	A, WIDEXFER jz mesgin_reject;
+	/* Pull the residue byte */
+	mvi	REG0	call inb_next;
+	cmp	REG0, 0x01 jne mesgin_reject;
+	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 2;
+	test	SCB_TASK_ATTRIBUTE, SCB_XFERLEN_ODD jnz mesgin_done;
+	SET_SEQINTCODE(IGN_WIDE_RES)
+	jmp	mesgin_done;
+
+mesgin_proto_violation:
+	SET_SEQINTCODE(PROTO_VIOLATION)
+	jmp	mesgin_done;
+mesgin_reject:
+	mvi	MSG_MESSAGE_REJECT	call mk_mesg;
+mesgin_done:
+	mov	NONE,SCSIDAT;		/*dummy read from latch to ACK*/
+	jmp	ITloop;
+
+#define INDEX_DISC_LIST(scsiid, lun)					\
+	and	A, 0xC0, scsiid;					\
+	or	SCBPTR, A, lun;						\
+	clr	SCBPTR[1];						\
+	and	SINDEX, 0x30, scsiid;					\
+	shr	SINDEX, 3;	/* Multiply by 2 */			\
+	add	SINDEX, (SCB_DISCONNECTED_LISTS & 0xFF);		\
+	mvi	SINDEX[1], ((SCB_DISCONNECTED_LISTS >> 8) & 0xFF)
+
+mesgin_identify:
+	/*
+	 * Determine whether a target is using tagged or non-tagged
+	 * transactions by first looking at the transaction stored in
+	 * the per-device, disconnected array.  If there is no untagged
+	 * transaction for this target, this must be a tagged transaction.
+	 */
+	and	SAVED_LUN, MSG_IDENTIFY_LUNMASK, A;
+	INDEX_DISC_LIST(SAVED_SCSIID, SAVED_LUN);
+	bmov	DINDEX, SINDEX, 2;
+	bmov	REG0, SINDIR, 2;
+	cmp	REG0[1], SCB_LIST_NULL je snoop_tag;
+	/* Untagged.  Clear the busy table entry and setup the SCB. */
+	bmov	DINDIR, ALLONES, 2;
+	bmov	SCBPTR, REG0, 2;
+	jmp	setup_SCB;
+
+/*
+ * Here we "snoop" the bus looking for a SIMPLE QUEUE TAG message.
+ * If we get one, we use the tag returned to find the proper
+ * SCB.  After receiving the tag, look for the SCB at SCB locations tag and
+ * tag + 256.
+ */
+snoop_tag:
+	if ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {
+		or	SEQ_FLAGS, 0x80;
+	}
+	mov	NONE, SCSIDAT;		/* ACK Identify MSG */
+	call	phase_lock;
+	if ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {
+		or	SEQ_FLAGS, 0x1;
+	}
+	cmp	LASTPHASE, P_MESGIN	jne not_found_ITloop;
+	if ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {
+		or	SEQ_FLAGS, 0x2;
+	}
+	cmp	SCSIBUS, MSG_SIMPLE_Q_TAG jne not_found;
+get_tag:
+	clr	SCBPTR[1];
+	mvi	SCBPTR	call inb_next;	/* tag value */
+verify_scb:
+	test	SCB_CONTROL,DISCONNECTED jz verify_other_scb;
+	mov	A, SAVED_SCSIID;
+	cmp	SCB_SCSIID, A jne verify_other_scb;
+	mov	A, SAVED_LUN;
+	cmp	SCB_LUN, A je setup_SCB_disconnected;
+verify_other_scb:
+	xor	SCBPTR[1], 1;
+	test	SCBPTR[1], 0xFF jnz verify_scb;
+	jmp	not_found;
+
+/*
+ * Ensure that the SCB the tag points to is for
+ * an SCB transaction to the reconnecting target.
+ */
+setup_SCB:
+	if ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0) {
+		or	SEQ_FLAGS, 0x10;
+	}
+	test	SCB_CONTROL,DISCONNECTED jz not_found;
+setup_SCB_disconnected:
+	and	SCB_CONTROL,~DISCONNECTED;
+	clr	SEQ_FLAGS;	/* make note of IDENTIFY */
+	test	SCB_SGPTR, SG_LIST_NULL jnz . + 3;
+	bmov	ALLOCFIFO_SCBPTR, SCBPTR, 2;
+	call	allocate_fifo;
+	/* See if the host wants to send a message upon reconnection */
+	test	SCB_CONTROL, MK_MESSAGE jz mesgin_done;
+	mvi	HOST_MSG	call mk_mesg;
+	jmp	mesgin_done;
+
+not_found:
+	SET_SEQINTCODE(NO_MATCH)
+	jmp	mesgin_done;
+
+not_found_ITloop:
+	SET_SEQINTCODE(NO_MATCH)
+	jmp	ITloop;
+
+/*
+ * We received a "command complete" message.  Put the SCB on the complete
+ * queue and trigger a completion interrupt via the idle loop.  Before doing
+ * so, check to see if there
+ * is a residual or the status byte is something other than STATUS_GOOD (0).
+ * In either of these conditions, we upload the SCB back to the host so it can
+ * process this information.  In the case of a non zero status byte, we 
+ * additionally interrupt the kernel driver synchronously, allowing it to
+ * decide if sense should be retrieved.  If the kernel driver wishes to request
+ * sense, it will fill the kernel SCB with a request sense command, requeue
+ * it to the QINFIFO and tell us not to post to the QOUTFIFO by setting 
+ * RETURN_1 to SEND_SENSE.
+ */
+mesgin_complete:
+
+	/*
+	 * If ATN is raised, we still want to give the target a message.
+	 * Perhaps there was a parity error on this last message byte.
+	 * Either way, the target should take us to message out phase
+	 * and then attempt to complete the command again.  We should use a
+	 * critical section here to guard against a timeout triggering
+	 * for this command and setting ATN while we are still processing
+	 * the completion.
+	test	SCSISIGI, ATNI jnz mesgin_done;
+	 */
+
+	/*
+	 * If we are identified and have successfully sent the CDB,
+	 * any status will do.  Optimize this fast path.
+	 */
+	test	SCB_CONTROL, STATUS_RCVD jz mesgin_proto_violation;
+	test	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT jz complete_accepted;
+
+	/*
+	 * If the target never sent an identify message but instead went
+	 * to mesgin to give an invalid message, let the host abort us.
+	 */
+	test	SEQ_FLAGS, NOT_IDENTIFIED jnz mesgin_proto_violation;
+
+	/*
+	 * If we recevied good status but never successfully sent the
+	 * cdb, abort the command.
+	 */
+	test	SCB_SCSI_STATUS,0xff	jnz complete_accepted;
+	test	SEQ_FLAGS, NO_CDB_SENT jnz mesgin_proto_violation;
+complete_accepted:
+
+	/*
+	 * See if we attempted to deliver a message but the target ingnored us.
+	 */
+	test	SCB_CONTROL, MK_MESSAGE jz complete_nomsg;
+	SET_SEQINTCODE(MKMSG_FAILED)
+complete_nomsg:
+	call	queue_scb_completion;
+	jmp	await_busfree;
+
+freeze_queue:
+	/* Cancel any pending select-out. */
+	test	SSTAT0, SELDO|SELINGO jnz . + 2;
+	and	SCSISEQ0, ~ENSELO;
+	mov	ACCUM_SAVE, A;
+	clr	A;
+	add	QFREEZE_COUNT, 1;
+	adc	QFREEZE_COUNT[1], A;
+	or	SEQ_FLAGS2, SELECTOUT_QFROZEN;
+	mov	A, ACCUM_SAVE ret;
+
+/*
+ * Complete the current FIFO's SCB if data for this same
+ * SCB is not transferring in the other FIFO.
+ */
+SET_SRC_MODE	M_DFF1;
+SET_DST_MODE	M_DFF1;
+pkt_complete_scb_if_fifos_idle:
+	bmov	ARG_1, SCBPTR, 2;
+	mvi	DFFSXFRCTL, CLRCHN;
+	SET_MODE(M_SCSI, M_SCSI)
+	bmov	SCBPTR, ARG_1, 2;
+	test	SCB_FIFO_USE_COUNT, 0xFF jnz return;
+queue_scb_completion:
+	test	SCB_SCSI_STATUS,0xff	jnz bad_status;
+	/*
+	 * Check for residuals
+	 */
+	test	SCB_SGPTR, SG_LIST_NULL jnz complete;	/* No xfer */
+	test	SCB_SGPTR, SG_FULL_RESID jnz upload_scb;/* Never xfered */
+	test	SCB_RESIDUAL_SGPTR, SG_LIST_NULL jz upload_scb;
+complete:
+	bmov	SCB_NEXT_COMPLETE, COMPLETE_SCB_HEAD, 2;
+	bmov	COMPLETE_SCB_HEAD, SCBPTR, 2 ret;
+bad_status:
+	cmp	SCB_SCSI_STATUS, STATUS_PKT_SENSE je upload_scb;
+	call	freeze_queue;
+upload_scb:
+	/*
+	 * Restore SCB TAG since we reuse this field
+	 * in the sequencer.  We don't want to corrupt
+	 * it on the host.
+	 */
+	bmov	SCB_TAG, SCBPTR, 2;
+	bmov	SCB_NEXT_COMPLETE, COMPLETE_DMA_SCB_HEAD, 2;
+	bmov	COMPLETE_DMA_SCB_HEAD, SCBPTR, 2;
+	or	SCB_SGPTR, SG_STATUS_VALID ret;
+
+/*
+ * Is it a disconnect message?  Set a flag in the SCB to remind us
+ * and await the bus going free.  If this is an untagged transaction
+ * store the SCB id for it in our untagged target table for lookup on
+ * a reselction.
+ */
+mesgin_disconnect:
+	/*
+	 * If ATN is raised, we still want to give the target a message.
+	 * Perhaps there was a parity error on this last message byte
+	 * or we want to abort this command.  Either way, the target
+	 * should take us to message out phase and then attempt to
+	 * disconnect again.
+	 * XXX - Wait for more testing.
+	test	SCSISIGI, ATNI jnz mesgin_done;
+	 */
+	test	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT
+		jnz mesgin_proto_violation;
+	or	SCB_CONTROL,DISCONNECTED;
+	test	SCB_CONTROL, TAG_ENB jnz await_busfree;
+queue_disc_scb:
+	bmov	REG0, SCBPTR, 2;
+	INDEX_DISC_LIST(SAVED_SCSIID, SAVED_LUN);
+	bmov	DINDEX, SINDEX, 2;
+	bmov	DINDIR, REG0, 2;
+	bmov	SCBPTR, REG0, 2;
+	/* FALLTHROUGH */
+await_busfree:
+	and	SIMODE1, ~ENBUSFREE;
+	if ((ahd->bugs & AHD_BUSFREEREV_BUG) == 0) {
+		/*
+		 * In the BUSFREEREV_BUG case, the
+		 * busfree status was cleared at the
+		 * beginning of the connection.
+		 */
+		mvi	CLRSINT1,CLRBUSFREE;
+	}
+	mov	NONE, SCSIDAT;		/* Ack the last byte */
+	test	MODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1))
+		jnz await_busfree_not_m_dff;
+SET_SRC_MODE	M_DFF1;
+SET_DST_MODE	M_DFF1;
+await_busfree_clrchn:
+	mvi	DFFSXFRCTL, CLRCHN;
+await_busfree_not_m_dff:
+	call	clear_target_state;
+	test	SSTAT1,REQINIT|BUSFREE	jz .;
+	test	SSTAT1, BUSFREE jnz idle_loop;
+	SET_SEQINTCODE(MISSED_BUSFREE)
+
+
+/*
+ * Save data pointers message:
+ * Copying RAM values back to SCB, for Save Data Pointers message, but
+ * only if we've actually been into a data phase to change them.  This
+ * protects against bogus data in scratch ram and the residual counts
+ * since they are only initialized when we go into data_in or data_out.
+ * Ack the message as soon as possible.
+ */
+SET_SRC_MODE	M_DFF1;
+SET_DST_MODE	M_DFF1;
+mesgin_sdptrs:
+	mov	NONE,SCSIDAT;		/*dummy read from latch to ACK*/
+	test	SEQ_FLAGS, DPHASE	jz ITloop;
+	call	save_pointers;
+	jmp	ITloop;
+
+save_pointers:
+	/*
+	 * If we are asked to save our position at the end of the
+	 * transfer, just mark us at the end rather than perform a
+	 * full save.
+	 */
+	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz save_pointers_full;
+	or	SCB_SGPTR, SG_LIST_NULL ret;
+
+save_pointers_full:
+	/*
+	 * The SCB_DATAPTR becomes the current SHADDR.
+	 * All other information comes directly from our residual
+	 * state.
+	 */
+	bmov	SCB_DATAPTR, SHADDR, 8;
+	bmov	SCB_DATACNT, SCB_RESIDUAL_DATACNT, 8 ret;
+
+/*
+ * Restore pointers message?  Data pointers are recopied from the
+ * SCB anytime we enter a data phase for the first time, so all
+ * we need to do is clear the DPHASE flag and let the data phase
+ * code do the rest.  We also reset/reallocate the FIFO to make
+ * sure we have a clean start for the next data or command phase.
+ */
+mesgin_rdptrs:
+	and	SEQ_FLAGS, ~DPHASE;
+	test	MODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1)) jnz msgin_rdptrs_get_fifo;
+	mvi	DFFSXFRCTL, RSTCHN|CLRSHCNT;
+	SET_MODE(M_SCSI, M_SCSI)
+msgin_rdptrs_get_fifo:
+	call	allocate_fifo;
+	jmp	mesgin_done;
+
+clear_target_state:
+	mvi	LASTPHASE, P_BUSFREE;
+	/* clear target specific flags */
+	mvi	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT ret;
+
+phase_lock:     
+	if ((ahd->bugs & AHD_EARLY_REQ_BUG) != 0) {
+		/*
+		 * Don't ignore persistent REQ assertions just because
+		 * they were asserted within the bus settle delay window.
+		 * This allows us to tolerate devices like the GEM318
+		 * that violate the SCSI spec.  We are careful not to
+		 * count REQ while we are waiting for it to fall during
+		 * an async phase due to our asserted ACK.  Each
+		 * sequencer instruction takes ~25ns, so the REQ must
+		 * last at least 100ns in order to be counted as a true
+		 * REQ.
+		 */
+		test	SCSIPHASE, 0xFF jnz phase_locked;
+		test	SCSISIGI, ACKI jnz phase_lock;
+		test	SCSISIGI, REQI jz phase_lock;
+		test	SCSIPHASE, 0xFF jnz phase_locked;
+		test	SCSISIGI, ACKI jnz phase_lock;
+		test	SCSISIGI, REQI jz phase_lock;
+phase_locked:
+	} else {
+		test	SCSIPHASE, 0xFF jz .;
+	}
+	test	SSTAT1, SCSIPERR jnz phase_lock;
+phase_lock_latch_phase:
+	and	LASTPHASE, PHASE_MASK, SCSISIGI ret;
+
+/*
+ * Functions to read data in Automatic PIO mode.
+ *
+ * An ACK is not sent on input from the target until SCSIDATL is read from.
+ * So we wait until SCSIDATL is latched (the usual way), then read the data
+ * byte directly off the bus using SCSIBUSL.  When we have pulled the ATN
+ * line, or we just want to acknowledge the byte, then we do a dummy read
+ * from SCISDATL.  The SCSI spec guarantees that the target will hold the
+ * data byte on the bus until we send our ACK.
+ *
+ * The assumption here is that these are called in a particular sequence,
+ * and that REQ is already set when inb_first is called.  inb_{first,next}
+ * use the same calling convention as inb.
+ */
+inb_next:
+	mov	NONE,SCSIDAT;		/*dummy read from latch to ACK*/
+inb_next_wait:
+	/*
+	 * If there is a parity error, wait for the kernel to
+	 * see the interrupt and prepare our message response
+	 * before continuing.
+	 */
+	test	SCSIPHASE, 0xFF jz .;
+	test	SSTAT1, SCSIPERR jnz inb_next_wait;
+inb_next_check_phase:
+	and	LASTPHASE, PHASE_MASK, SCSISIGI;
+	cmp	LASTPHASE, P_MESGIN jne mesgin_phasemis;
+inb_first:
+	clr	DINDEX[1];
+	mov	DINDEX,SINDEX;
+	mov	DINDIR,SCSIBUS	ret;		/*read byte directly from bus*/
+inb_last:
+	mov	NONE,SCSIDAT ret;		/*dummy read from latch to ACK*/
+
+mk_mesg:
+	mvi	SCSISIGO, ATNO;
+	mov	MSG_OUT,SINDEX ret;
+
+SET_SRC_MODE	M_DFF1;
+SET_DST_MODE	M_DFF1;
+disable_ccsgen:
+	test	SG_STATE, FETCH_INPROG jz disable_ccsgen_fetch_done;
+	clr	CCSGCTL;
+disable_ccsgen_fetch_done:
+	clr	SG_STATE ret;
+
+service_fifo:
+	/*
+	 * Do we have any prefetch left???
+	 */
+	test	SG_STATE, SEGS_AVAIL jnz idle_sg_avail;
+
+	/*
+	 * Can this FIFO have access to the S/G cache yet?
+	 */
+	test	CCSGCTL, SG_CACHE_AVAIL jz return;
+
+	/* Did we just finish fetching segs? */
+	test	CCSGCTL, CCSGDONE jnz idle_sgfetch_complete;
+
+	/* Are we actively fetching segments? */
+	test	CCSGCTL, CCSGENACK jnz return;
+
+	/*
+	 * We fetch a "cacheline aligned" and sized amount of data
+	 * so we don't end up referencing a non-existant page.
+	 * Cacheline aligned is in quotes because the kernel will
+	 * set the prefetch amount to a reasonable level if the
+	 * cacheline size is unknown.
+	 */
+	bmov	SGHADDR, SCB_RESIDUAL_SGPTR, 4;
+	mvi	SGHCNT, SG_PREFETCH_CNT;
+	if ((ahd->bugs & AHD_REG_SLOW_SETTLE_BUG) != 0) {
+		/*
+		 * Need two instruction between "touches" of SGHADDR.
+		 */
+		nop;
+	}
+	and	SGHADDR[0], SG_PREFETCH_ALIGN_MASK, SCB_RESIDUAL_SGPTR;
+	mvi	CCSGCTL, CCSGEN|CCSGRESET;
+	or	SG_STATE, FETCH_INPROG ret;
+idle_sgfetch_complete:
+	/*
+	 * Guard against SG_CACHE_AVAIL activating during sg fetch
+	 * request in the other FIFO.
+	 */
+	test	SG_STATE, FETCH_INPROG jz return;
+	clr	CCSGCTL;
+	and	CCSGADDR, SG_PREFETCH_ADDR_MASK, SCB_RESIDUAL_SGPTR;
+	mvi	SG_STATE, SEGS_AVAIL|LOADING_NEEDED;
+idle_sg_avail:
+	/* Does the hardware have space for another SG entry? */
+	test	DFSTATUS, PRELOAD_AVAIL jz return;
+	/*
+	 * On the A, preloading a segment before HDMAENACK
+	 * comes true can clobber the shaddow address of the
+	 * first segment in the S/G FIFO.  Wait until it is
+	 * safe to proceed.
+	 */
+	if ((ahd->features & AHD_NEW_DFCNTRL_OPTS) == 0) {
+		test	DFCNTRL, HDMAENACK jz return;
+	}
+	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
+		bmov	HADDR, CCSGRAM, 8;
+	} else {
+		bmov 	HADDR, CCSGRAM, 4;
+	}
+	bmov	HCNT, CCSGRAM, 3;
+	bmov	SCB_RESIDUAL_DATACNT[3], CCSGRAM, 1;
+	if ((ahd->flags & AHD_39BIT_ADDRESSING) != 0) {
+		and	HADDR[4], SG_HIGH_ADDR_BITS, SCB_RESIDUAL_DATACNT[3];
+	}
+	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
+		/* Skip 4 bytes of pad. */
+		add	CCSGADDR, 4;
+	}
+sg_advance:
+	clr	A;			/* add sizeof(struct scatter) */
+	add	SCB_RESIDUAL_SGPTR[0],SG_SIZEOF;
+	adc	SCB_RESIDUAL_SGPTR[1],A;
+	adc	SCB_RESIDUAL_SGPTR[2],A;
+	adc	SCB_RESIDUAL_SGPTR[3],A;
+	mov	SINDEX, SCB_RESIDUAL_SGPTR[0];
+	test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 3;
+	or	SINDEX, LAST_SEG;
+	clr	SG_STATE;
+	mov	SG_CACHE_PRE, SINDEX;
+	if ((ahd->features & AHD_NEW_DFCNTRL_OPTS) != 0) {
+		/*
+		 * Use SCSIENWRDIS so that SCSIEN is never
+		 * modified by this operation.
+		 */
+		or	DFCNTRL, PRELOADEN|HDMAEN|SCSIENWRDIS;
+	} else {
+		or	DFCNTRL, PRELOADEN|HDMAEN;
+	}
+	/*
+	 * Do we have another segment in the cache?
+	 */
+	add	NONE, SG_PREFETCH_CNT_LIMIT, CCSGADDR;
+	jnc	return;
+	and	SG_STATE, ~SEGS_AVAIL ret;
+
+/*
+ * Initialize the DMA address and counter from the SCB.
+ */
+load_first_seg:
+	bmov	HADDR, SCB_DATAPTR, 11;
+	and	REG_ISR, ~SG_FULL_RESID, SCB_SGPTR[0];
+	test	SCB_DATACNT[3], SG_LAST_SEG jz . + 2;
+	or	REG_ISR, LAST_SEG;
+	mov	SG_CACHE_PRE, REG_ISR;
+	mvi	DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN);
+	/*
+	 * Since we've are entering a data phase, we will
+	 * rely on the SCB_RESID* fields.  Initialize the
+	 * residual and clear the full residual flag.
+	 */
+	and	SCB_SGPTR[0], ~SG_FULL_RESID;
+	bmov	SCB_RESIDUAL_DATACNT[3], SCB_DATACNT[3], 5;
+	/* If we need more S/G elements, tell the idle loop */
+	test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jnz . + 2;
+	mvi	SG_STATE, LOADING_NEEDED ret;
+	clr	SG_STATE ret;
+
+p_data_handle_xfer:
+	call	setjmp;
+	test	SG_STATE, LOADING_NEEDED jnz service_fifo;
+p_data_clear_handler:
+	or	LONGJMP_ADDR[1], INVALID_ADDR ret;
+
+p_data:
+	test	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT	jz p_data_allowed;
+	SET_SEQINTCODE(PROTO_VIOLATION)
+p_data_allowed:
+ 
+	test	SEQ_FLAGS, DPHASE	jz data_phase_initialize;
+
+	/*
+	 * If we re-enter the data phase after going through another
+	 * phase, our transfer location has almost certainly been
+	 * corrupted by the interveining, non-data, transfers.  Ask
+	 * the host driver to fix us up based on the transfer residual
+	 * unless we already know that we should be bitbucketing.
+	 */
+	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jnz p_data_bitbucket;
+	SET_SEQINTCODE(PDATA_REINIT)
+	jmp	data_phase_inbounds;
+
+p_data_bitbucket:
+	/*
+	 * Turn on `Bit Bucket' mode, wait until the target takes
+	 * us to another phase, and then notify the host.
+	 */
+	mov	SAVED_MODE, MODE_PTR;
+	test	MODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1))
+		jnz bitbucket_not_m_dff;
+	/*
+	 * Ensure that any FIFO contents are cleared out and the
+	 * FIFO free'd prior to starting the BITBUCKET.  BITBUCKET
+	 * doesn't discard data already in the FIFO.
+	 */
+	mvi	DFFSXFRCTL, RSTCHN|CLRSHCNT;
+	SET_MODE(M_SCSI, M_SCSI)
+bitbucket_not_m_dff:
+	or	SXFRCTL1,BITBUCKET;
+	/* Wait for non-data phase. */
+	test	SCSIPHASE, ~DATA_PHASE_MASK jz .;
+	and	SXFRCTL1, ~BITBUCKET;
+	RESTORE_MODE(SAVED_MODE)
+SET_SRC_MODE	M_DFF1;
+SET_DST_MODE	M_DFF1;
+	SET_SEQINTCODE(DATA_OVERRUN)
+	jmp	ITloop;
+
+data_phase_initialize:
+	test	SCB_SGPTR[0], SG_LIST_NULL jnz p_data_bitbucket;
+	call	load_first_seg;
+data_phase_inbounds:
+	/* We have seen a data phase at least once. */
+	or	SEQ_FLAGS, DPHASE;
+	mov	SAVED_MODE, MODE_PTR;
+	test	SG_STATE, LOADING_NEEDED jz data_group_dma_loop;
+	call	p_data_handle_xfer;
+data_group_dma_loop:
+	/*
+	 * The transfer is complete if either the last segment
+	 * completes or the target changes phase.  Both conditions
+	 * will clear SCSIEN.
+	 */
+	call	idle_loop_service_fifos;
+	call	idle_loop_cchan;
+	call	idle_loop_gsfifo;
+	RESTORE_MODE(SAVED_MODE)
+	test	DFCNTRL, SCSIEN jnz data_group_dma_loop;
+
+data_group_dmafinish:
+	/*
+	 * The transfer has terminated either due to a phase
+	 * change, and/or the completion of the last segment.
+	 * We have two goals here.  Do as much other work
+	 * as possible while the data fifo drains on a read
+	 * and respond as quickly as possible to the standard
+	 * messages (save data pointers/disconnect and command
+	 * complete) that usually follow a data phase.
+	 */
+	call	calc_residual;
+
+	/*
+	 * Go ahead and shut down the DMA engine now.
+	 */
+	test	DFCNTRL, DIRECTION jnz data_phase_finish;
+data_group_fifoflush:
+	if ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0) {
+		or	DFCNTRL, FIFOFLUSH;
+	}
+	/*
+	 * We have enabled the auto-ack feature.  This means
+	 * that the controller may have already transferred
+	 * some overrun bytes into the data FIFO and acked them
+	 * on the bus.  The only way to detect this situation is
+	 * to wait for LAST_SEG_DONE to come true on a completed
+	 * transfer and then test to see if the data FIFO is
+	 * non-empty.  We know there is more data yet to transfer
+	 * if SG_LIST_NULL is not yet set, thus there cannot be
+	 * an overrun.
+	 */
+	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz data_phase_finish;
+	test	SG_CACHE_SHADOW, LAST_SEG_DONE jz .;
+	test	DFSTATUS, FIFOEMP jnz data_phase_finish;
+	/* Overrun */
+	jmp	p_data;
+data_phase_finish:
+	/*
+	 * If the target has left us in data phase, loop through
+	 * the dma code again.  We will only loop if there is a
+	 * data overrun.  
+	 */
+	if ((ahd->flags & AHD_TARGETROLE) != 0) {
+		test	SSTAT0, TARGET jnz data_phase_done;
+	}
+	if ((ahd->flags & AHD_INITIATORROLE) != 0) {
+		test	SSTAT1, REQINIT jz .;
+		test	SCSIPHASE, DATA_PHASE_MASK jnz p_data;
+	}
+
+data_phase_done:
+	/* Kill off any pending prefetch */
+	call	disable_ccsgen;
+	or 	LONGJMP_ADDR[1], INVALID_ADDR;
+
+	if ((ahd->flags & AHD_TARGETROLE) != 0) {
+		test	SEQ_FLAGS, DPHASE_PENDING jz ITloop;
+		/*
+		and	SEQ_FLAGS, ~DPHASE_PENDING;
+		 * For data-in phases, wait for any pending acks from the
+		 * initiator before changing phase.  We only need to
+		 * send Ignore Wide Residue messages for data-in phases.
+		test	DFCNTRL, DIRECTION jz target_ITloop;
+		test	SSTAT1, REQINIT	jnz .;
+		test	SCB_TASK_ATTRIBUTE, SCB_XFERLEN_ODD jz target_ITloop;
+		SET_MODE(M_SCSI, M_SCSI)
+		test	NEGCONOPTS, WIDEXFER jz target_ITloop;
+		 */
+		/*
+		 * Issue an Ignore Wide Residue Message.
+		mvi	P_MESGIN|BSYO call change_phase;
+		mvi	MSG_IGN_WIDE_RESIDUE call target_outb;
+		mvi	1 call target_outb;
+		jmp	target_ITloop;
+		 */
+	} else {
+		jmp	ITloop;
+	}
+
+/*
+ * We assume that, even though data may still be
+ * transferring to the host, that the SCSI side of
+ * the DMA engine is now in a static state.  This
+ * allows us to update our notion of where we are
+ * in this transfer.
+ *
+ * If, by chance, we stopped before being able
+ * to fetch additional segments for this transfer,
+ * yet the last S/G was completely exhausted,
+ * call our idle loop until it is able to load
+ * another segment.  This will allow us to immediately
+ * pickup on the next segment on the next data phase.
+ *
+ * If we happened to stop on the last segment, then
+ * our residual information is still correct from
+ * the idle loop and there is no need to perform
+ * any fixups.
+ */
+residual_before_last_seg:
+	test    MDFFSTAT, SHVALID	jnz sgptr_fixup;
+	/*
+	 * Can never happen from an interrupt as the packetized
+	 * hardware will only interrupt us once SHVALID or
+	 * LAST_SEG_DONE.
+	 */
+	call	idle_loop_service_fifos;
+	RESTORE_MODE(SAVED_MODE)
+	/* FALLTHROUGH */
+calc_residual:
+	test	SG_CACHE_SHADOW, LAST_SEG jz residual_before_last_seg;
+	/* Record if we've consumed all S/G entries */
+	test	MDFFSTAT, SHVALID	jz . + 2;
+	bmov	SCB_RESIDUAL_DATACNT, SHCNT, 3 ret;
+	or	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL ret;
+
+sgptr_fixup:
+	/*
+	 * Fixup the residual next S/G pointer.  The S/G preload
+	 * feature of the chip allows us to load two elements
+	 * in addition to the currently active element.  We
+	 * store the bottom byte of the next S/G pointer in
+	 * the SG_CACHE_PTR register so we can restore the
+	 * correct value when the DMA completes.  If the next
+	 * sg ptr value has advanced to the point where higher
+	 * bytes in the address have been affected, fix them
+	 * too.
+	 */
+	test	SG_CACHE_SHADOW, 0x80 jz sgptr_fixup_done;
+	test	SCB_RESIDUAL_SGPTR[0], 0x80 jnz sgptr_fixup_done;
+	add	SCB_RESIDUAL_SGPTR[1], -1;
+	adc	SCB_RESIDUAL_SGPTR[2], -1; 
+	adc	SCB_RESIDUAL_SGPTR[3], -1;
+sgptr_fixup_done:
+	and	SCB_RESIDUAL_SGPTR[0], SG_ADDR_MASK, SG_CACHE_SHADOW;
+	clr	SCB_RESIDUAL_DATACNT[3]; /* We are not the last seg */
+	bmov	SCB_RESIDUAL_DATACNT, SHCNT, 3 ret;
+
+export timer_isr:
+	call	issue_cmdcmplt;
+	mvi	CLRSEQINTSTAT, CLRSEQ_SWTMRTO;
+	if ((ahd->bugs & AHD_SET_MODE_BUG) != 0) {
+		/*
+		 * In H2A4, the mode pointer is not saved
+		 * for intvec2, but is restored on iret.
+		 * This can lead to the restoration of a
+		 * bogus mode ptr.  Manually clear the
+		 * intmask bits and do a normal return
+		 * to compensate.
+		 */
+		and	SEQINTCTL, ~(INTMASK2|INTMASK1) ret;
+	} else {
+		or	SEQINTCTL, IRET ret;
+	}
+
+export seq_isr:
+	if ((ahd->features & AHD_RTI) == 0) {
+		/*
+		 * On RevA Silicon, if the target returns us to data-out
+		 * after we have already trained for data-out, it is
+		 * possible for us to transition the free running clock to
+		 * data-valid before the required 100ns P1 setup time (8 P1
+		 * assertions in fast-160 mode).  This will only happen if
+		 * this L-Q is a continuation of a data transfer for which
+		 * we have already prefetched data into our FIFO (LQ/Data
+		 * followed by LQ/Data for the same write transaction).
+		 * This can cause some target implementations to miss the
+		 * first few data transfers on the bus.  We detect this
+		 * situation by noticing that this is the first data transfer
+		 * after an LQ (LQIWORKONLQ true), that the data transfer is
+		 * a continuation of a transfer already setup in our FIFO
+		 * (SAVEPTRS interrupt), and that the transaction is a write
+		 * (DIRECTION set in DFCNTRL). The delay is performed by
+		 * disabling SCSIEN until we see the first REQ from the
+		 * target.
+		 * 
+		 * First instruction in an ISR cannot be a branch on
+		 * Rev A.  Snapshot LQISTAT2 so the status is not missed
+		 * and deffer the test by one instruction.
+		 */
+		mov	REG_ISR, LQISTAT2;
+		test	REG_ISR, LQIWORKONLQ jz main_isr;
+		test	SEQINTSRC, SAVEPTRS  jz main_isr;
+		test	LONGJMP_ADDR[1], INVALID_ADDR jz saveptr_active_fifo;
+		/*
+		 * Switch to the active FIFO after clearing the snapshot
+		 * savepointer in the current FIFO.  We do this so that
+		 * a pending CTXTDONE or SAVEPTR is visible in the active
+		 * FIFO.  This status is the only way we can detect if we
+		 * have lost the race (e.g. host paused us) and our attepts
+		 * to disable the channel occurred after all REQs were
+		 * already seen and acked (REQINIT never comes true).
+		 */
+		mvi	DFFSXFRCTL, CLRCHN;
+		xor	MODE_PTR, MK_MODE(M_DFF1, M_DFF1);
+		test	DFCNTRL, DIRECTION jz interrupt_return;
+		and	DFCNTRL, ~SCSIEN;
+snapshot_wait_data_valid:
+		test	SEQINTSRC, (CTXTDONE|SAVEPTRS) jnz snapshot_data_valid;
+		test	SSTAT1, REQINIT	jz snapshot_wait_data_valid;
+snapshot_data_valid:
+		or	DFCNTRL, SCSIEN;
+		or	SEQINTCTL, IRET ret;
+snapshot_saveptr:
+		mvi	DFFSXFRCTL, CLRCHN;
+		or	SEQINTCTL, IRET ret;
+main_isr:
+	}
+	test	SEQINTSRC, CFG4DATA	jnz cfg4data_intr;
+	test	SEQINTSRC, CFG4ISTAT	jnz cfg4istat_intr;
+	test	SEQINTSRC, SAVEPTRS	jnz saveptr_intr;
+	test	SEQINTSRC, CFG4ICMD	jnz cfg4icmd_intr;
+	SET_SEQINTCODE(INVALID_SEQINT)
+
+/*
+ * There are two types of save pointers interrupts:
+ * The first is a snapshot save pointers where the current FIFO is not
+ * active and contains a snapshot of the current poniter information.
+ * This happens between packets in a stream for a single L_Q.  Since we
+ * are not performing a pointer save, we can safely clear the channel
+ * so it can be used for other transactions.  On RTI capable controllers,
+ * where snapshots can, and are, disabled, the code to handle this type
+ * of snapshot is not active.
+ *
+ * The second case is a save pointers on an active FIFO which occurs
+ * if the target changes to a new L_Q or busfrees/QASes and the transfer
+ * has a residual.  This should occur coincident with a ctxtdone.  We
+ * disable the interrupt and allow our active routine to handle the
+ * save.
+ */
+saveptr_intr:
+	if ((ahd->features & AHD_RTI) == 0) {
+		test	LONGJMP_ADDR[1], INVALID_ADDR jnz snapshot_saveptr;
+	}
+saveptr_active_fifo:
+	and	SEQIMODE, ~ENSAVEPTRS;
+	or	SEQINTCTL, IRET ret;
+
+cfg4data_intr:
+	test	SCB_SGPTR[0], SG_LIST_NULL jnz pkt_handle_overrun_inc_use_count;
+	call	load_first_seg;
+	call	pkt_handle_xfer;
+	inc	SCB_FIFO_USE_COUNT;
+interrupt_return:
+	or	SEQINTCTL, IRET ret;
+
+cfg4istat_intr:
+	call	freeze_queue;
+	add	NONE, -13, SCB_CDB_LEN;
+	jnc	cfg4istat_have_sense_addr;
+	test	SCB_CDB_LEN, SCB_CDB_LEN_PTR jnz cfg4istat_have_sense_addr;
+	/*
+	 * Host sets up address/count and enables transfer.
+	 */
+	SET_SEQINTCODE(CFG4ISTAT_INTR)
+	jmp	cfg4istat_setup_handler;
+cfg4istat_have_sense_addr:
+	bmov	HADDR, SCB_SENSE_BUSADDR, 4;
+	mvi	HCNT[1], (AHD_SENSE_BUFSIZE >> 8);
+	mvi	SG_CACHE_PRE, LAST_SEG;
+	mvi	DFCNTRL, PRELOADEN|SCSIEN|HDMAEN;
+cfg4istat_setup_handler:
+	/*
+	 * Status pkt is transferring to host.
+	 * Wait in idle loop for transfer to complete.
+	 * If a command completed before an attempted
+	 * task management function completed, notify the host.
+	 */
+	test	SCB_TASK_MANAGEMENT, 0xFF jz cfg4istat_no_taskmgmt_func;
+	SET_SEQINTCODE(TASKMGMT_CMD_CMPLT_OKAY)
+cfg4istat_no_taskmgmt_func:
+	call	pkt_handle_status;
+	or	SEQINTCTL, IRET ret;
+
+cfg4icmd_intr:
+	/*
+	 * In the case of DMAing a CDB from the host, the normal
+	 * CDB buffer is formatted with an 8 byte address followed
+	 * by a 1 byte count.
+	 */
+	bmov	HADDR[0], SCB_HOST_CDB_PTR, 9;
+	mvi	SG_CACHE_PRE, LAST_SEG;
+	mvi	DFCNTRL, (PRELOADEN|SCSIEN|HDMAEN);
+	call	pkt_handle_cdb;
+	or	SEQINTCTL, IRET ret;
+
+/*
+ * See if the target has gone on in this context creating an
+ * overrun condition.  For the write case, the hardware cannot
+ * ack bytes until data are provided.  So, if the target begins
+ * another  packet without changing contexts, implying we are
+ * not sitting on a packet boundary, we are in an overrun
+ * situation.  For the read case, the hardware will continue to
+ * ack bytes into the FIFO, and may even ack the last overrun packet
+ * into the FIFO.   If the FIFO should become non-empty, we are in
+ * a read overrun case.
+ */
+#define check_overrun							\
+	/* Not on a packet boundary. */					\
+	test 	MDFFSTAT, DLZERO jz pkt_handle_overrun;			\
+	test	DFSTATUS, FIFOEMP jz pkt_handle_overrun
+
+pkt_handle_xfer:
+	test	SG_STATE, LOADING_NEEDED jz pkt_last_seg;
+	call	setjmp;
+	test	SEQINTSRC, SAVEPTRS jnz pkt_saveptrs;
+	test	SCSIPHASE, ~DATA_PHASE_MASK jz . + 2;
+	test	SCSISIGO, ATNO jnz . + 2;
+	test	SSTAT2, NONPACKREQ jz pkt_service_fifo;
+	/*
+	 * Defer handling of this NONPACKREQ until we
+	 * can be sure it pertains to this FIFO.  SAVEPTRS
+	 * will not be asserted if the NONPACKREQ is for us,
+	 * so we must simulate it if shaddow is valid.  If
+	 * shaddow is not valid, keep running this FIFO until we
+	 * have satisfied the transfer by loading segments and
+	 * waiting for either shaddow valid or last_seg_done.
+	 */
+	test	MDFFSTAT, SHVALID jnz pkt_saveptrs;
+pkt_service_fifo:
+	test	SG_STATE, LOADING_NEEDED jnz service_fifo;
+pkt_last_seg:
+	call	setjmp;
+	test	SEQINTSRC, SAVEPTRS jnz pkt_saveptrs;
+	test	SG_CACHE_SHADOW, LAST_SEG_DONE jnz pkt_last_seg_done;
+	test	SCSIPHASE, ~DATA_PHASE_MASK jz . + 2;
+	test	SCSISIGO, ATNO jnz . + 2;
+	test	SSTAT2, NONPACKREQ jz return;
+	test	MDFFSTAT, SHVALID jz return;
+	/* FALLTHROUGH */
+
+/*
+ * Either a SAVEPTRS interrupt condition is pending for this FIFO
+ * or we have a pending NONPACKREQ for this FIFO.  We differentiate
+ * between the two by capturing the state of the SAVEPTRS interrupt
+ * prior to clearing this status and executing the common code for
+ * these two cases.
+ */
+pkt_saveptrs:
+BEGIN_CRITICAL;
+	if ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0) {
+		or	DFCNTRL, FIFOFLUSH;
+	}
+	mov	REG0, SEQINTSRC;
+	call	calc_residual;
+	call	save_pointers;
+	mvi	CLRSEQINTSRC, CLRSAVEPTRS;
+	call	disable_ccsgen;
+	or	SEQIMODE, ENSAVEPTRS;
+	test	DFCNTRL, DIRECTION jnz pkt_saveptrs_check_status;
+	test	DFSTATUS, FIFOEMP jnz pkt_saveptrs_check_status;
+	/*
+	 * Keep a handler around for this FIFO until it drains
+	 * to the host to guarantee that we don't complete the
+	 * command to the host before the data arrives.
+	 */
+pkt_saveptrs_wait_fifoemp:
+	call	setjmp;
+	test	DFSTATUS, FIFOEMP jz return;
+pkt_saveptrs_check_status:
+	or	LONGJMP_ADDR[1], INVALID_ADDR;
+	test	REG0, SAVEPTRS jz unexpected_nonpkt_phase;
+	dec	SCB_FIFO_USE_COUNT;
+	test	SCB_CONTROL, STATUS_RCVD jnz pkt_complete_scb_if_fifos_idle;
+	mvi	DFFSXFRCTL, CLRCHN ret;
+END_CRITICAL;
+
+/*
+ * LAST_SEG_DONE status has been seen in the current FIFO.
+ * This indicates that all of the allowed data for this
+ * command has transferred across the SCSI and host buses.
+ * Check for overrun and see if we can complete this command.
+ */
+pkt_last_seg_done:
+BEGIN_CRITICAL;
+	/*
+	 * Mark transfer as completed.
+	 */
+	or	SCB_SGPTR, SG_LIST_NULL;
+
+	/*
+	 * Wait for the current context to finish to verify that
+	 * no overrun condition has occurred.
+	 */
+	test	SEQINTSRC, CTXTDONE jnz pkt_ctxt_done;
+	call	setjmp;
+pkt_wait_ctxt_done_loop:
+	test	SEQINTSRC, CTXTDONE jnz pkt_ctxt_done;
+	/*
+	 * A sufficiently large overrun or a NONPACKREQ may
+	 * prevent CTXTDONE from ever asserting, so we must
+	 * poll for these statuses too.
+	 */
+	check_overrun;
+	test	SSTAT2, NONPACKREQ jz return;
+	test	SEQINTSRC, CTXTDONE jz unexpected_nonpkt_phase;
+	/* FALLTHROUGH */
+
+pkt_ctxt_done:
+	check_overrun;
+	or	LONGJMP_ADDR[1], INVALID_ADDR;
+	/*
+	 * If status has been received, it is safe to skip
+	 * the check to see if another FIFO is active because
+	 * LAST_SEG_DONE has been observed.  However, we check
+	 * the FIFO anyway since it costs us only one extra
+	 * instruction to leverage common code to perform the
+	 * SCB completion.
+	 */
+	dec	SCB_FIFO_USE_COUNT;
+	test	SCB_CONTROL, STATUS_RCVD jnz pkt_complete_scb_if_fifos_idle;
+	mvi	DFFSXFRCTL, CLRCHN ret;
+END_CRITICAL;
+
+/*
+ * Must wait until CDB xfer is over before issuing the
+ * clear channel.
+ */
+pkt_handle_cdb:
+	call	setjmp;
+	test	SG_CACHE_SHADOW, LAST_SEG_DONE jz return;
+	or	LONGJMP_ADDR[1], INVALID_ADDR;
+	mvi	DFFSXFRCTL, CLRCHN ret;
+
+/*
+ * Watch over the status transfer.  Our host sense buffer is
+ * large enough to take the maximum allowed status packet.
+ * None-the-less, we must still catch and report overruns to
+ * the host.  Additionally, properly catch unexpected non-packet
+ * phases that are typically caused by CRC errors in status packet
+ * transmission.
+ */
+pkt_handle_status:
+	call	setjmp;
+	test	SG_CACHE_SHADOW, LAST_SEG_DONE jnz pkt_status_check_overrun;
+	test	SEQINTSRC, CTXTDONE jz pkt_status_check_nonpackreq;
+	test	SG_CACHE_SHADOW, LAST_SEG_DONE jnz pkt_status_check_overrun;
+pkt_status_IU_done:
+	if ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0) {
+		or	DFCNTRL, FIFOFLUSH;
+	}
+	test	DFSTATUS, FIFOEMP jz return;
+BEGIN_CRITICAL;
+	or	LONGJMP_ADDR[1], INVALID_ADDR;
+	mvi	SCB_SCSI_STATUS, STATUS_PKT_SENSE;
+	or	SCB_CONTROL, STATUS_RCVD;
+	jmp	pkt_complete_scb_if_fifos_idle;
+END_CRITICAL;
+pkt_status_check_overrun:
+	/*
+	 * Status PKT overruns are uncerimoniously recovered with a
+	 * bus reset.  If we've overrun, let the host know so that
+	 * recovery can be performed.
+	 *
+	 * LAST_SEG_DONE has been observed.  If either CTXTDONE or
+	 * a NONPACKREQ phase change have occurred and the FIFO is
+	 * empty, there is no overrun.
+	 */
+	test	DFSTATUS, FIFOEMP jz pkt_status_report_overrun;
+	test	SEQINTSRC, CTXTDONE jz . + 2;
+	test	DFSTATUS, FIFOEMP jnz pkt_status_IU_done;
+	test	SCSIPHASE, ~DATA_PHASE_MASK jz return;
+	test	DFSTATUS, FIFOEMP jnz pkt_status_check_nonpackreq;
+pkt_status_report_overrun:
+	SET_SEQINTCODE(STATUS_OVERRUN)
+	/* SEQUENCER RESTARTED */
+pkt_status_check_nonpackreq:
+	/*
+	 * CTXTDONE may be held off if a NONPACKREQ is associated with
+	 * the current context.  If a NONPACKREQ is observed, decide
+	 * if it is for the current context.  If it is for the current
+	 * context, we must defer NONPACKREQ processing until all data
+	 * has transferred to the host.
+	 */
+	test	SCSIPHASE, ~DATA_PHASE_MASK jz return;
+	test	SCSISIGO, ATNO jnz . + 2;
+	test	SSTAT2, NONPACKREQ jz return;
+	test	SEQINTSRC, CTXTDONE jnz pkt_status_IU_done;
+	test	DFSTATUS, FIFOEMP jz return;
+	/*
+	 * The unexpected nonpkt phase handler assumes that any
+	 * data channel use will have a FIFO reference count.  It
+	 * turns out that the status handler doesn't need a refernce
+	 * count since the status received flag, and thus completion
+	 * processing, cannot be set until the handler is finished.
+	 * We increment the count here to make the nonpkt handler
+	 * happy.
+	 */
+	inc	SCB_FIFO_USE_COUNT;
+	/* FALLTHROUGH */
+
+/*
+ * Nonpackreq is a polled status.  It can come true in three situations:
+ * we have received an L_Q, we have sent one or more L_Qs, or there is no
+ * L_Q context associated with this REQ (REQ occurs immediately after a
+ * (re)selection).  Routines that know that the context responsible for this
+ * nonpackreq call directly into unexpected_nonpkt_phase.  In the case of the
+ * top level idle loop, we exhaust all active contexts prior to determining that
+ * we simply do not have the full I_T_L_Q for this phase.
+ */
+unexpected_nonpkt_phase_find_ctxt:
+	/*
+	 * This nonpackreq is most likely associated with one of the tags
+	 * in a FIFO or an outgoing LQ.  Only treat it as an I_T only
+	 * nonpackreq if we've cleared out the FIFOs and handled any
+	 * pending SELDO.
+	 */
+SET_SRC_MODE	M_SCSI;
+SET_DST_MODE	M_SCSI;
+	and	A, FIFO1FREE|FIFO0FREE, DFFSTAT;
+	cmp	A, FIFO1FREE|FIFO0FREE jne return;
+	test	SSTAT0, SELDO jnz return;
+	mvi	SCBPTR[1], SCB_LIST_NULL;
+unexpected_nonpkt_phase:
+	test	MODE_PTR, ~(MK_MODE(M_DFF1, M_DFF1)) jnz . + 3;
+SET_SRC_MODE	M_DFF0;
+SET_DST_MODE	M_DFF0;
+	or	LONGJMP_ADDR[1], INVALID_ADDR;
+	dec	SCB_FIFO_USE_COUNT;
+	mvi	DFFSXFRCTL, CLRCHN;
+	mvi	CLRSINT2, CLRNONPACKREQ;
+	test	SCSIPHASE, ~(MSG_IN_PHASE|MSG_OUT_PHASE) jnz illegal_phase;
+	SET_SEQINTCODE(ENTERING_NONPACK)
+	jmp	ITloop;
+
+illegal_phase:
+	SET_SEQINTCODE(ILLEGAL_PHASE)
+	jmp	ITloop;
+
+/*
+ * We have entered an overrun situation.  If we have working
+ * BITBUCKET, flip that on and let the hardware eat any overrun
+ * data.  Otherwise use an overrun buffer in the host to simulate
+ * BITBUCKET.
+ */
+pkt_handle_overrun_inc_use_count:
+	inc	SCB_FIFO_USE_COUNT;
+pkt_handle_overrun:
+	SET_SEQINTCODE(CFG4OVERRUN)
+	call	freeze_queue;
+	if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) == 0) {
+		or	DFFSXFRCTL, DFFBITBUCKET;
+SET_SRC_MODE	M_DFF1;
+SET_DST_MODE	M_DFF1;
+	} else {
+		call	load_overrun_buf;
+		mvi	DFCNTRL, (HDMAEN|SCSIEN|PRELOADEN);
+	}
+	call	setjmp;
+	if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0) {
+		test	DFSTATUS, PRELOAD_AVAIL jz overrun_load_done;
+		call	load_overrun_buf;
+		or	DFCNTRL, PRELOADEN;
+overrun_load_done:
+		test	SEQINTSRC, CTXTDONE jnz pkt_overrun_end;
+	} else {
+		test	DFFSXFRCTL, DFFBITBUCKET jz pkt_overrun_end;
+	}
+	test	SSTAT2, NONPACKREQ jz return;
+pkt_overrun_end:
+	or	SCB_RESIDUAL_SGPTR, SG_OVERRUN_RESID;
+	test	SEQINTSRC, CTXTDONE jz unexpected_nonpkt_phase;
+	dec	SCB_FIFO_USE_COUNT;
+	or	LONGJMP_ADDR[1], INVALID_ADDR;
+	test	SCB_CONTROL, STATUS_RCVD jnz pkt_complete_scb_if_fifos_idle;
+	mvi	DFFSXFRCTL, CLRCHN ret;
+
+if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0) {
+load_overrun_buf:
+	/*
+	 * Load a dummy segment if preload space is available.
+	 */
+	mov 	HADDR[0], SHARED_DATA_ADDR;
+	add	HADDR[1], PKT_OVERRUN_BUFOFFSET, SHARED_DATA_ADDR[1];
+	mov	ACCUM_SAVE, A;
+	clr	A;
+	adc	HADDR[2], A, SHARED_DATA_ADDR[2];
+	adc	HADDR[3], A, SHARED_DATA_ADDR[3];
+	mov	A, ACCUM_SAVE;
+	bmov	HADDR[4], ALLZEROS, 4;
+	/* PKT_OVERRUN_BUFSIZE is a multiple of 256 */
+	clr	HCNT[0];
+	mvi	HCNT[1], ((PKT_OVERRUN_BUFSIZE >> 8) & 0xFF);
+	clr	HCNT[2] ret;
+}
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic79xx_core.c linux-5730/drivers/scsi/aic7xxx/aic79xx_core.c
--- linux-5720/drivers/scsi/aic7xxx/aic79xx_core.c
+++ linux-5730/drivers/scsi/aic7xxx/aic79xx_core.c
@@ -0,0 +1,9542 @@
+/*
+ * Core routines and tables shareable across OS platforms.
+ *
+ * Copyright (c) 1994-2002 Justin T. Gibbs.
+ * Copyright (c) 2000-2003 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.c#197 $
+ *
+ * $FreeBSD$
+ */
+
+#ifdef __linux__
+#include "aic79xx_osm.h"
+#include "aic79xx_inline.h"
+#include "aicasm/aicasm_insformat.h"
+#else
+#include <dev/aic7xxx/aic79xx_osm.h>
+#include <dev/aic7xxx/aic79xx_inline.h>
+#include <dev/aic7xxx/aicasm/aicasm_insformat.h>
+#endif
+
+/******************************** Globals *************************************/
+struct ahd_softc_tailq ahd_tailq = TAILQ_HEAD_INITIALIZER(ahd_tailq);
+uint32_t ahd_attach_to_HostRAID_controllers = 1;
+
+/***************************** Lookup Tables **********************************/
+char *ahd_chip_names[] =
+{
+	"NONE",
+	"aic7901",
+	"aic7902",
+	"aic7901A"
+};
+static const u_int num_chip_names = NUM_ELEMENTS(ahd_chip_names);
+
+/*
+ * Hardware error codes.
+ */
+struct ahd_hard_error_entry {
+        uint8_t errno;
+	char *errmesg;
+};
+
+static struct ahd_hard_error_entry ahd_hard_errors[] = {
+	{ DSCTMOUT,	"Discard Timer has timed out" },
+	{ ILLOPCODE,	"Illegal Opcode in sequencer program" },
+	{ SQPARERR,	"Sequencer Parity Error" },
+	{ DPARERR,	"Data-path Parity Error" },
+	{ MPARERR,	"Scratch or SCB Memory Parity Error" },
+	{ CIOPARERR,	"CIOBUS Parity Error" },
+};
+static const u_int num_errors = NUM_ELEMENTS(ahd_hard_errors);
+
+static struct ahd_phase_table_entry ahd_phase_table[] =
+{
+	{ P_DATAOUT,	MSG_NOOP,		"in Data-out phase"	},
+	{ P_DATAIN,	MSG_INITIATOR_DET_ERR,	"in Data-in phase"	},
+	{ P_DATAOUT_DT,	MSG_NOOP,		"in DT Data-out phase"	},
+	{ P_DATAIN_DT,	MSG_INITIATOR_DET_ERR,	"in DT Data-in phase"	},
+	{ P_COMMAND,	MSG_NOOP,		"in Command phase"	},
+	{ P_MESGOUT,	MSG_NOOP,		"in Message-out phase"	},
+	{ P_STATUS,	MSG_INITIATOR_DET_ERR,	"in Status phase"	},
+	{ P_MESGIN,	MSG_PARITY_ERROR,	"in Message-in phase"	},
+	{ P_BUSFREE,	MSG_NOOP,		"while idle"		},
+	{ 0,		MSG_NOOP,		"in unknown phase"	}
+};
+
+/*
+ * In most cases we only wish to itterate over real phases, so
+ * exclude the last element from the count.
+ */
+static const u_int num_phases = NUM_ELEMENTS(ahd_phase_table) - 1;
+
+/* Our Sequencer Program */
+#include "aic79xx_seq.h"
+
+/**************************** Function Declarations ***************************/
+static void		ahd_handle_transmission_error(struct ahd_softc *ahd);
+static void		ahd_handle_lqiphase_error(struct ahd_softc *ahd,
+						  u_int lqistat1);
+static int		ahd_handle_pkt_busfree(struct ahd_softc *ahd,
+					       u_int busfreetime);
+static int		ahd_handle_nonpkt_busfree(struct ahd_softc *ahd);
+static void		ahd_handle_proto_violation(struct ahd_softc *ahd);
+static void		ahd_force_renegotiation(struct ahd_softc *ahd,
+						struct ahd_devinfo *devinfo);
+
+static struct ahd_tmode_tstate*
+			ahd_alloc_tstate(struct ahd_softc *ahd,
+					 u_int scsi_id, char channel);
+#ifdef AHD_TARGET_MODE
+static void		ahd_free_tstate(struct ahd_softc *ahd,
+					u_int scsi_id, char channel, int force);
+#endif
+static void		ahd_devlimited_syncrate(struct ahd_softc *ahd,
+					        struct ahd_initiator_tinfo *,
+						u_int *period,
+						u_int *ppr_options,
+						role_t role);
+static void		ahd_update_neg_table(struct ahd_softc *ahd,
+					     struct ahd_devinfo *devinfo,
+					     struct ahd_transinfo *tinfo);
+static void		ahd_update_pending_scbs(struct ahd_softc *ahd);
+static void		ahd_fetch_devinfo(struct ahd_softc *ahd,
+					  struct ahd_devinfo *devinfo);
+static void		ahd_scb_devinfo(struct ahd_softc *ahd,
+					struct ahd_devinfo *devinfo,
+					struct scb *scb);
+static void		ahd_setup_initiator_msgout(struct ahd_softc *ahd,
+						   struct ahd_devinfo *devinfo,
+						   struct scb *scb);
+static void		ahd_build_transfer_msg(struct ahd_softc *ahd,
+					       struct ahd_devinfo *devinfo);
+static void		ahd_construct_sdtr(struct ahd_softc *ahd,
+					   struct ahd_devinfo *devinfo,
+					   u_int period, u_int offset);
+static void		ahd_construct_wdtr(struct ahd_softc *ahd,
+					   struct ahd_devinfo *devinfo,
+					   u_int bus_width);
+static void		ahd_construct_ppr(struct ahd_softc *ahd,
+					  struct ahd_devinfo *devinfo,
+					  u_int period, u_int offset,
+					  u_int bus_width, u_int ppr_options);
+static void		ahd_clear_msg_state(struct ahd_softc *ahd);
+static void		ahd_handle_message_phase(struct ahd_softc *ahd);
+typedef enum {
+	AHDMSG_1B,
+	AHDMSG_2B,
+	AHDMSG_EXT
+} ahd_msgtype;
+static int		ahd_sent_msg(struct ahd_softc *ahd, ahd_msgtype type,
+				     u_int msgval, int full);
+static int		ahd_parse_msg(struct ahd_softc *ahd,
+				      struct ahd_devinfo *devinfo);
+static int		ahd_handle_msg_reject(struct ahd_softc *ahd,
+					      struct ahd_devinfo *devinfo);
+static void		ahd_handle_ign_wide_residue(struct ahd_softc *ahd,
+						struct ahd_devinfo *devinfo);
+static void		ahd_reinitialize_dataptrs(struct ahd_softc *ahd);
+static void		ahd_handle_devreset(struct ahd_softc *ahd,
+					    struct ahd_devinfo *devinfo,
+					    u_int lun, cam_status status,
+					    char *message, int verbose_level);
+#if AHD_TARGET_MODE
+static void		ahd_setup_target_msgin(struct ahd_softc *ahd,
+					       struct ahd_devinfo *devinfo,
+					       struct scb *scb);
+#endif
+
+static u_int		ahd_sglist_size(struct ahd_softc *ahd);
+static u_int		ahd_sglist_allocsize(struct ahd_softc *ahd);
+static bus_dmamap_callback_t
+			ahd_dmamap_cb; 
+static void		ahd_initialize_hscbs(struct ahd_softc *ahd);
+static int		ahd_init_scbdata(struct ahd_softc *ahd);
+static void		ahd_fini_scbdata(struct ahd_softc *ahd);
+static void		ahd_setup_iocell_workaround(struct ahd_softc *ahd);
+static void		ahd_iocell_first_selection(struct ahd_softc *ahd);
+static void		ahd_add_col_list(struct ahd_softc *ahd,
+					 struct scb *scb, u_int col_idx);
+static void		ahd_rem_col_list(struct ahd_softc *ahd,
+					 struct scb *scb);
+static void		ahd_chip_init(struct ahd_softc *ahd);
+static void		ahd_qinfifo_requeue(struct ahd_softc *ahd,
+					    struct scb *prev_scb,
+					    struct scb *scb);
+static int		ahd_qinfifo_count(struct ahd_softc *ahd);
+static int		ahd_search_scb_list(struct ahd_softc *ahd, int target,
+					    char channel, int lun, u_int tag,
+					    role_t role, uint32_t status,
+					    ahd_search_action action,
+					    u_int *list_head, u_int tid);
+static void		ahd_stitch_tid_list(struct ahd_softc *ahd,
+					    u_int tid_prev, u_int tid_cur,
+					    u_int tid_next);
+static void		ahd_add_scb_to_free_list(struct ahd_softc *ahd,
+						 u_int scbid);
+static u_int		ahd_rem_wscb(struct ahd_softc *ahd, u_int scbid,
+				     u_int prev, u_int next, u_int tid);
+static void		ahd_reset_current_bus(struct ahd_softc *ahd);
+static ahd_callback_t	ahd_reset_poll;
+static ahd_callback_t	ahd_stat_timer;
+#ifdef AHD_DUMP_SEQ
+static void		ahd_dumpseq(struct ahd_softc *ahd);
+#endif
+static void		ahd_loadseq(struct ahd_softc *ahd);
+static int		ahd_check_patch(struct ahd_softc *ahd,
+					struct patch **start_patch,
+					u_int start_instr, u_int *skip_addr);
+static u_int		ahd_resolve_seqaddr(struct ahd_softc *ahd,
+					    u_int address);
+static void		ahd_download_instr(struct ahd_softc *ahd,
+					   u_int instrptr, uint8_t *dconsts);
+static int		ahd_probe_stack_size(struct ahd_softc *ahd);
+#ifdef AHD_TARGET_MODE
+static void		ahd_queue_lstate_event(struct ahd_softc *ahd,
+					       struct ahd_tmode_lstate *lstate,
+					       u_int initiator_id,
+					       u_int event_type,
+					       u_int event_arg);
+static void		ahd_update_scsiid(struct ahd_softc *ahd,
+					  u_int targid_mask);
+static int		ahd_handle_target_cmd(struct ahd_softc *ahd,
+					      struct target_cmd *cmd);
+#endif
+
+/******************************** Private Inlines *****************************/
+static __inline void	ahd_assert_atn(struct ahd_softc *ahd);
+static __inline int	ahd_currently_packetized(struct ahd_softc *ahd);
+static __inline int	ahd_set_active_fifo(struct ahd_softc *ahd);
+
+static __inline void
+ahd_assert_atn(struct ahd_softc *ahd)
+{
+	ahd_outb(ahd, SCSISIGO, ATNO);
+}
+
+/*
+ * Determine if the current connection has a packetized
+ * agreement.  This does not necessarily mean that we
+ * are currently in a packetized transfer.  We could
+ * just as easily be sending or receiving a message.
+ */
+static __inline int
+ahd_currently_packetized(struct ahd_softc *ahd)
+{
+	ahd_mode_state	 saved_modes;
+	int		 packetized;
+
+	saved_modes = ahd_save_modes(ahd);
+	if ((ahd->bugs & AHD_PKTIZED_STATUS_BUG) != 0) {
+		/*
+		 * The packetized bit refers to the last
+		 * connection, not the current one.  Check
+		 * for non-zero LQISTATE instead.
+		 */
+		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+		packetized = ahd_inb(ahd, LQISTATE) != 0;
+	} else {
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+		packetized = ahd_inb(ahd, LQISTAT2) & PACKETIZED;
+	}
+	ahd_restore_modes(ahd, saved_modes);
+	return (packetized);
+}
+
+static __inline int
+ahd_set_active_fifo(struct ahd_softc *ahd)
+{
+	u_int active_fifo;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	active_fifo = ahd_inb(ahd, DFFSTAT) & CURRFIFO;
+	switch (active_fifo) {
+	case 0:
+	case 1:
+		ahd_set_modes(ahd, active_fifo, active_fifo);
+		return (1);
+	default:
+		return (0);
+	}
+}
+
+/************************* Sequencer Execution Control ************************/
+/*
+ * Restart the sequencer program from address zero
+ */
+void
+ahd_restart(struct ahd_softc *ahd)
+{
+
+	ahd_pause(ahd);
+
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+
+	/* No more pending messages */
+	ahd_clear_msg_state(ahd);
+	ahd_outb(ahd, SCSISIGO, 0);		/* De-assert BSY */
+	ahd_outb(ahd, MSG_OUT, MSG_NOOP);	/* No message to send */
+	ahd_outb(ahd, SXFRCTL1, ahd_inb(ahd, SXFRCTL1) & ~BITBUCKET);
+	ahd_outb(ahd, SEQINTCTL, 0);
+	ahd_outb(ahd, LASTPHASE, P_BUSFREE);
+	ahd_outb(ahd, SEQ_FLAGS, 0);
+	ahd_outb(ahd, SAVED_SCSIID, 0xFF);
+	ahd_outb(ahd, SAVED_LUN, 0xFF);
+
+	/*
+	 * Ensure that the sequencer's idea of TQINPOS
+	 * matches our own.  The sequencer increments TQINPOS
+	 * only after it sees a DMA complete and a reset could
+	 * occur before the increment leaving the kernel to believe
+	 * the command arrived but the sequencer to not.
+	 */
+	ahd_outb(ahd, TQINPOS, ahd->tqinfifonext);
+
+	/* Always allow reselection */
+	ahd_outb(ahd, SCSISEQ1,
+		 ahd_inb(ahd, SCSISEQ_TEMPLATE) & (ENSELI|ENRSELI|ENAUTOATNP));
+	/* Ensure that no DMA operations are in progress */
+	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
+	ahd_outb(ahd, SCBHCNT, 0);
+	ahd_outb(ahd, CCSCBCTL, CCSCBRESET);
+	ahd_outb(ahd, SEQCTL0, FASTMODE|SEQRESET);
+	ahd_unpause(ahd);
+}
+
+void
+ahd_clear_fifo(struct ahd_softc *ahd, u_int fifo)
+{
+	ahd_mode_state	 saved_modes;
+
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_FIFOS) != 0)
+		printf("%s: Clearing FIFO %d\n", ahd_name(ahd), fifo);
+#endif
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, fifo, fifo);
+	ahd_outb(ahd, DFFSXFRCTL, RSTCHN|CLRSHCNT);
+	if ((ahd_inb(ahd, SG_STATE) & FETCH_INPROG) != 0)
+		ahd_outb(ahd, CCSGCTL, CCSGRESET);
+	ahd_outb(ahd, LONGJMP_ADDR + 1, INVALID_ADDR);
+	ahd_outb(ahd, SG_STATE, 0);
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+/************************* Input/Output Queues ********************************/
+/*
+ * Flush and completed commands that are sitting in the command
+ * complete queues down on the chip but have yet to be dma'ed back up.
+ */
+void
+ahd_flush_qoutfifo(struct ahd_softc *ahd)
+{
+	struct		scb *scb;
+	ahd_mode_state	saved_modes;
+	u_int		saved_scbptr;
+	u_int		ccscbctl;
+	u_int		scbid;
+	u_int		next_scbid;
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
+	saved_scbptr = ahd_get_scbptr(ahd);
+
+	/*
+	 * Wait for any inprogress DMA to complete and clear DMA state
+	 * if this if for an SCB in the qinfifo.
+	 */
+	while ((ccscbctl = ahd_inb(ahd, CCSCBCTL) & (CCARREN|CCSCBEN)) != 0) {
+
+		if ((ccscbctl & (CCSCBDIR|CCARREN)) == (CCSCBDIR|CCARREN)) {
+			if ((ccscbctl & ARRDONE) != 0)
+				break;
+		} else if ((ccscbctl & CCSCBDONE) != 0)
+			break;
+		ahd_delay(200);
+	}
+	if ((ccscbctl & CCSCBDIR) != 0)
+		ahd_outb(ahd, CCSCBCTL, ccscbctl & ~(CCARREN|CCSCBEN));
+
+	/*
+	 * Complete any SCBs that just finished being
+	 * DMA'ed into the qoutfifo.
+	 */
+	ahd_run_qoutfifo(ahd);
+
+	/*
+	 * Manually update/complete any completed SCBs that are waiting to be
+	 * DMA'ed back up to the host.
+	 */
+	scbid = ahd_inw(ahd, COMPLETE_DMA_SCB_HEAD);
+	while (!SCBID_IS_NULL(scbid)) {
+		uint8_t *hscb_ptr;
+		u_int	 i;
+		
+		ahd_set_scbptr(ahd, scbid);
+		next_scbid = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL) {
+			printf("%s: Warning - DMA-up and complete "
+			       "SCB %d invalid\n", ahd_name(ahd), scbid);
+			continue;
+		}
+		hscb_ptr = (uint8_t *)scb->hscb;
+		for (i = 0; i < sizeof(struct hardware_scb); i++)
+			*hscb_ptr++ = ahd_inb_scbram(ahd, SCB_BASE + i);
+
+		ahd_complete_scb(ahd, scb);
+		scbid = next_scbid;
+	}
+	ahd_outw(ahd, COMPLETE_DMA_SCB_HEAD, SCB_LIST_NULL);
+
+	scbid = ahd_inw(ahd, COMPLETE_SCB_HEAD);
+	while (!SCBID_IS_NULL(scbid)) {
+
+		ahd_set_scbptr(ahd, scbid);
+		next_scbid = ahd_inw_scbram(ahd, SCB_NEXT_COMPLETE);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL) {
+			printf("%s: Warning - Complete SCB %d invalid\n",
+			       ahd_name(ahd), scbid);
+			continue;
+		}
+
+		ahd_complete_scb(ahd, scb);
+		scbid = next_scbid;
+	}
+	ahd_outw(ahd, COMPLETE_SCB_HEAD, SCB_LIST_NULL);
+	ahd_set_scbptr(ahd, saved_scbptr);
+
+	/*
+	 * Flush the good status FIFO for compelted packetized commands.
+	 */
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	while ((ahd_inb(ahd, LQISTAT2) & LQIGSAVAIL) != 0) {
+		scbid = (ahd_inb(ahd, GSFIFO+1) << 8)
+		      | ahd_inb(ahd, GSFIFO);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL) {
+			printf("%s: Warning - GSFIFO SCB %d invalid\n",
+			       ahd_name(ahd), scbid);
+			continue;
+		}
+		ahd_complete_scb(ahd, scb);
+	}
+
+	/*
+	 * Restore state.
+	 */
+	ahd_restore_modes(ahd, saved_modes);
+	ahd->flags |= AHD_UPDATE_PEND_CMDS;
+}
+
+void
+ahd_run_qoutfifo(struct ahd_softc *ahd)
+{
+	struct scb *scb;
+	u_int  scb_index;
+
+	if ((ahd->flags & AHD_RUNNING_QOUTFIFO) != 0)
+		panic("ahd_run_qoutfifo recursion");
+	ahd->flags |= AHD_RUNNING_QOUTFIFO;
+	ahd_sync_qoutfifo(ahd, BUS_DMASYNC_POSTREAD);
+	while ((ahd->qoutfifo[ahd->qoutfifonext]
+	     & QOUTFIFO_ENTRY_VALID_LE) == ahd->qoutfifonext_valid_tag) {
+
+		scb_index = ahd_le16toh(ahd->qoutfifo[ahd->qoutfifonext]
+				      & ~QOUTFIFO_ENTRY_VALID_LE);
+		scb = ahd_lookup_scb(ahd, scb_index);
+		if (scb == NULL) {
+			printf("%s: WARNING no command for scb %d "
+			       "(cmdcmplt)\nQOUTPOS = %d\n",
+			       ahd_name(ahd), scb_index,
+			       ahd->qoutfifonext);
+			ahd_dump_card_state(ahd);
+		} else
+			ahd_complete_scb(ahd, scb);
+
+		ahd->qoutfifonext = (ahd->qoutfifonext+1) & (AHD_QOUT_SIZE-1);
+		if (ahd->qoutfifonext == 0)
+			ahd->qoutfifonext_valid_tag ^= QOUTFIFO_ENTRY_VALID_LE;
+	}
+	ahd->flags &= ~AHD_RUNNING_QOUTFIFO;
+}
+
+/************************* Interrupt Handling *********************************/
+void
+ahd_handle_hwerrint(struct ahd_softc *ahd)
+{
+	/*
+	 * Some catastrophic hardware error has occurred.
+	 * Print it for the user and disable the controller.
+	 */
+	int i;
+	int error;
+
+	error = ahd_inb(ahd, ERROR);
+	for (i = 0; i < num_errors; i++) {
+		if ((error & ahd_hard_errors[i].errno) != 0)
+			printf("%s: hwerrint, %s\n",
+			       ahd_name(ahd), ahd_hard_errors[i].errmesg);
+	}
+
+	ahd_dump_card_state(ahd);
+	panic("BRKADRINT");
+
+	/* Tell everyone that this HBA is no longer available */
+	ahd_abort_scbs(ahd, CAM_TARGET_WILDCARD, ALL_CHANNELS,
+		       CAM_LUN_WILDCARD, SCB_LIST_NULL, ROLE_UNKNOWN,
+		       CAM_NO_HBA);
+
+	/* Tell the system that this controller has gone away. */
+	ahd_free(ahd);
+}
+
+void
+ahd_handle_seqint(struct ahd_softc *ahd, u_int intstat)
+{
+	u_int seqintcode;
+
+	/*
+	 * Save the sequencer interrupt code and clear the SEQINT
+	 * bit. We will unpause the sequencer, if appropriate,
+	 * after servicing the request.
+	 */
+	seqintcode = ahd_inb(ahd, SEQINTCODE);
+	ahd_outb(ahd, CLRINT, CLRSEQINT);
+	if ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {
+		/*
+		 * Unpause the sequencer and let it clear
+		 * SEQINT by writing NO_SEQINT to it.  This
+		 * will cause the sequencer to be paused again,
+		 * which is the expected state of this routine.
+		 */
+		ahd_unpause(ahd);
+		while (!ahd_is_paused(ahd))
+			;
+		ahd_outb(ahd, CLRINT, CLRSEQINT);
+	}
+	ahd_update_modes(ahd);
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_MISC) != 0)
+		printf("%s: Handle Seqint Called for code %d\n",
+		       ahd_name(ahd), seqintcode);
+#endif
+	switch (seqintcode) {
+	case BAD_SCB_STATUS:
+	{
+		struct	scb *scb;
+		u_int	scbid;
+		int	cmds_pending;
+
+		scbid = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb != NULL) {
+			ahd_complete_scb(ahd, scb);
+		} else {
+			printf("%s: WARNING no command for scb %d "
+			       "(bad status)\n", ahd_name(ahd), scbid);
+			ahd_dump_card_state(ahd);
+		}
+		cmds_pending = ahd_inw(ahd, CMDS_PENDING);
+		if (cmds_pending > 0)
+			ahd_outw(ahd, CMDS_PENDING, cmds_pending - 1);
+		break;
+	}
+	case ENTERING_NONPACK:
+	{
+		struct	scb *scb;
+		u_int	scbid;
+
+		AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
+				 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
+		scbid = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL) {
+			/*
+			 * Somehow need to know if this
+			 * is from a selection or reselection.
+			 * From that, we can termine target
+			 * ID so we at least have an I_T nexus.
+			 */
+		} else {
+			ahd_outb(ahd, SAVED_SCSIID, scb->hscb->scsiid);
+			ahd_outb(ahd, SAVED_LUN, scb->hscb->lun);
+			ahd_outb(ahd, SEQ_FLAGS, 0x0);
+		}
+		if ((ahd_inb(ahd, LQISTAT2) & LQIPHASE_OUTPKT) != 0
+		 && (ahd_inb(ahd, SCSISIGO) & ATNO) != 0) {
+			/*
+			 * Phase change after read stream with
+			 * CRC error with P0 asserted on last
+			 * packet.
+			 */
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_RECOVERY) != 0)
+				printf("%s: Assuming LQIPHASE_NLQ with "
+				       "P0 assertion\n", ahd_name(ahd));
+#endif
+		}
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_RECOVERY) != 0)
+			printf("%s: Entering NONPACK\n", ahd_name(ahd));
+#endif
+		break;
+	}
+	case INVALID_SEQINT:
+		printf("%s: Invalid Sequencer interrupt occurred.\n",
+		       ahd_name(ahd));
+		ahd_dump_card_state(ahd);
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+		break;
+	case STATUS_OVERRUN:
+	{
+		struct	scb *scb;
+		u_int	scbid;
+
+		scbid = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb != NULL)
+			ahd_print_path(ahd, scb);
+		else
+			printf("%s: ", ahd_name(ahd));
+		printf("SCB %d Packetized Status Overrun", scbid);
+		ahd_dump_card_state(ahd);
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+		break;
+	}
+	case CFG4ISTAT_INTR:
+	{
+		struct	scb *scb;
+		u_int	scbid;
+
+		scbid = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL) {
+			ahd_dump_card_state(ahd);
+			printf("CFG4ISTAT: Free SCB %d referenced", scbid);
+			panic("For safety");
+		}
+		ahd_outq(ahd, HADDR, scb->sense_busaddr);
+		ahd_outw(ahd, HCNT, AHD_SENSE_BUFSIZE);
+		ahd_outb(ahd, HCNT + 2, 0);
+		ahd_outb(ahd, SG_CACHE_PRE, SG_LAST_SEG);
+		ahd_outb(ahd, DFCNTRL, PRELOADEN|SCSIEN|HDMAEN);
+		break;
+	}
+	case ILLEGAL_PHASE:
+	{
+		u_int bus_phase;
+
+		bus_phase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;
+		printf("%s: ILLEGAL_PHASE 0x%x\n",
+		       ahd_name(ahd), bus_phase);
+
+		switch (bus_phase) {
+		case P_DATAOUT:
+		case P_DATAIN:
+		case P_DATAOUT_DT:
+		case P_DATAIN_DT:
+		case P_MESGOUT:
+		case P_STATUS:
+		case P_MESGIN:
+			ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+			printf("%s: Issued Bus Reset.\n", ahd_name(ahd));
+			break;
+		case P_COMMAND:
+		{
+			struct	ahd_devinfo devinfo;
+			struct	scb *scb;
+			struct	ahd_initiator_tinfo *targ_info;
+			struct	ahd_tmode_tstate *tstate;
+			struct	ahd_transinfo *tinfo;
+			u_int	scbid;
+
+			/*
+			 * If a target takes us into the command phase
+			 * assume that it has been externally reset and
+			 * has thus lost our previous packetized negotiation
+			 * agreement.  Since we have not sent an identify
+			 * message and may not have fully qualified the
+			 * connection, we change our command to TUR, assert
+			 * ATN and ABORT the task when we go to message in
+			 * phase.  The OSM will see the REQUEUE_REQUEST
+			 * status and retry the command.
+			 */
+			scbid = ahd_get_scbptr(ahd);
+			scb = ahd_lookup_scb(ahd, scbid);
+			if (scb == NULL) {
+				printf("Invalid phase with no valid SCB.  "
+				       "Resetting bus.\n");
+				ahd_reset_channel(ahd, 'A',
+						  /*Initiate Reset*/TRUE);
+				break;
+			}
+			ahd_compile_devinfo(&devinfo, SCB_GET_OUR_ID(scb),
+					    SCB_GET_TARGET(ahd, scb),
+					    SCB_GET_LUN(scb),
+					    SCB_GET_CHANNEL(ahd, scb),
+					    ROLE_INITIATOR);
+			targ_info = ahd_fetch_transinfo(ahd,
+							devinfo.channel,
+							devinfo.our_scsiid,
+							devinfo.target,
+							&tstate);
+			tinfo = &targ_info->curr;
+			ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+				      AHD_TRANS_ACTIVE, /*paused*/TRUE);
+			ahd_set_syncrate(ahd, &devinfo, /*period*/0,
+					 /*offset*/0, /*ppr_options*/0,
+					 AHD_TRANS_ACTIVE, /*paused*/TRUE);
+			ahd_outb(ahd, SCB_CDB_STORE, 0);
+			ahd_outb(ahd, SCB_CDB_STORE+1, 0);
+			ahd_outb(ahd, SCB_CDB_STORE+2, 0);
+			ahd_outb(ahd, SCB_CDB_STORE+3, 0);
+			ahd_outb(ahd, SCB_CDB_STORE+4, 0);
+			ahd_outb(ahd, SCB_CDB_STORE+5, 0);
+			ahd_outb(ahd, SCB_CDB_LEN, 6);
+			scb->hscb->control &= ~(TAG_ENB|SCB_TAG_TYPE);
+			scb->hscb->control |= MK_MESSAGE;
+			ahd_outb(ahd, SCB_CONTROL, scb->hscb->control);
+			ahd_outb(ahd, MSG_OUT, HOST_MSG);
+			ahd_outb(ahd, SAVED_SCSIID, scb->hscb->scsiid);
+			/*
+			 * The lun is 0, regardless of the SCB's lun
+			 * as we have not sent an identify message.
+			 */
+			ahd_outb(ahd, SAVED_LUN, 0);
+			ahd_outb(ahd, SEQ_FLAGS, 0);
+			ahd_assert_atn(ahd);
+			scb->flags &= ~(SCB_PACKETIZED);
+			scb->flags |= SCB_ABORT|SCB_CMDPHASE_ABORT;
+			ahd_freeze_devq(ahd, scb);
+			ahd_set_transaction_status(scb, CAM_REQUEUE_REQ);
+			ahd_freeze_scb(scb);
+
+			/*
+			 * Allow the sequencer to continue with
+			 * non-pack processing.
+			 */
+			ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+			ahd_outb(ahd, CLRLQOINT1, CLRLQOPHACHGINPKT);
+			if ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0) {
+				ahd_outb(ahd, CLRLQOINT1, 0);
+			}
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {
+				ahd_print_path(ahd, scb);
+				printf("Unexpected command phase from "
+				       "packetized target\n");
+			}
+#endif
+			break;
+		}
+		}
+		break;
+	}
+	case CFG4OVERRUN:
+	{
+		struct	scb *scb;
+		u_int	scb_index;
+		
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {
+			printf("%s: CFG4OVERRUN mode = %x\n", ahd_name(ahd),
+			       ahd_inb(ahd, MODE_PTR));
+		}
+#endif
+		scb_index = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scb_index);
+		if (scb == NULL) {
+			/*
+			 * Attempt to transfer to an SCB that is
+			 * not outstanding.
+			 */
+			ahd_assert_atn(ahd);
+			ahd_outb(ahd, MSG_OUT, HOST_MSG);
+			ahd->msgout_buf[0] = MSG_ABORT_TASK;
+			ahd->msgout_len = 1;
+			ahd->msgout_index = 0;
+			ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
+			/*
+			 * Clear status received flag to prevent any
+			 * attempt to complete this bogus SCB.
+			 */
+			ahd_outb(ahd, SCB_CONTROL,
+				 ahd_inb(ahd, SCB_CONTROL) & ~STATUS_RCVD);
+		}
+		break;
+	}
+	case DUMP_CARD_STATE:
+	{
+		ahd_dump_card_state(ahd);
+		break;
+	}
+	case PDATA_REINIT:
+	{
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {
+			printf("%s: PDATA_REINIT - DFCNTRL = 0x%x "
+			       "SG_CACHE_SHADOW = 0x%x\n",
+			       ahd_name(ahd), ahd_inb(ahd, DFCNTRL),
+			       ahd_inb(ahd, SG_CACHE_SHADOW));
+		}
+#endif
+		ahd_reinitialize_dataptrs(ahd);
+		break;
+	}
+	case HOST_MSG_LOOP:
+	{
+		struct ahd_devinfo devinfo;
+
+		/*
+		 * The sequencer has encountered a message phase
+		 * that requires host assistance for completion.
+		 * While handling the message phase(s), we will be
+		 * notified by the sequencer after each byte is
+		 * transfered so we can track bus phase changes.
+		 *
+		 * If this is the first time we've seen a HOST_MSG_LOOP
+		 * interrupt, initialize the state of the host message
+		 * loop.
+		 */
+		ahd_fetch_devinfo(ahd, &devinfo);
+		if (ahd->msg_type == MSG_TYPE_NONE) {
+			struct scb *scb;
+			u_int scb_index;
+			u_int bus_phase;
+
+			bus_phase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;
+			if (bus_phase != P_MESGIN
+			 && bus_phase != P_MESGOUT) {
+				printf("ahd_intr: HOST_MSG_LOOP bad "
+				       "phase 0x%x\n", bus_phase);
+				/*
+				 * Probably transitioned to bus free before
+				 * we got here.  Just punt the message.
+				 */
+				ahd_dump_card_state(ahd);
+				ahd_clear_intstat(ahd);
+				ahd_restart(ahd);
+				return;
+			}
+
+			scb_index = ahd_get_scbptr(ahd);
+			scb = ahd_lookup_scb(ahd, scb_index);
+			if (devinfo.role == ROLE_INITIATOR) {
+				if (bus_phase == P_MESGOUT)
+					ahd_setup_initiator_msgout(ahd,
+								   &devinfo,
+								   scb);
+				else {
+					ahd->msg_type =
+					    MSG_TYPE_INITIATOR_MSGIN;
+					ahd->msgin_index = 0;
+				}
+			}
+#if AHD_TARGET_MODE
+			else {
+				if (bus_phase == P_MESGOUT) {
+					ahd->msg_type =
+					    MSG_TYPE_TARGET_MSGOUT;
+					ahd->msgin_index = 0;
+				}
+				else 
+					ahd_setup_target_msgin(ahd,
+							       &devinfo,
+							       scb);
+			}
+#endif
+		}
+
+		ahd_handle_message_phase(ahd);
+		break;
+	}
+	case NO_MATCH:
+	{
+		/* Ensure we don't leave the selection hardware on */
+		AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+		ahd_outb(ahd, SCSISEQ0, ahd_inb(ahd, SCSISEQ0) & ~ENSELO);
+
+		printf("%s:%c:%d: no active SCB for reconnecting "
+		       "target - issuing BUS DEVICE RESET\n",
+		       ahd_name(ahd), 'A', ahd_inb(ahd, SELID) >> 4);
+		printf("SAVED_SCSIID == 0x%x, SAVED_LUN == 0x%x, "
+		       "REG0 == 0x%x ACCUM = 0x%x\n",
+		       ahd_inb(ahd, SAVED_SCSIID), ahd_inb(ahd, SAVED_LUN),
+		       ahd_inw(ahd, REG0), ahd_inb(ahd, ACCUM));
+		printf("SEQ_FLAGS == 0x%x, SCBPTR == 0x%x, BTT == 0x%x, "
+		       "SINDEX == 0x%x\n",
+		       ahd_inb(ahd, SEQ_FLAGS), ahd_get_scbptr(ahd),
+		       ahd_find_busy_tcl(ahd,
+					 BUILD_TCL(ahd_inb(ahd, SAVED_SCSIID),
+						   ahd_inb(ahd, SAVED_LUN))),
+		       ahd_inw(ahd, SINDEX));
+		printf("SELID == 0x%x, SCB_SCSIID == 0x%x, SCB_LUN == 0x%x, "
+		       "SCB_CONTROL == 0x%x\n",
+		       ahd_inb(ahd, SELID), ahd_inb_scbram(ahd, SCB_SCSIID),
+		       ahd_inb_scbram(ahd, SCB_LUN),
+		       ahd_inb_scbram(ahd, SCB_CONTROL));
+		printf("SCSIBUS[0] == 0x%x, SCSISIGI == 0x%x\n",
+		       ahd_inb(ahd, SCSIBUS), ahd_inb(ahd, SCSISIGI));
+		printf("SXFRCTL0 == 0x%x\n", ahd_inb(ahd, SXFRCTL0));
+		printf("SEQCTL0 == 0x%x\n", ahd_inb(ahd, SEQCTL0));
+		ahd_dump_card_state(ahd);
+		ahd->msgout_buf[0] = MSG_BUS_DEV_RESET;
+		ahd->msgout_len = 1;
+		ahd->msgout_index = 0;
+		ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
+		ahd_outb(ahd, MSG_OUT, HOST_MSG);
+		ahd_assert_atn(ahd);
+		break;
+	}
+	case PROTO_VIOLATION:
+	{
+		ahd_handle_proto_violation(ahd);
+		break;
+	}
+	case IGN_WIDE_RES:
+	{
+		struct ahd_devinfo devinfo;
+
+		ahd_fetch_devinfo(ahd, &devinfo);
+		ahd_handle_ign_wide_residue(ahd, &devinfo);
+		break;
+	}
+	case BAD_PHASE:
+	{
+		u_int lastphase;
+
+		lastphase = ahd_inb(ahd, LASTPHASE);
+		printf("%s:%c:%d: unknown scsi bus phase %x, "
+		       "lastphase = 0x%x.  Attempting to continue\n",
+		       ahd_name(ahd), 'A',
+		       SCSIID_TARGET(ahd, ahd_inb(ahd, SAVED_SCSIID)),
+		       lastphase, ahd_inb(ahd, SCSISIGI));
+		break;
+	}
+	case MISSED_BUSFREE:
+	{
+		u_int lastphase;
+
+		lastphase = ahd_inb(ahd, LASTPHASE);
+		printf("%s:%c:%d: Missed busfree. "
+		       "Lastphase = 0x%x, Curphase = 0x%x\n",
+		       ahd_name(ahd), 'A',
+		       SCSIID_TARGET(ahd, ahd_inb(ahd, SAVED_SCSIID)),
+		       lastphase, ahd_inb(ahd, SCSISIGI));
+		ahd_restart(ahd);
+		return;
+	}
+	case DATA_OVERRUN:
+	{
+		/*
+		 * When the sequencer detects an overrun, it
+		 * places the controller in "BITBUCKET" mode
+		 * and allows the target to complete its transfer.
+		 * Unfortunately, none of the counters get updated
+		 * when the controller is in this mode, so we have
+		 * no way of knowing how large the overrun was.
+		 */
+		struct	scb *scb;
+		u_int	scbindex;
+#ifdef AHD_DEBUG
+		u_int	lastphase;
+#endif
+
+		scbindex = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scbindex);
+#ifdef AHD_DEBUG
+		lastphase = ahd_inb(ahd, LASTPHASE);
+		if ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {
+			ahd_print_path(ahd, scb);
+			printf("data overrun detected %s.  Tag == 0x%x.\n",
+			       ahd_lookup_phase_entry(lastphase)->phasemsg,
+			       SCB_GET_TAG(scb));
+			ahd_print_path(ahd, scb);
+			printf("%s seen Data Phase.  Length = %ld.  "
+			       "NumSGs = %d.\n",
+			       ahd_inb(ahd, SEQ_FLAGS) & DPHASE
+			       ? "Have" : "Haven't",
+			       ahd_get_transfer_length(scb), scb->sg_count);
+			ahd_dump_sglist(scb);
+		}
+#endif
+
+		/*
+		 * Set this and it will take effect when the
+		 * target does a command complete.
+		 */
+		ahd_freeze_devq(ahd, scb);
+		ahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);
+		ahd_freeze_scb(scb);
+		break;
+	}
+	case MKMSG_FAILED:
+	{
+		struct ahd_devinfo devinfo;
+		struct scb *scb;
+		u_int scbid;
+
+		ahd_fetch_devinfo(ahd, &devinfo);
+		printf("%s:%c:%d:%d: Attempt to issue message failed\n",
+		       ahd_name(ahd), devinfo.channel, devinfo.target,
+		       devinfo.lun);
+		scbid = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb != NULL
+		 && (scb->flags & SCB_RECOVERY_SCB) != 0)
+			/*
+			 * Ensure that we didn't put a second instance of this
+			 * SCB into the QINFIFO.
+			 */
+			ahd_search_qinfifo(ahd, SCB_GET_TARGET(ahd, scb),
+					   SCB_GET_CHANNEL(ahd, scb),
+					   SCB_GET_LUN(scb), SCB_GET_TAG(scb),
+					   ROLE_INITIATOR, /*status*/0,
+					   SEARCH_REMOVE);
+		ahd_outb(ahd, SCB_CONTROL,
+			 ahd_inb(ahd, SCB_CONTROL) & ~MK_MESSAGE);
+		break;
+	}
+	case TASKMGMT_FUNC_COMPLETE:
+	{
+		u_int	scbid;
+		struct	scb *scb;
+
+		scbid = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb != NULL) {
+			u_int	   lun;
+			u_int	   tag;
+			cam_status error;
+
+			ahd_print_path(ahd, scb);
+			printf("Task Management Func 0x%x Complete\n",
+			       scb->hscb->task_management);
+			lun = CAM_LUN_WILDCARD;
+			tag = SCB_LIST_NULL;
+
+			switch (scb->hscb->task_management) {
+			case SIU_TASKMGMT_ABORT_TASK:
+				tag = SCB_GET_TAG(scb);
+			case SIU_TASKMGMT_ABORT_TASK_SET:
+			case SIU_TASKMGMT_CLEAR_TASK_SET:
+				lun = scb->hscb->lun;
+				error = CAM_REQ_ABORTED;
+				ahd_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),
+					       'A', lun, tag, ROLE_INITIATOR,
+					       error);
+				break;
+			case SIU_TASKMGMT_LUN_RESET:
+				lun = scb->hscb->lun;
+			case SIU_TASKMGMT_TARGET_RESET:
+			{
+				struct ahd_devinfo devinfo;
+
+				ahd_scb_devinfo(ahd, &devinfo, scb);
+				error = CAM_BDR_SENT;
+				ahd_handle_devreset(ahd, &devinfo, lun,
+						    CAM_BDR_SENT,
+						    lun != CAM_LUN_WILDCARD
+						    ? "Lun Reset"
+						    : "Target Reset",
+						    /*verbose_level*/0);
+				break;
+			}
+			default:
+				panic("Unexpected TaskMgmt Func\n");
+				break;
+			}
+		}
+		break;
+	}
+	case TASKMGMT_CMD_CMPLT_OKAY:
+	{
+		u_int	scbid;
+		struct	scb *scb;
+
+		/*
+		 * An ABORT TASK TMF failed to be delivered before
+		 * the targeted command completed normally.
+		 */
+		scbid = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb != NULL) {
+			/*
+			 * Remove the second instance of this SCB from
+			 * the QINFIFO if it is still there.
+                         */
+			ahd_print_path(ahd, scb);
+			printf("SCB completes before TMF\n");
+			/*
+			 * Handle losing the race.  Wait until any
+			 * current selection completes.  We will then
+			 * set the TMF back to zero in this SCB so that
+			 * the sequencer doesn't bother to issue another
+			 * sequencer interrupt for its completion.
+			 */
+			while ((ahd_inb(ahd, SCSISEQ0) & ENSELO) != 0
+			    && (ahd_inb(ahd, SSTAT0) & SELDO) == 0
+			    && (ahd_inb(ahd, SSTAT1) & SELTO) == 0)
+				;
+			ahd_outb(ahd, SCB_TASK_MANAGEMENT, 0);
+			ahd_search_qinfifo(ahd, SCB_GET_TARGET(ahd, scb),
+					   SCB_GET_CHANNEL(ahd, scb),  
+					   SCB_GET_LUN(scb), SCB_GET_TAG(scb), 
+					   ROLE_INITIATOR, /*status*/0,   
+					   SEARCH_REMOVE);
+		}
+		break;
+	}
+	case TRACEPOINT0:
+	case TRACEPOINT1:
+	case TRACEPOINT2:
+	case TRACEPOINT3:
+		printf("%s: Tracepoint %d\n", ahd_name(ahd),
+		       seqintcode - TRACEPOINT0);
+		break;
+	case NO_SEQINT:
+		break;
+	case SAW_HWERR:
+		ahd_handle_hwerrint(ahd);
+		break;
+	default:
+		printf("%s: Unexpected SEQINTCODE %d\n", ahd_name(ahd),
+		       seqintcode);
+		break;
+	}
+	/*
+	 *  The sequencer is paused immediately on
+	 *  a SEQINT, so we should restart it when
+	 *  we're done.
+	 */
+	ahd_unpause(ahd);
+}
+
+void
+ahd_handle_scsiint(struct ahd_softc *ahd, u_int intstat)
+{
+	struct scb	*scb;
+	u_int		 status0;
+	u_int		 status3;
+	u_int		 status;
+	u_int		 lqistat1;
+	u_int		 lqostat0;
+	u_int		 scbid;
+	u_int		 busfreetime;
+
+	ahd_update_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+
+	status3 = ahd_inb(ahd, SSTAT3) & (NTRAMPERR|OSRAMPERR);
+	status0 = ahd_inb(ahd, SSTAT0) & (IOERR|OVERRUN|SELDI|SELDO);
+	status = ahd_inb(ahd, SSTAT1) & (SELTO|SCSIRSTI|BUSFREE|SCSIPERR);
+	lqistat1 = ahd_inb(ahd, LQISTAT1);
+	lqostat0 = ahd_inb(ahd, LQOSTAT0);
+	busfreetime = ahd_inb(ahd, SSTAT2) & BUSFREETIME;
+	if ((status0 & (SELDI|SELDO)) != 0) {
+		u_int simode0;
+
+		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+		simode0 = ahd_inb(ahd, SIMODE0);
+		status0 &= simode0 & (IOERR|OVERRUN|SELDI|SELDO);
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	}
+	scbid = ahd_get_scbptr(ahd);
+	scb = ahd_lookup_scb(ahd, scbid);
+	if (scb != NULL
+	 && (ahd_inb(ahd, SEQ_FLAGS) & NOT_IDENTIFIED) != 0)
+		scb = NULL;
+
+	/* Make sure the sequencer is in a safe location. */
+	ahd_clear_critical_section(ahd);
+
+	if ((status0 & IOERR) != 0) {
+		u_int now_lvd;
+
+		now_lvd = ahd_inb(ahd, SBLKCTL) & ENAB40;
+		printf("%s: Transceiver State Has Changed to %s mode\n",
+		       ahd_name(ahd), now_lvd ? "LVD" : "SE");
+		ahd_outb(ahd, CLRSINT0, CLRIOERR);
+		/*
+		 * A change in I/O mode is equivalent to a bus reset.
+		 */
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+		ahd_pause(ahd);
+		ahd_setup_iocell_workaround(ahd);
+		ahd_unpause(ahd);
+	} else if ((status0 & OVERRUN) != 0) {
+		printf("%s: SCSI offset overrun detected.  Resetting bus.\n",
+		       ahd_name(ahd));
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+	} else if ((status & SCSIRSTI) != 0) {
+		printf("%s: Someone reset channel A\n", ahd_name(ahd));
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/FALSE);
+	} else if ((status & SCSIPERR) != 0) {
+		ahd_handle_transmission_error(ahd);
+	} else if (lqostat0 != 0) {
+		printf("%s: lqostat0 == 0x%x!\n", ahd_name(ahd), lqostat0);
+		ahd_outb(ahd, CLRLQOINT0, lqostat0);
+		if ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0) {
+			ahd_outb(ahd, CLRLQOINT1, 0);
+		}
+	} else if ((status & SELTO) != 0) {
+		u_int  scbid;
+
+		/* Stop the selection */
+		ahd_outb(ahd, SCSISEQ0, 0);
+
+		/* No more pending messages */
+		ahd_clear_msg_state(ahd);
+
+		/* Clear interrupt state */
+		ahd_outb(ahd, CLRSINT1, CLRSELTIMEO|CLRBUSFREE|CLRSCSIPERR);
+
+		/*
+		 * Although the driver does not care about the
+		 * 'Selection in Progress' status bit, the busy
+		 * LED does.  SELINGO is only cleared by a sucessfull
+		 * selection, so we must manually clear it to insure
+		 * the LED turns off just incase no future successful
+		 * selections occur (e.g. no devices on the bus).
+		 */
+		ahd_outb(ahd, CLRSINT0, CLRSELINGO);
+
+		scbid = ahd_inw(ahd, WAITING_TID_HEAD);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL) {
+			printf("%s: ahd_intr - referenced scb not "
+			       "valid during SELTO scb(0x%x)\n",
+			       ahd_name(ahd), scbid);
+			ahd_dump_card_state(ahd);
+		} else {
+			struct ahd_devinfo devinfo;
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_SELTO) != 0) {
+				ahd_print_path(ahd, scb);
+				printf("Saw Selection Timeout for SCB 0x%x\n",
+				       scbid);
+			}
+#endif
+			/*
+			 * Force a renegotiation with this target just in
+			 * case the cable was pulled and will later be
+			 * re-attached.  The target may forget its negotiation
+			 * settings with us should it attempt to reselect
+			 * during the interruption.  The target will not issue
+			 * a unit attention in this case, so we must always
+			 * renegotiate.
+			 */
+			ahd_scb_devinfo(ahd, &devinfo, scb);
+			ahd_force_renegotiation(ahd, &devinfo);
+			ahd_set_transaction_status(scb, CAM_SEL_TIMEOUT);
+			ahd_freeze_devq(ahd, scb);
+		}
+		ahd_outb(ahd, CLRINT, CLRSCSIINT);
+		ahd_iocell_first_selection(ahd);
+		ahd_unpause(ahd);
+	} else if ((status0 & (SELDI|SELDO)) != 0) {
+		ahd_iocell_first_selection(ahd);
+		ahd_unpause(ahd);
+	} else if (status3 != 0) {
+		printf("%s: SCSI Cell parity error SSTAT3 == 0x%x\n",
+		       ahd_name(ahd), status3);
+		ahd_outb(ahd, CLRSINT3, status3);
+	} else if ((lqistat1 & (LQIPHASE_LQ|LQIPHASE_NLQ)) != 0) {
+		ahd_handle_lqiphase_error(ahd, lqistat1);
+	} else if ((lqistat1 & LQICRCI_NLQ) != 0) {
+		/*
+		 * This status can be delayed during some
+		 * streaming operations.  The SCSIPHASE
+		 * handler has already dealt with this case
+		 * so just clear the error.
+		 */
+		ahd_outb(ahd, CLRLQIINT1, CLRLQICRCI_NLQ);
+	} else if ((status & BUSFREE) != 0) {
+		u_int lqostat1;
+		int   restart;
+		int   clear_fifo;
+		int   packetized;
+		u_int mode;
+
+		/*
+		 * Clear our selection hardware as soon as possible.
+		 * We may have an entry in the waiting Q for this target,
+		 * that is affected by this busfree and we don't want to
+		 * go about selecting the target while we handle the event.
+		 */
+		ahd_outb(ahd, SCSISEQ0, 0);
+
+		/*
+		 * Determine what we were up to at the time of
+		 * the busfree.
+		 */
+		mode = AHD_MODE_SCSI;
+		busfreetime = ahd_inb(ahd, SSTAT2) & BUSFREETIME;
+		lqostat1 = ahd_inb(ahd, LQOSTAT1);
+		switch (busfreetime) {
+		case BUSFREE_DFF0:
+		case BUSFREE_DFF1:
+		{
+			u_int	scbid;
+			struct	scb *scb;
+
+			mode = busfreetime == BUSFREE_DFF0
+			     ? AHD_MODE_DFF0 : AHD_MODE_DFF1;
+			ahd_set_modes(ahd, mode, mode);
+			scbid = ahd_get_scbptr(ahd);
+			scb = ahd_lookup_scb(ahd, scbid);
+			if (scb == NULL) {
+				printf("%s: Invalid SCB %d in DFF%d "
+				       "during unexpected busfree\n",
+				       ahd_name(ahd), scbid, mode);
+				packetized = 0;
+			} else
+				packetized = (scb->flags & SCB_PACKETIZED) != 0;
+			clear_fifo = 1;
+			break;
+		}
+		case BUSFREE_LQO:
+			clear_fifo = 0;
+			packetized = 1;
+			break;
+		default:
+			clear_fifo = 0;
+			packetized =  (lqostat1 & LQOBUSFREE) != 0;
+			if (!packetized
+			 && ahd_inb(ahd, LASTPHASE) == P_BUSFREE)
+				packetized = 1;
+			break;
+		}
+
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MISC) != 0)
+			printf("Saw Busfree.  Busfreetime = 0x%x.\n",
+			       busfreetime);
+#endif
+		/*
+		 * Busfrees that occur in non-packetized phases are
+		 * handled by the nonpkt_busfree handler.
+		 */
+		if (packetized && ahd_inb(ahd, LASTPHASE) == P_BUSFREE) {
+			restart = ahd_handle_pkt_busfree(ahd, busfreetime);
+		} else {
+			packetized = 0;
+			restart = ahd_handle_nonpkt_busfree(ahd);
+		}
+		/*
+		 * Clear the busfree interrupt status.  The setting of
+		 * the interrupt is a pulse, so in a perfect world, we
+		 * would not need to muck with the ENBUSFREE logic.  This
+		 * would ensure that if the bus moves on to another
+		 * connection, busfree protection is still in force.  If
+		 * BUSFREEREV is broken, however, we must manually clear
+		 * the ENBUSFREE if the busfree occurred during a non-pack
+		 * connection so that we don't get false positives during
+		 * future, packetized, connections.
+		 */
+		ahd_outb(ahd, CLRSINT1, CLRBUSFREE);
+		if (packetized == 0
+		 && (ahd->bugs & AHD_BUSFREEREV_BUG) != 0)
+			ahd_outb(ahd, SIMODE1,
+				 ahd_inb(ahd, SIMODE1) & ~ENBUSFREE);
+
+		if (clear_fifo)
+			ahd_clear_fifo(ahd, mode);
+
+		ahd_clear_msg_state(ahd);
+		ahd_outb(ahd, CLRINT, CLRSCSIINT);
+		if (restart) {
+			ahd_restart(ahd);
+		} else {
+			ahd_unpause(ahd);
+		}
+	} else {
+		printf("%s: Missing case in ahd_handle_scsiint. status = %x\n",
+		       ahd_name(ahd), status);
+		ahd_dump_card_state(ahd);
+		ahd_clear_intstat(ahd);
+		ahd_unpause(ahd);
+	}
+}
+
+static void
+ahd_handle_transmission_error(struct ahd_softc *ahd)
+{
+	struct	scb *scb;
+	u_int	scbid;
+	u_int	lqistat1;
+	u_int	lqistat2;
+	u_int	msg_out;
+	u_int	curphase;
+	u_int	lastphase;
+	u_int	perrdiag;
+	u_int	cur_col;
+	int	silent;
+
+	scb = NULL;
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	lqistat1 = ahd_inb(ahd, LQISTAT1) & ~(LQIPHASE_LQ|LQIPHASE_NLQ);
+	lqistat2 = ahd_inb(ahd, LQISTAT2);
+	if ((lqistat1 & (LQICRCI_NLQ|LQICRCI_LQ)) == 0
+	 && (ahd->bugs & AHD_NLQICRC_DELAYED_BUG) != 0) {
+		u_int lqistate;
+
+		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+		lqistate = ahd_inb(ahd, LQISTATE);
+		if ((lqistate >= 0x1E && lqistate <= 0x24)
+		 || (lqistate == 0x29)) {
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_RECOVERY) != 0) {
+				printf("%s: NLQCRC found via LQISTATE\n",
+				       ahd_name(ahd));
+			}
+#endif
+			lqistat1 |= LQICRCI_NLQ;
+		}
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	}
+
+	ahd_outb(ahd, CLRLQIINT1, lqistat1);
+	lastphase = ahd_inb(ahd, LASTPHASE);
+	curphase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;
+	perrdiag = ahd_inb(ahd, PERRDIAG);
+	msg_out = MSG_INITIATOR_DET_ERR;
+	ahd_outb(ahd, CLRSINT1, CLRSCSIPERR);
+	
+	/*
+	 * Try to find the SCB associated with this error.
+	 */
+	silent = FALSE;
+	if (lqistat1 == 0
+	 || (lqistat1 & LQICRCI_NLQ) != 0) {
+	 	if ((lqistat1 & (LQICRCI_NLQ|LQIOVERI_NLQ)) != 0)
+			ahd_set_active_fifo(ahd);
+		scbid = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb != NULL && SCB_IS_SILENT(scb))
+			silent = TRUE;
+	}
+
+	cur_col = 0;
+	if (silent == FALSE) {
+		printf("%s: Transmission error detected\n", ahd_name(ahd));
+		ahd_lqistat1_print(lqistat1, &cur_col, 50);
+		ahd_lastphase_print(lastphase, &cur_col, 50);
+		ahd_scsisigi_print(curphase, &cur_col, 50);
+		ahd_perrdiag_print(perrdiag, &cur_col, 50);
+		printf("\n");
+		ahd_dump_card_state(ahd);
+	}
+
+	if ((lqistat1 & (LQIOVERI_LQ|LQIOVERI_NLQ)) != 0) {
+		if (silent == FALSE) {
+			printf("%s: Gross protocol error during incoming "
+			       "packet.  lqistat1 == 0x%x.  Resetting bus.\n",
+			       ahd_name(ahd), lqistat1);
+		}
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+		return;
+	} else if ((lqistat1 & LQICRCI_LQ) != 0) {
+		/*
+		 * A CRC error has been detected on an incoming LQ.
+		 * The bus is currently hung on the last ACK.
+		 * Hit LQIRETRY to release the last ack, and
+		 * wait for the sequencer to determine that ATNO
+		 * is asserted while in message out to take us
+		 * to our host message loop.  No NONPACKREQ or
+		 * LQIPHASE type errors will occur in this
+		 * scenario.  After this first LQIRETRY, the LQI
+		 * manager will be in ISELO where it will
+		 * happily sit until another packet phase begins.
+		 * Unexpected bus free detection is enabled
+		 * through any phases that occur after we release
+		 * this last ack until the LQI manager sees a
+		 * packet phase.  This implies we may have to
+		 * ignore a perfectly valid "unexected busfree"
+		 * after our "initiator detected error" message is
+		 * sent.  A busfree is the expected response after
+		 * we tell the target that it's L_Q was corrupted.
+		 * (SPI4R09 10.7.3.3.3)
+		 */
+		ahd_outb(ahd, LQCTL2, LQIRETRY);
+		printf("LQIRetry for LQICRCI_LQ to release ACK\n");
+	} else if ((lqistat1 & LQICRCI_NLQ) != 0) {
+		/*
+		 * We detected a CRC error in a NON-LQ packet.
+		 * The hardware has varying behavior in this situation
+		 * depending on whether this packet was part of a
+		 * stream or not.
+		 *
+		 * PKT by PKT mode:
+		 * The hardware has already acked the complete packet.
+		 * If the target honors our outstanding ATN condition,
+		 * we should be (or soon will be) in MSGOUT phase.
+		 * This will trigger the LQIPHASE_LQ status bit as the
+		 * hardware was expecting another LQ.  Unexpected
+		 * busfree detection is enabled.  Once LQIPHASE_LQ is
+		 * true (first entry into host message loop is much
+		 * the same), we must clear LQIPHASE_LQ and hit
+		 * LQIRETRY so the hardware is ready to handle
+		 * a future LQ.  NONPACKREQ will not be asserted again
+		 * once we hit LQIRETRY until another packet is
+		 * processed.  The target may either go busfree
+		 * or start another packet in response to our message.
+		 *
+		 * Read Streaming P0 asserted:
+		 * If we raise ATN and the target completes the entire
+		 * stream (P0 asserted during the last packet), the
+		 * hardware will ack all data and return to the ISTART
+		 * state.  When the target reponds to our ATN condition,
+		 * LQIPHASE_LQ will be asserted.  We should respond to
+		 * this with an LQIRETRY to prepare for any future
+		 * packets.  NONPACKREQ will not be asserted again
+		 * once we hit LQIRETRY until another packet is
+		 * processed.  The target may either go busfree or
+		 * start another packet in response to our message.
+		 * Busfree detection is enabled.
+		 *
+		 * Read Streaming P0 not asserted:
+		 * If we raise ATN and the target transitions to
+		 * MSGOUT in or after a packet where P0 is not
+		 * asserted, the hardware will assert LQIPHASE_NLQ.
+		 * We should respond to the LQIPHASE_NLQ with an
+		 * LQIRETRY.  Should the target stay in a non-pkt
+		 * phase after we send our message, the hardware
+		 * will assert LQIPHASE_LQ.  Recovery is then just as
+		 * listed above for the read streaming with P0 asserted.
+		 * Busfree detection is enabled.
+		 */
+		if (silent == FALSE)
+			printf("LQICRC_NLQ\n");
+		if (scb == NULL) {
+			printf("%s: No SCB valid for LQICRC_NLQ.  "
+			       "Resetting bus\n", ahd_name(ahd));
+			ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+			return;
+		}
+	} else if ((lqistat1 & LQIBADLQI) != 0) {
+		printf("Need to handle BADLQI!\n");
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+		return;
+	} else if ((perrdiag & (PARITYERR|PREVPHASE)) == PARITYERR) {
+		if ((curphase & ~P_DATAIN_DT) != 0) {
+			/* Ack the byte.  So we can continue. */
+			if (silent == FALSE)
+				printf("Acking %s to clear perror\n",
+				    ahd_lookup_phase_entry(curphase)->phasemsg);
+			ahd_inb(ahd, SCSIDAT);
+		}
+	
+		if (curphase == P_MESGIN)
+			msg_out = MSG_PARITY_ERROR;
+	}
+
+	/*
+	 * We've set the hardware to assert ATN if we 
+	 * get a parity error on "in" phases, so all we
+	 * need to do is stuff the message buffer with
+	 * the appropriate message.  "In" phases have set
+	 * mesg_out to something other than MSG_NOP.
+	 */
+	ahd->send_msg_perror = msg_out;
+	if (scb != NULL && msg_out == MSG_INITIATOR_DET_ERR)
+		scb->flags |= SCB_TRANSMISSION_ERROR;
+	ahd_outb(ahd, MSG_OUT, HOST_MSG);
+	ahd_outb(ahd, CLRINT, CLRSCSIINT);
+	ahd_unpause(ahd);
+}
+
+static void
+ahd_handle_lqiphase_error(struct ahd_softc *ahd, u_int lqistat1)
+{
+	/*
+	 * Clear the sources of the interrupts.
+	 */
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	ahd_outb(ahd, CLRLQIINT1, lqistat1);
+
+	/*
+	 * If the "illegal" phase changes were in response
+	 * to our ATN to flag a CRC error, AND we ended up
+	 * on packet boundaries, clear the error, restart the
+	 * LQI manager as appropriate, and go on our merry
+	 * way toward sending the message.  Otherwise, reset
+	 * the bus to clear the error.
+	 */
+	ahd_set_active_fifo(ahd);
+	if ((ahd_inb(ahd, SCSISIGO) & ATNO) != 0
+	 && (ahd_inb(ahd, MDFFSTAT) & DLZERO) != 0) {
+		if ((lqistat1 & LQIPHASE_LQ) != 0) {
+			printf("LQIRETRY for LQIPHASE_LQ\n");
+			ahd_outb(ahd, LQCTL2, LQIRETRY);
+		} else if ((lqistat1 & LQIPHASE_NLQ) != 0) {
+			printf("LQIRETRY for LQIPHASE_NLQ\n");
+			ahd_outb(ahd, LQCTL2, LQIRETRY);
+		} else
+			panic("ahd_handle_lqiphase_error: No phase errors\n");
+		ahd_dump_card_state(ahd);
+		ahd_outb(ahd, CLRINT, CLRSCSIINT);
+		ahd_unpause(ahd);
+	} else {
+		printf("Reseting Channel for LQI Phase error\n");
+		ahd_dump_card_state(ahd);
+		ahd_reset_channel(ahd, 'A', /*Initiate Reset*/TRUE);
+	}
+}
+
+/*
+ * Packetized unexpected or expected busfree.
+ * Entered in mode based on busfreetime.
+ */
+static int
+ahd_handle_pkt_busfree(struct ahd_softc *ahd, u_int busfreetime)
+{
+	u_int lqostat1;
+
+	AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
+			 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
+	lqostat1 = ahd_inb(ahd, LQOSTAT1);
+	if ((lqostat1 & LQOBUSFREE) != 0) {
+		struct scb *scb;
+		u_int scbid;
+		u_int saved_scbptr;
+		u_int waiting_h;
+		u_int waiting_t;
+		u_int next;
+
+		if ((busfreetime & BUSFREE_LQO) == 0)
+			printf("%s: Warning, BUSFREE time is 0x%x.  "
+			       "Expected BUSFREE_LQO.\n",
+			       ahd_name(ahd), busfreetime);
+		/*
+		 * The LQO manager detected an unexpected busfree
+		 * either:
+		 *
+		 * 1) During an outgoing LQ.
+		 * 2) After an outgoing LQ but before the first
+		 *    REQ of the command packet.
+		 * 3) During an outgoing command packet.
+		 *
+		 * In all cases, CURRSCB is pointing to the
+		 * SCB that encountered the failure.  Clean
+		 * up the queue, clear SELDO and LQOBUSFREE,
+		 * and allow the sequencer to restart the select
+		 * out at its lesure.
+		 */
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+		scbid = ahd_inw(ahd, CURRSCB);
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL)
+		       panic("SCB not valid during LQOBUSFREE");
+		/*
+		 * Clear the status.
+		 */
+		ahd_outb(ahd, CLRLQOINT1, CLRLQOBUSFREE);
+		if ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0)
+			ahd_outb(ahd, CLRLQOINT1, 0);
+		ahd_outb(ahd, SCSISEQ0, ahd_inb(ahd, SCSISEQ0) & ~ENSELO);
+		ahd_flush_device_writes(ahd);
+		ahd_outb(ahd, CLRSINT0, CLRSELDO);
+
+		/*
+		 * Return the LQO manager to its idle loop.  It will
+		 * not do this automatically if the busfree occurs
+		 * after the first REQ of either the LQ or command
+		 * packet or between the LQ and command packet.
+		 */
+		ahd_outb(ahd, LQCTL2, ahd_inb(ahd, LQCTL2) | LQOTOIDLE);
+
+		/*
+		 * Update the waiting for selection queue so
+		 * we restart on the correct SCB.
+		 */
+		waiting_h = ahd_inw(ahd, WAITING_TID_HEAD);
+		saved_scbptr = ahd_get_scbptr(ahd);
+		if (waiting_h != scbid) {
+
+			ahd_outw(ahd, WAITING_TID_HEAD, scbid);
+			waiting_t = ahd_inw(ahd, WAITING_TID_TAIL);
+			if (waiting_t == waiting_h) {
+				ahd_outw(ahd, WAITING_TID_TAIL, scbid);
+				next = SCB_LIST_NULL;
+			} else {
+				ahd_set_scbptr(ahd, waiting_h);
+				next = ahd_inw_scbram(ahd, SCB_NEXT2);
+			}
+			ahd_set_scbptr(ahd, scbid);
+			ahd_outw(ahd, SCB_NEXT2, next);
+		}
+		ahd_set_scbptr(ahd, saved_scbptr);
+		if (scb->crc_retry_count < AHD_MAX_LQ_CRC_ERRORS) {
+			if (SCB_IS_SILENT(scb) == FALSE) {
+				ahd_print_path(ahd, scb);
+				printf("Probable outgoing LQ CRC error.  "
+				       "Retrying command\n");
+			}
+			scb->crc_retry_count++;
+		} else {
+			ahd_set_transaction_status(scb, CAM_UNCOR_PARITY);
+			ahd_freeze_scb(scb);
+			ahd_freeze_devq(ahd, scb);
+		}
+		/* Return unpausing the sequencer. */
+		return (0);
+	} else if ((ahd_inb(ahd, PERRDIAG) & PARITYERR) != 0) {
+		/*
+		 * Ignore what are really parity errors that
+		 * occur on the last REQ of a free running
+		 * clock prior to going busfree.  Some drives
+		 * do not properly active negate just before
+		 * going busfree resulting in a parity glitch.
+		 */
+		ahd_outb(ahd, CLRSINT1, CLRSCSIPERR|CLRBUSFREE);
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MASKED_ERRORS) != 0)
+			printf("%s: Parity on last REQ detected "
+			       "during busfree phase.\n",
+			       ahd_name(ahd));
+#endif
+		/* Return unpausing the sequencer. */
+		return (0);
+	}
+	if (ahd->src_mode != AHD_MODE_SCSI) {
+		u_int	scbid;
+		struct	scb *scb;
+
+		scbid = ahd_get_scbptr(ahd);
+		scb = ahd_lookup_scb(ahd, scbid);
+		ahd_print_path(ahd, scb);
+		printf("Unexpected PKT busfree condition\n");
+		ahd_dump_card_state(ahd);
+		ahd_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb), 'A',
+			       SCB_GET_LUN(scb), SCB_GET_TAG(scb),
+			       ROLE_INITIATOR, CAM_UNEXP_BUSFREE);
+
+		/* Return restarting the sequencer. */
+		return (1);
+	}
+	printf("%s: Unexpected PKT busfree condition\n", ahd_name(ahd));
+	ahd_dump_card_state(ahd);
+	/* Restart the sequencer. */
+	return (1);
+}
+
+/*
+ * Non-packetized unexpected or expected busfree.
+ */
+static int
+ahd_handle_nonpkt_busfree(struct ahd_softc *ahd)
+{
+	struct	ahd_devinfo devinfo;
+	struct	scb *scb;
+	u_int	lastphase;
+	u_int	saved_scsiid;
+	u_int	saved_lun;
+	u_int	target;
+	u_int	initiator_role_id;
+	u_int	scbid;
+	u_int	ppr_busfree;
+	int	printerror;
+
+	/*
+	 * Look at what phase we were last in.  If its message out,
+	 * chances are pretty good that the busfree was in response
+	 * to one of our abort requests.
+	 */
+	lastphase = ahd_inb(ahd, LASTPHASE);
+	saved_scsiid = ahd_inb(ahd, SAVED_SCSIID);
+	saved_lun = ahd_inb(ahd, SAVED_LUN);
+	target = SCSIID_TARGET(ahd, saved_scsiid);
+	initiator_role_id = SCSIID_OUR_ID(saved_scsiid);
+	ahd_compile_devinfo(&devinfo, initiator_role_id,
+			    target, saved_lun, 'A', ROLE_INITIATOR);
+	printerror = 1;
+
+	scbid = ahd_get_scbptr(ahd);
+	scb = ahd_lookup_scb(ahd, scbid);
+	if (scb != NULL
+	 && (ahd_inb(ahd, SEQ_FLAGS) & NOT_IDENTIFIED) != 0)
+		scb = NULL;
+
+	ppr_busfree = (ahd->msg_flags & MSG_FLAG_EXPECT_PPR_BUSFREE) != 0;
+	if (lastphase == P_MESGOUT) {
+		u_int tag;
+
+		tag = SCB_LIST_NULL;
+		if (ahd_sent_msg(ahd, AHDMSG_1B, MSG_ABORT_TAG, TRUE)
+		 || ahd_sent_msg(ahd, AHDMSG_1B, MSG_ABORT, TRUE)) {
+			int found;
+			int sent_msg;
+
+			if (scb == NULL) {
+				ahd_print_devinfo(ahd, &devinfo);
+				printf("Abort for unidentified "
+				       "connection completed.\n");
+				/* restart the sequencer. */
+				return (1);
+			}
+			sent_msg = ahd->msgout_buf[ahd->msgout_index - 1];
+			ahd_print_path(ahd, scb);
+			printf("SCB %d - Abort%s Completed.\n",
+			       SCB_GET_TAG(scb),
+			       sent_msg == MSG_ABORT_TAG ? "" : " Tag");
+
+			if (sent_msg == MSG_ABORT_TAG)
+				tag = SCB_GET_TAG(scb);
+
+			if ((scb->flags & SCB_CMDPHASE_ABORT) != 0) {
+				/*
+				 * This abort is in response to an
+				 * unexpected switch to command phase
+				 * for a packetized connection.  Since
+				 * the identify message was never sent,
+				 * "saved lun" is 0.  We really want to
+				 * abort only the SCB that encountered
+				 * this error, which could have a different
+				 * lun.  The SCB will be retried so the OS
+				 * will see the UA after renegotiating to
+				 * packetized.
+				 */
+				tag = SCB_GET_TAG(scb);
+				saved_lun = scb->hscb->lun;
+			}
+			found = ahd_abort_scbs(ahd, target, 'A', saved_lun,
+					       tag, ROLE_INITIATOR,
+					       CAM_REQ_ABORTED);
+			printf("found == 0x%x\n", found);
+			printerror = 0;
+		} else if (ahd_sent_msg(ahd, AHDMSG_1B,
+					MSG_BUS_DEV_RESET, TRUE)) {
+#ifdef __FreeBSD__
+			/*
+			 * Don't mark the user's request for this BDR
+			 * as completing with CAM_BDR_SENT.  CAM3
+			 * specifies CAM_REQ_CMP.
+			 */
+			if (scb != NULL
+			 && scb->io_ctx->ccb_h.func_code== XPT_RESET_DEV
+			 && ahd_match_scb(ahd, scb, target, 'A',
+					  CAM_LUN_WILDCARD, SCB_LIST_NULL,
+					  ROLE_INITIATOR))
+				ahd_set_transaction_status(scb, CAM_REQ_CMP);
+#endif
+			ahd_handle_devreset(ahd, &devinfo, CAM_LUN_WILDCARD,
+					    CAM_BDR_SENT, "Bus Device Reset",
+					    /*verbose_level*/0);
+			printerror = 0;
+		} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_PPR, FALSE)
+			&& ppr_busfree == 0) {
+			struct ahd_initiator_tinfo *tinfo;
+			struct ahd_tmode_tstate *tstate;
+
+			/*
+			 * PPR Rejected.  Try non-ppr negotiation
+			 * and retry command.
+			 */
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+				printf("PPR negotiation rejected busfree.\n");
+#endif
+			tinfo = ahd_fetch_transinfo(ahd, devinfo.channel,
+						    devinfo.our_scsiid,
+						    devinfo.target, &tstate);
+			tinfo->curr.transport_version = 2;
+			tinfo->goal.transport_version = 2;
+			tinfo->goal.ppr_options = 0;
+			ahd_qinfifo_requeue_tail(ahd, scb);
+			printerror = 0;
+		} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_WDTR, FALSE)
+			&& ppr_busfree == 0) {
+			/*
+			 * Negotiation Rejected.  Go-narrow and
+			 * retry command.
+			 */
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+				printf("WDTR negotiation rejected busfree.\n");
+#endif
+			ahd_set_width(ahd, &devinfo,
+				      MSG_EXT_WDTR_BUS_8_BIT,
+				      AHD_TRANS_CUR|AHD_TRANS_GOAL,
+				      /*paused*/TRUE);
+			ahd_qinfifo_requeue_tail(ahd, scb);
+			printerror = 0;
+		} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_SDTR, FALSE)
+			&& ppr_busfree == 0) {
+			/*
+			 * Negotiation Rejected.  Go-async and
+			 * retry command.
+			 */
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+				printf("SDTR negotiation rejected busfree.\n");
+#endif
+			ahd_set_syncrate(ahd, &devinfo,
+					/*period*/0, /*offset*/0,
+					/*ppr_options*/0,
+					AHD_TRANS_CUR|AHD_TRANS_GOAL,
+					/*paused*/TRUE);
+			ahd_qinfifo_requeue_tail(ahd, scb);
+			printerror = 0;
+		} else if ((ahd->msg_flags & MSG_FLAG_EXPECT_IDE_BUSFREE) != 0
+			&& ahd_sent_msg(ahd, AHDMSG_1B,
+					 MSG_INITIATOR_DET_ERR, TRUE)) {
+
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+				printf("Expected IDE Busfree\n");
+#endif
+			printerror = 0;
+		} else if ((ahd->msg_flags & MSG_FLAG_EXPECT_QASREJ_BUSFREE)
+			&& ahd_sent_msg(ahd, AHDMSG_1B,
+					MSG_MESSAGE_REJECT, TRUE)) {
+
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+				printf("Expected QAS Reject Busfree\n");
+#endif
+			printerror = 0;
+		}
+	}
+
+	/*
+	 * The busfree required flag is honored at the end of
+	 * the message phases.  We check it last in case we
+	 * had to send some other message that caused a busfree.
+	 */
+	if (printerror != 0
+	 && (lastphase == P_MESGIN || lastphase == P_MESGOUT)
+	 && ((ahd->msg_flags & MSG_FLAG_EXPECT_PPR_BUSFREE) != 0)) {
+
+		ahd_freeze_devq(ahd, scb);
+		ahd_set_transaction_status(scb, CAM_REQUEUE_REQ);
+		ahd_freeze_scb(scb);
+		if ((ahd->msg_flags & MSG_FLAG_IU_REQ_CHANGED) != 0) {
+			ahd_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),
+				       SCB_GET_CHANNEL(ahd, scb),
+				       SCB_GET_LUN(scb), SCB_LIST_NULL,
+				       ROLE_INITIATOR, CAM_REQ_ABORTED);
+		} else {
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+				printf("PPR Negotiation Busfree.\n");
+#endif
+			ahd_done(ahd, scb);
+		}
+		printerror = 0;
+	}
+	if (printerror != 0) {
+		int aborted;
+
+		aborted = 0;
+		if (scb != NULL) {
+			u_int tag;
+
+			if ((scb->hscb->control & TAG_ENB) != 0)
+				tag = SCB_GET_TAG(scb);
+			else
+				tag = SCB_LIST_NULL;
+			ahd_print_path(ahd, scb);
+			aborted = ahd_abort_scbs(ahd, target, 'A',
+				       SCB_GET_LUN(scb), tag,
+				       ROLE_INITIATOR,
+				       CAM_UNEXP_BUSFREE);
+		} else {
+			/*
+			 * We had not fully identified this connection,
+			 * so we cannot abort anything.
+			 */
+			printf("%s: ", ahd_name(ahd));
+		}
+		if (lastphase != P_BUSFREE)
+			ahd_force_renegotiation(ahd, &devinfo);
+		printf("Unexpected busfree %s, %d SCBs aborted, "
+		       "PRGMCNT == 0x%x\n",
+		       ahd_lookup_phase_entry(lastphase)->phasemsg,
+		       aborted,
+		       ahd_inb(ahd, PRGMCNT)
+			| (ahd_inb(ahd, PRGMCNT+1) << 8));
+		ahd_dump_card_state(ahd);
+	}
+	/* Always restart the sequencer. */
+	return (1);
+}
+
+static void
+ahd_handle_proto_violation(struct ahd_softc *ahd)
+{
+	struct	ahd_devinfo devinfo;
+	struct	scb *scb;
+	u_int	scbid;
+	u_int	seq_flags;
+	u_int	curphase;
+	u_int	lastphase;
+	int	found;
+
+	ahd_fetch_devinfo(ahd, &devinfo);
+	scbid = ahd_get_scbptr(ahd);
+	scb = ahd_lookup_scb(ahd, scbid);
+	seq_flags = ahd_inb(ahd, SEQ_FLAGS);
+	curphase = ahd_inb(ahd, SCSISIGI) & PHASE_MASK;
+	lastphase = ahd_inb(ahd, LASTPHASE);
+	if ((seq_flags & NOT_IDENTIFIED) != 0) {
+
+		/*
+		 * The reconnecting target either did not send an
+		 * identify message, or did, but we didn't find an SCB
+		 * to match.
+		 */
+		ahd_print_devinfo(ahd, &devinfo);
+		printf("Target did not send an IDENTIFY message. "
+		       "LASTPHASE = 0x%x.\n", lastphase);
+		scb = NULL;
+	} else if (scb == NULL) {
+		/*
+		 * We don't seem to have an SCB active for this
+		 * transaction.  Print an error and reset the bus.
+		 */
+		ahd_print_devinfo(ahd, &devinfo);
+		printf("No SCB found during protocol violation\n");
+		goto proto_violation_reset;
+	} else {
+		ahd_set_transaction_status(scb, CAM_SEQUENCE_FAIL);
+		if ((seq_flags & NO_CDB_SENT) != 0) {
+			ahd_print_path(ahd, scb);
+			printf("No or incomplete CDB sent to device.\n");
+		} else if ((ahd_inb_scbram(ahd, SCB_CONTROL)
+			  & STATUS_RCVD) == 0) {
+			/*
+			 * The target never bothered to provide status to
+			 * us prior to completing the command.  Since we don't
+			 * know the disposition of this command, we must attempt
+			 * to abort it.  Assert ATN and prepare to send an abort
+			 * message.
+			 */
+			ahd_print_path(ahd, scb);
+			printf("Completed command without status.\n");
+		} else {
+			ahd_print_path(ahd, scb);
+			printf("Unknown protocol violation.\n");
+			ahd_dump_card_state(ahd);
+		}
+	}
+	if ((lastphase & ~P_DATAIN_DT) == 0
+	 || lastphase == P_COMMAND) {
+proto_violation_reset:
+		/*
+		 * Target either went directly to data
+		 * phase or didn't respond to our ATN.
+		 * The only safe thing to do is to blow
+		 * it away with a bus reset.
+		 */
+		found = ahd_reset_channel(ahd, 'A', TRUE);
+		printf("%s: Issued Channel %c Bus Reset. "
+		       "%d SCBs aborted\n", ahd_name(ahd), 'A', found);
+	} else {
+		/*
+		 * Leave the selection hardware off in case
+		 * this abort attempt will affect yet to
+		 * be sent commands.
+		 */
+		ahd_outb(ahd, SCSISEQ0,
+			 ahd_inb(ahd, SCSISEQ0) & ~ENSELO);
+		ahd_assert_atn(ahd);
+		ahd_outb(ahd, MSG_OUT, HOST_MSG);
+		if (scb == NULL) {
+			ahd_print_devinfo(ahd, &devinfo);
+			ahd->msgout_buf[0] = MSG_ABORT_TASK;
+			ahd->msgout_len = 1;
+			ahd->msgout_index = 0;
+			ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
+		} else {
+			ahd_print_path(ahd, scb);
+			scb->flags |= SCB_ABORT;
+		}
+		printf("Protocol violation %s.  Attempting to abort.\n",
+		       ahd_lookup_phase_entry(curphase)->phasemsg);
+	}
+}
+
+/*
+ * Force renegotiation to occur the next time we initiate
+ * a command to the current device.
+ */
+static void
+ahd_force_renegotiation(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	struct	ahd_initiator_tinfo *targ_info;
+	struct	ahd_tmode_tstate *tstate;
+
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
+		ahd_print_devinfo(ahd, devinfo);
+		printf("Forcing renegotiation\n");
+	}
+#endif
+	targ_info = ahd_fetch_transinfo(ahd,
+					devinfo->channel,
+					devinfo->our_scsiid,
+					devinfo->target,
+					&tstate);
+	ahd_update_neg_request(ahd, devinfo, tstate,
+			       targ_info, AHD_NEG_IF_NON_ASYNC);
+}
+
+#define AHD_MAX_STEPS 2000
+void
+ahd_clear_critical_section(struct ahd_softc *ahd)
+{
+	ahd_mode_state	saved_modes;
+	int		stepping;
+	int		steps;
+	int		first_instr;
+	u_int		simode0;
+	u_int		simode1;
+	u_int		simode3;
+	u_int		lqimode0;
+	u_int		lqimode1;
+	u_int		lqomode0;
+	u_int		lqomode1;
+
+	if (ahd->num_critical_sections == 0)
+		return;
+
+	stepping = FALSE;
+	steps = 0;
+	first_instr = 0;
+	simode0 = 0;
+	simode1 = 0;
+	simode3 = 0;
+	lqimode0 = 0;
+	lqimode1 = 0;
+	lqomode0 = 0;
+	lqomode1 = 0;
+	saved_modes = ahd_save_modes(ahd);
+	for (;;) {
+		struct	cs *cs;
+		u_int	seqaddr;
+		u_int	i;
+
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+		seqaddr = ahd_inb(ahd, CURADDR)
+			| (ahd_inb(ahd, CURADDR+1) << 8);
+
+		cs = ahd->critical_sections;
+		for (i = 0; i < ahd->num_critical_sections; i++, cs++) {
+			
+			if (cs->begin < seqaddr && cs->end >= seqaddr)
+				break;
+		}
+
+		if (i == ahd->num_critical_sections)
+			break;
+
+		if (steps > AHD_MAX_STEPS) {
+			printf("%s: Infinite loop in critical section\n"
+			       "%s: First Instruction 0x%x now 0x%x\n",
+			       ahd_name(ahd), ahd_name(ahd), first_instr,
+			       seqaddr);
+			ahd_dump_card_state(ahd);
+			panic("critical section loop");
+		}
+
+		steps++;
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MISC) != 0)
+			printf("%s: Single stepping at 0x%x\n", ahd_name(ahd),
+			       seqaddr);
+#endif
+		if (stepping == FALSE) {
+
+			first_instr = seqaddr;
+  			ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+  			simode0 = ahd_inb(ahd, SIMODE0);
+			simode3 = ahd_inb(ahd, SIMODE3);
+			lqimode0 = ahd_inb(ahd, LQIMODE0);
+			lqimode1 = ahd_inb(ahd, LQIMODE1);
+			lqomode0 = ahd_inb(ahd, LQOMODE0);
+			lqomode1 = ahd_inb(ahd, LQOMODE1);
+			ahd_outb(ahd, SIMODE0, 0);
+			ahd_outb(ahd, SIMODE3, 0);
+			ahd_outb(ahd, LQIMODE0, 0);
+			ahd_outb(ahd, LQIMODE1, 0);
+			ahd_outb(ahd, LQOMODE0, 0);
+			ahd_outb(ahd, LQOMODE1, 0);
+			ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+  			simode1 = ahd_inb(ahd, SIMODE1);
+  			ahd_outb(ahd, SIMODE1, ENBUSFREE);
+			ahd_outb(ahd, SEQCTL0, ahd_inb(ahd, SEQCTL0) | STEP);
+			stepping = TRUE;
+		}
+		ahd_outb(ahd, CLRSINT1, CLRBUSFREE);
+		ahd_outb(ahd, CLRINT, CLRSCSIINT);
+		ahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);
+		ahd_outb(ahd, HCNTRL, ahd->unpause);
+		do {
+			ahd_delay(200);
+		} while (!ahd_is_paused(ahd));
+		ahd_update_modes(ahd);
+	}
+	if (stepping) {
+		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+		ahd_outb(ahd, SIMODE0, simode0);
+		ahd_outb(ahd, SIMODE3, simode3);
+		ahd_outb(ahd, LQIMODE0, lqimode0);
+		ahd_outb(ahd, LQIMODE1, lqimode1);
+		ahd_outb(ahd, LQOMODE0, lqomode0);
+		ahd_outb(ahd, LQOMODE1, lqomode1);
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+		ahd_outb(ahd, SEQCTL0, ahd_inb(ahd, SEQCTL0) & ~STEP);
+  		ahd_outb(ahd, SIMODE1, simode1);
+		/*
+		 * SCSIINT seems to glitch occassionally when
+		 * the interrupt masks are restored.  Clear SCSIINT
+		 * one more time so that only persistent errors
+		 * are seen as a real interrupt.
+		 */
+		ahd_outb(ahd, CLRINT, CLRSCSIINT);
+	}
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+/*
+ * Clear any pending interrupt status.
+ */
+void
+ahd_clear_intstat(struct ahd_softc *ahd)
+{
+	AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
+			 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
+	/* Clear any interrupt conditions this may have caused */
+	ahd_outb(ahd, CLRLQIINT0, CLRLQIATNQAS|CLRLQICRCT1|CLRLQICRCT2
+				 |CLRLQIBADLQT|CLRLQIATNLQ|CLRLQIATNCMD);
+	ahd_outb(ahd, CLRLQIINT1, CLRLQIPHASE_LQ|CLRLQIPHASE_NLQ|CLRLIQABORT
+				 |CLRLQICRCI_LQ|CLRLQICRCI_NLQ|CLRLQIBADLQI
+				 |CLRLQIOVERI_LQ|CLRLQIOVERI_NLQ|CLRNONPACKREQ);
+	ahd_outb(ahd, CLRLQOINT0, CLRLQOTARGSCBPERR|CLRLQOSTOPT2|CLRLQOATNLQ
+				 |CLRLQOATNPKT|CLRLQOTCRC);
+	ahd_outb(ahd, CLRLQOINT1, CLRLQOINITSCBPERR|CLRLQOSTOPI2|CLRLQOBADQAS
+				 |CLRLQOBUSFREE|CLRLQOPHACHGINPKT);
+	if ((ahd->bugs & AHD_CLRLQO_AUTOCLR_BUG) != 0) {
+		ahd_outb(ahd, CLRLQOINT0, 0);
+		ahd_outb(ahd, CLRLQOINT1, 0);
+	}
+	ahd_outb(ahd, CLRSINT3, CLRNTRAMPERR|CLROSRAMPERR);
+	ahd_outb(ahd, CLRSINT1, CLRSELTIMEO|CLRATNO|CLRSCSIRSTI
+				|CLRBUSFREE|CLRSCSIPERR|CLRREQINIT);
+	ahd_outb(ahd, CLRSINT0, CLRSELDO|CLRSELDI|CLRSELINGO
+			        |CLRIOERR|CLROVERRUN);
+	ahd_outb(ahd, CLRINT, CLRSCSIINT);
+}
+
+/**************************** Debugging Routines ******************************/
+#ifdef AHD_DEBUG
+uint32_t ahd_debug = AHD_DEBUG_OPTS;
+#endif
+void
+ahd_print_scb(struct scb *scb)
+{
+	struct hardware_scb *hscb;
+	int i;
+
+	hscb = scb->hscb;
+	printf("scb:%p control:0x%x scsiid:0x%x lun:%d cdb_len:%d\n",
+	       (void *)scb,
+	       hscb->control,
+	       hscb->scsiid,
+	       hscb->lun,
+	       hscb->cdb_len);
+	printf("Shared Data: ");
+	for (i = 0; i < sizeof(hscb->shared_data.idata.cdb); i++)
+		printf("%#02x", hscb->shared_data.idata.cdb[i]);
+	printf("        dataptr:%#x%x datacnt:%#x sgptr:%#x tag:%#x\n",
+	       (uint32_t)((ahd_le64toh(hscb->dataptr) >> 32) & 0xFFFFFFFF),
+	       (uint32_t)(ahd_le64toh(hscb->dataptr) & 0xFFFFFFFF),
+	       ahd_le32toh(hscb->datacnt),
+	       ahd_le32toh(hscb->sgptr),
+	       SCB_GET_TAG(scb));
+	ahd_dump_sglist(scb);
+}
+
+void
+ahd_dump_sglist(struct scb *scb)
+{
+	int i;
+
+	if (scb->sg_count > 0) {
+		if ((scb->ahd_softc->flags & AHD_64BIT_ADDRESSING) != 0) {
+			struct ahd_dma64_seg *sg_list;
+
+			sg_list = (struct ahd_dma64_seg*)scb->sg_list;
+			for (i = 0; i < scb->sg_count; i++) {
+				uint64_t addr;
+				uint32_t len;
+
+				addr = ahd_le64toh(sg_list[i].addr);
+				len = ahd_le32toh(sg_list[i].len);
+				printf("sg[%d] - Addr 0x%x%x : Length %d%s\n",
+				       i,
+				       (uint32_t)((addr >> 32) & 0xFFFFFFFF),
+				       (uint32_t)(addr & 0xFFFFFFFF),
+				       sg_list[i].len & AHD_SG_LEN_MASK,
+				       (sg_list[i].len & AHD_DMA_LAST_SEG)
+				     ? " Last" : "");
+			}
+		} else {
+			struct ahd_dma_seg *sg_list;
+
+			sg_list = (struct ahd_dma_seg*)scb->sg_list;
+			for (i = 0; i < scb->sg_count; i++) {
+				uint32_t len;
+
+				len = ahd_le32toh(sg_list[i].len);
+				printf("sg[%d] - Addr 0x%x%x : Length %d%s\n",
+				       i,
+				       (len >> 24) & SG_HIGH_ADDR_BITS,
+				       ahd_le32toh(sg_list[i].addr),
+				       len & AHD_SG_LEN_MASK,
+				       len & AHD_DMA_LAST_SEG ? " Last" : "");
+			}
+		}
+	}
+}
+
+/************************* Transfer Negotiation *******************************/
+/*
+ * Allocate per target mode instance (ID we respond to as a target)
+ * transfer negotiation data structures.
+ */
+static struct ahd_tmode_tstate *
+ahd_alloc_tstate(struct ahd_softc *ahd, u_int scsi_id, char channel)
+{
+	struct ahd_tmode_tstate *master_tstate;
+	struct ahd_tmode_tstate *tstate;
+	int i;
+
+	master_tstate = ahd->enabled_targets[ahd->our_id];
+	if (ahd->enabled_targets[scsi_id] != NULL
+	 && ahd->enabled_targets[scsi_id] != master_tstate)
+		panic("%s: ahd_alloc_tstate - Target already allocated",
+		      ahd_name(ahd));
+	tstate = malloc(sizeof(*tstate), M_DEVBUF, M_NOWAIT);
+	if (tstate == NULL)
+		return (NULL);
+
+	/*
+	 * If we have allocated a master tstate, copy user settings from
+	 * the master tstate (taken from SRAM or the EEPROM) for this
+	 * channel, but reset our current and goal settings to async/narrow
+	 * until an initiator talks to us.
+	 */
+	if (master_tstate != NULL) {
+		memcpy(tstate, master_tstate, sizeof(*tstate));
+		memset(tstate->enabled_luns, 0, sizeof(tstate->enabled_luns));
+		for (i = 0; i < 16; i++) {
+			memset(&tstate->transinfo[i].curr, 0,
+			      sizeof(tstate->transinfo[i].curr));
+			memset(&tstate->transinfo[i].goal, 0,
+			      sizeof(tstate->transinfo[i].goal));
+		}
+	} else
+		memset(tstate, 0, sizeof(*tstate));
+	ahd->enabled_targets[scsi_id] = tstate;
+	return (tstate);
+}
+
+#ifdef AHD_TARGET_MODE
+/*
+ * Free per target mode instance (ID we respond to as a target)
+ * transfer negotiation data structures.
+ */
+static void
+ahd_free_tstate(struct ahd_softc *ahd, u_int scsi_id, char channel, int force)
+{
+	struct ahd_tmode_tstate *tstate;
+
+	/*
+	 * Don't clean up our "master" tstate.
+	 * It has our default user settings.
+	 */
+	if (scsi_id == ahd->our_id
+	 && force == FALSE)
+		return;
+
+	tstate = ahd->enabled_targets[scsi_id];
+	if (tstate != NULL)
+		free(tstate, M_DEVBUF);
+	ahd->enabled_targets[scsi_id] = NULL;
+}
+#endif
+
+/*
+ * Called when we have an active connection to a target on the bus,
+ * this function finds the nearest period to the input period limited
+ * by the capabilities of the bus connectivity of and sync settings for
+ * the target.
+ */
+void
+ahd_devlimited_syncrate(struct ahd_softc *ahd,
+			struct ahd_initiator_tinfo *tinfo,
+			u_int *period, u_int *ppr_options, role_t role)
+{
+	struct	ahd_transinfo *transinfo;
+	u_int	maxsync;
+
+	if ((ahd_inb(ahd, SBLKCTL) & ENAB40) != 0
+	 && (ahd_inb(ahd, SSTAT2) & EXP_ACTIVE) == 0) {
+		maxsync = AHD_SYNCRATE_PACED;
+	} else {
+		maxsync = AHD_SYNCRATE_ULTRA;
+		/* Can't do DT related options on an SE bus */
+		*ppr_options &= MSG_EXT_PPR_QAS_REQ;
+	}
+	/*
+	 * Never allow a value higher than our current goal
+	 * period otherwise we may allow a target initiated
+	 * negotiation to go above the limit as set by the
+	 * user.  In the case of an initiator initiated
+	 * sync negotiation, we limit based on the user
+	 * setting.  This allows the system to still accept
+	 * incoming negotiations even if target initiated
+	 * negotiation is not performed.
+	 */
+	if (role == ROLE_TARGET)
+		transinfo = &tinfo->user;
+	else 
+		transinfo = &tinfo->goal;
+	*ppr_options &= (transinfo->ppr_options|MSG_EXT_PPR_PCOMP_EN);
+	if (transinfo->width == MSG_EXT_WDTR_BUS_8_BIT) {
+		maxsync = MAX(maxsync, AHD_SYNCRATE_ULTRA2);
+		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
+	}
+	if (transinfo->period == 0) {
+		*period = 0;
+		*ppr_options = 0;
+	} else {
+		*period = MAX(*period, transinfo->period);
+		ahd_find_syncrate(ahd, period, ppr_options, maxsync);
+	}
+}
+
+/*
+ * Look up the valid period to SCSIRATE conversion in our table.
+ * Return the period and offset that should be sent to the target
+ * if this was the beginning of an SDTR.
+ */
+void
+ahd_find_syncrate(struct ahd_softc *ahd, u_int *period,
+		  u_int *ppr_options, u_int maxsync)
+{
+	if (*period < maxsync)
+		*period = maxsync;
+
+	if ((*ppr_options & MSG_EXT_PPR_DT_REQ) != 0
+	 && *period > AHD_SYNCRATE_MIN_DT)
+		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
+		
+	if (*period > AHD_SYNCRATE_MIN)
+		*period = 0;
+
+	/* Honor PPR option conformance rules. */
+	if (*period > AHD_SYNCRATE_PACED)
+		*ppr_options &= ~MSG_EXT_PPR_RTI;
+
+	if ((*ppr_options & MSG_EXT_PPR_IU_REQ) == 0)
+		*ppr_options &= (MSG_EXT_PPR_DT_REQ|MSG_EXT_PPR_QAS_REQ);
+
+	if ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0)
+		*ppr_options &= MSG_EXT_PPR_QAS_REQ;
+
+	/* Skip all PACED only entries if IU is not available */
+	if ((*ppr_options & MSG_EXT_PPR_IU_REQ) == 0
+	 && *period < AHD_SYNCRATE_DT)
+		*period = AHD_SYNCRATE_DT;
+
+	/* Skip all DT only entries if DT is not available */
+	if ((*ppr_options & MSG_EXT_PPR_DT_REQ) == 0
+	 && *period < AHD_SYNCRATE_ULTRA2)
+		*period = AHD_SYNCRATE_ULTRA2;
+}
+
+/*
+ * Truncate the given synchronous offset to a value the
+ * current adapter type and syncrate are capable of.
+ */
+void
+ahd_validate_offset(struct ahd_softc *ahd,
+		    struct ahd_initiator_tinfo *tinfo,
+		    u_int period, u_int *offset, int wide,
+		    role_t role)
+{
+	u_int maxoffset;
+
+	/* Limit offset to what we can do */
+	if (period == 0)
+		maxoffset = 0;
+	else if (period <= AHD_SYNCRATE_PACED) {
+		if ((ahd->bugs & AHD_PACED_NEGTABLE_BUG) != 0)
+			maxoffset = MAX_OFFSET_PACED_BUG;
+		else
+			maxoffset = MAX_OFFSET_PACED;
+	} else
+		maxoffset = MAX_OFFSET_NON_PACED;
+	*offset = MIN(*offset, maxoffset);
+	if (tinfo != NULL) {
+		if (role == ROLE_TARGET)
+			*offset = MIN(*offset, tinfo->user.offset);
+		else
+			*offset = MIN(*offset, tinfo->goal.offset);
+	}
+}
+
+/*
+ * Truncate the given transfer width parameter to a value the
+ * current adapter type is capable of.
+ */
+void
+ahd_validate_width(struct ahd_softc *ahd, struct ahd_initiator_tinfo *tinfo,
+		   u_int *bus_width, role_t role)
+{
+	switch (*bus_width) {
+	default:
+		if (ahd->features & AHD_WIDE) {
+			/* Respond Wide */
+			*bus_width = MSG_EXT_WDTR_BUS_16_BIT;
+			break;
+		}
+		/* FALLTHROUGH */
+	case MSG_EXT_WDTR_BUS_8_BIT:
+		*bus_width = MSG_EXT_WDTR_BUS_8_BIT;
+		break;
+	}
+	if (tinfo != NULL) {
+		if (role == ROLE_TARGET)
+			*bus_width = MIN(tinfo->user.width, *bus_width);
+		else
+			*bus_width = MIN(tinfo->goal.width, *bus_width);
+	}
+}
+
+/*
+ * Update the bitmask of targets for which the controller should
+ * negotiate with at the next convenient oportunity.  This currently
+ * means the next time we send the initial identify messages for
+ * a new transaction.
+ */
+int
+ahd_update_neg_request(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		       struct ahd_tmode_tstate *tstate,
+		       struct ahd_initiator_tinfo *tinfo, ahd_neg_type neg_type)
+{
+	u_int auto_negotiate_orig;
+
+	auto_negotiate_orig = tstate->auto_negotiate;
+	if (neg_type == AHD_NEG_ALWAYS) {
+		/*
+		 * Force our "current" settings to be
+		 * unknown so that unless a bus reset
+		 * occurs the need to renegotiate is
+		 * recorded persistently.
+		 */
+		if ((ahd->features & AHD_WIDE) != 0)
+			tinfo->curr.width = AHD_WIDTH_UNKNOWN;
+		tinfo->curr.period = AHD_PERIOD_UNKNOWN;
+		tinfo->curr.offset = AHD_OFFSET_UNKNOWN;
+	}
+	if (tinfo->curr.period != tinfo->goal.period
+	 || tinfo->curr.width != tinfo->goal.width
+	 || tinfo->curr.offset != tinfo->goal.offset
+	 || tinfo->curr.ppr_options != tinfo->goal.ppr_options
+	 || (neg_type == AHD_NEG_IF_NON_ASYNC
+	  && (tinfo->goal.offset != 0
+	   || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT
+	   || tinfo->goal.ppr_options != 0)))
+		tstate->auto_negotiate |= devinfo->target_mask;
+	else
+		tstate->auto_negotiate &= ~devinfo->target_mask;
+
+	return (auto_negotiate_orig != tstate->auto_negotiate);
+}
+
+/*
+ * Update the user/goal/curr tables of synchronous negotiation
+ * parameters as well as, in the case of a current or active update,
+ * any data structures on the host controller.  In the case of an
+ * active update, the specified target is currently talking to us on
+ * the bus, so the transfer parameter update must take effect
+ * immediately.
+ */
+void
+ahd_set_syncrate(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		 u_int period, u_int offset, u_int ppr_options,
+		 u_int type, int paused)
+{
+	struct	ahd_initiator_tinfo *tinfo;
+	struct	ahd_tmode_tstate *tstate;
+	u_int	old_period;
+	u_int	old_offset;
+	u_int	old_ppr;
+	int	active;
+	int	update_needed;
+
+	active = (type & AHD_TRANS_ACTIVE) == AHD_TRANS_ACTIVE;
+	update_needed = 0;
+
+	if (period == 0 || offset == 0) {
+		period = 0;
+		offset = 0;
+	}
+
+	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,
+				    devinfo->target, &tstate);
+
+	if ((type & AHD_TRANS_USER) != 0) {
+		tinfo->user.period = period;
+		tinfo->user.offset = offset;
+		tinfo->user.ppr_options = ppr_options;
+	}
+
+	if ((type & AHD_TRANS_GOAL) != 0) {
+		tinfo->goal.period = period;
+		tinfo->goal.offset = offset;
+		tinfo->goal.ppr_options = ppr_options;
+	}
+
+	old_period = tinfo->curr.period;
+	old_offset = tinfo->curr.offset;
+	old_ppr	   = tinfo->curr.ppr_options;
+
+	if ((type & AHD_TRANS_CUR) != 0
+	 && (old_period != period
+	  || old_offset != offset
+	  || old_ppr != ppr_options)) {
+
+		update_needed++;
+
+		tinfo->curr.period = period;
+		tinfo->curr.offset = offset;
+		tinfo->curr.ppr_options = ppr_options;
+
+		ahd_send_async(ahd, devinfo->channel, devinfo->target,
+			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
+		if (bootverbose) {
+			if (offset != 0) {
+				int options;
+
+				printf("%s: target %d synchronous with "
+				       "period = 0x%x, offset = 0x%x",
+				       ahd_name(ahd), devinfo->target,
+				       period, offset);
+				options = 0;
+				if ((ppr_options & MSG_EXT_PPR_RD_STRM) != 0) {
+					printf("(RDSTRM");
+					options++;
+				}
+				if ((ppr_options & MSG_EXT_PPR_DT_REQ) != 0) {
+					printf("%s", options ? "|DT" : "(DT");
+					options++;
+				}
+				if ((ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
+					printf("%s", options ? "|IU" : "(IU");
+					options++;
+				}
+				if ((ppr_options & MSG_EXT_PPR_RTI) != 0) {
+					printf("%s", options ? "|RTI" : "(RTI");
+					options++;
+				}
+				if ((ppr_options & MSG_EXT_PPR_QAS_REQ) != 0) {
+					printf("%s", options ? "|QAS" : "(QAS");
+					options++;
+				}
+				if (options != 0)
+					printf(")\n");
+				else
+					printf("\n");
+			} else {
+				printf("%s: target %d using "
+				       "asynchronous transfers%s\n",
+				       ahd_name(ahd), devinfo->target,
+				       (ppr_options & MSG_EXT_PPR_QAS_REQ) != 0
+				     ?  "(QAS)" : "");
+			}
+		}
+	}
+	/*
+	 * Always refresh the neg-table to handle the case of the
+	 * sequencer setting the ENATNO bit for a MK_MESSAGE request.
+	 * We will always renegotiate in that case if this is a
+	 * packetized request.  Also manage the busfree expected flag
+	 * from this common routine so that we catch changes due to
+	 * WDTR or SDTR messages.
+	 */
+	if ((type & AHD_TRANS_CUR) != 0) {
+		if (!paused)
+			ahd_pause(ahd);
+		ahd_update_neg_table(ahd, devinfo, &tinfo->curr);
+		if (!paused)
+			ahd_unpause(ahd);
+		if (ahd->msg_type != MSG_TYPE_NONE) {
+			if ((old_ppr & MSG_EXT_PPR_IU_REQ)
+			 != (ppr_options & MSG_EXT_PPR_IU_REQ)) {
+#ifdef AHD_DEBUG
+				if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
+					ahd_print_devinfo(ahd, devinfo);
+					printf("Expecting IU Change busfree\n");
+				}
+#endif
+				ahd->msg_flags |= MSG_FLAG_EXPECT_PPR_BUSFREE
+					       |  MSG_FLAG_IU_REQ_CHANGED;
+			}
+			if ((old_ppr & MSG_EXT_PPR_IU_REQ) != 0) {
+#ifdef AHD_DEBUG
+				if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+					printf("PPR with IU_REQ outstanding\n");
+#endif
+				ahd->msg_flags |= MSG_FLAG_EXPECT_PPR_BUSFREE;
+			}
+		}
+	}
+
+	update_needed += ahd_update_neg_request(ahd, devinfo, tstate,
+						tinfo, AHD_NEG_TO_GOAL);
+
+	if (update_needed && active)
+		ahd_update_pending_scbs(ahd);
+}
+
+/*
+ * Update the user/goal/curr tables of wide negotiation
+ * parameters as well as, in the case of a current or active update,
+ * any data structures on the host controller.  In the case of an
+ * active update, the specified target is currently talking to us on
+ * the bus, so the transfer parameter update must take effect
+ * immediately.
+ */
+void
+ahd_set_width(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+	      u_int width, u_int type, int paused)
+{
+	struct	ahd_initiator_tinfo *tinfo;
+	struct	ahd_tmode_tstate *tstate;
+	u_int	oldwidth;
+	int	active;
+	int	update_needed;
+
+	active = (type & AHD_TRANS_ACTIVE) == AHD_TRANS_ACTIVE;
+	update_needed = 0;
+	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,
+				    devinfo->target, &tstate);
+
+	if ((type & AHD_TRANS_USER) != 0)
+		tinfo->user.width = width;
+
+	if ((type & AHD_TRANS_GOAL) != 0)
+		tinfo->goal.width = width;
+
+	oldwidth = tinfo->curr.width;
+	if ((type & AHD_TRANS_CUR) != 0 && oldwidth != width) {
+
+		update_needed++;
+
+		tinfo->curr.width = width;
+		ahd_send_async(ahd, devinfo->channel, devinfo->target,
+			       CAM_LUN_WILDCARD, AC_TRANSFER_NEG, NULL);
+		if (bootverbose) {
+			printf("%s: target %d using %dbit transfers\n",
+			       ahd_name(ahd), devinfo->target,
+			       8 * (0x01 << width));
+		}
+	}
+
+	if ((type & AHD_TRANS_CUR) != 0) {
+		if (!paused)
+			ahd_pause(ahd);
+		ahd_update_neg_table(ahd, devinfo, &tinfo->curr);
+		if (!paused)
+			ahd_unpause(ahd);
+	}
+
+	update_needed += ahd_update_neg_request(ahd, devinfo, tstate,
+						tinfo, AHD_NEG_TO_GOAL);
+	if (update_needed && active)
+		ahd_update_pending_scbs(ahd);
+
+}
+
+/*
+ * Update the current state of tagged queuing for a given target.
+ */
+void
+ahd_set_tags(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+	     ahd_queue_alg alg)
+{
+	ahd_platform_set_tags(ahd, devinfo, alg);
+	ahd_send_async(ahd, devinfo->channel, devinfo->target,
+		       devinfo->lun, AC_TRANSFER_NEG, &alg);
+}
+
+static void
+ahd_update_neg_table(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		     struct ahd_transinfo *tinfo)
+{
+	ahd_mode_state	saved_modes;
+	u_int		period;
+	u_int		ppr_opts;
+	u_int		con_opts;
+	u_int		offset;
+	u_int		saved_negoaddr;
+	uint8_t		iocell_opts[sizeof(ahd->iocell_opts)];
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+
+	saved_negoaddr = ahd_inb(ahd, NEGOADDR);
+	ahd_outb(ahd, NEGOADDR, devinfo->target);
+	period = tinfo->period;
+	offset = tinfo->offset;
+	memcpy(iocell_opts, ahd->iocell_opts, sizeof(ahd->iocell_opts)); 
+	ppr_opts = tinfo->ppr_options & (MSG_EXT_PPR_QAS_REQ|MSG_EXT_PPR_DT_REQ
+					|MSG_EXT_PPR_IU_REQ|MSG_EXT_PPR_RTI);
+	con_opts = 0;
+	if (period == 0)
+		period = AHD_SYNCRATE_ASYNC;
+	if (period == AHD_SYNCRATE_160) {
+
+		if ((ahd->bugs & AHD_PACED_NEGTABLE_BUG) != 0) {
+			/*
+			 * When the SPI4 spec was finalized, PACE transfers
+			 * was not made a configurable option in the PPR
+			 * message.  Instead it is assumed to be enabled for
+			 * any syncrate faster than 80MHz.  Nevertheless,
+			 * Harpoon2A4 allows this to be configurable.
+			 *
+			 * Harpoon2A4 also assumes at most 2 data bytes per
+			 * negotiated REQ/ACK offset.  Paced transfers take
+			 * 4, so we must adjust our offset.
+			 */
+			ppr_opts |= PPROPT_PACE;
+			offset *= 2;
+
+			/*
+			 * Harpoon2A assumed that there would be a
+			 * fallback rate between 160MHz and 80Mhz,
+			 * so 7 is used as the period factor rather
+			 * than 8 for 160MHz.
+			 */
+			period = AHD_SYNCRATE_REVA_160;
+		}
+		if ((tinfo->ppr_options & MSG_EXT_PPR_PCOMP_EN) == 0)
+			iocell_opts[AHD_PRECOMP_SLEW_INDEX] &=
+			    ~AHD_PRECOMP_MASK;
+	} else {
+		/*
+		 * Precomp should be disabled for non-paced transfers.
+		 */
+		iocell_opts[AHD_PRECOMP_SLEW_INDEX] &= ~AHD_PRECOMP_MASK;
+
+		if ((ahd->features & AHD_NEW_IOCELL_OPTS) != 0
+		 && (ppr_opts & MSG_EXT_PPR_DT_REQ) != 0) {
+			/*
+			 * Slow down our CRC interval to be
+			 * compatible with devices that can't
+			 * handle a CRC at full speed.
+			 */
+			con_opts |= ENSLOWCRC;
+		}
+	}
+
+	ahd_outb(ahd, ANNEXCOL, AHD_ANNEXCOL_PRECOMP_SLEW);
+	ahd_outb(ahd, ANNEXDAT, iocell_opts[AHD_PRECOMP_SLEW_INDEX]);
+	ahd_outb(ahd, ANNEXCOL, AHD_ANNEXCOL_AMPLITUDE);
+	ahd_outb(ahd, ANNEXDAT, iocell_opts[AHD_AMPLITUDE_INDEX]);
+
+	ahd_outb(ahd, NEGPERIOD, period);
+	ahd_outb(ahd, NEGPPROPTS, ppr_opts);
+	ahd_outb(ahd, NEGOFFSET, offset);
+
+	if (tinfo->width == MSG_EXT_WDTR_BUS_16_BIT)
+		con_opts |= WIDEXFER;
+
+	/*
+	 * During packetized transfers, the target will
+	 * give us the oportunity to send command packets
+	 * without us asserting attention.
+	 */
+	if ((tinfo->ppr_options & MSG_EXT_PPR_IU_REQ) == 0)
+		con_opts |= ENAUTOATNO;
+	ahd_outb(ahd, NEGCONOPTS, con_opts);
+	ahd_outb(ahd, NEGOADDR, saved_negoaddr);
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+/*
+ * When the transfer settings for a connection change, setup for
+ * negotiation in pending SCBs to effect the change as quickly as
+ * possible.  We also cancel any negotiations that are scheduled
+ * for inflight SCBs that have not been started yet.
+ */
+static void
+ahd_update_pending_scbs(struct ahd_softc *ahd)
+{
+	struct		scb *pending_scb;
+	int		pending_scb_count;
+	int		i;
+	int		paused;
+	u_int		saved_scbptr;
+	ahd_mode_state	saved_modes;
+
+	/*
+	 * Traverse the pending SCB list and ensure that all of the
+	 * SCBs there have the proper settings.  We can only safely
+	 * clear the negotiation required flag (setting requires the
+	 * execution queue to be modified) and this is only possible
+	 * if we are not already attempting to select out for this
+	 * SCB.  For this reason, all callers only call this routine
+	 * if we are changing the negotiation settings for the currently
+	 * active transaction on the bus.
+	 */
+	pending_scb_count = 0;
+	LIST_FOREACH(pending_scb, &ahd->pending_scbs, pending_links) {
+		struct ahd_devinfo devinfo;
+		struct hardware_scb *pending_hscb;
+		struct ahd_initiator_tinfo *tinfo;
+		struct ahd_tmode_tstate *tstate;
+
+		ahd_scb_devinfo(ahd, &devinfo, pending_scb);
+		tinfo = ahd_fetch_transinfo(ahd, devinfo.channel,
+					    devinfo.our_scsiid,
+					    devinfo.target, &tstate);
+		pending_hscb = pending_scb->hscb;
+		if ((tstate->auto_negotiate & devinfo.target_mask) == 0
+		 && (pending_scb->flags & SCB_AUTO_NEGOTIATE) != 0) {
+			pending_scb->flags &= ~SCB_AUTO_NEGOTIATE;
+			pending_hscb->control &= ~MK_MESSAGE;
+		}
+		ahd_sync_scb(ahd, pending_scb,
+			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
+		pending_scb_count++;
+	}
+
+	if (pending_scb_count == 0)
+		return;
+
+	if (ahd_is_paused(ahd)) {
+		paused = 1;
+	} else {
+		paused = 0;
+		ahd_pause(ahd);
+	}
+
+	/*
+	 * Force the sequencer to reinitialize the selection for
+	 * the command at the head of the execution queue if it
+	 * has already been setup.  The negotiation changes may
+	 * effect whether we select-out with ATN.
+	 */
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	ahd_outb(ahd, SCSISEQ0, ahd_inb(ahd, SCSISEQ0) & ~ENSELO);
+	saved_scbptr = ahd_get_scbptr(ahd);
+	/* Ensure that the hscbs down on the card match the new information */
+	for (i = 0; i < ahd->scb_data.maxhscbs; i++) {
+		struct	hardware_scb *pending_hscb;
+		u_int	control;
+		u_int	scb_tag;
+
+		ahd_set_scbptr(ahd, i);
+		scb_tag = i;
+		pending_scb = ahd_lookup_scb(ahd, scb_tag);
+		if (pending_scb == NULL)
+			continue;
+
+		pending_hscb = pending_scb->hscb;
+		control = ahd_inb_scbram(ahd, SCB_CONTROL);
+		control &= ~MK_MESSAGE;
+		control |= pending_hscb->control & MK_MESSAGE;
+		ahd_outb(ahd, SCB_CONTROL, control);
+	}
+	ahd_set_scbptr(ahd, saved_scbptr);
+	ahd_restore_modes(ahd, saved_modes);
+
+	if (paused == 0)
+		ahd_unpause(ahd);
+}
+
+/**************************** Pathing Information *****************************/
+static void
+ahd_fetch_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	ahd_mode_state	saved_modes;
+	u_int		saved_scsiid;
+	role_t		role;
+	int		our_id;
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+
+	if (ahd_inb(ahd, SSTAT0) & TARGET)
+		role = ROLE_TARGET;
+	else
+		role = ROLE_INITIATOR;
+
+	if (role == ROLE_TARGET
+	 && (ahd_inb(ahd, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {
+		/* We were selected, so pull our id from TARGIDIN */
+		our_id = ahd_inb(ahd, TARGIDIN) & OID;
+	} else if (role == ROLE_TARGET)
+		our_id = ahd_inb(ahd, TOWNID);
+	else
+		our_id = ahd_inb(ahd, IOWNID);
+
+	saved_scsiid = ahd_inb(ahd, SAVED_SCSIID);
+	ahd_compile_devinfo(devinfo,
+			    our_id,
+			    SCSIID_TARGET(ahd, saved_scsiid),
+			    ahd_inb(ahd, SAVED_LUN),
+			    SCSIID_CHANNEL(ahd, saved_scsiid),
+			    role);
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+void
+ahd_print_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	printf("%s:%c:%d:%d: ", ahd_name(ahd), 'A',
+	       devinfo->target, devinfo->lun);
+}
+
+struct ahd_phase_table_entry*
+ahd_lookup_phase_entry(int phase)
+{
+	struct ahd_phase_table_entry *entry;
+	struct ahd_phase_table_entry *last_entry;
+
+	/*
+	 * num_phases doesn't include the default entry which
+	 * will be returned if the phase doesn't match.
+	 */
+	last_entry = &ahd_phase_table[num_phases];
+	for (entry = ahd_phase_table; entry < last_entry; entry++) {
+		if (phase == entry->phase)
+			break;
+	}
+	return (entry);
+}
+
+void
+ahd_compile_devinfo(struct ahd_devinfo *devinfo, u_int our_id, u_int target,
+		    u_int lun, char channel, role_t role)
+{
+	devinfo->our_scsiid = our_id;
+	devinfo->target = target;
+	devinfo->lun = lun;
+	devinfo->target_offset = target;
+	devinfo->channel = channel;
+	devinfo->role = role;
+	if (channel == 'B')
+		devinfo->target_offset += 8;
+	devinfo->target_mask = (0x01 << devinfo->target_offset);
+}
+
+static void
+ahd_scb_devinfo(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		struct scb *scb)
+{
+	role_t	role;
+	int	our_id;
+
+	our_id = SCSIID_OUR_ID(scb->hscb->scsiid);
+	role = ROLE_INITIATOR;
+	if ((scb->hscb->control & TARGET_SCB) != 0)
+		role = ROLE_TARGET;
+	ahd_compile_devinfo(devinfo, our_id, SCB_GET_TARGET(ahd, scb),
+			    SCB_GET_LUN(scb), SCB_GET_CHANNEL(ahd, scb), role);
+}
+
+
+/************************ Message Phase Processing ****************************/
+/*
+ * When an initiator transaction with the MK_MESSAGE flag either reconnects
+ * or enters the initial message out phase, we are interrupted.  Fill our
+ * outgoing message buffer with the appropriate message and beging handing
+ * the message phase(s) manually.
+ */
+static void
+ahd_setup_initiator_msgout(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+			   struct scb *scb)
+{
+	/*
+	 * To facilitate adding multiple messages together,
+	 * each routine should increment the index and len
+	 * variables instead of setting them explicitly.
+	 */
+	ahd->msgout_index = 0;
+	ahd->msgout_len = 0;
+
+	if (ahd_currently_packetized(ahd))
+		ahd->msg_flags |= MSG_FLAG_PACKETIZED;
+
+	if (ahd->send_msg_perror
+	 && ahd_inb(ahd, MSG_OUT) == HOST_MSG) {
+		ahd->msgout_buf[ahd->msgout_index++] = ahd->send_msg_perror;
+		ahd->msgout_len++;
+		ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+			printf("Setting up for Parity Error delivery\n");
+#endif
+		return;
+	} else if (scb == NULL) {
+		printf("%s: WARNING. No pending message for "
+		       "I_T msgin.  Issuing NO-OP\n", ahd_name(ahd));
+		ahd->msgout_buf[ahd->msgout_index++] = MSG_NOOP;
+		ahd->msgout_len++;
+		ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
+		return;
+	}
+
+	if ((scb->flags & SCB_DEVICE_RESET) == 0
+	 && (scb->flags & SCB_PACKETIZED) == 0
+	 && ahd_inb(ahd, MSG_OUT) == MSG_IDENTIFYFLAG) {
+		u_int identify_msg;
+
+		identify_msg = MSG_IDENTIFYFLAG | SCB_GET_LUN(scb);
+		if ((scb->hscb->control & DISCENB) != 0)
+			identify_msg |= MSG_IDENTIFY_DISCFLAG;
+		ahd->msgout_buf[ahd->msgout_index++] = identify_msg;
+		ahd->msgout_len++;
+
+		if ((scb->hscb->control & TAG_ENB) != 0) {
+			ahd->msgout_buf[ahd->msgout_index++] =
+			    scb->hscb->control & (TAG_ENB|SCB_TAG_TYPE);
+			ahd->msgout_buf[ahd->msgout_index++] = SCB_GET_TAG(scb);
+			ahd->msgout_len += 2;
+		}
+	}
+
+	if (scb->flags & SCB_DEVICE_RESET) {
+		ahd->msgout_buf[ahd->msgout_index++] = MSG_BUS_DEV_RESET;
+		ahd->msgout_len++;
+		ahd_print_path(ahd, scb);
+		printf("Bus Device Reset Message Sent\n");
+		/*
+		 * Clear our selection hardware in advance of
+		 * the busfree.  We may have an entry in the waiting
+		 * Q for this target, and we don't want to go about
+		 * selecting while we handle the busfree and blow it
+		 * away.
+		 */
+		ahd_outb(ahd, SCSISEQ0, 0);
+	} else if ((scb->flags & SCB_ABORT) != 0) {
+
+		if ((scb->hscb->control & TAG_ENB) != 0) {
+			ahd->msgout_buf[ahd->msgout_index++] = MSG_ABORT_TAG;
+		} else {
+			ahd->msgout_buf[ahd->msgout_index++] = MSG_ABORT;
+		}
+		ahd->msgout_len++;
+		ahd_print_path(ahd, scb);
+		printf("Abort%s Message Sent\n",
+		       (scb->hscb->control & TAG_ENB) != 0 ? " Tag" : "");
+		/*
+		 * Clear our selection hardware in advance of
+		 * the busfree.  We may have an entry in the waiting
+		 * Q for this target, and we don't want to go about
+		 * selecting while we handle the busfree and blow it
+		 * away.
+		 */
+		ahd_outb(ahd, SCSISEQ0, 0);
+	} else if ((scb->flags & (SCB_AUTO_NEGOTIATE|SCB_NEGOTIATE)) != 0) {
+		ahd_build_transfer_msg(ahd, devinfo);
+		/*
+		 * Clear our selection hardware in advance of potential
+		 * PPR IU status change busfree.  We may have an entry in
+		 * the waiting Q for this target, and we don't want to go
+		 * about selecting while we handle the busfree and blow
+		 * it away.
+		 */
+		ahd_outb(ahd, SCSISEQ0, 0);
+	} else {
+		printf("ahd_intr: AWAITING_MSG for an SCB that "
+		       "does not have a waiting message\n");
+		printf("SCSIID = %x, target_mask = %x\n", scb->hscb->scsiid,
+		       devinfo->target_mask);
+		panic("SCB = %d, SCB Control = %x:%x, MSG_OUT = %x "
+		      "SCB flags = %x", SCB_GET_TAG(scb), scb->hscb->control,
+		      ahd_inb(ahd, SCB_CONTROL), ahd_inb(ahd, MSG_OUT),
+		      scb->flags);
+	}
+
+	/*
+	 * Clear the MK_MESSAGE flag from the SCB so we aren't
+	 * asked to send this message again.
+	 */
+	ahd_outb(ahd, SCB_CONTROL,
+		 ahd_inb_scbram(ahd, SCB_CONTROL) & ~MK_MESSAGE);
+	scb->hscb->control &= ~MK_MESSAGE;
+	ahd->msgout_index = 0;
+	ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
+}
+
+/*
+ * Build an appropriate transfer negotiation message for the
+ * currently active target.
+ */
+static void
+ahd_build_transfer_msg(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	/*
+	 * We need to initiate transfer negotiations.
+	 * If our current and goal settings are identical,
+	 * we want to renegotiate due to a check condition.
+	 */
+	struct	ahd_initiator_tinfo *tinfo;
+	struct	ahd_tmode_tstate *tstate;
+	int	dowide;
+	int	dosync;
+	int	doppr;
+	u_int	period;
+	u_int	ppr_options;
+	u_int	offset;
+
+	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,
+				    devinfo->target, &tstate);
+	/*
+	 * Filter our period based on the current connection.
+	 * If we can't perform DT transfers on this segment (not in LVD
+	 * mode for instance), then our decision to issue a PPR message
+	 * may change.
+	 */
+	period = tinfo->goal.period;
+	offset = tinfo->goal.offset;
+	ppr_options = tinfo->goal.ppr_options;
+	/* Target initiated PPR is not allowed in the SCSI spec */
+	if (devinfo->role == ROLE_TARGET)
+		ppr_options = 0;
+	ahd_devlimited_syncrate(ahd, tinfo, &period,
+				&ppr_options, devinfo->role);
+	dowide = tinfo->curr.width != tinfo->goal.width;
+	dosync = tinfo->curr.offset != offset || tinfo->curr.period != period;
+	/*
+	 * Only use PPR if we have options that need it, even if the device
+	 * claims to support it.  There might be an expander in the way
+	 * that doesn't.
+	 */
+	doppr = ppr_options != 0;
+
+	if (!dowide && !dosync && !doppr) {
+		dowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;
+		dosync = tinfo->goal.offset != 0;
+	}
+
+	if (!dowide && !dosync && !doppr) {
+		/*
+		 * Force async with a WDTR message if we have a wide bus,
+		 * or just issue an SDTR with a 0 offset.
+		 */
+		if ((ahd->features & AHD_WIDE) != 0)
+			dowide = 1;
+		else
+			dosync = 1;
+
+		if (bootverbose) {
+			ahd_print_devinfo(ahd, devinfo);
+			printf("Ensuring async\n");
+		}
+	}
+	/* Target initiated PPR is not allowed in the SCSI spec */
+	if (devinfo->role == ROLE_TARGET)
+		doppr = 0;
+
+	/*
+	 * Both the PPR message and SDTR message require the
+	 * goal syncrate to be limited to what the target device
+	 * is capable of handling (based on whether an LVD->SE
+	 * expander is on the bus), so combine these two cases.
+	 * Regardless, guarantee that if we are using WDTR and SDTR
+	 * messages that WDTR comes first.
+	 */
+	if (doppr || (dosync && !dowide)) {
+
+		offset = tinfo->goal.offset;
+		ahd_validate_offset(ahd, tinfo, period, &offset,
+				    doppr ? tinfo->goal.width
+					  : tinfo->curr.width,
+				    devinfo->role);
+		if (doppr) {
+			ahd_construct_ppr(ahd, devinfo, period, offset,
+					  tinfo->goal.width, ppr_options);
+		} else {
+			ahd_construct_sdtr(ahd, devinfo, period, offset);
+		}
+	} else {
+		ahd_construct_wdtr(ahd, devinfo, tinfo->goal.width);
+	}
+}
+
+/*
+ * Build a synchronous negotiation message in our message
+ * buffer based on the input parameters.
+ */
+static void
+ahd_construct_sdtr(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		   u_int period, u_int offset)
+{
+	if (offset == 0)
+		period = AHD_ASYNC_XFER_PERIOD;
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXTENDED;
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_SDTR_LEN;
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_SDTR;
+	ahd->msgout_buf[ahd->msgout_index++] = period;
+	ahd->msgout_buf[ahd->msgout_index++] = offset;
+	ahd->msgout_len += 5;
+	if (bootverbose) {
+		printf("(%s:%c:%d:%d): Sending SDTR period %x, offset %x\n",
+		       ahd_name(ahd), devinfo->channel, devinfo->target,
+		       devinfo->lun, period, offset);
+	}
+}
+
+/*
+ * Build a wide negotiateion message in our message
+ * buffer based on the input parameters.
+ */
+static void
+ahd_construct_wdtr(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		   u_int bus_width)
+{
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXTENDED;
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_WDTR_LEN;
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_WDTR;
+	ahd->msgout_buf[ahd->msgout_index++] = bus_width;
+	ahd->msgout_len += 4;
+	if (bootverbose) {
+		printf("(%s:%c:%d:%d): Sending WDTR %x\n",
+		       ahd_name(ahd), devinfo->channel, devinfo->target,
+		       devinfo->lun, bus_width);
+	}
+}
+
+/*
+ * Build a parallel protocol request message in our message
+ * buffer based on the input parameters.
+ */
+static void
+ahd_construct_ppr(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		  u_int period, u_int offset, u_int bus_width,
+		  u_int ppr_options)
+{
+	/*
+	 * Always request precompensation from
+	 * the other target if we are running
+	 * at paced syncrates.
+	 */
+	if (period <= AHD_SYNCRATE_PACED)
+		ppr_options |= MSG_EXT_PPR_PCOMP_EN;
+	if (offset == 0)
+		period = AHD_ASYNC_XFER_PERIOD;
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXTENDED;
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_PPR_LEN;
+	ahd->msgout_buf[ahd->msgout_index++] = MSG_EXT_PPR;
+	ahd->msgout_buf[ahd->msgout_index++] = period;
+	ahd->msgout_buf[ahd->msgout_index++] = 0;
+	ahd->msgout_buf[ahd->msgout_index++] = offset;
+	ahd->msgout_buf[ahd->msgout_index++] = bus_width;
+	ahd->msgout_buf[ahd->msgout_index++] = ppr_options;
+	ahd->msgout_len += 8;
+	if (bootverbose) {
+		printf("(%s:%c:%d:%d): Sending PPR bus_width %x, period %x, "
+		       "offset %x, ppr_options %x\n", ahd_name(ahd),
+		       devinfo->channel, devinfo->target, devinfo->lun,
+		       bus_width, period, offset, ppr_options);
+	}
+}
+
+/*
+ * Clear any active message state.
+ */
+static void
+ahd_clear_msg_state(struct ahd_softc *ahd)
+{
+	ahd_mode_state saved_modes;
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	ahd->send_msg_perror = 0;
+	ahd->msg_flags = MSG_FLAG_NONE;
+	ahd->msgout_len = 0;
+	ahd->msgin_index = 0;
+	ahd->msg_type = MSG_TYPE_NONE;
+	if ((ahd_inb(ahd, SCSISIGO) & ATNO) != 0) {
+		/*
+		 * The target didn't care to respond to our
+		 * message request, so clear ATN.
+		 */
+		ahd_outb(ahd, CLRSINT1, CLRATNO);
+	}
+	ahd_outb(ahd, MSG_OUT, MSG_NOOP);
+	ahd_outb(ahd, SEQ_FLAGS2,
+		 ahd_inb(ahd, SEQ_FLAGS2) & ~TARGET_MSG_PENDING);
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+/*
+ * Manual message loop handler.
+ */
+static void
+ahd_handle_message_phase(struct ahd_softc *ahd)
+{ 
+	struct	ahd_devinfo devinfo;
+	u_int	bus_phase;
+	int	end_session;
+
+	ahd_fetch_devinfo(ahd, &devinfo);
+	end_session = FALSE;
+	bus_phase = ahd_inb(ahd, LASTPHASE);
+
+	if ((ahd_inb(ahd, LQISTAT2) & LQIPHASE_OUTPKT) != 0) {
+		printf("LQIRETRY for LQIPHASE_OUTPKT\n");
+		ahd_outb(ahd, LQCTL2, LQIRETRY);
+	}
+reswitch:
+	switch (ahd->msg_type) {
+	case MSG_TYPE_INITIATOR_MSGOUT:
+	{
+		int lastbyte;
+		int phasemis;
+		int msgdone;
+
+		if (ahd->msgout_len == 0 && ahd->send_msg_perror == 0)
+			panic("HOST_MSG_LOOP interrupt with no active message");
+
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
+			ahd_print_devinfo(ahd, &devinfo);
+			printf("INITIATOR_MSG_OUT");
+		}
+#endif
+		phasemis = bus_phase != P_MESGOUT;
+		if (phasemis) {
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
+				printf(" PHASEMIS %s\n",
+				       ahd_lookup_phase_entry(bus_phase)
+							     ->phasemsg);
+			}
+#endif
+			if (bus_phase == P_MESGIN) {
+				/*
+				 * Change gears and see if
+				 * this messages is of interest to
+				 * us or should be passed back to
+				 * the sequencer.
+				 */
+				ahd_outb(ahd, CLRSINT1, CLRATNO);
+				ahd->send_msg_perror = 0;
+				ahd->msg_type = MSG_TYPE_INITIATOR_MSGIN;
+				ahd->msgin_index = 0;
+				goto reswitch;
+			}
+			end_session = TRUE;
+			break;
+		}
+
+		if (ahd->send_msg_perror) {
+			ahd_outb(ahd, CLRSINT1, CLRATNO);
+			ahd_outb(ahd, CLRSINT1, CLRREQINIT);
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+				printf(" byte 0x%x\n", ahd->send_msg_perror);
+#endif
+			/*
+			 * If we are notifying the target of a CRC error
+			 * during packetized operations, the target is
+			 * within its rights to acknowledge our message
+			 * with a busfree.
+			 */
+			if ((ahd->msg_flags & MSG_FLAG_PACKETIZED) != 0
+			 && ahd->send_msg_perror == MSG_INITIATOR_DET_ERR)
+				ahd->msg_flags |= MSG_FLAG_EXPECT_IDE_BUSFREE;
+
+			ahd_outb(ahd, RETURN_2, ahd->send_msg_perror);
+			ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_WRITE);
+			break;
+		}
+
+		msgdone	= ahd->msgout_index == ahd->msgout_len;
+		if (msgdone) {
+			/*
+			 * The target has requested a retry.
+			 * Re-assert ATN, reset our message index to
+			 * 0, and try again.
+			 */
+			ahd->msgout_index = 0;
+			ahd_assert_atn(ahd);
+		}
+
+		lastbyte = ahd->msgout_index == (ahd->msgout_len - 1);
+		if (lastbyte) {
+			/* Last byte is signified by dropping ATN */
+			ahd_outb(ahd, CLRSINT1, CLRATNO);
+		}
+
+		/*
+		 * Clear our interrupt status and present
+		 * the next byte on the bus.
+		 */
+		ahd_outb(ahd, CLRSINT1, CLRREQINIT);
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+			printf(" byte 0x%x\n",
+			       ahd->msgout_buf[ahd->msgout_index]);
+#endif
+		ahd_outb(ahd, RETURN_2, ahd->msgout_buf[ahd->msgout_index++]);
+		ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_WRITE);
+		break;
+	}
+	case MSG_TYPE_INITIATOR_MSGIN:
+	{
+		int phasemis;
+		int message_done;
+
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
+			ahd_print_devinfo(ahd, &devinfo);
+			printf("INITIATOR_MSG_IN");
+		}
+#endif
+		phasemis = bus_phase != P_MESGIN;
+		if (phasemis) {
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
+				printf(" PHASEMIS %s\n",
+				       ahd_lookup_phase_entry(bus_phase)
+							     ->phasemsg);
+			}
+#endif
+			ahd->msgin_index = 0;
+			if (bus_phase == P_MESGOUT
+			 && (ahd->send_msg_perror != 0
+			  || (ahd->msgout_len != 0
+			   && ahd->msgout_index == 0))) {
+				ahd->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
+				goto reswitch;
+			}
+			end_session = TRUE;
+			break;
+		}
+
+		/* Pull the byte in without acking it */
+		ahd->msgin_buf[ahd->msgin_index] = ahd_inb(ahd, SCSIBUS);
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+			printf(" byte 0x%x\n",
+			       ahd->msgin_buf[ahd->msgin_index]);
+#endif
+
+		message_done = ahd_parse_msg(ahd, &devinfo);
+
+		if (message_done) {
+			/*
+			 * Clear our incoming message buffer in case there
+			 * is another message following this one.
+			 */
+			ahd->msgin_index = 0;
+
+			/*
+			 * If this message illicited a response,
+			 * assert ATN so the target takes us to the
+			 * message out phase.
+			 */
+			if (ahd->msgout_len != 0) {
+#ifdef AHD_DEBUG
+				if ((ahd_debug & AHD_SHOW_MESSAGES) != 0) {
+					ahd_print_devinfo(ahd, &devinfo);
+					printf("Asserting ATN for response\n");
+				}
+#endif
+				ahd_assert_atn(ahd);
+			}
+		} else 
+			ahd->msgin_index++;
+
+		if (message_done == MSGLOOP_TERMINATED) {
+			end_session = TRUE;
+		} else {
+			/* Ack the byte */
+			ahd_outb(ahd, CLRSINT1, CLRREQINIT);
+			ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_READ);
+		}
+		break;
+	}
+	case MSG_TYPE_TARGET_MSGIN:
+	{
+		int msgdone;
+		int msgout_request;
+
+		/*
+		 * By default, the message loop will continue.
+		 */
+		ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_TARG);
+
+		if (ahd->msgout_len == 0)
+			panic("Target MSGIN with no active message");
+
+		/*
+		 * If we interrupted a mesgout session, the initiator
+		 * will not know this until our first REQ.  So, we
+		 * only honor mesgout requests after we've sent our
+		 * first byte.
+		 */
+		if ((ahd_inb(ahd, SCSISIGI) & ATNI) != 0
+		 && ahd->msgout_index > 0)
+			msgout_request = TRUE;
+		else
+			msgout_request = FALSE;
+
+		if (msgout_request) {
+
+			/*
+			 * Change gears and see if
+			 * this messages is of interest to
+			 * us or should be passed back to
+			 * the sequencer.
+			 */
+			ahd->msg_type = MSG_TYPE_TARGET_MSGOUT;
+			ahd_outb(ahd, SCSISIGO, P_MESGOUT | BSYO);
+			ahd->msgin_index = 0;
+			/* Dummy read to REQ for first byte */
+			ahd_inb(ahd, SCSIDAT);
+			ahd_outb(ahd, SXFRCTL0,
+				 ahd_inb(ahd, SXFRCTL0) | SPIOEN);
+			break;
+		}
+
+		msgdone = ahd->msgout_index == ahd->msgout_len;
+		if (msgdone) {
+			ahd_outb(ahd, SXFRCTL0,
+				 ahd_inb(ahd, SXFRCTL0) & ~SPIOEN);
+			end_session = TRUE;
+			break;
+		}
+
+		/*
+		 * Present the next byte on the bus.
+		 */
+		ahd_outb(ahd, SXFRCTL0, ahd_inb(ahd, SXFRCTL0) | SPIOEN);
+		ahd_outb(ahd, SCSIDAT, ahd->msgout_buf[ahd->msgout_index++]);
+		break;
+	}
+	case MSG_TYPE_TARGET_MSGOUT:
+	{
+		int lastbyte;
+		int msgdone;
+
+		/*
+		 * By default, the message loop will continue.
+		 */
+		ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_TARG);
+
+		/*
+		 * The initiator signals that this is
+		 * the last byte by dropping ATN.
+		 */
+		lastbyte = (ahd_inb(ahd, SCSISIGI) & ATNI) == 0;
+
+		/*
+		 * Read the latched byte, but turn off SPIOEN first
+		 * so that we don't inadvertently cause a REQ for the
+		 * next byte.
+		 */
+		ahd_outb(ahd, SXFRCTL0, ahd_inb(ahd, SXFRCTL0) & ~SPIOEN);
+		ahd->msgin_buf[ahd->msgin_index] = ahd_inb(ahd, SCSIDAT);
+		msgdone = ahd_parse_msg(ahd, &devinfo);
+		if (msgdone == MSGLOOP_TERMINATED) {
+			/*
+			 * The message is *really* done in that it caused
+			 * us to go to bus free.  The sequencer has already
+			 * been reset at this point, so pull the ejection
+			 * handle.
+			 */
+			return;
+		}
+		
+		ahd->msgin_index++;
+
+		/*
+		 * XXX Read spec about initiator dropping ATN too soon
+		 *     and use msgdone to detect it.
+		 */
+		if (msgdone == MSGLOOP_MSGCOMPLETE) {
+			ahd->msgin_index = 0;
+
+			/*
+			 * If this message illicited a response, transition
+			 * to the Message in phase and send it.
+			 */
+			if (ahd->msgout_len != 0) {
+				ahd_outb(ahd, SCSISIGO, P_MESGIN | BSYO);
+				ahd_outb(ahd, SXFRCTL0,
+					 ahd_inb(ahd, SXFRCTL0) | SPIOEN);
+				ahd->msg_type = MSG_TYPE_TARGET_MSGIN;
+				ahd->msgin_index = 0;
+				break;
+			}
+		}
+
+		if (lastbyte)
+			end_session = TRUE;
+		else {
+			/* Ask for the next byte. */
+			ahd_outb(ahd, SXFRCTL0,
+				 ahd_inb(ahd, SXFRCTL0) | SPIOEN);
+		}
+
+		break;
+	}
+	default:
+		panic("Unknown REQINIT message type");
+	}
+
+	if (end_session) {
+		if ((ahd->msg_flags & MSG_FLAG_PACKETIZED) != 0) {
+			printf("%s: Returning to Idle Loop\n",
+			       ahd_name(ahd));
+			ahd_outb(ahd, LASTPHASE, P_BUSFREE);
+			ahd_clear_msg_state(ahd);
+			ahd_outb(ahd, SEQCTL0, FASTMODE|SEQRESET);
+		} else {
+			ahd_clear_msg_state(ahd);
+			ahd_outb(ahd, RETURN_1, EXIT_MSG_LOOP);
+		}
+	}
+}
+
+/*
+ * See if we sent a particular extended message to the target.
+ * If "full" is true, return true only if the target saw the full
+ * message.  If "full" is false, return true if the target saw at
+ * least the first byte of the message.
+ */
+static int
+ahd_sent_msg(struct ahd_softc *ahd, ahd_msgtype type, u_int msgval, int full)
+{
+	int found;
+	u_int index;
+
+	found = FALSE;
+	index = 0;
+
+	while (index < ahd->msgout_len) {
+		if (ahd->msgout_buf[index] == MSG_EXTENDED) {
+			u_int end_index;
+
+			end_index = index + 1 + ahd->msgout_buf[index + 1];
+			if (ahd->msgout_buf[index+2] == msgval
+			 && type == AHDMSG_EXT) {
+
+				if (full) {
+					if (ahd->msgout_index > end_index)
+						found = TRUE;
+				} else if (ahd->msgout_index > index)
+					found = TRUE;
+			}
+			index = end_index;
+		} else if (ahd->msgout_buf[index] >= MSG_SIMPLE_TASK
+			&& ahd->msgout_buf[index] <= MSG_IGN_WIDE_RESIDUE) {
+
+			/* Skip tag type and tag id or residue param*/
+			index += 2;
+		} else {
+			/* Single byte message */
+			if (type == AHDMSG_1B
+			 && ahd->msgout_index > index
+			 && (ahd->msgout_buf[index] == msgval
+			  || ((ahd->msgout_buf[index] & MSG_IDENTIFYFLAG) != 0
+			   && msgval == MSG_IDENTIFYFLAG)))
+				found = TRUE;
+			index++;
+		}
+
+		if (found)
+			break;
+	}
+	return (found);
+}
+
+/*
+ * Wait for a complete incoming message, parse it, and respond accordingly.
+ */
+static int
+ahd_parse_msg(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	struct	ahd_initiator_tinfo *tinfo;
+	struct	ahd_tmode_tstate *tstate;
+	int	reject;
+	int	done;
+	int	response;
+
+	done = MSGLOOP_IN_PROG;
+	response = FALSE;
+	reject = FALSE;
+	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,
+				    devinfo->target, &tstate);
+
+	/*
+	 * Parse as much of the message as is available,
+	 * rejecting it if we don't support it.  When
+	 * the entire message is available and has been
+	 * handled, return MSGLOOP_MSGCOMPLETE, indicating
+	 * that we have parsed an entire message.
+	 *
+	 * In the case of extended messages, we accept the length
+	 * byte outright and perform more checking once we know the
+	 * extended message type.
+	 */
+	switch (ahd->msgin_buf[0]) {
+	case MSG_DISCONNECT:
+	case MSG_SAVEDATAPOINTER:
+	case MSG_CMDCOMPLETE:
+	case MSG_RESTOREPOINTERS:
+	case MSG_IGN_WIDE_RESIDUE:
+		/*
+		 * End our message loop as these are messages
+		 * the sequencer handles on its own.
+		 */
+		done = MSGLOOP_TERMINATED;
+		break;
+	case MSG_MESSAGE_REJECT:
+		response = ahd_handle_msg_reject(ahd, devinfo);
+		/* FALLTHROUGH */
+	case MSG_NOOP:
+		done = MSGLOOP_MSGCOMPLETE;
+		break;
+	case MSG_EXTENDED:
+	{
+		/* Wait for enough of the message to begin validation */
+		if (ahd->msgin_index < 2)
+			break;
+		switch (ahd->msgin_buf[2]) {
+		case MSG_EXT_SDTR:
+		{
+			u_int	 period;
+			u_int	 ppr_options;
+			u_int	 offset;
+			u_int	 saved_offset;
+			
+			if (ahd->msgin_buf[1] != MSG_EXT_SDTR_LEN) {
+				reject = TRUE;
+				break;
+			}
+
+			/*
+			 * Wait until we have both args before validating
+			 * and acting on this message.
+			 *
+			 * Add one to MSG_EXT_SDTR_LEN to account for
+			 * the extended message preamble.
+			 */
+			if (ahd->msgin_index < (MSG_EXT_SDTR_LEN + 1))
+				break;
+
+			period = ahd->msgin_buf[3];
+			ppr_options = 0;
+			saved_offset = offset = ahd->msgin_buf[4];
+			ahd_devlimited_syncrate(ahd, tinfo, &period,
+						&ppr_options, devinfo->role);
+			ahd_validate_offset(ahd, tinfo, period, &offset,
+					    tinfo->curr.width, devinfo->role);
+			if (bootverbose) {
+				printf("(%s:%c:%d:%d): Received "
+				       "SDTR period %x, offset %x\n\t"
+				       "Filtered to period %x, offset %x\n",
+				       ahd_name(ahd), devinfo->channel,
+				       devinfo->target, devinfo->lun,
+				       ahd->msgin_buf[3], saved_offset,
+				       period, offset);
+			}
+			ahd_set_syncrate(ahd, devinfo, period,
+					 offset, ppr_options,
+					 AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
+					 /*paused*/TRUE);
+
+			/*
+			 * See if we initiated Sync Negotiation
+			 * and didn't have to fall down to async
+			 * transfers.
+			 */
+			if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_SDTR, TRUE)) {
+				/* We started it */
+				if (saved_offset != offset) {
+					/* Went too low - force async */
+					reject = TRUE;
+				}
+			} else {
+				/*
+				 * Send our own SDTR in reply
+				 */
+				if (bootverbose
+				 && devinfo->role == ROLE_INITIATOR) {
+					printf("(%s:%c:%d:%d): Target "
+					       "Initiated SDTR\n",
+					       ahd_name(ahd), devinfo->channel,
+					       devinfo->target, devinfo->lun);
+				}
+				ahd->msgout_index = 0;
+				ahd->msgout_len = 0;
+				ahd_construct_sdtr(ahd, devinfo,
+						   period, offset);
+				ahd->msgout_index = 0;
+				response = TRUE;
+			}
+			done = MSGLOOP_MSGCOMPLETE;
+			break;
+		}
+		case MSG_EXT_WDTR:
+		{
+			u_int bus_width;
+			u_int saved_width;
+			u_int sending_reply;
+
+			sending_reply = FALSE;
+			if (ahd->msgin_buf[1] != MSG_EXT_WDTR_LEN) {
+				reject = TRUE;
+				break;
+			}
+
+			/*
+			 * Wait until we have our arg before validating
+			 * and acting on this message.
+			 *
+			 * Add one to MSG_EXT_WDTR_LEN to account for
+			 * the extended message preamble.
+			 */
+			if (ahd->msgin_index < (MSG_EXT_WDTR_LEN + 1))
+				break;
+
+			bus_width = ahd->msgin_buf[3];
+			saved_width = bus_width;
+			ahd_validate_width(ahd, tinfo, &bus_width,
+					   devinfo->role);
+			if (bootverbose) {
+				printf("(%s:%c:%d:%d): Received WDTR "
+				       "%x filtered to %x\n",
+				       ahd_name(ahd), devinfo->channel,
+				       devinfo->target, devinfo->lun,
+				       saved_width, bus_width);
+			}
+
+			if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_WDTR, TRUE)) {
+				/*
+				 * Don't send a WDTR back to the
+				 * target, since we asked first.
+				 * If the width went higher than our
+				 * request, reject it.
+				 */
+				if (saved_width > bus_width) {
+					reject = TRUE;
+					printf("(%s:%c:%d:%d): requested %dBit "
+					       "transfers.  Rejecting...\n",
+					       ahd_name(ahd), devinfo->channel,
+					       devinfo->target, devinfo->lun,
+					       8 * (0x01 << bus_width));
+					bus_width = 0;
+				}
+			} else {
+				/*
+				 * Send our own WDTR in reply
+				 */
+				if (bootverbose
+				 && devinfo->role == ROLE_INITIATOR) {
+					printf("(%s:%c:%d:%d): Target "
+					       "Initiated WDTR\n",
+					       ahd_name(ahd), devinfo->channel,
+					       devinfo->target, devinfo->lun);
+				}
+				ahd->msgout_index = 0;
+				ahd->msgout_len = 0;
+				ahd_construct_wdtr(ahd, devinfo, bus_width);
+				ahd->msgout_index = 0;
+				response = TRUE;
+				sending_reply = TRUE;
+			}
+			/*
+			 * After a wide message, we are async, but
+			 * some devices don't seem to honor this portion
+			 * of the spec.  Force a renegotiation of the
+			 * sync component of our transfer agreement even
+			 * if our goal is async.  By updating our width
+			 * after forcing the negotiation, we avoid
+			 * renegotiating for width.
+			 */
+			ahd_update_neg_request(ahd, devinfo, tstate,
+					       tinfo, AHD_NEG_ALWAYS);
+			ahd_set_width(ahd, devinfo, bus_width,
+				      AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
+				      /*paused*/TRUE);
+			if (sending_reply == FALSE && reject == FALSE) {
+
+				/*
+				 * We will always have an SDTR to send.
+				 */
+				ahd->msgout_index = 0;
+				ahd->msgout_len = 0;
+				ahd_build_transfer_msg(ahd, devinfo);
+				ahd->msgout_index = 0;
+				response = TRUE;
+			}
+			done = MSGLOOP_MSGCOMPLETE;
+			break;
+		}
+		case MSG_EXT_PPR:
+		{
+			u_int	period;
+			u_int	offset;
+			u_int	bus_width;
+			u_int	ppr_options;
+			u_int	saved_width;
+			u_int	saved_offset;
+			u_int	saved_ppr_options;
+
+			if (ahd->msgin_buf[1] != MSG_EXT_PPR_LEN) {
+				reject = TRUE;
+				break;
+			}
+
+			/*
+			 * Wait until we have all args before validating
+			 * and acting on this message.
+			 *
+			 * Add one to MSG_EXT_PPR_LEN to account for
+			 * the extended message preamble.
+			 */
+			if (ahd->msgin_index < (MSG_EXT_PPR_LEN + 1))
+				break;
+
+			period = ahd->msgin_buf[3];
+			offset = ahd->msgin_buf[5];
+			bus_width = ahd->msgin_buf[6];
+			saved_width = bus_width;
+			ppr_options = ahd->msgin_buf[7];
+			/*
+			 * According to the spec, a DT only
+			 * period factor with no DT option
+			 * set implies async.
+			 */
+			if ((ppr_options & MSG_EXT_PPR_DT_REQ) == 0
+			 && period <= 9)
+				offset = 0;
+			saved_ppr_options = ppr_options;
+			saved_offset = offset;
+
+			/*
+			 * Transfer options are only available if we
+			 * are negotiating wide.
+			 */
+			if (bus_width == 0)
+				ppr_options &= MSG_EXT_PPR_QAS_REQ;
+
+			ahd_validate_width(ahd, tinfo, &bus_width,
+					   devinfo->role);
+			ahd_devlimited_syncrate(ahd, tinfo, &period,
+						&ppr_options, devinfo->role);
+			ahd_validate_offset(ahd, tinfo, period, &offset,
+					    bus_width, devinfo->role);
+
+			if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_PPR, TRUE)) {
+				/*
+				 * If we are unable to do any of the
+				 * requested options (we went too low),
+				 * then we'll have to reject the message.
+				 */
+				if (saved_width > bus_width
+				 || saved_offset != offset
+				 || saved_ppr_options != ppr_options) {
+					reject = TRUE;
+					period = 0;
+					offset = 0;
+					bus_width = 0;
+					ppr_options = 0;
+				}
+			} else {
+				if (devinfo->role != ROLE_TARGET)
+					printf("(%s:%c:%d:%d): Target "
+					       "Initiated PPR\n",
+					       ahd_name(ahd), devinfo->channel,
+					       devinfo->target, devinfo->lun);
+				else
+					printf("(%s:%c:%d:%d): Initiator "
+					       "Initiated PPR\n",
+					       ahd_name(ahd), devinfo->channel,
+					       devinfo->target, devinfo->lun);
+				ahd->msgout_index = 0;
+				ahd->msgout_len = 0;
+				ahd_construct_ppr(ahd, devinfo, period, offset,
+						  bus_width, ppr_options);
+				ahd->msgout_index = 0;
+				response = TRUE;
+			}
+			if (bootverbose) {
+				printf("(%s:%c:%d:%d): Received PPR width %x, "
+				       "period %x, offset %x,options %x\n"
+				       "\tFiltered to width %x, period %x, "
+				       "offset %x, options %x\n",
+				       ahd_name(ahd), devinfo->channel,
+				       devinfo->target, devinfo->lun,
+				       saved_width, ahd->msgin_buf[3],
+				       saved_offset, saved_ppr_options,
+				       bus_width, period, offset, ppr_options);
+			}
+			ahd_set_width(ahd, devinfo, bus_width,
+				      AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
+				      /*paused*/TRUE);
+			ahd_set_syncrate(ahd, devinfo, period,
+					 offset, ppr_options,
+					 AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
+					 /*paused*/TRUE);
+
+			done = MSGLOOP_MSGCOMPLETE;
+			break;
+		}
+		default:
+			/* Unknown extended message.  Reject it. */
+			reject = TRUE;
+			break;
+		}
+		break;
+	}
+#ifdef AHD_TARGET_MODE
+	case MSG_BUS_DEV_RESET:
+		ahd_handle_devreset(ahd, devinfo, CAM_LUN_WILDCARD,
+				    CAM_BDR_SENT,
+				    "Bus Device Reset Received",
+				    /*verbose_level*/0);
+		ahd_restart(ahd);
+		done = MSGLOOP_TERMINATED;
+		break;
+	case MSG_ABORT_TAG:
+	case MSG_ABORT:
+	case MSG_CLEAR_QUEUE:
+	{
+		int tag;
+
+		/* Target mode messages */
+		if (devinfo->role != ROLE_TARGET) {
+			reject = TRUE;
+			break;
+		}
+		tag = SCB_LIST_NULL;
+		if (ahd->msgin_buf[0] == MSG_ABORT_TAG)
+			tag = ahd_inb(ahd, INITIATOR_TAG);
+		ahd_abort_scbs(ahd, devinfo->target, devinfo->channel,
+			       devinfo->lun, tag, ROLE_TARGET,
+			       CAM_REQ_ABORTED);
+
+		tstate = ahd->enabled_targets[devinfo->our_scsiid];
+		if (tstate != NULL) {
+			struct ahd_tmode_lstate* lstate;
+
+			lstate = tstate->enabled_luns[devinfo->lun];
+			if (lstate != NULL) {
+				ahd_queue_lstate_event(ahd, lstate,
+						       devinfo->our_scsiid,
+						       ahd->msgin_buf[0],
+						       /*arg*/tag);
+				ahd_send_lstate_events(ahd, lstate);
+			}
+		}
+		ahd_restart(ahd);
+		done = MSGLOOP_TERMINATED;
+		break;
+	}
+#endif
+	case MSG_QAS_REQUEST:
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+			printf("%s: QAS request.  SCSISIGI == 0x%x\n",
+			       ahd_name(ahd), ahd_inb(ahd, SCSISIGI));
+#endif
+		ahd->msg_flags |= MSG_FLAG_EXPECT_QASREJ_BUSFREE;
+		/* FALLTHROUGH */
+	case MSG_TERM_IO_PROC:
+	default:
+		reject = TRUE;
+		break;
+	}
+
+	if (reject) {
+		/*
+		 * Setup to reject the message.
+		 */
+		ahd->msgout_index = 0;
+		ahd->msgout_len = 1;
+		ahd->msgout_buf[0] = MSG_MESSAGE_REJECT;
+		done = MSGLOOP_MSGCOMPLETE;
+		response = TRUE;
+	}
+
+	if (done != MSGLOOP_IN_PROG && !response)
+		/* Clear the outgoing message buffer */
+		ahd->msgout_len = 0;
+
+	return (done);
+}
+
+/*
+ * Process a message reject message.
+ */
+static int
+ahd_handle_msg_reject(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	/*
+	 * What we care about here is if we had an
+	 * outstanding SDTR or WDTR message for this
+	 * target.  If we did, this is a signal that
+	 * the target is refusing negotiation.
+	 */
+	struct scb *scb;
+	struct ahd_initiator_tinfo *tinfo;
+	struct ahd_tmode_tstate *tstate;
+	u_int scb_index;
+	u_int last_msg;
+	int   response = 0;
+
+	scb_index = ahd_get_scbptr(ahd);
+	scb = ahd_lookup_scb(ahd, scb_index);
+	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel,
+				    devinfo->our_scsiid,
+				    devinfo->target, &tstate);
+	/* Might be necessary */
+	last_msg = ahd_inb(ahd, LAST_MSG);
+
+	if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_PPR, /*full*/FALSE)) {
+		if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_PPR, /*full*/TRUE)
+		 && tinfo->goal.period <= AHD_SYNCRATE_PACED) {
+			/*
+			 * Target may not like our SPI-4 PPR Options.
+			 * Attempt to negotiate 80MHz which will turn
+			 * off these options.
+			 */
+			if (bootverbose) {
+				printf("(%s:%c:%d:%d): PPR Rejected. "
+				       "Trying simple U160 PPR\n",
+				       ahd_name(ahd), devinfo->channel,
+				       devinfo->target, devinfo->lun);
+			}
+			tinfo->goal.period = AHD_SYNCRATE_DT;
+			tinfo->goal.ppr_options &= MSG_EXT_PPR_IU_REQ
+						|  MSG_EXT_PPR_QAS_REQ
+						|  MSG_EXT_PPR_DT_REQ;
+		} else {
+			/*
+			 * Target does not support the PPR message.
+			 * Attempt to negotiate SPI-2 style.
+			 */
+			if (bootverbose) {
+				printf("(%s:%c:%d:%d): PPR Rejected. "
+				       "Trying WDTR/SDTR\n",
+				       ahd_name(ahd), devinfo->channel,
+				       devinfo->target, devinfo->lun);
+			}
+			tinfo->goal.ppr_options = 0;
+			tinfo->curr.transport_version = 2;
+			tinfo->goal.transport_version = 2;
+		}
+		ahd->msgout_index = 0;
+		ahd->msgout_len = 0;
+		ahd_build_transfer_msg(ahd, devinfo);
+		ahd->msgout_index = 0;
+		response = 1;
+	} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_WDTR, /*full*/FALSE)) {
+
+		/* note 8bit xfers */
+		printf("(%s:%c:%d:%d): refuses WIDE negotiation.  Using "
+		       "8bit transfers\n", ahd_name(ahd),
+		       devinfo->channel, devinfo->target, devinfo->lun);
+		ahd_set_width(ahd, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+			      AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
+			      /*paused*/TRUE);
+		/*
+		 * No need to clear the sync rate.  If the target
+		 * did not accept the command, our syncrate is
+		 * unaffected.  If the target started the negotiation,
+		 * but rejected our response, we already cleared the
+		 * sync rate before sending our WDTR.
+		 */
+		if (tinfo->goal.offset != tinfo->curr.offset) {
+
+			/* Start the sync negotiation */
+			ahd->msgout_index = 0;
+			ahd->msgout_len = 0;
+			ahd_build_transfer_msg(ahd, devinfo);
+			ahd->msgout_index = 0;
+			response = 1;
+		}
+	} else if (ahd_sent_msg(ahd, AHDMSG_EXT, MSG_EXT_SDTR, /*full*/FALSE)) {
+		/* note asynch xfers and clear flag */
+		ahd_set_syncrate(ahd, devinfo, /*period*/0,
+				 /*offset*/0, /*ppr_options*/0,
+				 AHD_TRANS_ACTIVE|AHD_TRANS_GOAL,
+				 /*paused*/TRUE);
+		printf("(%s:%c:%d:%d): refuses synchronous negotiation. "
+		       "Using asynchronous transfers\n",
+		       ahd_name(ahd), devinfo->channel,
+		       devinfo->target, devinfo->lun);
+	} else if ((scb->hscb->control & MSG_SIMPLE_TASK) != 0) {
+		int tag_type;
+		int mask;
+
+		tag_type = (scb->hscb->control & MSG_SIMPLE_TASK);
+
+		if (tag_type == MSG_SIMPLE_TASK) {
+			printf("(%s:%c:%d:%d): refuses tagged commands.  "
+			       "Performing non-tagged I/O\n", ahd_name(ahd),
+			       devinfo->channel, devinfo->target, devinfo->lun);
+			ahd_set_tags(ahd, devinfo, AHD_QUEUE_NONE);
+			mask = ~0x23;
+		} else {
+			printf("(%s:%c:%d:%d): refuses %s tagged commands.  "
+			       "Performing simple queue tagged I/O only\n",
+			       ahd_name(ahd), devinfo->channel, devinfo->target,
+			       devinfo->lun, tag_type == MSG_ORDERED_TASK
+			       ? "ordered" : "head of queue");
+			ahd_set_tags(ahd, devinfo, AHD_QUEUE_BASIC);
+			mask = ~0x03;
+		}
+
+		/*
+		 * Resend the identify for this CCB as the target
+		 * may believe that the selection is invalid otherwise.
+		 */
+		ahd_outb(ahd, SCB_CONTROL,
+			 ahd_inb_scbram(ahd, SCB_CONTROL) & mask);
+	 	scb->hscb->control &= mask;
+		ahd_set_transaction_tag(scb, /*enabled*/FALSE,
+					/*type*/MSG_SIMPLE_TASK);
+		ahd_outb(ahd, MSG_OUT, MSG_IDENTIFYFLAG);
+		ahd_assert_atn(ahd);
+		ahd_busy_tcl(ahd, BUILD_TCL(scb->hscb->scsiid, devinfo->lun),
+			     SCB_GET_TAG(scb));
+
+		/*
+		 * Requeue all tagged commands for this target
+		 * currently in our posession so they can be
+		 * converted to untagged commands.
+		 */
+		ahd_search_qinfifo(ahd, SCB_GET_TARGET(ahd, scb),
+				   SCB_GET_CHANNEL(ahd, scb),
+				   SCB_GET_LUN(scb), /*tag*/SCB_LIST_NULL,
+				   ROLE_INITIATOR, CAM_REQUEUE_REQ,
+				   SEARCH_COMPLETE);
+	} else if (ahd_sent_msg(ahd, AHDMSG_1B, MSG_IDENTIFYFLAG, TRUE)) {
+		/*
+		 * Most likely the device believes that we had
+		 * previously negotiated packetized.
+		 */
+		ahd->msg_flags |= MSG_FLAG_EXPECT_PPR_BUSFREE
+			       |  MSG_FLAG_IU_REQ_CHANGED;
+
+		ahd_force_renegotiation(ahd, devinfo);
+		ahd->msgout_index = 0;
+		ahd->msgout_len = 0;
+		ahd_build_transfer_msg(ahd, devinfo);
+		ahd->msgout_index = 0;
+		response = 1;
+	} else {
+		/*
+		 * Otherwise, we ignore it.
+		 */
+		printf("%s:%c:%d: Message reject for %x -- ignored\n",
+		       ahd_name(ahd), devinfo->channel, devinfo->target,
+		       last_msg);
+	}
+	return (response);
+}
+
+/*
+ * Process an ingnore wide residue message.
+ */
+static void
+ahd_handle_ign_wide_residue(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	u_int scb_index;
+	struct scb *scb;
+
+	scb_index = ahd_get_scbptr(ahd);
+	scb = ahd_lookup_scb(ahd, scb_index);
+	/*
+	 * XXX Actually check data direction in the sequencer?
+	 * Perhaps add datadir to some spare bits in the hscb?
+	 */
+	if ((ahd_inb(ahd, SEQ_FLAGS) & DPHASE) == 0
+	 || ahd_get_transfer_dir(scb) != CAM_DIR_IN) {
+		/*
+		 * Ignore the message if we haven't
+		 * seen an appropriate data phase yet.
+		 */
+	} else {
+		/*
+		 * If the residual occurred on the last
+		 * transfer and the transfer request was
+		 * expected to end on an odd count, do
+		 * nothing.  Otherwise, subtract a byte
+		 * and update the residual count accordingly.
+		 */
+		uint32_t sgptr;
+
+		sgptr = ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR);
+		if ((sgptr & SG_LIST_NULL) != 0
+		 && (ahd_inb(ahd, SCB_TASK_ATTRIBUTE) & SCB_XFERLEN_ODD) != 0) {
+			/*
+			 * If the residual occurred on the last
+			 * transfer and the transfer request was
+			 * expected to end on an odd count, do
+			 * nothing.
+			 */
+		} else {
+			uint32_t data_cnt;
+			uint64_t data_addr;
+			uint32_t sglen;
+
+			/* Pull in the rest of the sgptr */
+			sgptr = ahd_inl_scbram(ahd, SCB_RESIDUAL_SGPTR);
+			data_cnt = ahd_inl_scbram(ahd, SCB_RESIDUAL_DATACNT);
+			if ((sgptr & SG_LIST_NULL) != 0) {
+				/*
+				 * The residual data count is not updated
+				 * for the command run to completion case.
+				 * Explicitly zero the count.
+				 */
+				data_cnt &= ~AHD_SG_LEN_MASK;
+			}
+			data_addr = ahd_inq(ahd, SHADDR);
+			data_cnt += 1;
+			data_addr -= 1;
+			sgptr &= SG_PTR_MASK;
+			if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
+				struct ahd_dma64_seg *sg;
+
+				sg = ahd_sg_bus_to_virt(ahd, scb, sgptr);
+
+				/*
+				 * The residual sg ptr points to the next S/G
+				 * to load so we must go back one.
+				 */
+				sg--;
+				sglen = ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;
+				if (sg != scb->sg_list
+				 && sglen < (data_cnt & AHD_SG_LEN_MASK)) {
+
+					sg--;
+					sglen = ahd_le32toh(sg->len);
+					/*
+					 * Preserve High Address and SG_LIST
+					 * bits while setting the count to 1.
+					 */
+					data_cnt = 1|(sglen&(~AHD_SG_LEN_MASK));
+					data_addr = ahd_le64toh(sg->addr)
+						  + (sglen & AHD_SG_LEN_MASK)
+						  - 1;
+
+					/*
+					 * Increment sg so it points to the
+					 * "next" sg.
+					 */
+					sg++;
+					sgptr = ahd_sg_virt_to_bus(ahd, scb,
+								   sg);
+				}
+			} else {
+				struct ahd_dma_seg *sg;
+
+				sg = ahd_sg_bus_to_virt(ahd, scb, sgptr);
+
+				/*
+				 * The residual sg ptr points to the next S/G
+				 * to load so we must go back one.
+				 */
+				sg--;
+				sglen = ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;
+				if (sg != scb->sg_list
+				 && sglen < (data_cnt & AHD_SG_LEN_MASK)) {
+
+					sg--;
+					sglen = ahd_le32toh(sg->len);
+					/*
+					 * Preserve High Address and SG_LIST
+					 * bits while setting the count to 1.
+					 */
+					data_cnt = 1|(sglen&(~AHD_SG_LEN_MASK));
+					data_addr = ahd_le32toh(sg->addr)
+						  + (sglen & AHD_SG_LEN_MASK)
+						  - 1;
+
+					/*
+					 * Increment sg so it points to the
+					 * "next" sg.
+					 */
+					sg++;
+					sgptr = ahd_sg_virt_to_bus(ahd, scb,
+								  sg);
+				}
+			}
+			/*
+			 * Toggle the "oddness" of the transfer length
+			 * to handle this mid-transfer ignore wide
+			 * residue.  This ensures that the oddness is
+			 * correct for subsequent data transfers.
+			 */
+			ahd_outb(ahd, SCB_TASK_ATTRIBUTE,
+			    ahd_inb(ahd, SCB_TASK_ATTRIBUTE) ^ SCB_XFERLEN_ODD);
+
+			ahd_outl(ahd, SCB_RESIDUAL_SGPTR, sgptr);
+			ahd_outl(ahd, SCB_RESIDUAL_DATACNT, data_cnt);
+			/*
+			 * The FIFO's pointers will be updated if/when the
+			 * sequencer re-enters a data phase.
+			 */
+		}
+	}
+}
+
+
+/*
+ * Reinitialize the data pointers for the active transfer
+ * based on its current residual.
+ */
+static void
+ahd_reinitialize_dataptrs(struct ahd_softc *ahd)
+{
+	struct		 scb *scb;
+	ahd_mode_state	 saved_modes;
+	u_int		 scb_index;
+	u_int		 wait;
+	uint32_t	 sgptr;
+	uint32_t	 resid;
+	uint64_t	 dataptr;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_DFF0_MSK|AHD_MODE_DFF1_MSK,
+			 AHD_MODE_DFF0_MSK|AHD_MODE_DFF1_MSK);
+			 
+	scb_index = ahd_get_scbptr(ahd);
+	scb = ahd_lookup_scb(ahd, scb_index);
+
+	/*
+	 * Release and reacquire the FIFO so we
+	 * have a clean slate.
+	 */
+	ahd_outb(ahd, DFFSXFRCTL, CLRCHN);
+	wait = 1000;
+	do {
+		ahd_delay(100);
+	} while (--wait && !(ahd_inb(ahd, MDFFSTAT) & FIFOFREE));
+	if (wait == 0) {
+		ahd_print_path(ahd, scb);
+		printf("ahd_reinitialize_dataptrs: Forcing FIFO free.\n");
+		ahd_outb(ahd, DFFSXFRCTL, RSTCHN|CLRSHCNT);
+	}
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	ahd_outb(ahd, DFFSTAT,
+		 ahd_inb(ahd, DFFSTAT)
+		| (saved_modes == 0x11 ? CURRFIFO_1 : CURRFIFO_0));
+
+	/*
+	 * Determine initial values for data_addr and data_cnt
+	 * for resuming the data phase.
+	 */
+	sgptr = (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 3) << 24)
+	      | (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 2) << 16)
+	      | (ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR + 1) << 8)
+	      |	ahd_inb_scbram(ahd, SCB_RESIDUAL_SGPTR);
+	sgptr &= SG_PTR_MASK;
+
+	resid = (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT + 2) << 16)
+	      | (ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT + 1) << 8)
+	      | ahd_inb_scbram(ahd, SCB_RESIDUAL_DATACNT);
+
+	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
+		struct ahd_dma64_seg *sg;
+
+		sg = ahd_sg_bus_to_virt(ahd, scb, sgptr);
+
+		/* The residual sg_ptr always points to the next sg */
+		sg--;
+
+		dataptr = ahd_le64toh(sg->addr)
+			+ (ahd_le32toh(sg->len) & AHD_SG_LEN_MASK)
+			- resid;
+		ahd_outb(ahd, HADDR + 7, dataptr >> 56);
+		ahd_outb(ahd, HADDR + 6, dataptr >> 48);
+		ahd_outb(ahd, HADDR + 5, dataptr >> 40);
+		ahd_outb(ahd, HADDR + 4, dataptr >> 32);
+	} else {
+		struct	 ahd_dma_seg *sg;
+
+		sg = ahd_sg_bus_to_virt(ahd, scb, sgptr);
+
+		/* The residual sg_ptr always points to the next sg */
+		sg--;
+
+		dataptr = ahd_le32toh(sg->addr)
+			+ (ahd_le32toh(sg->len) & AHD_SG_LEN_MASK)
+			- resid;
+		ahd_outb(ahd, HADDR + 4,
+			 (ahd_le32toh(sg->len) & ~AHD_SG_LEN_MASK) >> 24);
+	}
+	ahd_outb(ahd, HADDR + 3, dataptr >> 24);
+	ahd_outb(ahd, HADDR + 2, dataptr >> 16);
+	ahd_outb(ahd, HADDR + 1, dataptr >> 8);
+	ahd_outb(ahd, HADDR, dataptr);
+	ahd_outb(ahd, HCNT + 2, resid >> 16);
+	ahd_outb(ahd, HCNT + 1, resid >> 8);
+	ahd_outb(ahd, HCNT, resid);
+}
+
+/*
+ * Handle the effects of issuing a bus device reset message.
+ */
+static void
+ahd_handle_devreset(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		    u_int lun, cam_status status, char *message,
+		    int verbose_level)
+{
+#ifdef AHD_TARGET_MODE
+	struct ahd_tmode_tstate* tstate;
+#endif
+	int found;
+
+	found = ahd_abort_scbs(ahd, devinfo->target, devinfo->channel,
+			       lun, SCB_LIST_NULL, devinfo->role,
+			       status);
+
+#ifdef AHD_TARGET_MODE
+	/*
+	 * Send an immediate notify ccb to all target mord peripheral
+	 * drivers affected by this action.
+	 */
+	tstate = ahd->enabled_targets[devinfo->our_scsiid];
+	if (tstate != NULL) {
+		u_int cur_lun;
+		u_int max_lun;
+
+		if (lun != CAM_LUN_WILDCARD) {
+			cur_lun = 0;
+			max_lun = AHD_NUM_LUNS - 1;
+		} else {
+			cur_lun = lun;
+			max_lun = lun;
+		}
+		for (cur_lun <= max_lun; cur_lun++) {
+			struct ahd_tmode_lstate* lstate;
+
+			lstate = tstate->enabled_luns[cur_lun];
+			if (lstate == NULL)
+				continue;
+
+			ahd_queue_lstate_event(ahd, lstate, devinfo->our_scsiid,
+					       MSG_BUS_DEV_RESET, /*arg*/0);
+			ahd_send_lstate_events(ahd, lstate);
+		}
+	}
+#endif
+
+	/*
+	 * Go back to async/narrow transfers and renegotiate.
+	 */
+	ahd_set_width(ahd, devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+		      AHD_TRANS_CUR, /*paused*/TRUE);
+	ahd_set_syncrate(ahd, devinfo, /*period*/0, /*offset*/0,
+			 /*ppr_options*/0, AHD_TRANS_CUR, /*paused*/TRUE);
+	
+	ahd_send_async(ahd, devinfo->channel, devinfo->target,
+		       lun, AC_SENT_BDR, NULL);
+
+	if (message != NULL
+	 && (verbose_level <= bootverbose))
+		printf("%s: %s on %c:%d. %d SCBs aborted\n", ahd_name(ahd),
+		       message, devinfo->channel, devinfo->target, found);
+}
+
+#ifdef AHD_TARGET_MODE
+static void
+ahd_setup_target_msgin(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		       struct scb *scb)
+{
+
+	/*              
+	 * To facilitate adding multiple messages together,
+	 * each routine should increment the index and len
+	 * variables instead of setting them explicitly.
+	 */             
+	ahd->msgout_index = 0;
+	ahd->msgout_len = 0;
+
+	if (scb != NULL && (scb->flags & SCB_AUTO_NEGOTIATE) != 0)
+		ahd_build_transfer_msg(ahd, devinfo);
+	else
+		panic("ahd_intr: AWAITING target message with no message");
+
+	ahd->msgout_index = 0;
+	ahd->msg_type = MSG_TYPE_TARGET_MSGIN;
+}
+#endif
+/**************************** Initialization **********************************/
+static u_int
+ahd_sglist_size(struct ahd_softc *ahd)
+{
+	bus_size_t list_size;
+
+	list_size = sizeof(struct ahd_dma_seg) * AHD_NSEG;
+	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)
+		list_size = sizeof(struct ahd_dma64_seg) * AHD_NSEG;
+	return (list_size);
+}
+
+/*
+ * Calculate the optimum S/G List allocation size.  S/G elements used
+ * for a given transaction must be physically contiguous.  Assume the
+ * OS will allocate full pages to us, so it doesn't make sense to request
+ * less than a page.
+ */
+static u_int
+ahd_sglist_allocsize(struct ahd_softc *ahd)
+{
+	bus_size_t sg_list_increment;
+	bus_size_t sg_list_size;
+	bus_size_t max_list_size;
+	bus_size_t best_list_size;
+
+	/* Start out with the minimum required for AHD_NSEG. */
+	sg_list_increment = ahd_sglist_size(ahd);
+	sg_list_size = sg_list_increment;
+
+	/* Get us as close as possible to a page in size. */
+	while ((sg_list_size + sg_list_increment) <= PAGE_SIZE)
+		sg_list_size += sg_list_increment;
+
+	/*
+	 * Try to reduce the amount of wastage by allocating
+	 * multiple pages.
+	 */
+	best_list_size = sg_list_size;
+	max_list_size = roundup(sg_list_increment, PAGE_SIZE);
+	if (max_list_size < 4 * PAGE_SIZE)
+		max_list_size = 4 * PAGE_SIZE;
+	if (max_list_size > (AHD_SCB_MAX_ALLOC * sg_list_increment))
+		max_list_size = (AHD_SCB_MAX_ALLOC * sg_list_increment);
+	while ((sg_list_size + sg_list_increment) <= max_list_size
+	   &&  (sg_list_size % PAGE_SIZE) != 0) {
+		bus_size_t new_mod;
+		bus_size_t best_mod;
+
+		sg_list_size += sg_list_increment;
+		new_mod = sg_list_size % PAGE_SIZE;
+		best_mod = best_list_size % PAGE_SIZE;
+		if (new_mod > best_mod || new_mod == 0) {
+			best_list_size = sg_list_size;
+		}
+	}
+	return (best_list_size);
+}
+
+/*
+ * Allocate a controller structure for a new device
+ * and perform initial initializion.
+ */
+struct ahd_softc *
+ahd_alloc(void *platform_arg, char *name)
+{
+	struct  ahd_softc *ahd;
+
+#ifndef	__FreeBSD__
+	ahd = malloc(sizeof(*ahd), M_DEVBUF, M_NOWAIT);
+	if (!ahd) {
+		printf("aic7xxx: cannot malloc softc!\n");
+		free(name, M_DEVBUF);
+		return NULL;
+	}
+#else
+	ahd = device_get_softc((device_t)platform_arg);
+#endif
+	memset(ahd, 0, sizeof(*ahd));
+	ahd->seep_config = malloc(sizeof(*ahd->seep_config),
+				  M_DEVBUF, M_NOWAIT);
+	if (ahd->seep_config == NULL) {
+#ifndef	__FreeBSD__
+		free(ahd, M_DEVBUF);
+#endif
+		free(name, M_DEVBUF);
+		return (NULL);
+	}
+	LIST_INIT(&ahd->pending_scbs);
+	/* We don't know our unit number until the OSM sets it */
+	ahd->name = name;
+	ahd->unit = -1;
+	ahd->description = NULL;
+	ahd->bus_description = NULL;
+	ahd->channel = 'A';
+	ahd->chip = AHD_NONE;
+	ahd->features = AHD_FENONE;
+	ahd->bugs = AHD_BUGNONE;
+	ahd->flags = AHD_SPCHK_ENB_A|AHD_RESET_BUS_A|AHD_TERM_ENB_A
+		   | AHD_EXTENDED_TRANS_A|AHD_STPWLEVEL_A;
+	ahd_timer_init(&ahd->reset_timer);
+	ahd_timer_init(&ahd->stat_timer);
+	ahd->int_coalescing_timer = AHD_INT_COALESCING_TIMER_DEFAULT;
+	ahd->int_coalescing_maxcmds = AHD_INT_COALESCING_MAXCMDS_DEFAULT;
+	ahd->int_coalescing_mincmds = AHD_INT_COALESCING_MINCMDS_DEFAULT;
+	ahd->int_coalescing_threshold = AHD_INT_COALESCING_THRESHOLD_DEFAULT;
+	ahd->int_coalescing_stop_threshold =
+	    AHD_INT_COALESCING_STOP_THRESHOLD_DEFAULT;
+
+	if (ahd_platform_alloc(ahd, platform_arg) != 0) {
+		ahd_free(ahd);
+		ahd = NULL;
+	}
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_MEMORY) != 0) {
+		printf("%s: scb size = 0x%x, hscb size = 0x%x\n",
+		       ahd_name(ahd), (u_int)sizeof(struct scb),
+		       (u_int)sizeof(struct hardware_scb));
+	}
+#endif
+	return (ahd);
+}
+
+int
+ahd_softc_init(struct ahd_softc *ahd)
+{
+
+	ahd->unpause = 0;
+	ahd->pause = PAUSE; 
+	return (0);
+}
+
+void
+ahd_softc_insert(struct ahd_softc *ahd)
+{
+	struct ahd_softc *list_ahd;
+
+#if AHD_PCI_CONFIG > 0
+	/*
+	 * Second Function PCI devices need to inherit some
+	 * settings from function 0.
+	 */
+	if ((ahd->features & AHD_MULTI_FUNC) != 0) {
+		TAILQ_FOREACH(list_ahd, &ahd_tailq, links) {
+			ahd_dev_softc_t list_pci;
+			ahd_dev_softc_t pci;
+
+			list_pci = list_ahd->dev_softc;
+			pci = ahd->dev_softc;
+			if (ahd_get_pci_slot(list_pci) == ahd_get_pci_slot(pci)
+			 && ahd_get_pci_bus(list_pci) == ahd_get_pci_bus(pci)) {
+				struct ahd_softc *master;
+				struct ahd_softc *slave;
+
+				if (ahd_get_pci_function(list_pci) == 0) {
+					master = list_ahd;
+					slave = ahd;
+				} else {
+					master = ahd;
+					slave = list_ahd;
+				}
+				slave->flags &= ~AHD_BIOS_ENABLED; 
+				slave->flags |=
+				    master->flags & AHD_BIOS_ENABLED;
+				break;
+			}
+		}
+	}
+#endif
+
+	/*
+	 * Insertion sort into our list of softcs.
+	 */
+	list_ahd = TAILQ_FIRST(&ahd_tailq);
+	while (list_ahd != NULL
+	    && ahd_softc_comp(ahd, list_ahd) <= 0)
+		list_ahd = TAILQ_NEXT(list_ahd, links);
+	if (list_ahd != NULL)
+		TAILQ_INSERT_BEFORE(list_ahd, ahd, links);
+	else
+		TAILQ_INSERT_TAIL(&ahd_tailq, ahd, links);
+	ahd->init_level++;
+}
+
+/*
+ * Verify that the passed in softc pointer is for a
+ * controller that is still configured.
+ */
+struct ahd_softc *
+ahd_find_softc(struct ahd_softc *ahd)
+{
+	struct ahd_softc *list_ahd;
+
+	TAILQ_FOREACH(list_ahd, &ahd_tailq, links) {
+		if (list_ahd == ahd)
+			return (ahd);
+	}
+	return (NULL);
+}
+
+void
+ahd_set_unit(struct ahd_softc *ahd, int unit)
+{
+	ahd->unit = unit;
+}
+
+void
+ahd_set_name(struct ahd_softc *ahd, char *name)
+{
+	if (ahd->name != NULL)
+		free(ahd->name, M_DEVBUF);
+	ahd->name = name;
+}
+
+void
+ahd_free(struct ahd_softc *ahd)
+{
+	int i;
+
+	switch (ahd->init_level) {
+	default:
+	case 5:
+		ahd_shutdown(ahd);
+		TAILQ_REMOVE(&ahd_tailq, ahd, links);
+		/* FALLTHROUGH */
+	case 4:
+		ahd_dmamap_unload(ahd, ahd->shared_data_dmat,
+				  ahd->shared_data_dmamap);
+		/* FALLTHROUGH */
+	case 3:
+		ahd_dmamem_free(ahd, ahd->shared_data_dmat, ahd->qoutfifo,
+				ahd->shared_data_dmamap);
+		ahd_dmamap_destroy(ahd, ahd->shared_data_dmat,
+				   ahd->shared_data_dmamap);
+		/* FALLTHROUGH */
+	case 2:
+		ahd_dma_tag_destroy(ahd, ahd->shared_data_dmat);
+	case 1:
+#ifndef __linux__
+		ahd_dma_tag_destroy(ahd, ahd->buffer_dmat);
+#endif
+		break;
+	case 0:
+		break;
+	}
+
+#ifndef __linux__
+	ahd_dma_tag_destroy(ahd, ahd->parent_dmat);
+#endif
+	ahd_platform_free(ahd);
+	ahd_fini_scbdata(ahd);
+	for (i = 0; i < AHD_NUM_TARGETS; i++) {
+		struct ahd_tmode_tstate *tstate;
+
+		tstate = ahd->enabled_targets[i];
+		if (tstate != NULL) {
+#if AHD_TARGET_MODE
+			int j;
+
+			for (j = 0; j < AHD_NUM_LUNS; j++) {
+				struct ahd_tmode_lstate *lstate;
+
+				lstate = tstate->enabled_luns[j];
+				if (lstate != NULL) {
+					xpt_free_path(lstate->path);
+					free(lstate, M_DEVBUF);
+				}
+			}
+#endif
+			free(tstate, M_DEVBUF);
+		}
+	}
+#if AHD_TARGET_MODE
+	if (ahd->black_hole != NULL) {
+		xpt_free_path(ahd->black_hole->path);
+		free(ahd->black_hole, M_DEVBUF);
+	}
+#endif
+	if (ahd->name != NULL)
+		free(ahd->name, M_DEVBUF);
+	if (ahd->seep_config != NULL)
+		free(ahd->seep_config, M_DEVBUF);
+	if (ahd->saved_stack != NULL)
+		free(ahd->saved_stack, M_DEVBUF);
+#ifndef __FreeBSD__
+	free(ahd, M_DEVBUF);
+#endif
+	return;
+}
+
+void
+ahd_shutdown(void *arg)
+{
+	struct	ahd_softc *ahd;
+
+	ahd = (struct ahd_softc *)arg;
+
+	/*
+	 * Stop periodic timer callbacks.
+	 */
+	ahd_timer_stop(&ahd->reset_timer);
+	ahd_timer_stop(&ahd->stat_timer);
+
+	/* This will reset most registers to 0, but not all */
+	ahd_reset(ahd, /*reinit*/FALSE);
+}
+
+/*
+ * Reset the controller and record some information about it
+ * that is only available just after a reset.  If "reinit" is
+ * non-zero, this reset occured after initial configuration
+ * and the caller requests that the chip be fully reinitialized
+ * to a runable state.  Chip interrupts are *not* enabled after
+ * a reinitialization.  The caller must enable interrupts via
+ * ahd_intr_enable().
+ */
+int
+ahd_reset(struct ahd_softc *ahd, int reinit)
+{
+	u_int	 sxfrctl1;
+	int	 wait;
+	uint32_t cmd;
+	
+	/*
+	 * Preserve the value of the SXFRCTL1 register for all channels.
+	 * It contains settings that affect termination and we don't want
+	 * to disturb the integrity of the bus.
+	 */
+	ahd_pause(ahd);
+	ahd_update_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	sxfrctl1 = ahd_inb(ahd, SXFRCTL1);
+
+	cmd = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, /*bytes*/2);
+	if ((ahd->bugs & AHD_PCIX_CHIPRST_BUG) != 0) {
+		uint32_t mod_cmd;
+
+		/*
+		 * A4 Razor #632
+		 * During the assertion of CHIPRST, the chip
+		 * does not disable its parity logic prior to
+		 * the start of the reset.  This may cause a
+		 * parity error to be detected and thus a
+		 * spurious SERR or PERR assertion.  Disble
+		 * PERR and SERR responses during the CHIPRST.
+		 */
+		mod_cmd = cmd & ~(PCIM_CMD_PERRESPEN|PCIM_CMD_SERRESPEN);
+		ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
+				     mod_cmd, /*bytes*/2);
+	}
+	ahd_outb(ahd, HCNTRL, CHIPRST | ahd->pause);
+
+	/*
+	 * Ensure that the reset has finished.  We delay 1000us
+	 * prior to reading the register to make sure the chip
+	 * has sufficiently completed its reset to handle register
+	 * accesses.
+	 */
+	wait = 1000;
+	do {
+		ahd_delay(1000);
+	} while (--wait && !(ahd_inb(ahd, HCNTRL) & CHIPRSTACK));
+
+	if (wait == 0) {
+		printf("%s: WARNING - Failed chip reset!  "
+		       "Trying to initialize anyway.\n", ahd_name(ahd));
+	}
+	ahd_outb(ahd, HCNTRL, ahd->pause);
+
+	if ((ahd->bugs & AHD_PCIX_CHIPRST_BUG) != 0) {
+		/*
+		 * Clear any latched PCI error status and restore
+		 * previous SERR and PERR response enables.
+		 */
+		ahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
+				     0xFF, /*bytes*/1);
+		ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
+				     cmd, /*bytes*/2);
+	}
+
+	/*
+	 * Mode should be SCSI after a chip reset, but lets
+	 * set it just to be safe.  We touch the MODE_PTR
+	 * register directly so as to bypass the lazy update
+	 * code in ahd_set_modes().
+	 */
+	ahd_known_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	ahd_outb(ahd, MODE_PTR,
+		 ahd_build_mode_state(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI));
+
+	/*
+	 * Restore SXFRCTL1.
+	 *
+	 * We must always initialize STPWEN to 1 before we
+	 * restore the saved values.  STPWEN is initialized
+	 * to a tri-state condition which can only be cleared
+	 * by turning it on.
+	 */
+	ahd_outb(ahd, SXFRCTL1, sxfrctl1|STPWEN);
+	ahd_outb(ahd, SXFRCTL1, sxfrctl1);
+
+	/* Determine chip configuration */
+	ahd->features &= ~AHD_WIDE;
+	if ((ahd_inb(ahd, SBLKCTL) & SELWIDE) != 0)
+		ahd->features |= AHD_WIDE;
+
+	/*
+	 * If a recovery action has forced a chip reset,
+	 * re-initialize the chip to our liking.
+	 */
+	if (reinit != 0)
+		ahd_chip_init(ahd);
+
+	return (0);
+}
+
+/*
+ * Determine the number of SCBs available on the controller
+ */
+int
+ahd_probe_scbs(struct ahd_softc *ahd) {
+	int i;
+
+	AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
+			 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
+	for (i = 0; i < AHD_SCB_MAX; i++) {
+		int j;
+
+		ahd_set_scbptr(ahd, i);
+		ahd_outw(ahd, SCB_BASE, i);
+		for (j = 2; j < 64; j++)
+			ahd_outb(ahd, SCB_BASE+j, 0);
+		/* Start out life as unallocated (needing an abort) */
+		ahd_outb(ahd, SCB_CONTROL, MK_MESSAGE);
+		if (ahd_inw_scbram(ahd, SCB_BASE) != i)
+			break;
+		ahd_set_scbptr(ahd, 0);
+		if (ahd_inw_scbram(ahd, SCB_BASE) != 0)
+			break;
+	}
+	return (i);
+}
+
+static void
+ahd_dmamap_cb(void *arg, bus_dma_segment_t *segs, int nseg, int error) 
+{
+	bus_addr_t *baddr;
+
+	baddr = (bus_addr_t *)arg;
+	*baddr = segs->ds_addr;
+}
+
+static void
+ahd_initialize_hscbs(struct ahd_softc *ahd)
+{
+	int i;
+
+	for (i = 0; i < ahd->scb_data.maxhscbs; i++) {
+		ahd_set_scbptr(ahd, i);
+
+		/* Clear the control byte. */
+		ahd_outb(ahd, SCB_CONTROL, 0);
+
+		/* Set the next pointer */
+		ahd_outw(ahd, SCB_NEXT, SCB_LIST_NULL);
+	}
+}
+
+static int
+ahd_init_scbdata(struct ahd_softc *ahd)
+{
+	struct	scb_data *scb_data;
+	int	i;
+
+	scb_data = &ahd->scb_data;
+	TAILQ_INIT(&scb_data->free_scbs);
+	for (i = 0; i < AHD_NUM_TARGETS * AHD_NUM_LUNS_NONPKT; i++)
+		LIST_INIT(&scb_data->free_scb_lists[i]);
+	LIST_INIT(&scb_data->any_dev_free_scb_list);
+	SLIST_INIT(&scb_data->hscb_maps);
+	SLIST_INIT(&scb_data->sg_maps);
+	SLIST_INIT(&scb_data->sense_maps);
+
+	/* Determine the number of hardware SCBs and initialize them */
+	scb_data->maxhscbs = ahd_probe_scbs(ahd);
+	if (scb_data->maxhscbs == 0) {
+		printf("%s: No SCB space found\n", ahd_name(ahd));
+		return (ENXIO);
+	}
+
+	ahd_initialize_hscbs(ahd);
+
+	/*
+	 * Create our DMA tags.  These tags define the kinds of device
+	 * accessible memory allocations and memory mappings we will
+	 * need to perform during normal operation.
+	 *
+	 * Unless we need to further restrict the allocation, we rely
+	 * on the restrictions of the parent dmat, hence the common
+	 * use of MAXADDR and MAXSIZE.
+	 */
+
+	/* DMA tag for our hardware scb structures */
+	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
+			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
+			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
+			       /*highaddr*/BUS_SPACE_MAXADDR,
+			       /*filter*/NULL, /*filterarg*/NULL,
+			       PAGE_SIZE, /*nsegments*/1,
+			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
+			       /*flags*/0, &scb_data->hscb_dmat) != 0) {
+		goto error_exit;
+	}
+
+	scb_data->init_level++;
+
+	/* DMA tag for our S/G structures. */
+	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/8,
+			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
+			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
+			       /*highaddr*/BUS_SPACE_MAXADDR,
+			       /*filter*/NULL, /*filterarg*/NULL,
+			       ahd_sglist_allocsize(ahd), /*nsegments*/1,
+			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
+			       /*flags*/0, &scb_data->sg_dmat) != 0) {
+		goto error_exit;
+	}
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_MEMORY) != 0)
+		printf("%s: ahd_sglist_allocsize = 0x%x\n", ahd_name(ahd),
+		       ahd_sglist_allocsize(ahd));
+#endif
+
+	scb_data->init_level++;
+
+	/* DMA tag for our sense buffers.  We allocate in page sized chunks */
+	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
+			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
+			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
+			       /*highaddr*/BUS_SPACE_MAXADDR,
+			       /*filter*/NULL, /*filterarg*/NULL,
+			       PAGE_SIZE, /*nsegments*/1,
+			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
+			       /*flags*/0, &scb_data->sense_dmat) != 0) {
+		goto error_exit;
+	}
+
+	scb_data->init_level++;
+
+	/* Perform initial CCB allocation */
+	ahd_alloc_scbs(ahd);
+
+	if (scb_data->numscbs == 0) {
+		printf("%s: ahd_init_scbdata - "
+		       "Unable to allocate initial scbs\n",
+		       ahd_name(ahd));
+		goto error_exit;
+	}
+
+	/*
+	 * Note that we were successfull
+	 */
+	return (0); 
+
+error_exit:
+
+	return (ENOMEM);
+}
+
+static struct scb *
+ahd_find_scb_by_tag(struct ahd_softc *ahd, u_int tag)
+{
+	struct scb *scb;
+
+	/*
+	 * Look on the pending list.
+	 */
+	LIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {
+		if (SCB_GET_TAG(scb) == tag)
+			return (scb);
+	}
+
+	/*
+	 * Then on all of the collision free lists.
+	 */
+	TAILQ_FOREACH(scb, &ahd->scb_data.free_scbs, links.tqe) {
+		struct scb *list_scb;
+
+		list_scb = scb;
+		do {
+			if (SCB_GET_TAG(list_scb) == tag)
+				return (list_scb);
+			list_scb = LIST_NEXT(list_scb, collision_links);
+		} while (list_scb);
+	}
+
+	/*
+	 * And finally on the generic free list.
+	 */
+	LIST_FOREACH(scb, &ahd->scb_data.any_dev_free_scb_list, links.le) {
+		if (SCB_GET_TAG(scb) == tag)
+			return (scb);
+	}
+
+	return (NULL);
+}
+
+static void
+ahd_fini_scbdata(struct ahd_softc *ahd)
+{
+	struct scb_data *scb_data;
+
+	scb_data = &ahd->scb_data;
+	if (scb_data == NULL)
+		return;
+
+	switch (scb_data->init_level) {
+	default:
+	case 7:
+	{
+		struct map_node *sns_map;
+
+		while ((sns_map = SLIST_FIRST(&scb_data->sense_maps)) != NULL) {
+			SLIST_REMOVE_HEAD(&scb_data->sense_maps, links);
+			ahd_dmamap_unload(ahd, scb_data->sense_dmat,
+					  sns_map->dmamap);
+			ahd_dmamem_free(ahd, scb_data->sense_dmat,
+					sns_map->vaddr, sns_map->dmamap);
+			free(sns_map, M_DEVBUF);
+		}
+		ahd_dma_tag_destroy(ahd, scb_data->sense_dmat);
+		/* FALLTHROUGH */
+	}
+	case 6:
+	{
+		struct map_node *sg_map;
+
+		while ((sg_map = SLIST_FIRST(&scb_data->sg_maps)) != NULL) {
+			SLIST_REMOVE_HEAD(&scb_data->sg_maps, links);
+			ahd_dmamap_unload(ahd, scb_data->sg_dmat,
+					  sg_map->dmamap);
+			ahd_dmamem_free(ahd, scb_data->sg_dmat,
+					sg_map->vaddr, sg_map->dmamap);
+			free(sg_map, M_DEVBUF);
+		}
+		ahd_dma_tag_destroy(ahd, scb_data->sg_dmat);
+		/* FALLTHROUGH */
+	}
+	case 5:
+	{
+		struct map_node *hscb_map;
+
+		while ((hscb_map = SLIST_FIRST(&scb_data->hscb_maps)) != NULL) {
+			SLIST_REMOVE_HEAD(&scb_data->hscb_maps, links);
+			ahd_dmamap_unload(ahd, scb_data->hscb_dmat,
+					  hscb_map->dmamap);
+			ahd_dmamem_free(ahd, scb_data->hscb_dmat,
+					hscb_map->vaddr, hscb_map->dmamap);
+			free(hscb_map, M_DEVBUF);
+		}
+		ahd_dma_tag_destroy(ahd, scb_data->hscb_dmat);
+		/* FALLTHROUGH */
+	}
+	case 4:
+	case 3:
+	case 2:
+	case 1:
+	case 0:
+		break;
+	}
+}
+
+/*
+ * DSP filter Bypass must be enabled until the first selection
+ * after a change in bus mode (Razor #491 and #493).
+ */
+static void
+ahd_setup_iocell_workaround(struct ahd_softc *ahd)
+{
+	ahd_mode_state saved_modes;
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+	ahd_outb(ahd, DSPDATACTL, ahd_inb(ahd, DSPDATACTL)
+	       | BYPASSENAB | RCVROFFSTDIS | XMITOFFSTDIS);
+	ahd_outb(ahd, SIMODE0, ahd_inb(ahd, SIMODE0) | (ENSELDO|ENSELDI));
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_MISC) != 0)
+		printf("%s: Setting up iocell workaround\n", ahd_name(ahd));
+#endif
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+static void
+ahd_iocell_first_selection(struct ahd_softc *ahd)
+{
+	ahd_mode_state	saved_modes;
+	u_int		sblkctl;
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	sblkctl = ahd_inb(ahd, SBLKCTL);
+	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_MISC) != 0)
+		printf("%s: iocell first selection\n", ahd_name(ahd));
+#endif
+	if ((sblkctl & ENAB40) != 0) {
+		ahd_outb(ahd, DSPDATACTL,
+			 ahd_inb(ahd, DSPDATACTL) & ~BYPASSENAB);
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MISC) != 0)
+			printf("%s: BYPASS now disabled\n", ahd_name(ahd));
+#endif
+	}
+	ahd_outb(ahd, SIMODE0, ahd_inb(ahd, SIMODE0) & ~(ENSELDO|ENSELDI));
+	ahd_outb(ahd, CLRINT, CLRSCSIINT);
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+/*************************** SCB Management ***********************************/
+static void
+ahd_add_col_list(struct ahd_softc *ahd, struct scb *scb, u_int col_idx)
+{
+	struct	scb_list *free_list;
+	struct	scb_tailq *free_tailq;
+	struct	scb *first_scb;
+
+	scb->flags |= SCB_ON_COL_LIST;
+	AHD_SET_SCB_COL_IDX(scb, col_idx);
+	free_list = &ahd->scb_data.free_scb_lists[col_idx];
+	free_tailq = &ahd->scb_data.free_scbs;
+	first_scb = LIST_FIRST(free_list);
+	if (first_scb != NULL) {
+		LIST_INSERT_AFTER(first_scb, scb, collision_links);
+	} else {
+		LIST_INSERT_HEAD(free_list, scb, collision_links);
+		TAILQ_INSERT_TAIL(free_tailq, scb, links.tqe);
+	}
+}
+
+static void
+ahd_rem_col_list(struct ahd_softc *ahd, struct scb *scb)
+{
+	struct	scb_list *free_list;
+	struct	scb_tailq *free_tailq;
+	struct	scb *first_scb;
+	u_int	col_idx;
+
+	scb->flags &= ~SCB_ON_COL_LIST;
+	col_idx = AHD_GET_SCB_COL_IDX(ahd, scb);
+	free_list = &ahd->scb_data.free_scb_lists[col_idx];
+	free_tailq = &ahd->scb_data.free_scbs;
+	first_scb = LIST_FIRST(free_list);
+	if (first_scb == scb) {
+		struct scb *next_scb;
+
+		/*
+		 * Maintain order in the collision free
+		 * lists for fairness if this device has
+		 * other colliding tags active.
+		 */
+		next_scb = LIST_NEXT(scb, collision_links);
+		if (next_scb != NULL) {
+			TAILQ_INSERT_AFTER(free_tailq, scb,
+					   next_scb, links.tqe);
+		}
+		TAILQ_REMOVE(free_tailq, scb, links.tqe);
+	}
+	LIST_REMOVE(scb, collision_links);
+}
+
+/*
+ * Get a free scb. If there are none, see if we can allocate a new SCB.
+ */
+struct scb *
+ahd_get_scb(struct ahd_softc *ahd, u_int col_idx)
+{
+	struct scb *scb;
+	int tries;
+
+	tries = 0;
+look_again:
+	TAILQ_FOREACH(scb, &ahd->scb_data.free_scbs, links.tqe) {
+		if (AHD_GET_SCB_COL_IDX(ahd, scb) != col_idx) {
+			ahd_rem_col_list(ahd, scb);
+			goto found;
+		}
+	}
+	if ((scb = LIST_FIRST(&ahd->scb_data.any_dev_free_scb_list)) == NULL) {
+
+		if (tries++ != 0)
+			return (NULL);
+		ahd_alloc_scbs(ahd);
+		goto look_again;
+	}
+	LIST_REMOVE(scb, links.le);
+	if (col_idx != AHD_NEVER_COL_IDX
+	 && (scb->col_scb != NULL)
+	 && (scb->col_scb->flags & SCB_ACTIVE) == 0) {
+		LIST_REMOVE(scb->col_scb, links.le);
+		ahd_add_col_list(ahd, scb->col_scb, col_idx);
+	}
+found:
+	scb->flags |= SCB_ACTIVE;
+	return (scb);
+}
+
+/*
+ * Return an SCB resource to the free list.
+ */
+void
+ahd_free_scb(struct ahd_softc *ahd, struct scb *scb)
+{       
+
+	/* Clean up for the next user */
+	scb->flags = SCB_FLAG_NONE;
+	scb->hscb->control = 0;
+	ahd->scb_data.scbindex[SCB_GET_TAG(scb)] = NULL;
+
+	if (scb->col_scb == NULL) {
+
+		/*
+		 * No collision possible.  Just free normally.
+		 */
+		LIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,
+				 scb, links.le);
+	} else if ((scb->col_scb->flags & SCB_ON_COL_LIST) != 0) {
+
+		/*
+		 * The SCB we might have collided with is on
+		 * a free collision list.  Put both SCBs on
+		 * the generic list.
+		 */
+		ahd_rem_col_list(ahd, scb->col_scb);
+		LIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,
+				 scb, links.le);
+		LIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,
+				 scb->col_scb, links.le);
+	} else if ((scb->col_scb->flags
+		  & (SCB_PACKETIZED|SCB_ACTIVE)) == SCB_ACTIVE
+		&& (scb->col_scb->hscb->control & TAG_ENB) != 0) {
+
+		/*
+		 * The SCB we might collide with on the next allocation
+		 * is still active in a non-packetized, tagged, context.
+		 * Put us on the SCB collision list.
+		 */
+		ahd_add_col_list(ahd, scb,
+				 AHD_GET_SCB_COL_IDX(ahd, scb->col_scb));
+	} else {
+		/*
+		 * The SCB we might collide with on the next allocation
+		 * is either active in a packetized context, or free.
+		 * Since we can't collide, put this SCB on the generic
+		 * free list.
+		 */
+		LIST_INSERT_HEAD(&ahd->scb_data.any_dev_free_scb_list,
+				 scb, links.le);
+	}
+
+	ahd_platform_scb_free(ahd, scb);
+}
+
+void
+ahd_alloc_scbs(struct ahd_softc *ahd)
+{
+	struct scb_data *scb_data;
+	struct scb	*next_scb;
+	struct hardware_scb *hscb;
+	struct map_node *hscb_map;
+	struct map_node *sg_map;
+	struct map_node *sense_map;
+	uint8_t		*segs;
+	uint8_t		*sense_data;
+	bus_addr_t	 hscb_busaddr;
+	bus_addr_t	 sg_busaddr;
+	bus_addr_t	 sense_busaddr;
+	int		 newcount;
+	int		 i;
+
+	scb_data = &ahd->scb_data;
+	if (scb_data->numscbs >= AHD_SCB_MAX_ALLOC)
+		/* Can't allocate any more */
+		return;
+
+	if (scb_data->scbs_left != 0) {
+		int offset;
+
+		offset = (PAGE_SIZE / sizeof(*hscb)) - scb_data->scbs_left;
+		hscb_map = SLIST_FIRST(&scb_data->hscb_maps);
+		hscb = &((struct hardware_scb *)hscb_map->vaddr)[offset];
+		hscb_busaddr = hscb_map->physaddr + (offset * sizeof(*hscb));
+	} else {
+		hscb_map = malloc(sizeof(*hscb_map), M_DEVBUF, M_NOWAIT);
+
+		if (hscb_map == NULL)
+			return;
+
+		/* Allocate the next batch of hardware SCBs */
+		if (ahd_dmamem_alloc(ahd, scb_data->hscb_dmat,
+				     (void **)&hscb_map->vaddr,
+				     BUS_DMA_NOWAIT, &hscb_map->dmamap) != 0) {
+			free(hscb_map, M_DEVBUF);
+			return;
+		}
+
+		SLIST_INSERT_HEAD(&scb_data->hscb_maps, hscb_map, links);
+
+		ahd_dmamap_load(ahd, scb_data->hscb_dmat, hscb_map->dmamap,
+				hscb_map->vaddr, PAGE_SIZE, ahd_dmamap_cb,
+				&hscb_map->physaddr, /*flags*/0);
+
+		hscb = (struct hardware_scb *)hscb_map->vaddr;
+		hscb_busaddr = hscb_map->physaddr;
+		scb_data->scbs_left = PAGE_SIZE / sizeof(*hscb);
+	}
+
+	if (scb_data->sgs_left != 0) {
+		int offset;
+
+		offset = ((ahd_sglist_allocsize(ahd) / ahd_sglist_size(ahd))
+		       - scb_data->sgs_left) * ahd_sglist_size(ahd);
+		sg_map = SLIST_FIRST(&scb_data->sg_maps);
+		segs = sg_map->vaddr + offset;
+		sg_busaddr = sg_map->physaddr + offset;
+	} else {
+		sg_map = malloc(sizeof(*sg_map), M_DEVBUF, M_NOWAIT);
+
+		if (sg_map == NULL)
+			return;
+
+		/* Allocate the next batch of S/G lists */
+		if (ahd_dmamem_alloc(ahd, scb_data->sg_dmat,
+				     (void **)&sg_map->vaddr,
+				     BUS_DMA_NOWAIT, &sg_map->dmamap) != 0) {
+			free(sg_map, M_DEVBUF);
+			return;
+		}
+
+		SLIST_INSERT_HEAD(&scb_data->sg_maps, sg_map, links);
+
+		ahd_dmamap_load(ahd, scb_data->sg_dmat, sg_map->dmamap,
+				sg_map->vaddr, ahd_sglist_allocsize(ahd),
+				ahd_dmamap_cb, &sg_map->physaddr, /*flags*/0);
+
+		segs = sg_map->vaddr;
+		sg_busaddr = sg_map->physaddr;
+		scb_data->sgs_left =
+		    ahd_sglist_allocsize(ahd) / ahd_sglist_size(ahd);
+#ifdef AHD_DEBUG
+		if (ahd_debug & AHD_SHOW_MEMORY)
+			printf("Mapped SG data\n");
+#endif
+	}
+
+	if (scb_data->sense_left != 0) {
+		int offset;
+
+		offset = PAGE_SIZE - (AHD_SENSE_BUFSIZE * scb_data->sense_left);
+		sense_map = SLIST_FIRST(&scb_data->sense_maps);
+		sense_data = sense_map->vaddr + offset;
+		sense_busaddr = sense_map->physaddr + offset;
+	} else {
+		sense_map = malloc(sizeof(*sense_map), M_DEVBUF, M_NOWAIT);
+
+		if (sense_map == NULL)
+			return;
+
+		/* Allocate the next batch of sense buffers */
+		if (ahd_dmamem_alloc(ahd, scb_data->sense_dmat,
+				     (void **)&sense_map->vaddr,
+				     BUS_DMA_NOWAIT, &sense_map->dmamap) != 0) {
+			free(sense_map, M_DEVBUF);
+			return;
+		}
+
+		SLIST_INSERT_HEAD(&scb_data->sense_maps, sense_map, links);
+
+		ahd_dmamap_load(ahd, scb_data->sense_dmat, sense_map->dmamap,
+				sense_map->vaddr, PAGE_SIZE, ahd_dmamap_cb,
+				&sense_map->physaddr, /*flags*/0);
+
+		sense_data = sense_map->vaddr;
+		sense_busaddr = sense_map->physaddr;
+		scb_data->sense_left = PAGE_SIZE / AHD_SENSE_BUFSIZE;
+#ifdef AHD_DEBUG
+		if (ahd_debug & AHD_SHOW_MEMORY)
+			printf("Mapped sense data\n");
+#endif
+	}
+
+	newcount = MIN(scb_data->sense_left, scb_data->scbs_left);
+	newcount = MIN(newcount, scb_data->sgs_left);
+	newcount = MIN(newcount, (AHD_SCB_MAX_ALLOC - scb_data->numscbs));
+	scb_data->sense_left -= newcount;
+	scb_data->scbs_left -= newcount;
+	scb_data->sgs_left -= newcount;
+	for (i = 0; i < newcount; i++) {
+		u_int col_tag;
+
+		struct scb_platform_data *pdata;
+#ifndef __linux__
+		int error;
+#endif
+		next_scb = (struct scb *)malloc(sizeof(*next_scb),
+						M_DEVBUF, M_NOWAIT);
+		if (next_scb == NULL)
+			break;
+
+		pdata = (struct scb_platform_data *)malloc(sizeof(*pdata),
+							   M_DEVBUF, M_NOWAIT);
+		if (pdata == NULL) {
+			free(next_scb, M_DEVBUF);
+			break;
+		}
+		next_scb->platform_data = pdata;
+		next_scb->hscb_map = hscb_map;
+		next_scb->sg_map = sg_map;
+		next_scb->sense_map = sense_map;
+		next_scb->sg_list = segs;
+		next_scb->sense_data = sense_data;
+		next_scb->sense_busaddr = sense_busaddr;
+		memset(hscb, 0, sizeof(*hscb));
+		next_scb->hscb = hscb;
+		hscb->hscb_busaddr = ahd_htole32(hscb_busaddr);
+
+		/*
+		 * The sequencer always starts with the second entry.
+		 * The first entry is embedded in the scb.
+		 */
+		next_scb->sg_list_busaddr = sg_busaddr;
+		if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)
+			next_scb->sg_list_busaddr
+			    += sizeof(struct ahd_dma64_seg);
+		else
+			next_scb->sg_list_busaddr += sizeof(struct ahd_dma_seg);
+		next_scb->ahd_softc = ahd;
+		next_scb->flags = SCB_FLAG_NONE;
+#ifndef __linux__
+		error = ahd_dmamap_create(ahd, ahd->buffer_dmat, /*flags*/0,
+					  &next_scb->dmamap);
+		if (error != 0) {
+			free(next_scb, M_DEVBUF);
+			free(pdata, M_DEVBUF);
+			break;
+		}
+#endif
+		next_scb->hscb->tag = ahd_htole16(scb_data->numscbs);
+		col_tag = scb_data->numscbs ^ 0x100;
+		next_scb->col_scb = ahd_find_scb_by_tag(ahd, col_tag);
+		if (next_scb->col_scb != NULL)
+			next_scb->col_scb->col_scb = next_scb;
+		ahd_free_scb(ahd, next_scb);
+		hscb++;
+		hscb_busaddr += sizeof(*hscb);
+		segs += ahd_sglist_size(ahd);
+		sg_busaddr += ahd_sglist_size(ahd);
+		sense_data += AHD_SENSE_BUFSIZE;
+		sense_busaddr += AHD_SENSE_BUFSIZE;
+		scb_data->numscbs++;
+	}
+}
+
+void
+ahd_controller_info(struct ahd_softc *ahd, char *buf)
+{
+	const char *speed;
+	const char *type;
+	int len;
+
+	len = sprintf(buf, "%s: ", ahd_chip_names[ahd->chip & AHD_CHIPID_MASK]);
+	buf += len;
+
+	speed = "Ultra320 ";
+	if ((ahd->features & AHD_WIDE) != 0) {
+		type = "Wide ";
+	} else {
+		type = "Single ";
+	}
+	len = sprintf(buf, "%s%sChannel %c, SCSI Id=%d, ",
+		      speed, type, ahd->channel, ahd->our_id);
+	buf += len;
+
+	sprintf(buf, "%s, %d SCBs", ahd->bus_description,
+		ahd->scb_data.maxhscbs);
+}
+
+static const char *channel_strings[] = {
+	"Primary Low",
+	"Primary High",
+	"Secondary Low", 
+	"Secondary High"
+};
+
+static const char *termstat_strings[] = {
+	"Terminated Correctly",
+	"Over Terminated",
+	"Under Terminated",
+	"Not Configured"
+};
+
+/*
+ * Start the board, ready for normal operation
+ */
+int
+ahd_init(struct ahd_softc *ahd)
+{
+	uint8_t		*base_vaddr;
+	uint8_t		*next_vaddr;
+	bus_addr_t	 next_baddr;
+	size_t		 driver_data_size;
+	int		 i;
+	int		 error;
+	u_int		 warn_user;
+	uint8_t		 current_sensing;
+	uint8_t		 fstat;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+
+	ahd->stack_size = ahd_probe_stack_size(ahd);
+	ahd->saved_stack = malloc(ahd->stack_size * sizeof(uint16_t),
+				  M_DEVBUF, M_NOWAIT);
+	if (ahd->saved_stack == NULL)
+		return (ENOMEM);
+
+	/*
+	 * Verify that the compiler hasn't over-agressively
+	 * padded important structures.
+	 */
+	if (sizeof(struct hardware_scb) != 64)
+		panic("Hardware SCB size is incorrect");
+
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_DEBUG_SEQUENCER) != 0)
+		ahd->flags |= AHD_SEQUENCER_DEBUG;
+#endif
+
+	/*
+	 * Default to allowing initiator operations.
+	 */
+	ahd->flags |= AHD_INITIATORROLE;
+
+	/*
+	 * Only allow target mode features if this unit has them enabled.
+	 */
+	if ((AHD_TMODE_ENABLE & (0x1 << ahd->unit)) == 0)
+		ahd->features &= ~AHD_TARGETMODE;
+
+#ifndef __linux__
+	/* DMA tag for mapping buffers into device visible space. */
+	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
+			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
+			       /*lowaddr*/ahd->flags & AHD_39BIT_ADDRESSING
+					? (bus_addr_t)0x7FFFFFFFFFULL
+					: BUS_SPACE_MAXADDR_32BIT,
+			       /*highaddr*/BUS_SPACE_MAXADDR,
+			       /*filter*/NULL, /*filterarg*/NULL,
+			       /*maxsize*/(AHD_NSEG - 1) * PAGE_SIZE,
+			       /*nsegments*/AHD_NSEG,
+			       /*maxsegsz*/AHD_MAXTRANSFER_SIZE,
+			       /*flags*/BUS_DMA_ALLOCNOW,
+			       &ahd->buffer_dmat) != 0) {
+		return (ENOMEM);
+	}
+#endif
+
+	ahd->init_level++;
+
+	/*
+	 * DMA tag for our command fifos and other data in system memory
+	 * the card's sequencer must be able to access.  For initiator
+	 * roles, we need to allocate space for the qoutfifo.  When providing
+	 * for the target mode role, we must additionally provide space for
+	 * the incoming target command fifo.
+	 */
+	driver_data_size = AHD_SCB_MAX * sizeof(uint16_t)
+			 + sizeof(struct hardware_scb);
+	if ((ahd->features & AHD_TARGETMODE) != 0)
+		driver_data_size += AHD_TMODE_CMDS * sizeof(struct target_cmd);
+	if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0)
+		driver_data_size += PKT_OVERRUN_BUFSIZE;
+	if (ahd_dma_tag_create(ahd, ahd->parent_dmat, /*alignment*/1,
+			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
+			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
+			       /*highaddr*/BUS_SPACE_MAXADDR,
+			       /*filter*/NULL, /*filterarg*/NULL,
+			       driver_data_size,
+			       /*nsegments*/1,
+			       /*maxsegsz*/BUS_SPACE_MAXSIZE_32BIT,
+			       /*flags*/0, &ahd->shared_data_dmat) != 0) {
+		return (ENOMEM);
+	}
+
+	ahd->init_level++;
+
+	/* Allocation of driver data */
+	if (ahd_dmamem_alloc(ahd, ahd->shared_data_dmat,
+			     (void **)&base_vaddr,
+			     BUS_DMA_NOWAIT, &ahd->shared_data_dmamap) != 0) {
+		return (ENOMEM);
+	}
+
+	ahd->init_level++;
+
+	/* And permanently map it in */
+	ahd_dmamap_load(ahd, ahd->shared_data_dmat, ahd->shared_data_dmamap,
+			base_vaddr, driver_data_size, ahd_dmamap_cb,
+			&ahd->shared_data_busaddr, /*flags*/0);
+	ahd->qoutfifo = (uint16_t *)base_vaddr;
+	next_vaddr = (uint8_t *)&ahd->qoutfifo[AHD_QOUT_SIZE];
+	next_baddr = ahd->shared_data_busaddr + AHD_QOUT_SIZE*sizeof(uint16_t);
+	if ((ahd->features & AHD_TARGETMODE) != 0) {
+		ahd->targetcmds = (struct target_cmd *)next_vaddr;
+		next_vaddr += AHD_TMODE_CMDS * sizeof(struct target_cmd);
+		next_baddr += AHD_TMODE_CMDS * sizeof(struct target_cmd);
+	}
+
+	if ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0) {
+		ahd->overrun_buf = next_vaddr;
+		next_vaddr += PKT_OVERRUN_BUFSIZE;
+		next_baddr += PKT_OVERRUN_BUFSIZE;
+	}
+
+	/*
+	 * We need one SCB to serve as the "next SCB".  Since the
+	 * tag identifier in this SCB will never be used, there is
+	 * no point in using a valid HSCB tag from an SCB pulled from
+	 * the standard free pool.  So, we allocate this "sentinel"
+	 * specially from the DMA safe memory chunk used for the QOUTFIFO.
+	 */
+	ahd->next_queued_hscb = (struct hardware_scb *)next_vaddr;
+	ahd->next_queued_hscb->hscb_busaddr = ahd_htole32(next_baddr);
+
+	ahd->init_level++;
+
+	/* Allocate SCB data now that buffer_dmat is initialized */
+	if (ahd_init_scbdata(ahd) != 0)
+		return (ENOMEM);
+
+	if ((ahd->flags & AHD_INITIATORROLE) == 0)
+		ahd->flags &= ~AHD_RESET_BUS_A;
+
+	/*
+	 * Before committing these settings to the chip, give
+	 * the OSM one last chance to modify our configuration.
+	 */
+	ahd_platform_init(ahd);
+
+	/* Bring up the chip. */
+	ahd_chip_init(ahd);
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+
+	if ((ahd->flags & AHD_CURRENT_SENSING) == 0)
+		goto init_done;
+
+	/*
+	 * Verify termination based on current draw and
+	 * warn user if the bus is over/under terminated.
+	 */
+	error = ahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL,
+				   CURSENSE_ENB);
+	if (error != 0) {
+		printf("%s: current sensing timeout 1\n", ahd_name(ahd));
+		goto init_done;
+	}
+	for (i = 20, fstat = FLX_FSTAT_BUSY;
+	     (fstat & FLX_FSTAT_BUSY) != 0 && i; i--) {
+		error = ahd_read_flexport(ahd, FLXADDR_FLEXSTAT, &fstat);
+		if (error != 0) {
+			printf("%s: current sensing timeout 2\n",
+			       ahd_name(ahd));
+			goto init_done;
+		}
+	}
+	if (i == 0) {
+		printf("%s: Timedout during current-sensing test\n",
+		       ahd_name(ahd));
+		goto init_done;
+	}
+
+	/* Latch Current Sensing status. */
+	error = ahd_read_flexport(ahd, FLXADDR_CURRENT_STAT, &current_sensing);
+	if (error != 0) {
+		printf("%s: current sensing timeout 3\n", ahd_name(ahd));
+		goto init_done;
+	}
+
+	/* Diable current sensing. */
+	ahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, 0);
+
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_TERMCTL) != 0) {
+		printf("%s: current_sensing == 0x%x\n",
+		       ahd_name(ahd), current_sensing);
+	}
+#endif
+	warn_user = 0;
+	for (i = 0; i < 4; i++, current_sensing >>= FLX_CSTAT_SHIFT) {
+		u_int term_stat;
+
+		term_stat = (current_sensing & FLX_CSTAT_MASK);
+		switch (term_stat) {
+		case FLX_CSTAT_OVER:
+		case FLX_CSTAT_UNDER:
+			warn_user++;
+		case FLX_CSTAT_INVALID:
+		case FLX_CSTAT_OKAY:
+			if (warn_user == 0 && bootverbose == 0)
+				break;
+			printf("%s: %s Channel %s\n", ahd_name(ahd),
+			       channel_strings[i], termstat_strings[term_stat]);
+			break;
+		}
+	}
+	if (warn_user) {
+		printf("%s: WARNING. Termination is not configured correctly.\n"
+		       "%s: WARNING. SCSI bus operations may FAIL.\n",
+		       ahd_name(ahd), ahd_name(ahd));
+	}
+init_done:
+	ahd_restart(ahd);
+	ahd_timer_reset(&ahd->stat_timer, AHD_STAT_UPDATE_US,
+			ahd_stat_timer, ahd);
+	return (0);
+}
+
+/*
+ * (Re)initialize chip state after a chip reset.
+ */
+static void
+ahd_chip_init(struct ahd_softc *ahd)
+{
+	uint32_t busaddr;
+	u_int	 sxfrctl1;
+	u_int	 scsiseq_template;
+	u_int	 wait;
+	u_int	 i;
+	u_int	 target;
+
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	/*
+	 * Take the LED out of diagnostic mode
+	 */
+	ahd_outb(ahd, SBLKCTL, ahd_inb(ahd, SBLKCTL) & ~(DIAGLEDEN|DIAGLEDON));
+
+	/*
+	 * Return HS_MAILBOX to its default value.
+	 */
+	ahd->hs_mailbox = 0;
+	ahd_outb(ahd, HS_MAILBOX, 0);
+
+	/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1. */
+	ahd_outb(ahd, IOWNID, ahd->our_id);
+	ahd_outb(ahd, TOWNID, ahd->our_id);
+	sxfrctl1 = (ahd->flags & AHD_TERM_ENB_A) != 0 ? STPWEN : 0;
+	sxfrctl1 |= (ahd->flags & AHD_SPCHK_ENB_A) != 0 ? ENSPCHK : 0;
+	if ((ahd->bugs & AHD_LONG_SETIMO_BUG)
+	 && (ahd->seltime != STIMESEL_MIN)) {
+		/*
+		 * The selection timer duration is twice as long
+		 * as it should be.  Halve it by adding "1" to
+		 * the user specified setting.
+		 */
+		sxfrctl1 |= ahd->seltime + STIMESEL_BUG_ADJ;
+	} else {
+		sxfrctl1 |= ahd->seltime;
+	}
+		
+	ahd_outb(ahd, SXFRCTL0, DFON);
+	ahd_outb(ahd, SXFRCTL1, sxfrctl1|ahd->seltime|ENSTIMER|ACTNEGEN);
+	ahd_outb(ahd, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);
+
+	/*
+	 * Now that termination is set, wait for up
+	 * to 500ms for our transceivers to settle.  If
+	 * the adapter does not have a cable attached,
+	 * the transceivers may never settle, so don't
+	 * complain if we fail here.
+	 */
+	for (wait = 10000;
+	     (ahd_inb(ahd, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;
+	     wait--)
+		ahd_delay(100);
+
+	/* Clear any false bus resets due to the transceivers settling */
+	ahd_outb(ahd, CLRSINT1, CLRSCSIRSTI);
+	ahd_outb(ahd, CLRINT, CLRSCSIINT);
+
+	/* Initialize mode specific S/G state. */
+	for (i = 0; i < 2; i++) {
+		ahd_set_modes(ahd, AHD_MODE_DFF0 + i, AHD_MODE_DFF0 + i);
+		ahd_outb(ahd, LONGJMP_ADDR + 1, INVALID_ADDR);
+		ahd_outb(ahd, SG_STATE, 0);
+		ahd_outb(ahd, CLRSEQINTSRC, 0xFF);
+		ahd_outb(ahd, SEQIMODE,
+			 ENSAVEPTRS|ENCFG4DATA|ENCFG4ISTAT
+			|ENCFG4TSTAT|ENCFG4ICMD|ENCFG4TCMD);
+	}
+
+	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+	ahd_outb(ahd, DSCOMMAND0, ahd_inb(ahd, DSCOMMAND0)|MPARCKEN|CACHETHEN);
+	ahd_outb(ahd, DFF_THRSH, RD_DFTHRSH_75|WR_DFTHRSH_75);
+	ahd_outb(ahd, SIMODE0, ENIOERR|ENOVERRUN);
+	ahd_outb(ahd, SIMODE3, ENNTRAMPERR|ENOSRAMPERR);
+	if ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0) {
+		ahd_outb(ahd, OPTIONMODE, AUTOACKEN|AUTO_MSGOUT_DE);
+	} else {
+		ahd_outb(ahd, OPTIONMODE, AUTOACKEN|BUSFREEREV|AUTO_MSGOUT_DE);
+	}
+	ahd_outb(ahd, SCSCHKN, CURRFIFODEF|WIDERESEN|SHVALIDSTDIS);
+	if ((ahd->chip & AHD_BUS_MASK) == AHD_PCIX)
+		/*
+		 * Do not issue a target abort when a split completion
+		 * error occurs.  Let our PCIX interrupt handler deal
+		 * with it instead. H2A4 Razor #625
+		 */
+		ahd_outb(ahd, PCIXCTL, ahd_inb(ahd, PCIXCTL) | SPLTSTADIS);
+
+	if ((ahd->bugs & AHD_LQOOVERRUN_BUG) != 0)
+		ahd_outb(ahd, LQOSCSCTL, LQONOCHKOVER);
+
+	/*
+	 * Tweak IOCELL settings.
+	 */
+	if ((ahd->flags & AHD_HP_BOARD) != 0) {
+		for (i = 0; i < NUMDSPS; i++) {
+			ahd_outb(ahd, DSPSELECT, i);
+			ahd_outb(ahd, WRTBIASCTL, WRTBIASCTL_HP_DEFAULT);
+		}
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MISC) != 0)
+			printf("%s: WRTBIASCTL now 0x%x\n", ahd_name(ahd),
+			       WRTBIASCTL_HP_DEFAULT);
+#endif
+	}
+	ahd_setup_iocell_workaround(ahd);
+
+	/*
+	 * Enable LQI Manager interrupts.
+	 */
+	ahd_outb(ahd, LQIMODE1, ENLQIPHASE_LQ|ENLQIPHASE_NLQ|ENLIQABORT
+			      | ENLQICRCI_LQ|ENLQICRCI_NLQ|ENLQIBADLQI
+			      | ENLQIOVERI_LQ|ENLQIOVERI_NLQ);
+	ahd_outb(ahd, LQOMODE0, ENLQOATNLQ|ENLQOATNPKT|ENLQOTCRC);
+	/*
+	 * An interrupt from LQOBUSFREE is made redundant by the
+	 * BUSFREE interrupt.  We choose to have the sequencer catch
+	 * LQOPHCHGINPKT errors manually for the command phase at the
+	 * start of a packetized selection case.
+	ahd_outb(ahd, LQOMODE1, ENLQOBUSFREE|ENLQOPHACHGINPKT);
+	 */
+	ahd_outb(ahd, LQOMODE1, 0);
+
+	/*
+	 * Setup sequencer interrupt handlers.
+	 */
+	ahd_outw(ahd, INTVEC1_ADDR, ahd_resolve_seqaddr(ahd, LABEL_seq_isr));
+	ahd_outw(ahd, INTVEC2_ADDR, ahd_resolve_seqaddr(ahd, LABEL_timer_isr));
+
+	/*
+	 * Setup SCB Offset registers.
+	 */
+	if ((ahd->bugs & AHD_PKT_LUN_BUG) != 0) {
+		ahd_outb(ahd, LUNPTR, offsetof(struct hardware_scb,
+			 pkt_long_lun));
+	} else {
+		ahd_outb(ahd, LUNPTR, offsetof(struct hardware_scb, lun));
+	}
+	ahd_outb(ahd, CMDLENPTR, offsetof(struct hardware_scb, cdb_len));
+	ahd_outb(ahd, ATTRPTR, offsetof(struct hardware_scb, task_attribute));
+	ahd_outb(ahd, FLAGPTR, offsetof(struct hardware_scb, task_management));
+	ahd_outb(ahd, CMDPTR, offsetof(struct hardware_scb,
+				       shared_data.idata.cdb));
+	ahd_outb(ahd, QNEXTPTR,
+		 offsetof(struct hardware_scb, next_hscb_busaddr));
+	ahd_outb(ahd, ABRTBITPTR, MK_MESSAGE_BIT_OFFSET);
+	ahd_outb(ahd, ABRTBYTEPTR, offsetof(struct hardware_scb, control));
+	if ((ahd->bugs & AHD_PKT_LUN_BUG) != 0) {
+		ahd_outb(ahd, LUNLEN,
+			 sizeof(ahd->next_queued_hscb->pkt_long_lun) - 1);
+	} else {
+		ahd_outb(ahd, LUNLEN, LUNLEN_SINGLE_LEVEL_LUN);
+	}
+	ahd_outb(ahd, CDBLIMIT, SCB_CDB_LEN_PTR - 1);
+	ahd_outb(ahd, MAXCMD, 0xFF);
+	ahd_outb(ahd, SCBAUTOPTR,
+		 AUSCBPTR_EN | offsetof(struct hardware_scb, tag));
+
+	/* We haven't been enabled for target mode yet. */
+	ahd_outb(ahd, MULTARGID, 0);
+	ahd_outb(ahd, MULTARGID + 1, 0);
+
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	/* Initialize the negotiation table. */
+	if ((ahd->features & AHD_NEW_IOCELL_OPTS) == 0) {
+		/*
+		 * Clear the spare bytes in the neg table to avoid
+		 * spurious parity errors.
+		 */
+		for (target = 0; target < AHD_NUM_TARGETS; target++) {
+			ahd_outb(ahd, NEGOADDR, target);
+			ahd_outb(ahd, ANNEXCOL, AHD_ANNEXCOL_PER_DEV0);
+			for (i = 0; i < AHD_NUM_PER_DEV_ANNEXCOLS; i++)
+				ahd_outb(ahd, ANNEXDAT, 0);
+		}
+	}
+	for (target = 0; target < AHD_NUM_TARGETS; target++) {
+		struct	 ahd_devinfo devinfo;
+		struct	 ahd_initiator_tinfo *tinfo;
+		struct	 ahd_tmode_tstate *tstate;
+
+		tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
+					    target, &tstate);
+		ahd_compile_devinfo(&devinfo, ahd->our_id,
+				    target, CAM_LUN_WILDCARD,
+				    'A', ROLE_INITIATOR);
+		ahd_update_neg_table(ahd, &devinfo, &tinfo->curr);
+	}
+
+	ahd_outb(ahd, CLRSINT3, NTRAMPERR|OSRAMPERR);
+	ahd_outb(ahd, CLRINT, CLRSCSIINT);
+
+	/*
+	 * Always enable abort on incoming L_Qs if this feature is
+	 * supported.  We use this to catch invalid SCB references.
+	 */
+	if ((ahd->bugs & AHD_ABORT_LQI_BUG) == 0)
+		ahd_outb(ahd, LQCTL1, ABORTPENDING);
+	else
+		ahd_outb(ahd, LQCTL1, 0);
+
+	/* All of our queues are empty */
+	ahd->qoutfifonext = 0;
+	ahd->qoutfifonext_valid_tag = QOUTFIFO_ENTRY_VALID_LE;
+	ahd_outb(ahd, QOUTFIFO_ENTRY_VALID_TAG, QOUTFIFO_ENTRY_VALID >> 8);
+	for (i = 0; i < AHD_QOUT_SIZE; i++)
+		ahd->qoutfifo[i] = 0;
+	ahd_sync_qoutfifo(ahd, BUS_DMASYNC_PREREAD);
+
+	ahd->qinfifonext = 0;
+	for (i = 0; i < AHD_QIN_SIZE; i++)
+		ahd->qinfifo[i] = SCB_LIST_NULL;
+
+	if ((ahd->features & AHD_TARGETMODE) != 0) {
+		/* All target command blocks start out invalid. */
+		for (i = 0; i < AHD_TMODE_CMDS; i++)
+			ahd->targetcmds[i].cmd_valid = 0;
+		ahd_sync_tqinfifo(ahd, BUS_DMASYNC_PREREAD);
+		ahd->tqinfifonext = 1;
+		ahd_outb(ahd, KERNEL_TQINPOS, ahd->tqinfifonext - 1);
+		ahd_outb(ahd, TQINPOS, ahd->tqinfifonext);
+	}
+
+	/* Initialize Scratch Ram. */
+	ahd_outb(ahd, SEQ_FLAGS, 0);
+	ahd_outb(ahd, SEQ_FLAGS2, 0);
+
+	/* We don't have any waiting selections */
+	ahd_outw(ahd, WAITING_TID_HEAD, SCB_LIST_NULL);
+	ahd_outw(ahd, WAITING_TID_TAIL, SCB_LIST_NULL);
+	for (i = 0; i < AHD_NUM_TARGETS; i++)
+		ahd_outw(ahd, WAITING_SCB_TAILS + (2 * i), SCB_LIST_NULL);
+
+	/*
+	 * Nobody is waiting to be DMAed into the QOUTFIFO.
+	 */
+	ahd_outw(ahd, COMPLETE_SCB_HEAD, SCB_LIST_NULL);
+	ahd_outw(ahd, COMPLETE_SCB_DMAINPROG_HEAD, SCB_LIST_NULL);
+	ahd_outw(ahd, COMPLETE_DMA_SCB_HEAD, SCB_LIST_NULL);
+
+	/*
+	 * The Freeze Count is 0.
+	 */
+	ahd_outw(ahd, QFREEZE_COUNT, 0);
+
+	/*
+	 * Tell the sequencer where it can find our arrays in memory.
+	 */
+	busaddr = ahd->shared_data_busaddr;
+	ahd_outb(ahd, SHARED_DATA_ADDR, busaddr & 0xFF);
+	ahd_outb(ahd, SHARED_DATA_ADDR + 1, (busaddr >> 8) & 0xFF);
+	ahd_outb(ahd, SHARED_DATA_ADDR + 2, (busaddr >> 16) & 0xFF);
+	ahd_outb(ahd, SHARED_DATA_ADDR + 3, (busaddr >> 24) & 0xFF);
+	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR, busaddr & 0xFF);
+	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR + 1, (busaddr >> 8) & 0xFF);
+	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR + 2, (busaddr >> 16) & 0xFF);
+	ahd_outb(ahd, QOUTFIFO_NEXT_ADDR + 3, (busaddr >> 24) & 0xFF);
+
+	/*
+	 * Setup the allowed SCSI Sequences based on operational mode.
+	 * If we are a target, we'll enable select in operations once
+	 * we've had a lun enabled.
+	 */
+	scsiseq_template = ENAUTOATNP;
+	if ((ahd->flags & AHD_INITIATORROLE) != 0)
+		scsiseq_template |= ENRSELI;
+	ahd_outb(ahd, SCSISEQ_TEMPLATE, scsiseq_template);
+
+	/* There are no busy SCBs yet. */
+	for (target = 0; target < AHD_NUM_TARGETS; target++) {
+		int lun;
+
+		for (lun = 0; lun < AHD_NUM_LUNS_NONPKT; lun++)
+			ahd_unbusy_tcl(ahd, BUILD_TCL_RAW(target, 'A', lun));
+	}
+
+	/*
+	 * Initialize the group code to command length table.
+	 * Vendor Unique codes are set to 0 so we only capture
+	 * the first byte of the cdb.  These can be overridden
+	 * when target mode is enabled.
+	 */
+	ahd_outb(ahd, CMDSIZE_TABLE, 5);
+	ahd_outb(ahd, CMDSIZE_TABLE + 1, 9);
+	ahd_outb(ahd, CMDSIZE_TABLE + 2, 9);
+	ahd_outb(ahd, CMDSIZE_TABLE + 3, 0);
+	ahd_outb(ahd, CMDSIZE_TABLE + 4, 15);
+	ahd_outb(ahd, CMDSIZE_TABLE + 5, 11);
+	ahd_outb(ahd, CMDSIZE_TABLE + 6, 0);
+	ahd_outb(ahd, CMDSIZE_TABLE + 7, 0);
+		
+	/* Tell the sequencer of our initial queue positions */
+	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
+	ahd_outb(ahd, QOFF_CTLSTA, SCB_QSIZE_512);
+	ahd->qinfifonext = 0;
+	ahd_set_hnscb_qoff(ahd, ahd->qinfifonext);
+	ahd_set_hescb_qoff(ahd, 0);
+	ahd_set_snscb_qoff(ahd, 0);
+	ahd_set_sescb_qoff(ahd, 0);
+	ahd_set_sdscb_qoff(ahd, 0);
+
+	/*
+	 * Tell the sequencer which SCB will be the next one it receives.
+	 */
+	busaddr = ahd_le32toh(ahd->next_queued_hscb->hscb_busaddr);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 0, busaddr & 0xFF);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 1, (busaddr >> 8) & 0xFF);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 2, (busaddr >> 16) & 0xFF);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 3, (busaddr >> 24) & 0xFF);
+
+	/*
+	 * Default to coalescing disabled.
+	 */
+	ahd_outw(ahd, INT_COALESCING_CMDCOUNT, 0);
+	ahd_outw(ahd, CMDS_PENDING, 0);
+	ahd_update_coalescing_values(ahd, ahd->int_coalescing_timer,
+				     ahd->int_coalescing_maxcmds,
+				     ahd->int_coalescing_mincmds);
+	ahd_enable_coalescing(ahd, FALSE);
+
+	ahd_loadseq(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+}
+
+/*
+ * Setup default device and controller settings.
+ * This should only be called if our probe has
+ * determined that no configuration data is available.
+ */
+int
+ahd_default_config(struct ahd_softc *ahd)
+{
+	int	targ;
+
+	ahd->our_id = 7;
+
+	/*
+	 * Allocate a tstate to house information for our
+	 * initiator presence on the bus as well as the user
+	 * data for any target mode initiator.
+	 */
+	if (ahd_alloc_tstate(ahd, ahd->our_id, 'A') == NULL) {
+		printf("%s: unable to allocate ahd_tmode_tstate.  "
+		       "Failing attach\n", ahd_name(ahd));
+		return (ENOMEM);
+	}
+
+	for (targ = 0; targ < AHD_NUM_TARGETS; targ++) {
+		struct	 ahd_devinfo devinfo;
+		struct	 ahd_initiator_tinfo *tinfo;
+		struct	 ahd_tmode_tstate *tstate;
+		uint16_t target_mask;
+
+		tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
+					    targ, &tstate);
+		/*
+		 * We support SPC2 and SPI4.
+		 */
+		tinfo->user.protocol_version = 4;
+		tinfo->user.transport_version = 4;
+
+		target_mask = 0x01 << targ;
+		ahd->user_discenable |= target_mask;
+		tstate->discenable |= target_mask;
+		ahd->user_tagenable |= target_mask;
+#ifdef AHD_FORCE_160
+		tinfo->user.period = AHD_SYNCRATE_DT;
+#else
+		tinfo->user.period = AHD_SYNCRATE_160;
+#endif
+		tinfo->user.offset = MAX_OFFSET;
+		tinfo->user.ppr_options = MSG_EXT_PPR_RD_STRM
+					| MSG_EXT_PPR_WR_FLOW
+					| MSG_EXT_PPR_HOLD_MCS
+					| MSG_EXT_PPR_IU_REQ
+					| MSG_EXT_PPR_QAS_REQ
+					| MSG_EXT_PPR_DT_REQ;
+		if ((ahd->features & AHD_RTI) != 0)
+			tinfo->user.ppr_options |= MSG_EXT_PPR_RTI;
+
+		tinfo->user.width = MSG_EXT_WDTR_BUS_16_BIT;
+
+		/*
+		 * Start out Async/Narrow/Untagged and with
+		 * conservative protocol support.
+		 */
+		tinfo->goal.protocol_version = 2;
+		tinfo->goal.transport_version = 2;
+		tinfo->curr.protocol_version = 2;
+		tinfo->curr.transport_version = 2;
+		ahd_compile_devinfo(&devinfo, ahd->our_id,
+				    targ, CAM_LUN_WILDCARD,
+				    'A', ROLE_INITIATOR);
+		tstate->tagenable &= ~target_mask;
+		ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+			      AHD_TRANS_CUR|AHD_TRANS_GOAL, /*paused*/TRUE);
+		ahd_set_syncrate(ahd, &devinfo, /*period*/0, /*offset*/0,
+				 /*ppr_options*/0, AHD_TRANS_CUR|AHD_TRANS_GOAL,
+				 /*paused*/TRUE);
+	}
+	return (0);
+}
+
+/*
+ * Parse device configuration information.
+ */
+int
+ahd_parse_cfgdata(struct ahd_softc *ahd, struct seeprom_config *sc)
+{
+	int targ;
+	int max_targ;
+
+	max_targ = sc->max_targets & CFMAXTARG;
+	ahd->our_id = sc->brtime_id & CFSCSIID;
+
+	/*
+	 * Allocate a tstate to house information for our
+	 * initiator presence on the bus as well as the user
+	 * data for any target mode initiator.
+	 */
+	if (ahd_alloc_tstate(ahd, ahd->our_id, 'A') == NULL) {
+		printf("%s: unable to allocate ahd_tmode_tstate.  "
+		       "Failing attach\n", ahd_name(ahd));
+		return (ENOMEM);
+	}
+
+	for (targ = 0; targ < max_targ; targ++) {
+		struct	 ahd_devinfo devinfo;
+		struct	 ahd_initiator_tinfo *tinfo;
+		struct	 ahd_transinfo *user_tinfo;
+		struct	 ahd_tmode_tstate *tstate;
+		uint16_t target_mask;
+
+		tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
+					    targ, &tstate);
+		user_tinfo = &tinfo->user;
+
+		/*
+		 * We support SPC2 and SPI4.
+		 */
+		tinfo->user.protocol_version = 4;
+		tinfo->user.transport_version = 4;
+
+		target_mask = 0x01 << targ;
+		ahd->user_discenable &= ~target_mask;
+		tstate->discenable &= ~target_mask;
+		ahd->user_tagenable &= ~target_mask;
+		if (sc->device_flags[targ] & CFDISC) {
+			tstate->discenable |= target_mask;
+			ahd->user_discenable |= target_mask;
+			ahd->user_tagenable |= target_mask;
+		} else {
+			/*
+			 * Cannot be packetized without disconnection.
+			 */
+			sc->device_flags[targ] &= ~CFPACKETIZED;
+		}
+
+		user_tinfo->ppr_options = 0;
+		user_tinfo->period = (sc->device_flags[targ] & CFXFER);
+		if (user_tinfo->period < CFXFER_ASYNC) {
+			if (user_tinfo->period <= AHD_PERIOD_10MHz)
+				user_tinfo->ppr_options |= MSG_EXT_PPR_DT_REQ;
+			user_tinfo->offset = MAX_OFFSET;
+		} else  {
+			user_tinfo->offset = 0;
+			user_tinfo->period = AHD_ASYNC_XFER_PERIOD;
+		}
+#ifdef AHD_FORCE_160
+		if (user_tinfo->period <= AHD_SYNCRATE_160)
+			user_tinfo->period = AHD_SYNCRATE_DT;
+#endif
+
+		if ((sc->device_flags[targ] & CFPACKETIZED) != 0) {
+			user_tinfo->ppr_options |= MSG_EXT_PPR_RD_STRM
+						|  MSG_EXT_PPR_WR_FLOW
+						|  MSG_EXT_PPR_HOLD_MCS
+						|  MSG_EXT_PPR_IU_REQ;
+			if ((ahd->features & AHD_RTI) != 0)
+				user_tinfo->ppr_options |= MSG_EXT_PPR_RTI;
+		}
+
+		if ((sc->device_flags[targ] & CFQAS) != 0)
+			user_tinfo->ppr_options |= MSG_EXT_PPR_QAS_REQ;
+
+		if ((sc->device_flags[targ] & CFWIDEB) != 0)
+			user_tinfo->width = MSG_EXT_WDTR_BUS_16_BIT;
+		else
+			user_tinfo->width = MSG_EXT_WDTR_BUS_8_BIT;
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MISC) != 0)
+			printf("(%d): %x:%x:%x:%x\n", targ, user_tinfo->width,
+			       user_tinfo->period, user_tinfo->offset,
+			       user_tinfo->ppr_options);
+#endif
+		/*
+		 * Start out Async/Narrow/Untagged and with
+		 * conservative protocol support.
+		 */
+		tstate->tagenable &= ~target_mask;
+		tinfo->goal.protocol_version = 2;
+		tinfo->goal.transport_version = 2;
+		tinfo->curr.protocol_version = 2;
+		tinfo->curr.transport_version = 2;
+		ahd_compile_devinfo(&devinfo, ahd->our_id,
+				    targ, CAM_LUN_WILDCARD,
+				    'A', ROLE_INITIATOR);
+		ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+			      AHD_TRANS_CUR|AHD_TRANS_GOAL, /*paused*/TRUE);
+		ahd_set_syncrate(ahd, &devinfo, /*period*/0, /*offset*/0,
+				 /*ppr_options*/0, AHD_TRANS_CUR|AHD_TRANS_GOAL,
+				 /*paused*/TRUE);
+	}
+
+	ahd->flags &= ~AHD_SPCHK_ENB_A;
+	if (sc->bios_control & CFSPARITY)
+		ahd->flags |= AHD_SPCHK_ENB_A;
+
+	ahd->flags &= ~AHD_RESET_BUS_A;
+	if (sc->bios_control & CFRESETB)
+		ahd->flags |= AHD_RESET_BUS_A;
+
+	ahd->flags &= ~AHD_EXTENDED_TRANS_A;
+	if (sc->bios_control & CFEXTEND)
+		ahd->flags |= AHD_EXTENDED_TRANS_A;
+
+	ahd->flags &= ~AHD_BIOS_ENABLED;
+	if ((sc->bios_control & CFBIOSSTATE) == CFBS_ENABLED)
+		ahd->flags |= AHD_BIOS_ENABLED;
+
+	ahd->flags &= ~AHD_STPWLEVEL_A;
+	if ((sc->adapter_control & CFSTPWLEVEL) != 0)
+		ahd->flags |= AHD_STPWLEVEL_A;
+
+	return (0);
+}
+
+/*
+ * Parse device configuration information.
+ */
+int
+ahd_parse_vpddata(struct ahd_softc *ahd, struct vpd_config *vpd)
+{
+	int error;
+
+	error = ahd_verify_vpd_cksum(vpd);
+	if (error == 0)
+		return (EINVAL);
+	if ((vpd->bios_flags & VPDBOOTHOST) != 0)
+		ahd->flags |= AHD_BOOT_CHANNEL;
+	return (0);
+}
+
+void
+ahd_intr_enable(struct ahd_softc *ahd, int enable)
+{
+	u_int hcntrl;
+
+	hcntrl = ahd_inb(ahd, HCNTRL);
+	hcntrl &= ~INTEN;
+	ahd->pause &= ~INTEN;
+	ahd->unpause &= ~INTEN;
+	if (enable) {
+		hcntrl |= INTEN;
+		ahd->pause |= INTEN;
+		ahd->unpause |= INTEN;
+	}
+	ahd_outb(ahd, HCNTRL, hcntrl);
+}
+
+void
+ahd_update_coalescing_values(struct ahd_softc *ahd, u_int timer, u_int maxcmds,
+			     u_int mincmds)
+{
+	if (timer > AHD_TIMER_MAX_US)
+		timer = AHD_TIMER_MAX_US;
+	ahd->int_coalescing_timer = timer;
+
+	if (maxcmds > AHD_INT_COALESCING_MAXCMDS_MAX)
+		maxcmds = AHD_INT_COALESCING_MAXCMDS_MAX;
+	if (mincmds > AHD_INT_COALESCING_MINCMDS_MAX)
+		mincmds = AHD_INT_COALESCING_MINCMDS_MAX;
+	ahd->int_coalescing_maxcmds = maxcmds;
+	ahd_outw(ahd, INT_COALESCING_TIMER, timer / AHD_TIMER_US_PER_TICK);
+	ahd_outb(ahd, INT_COALESCING_MAXCMDS, -maxcmds);
+	ahd_outb(ahd, INT_COALESCING_MINCMDS, -mincmds);
+}
+
+void
+ahd_enable_coalescing(struct ahd_softc *ahd, int enable)
+{
+
+	ahd->hs_mailbox &= ~ENINT_COALESCE;
+	if (enable)
+		ahd->hs_mailbox |= ENINT_COALESCE;
+	ahd_outb(ahd, HS_MAILBOX, ahd->hs_mailbox);
+	ahd_flush_device_writes(ahd);
+	ahd_run_qoutfifo(ahd);
+}
+
+/*
+ * Ensure that the card is paused in a location
+ * outside of all critical sections and that all
+ * pending work is completed prior to returning.
+ * This routine should only be called from outside
+ * an interrupt context.
+ */
+void
+ahd_pause_and_flushwork(struct ahd_softc *ahd)
+{
+	u_int intstat;
+	u_int maxloops;
+	u_int qfreeze_cnt;
+
+	maxloops = 1000;
+	ahd->flags |= AHD_ALL_INTERRUPTS;
+	ahd_pause(ahd);
+	/*
+	 * Increment the QFreeze Count so that the sequencer
+	 * will not start new selections.  We do this only
+	 * until we are safely paused without further selections
+	 * pending.
+	 */
+	ahd_outw(ahd, QFREEZE_COUNT, ahd_inw(ahd, QFREEZE_COUNT) + 1);
+	ahd_outb(ahd, SEQ_FLAGS2, ahd_inb(ahd, SEQ_FLAGS2) | SELECTOUT_QFROZEN);
+	do {
+		struct scb *waiting_scb;
+
+		ahd_unpause(ahd);
+		ahd_intr(ahd);
+		ahd_pause(ahd);
+		ahd_clear_critical_section(ahd);
+		intstat = ahd_inb(ahd, INTSTAT);
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+		if ((ahd_inb(ahd, SSTAT0) & (SELDO|SELINGO)) == 0)
+			ahd_outb(ahd, SCSISEQ0,
+				 ahd_inb(ahd, SCSISEQ0) & ~ENSELO);
+		/*
+		 * In the non-packetized case, the sequencer (for Rev A),
+		 * relies on ENSELO remaining set after SELDO.  The hardware
+		 * auto-clears ENSELO in the packetized case.
+		 */
+		waiting_scb = ahd_lookup_scb(ahd,
+					     ahd_inw(ahd, WAITING_TID_HEAD));
+		if (waiting_scb != NULL
+		 && (waiting_scb->flags & SCB_PACKETIZED) == 0
+		 && (ahd_inb(ahd, SSTAT0) & (SELDO|SELINGO)) != 0)
+			ahd_outb(ahd, SCSISEQ0,
+				 ahd_inb(ahd, SCSISEQ0) | ENSELO);
+	} while (--maxloops
+	      && (intstat != 0xFF || (ahd->features & AHD_REMOVABLE) == 0)
+	      && ((intstat & INT_PEND) != 0
+	       || (ahd_inb(ahd, SCSISEQ0) & ENSELO) != 0
+	       || (ahd_inb(ahd, SSTAT0) & (SELDO|SELINGO)) != 0));
+
+	if (maxloops == 0) {
+		printf("Infinite interrupt loop, INTSTAT = %x",
+		      ahd_inb(ahd, INTSTAT));
+	}
+	qfreeze_cnt = ahd_inw(ahd, QFREEZE_COUNT);
+	if (qfreeze_cnt == 0) {
+		printf("%s: ahd_pause_and_flushwork with 0 qfreeze count!\n",
+		       ahd_name(ahd));
+	} else {
+		qfreeze_cnt--;
+	}
+	ahd_outw(ahd, QFREEZE_COUNT, qfreeze_cnt);
+	if (qfreeze_cnt == 0)
+		ahd_outb(ahd, SEQ_FLAGS2,
+			 ahd_inb(ahd, SEQ_FLAGS2) & ~SELECTOUT_QFROZEN);
+
+	ahd_flush_qoutfifo(ahd);
+
+	ahd_platform_flushwork(ahd);
+	ahd->flags &= ~AHD_ALL_INTERRUPTS;
+}
+
+int
+ahd_suspend(struct ahd_softc *ahd)
+{
+
+	ahd_pause_and_flushwork(ahd);
+
+	if (LIST_FIRST(&ahd->pending_scbs) != NULL) {
+		ahd_unpause(ahd);
+		return (EBUSY);
+	}
+	ahd_shutdown(ahd);
+	return (0);
+}
+
+int
+ahd_resume(struct ahd_softc *ahd)
+{
+
+	ahd_reset(ahd, /*reinit*/TRUE);
+	ahd_intr_enable(ahd, TRUE); 
+	ahd_restart(ahd);
+	return (0);
+}
+
+/************************** Busy Target Table *********************************/
+/*
+ * Set SCBPTR to the SCB that contains the busy
+ * table entry for TCL.  Return the offset into
+ * the SCB that contains the entry for TCL.
+ * saved_scbid is dereferenced and set to the
+ * scbid that should be restored once manipualtion
+ * of the TCL entry is complete.
+ */
+static __inline u_int
+ahd_index_busy_tcl(struct ahd_softc *ahd, u_int *saved_scbid, u_int tcl)
+{
+	/*
+	 * Index to the SCB that contains the busy entry.
+	 */
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	*saved_scbid = ahd_get_scbptr(ahd);
+	ahd_set_scbptr(ahd, TCL_LUN(tcl)
+		     | ((TCL_TARGET_OFFSET(tcl) & 0xC) << 4));
+
+	/*
+	 * And now calculate the SCB offset to the entry.
+	 * Each entry is 2 bytes wide, hence the
+	 * multiplication by 2.
+	 */
+	return (((TCL_TARGET_OFFSET(tcl) & 0x3) << 1) + SCB_DISCONNECTED_LISTS);
+}
+
+/*
+ * Return the untagged transaction id for a given target/channel lun.
+ */
+u_int
+ahd_find_busy_tcl(struct ahd_softc *ahd, u_int tcl)
+{
+	u_int scbid;
+	u_int scb_offset;
+	u_int saved_scbptr;
+		
+	scb_offset = ahd_index_busy_tcl(ahd, &saved_scbptr, tcl);
+	scbid = ahd_inw_scbram(ahd, scb_offset);
+	ahd_set_scbptr(ahd, saved_scbptr);
+	return (scbid);
+}
+
+void
+ahd_busy_tcl(struct ahd_softc *ahd, u_int tcl, u_int scbid)
+{
+	u_int scb_offset;
+	u_int saved_scbptr;
+		
+	scb_offset = ahd_index_busy_tcl(ahd, &saved_scbptr, tcl);
+	ahd_outw(ahd, scb_offset, scbid);
+	ahd_set_scbptr(ahd, saved_scbptr);
+}
+
+/************************** SCB and SCB queue management **********************/
+int
+ahd_match_scb(struct ahd_softc *ahd, struct scb *scb, int target,
+	      char channel, int lun, u_int tag, role_t role)
+{
+	int targ = SCB_GET_TARGET(ahd, scb);
+	char chan = SCB_GET_CHANNEL(ahd, scb);
+	int slun = SCB_GET_LUN(scb);
+	int match;
+
+	match = ((chan == channel) || (channel == ALL_CHANNELS));
+	if (match != 0)
+		match = ((targ == target) || (target == CAM_TARGET_WILDCARD));
+	if (match != 0)
+		match = ((lun == slun) || (lun == CAM_LUN_WILDCARD));
+	if (match != 0) {
+#if AHD_TARGET_MODE
+		int group;
+
+		group = XPT_FC_GROUP(scb->io_ctx->ccb_h.func_code);
+		if (role == ROLE_INITIATOR) {
+			match = (group != XPT_FC_GROUP_TMODE)
+			      && ((tag == SCB_GET_TAG(scb))
+			       || (tag == SCB_LIST_NULL));
+		} else if (role == ROLE_TARGET) {
+			match = (group == XPT_FC_GROUP_TMODE)
+			      && ((tag == scb->io_ctx->csio.tag_id)
+			       || (tag == SCB_LIST_NULL));
+		}
+#else /* !AHD_TARGET_MODE */
+		match = ((tag == SCB_GET_TAG(scb)) || (tag == SCB_LIST_NULL));
+#endif /* AHD_TARGET_MODE */
+	}
+
+	return match;
+}
+
+void
+ahd_freeze_devq(struct ahd_softc *ahd, struct scb *scb)
+{
+	int	target;
+	char	channel;
+	int	lun;
+
+	target = SCB_GET_TARGET(ahd, scb);
+	lun = SCB_GET_LUN(scb);
+	channel = SCB_GET_CHANNEL(ahd, scb);
+	
+	ahd_search_qinfifo(ahd, target, channel, lun,
+			   /*tag*/SCB_LIST_NULL, ROLE_UNKNOWN,
+			   CAM_REQUEUE_REQ, SEARCH_COMPLETE);
+
+	ahd_platform_freeze_devq(ahd, scb);
+}
+
+void
+ahd_qinfifo_requeue_tail(struct ahd_softc *ahd, struct scb *scb)
+{
+	struct scb	*prev_scb;
+	ahd_mode_state	 saved_modes;
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
+	prev_scb = NULL;
+	if (ahd_qinfifo_count(ahd) != 0) {
+		u_int prev_tag;
+		u_int prev_pos;
+
+		prev_pos = AHD_QIN_WRAP(ahd->qinfifonext - 1);
+		prev_tag = ahd->qinfifo[prev_pos];
+		prev_scb = ahd_lookup_scb(ahd, prev_tag);
+	}
+	ahd_qinfifo_requeue(ahd, prev_scb, scb);
+	ahd_set_hnscb_qoff(ahd, ahd->qinfifonext);
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+static void
+ahd_qinfifo_requeue(struct ahd_softc *ahd, struct scb *prev_scb,
+		    struct scb *scb)
+{
+	if (prev_scb == NULL) {
+		uint32_t busaddr;
+
+		busaddr = ahd_le32toh(scb->hscb->hscb_busaddr);
+		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 0, busaddr & 0xFF);
+		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 1, (busaddr >> 8) & 0xFF);
+		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 2, (busaddr >> 16) & 0xFF);
+		ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 3, (busaddr >> 24) & 0xFF);
+	} else {
+		prev_scb->hscb->next_hscb_busaddr = scb->hscb->hscb_busaddr;
+		ahd_sync_scb(ahd, prev_scb, 
+			     BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
+	}
+	ahd->qinfifo[AHD_QIN_WRAP(ahd->qinfifonext)] = SCB_GET_TAG(scb);
+	ahd->qinfifonext++;
+	scb->hscb->next_hscb_busaddr = ahd->next_queued_hscb->hscb_busaddr;
+	ahd_sync_scb(ahd, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
+}
+
+static int
+ahd_qinfifo_count(struct ahd_softc *ahd)
+{
+	u_int qinpos;
+	u_int wrap_qinpos;
+	u_int wrap_qinfifonext;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	qinpos = ahd_get_snscb_qoff(ahd);
+	wrap_qinpos = AHD_QIN_WRAP(qinpos);
+	wrap_qinfifonext = AHD_QIN_WRAP(ahd->qinfifonext);
+	if (wrap_qinfifonext >= wrap_qinpos)
+		return (wrap_qinfifonext - wrap_qinpos);
+	else
+		return (wrap_qinfifonext
+		      + NUM_ELEMENTS(ahd->qinfifo) - wrap_qinpos);
+}
+
+void
+ahd_reset_cmds_pending(struct ahd_softc *ahd)
+{
+	struct		scb *scb;
+	ahd_mode_state	saved_modes;
+	u_int		pending_cmds;
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
+
+	/*
+	 * Don't count any commands as outstanding that the
+	 * sequencer has already marked for completion.
+	 */
+	ahd_flush_qoutfifo(ahd);
+
+	pending_cmds = 0;
+	LIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {
+		pending_cmds++;
+	}
+	ahd_outw(ahd, CMDS_PENDING, pending_cmds - ahd_qinfifo_count(ahd));
+	ahd_restore_modes(ahd, saved_modes);
+	ahd->flags &= ~AHD_UPDATE_PEND_CMDS;
+}
+
+int
+ahd_search_qinfifo(struct ahd_softc *ahd, int target, char channel,
+		   int lun, u_int tag, role_t role, uint32_t status,
+		   ahd_search_action action)
+{
+	struct scb	*scb;
+	struct scb	*prev_scb;
+	ahd_mode_state	 saved_modes;
+	u_int		 qinstart;
+	u_int		 qinpos;
+	u_int		 qintail;
+	u_int		 tid_next;
+	u_int		 tid_prev;
+	u_int		 scbid;
+	u_int		 savedscbptr;
+	uint32_t	 busaddr;
+	int		 found;
+	int		 targets;
+
+	/* Must be in CCHAN mode */
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
+
+	/*
+	 * Halt any pending SCB DMA.  The sequencer will reinitiate
+	 * this dma if the qinfifo is not empty once we unpause.
+	 */
+	if ((ahd_inb(ahd, CCSCBCTL) & (CCARREN|CCSCBEN|CCSCBDIR))
+	 == (CCARREN|CCSCBEN|CCSCBDIR)) {
+		ahd_outb(ahd, CCSCBCTL,
+			 ahd_inb(ahd, CCSCBCTL) & ~(CCARREN|CCSCBEN));
+		while ((ahd_inb(ahd, CCSCBCTL) & (CCARREN|CCSCBEN)) != 0)
+			;
+	}
+	/* Determine sequencer's position in the qinfifo. */
+	qintail = AHD_QIN_WRAP(ahd->qinfifonext);
+	qinstart = ahd_get_snscb_qoff(ahd);
+	qinpos = AHD_QIN_WRAP(qinstart);
+	found = 0;
+	prev_scb = NULL;
+
+	if (action == SEARCH_PRINT) {
+		printf("qinstart = %d qinfifonext = %d\nQINFIFO:",
+		       qinstart, ahd->qinfifonext);
+	}
+
+	/*
+	 * Start with an empty queue.  Entries that are not chosen
+	 * for removal will be re-added to the queue as we go.
+	 */
+	ahd->qinfifonext = qinstart;
+	busaddr = ahd_le32toh(ahd->next_queued_hscb->hscb_busaddr);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 0, busaddr & 0xFF);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 1, (busaddr >> 8) & 0xFF);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 2, (busaddr >> 16) & 0xFF);
+	ahd_outb(ahd, NEXT_QUEUED_SCB_ADDR + 3, (busaddr >> 24) & 0xFF);
+
+	while (qinpos != qintail) {
+		scb = ahd_lookup_scb(ahd, ahd->qinfifo[qinpos]);
+		if (scb == NULL) {
+			printf("qinpos = %d, SCB index = %d\n",
+				qinpos, ahd->qinfifo[qinpos]);
+			panic("Loop 1\n");
+		}
+
+		if (ahd_match_scb(ahd, scb, target, channel, lun, tag, role)) {
+			/*
+			 * We found an scb that needs to be acted on.
+			 */
+			found++;
+			switch (action) {
+			case SEARCH_COMPLETE:
+			{
+				cam_status ostat;
+				cam_status cstat;
+
+				ostat = ahd_get_transaction_status(scb);
+				if (ostat == CAM_REQ_INPROG)
+					ahd_set_transaction_status(scb,
+								   status);
+				cstat = ahd_get_transaction_status(scb);
+				if (cstat != CAM_REQ_CMP)
+					ahd_freeze_scb(scb);
+				if ((scb->flags & SCB_ACTIVE) == 0)
+					printf("Inactive SCB in qinfifo\n");
+				ahd_done(ahd, scb);
+
+				/* FALLTHROUGH */
+			}
+			case SEARCH_REMOVE:
+				break;
+			case SEARCH_PRINT:
+				printf(" 0x%x", ahd->qinfifo[qinpos]);
+				/* FALLTHROUGH */
+			case SEARCH_COUNT:
+				ahd_qinfifo_requeue(ahd, prev_scb, scb);
+				prev_scb = scb;
+				break;
+			}
+		} else {
+			ahd_qinfifo_requeue(ahd, prev_scb, scb);
+			prev_scb = scb;
+		}
+		qinpos = AHD_QIN_WRAP(qinpos+1);
+	}
+
+	ahd_set_hnscb_qoff(ahd, ahd->qinfifonext);
+
+	if (action == SEARCH_PRINT)
+		printf("\nWAITING_TID_QUEUES:\n");
+
+	/*
+	 * Search waiting for selection lists.  We traverse the
+	 * list of "their ids" waiting for selection and, if
+	 * appropriate, traverse the SCBs of each "their id"
+	 * looking for matches.
+	 */
+	savedscbptr = ahd_get_scbptr(ahd);
+	tid_next = ahd_inw(ahd, WAITING_TID_HEAD);
+	tid_prev = SCB_LIST_NULL;
+	targets = 0;
+	for (scbid = tid_next; !SCBID_IS_NULL(scbid); scbid = tid_next) {
+		u_int tid_head;
+
+		/*
+		 * We limit based on the number of SCBs since
+		 * MK_MESSAGE SCBs are not in the per-tid lists.
+		 */
+		targets++;
+		if (targets > AHD_SCB_MAX) {
+			panic("TID LIST LOOP");
+		}
+		if (scbid >= ahd->scb_data.numscbs) {
+			printf("%s: Waiting TID List inconsistency. "
+			       "SCB index == 0x%x, yet numscbs == 0x%x.",
+			       ahd_name(ahd), scbid, ahd->scb_data.numscbs);
+			ahd_dump_card_state(ahd);
+			panic("for safety");
+		}
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL) {
+			printf("%s: SCB = 0x%x Not Active!\n",
+			       ahd_name(ahd), scbid);
+			panic("Waiting TID List traversal\n");
+		}
+		ahd_set_scbptr(ahd, scbid);
+		tid_next = ahd_inw_scbram(ahd, SCB_NEXT2);
+		if (ahd_match_scb(ahd, scb, target, channel, CAM_LUN_WILDCARD,
+				  SCB_LIST_NULL, ROLE_UNKNOWN) == 0) {
+			tid_prev = scbid;
+			continue;
+		}
+
+		/*
+		 * We found a list of scbs that needs to be searched.
+		 */
+		if (action == SEARCH_PRINT)
+			printf("       %d ( ", SCB_GET_TARGET(ahd, scb));
+		tid_head = scbid;
+		found += ahd_search_scb_list(ahd, target, channel,
+					     lun, tag, role, status,
+					     action, &tid_head,
+					     SCB_GET_TARGET(ahd, scb));
+		if (tid_head != scbid)
+			ahd_stitch_tid_list(ahd, tid_prev, tid_head, tid_next);
+		if (!SCBID_IS_NULL(tid_head))
+			tid_prev = tid_head;
+		if (action == SEARCH_PRINT)
+			printf(")\n");
+	}
+	ahd_set_scbptr(ahd, savedscbptr);
+	ahd_restore_modes(ahd, saved_modes);
+	return (found);
+}
+
+static int
+ahd_search_scb_list(struct ahd_softc *ahd, int target, char channel,
+		    int lun, u_int tag, role_t role, uint32_t status,
+		    ahd_search_action action, u_int *list_head, u_int tid)
+{
+	struct	scb *scb;
+	u_int	scbid;
+	u_int	next;
+	u_int	prev;
+	int	found;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	found = 0;
+	prev = SCB_LIST_NULL;
+	next = *list_head;
+	for (scbid = next; !SCBID_IS_NULL(scbid); scbid = next) {
+		if (scbid >= ahd->scb_data.numscbs) {
+			printf("%s:SCB List inconsistency. "
+			       "SCB == 0x%x, yet numscbs == 0x%x.",
+			       ahd_name(ahd), scbid, ahd->scb_data.numscbs);
+			ahd_dump_card_state(ahd);
+			panic("for safety");
+		}
+		scb = ahd_lookup_scb(ahd, scbid);
+		if (scb == NULL) {
+			printf("%s: SCB = %d Not Active!\n",
+			       ahd_name(ahd), scbid);
+			panic("Waiting List traversal\n");
+		}
+		ahd_set_scbptr(ahd, scbid);
+		next = ahd_inw_scbram(ahd, SCB_NEXT);
+		if (ahd_match_scb(ahd, scb, target, channel,
+				  lun, SCB_LIST_NULL, role) == 0) {
+			prev = scbid;
+			continue;
+		}
+		found++;
+		switch (action) {
+		case SEARCH_COMPLETE:
+		{
+			cam_status ostat;
+			cam_status cstat;
+
+			ostat = ahd_get_transaction_status(scb);
+			if (ostat == CAM_REQ_INPROG)
+				ahd_set_transaction_status(scb, status);
+			cstat = ahd_get_transaction_status(scb);
+			if (cstat != CAM_REQ_CMP)
+				ahd_freeze_scb(scb);
+			if ((scb->flags & SCB_ACTIVE) == 0)
+				printf("Inactive SCB in Waiting List\n");
+			ahd_done(ahd, scb);
+			/* FALLTHROUGH */
+		}
+		case SEARCH_REMOVE:
+			ahd_rem_wscb(ahd, scbid, prev, next, tid);
+			if (prev == SCB_LIST_NULL)
+				*list_head = next;
+			break;
+		case SEARCH_PRINT:
+			printf("0x%x ", scbid);
+		case SEARCH_COUNT:
+			prev = scbid;
+			break;
+		}
+		if (found > AHD_SCB_MAX)
+			panic("SCB LIST LOOP");
+	}
+	if (action == SEARCH_COMPLETE
+	 || action == SEARCH_REMOVE)
+		ahd_outw(ahd, CMDS_PENDING, ahd_inw(ahd, CMDS_PENDING) - found);
+	return (found);
+}
+
+static void
+ahd_stitch_tid_list(struct ahd_softc *ahd, u_int tid_prev,
+		    u_int tid_cur, u_int tid_next)
+{
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+
+	if (SCBID_IS_NULL(tid_cur)) {
+
+		/* Bypass current TID list */
+		if (SCBID_IS_NULL(tid_prev)) {
+			ahd_outw(ahd, WAITING_TID_HEAD, tid_next);
+		} else {
+			ahd_set_scbptr(ahd, tid_prev);
+			ahd_outw(ahd, SCB_NEXT2, tid_next);
+		}
+		if (SCBID_IS_NULL(tid_next))
+			ahd_outw(ahd, WAITING_TID_TAIL, tid_prev);
+	} else {
+
+		/* Stitch through tid_cur */
+		if (SCBID_IS_NULL(tid_prev)) {
+			ahd_outw(ahd, WAITING_TID_HEAD, tid_cur);
+		} else {
+			ahd_set_scbptr(ahd, tid_prev);
+			ahd_outw(ahd, SCB_NEXT2, tid_cur);
+		}
+		ahd_set_scbptr(ahd, tid_cur);
+		ahd_outw(ahd, SCB_NEXT2, tid_next);
+
+		if (SCBID_IS_NULL(tid_next))
+			ahd_outw(ahd, WAITING_TID_TAIL, tid_cur);
+	}
+}
+
+/*
+ * Manipulate the waiting for selection list and return the
+ * scb that follows the one that we remove.
+ */
+static u_int
+ahd_rem_wscb(struct ahd_softc *ahd, u_int scbid,
+	     u_int prev, u_int next, u_int tid)
+{
+	u_int tail_offset;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	if (!SCBID_IS_NULL(prev)) {
+		ahd_set_scbptr(ahd, prev);
+		ahd_outw(ahd, SCB_NEXT, next);
+	}
+
+	/*
+	 * SCBs that had MK_MESSAGE set in them will not
+	 * be queued to the per-target lists, so don't
+	 * blindly clear the tail pointer.
+	 */
+	tail_offset = WAITING_SCB_TAILS + (2 * tid);
+	if (SCBID_IS_NULL(next)
+	 && ahd_inw(ahd, tail_offset) == scbid)
+		ahd_outw(ahd, tail_offset, prev);
+	ahd_add_scb_to_free_list(ahd, scbid);
+	return (next);
+}
+
+/*
+ * Add the SCB as selected by SCBPTR onto the on chip list of
+ * free hardware SCBs.  This list is empty/unused if we are not
+ * performing SCB paging.
+ */
+static void
+ahd_add_scb_to_free_list(struct ahd_softc *ahd, u_int scbid)
+{
+/* XXX Need some other mechanism to designate "free". */
+	/*
+	 * Invalidate the tag so that our abort
+	 * routines don't think it's active.
+	ahd_outb(ahd, SCB_TAG, SCB_LIST_NULL);
+	 */
+}
+
+/******************************** Error Handling ******************************/
+/*
+ * Abort all SCBs that match the given description (target/channel/lun/tag),
+ * setting their status to the passed in status if the status has not already
+ * been modified from CAM_REQ_INPROG.  This routine assumes that the sequencer
+ * is paused before it is called.
+ */
+int
+ahd_abort_scbs(struct ahd_softc *ahd, int target, char channel,
+	       int lun, u_int tag, role_t role, uint32_t status)
+{
+	struct		scb *scbp;
+	struct		scb *scbp_next;
+	u_int		i, j;
+	u_int		maxtarget;
+	u_int		minlun;
+	u_int		maxlun;
+	int		found;
+	ahd_mode_state	saved_modes;
+
+	/* restore this when we're done */
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+
+	found = ahd_search_qinfifo(ahd, target, channel, lun, SCB_LIST_NULL,
+				   role, CAM_REQUEUE_REQ, SEARCH_COMPLETE);
+
+	/*
+	 * Clean out the busy target table for any untagged commands.
+	 */
+	i = 0;
+	maxtarget = 16;
+	if (target != CAM_TARGET_WILDCARD) {
+		i = target;
+		if (channel == 'B')
+			i += 8;
+		maxtarget = i + 1;
+	}
+
+	if (lun == CAM_LUN_WILDCARD) {
+		minlun = 0;
+		maxlun = AHD_NUM_LUNS_NONPKT;
+	} else if (lun >= AHD_NUM_LUNS_NONPKT) {
+		minlun = maxlun = 0;
+	} else {
+		minlun = lun;
+		maxlun = lun + 1;
+	}
+
+	if (role != ROLE_TARGET) {
+		for (;i < maxtarget; i++) {
+			for (j = minlun;j < maxlun; j++) {
+				u_int scbid;
+				u_int tcl;
+
+				tcl = BUILD_TCL_RAW(i, 'A', j);
+				scbid = ahd_find_busy_tcl(ahd, tcl);
+				scbp = ahd_lookup_scb(ahd, scbid);
+				if (scbp == NULL
+				 || ahd_match_scb(ahd, scbp, target, channel,
+						  lun, tag, role) == 0)
+					continue;
+				ahd_unbusy_tcl(ahd, BUILD_TCL_RAW(i, 'A', j));
+			}
+		}
+	}
+
+	/*
+	 * Don't abort commands that have already completed,
+	 * but haven't quite made it up to the host yet.
+	 */
+	ahd_flush_qoutfifo(ahd);
+
+	/*
+	 * Go through the pending CCB list and look for
+	 * commands for this target that are still active.
+	 * These are other tagged commands that were
+	 * disconnected when the reset occurred.
+	 */
+	scbp_next = LIST_FIRST(&ahd->pending_scbs);
+	while (scbp_next != NULL) {
+		scbp = scbp_next;
+		scbp_next = LIST_NEXT(scbp, pending_links);
+		if (ahd_match_scb(ahd, scbp, target, channel, lun, tag, role)) {
+			cam_status ostat;
+
+			ostat = ahd_get_transaction_status(scbp);
+			if (ostat == CAM_REQ_INPROG)
+				ahd_set_transaction_status(scbp, status);
+			if (ahd_get_transaction_status(scbp) != CAM_REQ_CMP)
+				ahd_freeze_scb(scbp);
+			if ((scbp->flags & SCB_ACTIVE) == 0)
+				printf("Inactive SCB on pending list\n");
+			ahd_done(ahd, scbp);
+			found++;
+		}
+	}
+	ahd_restore_modes(ahd, saved_modes);
+	ahd_platform_abort_scbs(ahd, target, channel, lun, tag, role, status);
+	ahd->flags |= AHD_UPDATE_PEND_CMDS;
+	return found;
+}
+
+static void
+ahd_reset_current_bus(struct ahd_softc *ahd)
+{
+	uint8_t scsiseq;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	ahd_outb(ahd, SIMODE1, ahd_inb(ahd, SIMODE1) & ~ENSCSIRST);
+	scsiseq = ahd_inb(ahd, SCSISEQ0) & ~(ENSELO|ENARBO|SCSIRSTO);
+	ahd_outb(ahd, SCSISEQ0, scsiseq | SCSIRSTO);
+	ahd_delay(AHD_BUSRESET_DELAY);
+	/* Turn off the bus reset */
+	ahd_outb(ahd, SCSISEQ0, scsiseq);
+	if ((ahd->bugs & AHD_SCSIRST_BUG) != 0) {
+		/*
+		 * 2A Razor #474
+		 * Certain chip state is not cleared for
+		 * SCSI bus resets that we initiate, so
+		 * we must reset the chip.
+		 */
+		ahd_delay(AHD_BUSRESET_DELAY);
+		ahd_reset(ahd, /*reinit*/TRUE);
+		ahd_intr_enable(ahd, /*enable*/TRUE);
+		AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	}
+
+	ahd_clear_intstat(ahd);
+}
+
+int
+ahd_reset_channel(struct ahd_softc *ahd, char channel, int initiate_reset)
+{
+	struct	ahd_devinfo devinfo;
+	u_int	initiator;
+	u_int	target;
+	u_int	max_scsiid;
+	int	found;
+	u_int	fifo;
+	u_int	next_fifo;
+
+	ahd->pending_device = NULL;
+
+	ahd_compile_devinfo(&devinfo,
+			    CAM_TARGET_WILDCARD,
+			    CAM_TARGET_WILDCARD,
+			    CAM_LUN_WILDCARD,
+			    channel, ROLE_UNKNOWN);
+	ahd_pause(ahd);
+
+	/* Make sure the sequencer is in a safe location. */
+	ahd_clear_critical_section(ahd);
+
+#if AHD_TARGET_MODE
+	if ((ahd->flags & AHD_TARGETROLE) != 0) {
+		ahd_run_tqinfifo(ahd, /*paused*/TRUE);
+	}
+#endif
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+
+	/*
+	 * Disable selections so no automatic hardware
+	 * functions will modify chip state.
+	 */
+	ahd_outb(ahd, SCSISEQ0, 0);
+	ahd_outb(ahd, SCSISEQ1, 0);
+
+	/*
+	 * Safely shut down our DMA engines.  Always start with
+	 * the FIFO that is not currently active (if any are
+	 * actively connected).
+	 */
+	next_fifo = fifo = ahd_inb(ahd, DFFSTAT) & CURRFIFO;
+	if (next_fifo > CURRFIFO_1)
+		/* If disconneced, arbitrarily start with FIFO1. */
+		next_fifo = fifo = 0;
+	do {
+		next_fifo ^= CURRFIFO_1;
+		ahd_set_modes(ahd, next_fifo, next_fifo);
+		ahd_outb(ahd, DFCNTRL,
+			 ahd_inb(ahd, DFCNTRL) & ~(SCSIEN|HDMAEN));
+		while ((ahd_inb(ahd, DFCNTRL) & HDMAENACK) != 0)
+			ahd_delay(10);
+		/*
+		 * Set CURRFIFO to the now inactive channel.
+		 */
+		ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+		ahd_outb(ahd, DFFSTAT, next_fifo);
+	} while (next_fifo != fifo);
+
+	/*
+	 * Reset the bus if we are initiating this reset
+	 */
+	ahd_clear_msg_state(ahd);
+	ahd_outb(ahd, SIMODE1,
+		 ahd_inb(ahd, SIMODE1) & ~(ENBUSFREE|ENSCSIRST|ENBUSFREE));
+
+	if (initiate_reset)
+		ahd_reset_current_bus(ahd);
+
+	ahd_clear_intstat(ahd);
+
+	/*
+	 * Clean up all the state information for the
+	 * pending transactions on this bus.
+	 */
+	found = ahd_abort_scbs(ahd, CAM_TARGET_WILDCARD, channel,
+			       CAM_LUN_WILDCARD, SCB_LIST_NULL,
+			       ROLE_UNKNOWN, CAM_SCSI_BUS_RESET);
+
+	/*
+	 * Cleanup anything left in the FIFOs.
+	 */
+	ahd_clear_fifo(ahd, 0);
+	ahd_clear_fifo(ahd, 1);
+
+	/*
+	 * Revert to async/narrow transfers until we renegotiate.
+	 */
+	max_scsiid = (ahd->features & AHD_WIDE) ? 15 : 7;
+	for (target = 0; target <= max_scsiid; target++) {
+
+		if (ahd->enabled_targets[target] == NULL)
+			continue;
+		for (initiator = 0; initiator <= max_scsiid; initiator++) {
+			struct ahd_devinfo devinfo;
+
+			ahd_compile_devinfo(&devinfo, target, initiator,
+					    CAM_LUN_WILDCARD,
+					    'A', ROLE_UNKNOWN);
+			ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+				      AHD_TRANS_CUR, /*paused*/TRUE);
+			ahd_set_syncrate(ahd, &devinfo, /*period*/0,
+					 /*offset*/0, /*ppr_options*/0,
+					 AHD_TRANS_CUR, /*paused*/TRUE);
+		}
+	}
+
+#ifdef AHD_TARGET_MODE
+	max_scsiid = (ahd->features & AHD_WIDE) ? 15 : 7;
+
+	/*
+	 * Send an immediate notify ccb to all target more peripheral
+	 * drivers affected by this action.
+	 */
+	for (target = 0; target <= max_scsiid; target++) {
+		struct ahd_tmode_tstate* tstate;
+		u_int lun;
+
+		tstate = ahd->enabled_targets[target];
+		if (tstate == NULL)
+			continue;
+		for (lun = 0; lun < AHD_NUM_LUNS; lun++) {
+			struct ahd_tmode_lstate* lstate;
+
+			lstate = tstate->enabled_luns[lun];
+			if (lstate == NULL)
+				continue;
+
+			ahd_queue_lstate_event(ahd, lstate, CAM_TARGET_WILDCARD,
+					       EVENT_TYPE_BUS_RESET, /*arg*/0);
+			ahd_send_lstate_events(ahd, lstate);
+		}
+	}
+#endif
+	/* Notify the XPT that a bus reset occurred */
+	ahd_send_async(ahd, devinfo.channel, CAM_TARGET_WILDCARD,
+		       CAM_LUN_WILDCARD, AC_BUS_RESET, NULL);
+	ahd_restart(ahd);
+	/*
+	 * Freeze the SIMQ until our poller can determine that
+	 * the bus reset has really gone away.  We set the initial
+	 * timer to 0 to have the check performed as soon as possible
+	 * from the timer context.
+	 */
+	if ((ahd->flags & AHD_RESET_POLL_ACTIVE) == 0) {
+		ahd->flags |= AHD_RESET_POLL_ACTIVE;
+		ahd_freeze_simq(ahd);
+		ahd_timer_reset(&ahd->reset_timer, 0, ahd_reset_poll, ahd);
+	}
+	return (found);
+}
+
+
+#define AHD_RESET_POLL_US 1000
+static void
+ahd_reset_poll(void *arg)
+{
+	struct	ahd_softc *ahd;
+	u_int	scsiseq1;
+	u_long	l;
+	u_long	s;
+	
+	ahd_list_lock(&l);
+	ahd = ahd_find_softc((struct ahd_softc *)arg);
+	if (ahd == NULL) {
+		printf("ahd_reset_poll: Instance %p no longer exists\n", arg);
+		ahd_list_unlock(&l);
+		return;
+	}
+	ahd_lock(ahd, &s);
+	ahd_pause(ahd);
+	ahd_update_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	ahd_outb(ahd, CLRSINT1, CLRSCSIRSTI);
+	if ((ahd_inb(ahd, SSTAT1) & SCSIRSTI) != 0) {
+		ahd_timer_reset(&ahd->reset_timer, AHD_RESET_POLL_US,
+				ahd_reset_poll, ahd);
+		ahd_unpause(ahd);
+		ahd_unlock(ahd, &s);
+		ahd_list_unlock(&l);
+		return;
+	}
+
+	/* Reset is now low.  Complete chip reinitialization. */
+	ahd_outb(ahd, SIMODE1, ahd_inb(ahd, SIMODE1) | ENSCSIRST);
+	scsiseq1 = ahd_inb(ahd, SCSISEQ_TEMPLATE);
+	ahd_outb(ahd, SCSISEQ1, scsiseq1 & (ENSELI|ENRSELI|ENAUTOATNP));
+	ahd_unpause(ahd);
+	ahd->flags &= ~AHD_RESET_POLL_ACTIVE;
+	ahd_unlock(ahd, &s);
+	ahd_release_simq(ahd);
+	ahd_list_unlock(&l);
+}
+
+/**************************** Statistics Processing ***************************/
+static void
+ahd_stat_timer(void *arg)
+{
+	struct	ahd_softc *ahd;
+	u_long	l;
+	u_long	s;
+	int	enint_coal;
+	
+	ahd_list_lock(&l);
+	ahd = ahd_find_softc((struct ahd_softc *)arg);
+	if (ahd == NULL) {
+		printf("ahd_stat_timer: Instance %p no longer exists\n", arg);
+		ahd_list_unlock(&l);
+		return;
+	}
+	ahd_lock(ahd, &s);
+
+	enint_coal = ahd->hs_mailbox & ENINT_COALESCE;
+	if (ahd->cmdcmplt_total > ahd->int_coalescing_threshold)
+		enint_coal |= ENINT_COALESCE;
+	else if (ahd->cmdcmplt_total < ahd->int_coalescing_stop_threshold)
+		enint_coal &= ~ENINT_COALESCE;
+
+	if (enint_coal != (ahd->hs_mailbox & ENINT_COALESCE)) {
+		ahd_enable_coalescing(ahd, enint_coal);
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_INT_COALESCING) != 0)
+			printf("%s: Interrupt coalescing "
+			       "now %sabled. Cmds %d\n",
+			       ahd_name(ahd),
+			       (enint_coal & ENINT_COALESCE) ? "en" : "dis",
+			       ahd->cmdcmplt_total);
+#endif
+	}
+
+	ahd->cmdcmplt_bucket = (ahd->cmdcmplt_bucket+1) & (AHD_STAT_BUCKETS-1);
+	ahd->cmdcmplt_total -= ahd->cmdcmplt_counts[ahd->cmdcmplt_bucket];
+	ahd->cmdcmplt_counts[ahd->cmdcmplt_bucket] = 0;
+	ahd_timer_reset(&ahd->stat_timer, AHD_STAT_UPDATE_US,
+			ahd_stat_timer, ahd);
+	ahd_unlock(ahd, &s);
+	ahd_list_unlock(&l);
+}
+
+/****************************** Status Processing *****************************/
+void
+ahd_handle_scb_status(struct ahd_softc *ahd, struct scb *scb)
+{
+	if (scb->hscb->shared_data.istatus.scsi_status != 0) {
+		ahd_handle_scsi_status(ahd, scb);
+	} else {
+		ahd_calc_residual(ahd, scb);
+		ahd_done(ahd, scb);
+	}
+}
+
+void
+ahd_handle_scsi_status(struct ahd_softc *ahd, struct scb *scb)
+{
+	struct hardware_scb *hscb;
+	u_int  qfreeze_cnt;
+
+	/*
+	 * The sequencer freezes its select-out queue
+	 * anytime a SCSI status error occurs.  We must
+	 * handle the error and decrement the QFREEZE count
+	 * to allow the sequencer to continue.
+	 */
+	hscb = scb->hscb; 
+
+	/* Freeze the queue until the client sees the error. */
+	ahd_freeze_devq(ahd, scb);
+	ahd_freeze_scb(scb);
+	qfreeze_cnt = ahd_inw(ahd, QFREEZE_COUNT);
+	if (qfreeze_cnt == 0) {
+		printf("%s: Bad status with 0 qfreeze count!\n", ahd_name(ahd));
+	} else {
+		qfreeze_cnt--;
+		ahd_outw(ahd, QFREEZE_COUNT, qfreeze_cnt);
+	}
+	if (qfreeze_cnt == 0)
+		ahd_outb(ahd, SEQ_FLAGS2,
+			 ahd_inb(ahd, SEQ_FLAGS2) & ~SELECTOUT_QFROZEN);
+
+	/* Don't want to clobber the original sense code */
+	if ((scb->flags & SCB_SENSE) != 0) {
+		/*
+		 * Clear the SCB_SENSE Flag and perform
+		 * a normal command completion.
+		 */
+		scb->flags &= ~SCB_SENSE;
+		ahd_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
+		ahd_done(ahd, scb);
+		return;
+	}
+	ahd_set_transaction_status(scb, CAM_SCSI_STATUS_ERROR);
+	ahd_set_scsi_status(scb, hscb->shared_data.istatus.scsi_status);
+	switch (hscb->shared_data.istatus.scsi_status) {
+	case STATUS_PKT_SENSE:
+	{
+		struct scsi_status_iu_header *siu;
+
+		ahd_sync_sense(ahd, scb, BUS_DMASYNC_POSTREAD);
+		siu = (struct scsi_status_iu_header *)scb->sense_data;
+		ahd_set_scsi_status(scb, siu->status);
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_SENSE) != 0) {
+			ahd_print_path(ahd, scb);
+			printf("SCB 0x%x Received PKT Status of 0x%x\n",
+			       SCB_GET_TAG(scb), siu->status);
+			printf("\tflags = 0x%x, sense len = 0x%x, "
+			       "pktfail = 0x%x\n",
+			       siu->flags, scsi_4btoul(siu->sense_length),
+			       scsi_4btoul(siu->pkt_failures_length));
+		}
+#endif
+		if ((siu->flags & SIU_RSPVALID) != 0) {
+			ahd_print_path(ahd, scb);
+			if (scsi_4btoul(siu->pkt_failures_length) < 4) {
+				printf("Unable to parse pkt_failures\n");
+			} else {
+
+				switch (SIU_PKTFAIL_CODE(siu)) {
+				case SIU_PFC_NONE:
+					printf("No packet failure found\n");
+					break;
+				case SIU_PFC_CIU_FIELDS_INVALID:
+					printf("Invalid Command IU Field\n");
+					break;
+				case SIU_PFC_TMF_NOT_SUPPORTED:
+					printf("TMF not supportd\n");
+					break;
+				case SIU_PFC_TMF_FAILED:
+					printf("TMF failed\n");
+					break;
+				case SIU_PFC_INVALID_TYPE_CODE:
+					printf("Invalid L_Q Type code\n");
+					break;
+				case SIU_PFC_ILLEGAL_REQUEST:
+					printf("Illegal request\n");
+				default:
+					break;
+				}
+			}
+			if (siu->status == SCSI_STATUS_OK)
+				ahd_set_transaction_status(scb,
+							   CAM_REQ_CMP_ERR);
+		}
+		if ((siu->flags & SIU_SNSVALID) != 0) {
+			scb->flags |= SCB_PKT_SENSE;
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_SENSE) != 0)
+				printf("Sense data available\n");
+#endif
+		}
+		ahd_done(ahd, scb);
+		break;
+	}
+	case SCSI_STATUS_CMD_TERMINATED:
+	case SCSI_STATUS_CHECK_COND:
+	{
+		struct ahd_devinfo devinfo;
+		struct ahd_dma_seg *sg;
+		struct scsi_sense *sc;
+		struct ahd_initiator_tinfo *targ_info;
+		struct ahd_tmode_tstate *tstate;
+		struct ahd_transinfo *tinfo;
+#ifdef AHD_DEBUG
+		if (ahd_debug & AHD_SHOW_SENSE) {
+			ahd_print_path(ahd, scb);
+			printf("SCB %d: requests Check Status\n",
+			       SCB_GET_TAG(scb));
+		}
+#endif
+
+		if (ahd_perform_autosense(scb) == 0)
+			break;
+
+		ahd_compile_devinfo(&devinfo, SCB_GET_OUR_ID(scb),
+				    SCB_GET_TARGET(ahd, scb),
+				    SCB_GET_LUN(scb),
+				    SCB_GET_CHANNEL(ahd, scb),
+				    ROLE_INITIATOR);
+		targ_info = ahd_fetch_transinfo(ahd,
+						devinfo.channel,
+						devinfo.our_scsiid,
+						devinfo.target,
+						&tstate);
+		tinfo = &targ_info->curr;
+		sg = scb->sg_list;
+		sc = (struct scsi_sense *)hscb->shared_data.idata.cdb;
+		/*
+		 * Save off the residual if there is one.
+		 */
+		ahd_update_residual(ahd, scb);
+#ifdef AHD_DEBUG
+		if (ahd_debug & AHD_SHOW_SENSE) {
+			ahd_print_path(ahd, scb);
+			printf("Sending Sense\n");
+		}
+#endif
+		scb->sg_count = 0;
+		sg = ahd_sg_setup(ahd, scb, sg, ahd_get_sense_bufaddr(ahd, scb),
+				  ahd_get_sense_bufsize(ahd, scb),
+				  /*last*/TRUE);
+		sc->opcode = REQUEST_SENSE;
+		sc->byte2 = 0;
+		if (tinfo->protocol_version <= SCSI_REV_2
+		 && SCB_GET_LUN(scb) < 8)
+			sc->byte2 = SCB_GET_LUN(scb) << 5;
+		sc->unused[0] = 0;
+		sc->unused[1] = 0;
+		sc->length = ahd_get_sense_bufsize(ahd, scb);
+		sc->control = 0;
+
+		/*
+		 * We can't allow the target to disconnect.
+		 * This will be an untagged transaction and
+		 * having the target disconnect will make this
+		 * transaction indestinguishable from outstanding
+		 * tagged transactions.
+		 */
+		hscb->control = 0;
+
+		/*
+		 * This request sense could be because the
+		 * the device lost power or in some other
+		 * way has lost our transfer negotiations.
+		 * Renegotiate if appropriate.  Unit attention
+		 * errors will be reported before any data
+		 * phases occur.
+		 */
+		if (ahd_get_residual(scb) == ahd_get_transfer_length(scb)) {
+			ahd_update_neg_request(ahd, &devinfo,
+					       tstate, targ_info,
+					       AHD_NEG_IF_NON_ASYNC);
+		}
+		if (tstate->auto_negotiate & devinfo.target_mask) {
+			hscb->control |= MK_MESSAGE;
+			scb->flags &=
+			    ~(SCB_NEGOTIATE|SCB_ABORT|SCB_DEVICE_RESET);
+			scb->flags |= SCB_AUTO_NEGOTIATE;
+		}
+		hscb->cdb_len = sizeof(*sc);
+		ahd_setup_data_scb(ahd, scb);
+		scb->flags |= SCB_SENSE;
+		ahd_queue_scb(ahd, scb);
+		/*
+		 * Ensure we have enough time to actually
+		 * retrieve the sense.
+		 */
+		ahd_scb_timer_reset(scb, 5 * 1000000);
+		break;
+	}
+	case SCSI_STATUS_OK:
+		printf("%s: Interrupted for staus of 0???\n",
+		       ahd_name(ahd));
+		/* FALLTHROUGH */
+	default:
+		ahd_done(ahd, scb);
+		break;
+	}
+}
+
+/*
+ * Calculate the residual for a just completed SCB.
+ */
+void
+ahd_calc_residual(struct ahd_softc *ahd, struct scb *scb)
+{
+	struct hardware_scb *hscb;
+	struct initiator_status *spkt;
+	uint32_t sgptr;
+	uint32_t resid_sgptr;
+	uint32_t resid;
+
+	/*
+	 * 5 cases.
+	 * 1) No residual.
+	 *    SG_STATUS_VALID clear in sgptr.
+	 * 2) Transferless command
+	 * 3) Never performed any transfers.
+	 *    sgptr has SG_FULL_RESID set.
+	 * 4) No residual but target did not
+	 *    save data pointers after the
+	 *    last transfer, so sgptr was
+	 *    never updated.
+	 * 5) We have a partial residual.
+	 *    Use residual_sgptr to determine
+	 *    where we are.
+	 */
+
+	hscb = scb->hscb;
+	sgptr = ahd_le32toh(hscb->sgptr);
+	if ((sgptr & SG_STATUS_VALID) == 0)
+		/* Case 1 */
+		return;
+	sgptr &= ~SG_STATUS_VALID;
+
+	if ((sgptr & SG_LIST_NULL) != 0)
+		/* Case 2 */
+		return;
+
+	/*
+	 * Residual fields are the same in both
+	 * target and initiator status packets,
+	 * so we can always use the initiator fields
+	 * regardless of the role for this SCB.
+	 */
+	spkt = &hscb->shared_data.istatus;
+	resid_sgptr = ahd_le32toh(spkt->residual_sgptr);
+	if ((sgptr & SG_FULL_RESID) != 0) {
+		/* Case 3 */
+		resid = ahd_get_transfer_length(scb);
+	} else if ((resid_sgptr & SG_LIST_NULL) != 0) {
+		/* Case 4 */
+		return;
+	} else if ((resid_sgptr & SG_OVERRUN_RESID) != 0) {
+		ahd_print_path(ahd, scb);
+		printf("data overrun detected Tag == 0x%x.\n",
+		       SCB_GET_TAG(scb));
+		ahd_freeze_devq(ahd, scb);
+		ahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);
+		ahd_freeze_scb(scb);
+		return;
+	} else if ((resid_sgptr & ~SG_PTR_MASK) != 0) {
+		panic("Bogus resid sgptr value 0x%x\n", resid_sgptr);
+		/* NOTREACHED */
+	} else {
+		struct ahd_dma_seg *sg;
+
+		/*
+		 * Remainder of the SG where the transfer
+		 * stopped.  
+		 */
+		resid = ahd_le32toh(spkt->residual_datacnt) & AHD_SG_LEN_MASK;
+		sg = ahd_sg_bus_to_virt(ahd, scb, resid_sgptr & SG_PTR_MASK);
+
+		/* The residual sg_ptr always points to the next sg */
+		sg--;
+
+		/*
+		 * Add up the contents of all residual
+		 * SG segments that are after the SG where
+		 * the transfer stopped.
+		 */
+		while ((ahd_le32toh(sg->len) & AHD_DMA_LAST_SEG) == 0) {
+			sg++;
+			resid += ahd_le32toh(sg->len) & AHD_SG_LEN_MASK;
+		}
+	}
+	if ((scb->flags & SCB_SENSE) == 0)
+		ahd_set_residual(scb, resid);
+	else
+		ahd_set_sense_residual(scb, resid);
+
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_MISC) != 0) {
+		ahd_print_path(ahd, scb);
+		printf("Handled %sResidual of %d bytes\n",
+		       (scb->flags & SCB_SENSE) ? "Sense " : "", resid);
+	}
+#endif
+}
+
+/******************************* Target Mode **********************************/
+#ifdef AHD_TARGET_MODE
+/*
+ * Add a target mode event to this lun's queue
+ */
+static void
+ahd_queue_lstate_event(struct ahd_softc *ahd, struct ahd_tmode_lstate *lstate,
+		       u_int initiator_id, u_int event_type, u_int event_arg)
+{
+	struct ahd_tmode_event *event;
+	int pending;
+
+	xpt_freeze_devq(lstate->path, /*count*/1);
+	if (lstate->event_w_idx >= lstate->event_r_idx)
+		pending = lstate->event_w_idx - lstate->event_r_idx;
+	else
+		pending = AHD_TMODE_EVENT_BUFFER_SIZE + 1
+			- (lstate->event_r_idx - lstate->event_w_idx);
+
+	if (event_type == EVENT_TYPE_BUS_RESET
+	 || event_type == MSG_BUS_DEV_RESET) {
+		/*
+		 * Any earlier events are irrelevant, so reset our buffer.
+		 * This has the effect of allowing us to deal with reset
+		 * floods (an external device holding down the reset line)
+		 * without losing the event that is really interesting.
+		 */
+		lstate->event_r_idx = 0;
+		lstate->event_w_idx = 0;
+		xpt_release_devq(lstate->path, pending, /*runqueue*/FALSE);
+	}
+
+	if (pending == AHD_TMODE_EVENT_BUFFER_SIZE) {
+		xpt_print_path(lstate->path);
+		printf("immediate event %x:%x lost\n",
+		       lstate->event_buffer[lstate->event_r_idx].event_type,
+		       lstate->event_buffer[lstate->event_r_idx].event_arg);
+		lstate->event_r_idx++;
+		if (lstate->event_r_idx == AHD_TMODE_EVENT_BUFFER_SIZE)
+			lstate->event_r_idx = 0;
+		xpt_release_devq(lstate->path, /*count*/1, /*runqueue*/FALSE);
+	}
+
+	event = &lstate->event_buffer[lstate->event_w_idx];
+	event->initiator_id = initiator_id;
+	event->event_type = event_type;
+	event->event_arg = event_arg;
+	lstate->event_w_idx++;
+	if (lstate->event_w_idx == AHD_TMODE_EVENT_BUFFER_SIZE)
+		lstate->event_w_idx = 0;
+}
+
+/*
+ * Send any target mode events queued up waiting
+ * for immediate notify resources.
+ */
+void
+ahd_send_lstate_events(struct ahd_softc *ahd, struct ahd_tmode_lstate *lstate)
+{
+	struct ccb_hdr *ccbh;
+	struct ccb_immed_notify *inot;
+
+	while (lstate->event_r_idx != lstate->event_w_idx
+	    && (ccbh = SLIST_FIRST(&lstate->immed_notifies)) != NULL) {
+		struct ahd_tmode_event *event;
+
+		event = &lstate->event_buffer[lstate->event_r_idx];
+		SLIST_REMOVE_HEAD(&lstate->immed_notifies, sim_links.sle);
+		inot = (struct ccb_immed_notify *)ccbh;
+		switch (event->event_type) {
+		case EVENT_TYPE_BUS_RESET:
+			ccbh->status = CAM_SCSI_BUS_RESET|CAM_DEV_QFRZN;
+			break;
+		default:
+			ccbh->status = CAM_MESSAGE_RECV|CAM_DEV_QFRZN;
+			inot->message_args[0] = event->event_type;
+			inot->message_args[1] = event->event_arg;
+			break;
+		}
+		inot->initiator_id = event->initiator_id;
+		inot->sense_len = 0;
+		xpt_done((union ccb *)inot);
+		lstate->event_r_idx++;
+		if (lstate->event_r_idx == AHD_TMODE_EVENT_BUFFER_SIZE)
+			lstate->event_r_idx = 0;
+	}
+}
+#endif
+
+/******************** Sequencer Program Patching/Download *********************/
+
+#ifdef AHD_DUMP_SEQ
+void
+ahd_dumpseq(struct ahd_softc* ahd)
+{
+	int i;
+	int max_prog;
+
+	max_prog = 2048;
+
+	ahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
+	ahd_outb(ahd, PRGMCNT, 0);
+	ahd_outb(ahd, PRGMCNT+1, 0);
+	for (i = 0; i < max_prog; i++) {
+		uint8_t ins_bytes[4];
+
+		ahd_insb(ahd, SEQRAM, ins_bytes, 4);
+		printf("0x%08x\n", ins_bytes[0] << 24
+				 | ins_bytes[1] << 16
+				 | ins_bytes[2] << 8
+				 | ins_bytes[3]);
+	}
+}
+#endif
+
+static void
+ahd_loadseq(struct ahd_softc *ahd)
+{
+	struct	cs cs_table[num_critical_sections];
+	u_int	begin_set[num_critical_sections];
+	u_int	end_set[num_critical_sections];
+	struct	patch *cur_patch;
+	u_int	cs_count;
+	u_int	cur_cs;
+	u_int	i;
+	int	downloaded;
+	u_int	skip_addr;
+	u_int	sg_prefetch_cnt;
+	u_int	sg_prefetch_cnt_limit;
+	u_int	sg_prefetch_align;
+	u_int	sg_size;
+	uint8_t	download_consts[DOWNLOAD_CONST_COUNT];
+
+	if (bootverbose)
+		printf("%s: Downloading Sequencer Program...",
+		       ahd_name(ahd));
+
+#if DOWNLOAD_CONST_COUNT != 7
+#error "Download Const Mismatch"
+#endif
+	/*
+	 * Start out with 0 critical sections
+	 * that apply to this firmware load.
+	 */
+	cs_count = 0;
+	cur_cs = 0;
+	memset(begin_set, 0, sizeof(begin_set));
+	memset(end_set, 0, sizeof(end_set));
+
+	/*
+	 * Setup downloadable constant table.
+	 * 
+	 * The computation for the S/G prefetch variables is
+	 * a bit complicated.  We would like to always fetch
+	 * in terms of cachelined sized increments.  However,
+	 * if the cacheline is not an even multiple of the
+	 * SG element size or is larger than our SG RAM, using
+	 * just the cache size might leave us with only a portion
+	 * of an SG element at the tail of a prefetch.  If the
+	 * cacheline is larger than our S/G prefetch buffer less
+	 * the size of an SG element, we may round down to a cacheline
+	 * that doesn't contain any or all of the S/G of interest
+	 * within the bounds of our S/G ram.  Provide variables to
+	 * the sequencer that will allow it to handle these edge
+	 * cases.
+	 */
+	/* Start by aligning to the nearest cacheline. */
+	sg_prefetch_align = ahd->pci_cachesize;
+	if (sg_prefetch_align == 0)
+		sg_prefetch_align = 8;
+	/* Round down to the nearest power of 2. */
+	while (powerof2(sg_prefetch_align) == 0)
+		sg_prefetch_align--;
+	/*
+	 * If the cacheline boundary is greater than half our prefetch RAM
+	 * we risk not being able to fetch even a single complete S/G
+	 * segment if we align to that boundary.
+	 */
+	if (sg_prefetch_align > CCSGADDR_MAX/2)
+		sg_prefetch_align = CCSGADDR_MAX/2;
+	/* Start by fetching a single cacheline. */
+	sg_prefetch_cnt = sg_prefetch_align;
+	/*
+	 * Increment the prefetch count by cachelines until
+	 * at least one S/G element will fit.
+	 */
+	sg_size = sizeof(struct ahd_dma_seg);
+	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)
+		sg_size = sizeof(struct ahd_dma64_seg);
+	while (sg_prefetch_cnt < sg_size)
+		sg_prefetch_cnt += sg_prefetch_align;
+	/*
+	 * If the cacheline is not an even multiple of
+	 * the S/G size, we may only get a partial S/G when
+	 * we align. Add a cacheline if this is the case.
+	 */
+	if ((sg_prefetch_align % sg_size) != 0
+	 && (sg_prefetch_cnt < CCSGADDR_MAX))
+		sg_prefetch_cnt += sg_prefetch_align;
+	/*
+	 * Lastly, compute a value that the sequencer can use
+	 * to determine if the remainder of the CCSGRAM buffer
+	 * has a full S/G element in it.
+	 */
+	sg_prefetch_cnt_limit = -(sg_prefetch_cnt - sg_size + 1);
+	download_consts[SG_PREFETCH_CNT] = sg_prefetch_cnt;
+	download_consts[SG_PREFETCH_CNT_LIMIT] = sg_prefetch_cnt_limit;
+	download_consts[SG_PREFETCH_ALIGN_MASK] = ~(sg_prefetch_align - 1);
+	download_consts[SG_PREFETCH_ADDR_MASK] = (sg_prefetch_align - 1);
+	download_consts[SG_SIZEOF] = sg_size;
+	download_consts[PKT_OVERRUN_BUFOFFSET] =
+		(ahd->overrun_buf - (uint8_t *)ahd->qoutfifo) / 256;
+	download_consts[SCB_TRANSFER_SIZE] = SCB_TRANSFER_SIZE_1BYTE_LUN;
+	cur_patch = patches;
+	downloaded = 0;
+	skip_addr = 0;
+	ahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
+	ahd_outb(ahd, PRGMCNT, 0);
+	ahd_outb(ahd, PRGMCNT+1, 0);
+
+	for (i = 0; i < sizeof(seqprog)/4; i++) {
+		if (ahd_check_patch(ahd, &cur_patch, i, &skip_addr) == 0) {
+			/*
+			 * Don't download this instruction as it
+			 * is in a patch that was removed.
+			 */
+			continue;
+		}
+		/*
+		 * Move through the CS table until we find a CS
+		 * that might apply to this instruction.
+		 */
+		for (; cur_cs < num_critical_sections; cur_cs++) {
+			if (critical_sections[cur_cs].end <= i) {
+				if (begin_set[cs_count] == TRUE
+				 && end_set[cs_count] == FALSE) {
+					cs_table[cs_count].end = downloaded;
+				 	end_set[cs_count] = TRUE;
+					cs_count++;
+				}
+				continue;
+			}
+			if (critical_sections[cur_cs].begin <= i
+			 && begin_set[cs_count] == FALSE) {
+				cs_table[cs_count].begin = downloaded;
+				begin_set[cs_count] = TRUE;
+			}
+			break;
+		}
+		ahd_download_instr(ahd, i, download_consts);
+		downloaded++;
+	}
+
+	ahd->num_critical_sections = cs_count;
+	if (cs_count != 0) {
+
+		cs_count *= sizeof(struct cs);
+		ahd->critical_sections = malloc(cs_count, M_DEVBUF, M_NOWAIT);
+		if (ahd->critical_sections == NULL)
+			panic("ahd_loadseq: Could not malloc");
+		memcpy(ahd->critical_sections, cs_table, cs_count);
+	}
+	ahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS|FASTMODE);
+
+	if (bootverbose) {
+		printf(" %d instructions downloaded\n", downloaded);
+		printf("%s: Features 0x%x, Bugs 0x%x, Flags 0x%x\n",
+		       ahd_name(ahd), ahd->features, ahd->bugs, ahd->flags);
+	}
+}
+
+static int
+ahd_check_patch(struct ahd_softc *ahd, struct patch **start_patch,
+		u_int start_instr, u_int *skip_addr)
+{
+	struct	patch *cur_patch;
+	struct	patch *last_patch;
+	u_int	num_patches;
+
+	num_patches = sizeof(patches)/sizeof(struct patch);
+	last_patch = &patches[num_patches];
+	cur_patch = *start_patch;
+
+	while (cur_patch < last_patch && start_instr == cur_patch->begin) {
+
+		if (cur_patch->patch_func(ahd) == 0) {
+
+			/* Start rejecting code */
+			*skip_addr = start_instr + cur_patch->skip_instr;
+			cur_patch += cur_patch->skip_patch;
+		} else {
+			/* Accepted this patch.  Advance to the next
+			 * one and wait for our intruction pointer to
+			 * hit this point.
+			 */
+			cur_patch++;
+		}
+	}
+
+	*start_patch = cur_patch;
+	if (start_instr < *skip_addr)
+		/* Still skipping */
+		return (0);
+
+	return (1);
+}
+
+static u_int
+ahd_resolve_seqaddr(struct ahd_softc *ahd, u_int address)
+{
+	struct patch *cur_patch;
+	int address_offset;
+	u_int skip_addr;
+	u_int i;
+
+	address_offset = 0;
+	cur_patch = patches;
+	skip_addr = 0;
+
+	for (i = 0; i < address;) {
+
+		ahd_check_patch(ahd, &cur_patch, i, &skip_addr);
+
+		if (skip_addr > i) {
+			int end_addr;
+
+			end_addr = MIN(address, skip_addr);
+			address_offset += end_addr - i;
+			i = skip_addr;
+		} else {
+			i++;
+		}
+	}
+	return (address - address_offset);
+}
+
+static void
+ahd_download_instr(struct ahd_softc *ahd, u_int instrptr, uint8_t *dconsts)
+{
+	union	ins_formats instr;
+	struct	ins_format1 *fmt1_ins;
+	struct	ins_format3 *fmt3_ins;
+	u_int	opcode;
+
+	/*
+	 * The firmware is always compiled into a little endian format.
+	 */
+	instr.integer = ahd_le32toh(*(uint32_t*)&seqprog[instrptr * 4]);
+
+	fmt1_ins = &instr.format1;
+	fmt3_ins = NULL;
+
+	/* Pull the opcode */
+	opcode = instr.format1.opcode;
+	switch (opcode) {
+	case AIC_OP_JMP:
+	case AIC_OP_JC:
+	case AIC_OP_JNC:
+	case AIC_OP_CALL:
+	case AIC_OP_JNE:
+	case AIC_OP_JNZ:
+	case AIC_OP_JE:
+	case AIC_OP_JZ:
+	{
+		fmt3_ins = &instr.format3;
+		fmt3_ins->address = ahd_resolve_seqaddr(ahd, fmt3_ins->address);
+		/* FALLTHROUGH */
+	}
+	case AIC_OP_OR:
+	case AIC_OP_AND:
+	case AIC_OP_XOR:
+	case AIC_OP_ADD:
+	case AIC_OP_ADC:
+	case AIC_OP_BMOV:
+		if (fmt1_ins->parity != 0) {
+			fmt1_ins->immediate = dconsts[fmt1_ins->immediate];
+		}
+		fmt1_ins->parity = 0;
+		/* FALLTHROUGH */
+	case AIC_OP_ROL:
+	{
+		int i, count;
+
+		/* Calculate odd parity for the instruction */
+		for (i = 0, count = 0; i < 31; i++) {
+			uint32_t mask;
+
+			mask = 0x01 << i;
+			if ((instr.integer & mask) != 0)
+				count++;
+		}
+		if ((count & 0x01) == 0)
+			instr.format1.parity = 1;
+
+		/* The sequencer is a little endian cpu */
+		instr.integer = ahd_htole32(instr.integer);
+		ahd_outsb(ahd, SEQRAM, instr.bytes, 4);
+		break;
+	}
+	default:
+		panic("Unknown opcode encountered in seq program");
+		break;
+	}
+}
+
+static int
+ahd_probe_stack_size(struct ahd_softc *ahd)
+{
+	int last_probe;
+
+	last_probe = 0;
+	while (1) {
+		int i;
+
+		/*
+		 * We avoid using 0 as a pattern to avoid
+		 * confusion if the stack implementation
+		 * "back-fills" with zeros when "poping'
+		 * entries.
+		 */
+		for (i = 1; i <= last_probe+1; i++) {
+		       ahd_outb(ahd, STACK, i & 0xFF);
+		       ahd_outb(ahd, STACK, (i >> 8) & 0xFF);
+		}
+
+		/* Verify */
+		for (i = last_probe+1; i > 0; i--) {
+			u_int stack_entry;
+
+			stack_entry = ahd_inb(ahd, STACK)
+				    |(ahd_inb(ahd, STACK) << 8);
+			if (stack_entry != i)
+				goto sized;
+		}
+		last_probe++;
+	}
+sized:
+	return (last_probe);
+}
+
+void
+ahd_dump_all_cards_state(void)
+{
+	struct ahd_softc *list_ahd;
+
+	TAILQ_FOREACH(list_ahd, &ahd_tailq, links) {
+		ahd_dump_card_state(list_ahd);
+	}
+}
+
+int
+ahd_print_register(ahd_reg_parse_entry_t *table, u_int num_entries,
+		   const char *name, u_int address, u_int value,
+		   u_int *cur_column, u_int wrap_point)
+{
+	int	printed;
+	u_int	printed_mask;
+
+	if (cur_column != NULL && *cur_column >= wrap_point) {
+		printf("\n");
+		*cur_column = 0;
+	}
+	printed = printf("%s[0x%x]", name, value);
+	if (table == NULL) {
+		printed += printf(" ");
+		*cur_column += printed;
+		return (printed);
+	}
+	printed_mask = 0;
+	while (printed_mask != 0xFF) {
+		int entry;
+
+		for (entry = 0; entry < num_entries; entry++) {
+			if (((value & table[entry].mask)
+			  != table[entry].value)
+			 || ((printed_mask & table[entry].mask)
+			  == table[entry].mask))
+				continue;
+
+			printed += printf("%s%s",
+					  printed_mask == 0 ? ":(" : "|",
+					  table[entry].name);
+			printed_mask |= table[entry].mask;
+			
+			break;
+		}
+		if (entry >= num_entries)
+			break;
+	}
+	if (printed_mask != 0)
+		printed += printf(") ");
+	else
+		printed += printf(" ");
+	if (cur_column != NULL)
+		*cur_column += printed;
+	return (printed);
+}
+
+void
+ahd_dump_card_state(struct ahd_softc *ahd)
+{
+	struct scb	*scb;
+	ahd_mode_state	 saved_modes;
+	u_int		 dffstat;
+	int		 paused;
+	u_int		 scb_index;
+	u_int		 saved_scb_index;
+	u_int		 cur_col;
+	int		 i;
+
+	if (ahd_is_paused(ahd)) {
+		paused = 1;
+	} else {
+		paused = 0;
+		ahd_pause(ahd);
+	}
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	printf(">>>>>>>>>>>>>>>>>> Dump Card State Begins <<<<<<<<<<<<<<<<<\n"
+	       "%s: Dumping Card State at program address 0x%x Mode 0x%x\n",
+	       ahd_name(ahd), 
+	       ahd_inb(ahd, CURADDR) | (ahd_inb(ahd, CURADDR+1) << 8),
+	       ahd_build_mode_state(ahd, ahd->saved_src_mode,
+				    ahd->saved_dst_mode));
+	if (paused)
+		printf("Card was paused\n");
+	/*
+	 * Mode independent registers.
+	 */
+	cur_col = 0;
+	ahd_hs_mailbox_print(ahd_inb(ahd, LOCAL_HS_MAILBOX), &cur_col, 50);
+	ahd_intctl_print(ahd_inb(ahd, INTCTL), &cur_col, 50);
+	ahd_seqintstat_print(ahd_inb(ahd, SEQINTSTAT), &cur_col, 50);
+	ahd_saved_mode_print(ahd_inb(ahd, SAVED_MODE), &cur_col, 50);
+	ahd_dffstat_print(ahd_inb(ahd, DFFSTAT), &cur_col, 50);
+	ahd_scsisigi_print(ahd_inb(ahd, SCSISIGI), &cur_col, 50);
+	ahd_scsiphase_print(ahd_inb(ahd, SCSIPHASE), &cur_col, 50);
+	ahd_scsibus_print(ahd_inb(ahd, SCSIBUS), &cur_col, 50);
+	ahd_lastphase_print(ahd_inb(ahd, LASTPHASE), &cur_col, 50);
+	ahd_scsiseq0_print(ahd_inb(ahd, SCSISEQ0), &cur_col, 50);
+	ahd_scsiseq1_print(ahd_inb(ahd, SCSISEQ1), &cur_col, 50);
+	ahd_seqctl0_print(ahd_inb(ahd, SEQCTL0), &cur_col, 50);
+	ahd_seqintctl_print(ahd_inb(ahd, SEQINTCTL), &cur_col, 50);
+	ahd_seq_flags_print(ahd_inb(ahd, SEQ_FLAGS), &cur_col, 50);
+	ahd_seq_flags2_print(ahd_inb(ahd, SEQ_FLAGS2), &cur_col, 50);
+	ahd_sstat0_print(ahd_inb(ahd, SSTAT0), &cur_col, 50);
+	ahd_sstat1_print(ahd_inb(ahd, SSTAT1), &cur_col, 50);
+	ahd_sstat2_print(ahd_inb(ahd, SSTAT2), &cur_col, 50);
+	ahd_sstat3_print(ahd_inb(ahd, SSTAT3), &cur_col, 50);
+	ahd_perrdiag_print(ahd_inb(ahd, PERRDIAG), &cur_col, 50);
+	ahd_simode1_print(ahd_inb(ahd, SIMODE1), &cur_col, 50);
+	ahd_lqistat0_print(ahd_inb(ahd, LQISTAT0), &cur_col, 50);
+	ahd_lqistat1_print(ahd_inb(ahd, LQISTAT1), &cur_col, 50);
+	ahd_lqistat2_print(ahd_inb(ahd, LQISTAT2), &cur_col, 50);
+	ahd_lqostat0_print(ahd_inb(ahd, LQOSTAT0), &cur_col, 50);
+	ahd_lqostat1_print(ahd_inb(ahd, LQOSTAT1), &cur_col, 50);
+	ahd_lqostat2_print(ahd_inb(ahd, LQOSTAT2), &cur_col, 50);
+	printf("\n");
+	printf("\nSCB Count = %d CMDS_PENDING = %d LASTSCB 0x%x "
+	       "CURRSCB 0x%x NEXTSCB 0x%x\n",
+	       ahd->scb_data.numscbs, ahd_inw(ahd, CMDS_PENDING),
+	       ahd_inw(ahd, LASTSCB), ahd_inw(ahd, CURRSCB),
+	       ahd_inw(ahd, NEXTSCB));
+	cur_col = 0;
+	/* QINFIFO */
+	ahd_search_qinfifo(ahd, CAM_TARGET_WILDCARD, ALL_CHANNELS,
+			   CAM_LUN_WILDCARD, SCB_LIST_NULL,
+			   ROLE_UNKNOWN, /*status*/0, SEARCH_PRINT);
+	saved_scb_index = ahd_get_scbptr(ahd);
+	printf("Pending list:");
+	i = 0;
+	LIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {
+		if (i++ > AHD_SCB_MAX)
+			break;
+		cur_col = printf("\n%3d FIFO_USE[0x%x] ", SCB_GET_TAG(scb),
+				 ahd_inb(ahd, SCB_FIFO_USE_COUNT));
+		ahd_set_scbptr(ahd, SCB_GET_TAG(scb));
+		ahd_scb_control_print(ahd_inb(ahd, SCB_CONTROL), &cur_col, 60);
+		ahd_scb_scsiid_print(ahd_inb(ahd, SCB_SCSIID), &cur_col, 60);
+	}
+	printf("\nTotal %d\n", i);
+
+	printf("Kernel Free SCB list: ");
+	i = 0;
+	TAILQ_FOREACH(scb, &ahd->scb_data.free_scbs, links.tqe) {
+		struct scb *list_scb;
+
+		list_scb = scb;
+		do {
+			printf("%d ", SCB_GET_TAG(list_scb));
+			list_scb = LIST_NEXT(list_scb, collision_links);
+		} while (list_scb && i++ < AHD_SCB_MAX);
+	}
+
+	LIST_FOREACH(scb, &ahd->scb_data.any_dev_free_scb_list, links.le) {
+		if (i++ > AHD_SCB_MAX)
+			break;
+		printf("%d ", SCB_GET_TAG(scb));
+	}
+	printf("\n");
+
+	printf("Sequencer Complete DMA-inprog list: ");
+	scb_index = ahd_inw(ahd, COMPLETE_SCB_DMAINPROG_HEAD);
+	i = 0;
+	while (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {
+		ahd_set_scbptr(ahd, scb_index);
+		printf("%d ", scb_index);
+		scb_index = ahd_inw(ahd, SCB_NEXT_COMPLETE);
+	}
+	printf("\n");
+
+	printf("Sequencer Complete list: ");
+	scb_index = ahd_inw(ahd, COMPLETE_SCB_HEAD);
+	i = 0;
+	while (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {
+		ahd_set_scbptr(ahd, scb_index);
+		printf("%d ", scb_index);
+		scb_index = ahd_inw(ahd, SCB_NEXT_COMPLETE);
+	}
+	printf("\n");
+
+	
+	printf("Sequencer DMA-Up and Complete list: ");
+	scb_index = ahd_inw(ahd, COMPLETE_DMA_SCB_HEAD);
+	i = 0;
+	while (!SCBID_IS_NULL(scb_index) && i++ < AHD_SCB_MAX) {
+		ahd_set_scbptr(ahd, scb_index);
+		printf("%d ", scb_index);
+		scb_index = ahd_inw(ahd, SCB_NEXT_COMPLETE);
+	}
+	printf("\n");
+	ahd_set_scbptr(ahd, saved_scb_index);
+	dffstat = ahd_inb(ahd, DFFSTAT);
+	for (i = 0; i < 2; i++) {
+#ifdef AHD_DEBUG
+		struct scb *fifo_scb;
+#endif
+		u_int	    fifo_scbptr;
+
+		ahd_set_modes(ahd, AHD_MODE_DFF0 + i, AHD_MODE_DFF0 + i);
+		fifo_scbptr = ahd_get_scbptr(ahd);
+		printf("\n%s: FIFO%d %s, LONGJMP == 0x%x, SCB 0x%x\n",
+		       ahd_name(ahd), i,
+		       (dffstat & (FIFO0FREE << i)) ? "Free" : "Active",
+		       ahd_inw(ahd, LONGJMP_ADDR), fifo_scbptr);
+		cur_col = 0;
+		ahd_seqimode_print(ahd_inb(ahd, SEQIMODE), &cur_col, 50);
+		ahd_seqintsrc_print(ahd_inb(ahd, SEQINTSRC), &cur_col, 50);
+		ahd_dfcntrl_print(ahd_inb(ahd, DFCNTRL), &cur_col, 50);
+		ahd_dfstatus_print(ahd_inb(ahd, DFSTATUS), &cur_col, 50);
+		ahd_sg_cache_shadow_print(ahd_inb(ahd, SG_CACHE_SHADOW),
+					  &cur_col, 50);
+		ahd_sg_state_print(ahd_inb(ahd, SG_STATE), &cur_col, 50);
+		ahd_dffsxfrctl_print(ahd_inb(ahd, DFFSXFRCTL), &cur_col, 50);
+		ahd_soffcnt_print(ahd_inb(ahd, SOFFCNT), &cur_col, 50);
+		ahd_mdffstat_print(ahd_inb(ahd, MDFFSTAT), &cur_col, 50);
+		if (cur_col > 50) {
+			printf("\n");
+			cur_col = 0;
+		}
+		cur_col += printf("SHADDR = 0x%x%x, SHCNT = 0x%x ",
+				  ahd_inl(ahd, SHADDR+4),
+				  ahd_inl(ahd, SHADDR),
+				  (ahd_inb(ahd, SHCNT)
+				| (ahd_inb(ahd, SHCNT + 1) << 8)
+				| (ahd_inb(ahd, SHCNT + 2) << 16)));
+		if (cur_col > 50) {
+			printf("\n");
+			cur_col = 0;
+		}
+		cur_col += printf("HADDR = 0x%x%x, HCNT = 0x%x ",
+				  ahd_inl(ahd, HADDR+4),
+				  ahd_inl(ahd, HADDR),
+				  (ahd_inb(ahd, HCNT)
+				| (ahd_inb(ahd, HCNT + 1) << 8)
+				| (ahd_inb(ahd, HCNT + 2) << 16)));
+		ahd_ccsgctl_print(ahd_inb(ahd, CCSGCTL), &cur_col, 50);
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_SG) != 0) {
+			fifo_scb = ahd_lookup_scb(ahd, fifo_scbptr);
+			if (fifo_scb != NULL)
+				ahd_dump_sglist(fifo_scb);
+		}
+#endif
+	}
+	printf("\nLQIN: ");
+	for (i = 0; i < 20; i++)
+		printf("0x%x ", ahd_inb(ahd, LQIN + i));
+	printf("\n");
+	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+	printf("%s: LQISTATE = 0x%x, LQOSTATE = 0x%x, OPTIONMODE = 0x%x\n",
+	       ahd_name(ahd), ahd_inb(ahd, LQISTATE), ahd_inb(ahd, LQOSTATE),
+	       ahd_inb(ahd, OPTIONMODE));
+	printf("%s: OS_SPACE_CNT = 0x%x MAXCMDCNT = 0x%x\n",
+	       ahd_name(ahd), ahd_inb(ahd, OS_SPACE_CNT),
+	       ahd_inb(ahd, MAXCMDCNT));
+	ahd_simode0_print(ahd_inb(ahd, SIMODE0), &cur_col, 50);
+	printf("\n");
+	ahd_set_modes(ahd, AHD_MODE_CCHAN, AHD_MODE_CCHAN);
+	cur_col = 0;
+	ahd_ccscbctl_print(ahd_inb(ahd, CCSCBCTL), &cur_col, 50);
+	printf("\n");
+	ahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);
+	printf("%s: REG0 == 0x%x, SINDEX = 0x%x, DINDEX = 0x%x\n",
+	       ahd_name(ahd), ahd_inw(ahd, REG0), ahd_inw(ahd, SINDEX),
+	       ahd_inw(ahd, DINDEX));
+	printf("%s: SCBPTR == 0x%x, SCB_NEXT == 0x%x, SCB_NEXT2 == 0x%x\n",
+	       ahd_name(ahd), ahd_get_scbptr(ahd), ahd_inw(ahd, SCB_NEXT),
+	       ahd_inw(ahd, SCB_NEXT2));
+	printf("CDB %x %x %x %x %x %x\n",
+	       ahd_inb(ahd, SCB_CDB_STORE),
+	       ahd_inb(ahd, SCB_CDB_STORE+1),
+	       ahd_inb(ahd, SCB_CDB_STORE+2),
+	       ahd_inb(ahd, SCB_CDB_STORE+3),
+	       ahd_inb(ahd, SCB_CDB_STORE+4),
+	       ahd_inb(ahd, SCB_CDB_STORE+5));
+	printf("STACK:");
+	for (i = 0; i < ahd->stack_size; i++) {
+		ahd->saved_stack[i] =
+		    ahd_inb(ahd, STACK)|(ahd_inb(ahd, STACK) << 8);
+		printf(" 0x%x", ahd->saved_stack[i]);
+	}
+	for (i = ahd->stack_size-1; i >= 0; i--) {
+		ahd_outb(ahd, STACK, ahd->saved_stack[i] & 0xFF);
+		ahd_outb(ahd, STACK, (ahd->saved_stack[i] >> 8) & 0xFF);
+	}
+	printf("\n<<<<<<<<<<<<<<<<< Dump Card State Ends >>>>>>>>>>>>>>>>>>\n");
+	ahd_platform_dump_card_state(ahd);
+	ahd_restore_modes(ahd, saved_modes);
+	if (paused == 0)
+		ahd_unpause(ahd);
+}
+
+void
+ahd_dump_scbs(struct ahd_softc *ahd)
+{
+	ahd_mode_state saved_modes;
+	u_int	       saved_scb_index;
+	int	       i;
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	saved_scb_index = ahd_get_scbptr(ahd);
+	for (i = 0; i < AHD_SCB_MAX; i++) {
+		ahd_set_scbptr(ahd, i);
+		printf("%3d", i);
+		printf("(CTRL 0x%x ID 0x%x N 0x%x N2 0x%x SG 0x%x, RSG 0x%x)\n",
+		       ahd_inb(ahd, SCB_CONTROL),
+		       ahd_inb(ahd, SCB_SCSIID), ahd_inw(ahd, SCB_NEXT),
+		       ahd_inw(ahd, SCB_NEXT2), ahd_inl(ahd, SCB_SGPTR),
+		       ahd_inl(ahd, SCB_RESIDUAL_SGPTR));
+	}
+	printf("\n");
+	ahd_set_scbptr(ahd, saved_scb_index);
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+/**************************** Flexport Logic **********************************/
+/*
+ * Read count 16bit words from 16bit word address start_addr from the
+ * SEEPROM attached to the controller, into buf, using the controller's
+ * SEEPROM reading state machine.  Optionally treat the data as a byte
+ * stream in terms of byte order.
+ */
+int
+ahd_read_seeprom(struct ahd_softc *ahd, uint16_t *buf,
+		 u_int start_addr, u_int count, int bytestream)
+{
+	u_int cur_addr;
+	u_int end_addr;
+	int   error;
+
+	/*
+	 * If we never make it through the loop even once,
+	 * we were passed invalid arguments.
+	 */
+	error = EINVAL;
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	end_addr = start_addr + count;
+	for (cur_addr = start_addr; cur_addr < end_addr; cur_addr++) {
+
+		ahd_outb(ahd, SEEADR, cur_addr);
+		ahd_outb(ahd, SEECTL, SEEOP_READ | SEESTART);
+		
+		error = ahd_wait_seeprom(ahd);
+		if (error)
+			break;
+		if (bytestream != 0) {
+			uint8_t *bytestream_ptr;
+
+			bytestream_ptr = (uint8_t *)buf;
+			*bytestream_ptr++ = ahd_inb(ahd, SEEDAT);
+			*bytestream_ptr = ahd_inb(ahd, SEEDAT+1);
+		} else {
+			/*
+			 * ahd_inw() already handles machine byte order.
+			 */
+			*buf = ahd_inw(ahd, SEEDAT);
+		}
+		buf++;
+	}
+	return (error);
+}
+
+/*
+ * Write count 16bit words from buf, into SEEPROM attache to the
+ * controller starting at 16bit word address start_addr, using the
+ * controller's SEEPROM writing state machine.
+ */
+int
+ahd_write_seeprom(struct ahd_softc *ahd, uint16_t *buf,
+		  u_int start_addr, u_int count)
+{
+	u_int cur_addr;
+	u_int end_addr;
+	int   error;
+	int   retval;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	error = ENOENT;
+
+	/* Place the chip into write-enable mode */
+	ahd_outb(ahd, SEEADR, SEEOP_EWEN_ADDR);
+	ahd_outb(ahd, SEECTL, SEEOP_EWEN | SEESTART);
+	error = ahd_wait_seeprom(ahd);
+	if (error)
+		return (error);
+
+	/*
+	 * Write the data.  If we don't get throught the loop at
+	 * least once, the arguments were invalid.
+	 */
+	retval = EINVAL;
+	end_addr = start_addr + count;
+	for (cur_addr = start_addr; cur_addr < end_addr; cur_addr++) {
+		ahd_outw(ahd, SEEDAT, *buf++);
+		ahd_outb(ahd, SEEADR, cur_addr);
+		ahd_outb(ahd, SEECTL, SEEOP_WRITE | SEESTART);
+		
+		retval = ahd_wait_seeprom(ahd);
+		if (retval)
+			break;
+	}
+
+	/*
+	 * Disable writes.
+	 */
+	ahd_outb(ahd, SEEADR, SEEOP_EWDS_ADDR);
+	ahd_outb(ahd, SEECTL, SEEOP_EWDS | SEESTART);
+	error = ahd_wait_seeprom(ahd);
+	if (error)
+		return (error);
+	return (retval);
+}
+
+/*
+ * Wait ~100us for the serial eeprom to satisfy our request.
+ */
+int
+ahd_wait_seeprom(struct ahd_softc *ahd)
+{
+	int cnt;
+
+	cnt = 20;
+	while ((ahd_inb(ahd, SEESTAT) & (SEEARBACK|SEEBUSY)) != 0 && --cnt)
+		ahd_delay(5);
+
+	if (cnt == 0)
+		return (ETIMEDOUT);
+	return (0);
+}
+
+/*
+ * Validate the two checksums in the per_channel
+ * vital product data struct.
+ */
+int
+ahd_verify_vpd_cksum(struct vpd_config *vpd)
+{
+	int i;
+	int maxaddr;
+	uint32_t checksum;
+	uint8_t *vpdarray;
+
+	vpdarray = (uint8_t *)vpd;
+	maxaddr = offsetof(struct vpd_config, vpd_checksum);
+	checksum = 0;
+	for (i = offsetof(struct vpd_config, resource_type); i < maxaddr; i++)
+		checksum = checksum + vpdarray[i];
+	if (checksum == 0
+	 || (-checksum & 0xFF) != vpd->vpd_checksum)
+		return (0);
+
+	checksum = 0;
+	maxaddr = offsetof(struct vpd_config, checksum);
+	for (i = offsetof(struct vpd_config, default_target_flags);
+	     i < maxaddr; i++)
+		checksum = checksum + vpdarray[i];
+	if (checksum == 0
+	 || (-checksum & 0xFF) != vpd->checksum)
+		return (0);
+	return (1);
+}
+
+int
+ahd_verify_cksum(struct seeprom_config *sc)
+{
+	int i;
+	int maxaddr;
+	uint32_t checksum;
+	uint16_t *scarray;
+
+	maxaddr = (sizeof(*sc)/2) - 1;
+	checksum = 0;
+	scarray = (uint16_t *)sc;
+
+	for (i = 0; i < maxaddr; i++)
+		checksum = checksum + scarray[i];
+	if (checksum == 0
+	 || (checksum & 0xFFFF) != sc->checksum) {
+		return (0);
+	} else {
+		return (1);
+	}
+}
+
+int
+ahd_acquire_seeprom(struct ahd_softc *ahd)
+{
+	/*
+	 * We should be able to determine the SEEPROM type
+	 * from the flexport logic, but unfortunately not
+	 * all implementations have this logic and there is
+	 * no programatic method for determining if the logic
+	 * is present.
+	 */
+	return (1);
+#if 0
+	uint8_t	seetype;
+	int	error;
+
+	error = ahd_read_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, &seetype);
+	if (error != 0
+         || ((seetype & FLX_ROMSTAT_SEECFG) == FLX_ROMSTAT_SEE_NONE))
+		return (0);
+	return (1);
+#endif
+}
+
+void
+ahd_release_seeprom(struct ahd_softc *ahd)
+{
+	/* Currently a no-op */
+}
+
+int
+ahd_write_flexport(struct ahd_softc *ahd, u_int addr, u_int value)
+{
+	int error;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	if (addr > 7)
+		panic("ahd_write_flexport: address out of range");
+	ahd_outb(ahd, BRDCTL, BRDEN|(addr << 3));
+	error = ahd_wait_flexport(ahd);
+	if (error != 0)
+		return (error);
+	ahd_outb(ahd, BRDDAT, value);
+	ahd_flush_device_writes(ahd);
+	ahd_outb(ahd, BRDCTL, BRDSTB|BRDEN|(addr << 3));
+	ahd_flush_device_writes(ahd);
+	ahd_outb(ahd, BRDCTL, BRDEN|(addr << 3));
+	ahd_flush_device_writes(ahd);
+	ahd_outb(ahd, BRDCTL, 0);
+	ahd_flush_device_writes(ahd);
+	return (0);
+}
+
+int
+ahd_read_flexport(struct ahd_softc *ahd, u_int addr, uint8_t *value)
+{
+	int	error;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	if (addr > 7)
+		panic("ahd_read_flexport: address out of range");
+	ahd_outb(ahd, BRDCTL, BRDRW|BRDEN|(addr << 3));
+	error = ahd_wait_flexport(ahd);
+	if (error != 0)
+		return (error);
+	*value = ahd_inb(ahd, BRDDAT);
+	ahd_outb(ahd, BRDCTL, 0);
+	ahd_flush_device_writes(ahd);
+	return (0);
+}
+
+/*
+ * Wait at most 2 seconds for flexport arbitration to succeed.
+ */
+int
+ahd_wait_flexport(struct ahd_softc *ahd)
+{
+	int cnt;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_SCSI_MSK, AHD_MODE_SCSI_MSK);
+	cnt = 1000000 * 2 / 5;
+	while ((ahd_inb(ahd, BRDCTL) & FLXARBACK) == 0 && --cnt)
+		ahd_delay(5);
+
+	if (cnt == 0)
+		return (ETIMEDOUT);
+	return (0);
+}
+
+/************************* Target Mode ****************************************/
+#ifdef AHD_TARGET_MODE
+cam_status
+ahd_find_tmode_devs(struct ahd_softc *ahd, struct cam_sim *sim, union ccb *ccb,
+		    struct ahd_tmode_tstate **tstate,
+		    struct ahd_tmode_lstate **lstate,
+		    int notfound_failure)
+{
+
+	if ((ahd->features & AHD_TARGETMODE) == 0)
+		return (CAM_REQ_INVALID);
+
+	/*
+	 * Handle the 'black hole' device that sucks up
+	 * requests to unattached luns on enabled targets.
+	 */
+	if (ccb->ccb_h.target_id == CAM_TARGET_WILDCARD
+	 && ccb->ccb_h.target_lun == CAM_LUN_WILDCARD) {
+		*tstate = NULL;
+		*lstate = ahd->black_hole;
+	} else {
+		u_int max_id;
+
+		max_id = (ahd->features & AHD_WIDE) ? 15 : 7;
+		if (ccb->ccb_h.target_id > max_id)
+			return (CAM_TID_INVALID);
+
+		if (ccb->ccb_h.target_lun >= AHD_NUM_LUNS)
+			return (CAM_LUN_INVALID);
+
+		*tstate = ahd->enabled_targets[ccb->ccb_h.target_id];
+		*lstate = NULL;
+		if (*tstate != NULL)
+			*lstate =
+			    (*tstate)->enabled_luns[ccb->ccb_h.target_lun];
+	}
+
+	if (notfound_failure != 0 && *lstate == NULL)
+		return (CAM_PATH_INVALID);
+
+	return (CAM_REQ_CMP);
+}
+
+void
+ahd_handle_en_lun(struct ahd_softc *ahd, struct cam_sim *sim, union ccb *ccb)
+{
+#if NOT_YET
+	struct	   ahd_tmode_tstate *tstate;
+	struct	   ahd_tmode_lstate *lstate;
+	struct	   ccb_en_lun *cel;
+	cam_status status;
+	u_int	   target;
+	u_int	   lun;
+	u_int	   target_mask;
+	u_long	   s;
+	char	   channel;
+
+	status = ahd_find_tmode_devs(ahd, sim, ccb, &tstate, &lstate,
+				     /*notfound_failure*/FALSE);
+
+	if (status != CAM_REQ_CMP) {
+		ccb->ccb_h.status = status;
+		return;
+	}
+
+	if ((ahd->features & AHD_MULTIROLE) != 0) {
+		u_int	   our_id;
+
+		our_id = ahd->our_id;
+		if (ccb->ccb_h.target_id != our_id) {
+			if ((ahd->features & AHD_MULTI_TID) != 0
+		   	 && (ahd->flags & AHD_INITIATORROLE) != 0) {
+				/*
+				 * Only allow additional targets if
+				 * the initiator role is disabled.
+				 * The hardware cannot handle a re-select-in
+				 * on the initiator id during a re-select-out
+				 * on a different target id.
+				 */
+				status = CAM_TID_INVALID;
+			} else if ((ahd->flags & AHD_INITIATORROLE) != 0
+				|| ahd->enabled_luns > 0) {
+				/*
+				 * Only allow our target id to change
+				 * if the initiator role is not configured
+				 * and there are no enabled luns which
+				 * are attached to the currently registered
+				 * scsi id.
+				 */
+				status = CAM_TID_INVALID;
+			}
+		}
+	}
+
+	if (status != CAM_REQ_CMP) {
+		ccb->ccb_h.status = status;
+		return;
+	}
+
+	/*
+	 * We now have an id that is valid.
+	 * If we aren't in target mode, switch modes.
+	 */
+	if ((ahd->flags & AHD_TARGETROLE) == 0
+	 && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {
+		u_long	s;
+
+		printf("Configuring Target Mode\n");
+		ahd_lock(ahd, &s);
+		if (LIST_FIRST(&ahd->pending_scbs) != NULL) {
+			ccb->ccb_h.status = CAM_BUSY;
+			ahd_unlock(ahd, &s);
+			return;
+		}
+		ahd->flags |= AHD_TARGETROLE;
+		if ((ahd->features & AHD_MULTIROLE) == 0)
+			ahd->flags &= ~AHD_INITIATORROLE;
+		ahd_pause(ahd);
+		ahd_loadseq(ahd);
+		ahd_restart(ahd);
+		ahd_unlock(ahd, &s);
+	}
+	cel = &ccb->cel;
+	target = ccb->ccb_h.target_id;
+	lun = ccb->ccb_h.target_lun;
+	channel = SIM_CHANNEL(ahd, sim);
+	target_mask = 0x01 << target;
+	if (channel == 'B')
+		target_mask <<= 8;
+
+	if (cel->enable != 0) {
+		u_int scsiseq1;
+
+		/* Are we already enabled?? */
+		if (lstate != NULL) {
+			xpt_print_path(ccb->ccb_h.path);
+			printf("Lun already enabled\n");
+			ccb->ccb_h.status = CAM_LUN_ALRDY_ENA;
+			return;
+		}
+
+		if (cel->grp6_len != 0
+		 || cel->grp7_len != 0) {
+			/*
+			 * Don't (yet?) support vendor
+			 * specific commands.
+			 */
+			ccb->ccb_h.status = CAM_REQ_INVALID;
+			printf("Non-zero Group Codes\n");
+			return;
+		}
+
+		/*
+		 * Seems to be okay.
+		 * Setup our data structures.
+		 */
+		if (target != CAM_TARGET_WILDCARD && tstate == NULL) {
+			tstate = ahd_alloc_tstate(ahd, target, channel);
+			if (tstate == NULL) {
+				xpt_print_path(ccb->ccb_h.path);
+				printf("Couldn't allocate tstate\n");
+				ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
+				return;
+			}
+		}
+		lstate = malloc(sizeof(*lstate), M_DEVBUF, M_NOWAIT);
+		if (lstate == NULL) {
+			xpt_print_path(ccb->ccb_h.path);
+			printf("Couldn't allocate lstate\n");
+			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
+			return;
+		}
+		memset(lstate, 0, sizeof(*lstate));
+		status = xpt_create_path(&lstate->path, /*periph*/NULL,
+					 xpt_path_path_id(ccb->ccb_h.path),
+					 xpt_path_target_id(ccb->ccb_h.path),
+					 xpt_path_lun_id(ccb->ccb_h.path));
+		if (status != CAM_REQ_CMP) {
+			free(lstate, M_DEVBUF);
+			xpt_print_path(ccb->ccb_h.path);
+			printf("Couldn't allocate path\n");
+			ccb->ccb_h.status = CAM_RESRC_UNAVAIL;
+			return;
+		}
+		SLIST_INIT(&lstate->accept_tios);
+		SLIST_INIT(&lstate->immed_notifies);
+		ahd_lock(ahd, &s);
+		ahd_pause(ahd);
+		if (target != CAM_TARGET_WILDCARD) {
+			tstate->enabled_luns[lun] = lstate;
+			ahd->enabled_luns++;
+
+			if ((ahd->features & AHD_MULTI_TID) != 0) {
+				u_int targid_mask;
+
+				targid_mask = ahd_inb(ahd, TARGID)
+					    | (ahd_inb(ahd, TARGID + 1) << 8);
+
+				targid_mask |= target_mask;
+				ahd_outb(ahd, TARGID, targid_mask);
+				ahd_outb(ahd, TARGID+1, (targid_mask >> 8));
+				
+				ahd_update_scsiid(ahd, targid_mask);
+			} else {
+				u_int our_id;
+				char  channel;
+
+				channel = SIM_CHANNEL(ahd, sim);
+				our_id = SIM_SCSI_ID(ahd, sim);
+
+				/*
+				 * This can only happen if selections
+				 * are not enabled
+				 */
+				if (target != our_id) {
+					u_int sblkctl;
+					char  cur_channel;
+					int   swap;
+
+					sblkctl = ahd_inb(ahd, SBLKCTL);
+					cur_channel = (sblkctl & SELBUSB)
+						    ? 'B' : 'A';
+					if ((ahd->features & AHD_TWIN) == 0)
+						cur_channel = 'A';
+					swap = cur_channel != channel;
+					ahd->our_id = target;
+
+					if (swap)
+						ahd_outb(ahd, SBLKCTL,
+							 sblkctl ^ SELBUSB);
+
+					ahd_outb(ahd, SCSIID, target);
+
+					if (swap)
+						ahd_outb(ahd, SBLKCTL, sblkctl);
+				}
+			}
+		} else
+			ahd->black_hole = lstate;
+		/* Allow select-in operations */
+		if (ahd->black_hole != NULL && ahd->enabled_luns > 0) {
+			scsiseq1 = ahd_inb(ahd, SCSISEQ_TEMPLATE);
+			scsiseq1 |= ENSELI;
+			ahd_outb(ahd, SCSISEQ_TEMPLATE, scsiseq1);
+			scsiseq1 = ahd_inb(ahd, SCSISEQ1);
+			scsiseq1 |= ENSELI;
+			ahd_outb(ahd, SCSISEQ1, scsiseq1);
+		}
+		ahd_unpause(ahd);
+		ahd_unlock(ahd, &s);
+		ccb->ccb_h.status = CAM_REQ_CMP;
+		xpt_print_path(ccb->ccb_h.path);
+		printf("Lun now enabled for target mode\n");
+	} else {
+		struct scb *scb;
+		int i, empty;
+
+		if (lstate == NULL) {
+			ccb->ccb_h.status = CAM_LUN_INVALID;
+			return;
+		}
+
+		ahd_lock(ahd, &s);
+		
+		ccb->ccb_h.status = CAM_REQ_CMP;
+		LIST_FOREACH(scb, &ahd->pending_scbs, pending_links) {
+			struct ccb_hdr *ccbh;
+
+			ccbh = &scb->io_ctx->ccb_h;
+			if (ccbh->func_code == XPT_CONT_TARGET_IO
+			 && !xpt_path_comp(ccbh->path, ccb->ccb_h.path)){
+				printf("CTIO pending\n");
+				ccb->ccb_h.status = CAM_REQ_INVALID;
+				ahd_unlock(ahd, &s);
+				return;
+			}
+		}
+
+		if (SLIST_FIRST(&lstate->accept_tios) != NULL) {
+			printf("ATIOs pending\n");
+			ccb->ccb_h.status = CAM_REQ_INVALID;
+		}
+
+		if (SLIST_FIRST(&lstate->immed_notifies) != NULL) {
+			printf("INOTs pending\n");
+			ccb->ccb_h.status = CAM_REQ_INVALID;
+		}
+
+		if (ccb->ccb_h.status != CAM_REQ_CMP) {
+			ahd_unlock(ahd, &s);
+			return;
+		}
+
+		xpt_print_path(ccb->ccb_h.path);
+		printf("Target mode disabled\n");
+		xpt_free_path(lstate->path);
+		free(lstate, M_DEVBUF);
+
+		ahd_pause(ahd);
+		/* Can we clean up the target too? */
+		if (target != CAM_TARGET_WILDCARD) {
+			tstate->enabled_luns[lun] = NULL;
+			ahd->enabled_luns--;
+			for (empty = 1, i = 0; i < 8; i++)
+				if (tstate->enabled_luns[i] != NULL) {
+					empty = 0;
+					break;
+				}
+
+			if (empty) {
+				ahd_free_tstate(ahd, target, channel,
+						/*force*/FALSE);
+				if (ahd->features & AHD_MULTI_TID) {
+					u_int targid_mask;
+
+					targid_mask = ahd_inb(ahd, TARGID)
+						    | (ahd_inb(ahd, TARGID + 1)
+						       << 8);
+
+					targid_mask &= ~target_mask;
+					ahd_outb(ahd, TARGID, targid_mask);
+					ahd_outb(ahd, TARGID+1,
+					 	 (targid_mask >> 8));
+					ahd_update_scsiid(ahd, targid_mask);
+				}
+			}
+		} else {
+
+			ahd->black_hole = NULL;
+
+			/*
+			 * We can't allow selections without
+			 * our black hole device.
+			 */
+			empty = TRUE;
+		}
+		if (ahd->enabled_luns == 0) {
+			/* Disallow select-in */
+			u_int scsiseq1;
+
+			scsiseq1 = ahd_inb(ahd, SCSISEQ_TEMPLATE);
+			scsiseq1 &= ~ENSELI;
+			ahd_outb(ahd, SCSISEQ_TEMPLATE, scsiseq1);
+			scsiseq1 = ahd_inb(ahd, SCSISEQ1);
+			scsiseq1 &= ~ENSELI;
+			ahd_outb(ahd, SCSISEQ1, scsiseq1);
+
+			if ((ahd->features & AHD_MULTIROLE) == 0) {
+				printf("Configuring Initiator Mode\n");
+				ahd->flags &= ~AHD_TARGETROLE;
+				ahd->flags |= AHD_INITIATORROLE;
+				ahd_pause(ahd);
+				ahd_loadseq(ahd);
+				ahd_restart(ahd);
+				/*
+				 * Unpaused.  The extra unpause
+				 * that follows is harmless.
+				 */
+			}
+		}
+		ahd_unpause(ahd);
+		ahd_unlock(ahd, &s);
+	}
+#endif
+}
+
+static void
+ahd_update_scsiid(struct ahd_softc *ahd, u_int targid_mask)
+{
+#if NOT_YET
+	u_int scsiid_mask;
+	u_int scsiid;
+
+	if ((ahd->features & AHD_MULTI_TID) == 0)
+		panic("ahd_update_scsiid called on non-multitid unit\n");
+
+	/*
+	 * Since we will rely on the TARGID mask
+	 * for selection enables, ensure that OID
+	 * in SCSIID is not set to some other ID
+	 * that we don't want to allow selections on.
+	 */
+	if ((ahd->features & AHD_ULTRA2) != 0)
+		scsiid = ahd_inb(ahd, SCSIID_ULTRA2);
+	else
+		scsiid = ahd_inb(ahd, SCSIID);
+	scsiid_mask = 0x1 << (scsiid & OID);
+	if ((targid_mask & scsiid_mask) == 0) {
+		u_int our_id;
+
+		/* ffs counts from 1 */
+		our_id = ffs(targid_mask);
+		if (our_id == 0)
+			our_id = ahd->our_id;
+		else
+			our_id--;
+		scsiid &= TID;
+		scsiid |= our_id;
+	}
+	if ((ahd->features & AHD_ULTRA2) != 0)
+		ahd_outb(ahd, SCSIID_ULTRA2, scsiid);
+	else
+		ahd_outb(ahd, SCSIID, scsiid);
+#endif
+}
+
+void
+ahd_run_tqinfifo(struct ahd_softc *ahd, int paused)
+{
+	struct target_cmd *cmd;
+
+	ahd_sync_tqinfifo(ahd, BUS_DMASYNC_POSTREAD);
+	while ((cmd = &ahd->targetcmds[ahd->tqinfifonext])->cmd_valid != 0) {
+
+		/*
+		 * Only advance through the queue if we
+		 * have the resources to process the command.
+		 */
+		if (ahd_handle_target_cmd(ahd, cmd) != 0)
+			break;
+
+		cmd->cmd_valid = 0;
+		ahd_dmamap_sync(ahd, ahd->shared_data_dmat,
+				ahd->shared_data_dmamap,
+				ahd_targetcmd_offset(ahd, ahd->tqinfifonext),
+				sizeof(struct target_cmd),
+				BUS_DMASYNC_PREREAD);
+		ahd->tqinfifonext++;
+
+		/*
+		 * Lazily update our position in the target mode incoming
+		 * command queue as seen by the sequencer.
+		 */
+		if ((ahd->tqinfifonext & (HOST_TQINPOS - 1)) == 1) {
+			u_int hs_mailbox;
+
+			hs_mailbox = ahd_inb(ahd, HS_MAILBOX);
+			hs_mailbox &= ~HOST_TQINPOS;
+			hs_mailbox |= ahd->tqinfifonext & HOST_TQINPOS;
+			ahd_outb(ahd, HS_MAILBOX, hs_mailbox);
+		}
+	}
+}
+
+static int
+ahd_handle_target_cmd(struct ahd_softc *ahd, struct target_cmd *cmd)
+{
+	struct	  ahd_tmode_tstate *tstate;
+	struct	  ahd_tmode_lstate *lstate;
+	struct	  ccb_accept_tio *atio;
+	uint8_t *byte;
+	int	  initiator;
+	int	  target;
+	int	  lun;
+
+	initiator = SCSIID_TARGET(ahd, cmd->scsiid);
+	target = SCSIID_OUR_ID(cmd->scsiid);
+	lun    = (cmd->identify & MSG_IDENTIFY_LUNMASK);
+
+	byte = cmd->bytes;
+	tstate = ahd->enabled_targets[target];
+	lstate = NULL;
+	if (tstate != NULL)
+		lstate = tstate->enabled_luns[lun];
+
+	/*
+	 * Commands for disabled luns go to the black hole driver.
+	 */
+	if (lstate == NULL)
+		lstate = ahd->black_hole;
+
+	atio = (struct ccb_accept_tio*)SLIST_FIRST(&lstate->accept_tios);
+	if (atio == NULL) {
+		ahd->flags |= AHD_TQINFIFO_BLOCKED;
+		/*
+		 * Wait for more ATIOs from the peripheral driver for this lun.
+		 */
+		return (1);
+	} else
+		ahd->flags &= ~AHD_TQINFIFO_BLOCKED;
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_TQIN) != 0)
+		printf("Incoming command from %d for %d:%d%s\n",
+		       initiator, target, lun,
+		       lstate == ahd->black_hole ? "(Black Holed)" : "");
+#endif
+	SLIST_REMOVE_HEAD(&lstate->accept_tios, sim_links.sle);
+
+	if (lstate == ahd->black_hole) {
+		/* Fill in the wildcards */
+		atio->ccb_h.target_id = target;
+		atio->ccb_h.target_lun = lun;
+	}
+
+	/*
+	 * Package it up and send it off to
+	 * whomever has this lun enabled.
+	 */
+	atio->sense_len = 0;
+	atio->init_id = initiator;
+	if (byte[0] != 0xFF) {
+		/* Tag was included */
+		atio->tag_action = *byte++;
+		atio->tag_id = *byte++;
+		atio->ccb_h.flags = CAM_TAG_ACTION_VALID;
+	} else {
+		atio->ccb_h.flags = 0;
+	}
+	byte++;
+
+	/* Okay.  Now determine the cdb size based on the command code */
+	switch (*byte >> CMD_GROUP_CODE_SHIFT) {
+	case 0:
+		atio->cdb_len = 6;
+		break;
+	case 1:
+	case 2:
+		atio->cdb_len = 10;
+		break;
+	case 4:
+		atio->cdb_len = 16;
+		break;
+	case 5:
+		atio->cdb_len = 12;
+		break;
+	case 3:
+	default:
+		/* Only copy the opcode. */
+		atio->cdb_len = 1;
+		printf("Reserved or VU command code type encountered\n");
+		break;
+	}
+	
+	memcpy(atio->cdb_io.cdb_bytes, byte, atio->cdb_len);
+
+	atio->ccb_h.status |= CAM_CDB_RECVD;
+
+	if ((cmd->identify & MSG_IDENTIFY_DISCFLAG) == 0) {
+		/*
+		 * We weren't allowed to disconnect.
+		 * We're hanging on the bus until a
+		 * continue target I/O comes in response
+		 * to this accept tio.
+		 */
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_TQIN) != 0)
+			printf("Received Immediate Command %d:%d:%d - %p\n",
+			       initiator, target, lun, ahd->pending_device);
+#endif
+		ahd->pending_device = lstate;
+		ahd_freeze_ccb((union ccb *)atio);
+		atio->ccb_h.flags |= CAM_DIS_DISCONNECT;
+	}
+	xpt_done((union ccb*)atio);
+	return (0);
+}
+
+#endif
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic79xx_inline.h linux-5730/drivers/scsi/aic7xxx/aic79xx_inline.h
--- linux-5720/drivers/scsi/aic7xxx/aic79xx_inline.h
+++ linux-5730/drivers/scsi/aic7xxx/aic79xx_inline.h
@@ -0,0 +1,958 @@
+/*
+ * Inline routines shareable across OS platforms.
+ *
+ * Copyright (c) 1994-2001 Justin T. Gibbs.
+ * Copyright (c) 2000-2003 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx_inline.h#50 $
+ *
+ * $FreeBSD$
+ */
+
+#ifndef _AIC79XX_INLINE_H_
+#define _AIC79XX_INLINE_H_
+
+/******************************** Debugging ***********************************/
+static __inline char *ahd_name(struct ahd_softc *ahd);
+
+static __inline char *
+ahd_name(struct ahd_softc *ahd)
+{
+	return (ahd->name);
+}
+
+/************************ Sequencer Execution Control *************************/
+static __inline void ahd_known_modes(struct ahd_softc *ahd,
+				     ahd_mode src, ahd_mode dst);
+static __inline ahd_mode_state ahd_build_mode_state(struct ahd_softc *ahd,
+						    ahd_mode src,
+						    ahd_mode dst);
+static __inline void ahd_extract_mode_state(struct ahd_softc *ahd,
+					    ahd_mode_state state,
+					    ahd_mode *src, ahd_mode *dst);
+static __inline void ahd_set_modes(struct ahd_softc *ahd, ahd_mode src,
+				   ahd_mode dst);
+static __inline void ahd_update_modes(struct ahd_softc *ahd);
+static __inline void ahd_assert_modes(struct ahd_softc *ahd, ahd_mode srcmode,
+				      ahd_mode dstmode, const char *file,
+				      int line);
+static __inline ahd_mode_state ahd_save_modes(struct ahd_softc *ahd);
+static __inline void ahd_restore_modes(struct ahd_softc *ahd,
+				       ahd_mode_state state);
+static __inline int  ahd_is_paused(struct ahd_softc *ahd);
+static __inline void ahd_pause(struct ahd_softc *ahd);
+static __inline void ahd_unpause(struct ahd_softc *ahd);
+
+static __inline void
+ahd_known_modes(struct ahd_softc *ahd, ahd_mode src, ahd_mode dst)
+{
+	ahd->src_mode = src;
+	ahd->dst_mode = dst;
+	ahd->saved_src_mode = src;
+	ahd->saved_dst_mode = dst;
+}
+
+static __inline ahd_mode_state
+ahd_build_mode_state(struct ahd_softc *ahd, ahd_mode src, ahd_mode dst)
+{
+	return ((src << SRC_MODE_SHIFT) | (dst << DST_MODE_SHIFT));
+}
+
+static __inline void
+ahd_extract_mode_state(struct ahd_softc *ahd, ahd_mode_state state,
+		       ahd_mode *src, ahd_mode *dst)
+{
+	*src = (state & SRC_MODE) >> SRC_MODE_SHIFT;
+	*dst = (state & DST_MODE) >> DST_MODE_SHIFT;
+}
+
+static __inline void
+ahd_set_modes(struct ahd_softc *ahd, ahd_mode src, ahd_mode dst)
+{
+	if (ahd->src_mode == src && ahd->dst_mode == dst)
+		return;
+#ifdef AHD_DEBUG
+	if (ahd->src_mode == AHD_MODE_UNKNOWN
+	 || ahd->dst_mode == AHD_MODE_UNKNOWN)
+		panic("Setting mode prior to saving it.\n");
+	if ((ahd_debug & AHD_SHOW_MODEPTR) != 0)
+		printf("%s: Setting mode 0x%x\n", ahd_name(ahd),
+		       ahd_build_mode_state(ahd, src, dst));
+#endif
+	ahd_outb(ahd, MODE_PTR, ahd_build_mode_state(ahd, src, dst));
+	ahd->src_mode = src;
+	ahd->dst_mode = dst;
+}
+
+static __inline void
+ahd_update_modes(struct ahd_softc *ahd)
+{
+	ahd_mode_state mode_ptr;
+	ahd_mode src;
+	ahd_mode dst;
+
+	mode_ptr = ahd_inb(ahd, MODE_PTR);
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_MODEPTR) != 0)
+		printf("Reading mode 0x%x\n", mode_ptr);
+#endif
+	ahd_extract_mode_state(ahd, mode_ptr, &src, &dst);
+	ahd_known_modes(ahd, src, dst);
+}
+
+static __inline void
+ahd_assert_modes(struct ahd_softc *ahd, ahd_mode srcmode,
+		 ahd_mode dstmode, const char *file, int line)
+{
+#ifdef AHD_DEBUG
+	if ((srcmode & AHD_MK_MSK(ahd->src_mode)) == 0
+	 || (dstmode & AHD_MK_MSK(ahd->dst_mode)) == 0) {
+		panic("%s:%s:%d: Mode assertion failed.\n",
+		       ahd_name(ahd), file, line);
+	}
+#endif
+}
+
+static __inline ahd_mode_state
+ahd_save_modes(struct ahd_softc *ahd)
+{
+	if (ahd->src_mode == AHD_MODE_UNKNOWN
+	 || ahd->dst_mode == AHD_MODE_UNKNOWN)
+		ahd_update_modes(ahd);
+
+	return (ahd_build_mode_state(ahd, ahd->src_mode, ahd->dst_mode));
+}
+
+static __inline void
+ahd_restore_modes(struct ahd_softc *ahd, ahd_mode_state state)
+{
+	ahd_mode src;
+	ahd_mode dst;
+
+	ahd_extract_mode_state(ahd, state, &src, &dst);
+	ahd_set_modes(ahd, src, dst);
+}
+
+#define AHD_ASSERT_MODES(ahd, source, dest) \
+	ahd_assert_modes(ahd, source, dest, __FILE__, __LINE__);
+
+/*
+ * Determine whether the sequencer has halted code execution.
+ * Returns non-zero status if the sequencer is stopped.
+ */
+static __inline int
+ahd_is_paused(struct ahd_softc *ahd)
+{
+	return ((ahd_inb(ahd, HCNTRL) & PAUSE) != 0);
+}
+
+/*
+ * Request that the sequencer stop and wait, indefinitely, for it
+ * to stop.  The sequencer will only acknowledge that it is paused
+ * once it has reached an instruction boundary and PAUSEDIS is
+ * cleared in the SEQCTL register.  The sequencer may use PAUSEDIS
+ * for critical sections.
+ */
+static __inline void
+ahd_pause(struct ahd_softc *ahd)
+{
+	ahd_outb(ahd, HCNTRL, ahd->pause);
+
+	/*
+	 * Since the sequencer can disable pausing in a critical section, we
+	 * must loop until it actually stops.
+	 */
+	while (ahd_is_paused(ahd) == 0)
+		;
+}
+
+/*
+ * Allow the sequencer to continue program execution.
+ * We check here to ensure that no additional interrupt
+ * sources that would cause the sequencer to halt have been
+ * asserted.  If, for example, a SCSI bus reset is detected
+ * while we are fielding a different, pausing, interrupt type,
+ * we don't want to release the sequencer before going back
+ * into our interrupt handler and dealing with this new
+ * condition.
+ */
+static __inline void
+ahd_unpause(struct ahd_softc *ahd)
+{
+	/*
+	 * Automatically restore our modes to those saved
+	 * prior to the first change of the mode.
+	 */
+	if (ahd->saved_src_mode != AHD_MODE_UNKNOWN
+	 && ahd->saved_dst_mode != AHD_MODE_UNKNOWN) {
+		if ((ahd->flags & AHD_UPDATE_PEND_CMDS) != 0)
+			ahd_reset_cmds_pending(ahd);
+		ahd_set_modes(ahd, ahd->saved_src_mode, ahd->saved_dst_mode);
+	}
+
+	if ((ahd_inb(ahd, INTSTAT) & ~CMDCMPLT) == 0)
+		ahd_outb(ahd, HCNTRL, ahd->unpause);
+
+	ahd_known_modes(ahd, AHD_MODE_UNKNOWN, AHD_MODE_UNKNOWN);
+}
+
+/*********************** Scatter Gather List Handling *************************/
+static __inline void	*ahd_sg_setup(struct ahd_softc *ahd, struct scb *scb,
+				      void *sgptr, bus_addr_t addr,
+				      bus_size_t len, int last);
+static __inline void	 ahd_setup_scb_common(struct ahd_softc *ahd,
+					      struct scb *scb);
+static __inline void	 ahd_setup_data_scb(struct ahd_softc *ahd,
+					    struct scb *scb);
+static __inline void	 ahd_setup_noxfer_scb(struct ahd_softc *ahd,
+					      struct scb *scb);
+
+static __inline void *
+ahd_sg_setup(struct ahd_softc *ahd, struct scb *scb,
+	     void *sgptr, bus_addr_t addr, bus_size_t len, int last)
+{
+	scb->sg_count++;
+	if (sizeof(bus_addr_t) > 4
+	 && (ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
+		struct ahd_dma64_seg *sg;
+
+		sg = (struct ahd_dma64_seg *)sgptr;
+		sg->addr = ahd_htole64(addr);
+		sg->len = ahd_htole32(len | (last ? AHD_DMA_LAST_SEG : 0));
+		return (sg + 1);
+	} else {
+		struct ahd_dma_seg *sg;
+
+		sg = (struct ahd_dma_seg *)sgptr;
+		sg->addr = ahd_htole32(addr & 0xFFFFFFFF);
+		sg->len = ahd_htole32(len | ((addr >> 8) & 0x7F000000)
+				    | (last ? AHD_DMA_LAST_SEG : 0));
+		return (sg + 1);
+	}
+}
+
+static __inline void
+ahd_setup_scb_common(struct ahd_softc *ahd, struct scb *scb)
+{
+	/* XXX Handle target mode SCBs. */
+	scb->crc_retry_count = 0;
+	if ((scb->flags & SCB_PACKETIZED) != 0) {
+		/* XXX what about ACA??  It is type 4, but TAG_TYPE == 0x3. */
+		scb->hscb->task_attribute = scb->hscb->control & SCB_TAG_TYPE;
+	} else {
+		if (ahd_get_transfer_length(scb) & 0x01)
+			scb->hscb->task_attribute = SCB_XFERLEN_ODD;
+		else
+			scb->hscb->task_attribute = 0;
+	}
+
+	if (scb->hscb->cdb_len <= MAX_CDB_LEN_WITH_SENSE_ADDR
+	 || (scb->hscb->cdb_len & SCB_CDB_LEN_PTR) != 0)
+		scb->hscb->shared_data.idata.cdb_plus_saddr.sense_addr =
+		    ahd_htole32(scb->sense_busaddr);
+}
+
+static __inline void
+ahd_setup_data_scb(struct ahd_softc *ahd, struct scb *scb)
+{
+	/*
+	 * Copy the first SG into the "current" data ponter area.
+	 */
+	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0) {
+		struct ahd_dma64_seg *sg;
+
+		sg = (struct ahd_dma64_seg *)scb->sg_list;
+		scb->hscb->dataptr = sg->addr;
+		scb->hscb->datacnt = sg->len;
+	} else {
+		struct ahd_dma_seg *sg;
+		uint32_t *dataptr_words;
+
+		sg = (struct ahd_dma_seg *)scb->sg_list;
+		dataptr_words = (uint32_t*)&scb->hscb->dataptr;
+		dataptr_words[0] = sg->addr;
+		dataptr_words[1] = 0;
+		if ((ahd->flags & AHD_39BIT_ADDRESSING) != 0) {
+			uint64_t high_addr;
+
+			high_addr = ahd_le32toh(sg->len) & 0x7F000000;
+			scb->hscb->dataptr |= ahd_htole64(high_addr << 8);
+		}
+		scb->hscb->datacnt = sg->len;
+	}
+	/*
+	 * Note where to find the SG entries in bus space.
+	 * We also set the full residual flag which the 
+	 * sequencer will clear as soon as a data transfer
+	 * occurs.
+	 */
+	scb->hscb->sgptr = ahd_htole32(scb->sg_list_busaddr|SG_FULL_RESID);
+}
+
+static __inline void
+ahd_setup_noxfer_scb(struct ahd_softc *ahd, struct scb *scb)
+{
+	scb->hscb->sgptr = ahd_htole32(SG_LIST_NULL);
+	scb->hscb->dataptr = 0;
+	scb->hscb->datacnt = 0;
+}
+
+/************************** Memory mapping routines ***************************/
+static __inline size_t	ahd_sg_size(struct ahd_softc *ahd);
+static __inline void *
+			ahd_sg_bus_to_virt(struct ahd_softc *ahd,
+					   struct scb *scb,
+					   uint32_t sg_busaddr);
+static __inline uint32_t
+			ahd_sg_virt_to_bus(struct ahd_softc *ahd,
+					   struct scb *scb,
+					   void *sg);
+static __inline void	ahd_sync_scb(struct ahd_softc *ahd,
+				     struct scb *scb, int op);
+static __inline void	ahd_sync_sglist(struct ahd_softc *ahd,
+					struct scb *scb, int op);
+static __inline void	ahd_sync_sense(struct ahd_softc *ahd,
+				       struct scb *scb, int op);
+static __inline uint32_t
+			ahd_targetcmd_offset(struct ahd_softc *ahd,
+					     u_int index);
+
+static __inline size_t
+ahd_sg_size(struct ahd_softc *ahd)
+{
+	if ((ahd->flags & AHD_64BIT_ADDRESSING) != 0)
+		return (sizeof(struct ahd_dma64_seg));
+	return (sizeof(struct ahd_dma_seg));
+}
+
+static __inline void *
+ahd_sg_bus_to_virt(struct ahd_softc *ahd, struct scb *scb, uint32_t sg_busaddr)
+{
+	bus_addr_t sg_offset;
+
+	/* sg_list_phys points to entry 1, not 0 */
+	sg_offset = sg_busaddr - (scb->sg_list_busaddr - ahd_sg_size(ahd));
+	return ((uint8_t *)scb->sg_list + sg_offset);
+}
+
+static __inline uint32_t
+ahd_sg_virt_to_bus(struct ahd_softc *ahd, struct scb *scb, void *sg)
+{
+	bus_addr_t sg_offset;
+
+	/* sg_list_phys points to entry 1, not 0 */
+	sg_offset = ((uint8_t *)sg - (uint8_t *)scb->sg_list)
+		  - ahd_sg_size(ahd);
+
+	return (scb->sg_list_busaddr + sg_offset);
+}
+
+static __inline void
+ahd_sync_scb(struct ahd_softc *ahd, struct scb *scb, int op)
+{
+	ahd_dmamap_sync(ahd, ahd->scb_data.hscb_dmat,
+			scb->hscb_map->dmamap,
+			/*offset*/(uint8_t*)scb->hscb - scb->hscb_map->vaddr,
+			/*len*/sizeof(*scb->hscb), op);
+}
+
+static __inline void
+ahd_sync_sglist(struct ahd_softc *ahd, struct scb *scb, int op)
+{
+	if (scb->sg_count == 0)
+		return;
+
+	ahd_dmamap_sync(ahd, ahd->scb_data.sg_dmat,
+			scb->sg_map->dmamap,
+			/*offset*/scb->sg_list_busaddr - ahd_sg_size(ahd),
+			/*len*/ahd_sg_size(ahd) * scb->sg_count, op);
+}
+
+static __inline void
+ahd_sync_sense(struct ahd_softc *ahd, struct scb *scb, int op)
+{
+	ahd_dmamap_sync(ahd, ahd->scb_data.sense_dmat,
+			scb->sense_map->dmamap,
+			/*offset*/scb->sense_busaddr,
+			/*len*/AHD_SENSE_BUFSIZE, op);
+}
+
+static __inline uint32_t
+ahd_targetcmd_offset(struct ahd_softc *ahd, u_int index)
+{
+	return (((uint8_t *)&ahd->targetcmds[index])
+	       - (uint8_t *)ahd->qoutfifo);
+}
+
+/*********************** Miscelaneous Support Functions ***********************/
+static __inline void	ahd_complete_scb(struct ahd_softc *ahd,
+					 struct scb *scb);
+static __inline void	ahd_update_residual(struct ahd_softc *ahd,
+					    struct scb *scb);
+static __inline struct ahd_initiator_tinfo *
+			ahd_fetch_transinfo(struct ahd_softc *ahd,
+					    char channel, u_int our_id,
+					    u_int remote_id,
+					    struct ahd_tmode_tstate **tstate);
+static __inline uint16_t
+			ahd_inw(struct ahd_softc *ahd, u_int port);
+static __inline void	ahd_outw(struct ahd_softc *ahd, u_int port,
+				 u_int value);
+static __inline uint32_t
+			ahd_inl(struct ahd_softc *ahd, u_int port);
+static __inline void	ahd_outl(struct ahd_softc *ahd, u_int port,
+				 uint32_t value);
+static __inline uint64_t
+			ahd_inq(struct ahd_softc *ahd, u_int port);
+static __inline void	ahd_outq(struct ahd_softc *ahd, u_int port,
+				 uint64_t value);
+static __inline u_int	ahd_get_scbptr(struct ahd_softc *ahd);
+static __inline void	ahd_set_scbptr(struct ahd_softc *ahd, u_int scbptr);
+static __inline u_int	ahd_get_hnscb_qoff(struct ahd_softc *ahd);
+static __inline void	ahd_set_hnscb_qoff(struct ahd_softc *ahd, u_int value);
+static __inline u_int	ahd_get_hescb_qoff(struct ahd_softc *ahd);
+static __inline void	ahd_set_hescb_qoff(struct ahd_softc *ahd, u_int value);
+static __inline u_int	ahd_get_snscb_qoff(struct ahd_softc *ahd);
+static __inline void	ahd_set_snscb_qoff(struct ahd_softc *ahd, u_int value);
+static __inline u_int	ahd_get_sescb_qoff(struct ahd_softc *ahd);
+static __inline void	ahd_set_sescb_qoff(struct ahd_softc *ahd, u_int value);
+static __inline u_int	ahd_get_sdscb_qoff(struct ahd_softc *ahd);
+static __inline void	ahd_set_sdscb_qoff(struct ahd_softc *ahd, u_int value);
+static __inline u_int	ahd_inb_scbram(struct ahd_softc *ahd, u_int offset);
+static __inline u_int	ahd_inw_scbram(struct ahd_softc *ahd, u_int offset);
+static __inline uint32_t
+			ahd_inl_scbram(struct ahd_softc *ahd, u_int offset);
+static __inline void	ahd_swap_with_next_hscb(struct ahd_softc *ahd,
+						struct scb *scb);
+static __inline void	ahd_queue_scb(struct ahd_softc *ahd, struct scb *scb);
+static __inline uint8_t *
+			ahd_get_sense_buf(struct ahd_softc *ahd,
+					  struct scb *scb);
+static __inline uint32_t
+			ahd_get_sense_bufaddr(struct ahd_softc *ahd,
+					      struct scb *scb);
+
+static __inline void
+ahd_complete_scb(struct ahd_softc *ahd, struct scb *scb)
+{
+	uint32_t sgptr;
+
+	sgptr = ahd_le32toh(scb->hscb->sgptr);
+	if ((sgptr & SG_STATUS_VALID) != 0)
+		ahd_handle_scb_status(ahd, scb);
+	else
+		ahd_done(ahd, scb);
+}
+
+/*
+ * Determine whether the sequencer reported a residual
+ * for this SCB/transaction.
+ */
+static __inline void
+ahd_update_residual(struct ahd_softc *ahd, struct scb *scb)
+{
+	uint32_t sgptr;
+
+	sgptr = ahd_le32toh(scb->hscb->sgptr);
+	if ((sgptr & SG_STATUS_VALID) != 0)
+		ahd_calc_residual(ahd, scb);
+}
+
+/*
+ * Return pointers to the transfer negotiation information
+ * for the specified our_id/remote_id pair.
+ */
+static __inline struct ahd_initiator_tinfo *
+ahd_fetch_transinfo(struct ahd_softc *ahd, char channel, u_int our_id,
+		    u_int remote_id, struct ahd_tmode_tstate **tstate)
+{
+	/*
+	 * Transfer data structures are stored from the perspective
+	 * of the target role.  Since the parameters for a connection
+	 * in the initiator role to a given target are the same as
+	 * when the roles are reversed, we pretend we are the target.
+	 */
+	if (channel == 'B')
+		our_id += 8;
+	*tstate = ahd->enabled_targets[our_id];
+	return (&(*tstate)->transinfo[remote_id]);
+}
+
+#define AHD_COPY_COL_IDX(dst, src)				\
+do {								\
+	dst->hscb->scsiid = src->hscb->scsiid;			\
+	dst->hscb->lun = src->hscb->lun;			\
+} while (0)
+
+static __inline uint16_t
+ahd_inw(struct ahd_softc *ahd, u_int port)
+{
+	return ((ahd_inb(ahd, port+1) << 8) | ahd_inb(ahd, port));
+}
+
+static __inline void
+ahd_outw(struct ahd_softc *ahd, u_int port, u_int value)
+{
+	ahd_outb(ahd, port, value & 0xFF);
+	ahd_outb(ahd, port+1, (value >> 8) & 0xFF);
+}
+
+static __inline uint32_t
+ahd_inl(struct ahd_softc *ahd, u_int port)
+{
+	return ((ahd_inb(ahd, port))
+	      | (ahd_inb(ahd, port+1) << 8)
+	      | (ahd_inb(ahd, port+2) << 16)
+	      | (ahd_inb(ahd, port+3) << 24));
+}
+
+static __inline void
+ahd_outl(struct ahd_softc *ahd, u_int port, uint32_t value)
+{
+	ahd_outb(ahd, port, (value) & 0xFF);
+	ahd_outb(ahd, port+1, ((value) >> 8) & 0xFF);
+	ahd_outb(ahd, port+2, ((value) >> 16) & 0xFF);
+	ahd_outb(ahd, port+3, ((value) >> 24) & 0xFF);
+}
+
+static __inline uint64_t
+ahd_inq(struct ahd_softc *ahd, u_int port)
+{
+	return ((ahd_inb(ahd, port))
+	      | (ahd_inb(ahd, port+1) << 8)
+	      | (ahd_inb(ahd, port+2) << 16)
+	      | (ahd_inb(ahd, port+3) << 24)
+	      | (((uint64_t)ahd_inb(ahd, port+4)) << 32)
+	      | (((uint64_t)ahd_inb(ahd, port+5)) << 40)
+	      | (((uint64_t)ahd_inb(ahd, port+6)) << 48)
+	      | (((uint64_t)ahd_inb(ahd, port+7)) << 56));
+}
+
+static __inline void
+ahd_outq(struct ahd_softc *ahd, u_int port, uint64_t value)
+{
+	ahd_outb(ahd, port, value & 0xFF);
+	ahd_outb(ahd, port+1, (value >> 8) & 0xFF);
+	ahd_outb(ahd, port+2, (value >> 16) & 0xFF);
+	ahd_outb(ahd, port+3, (value >> 24) & 0xFF);
+	ahd_outb(ahd, port+4, (value >> 32) & 0xFF);
+	ahd_outb(ahd, port+5, (value >> 40) & 0xFF);
+	ahd_outb(ahd, port+6, (value >> 48) & 0xFF);
+	ahd_outb(ahd, port+7, (value >> 56) & 0xFF);
+}
+
+static __inline u_int
+ahd_get_scbptr(struct ahd_softc *ahd)
+{
+	AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
+			 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
+	return (ahd_inb(ahd, SCBPTR) | (ahd_inb(ahd, SCBPTR + 1) << 8));
+}
+
+static __inline void
+ahd_set_scbptr(struct ahd_softc *ahd, u_int scbptr)
+{
+	AHD_ASSERT_MODES(ahd, ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK),
+			 ~(AHD_MODE_UNKNOWN_MSK|AHD_MODE_CFG_MSK));
+	ahd_outb(ahd, SCBPTR, scbptr & 0xFF);
+	ahd_outb(ahd, SCBPTR+1, (scbptr >> 8) & 0xFF);
+}
+
+static __inline u_int
+ahd_get_hnscb_qoff(struct ahd_softc *ahd)
+{
+	return (ahd_inw_atomic(ahd, HNSCB_QOFF));
+}
+
+static __inline void
+ahd_set_hnscb_qoff(struct ahd_softc *ahd, u_int value)
+{
+	ahd_outw_atomic(ahd, HNSCB_QOFF, value);
+}
+
+static __inline u_int
+ahd_get_hescb_qoff(struct ahd_softc *ahd)
+{
+	return (ahd_inb(ahd, HESCB_QOFF));
+}
+
+static __inline void
+ahd_set_hescb_qoff(struct ahd_softc *ahd, u_int value)
+{
+	ahd_outb(ahd, HESCB_QOFF, value);
+}
+
+static __inline u_int
+ahd_get_snscb_qoff(struct ahd_softc *ahd)
+{
+	u_int oldvalue;
+
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	oldvalue = ahd_inw(ahd, SNSCB_QOFF);
+	ahd_outw(ahd, SNSCB_QOFF, oldvalue);
+	return (oldvalue);
+}
+
+static __inline void
+ahd_set_snscb_qoff(struct ahd_softc *ahd, u_int value)
+{
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	ahd_outw(ahd, SNSCB_QOFF, value);
+}
+
+static __inline u_int
+ahd_get_sescb_qoff(struct ahd_softc *ahd)
+{
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	return (ahd_inb(ahd, SESCB_QOFF));
+}
+
+static __inline void
+ahd_set_sescb_qoff(struct ahd_softc *ahd, u_int value)
+{
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	ahd_outb(ahd, SESCB_QOFF, value);
+}
+
+static __inline u_int
+ahd_get_sdscb_qoff(struct ahd_softc *ahd)
+{
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	return (ahd_inb(ahd, SDSCB_QOFF) | (ahd_inb(ahd, SDSCB_QOFF + 1) << 8));
+}
+
+static __inline void
+ahd_set_sdscb_qoff(struct ahd_softc *ahd, u_int value)
+{
+	AHD_ASSERT_MODES(ahd, AHD_MODE_CCHAN_MSK, AHD_MODE_CCHAN_MSK);
+	ahd_outb(ahd, SDSCB_QOFF, value & 0xFF);
+	ahd_outb(ahd, SDSCB_QOFF+1, (value >> 8) & 0xFF);
+}
+
+static __inline u_int
+ahd_inb_scbram(struct ahd_softc *ahd, u_int offset)
+{
+	u_int value;
+
+	/*
+	 * Workaround PCI-X Rev A. hardware bug.
+	 * After a host read of SCB memory, the chip
+	 * may become confused into thinking prefetch
+	 * was required.  This starts the discard timer
+	 * running and can cause an unexpected discard
+	 * timer interrupt.  The work around is to read
+	 * a normal register prior to the exhaustion of
+	 * the discard timer.  The mode pointer register
+	 * has no side effects and so serves well for
+	 * this purpose.
+	 *
+	 * Razor #528
+	 */
+	value = ahd_inb(ahd, offset);
+	if ((ahd->flags & AHD_PCIX_SCBRAM_RD_BUG) != 0)
+		ahd_inb(ahd, MODE_PTR);
+	return (value);
+}
+
+static __inline u_int
+ahd_inw_scbram(struct ahd_softc *ahd, u_int offset)
+{
+	return (ahd_inb_scbram(ahd, offset)
+	      | (ahd_inb_scbram(ahd, offset+1) << 8));
+}
+
+static __inline uint32_t
+ahd_inl_scbram(struct ahd_softc *ahd, u_int offset)
+{
+	return (ahd_inb_scbram(ahd, offset)
+	      | (ahd_inb_scbram(ahd, offset+1) << 8)
+	      | (ahd_inb_scbram(ahd, offset+2) << 16)
+	      | (ahd_inb_scbram(ahd, offset+3) << 24));
+}
+
+static __inline struct scb *
+ahd_lookup_scb(struct ahd_softc *ahd, u_int tag)
+{
+	struct scb* scb;
+
+	if (tag >= AHD_SCB_MAX)
+		return (NULL);
+	scb = ahd->scb_data.scbindex[tag];
+	if (scb != NULL)
+		ahd_sync_scb(ahd, scb,
+			     BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
+	return (scb);
+}
+
+static __inline void
+ahd_swap_with_next_hscb(struct ahd_softc *ahd, struct scb *scb)
+{
+	struct hardware_scb *q_hscb;
+	uint32_t saved_hscb_busaddr;
+
+	/*
+	 * Our queuing method is a bit tricky.  The card
+	 * knows in advance which HSCB (by address) to download,
+	 * and we can't disappoint it.  To achieve this, the next
+	 * HSCB to download is saved off in ahd->next_queued_hscb.
+	 * When we are called to queue "an arbitrary scb",
+	 * we copy the contents of the incoming HSCB to the one
+	 * the sequencer knows about, swap HSCB pointers and
+	 * finally assign the SCB to the tag indexed location
+	 * in the scb_array.  This makes sure that we can still
+	 * locate the correct SCB by SCB_TAG.
+	 */
+	q_hscb = ahd->next_queued_hscb;
+	saved_hscb_busaddr = q_hscb->hscb_busaddr;
+	memcpy(q_hscb, scb->hscb, sizeof(*scb->hscb));
+	q_hscb->hscb_busaddr = saved_hscb_busaddr;
+	q_hscb->next_hscb_busaddr = scb->hscb->hscb_busaddr;
+
+	/* Now swap HSCB pointers. */
+	ahd->next_queued_hscb = scb->hscb;
+	scb->hscb = q_hscb;
+
+	/* Now define the mapping from tag to SCB in the scbindex */
+	ahd->scb_data.scbindex[SCB_GET_TAG(scb)] = scb;
+}
+
+/*
+ * Tell the sequencer about a new transaction to execute.
+ */
+static __inline void
+ahd_queue_scb(struct ahd_softc *ahd, struct scb *scb)
+{
+	ahd_swap_with_next_hscb(ahd, scb);
+
+	if (SCBID_IS_NULL(SCB_GET_TAG(scb)))
+		panic("Attempt to queue invalid SCB tag %x\n",
+		      SCB_GET_TAG(scb));
+
+	/*
+	 * Keep a history of SCBs we've downloaded in the qinfifo.
+	 */
+	ahd->qinfifo[AHD_QIN_WRAP(ahd->qinfifonext)] = SCB_GET_TAG(scb);
+	ahd->qinfifonext++;
+
+	if (scb->sg_count != 0)
+		ahd_setup_data_scb(ahd, scb);
+	else
+		ahd_setup_noxfer_scb(ahd, scb);
+	ahd_setup_scb_common(ahd, scb);
+
+	/*
+	 * Make sure our data is consistent from the
+	 * perspective of the adapter.
+	 */
+	ahd_sync_scb(ahd, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
+
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_QUEUE) != 0) {
+		uint64_t host_dataptr;
+
+		host_dataptr = ahd_le64toh(scb->hscb->dataptr);
+		printf("%s: Queueing SCB 0x%x bus addr 0x%x - 0x%x%x/0x%x\n",
+		       ahd_name(ahd),
+		       SCB_GET_TAG(scb), ahd_le32toh(scb->hscb->hscb_busaddr),
+		       (u_int)((host_dataptr >> 32) & 0xFFFFFFFF),
+		       (u_int)(host_dataptr & 0xFFFFFFFF),
+		       ahd_le32toh(scb->hscb->datacnt));
+	}
+#endif
+	/* Tell the adapter about the newly queued SCB */
+	ahd_set_hnscb_qoff(ahd, ahd->qinfifonext);
+}
+
+static __inline uint8_t *
+ahd_get_sense_buf(struct ahd_softc *ahd, struct scb *scb)
+{
+	return (scb->sense_data);
+}
+
+static __inline uint32_t
+ahd_get_sense_bufaddr(struct ahd_softc *ahd, struct scb *scb)
+{
+	return (scb->sense_busaddr);
+}
+
+/************************** Interrupt Processing ******************************/
+static __inline void	ahd_sync_qoutfifo(struct ahd_softc *ahd, int op);
+static __inline void	ahd_sync_tqinfifo(struct ahd_softc *ahd, int op);
+static __inline u_int	ahd_check_cmdcmpltqueues(struct ahd_softc *ahd);
+static __inline int	ahd_intr(struct ahd_softc *ahd);
+
+static __inline void
+ahd_sync_qoutfifo(struct ahd_softc *ahd, int op)
+{
+	ahd_dmamap_sync(ahd, ahd->shared_data_dmat, ahd->shared_data_dmamap,
+			/*offset*/0, /*len*/AHC_SCB_MAX * sizeof(uint16_t), op);
+}
+
+static __inline void
+ahd_sync_tqinfifo(struct ahd_softc *ahd, int op)
+{
+#ifdef AHD_TARGET_MODE
+	if ((ahd->flags & AHD_TARGETROLE) != 0) {
+		ahd_dmamap_sync(ahd, ahd->shared_data_dmat,
+				ahd->shared_data_dmamap,
+				ahd_targetcmd_offset(ahd, 0),
+				sizeof(struct target_cmd) * AHD_TMODE_CMDS,
+				op);
+	}
+#endif
+}
+
+/*
+ * See if the firmware has posted any completed commands
+ * into our in-core command complete fifos.
+ */
+#define AHD_RUN_QOUTFIFO 0x1
+#define AHD_RUN_TQINFIFO 0x2
+static __inline u_int
+ahd_check_cmdcmpltqueues(struct ahd_softc *ahd)
+{
+	u_int retval;
+
+	retval = 0;
+	ahd_dmamap_sync(ahd, ahd->shared_data_dmat, ahd->shared_data_dmamap,
+			/*offset*/ahd->qoutfifonext, /*len*/2,
+			BUS_DMASYNC_POSTREAD);
+	if ((ahd->qoutfifo[ahd->qoutfifonext]
+	     & QOUTFIFO_ENTRY_VALID_LE) == ahd->qoutfifonext_valid_tag)
+		retval |= AHD_RUN_QOUTFIFO;
+#ifdef AHD_TARGET_MODE
+	if ((ahd->flags & AHD_TARGETROLE) != 0
+	 && (ahd->flags & AHD_TQINFIFO_BLOCKED) == 0) {
+		ahd_dmamap_sync(ahd, ahd->shared_data_dmat,
+				ahd->shared_data_dmamap,
+				ahd_targetcmd_offset(ahd, ahd->tqinfifofnext),
+				/*len*/sizeof(struct target_cmd),
+				BUS_DMASYNC_POSTREAD);
+		if (ahd->targetcmds[ahd->tqinfifonext].cmd_valid != 0)
+			retval |= AHD_RUN_TQINFIFO;
+	}
+#endif
+	return (retval);
+}
+
+/*
+ * Catch an interrupt from the adapter
+ */
+static __inline int
+ahd_intr(struct ahd_softc *ahd)
+{
+	u_int	intstat;
+
+	if ((ahd->pause & INTEN) == 0) {
+		/*
+		 * Our interrupt is not enabled on the chip
+		 * and may be disabled for re-entrancy reasons,
+		 * so just return.  This is likely just a shared
+		 * interrupt.
+		 */
+		return (0);
+	}
+
+	/*
+	 * Instead of directly reading the interrupt status register,
+	 * infer the cause of the interrupt by checking our in-core
+	 * completion queues.  This avoids a costly PCI bus read in
+	 * most cases.
+	 */
+	if ((ahd->flags & AHD_ALL_INTERRUPTS) == 0
+	 && (ahd_check_cmdcmpltqueues(ahd) != 0))
+		intstat = CMDCMPLT;
+	else
+		intstat = ahd_inb(ahd, INTSTAT);
+
+	if ((intstat & INT_PEND) == 0)
+		return (0);
+
+	if (intstat & CMDCMPLT) {
+		ahd_outb(ahd, CLRINT, CLRCMDINT);
+
+		/*
+		 * Ensure that the chip sees that we've cleared
+		 * this interrupt before we walk the output fifo.
+		 * Otherwise, we may, due to posted bus writes,
+		 * clear the interrupt after we finish the scan,
+		 * and after the sequencer has added new entries
+		 * and asserted the interrupt again.
+		 */
+		if ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0) {
+			if (ahd_is_paused(ahd)) {
+				/*
+				 * Potentially lost SEQINT.
+				 * If SEQINTCODE is non-zero,
+				 * simulate the SEQINT.
+				 */
+				if (ahd_inb(ahd, SEQINTCODE) != NO_SEQINT)
+					intstat |= SEQINT;
+			}
+		} else {
+			ahd_flush_device_writes(ahd);
+		}
+		ahd_run_qoutfifo(ahd);
+		ahd->cmdcmplt_counts[ahd->cmdcmplt_bucket]++;
+		ahd->cmdcmplt_total++;
+#ifdef AHD_TARGET_MODE
+		if ((ahd->flags & AHD_TARGETROLE) != 0)
+			ahd_run_tqinfifo(ahd, /*paused*/FALSE);
+#endif
+	}
+
+	/*
+	 * Handle statuses that may invalidate our cached
+	 * copy of INTSTAT separately.
+	 */
+	if (intstat == 0xFF && (ahd->features & AHD_REMOVABLE) != 0) {
+		/* Hot eject.  Do nothing */
+	} else if (intstat & HWERRINT) {
+		ahd_handle_hwerrint(ahd);
+	} else if ((intstat & (PCIINT|SPLTINT)) != 0) {
+		ahd->bus_intr(ahd);
+	} else {
+
+		if ((intstat & SEQINT) != 0)
+			ahd_handle_seqint(ahd, intstat);
+
+		if ((intstat & SCSIINT) != 0)
+			ahd_handle_scsiint(ahd, intstat);
+	}
+	return (1);
+}
+
+#endif  /* _AIC79XX_INLINE_H_ */
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic79xx_osm.c linux-5730/drivers/scsi/aic7xxx/aic79xx_osm.c
--- linux-5720/drivers/scsi/aic7xxx/aic79xx_osm.c
+++ linux-5730/drivers/scsi/aic7xxx/aic79xx_osm.c
@@ -0,0 +1,5131 @@
+/*
+ * Adaptec AIC79xx device driver for Linux.
+ *
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.c#169 $
+ *
+ * --------------------------------------------------------------------------
+ * Copyright (c) 1994-2000 Justin T. Gibbs.
+ * Copyright (c) 1997-1999 Doug Ledford
+ * Copyright (c) 2000-2003 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ */
+
+#include "aic79xx_osm.h"
+#include "aic79xx_inline.h"
+#include <scsi/scsicam.h>
+
+/*
+ * Include aiclib.c as part of our
+ * "module dependencies are hard" work around.
+ */
+#include "aiclib.c"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+#include <linux/init.h>		/* __setup */
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#include "sd.h"			/* For geometry detection */
+#endif
+
+#include <linux/mm.h>		/* For fetching system memory size */
+
+/*
+ * Lock protecting manipulation of the ahd softc list.
+ */
+spinlock_t ahd_list_spinlock;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
+struct proc_dir_entry proc_scsi_aic79xx = {
+	PROC_SCSI_AIC79XX, 7, "aic79xx",
+	S_IFDIR | S_IRUGO | S_IXUGO, 2,
+	0, 0, 0, NULL, NULL, NULL, NULL, NULL, NULL, NULL
+};
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+/* For dynamic sglist size calculation. */
+u_int ahd_linux_nseg;
+#endif
+
+/*
+ * Bucket size for counting good commands in between bad ones.
+ */
+#define AHD_LINUX_ERR_THRESH	1000
+
+/*
+ * Set this to the delay in seconds after SCSI bus reset.
+ * Note, we honor this only for the initial bus reset.
+ * The scsi error recovery code performs its own bus settle
+ * delay handling for error recovery actions.
+ */
+#ifdef CONFIG_AIC79XX_RESET_DELAY_MS
+#define AIC79XX_RESET_DELAY CONFIG_AIC79XX_RESET_DELAY_MS
+#else
+#define AIC79XX_RESET_DELAY 5000
+#endif
+
+/*
+ * To change the default number of tagged transactions allowed per-device,
+ * add a line to the lilo.conf file like:
+ * append="aic79xx=verbose,tag_info:{{32,32,32,32},{32,32,32,32}}"
+ * which will result in the first four devices on the first two
+ * controllers being set to a tagged queue depth of 32.
+ *
+ * The tag_commands is an array of 16 to allow for wide and twin adapters.
+ * Twin adapters will use indexes 0-7 for channel 0, and indexes 8-15
+ * for channel 1.
+ */
+typedef struct {
+	uint16_t tag_commands[16];	/* Allow for wide/twin adapters. */
+} adapter_tag_info_t;
+
+/*
+ * Modify this as you see fit for your system.
+ *
+ * 0			tagged queuing disabled
+ * 1 <= n <= 253	n == max tags ever dispatched.
+ *
+ * The driver will throttle the number of commands dispatched to a
+ * device if it returns queue full.  For devices with a fixed maximum
+ * queue depth, the driver will eventually determine this depth and
+ * lock it in (a console message is printed to indicate that a lock
+ * has occurred).  On some devices, queue full is returned for a temporary
+ * resource shortage.  These devices will return queue full at varying
+ * depths.  The driver will throttle back when the queue fulls occur and
+ * attempt to slowly increase the depth over time as the device recovers
+ * from the resource shortage.
+ *
+ * In this example, the first line will disable tagged queueing for all
+ * the devices on the first probed aic79xx adapter.
+ *
+ * The second line enables tagged queueing with 4 commands/LUN for IDs
+ * (0, 2-11, 13-15), disables tagged queueing for ID 12, and tells the
+ * driver to attempt to use up to 64 tags for ID 1.
+ *
+ * The third line is the same as the first line.
+ *
+ * The fourth line disables tagged queueing for devices 0 and 3.  It
+ * enables tagged queueing for the other IDs, with 16 commands/LUN
+ * for IDs 1 and 4, 127 commands/LUN for ID 8, and 4 commands/LUN for
+ * IDs 2, 5-7, and 9-15.
+ */
+
+/*
+ * NOTE: The below structure is for reference only, the actual structure
+ *       to modify in order to change things is just below this comment block.
+adapter_tag_info_t aic79xx_tag_info[] =
+{
+	{{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
+	{{4, 64, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4}},
+	{{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}},
+	{{0, 16, 4, 0, 16, 4, 4, 4, 127, 4, 4, 4, 4, 4, 4, 4}}
+};
+*/
+
+#ifdef CONFIG_AIC79XX_CMDS_PER_DEVICE
+#define AIC79XX_CMDS_PER_DEVICE CONFIG_AIC79XX_CMDS_PER_DEVICE
+#else
+#define AIC79XX_CMDS_PER_DEVICE AHD_MAX_QUEUE
+#endif
+
+#define AIC79XX_CONFIGED_TAG_COMMANDS {					\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE,		\
+	AIC79XX_CMDS_PER_DEVICE, AIC79XX_CMDS_PER_DEVICE		\
+}
+
+/*
+ * By default, use the number of commands specified by
+ * the users kernel configuration.
+ */
+static adapter_tag_info_t aic79xx_tag_info[] =
+{
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS},
+	{AIC79XX_CONFIGED_TAG_COMMANDS}
+};
+
+/*
+ * By default, read streaming is disabled.  In theory,
+ * read streaming should enhance performance, but early
+ * U320 drive firmware actually performs slower with
+ * read streaming enabled.
+ */
+#ifdef CONFIG_AIC79XX_ENABLE_RD_STRM
+#define AIC79XX_CONFIGED_RD_STRM 0xFFFF
+#else
+#define AIC79XX_CONFIGED_RD_STRM 0
+#endif
+
+static uint16_t aic79xx_rd_strm_info[] =
+{
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM,
+	AIC79XX_CONFIGED_RD_STRM
+};
+
+/*
+ * DV option:
+ *
+ * positive value = DV Enabled
+ * zero		  = DV Disabled
+ * negative value = DV Default for adapter type/seeprom
+ */
+#ifdef CONFIG_AIC79XX_DV_SETTING
+#define AIC79XX_CONFIGED_DV CONFIG_AIC79XX_DV_SETTING
+#else
+#define AIC79XX_CONFIGED_DV -1
+#endif
+
+static int8_t aic79xx_dv_settings[] =
+{
+	AIC79XX_CONFIGED_DV,
+	AIC79XX_CONFIGED_DV,
+	AIC79XX_CONFIGED_DV,
+	AIC79XX_CONFIGED_DV,
+	AIC79XX_CONFIGED_DV,
+	AIC79XX_CONFIGED_DV,
+	AIC79XX_CONFIGED_DV,
+	AIC79XX_CONFIGED_DV,
+	AIC79XX_CONFIGED_DV,
+	AIC79XX_CONFIGED_DV,
+	AIC79XX_CONFIGED_DV,
+	AIC79XX_CONFIGED_DV,
+	AIC79XX_CONFIGED_DV,
+	AIC79XX_CONFIGED_DV,
+	AIC79XX_CONFIGED_DV,
+	AIC79XX_CONFIGED_DV
+};
+
+/*
+ * The I/O cell on the chip is very configurable in respect to its analog
+ * characteristics.  Set the defaults here; they can be overriden with
+ * the proper insmod parameters.
+ */
+struct ahd_linux_iocell_opts
+{
+	uint8_t	precomp;
+	uint8_t	slewrate;
+	uint8_t amplitude;
+};
+#define AIC79XX_DEFAULT_PRECOMP		0xFF
+#define AIC79XX_DEFAULT_SLEWRATE	0xFF
+#define AIC79XX_DEFAULT_AMPLITUDE	0xFF
+#define AIC79XX_DEFAULT_IOOPTS			\
+{						\
+	AIC79XX_DEFAULT_PRECOMP,		\
+	AIC79XX_DEFAULT_SLEWRATE,		\
+	AIC79XX_DEFAULT_AMPLITUDE		\
+}
+#define AIC79XX_PRECOMP_INDEX	0
+#define AIC79XX_SLEWRATE_INDEX	1
+#define AIC79XX_AMPLITUDE_INDEX	2
+static struct ahd_linux_iocell_opts aic79xx_iocell_info[] =
+{
+	AIC79XX_DEFAULT_IOOPTS,
+	AIC79XX_DEFAULT_IOOPTS,
+	AIC79XX_DEFAULT_IOOPTS,
+	AIC79XX_DEFAULT_IOOPTS,
+	AIC79XX_DEFAULT_IOOPTS,
+	AIC79XX_DEFAULT_IOOPTS,
+	AIC79XX_DEFAULT_IOOPTS,
+	AIC79XX_DEFAULT_IOOPTS,
+	AIC79XX_DEFAULT_IOOPTS,
+	AIC79XX_DEFAULT_IOOPTS,
+	AIC79XX_DEFAULT_IOOPTS,
+	AIC79XX_DEFAULT_IOOPTS,
+	AIC79XX_DEFAULT_IOOPTS,
+	AIC79XX_DEFAULT_IOOPTS,
+	AIC79XX_DEFAULT_IOOPTS,
+	AIC79XX_DEFAULT_IOOPTS
+};
+
+/*
+ * There should be a specific return value for this in scsi.h, but
+ * it seems that most drivers ignore it.
+ */
+#define DID_UNDERFLOW   DID_ERROR
+
+void
+ahd_print_path(struct ahd_softc *ahd, struct scb *scb)
+{
+	printk("(scsi%d:%c:%d:%d): ",
+	       ahd->platform_data->host->host_no,
+	       scb != NULL ? SCB_GET_CHANNEL(ahd, scb) : 'X',
+	       scb != NULL ? SCB_GET_TARGET(ahd, scb) : -1,
+	       scb != NULL ? SCB_GET_LUN(scb) : -1);
+}
+
+/*
+ * XXX - these options apply unilaterally to _all_ adapters
+ *       cards in the system.  This should be fixed.  Exceptions to this
+ *       rule are noted in the comments.
+ */
+
+/*
+ * Skip the scsi bus reset.  Non 0 make us skip the reset at startup.  This
+ * has no effect on any later resets that might occur due to things like
+ * SCSI bus timeouts.
+ */
+static uint32_t aic79xx_no_reset;
+
+/*
+ * Certain PCI motherboards will scan PCI devices from highest to lowest,
+ * others scan from lowest to highest, and they tend to do all kinds of
+ * strange things when they come into contact with PCI bridge chips.  The
+ * net result of all this is that the PCI card that is actually used to boot
+ * the machine is very hard to detect.  Most motherboards go from lowest
+ * PCI slot number to highest, and the first SCSI controller found is the
+ * one you boot from.  The only exceptions to this are when a controller
+ * has its BIOS disabled.  So, we by default sort all of our SCSI controllers
+ * from lowest PCI slot number to highest PCI slot number.  We also force
+ * all controllers with their BIOS disabled to the end of the list.  This
+ * works on *almost* all computers.  Where it doesn't work, we have this
+ * option.  Setting this option to non-0 will reverse the order of the sort
+ * to highest first, then lowest, but will still leave cards with their BIOS
+ * disabled at the very end.  That should fix everyone up unless there are
+ * really strange cirumstances.
+ */
+static uint32_t aic79xx_reverse_scan;
+
+/*
+ * Should we force EXTENDED translation on a controller.
+ *     0 == Use whatever is in the SEEPROM or default to off
+ *     1 == Use whatever is in the SEEPROM or default to on
+ */
+static uint32_t aic79xx_extended;
+
+/*
+ * PCI bus parity checking of the Adaptec controllers.  This is somewhat
+ * dubious at best.  To my knowledge, this option has never actually
+ * solved a PCI parity problem, but on certain machines with broken PCI
+ * chipset configurations, it can generate tons of false error messages.
+ * It's included in the driver for completeness.
+ *   0	   = Shut off PCI parity check
+ *   non-0 = Enable PCI parity check
+ *
+ * NOTE: you can't actually pass -1 on the lilo prompt.  So, to set this
+ * variable to -1 you would actually want to simply pass the variable
+ * name without a number.  That will invert the 0 which will result in
+ * -1.
+ */
+static uint32_t aic79xx_pci_parity = ~0;
+
+/*
+ * There are lots of broken chipsets in the world.  Some of them will
+ * violate the PCI spec when we issue byte sized memory writes to our
+ * controller.  I/O mapped register access, if allowed by the given
+ * platform, will work in almost all cases.
+ */
+uint32_t aic79xx_allow_memio = ~0;
+
+/*
+ * aic79xx_detect() has been run, so register all device arrivals
+ * immediately with the system rather than deferring to the sorted
+ * attachment performed by aic79xx_detect().
+ */
+int aic79xx_detect_complete;
+
+/*
+ * So that we can set how long each device is given as a selection timeout.
+ * The table of values goes like this:
+ *   0 - 256ms
+ *   1 - 128ms
+ *   2 - 64ms
+ *   3 - 32ms
+ * We default to 256ms because some older devices need a longer time
+ * to respond to initial selection.
+ */
+static uint32_t aic79xx_seltime;
+
+/*
+ * Certain devices do not perform any aging on commands.  Should the
+ * device be saturated by commands in one portion of the disk, it is
+ * possible for transactions on far away sectors to never be serviced.
+ * To handle these devices, we can periodically send an ordered tag to
+ * force all outstanding transactions to be serviced prior to a new
+ * transaction.
+ */
+uint32_t aic79xx_periodic_otag;
+
+/*
+ * Module information and settable options.
+ */
+#ifdef MODULE
+static char *aic79xx = NULL;
+/*
+ * Just in case someone uses commas to separate items on the insmod
+ * command line, we define a dummy buffer here to avoid having insmod
+ * write wild stuff into our code segment
+ */
+static char dummy_buffer[60] = "Please don't trounce on me insmod!!\n";
+
+MODULE_AUTHOR("Maintainer: Justin T. Gibbs <gibbs@scsiguy.com>");
+MODULE_DESCRIPTION("Adaptec Aic77XX/78XX SCSI Host Bus Adapter driver");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("Dual BSD/GPL");
+#endif
+MODULE_PARM(aic79xx, "s");
+MODULE_PARM_DESC(aic79xx,
+"period delimited, options string.\n"
+"	verbose			Enable verbose/diagnostic logging\n"
+"	attach_HostRAID:<int>	Attach to controllers in HostRAID mode\n"
+"	allow_memio		Allow device registers to be memory mapped\n"
+"	debug			Bitmask of debug values to enable\n"
+"	no_reset		Supress initial bus resets\n"
+"	extended		Enable extended geometry on all controllers\n"
+"	periodic_otag		Send an ordered tagged transaction\n"
+"				periodically to prevent tag starvation.\n"
+"				This may be required by some older disk\n"
+"				or drives/RAID arrays.\n"
+"	reverse_scan		Sort PCI devices highest Bus/Slot to lowest\n"
+"	tag_info:<tag_str>	Set per-target tag depth\n"
+"	global_tag_depth:<int>	Global tag depth for all targets on all buses\n"
+"	rd_strm:<rd_strm_masks> Set per-target read streaming setting.\n"
+"	dv:<dv_settings>	Set per-controller Domain Validation Setting.\n"
+"	slewrate:<slewrate_list>Set the signal slew rate (0-15).\n"
+"	precomp:<pcomp_list>	Set the signal precompensation (0-7).\n"
+"	amplitude:<int>		Set the signal amplitude (0-7).\n"
+"	seltime:<int>		Selection Timeout:\n"
+"				(0/256ms,1/128ms,2/64ms,3/32ms)\n"
+"\n"
+"	Sample /etc/modules.conf line:\n"
+"		Enable verbose logging\n"
+"		Set tag depth on Controller 2/Target 2 to 10 tags\n"
+"		Shorten the selection timeout to 128ms\n"
+"\n"
+"	options aic79xx 'aic79xx=verbose.tag_info:{{}.{}.{..10}}.seltime:1'\n"
+"\n"
+"	Sample /etc/modules.conf line:\n"
+"		Change Read Streaming for Controller's 2 and 3\n"
+"\n"
+"	options aic79xx 'aic79xx=rd_strm:{..0xFFF0.0xC0F0}'");
+#endif
+
+static void ahd_linux_handle_scsi_status(struct ahd_softc *,
+					 struct ahd_linux_device *,
+					 struct scb *);
+static void ahd_linux_queue_cmd_complete(struct ahd_softc *ahd,
+					 Scsi_Cmnd *cmd);
+static void ahd_linux_filter_inquiry(struct ahd_softc *ahd,
+				     struct ahd_devinfo *devinfo);
+static void ahd_linux_dev_timed_unfreeze(u_long arg);
+static void ahd_linux_sem_timeout(u_long arg);
+static void ahd_linux_initialize_scsi_bus(struct ahd_softc *ahd);
+static void ahd_linux_size_nseg(void);
+static void ahd_linux_thread_run_complete_queue(struct ahd_softc *ahd);
+static void ahd_linux_start_dv(struct ahd_softc *ahd);
+static void ahd_linux_dv_timeout(struct scsi_cmnd *cmd);
+static int  ahd_linux_dv_thread(void *data);
+static void ahd_linux_kill_dv_thread(struct ahd_softc *ahd);
+static void ahd_linux_dv_target(struct ahd_softc *ahd, u_int target);
+static void ahd_linux_dv_transition(struct ahd_softc *ahd,
+				    struct scsi_cmnd *cmd,
+				    struct ahd_devinfo *devinfo,
+				    struct ahd_linux_target *targ);
+static void ahd_linux_dv_fill_cmd(struct ahd_softc *ahd,
+				  struct scsi_cmnd *cmd,
+				  struct ahd_devinfo *devinfo);
+static void ahd_linux_dv_inq(struct ahd_softc *ahd,
+			     struct scsi_cmnd *cmd,
+			     struct ahd_devinfo *devinfo,
+			     struct ahd_linux_target *targ,
+			     u_int request_length);
+static void ahd_linux_dv_tur(struct ahd_softc *ahd,
+			     struct scsi_cmnd *cmd,
+			     struct ahd_devinfo *devinfo);
+static void ahd_linux_dv_rebd(struct ahd_softc *ahd,
+			      struct scsi_cmnd *cmd,
+			      struct ahd_devinfo *devinfo,
+			      struct ahd_linux_target *targ);
+static void ahd_linux_dv_web(struct ahd_softc *ahd,
+			     struct scsi_cmnd *cmd,
+			     struct ahd_devinfo *devinfo,
+			     struct ahd_linux_target *targ);
+static void ahd_linux_dv_reb(struct ahd_softc *ahd,
+			     struct scsi_cmnd *cmd,
+			     struct ahd_devinfo *devinfo,
+			     struct ahd_linux_target *targ);
+static void ahd_linux_dv_su(struct ahd_softc *ahd,
+			    struct scsi_cmnd *cmd,
+			    struct ahd_devinfo *devinfo,
+			    struct ahd_linux_target *targ);
+static __inline int
+	   ahd_linux_dv_fallback(struct ahd_softc *ahd,
+				 struct ahd_devinfo *devinfo);
+static int ahd_linux_fallback(struct ahd_softc *ahd,
+			      struct ahd_devinfo *devinfo);
+static __inline int ahd_linux_dv_fallback(struct ahd_softc *ahd,
+					  struct ahd_devinfo *devinfo);
+static void ahd_linux_dv_complete(Scsi_Cmnd *cmd);
+static void ahd_linux_generate_dv_pattern(struct ahd_linux_target *targ);
+static u_int ahd_linux_user_tagdepth(struct ahd_softc *ahd,
+				     struct ahd_devinfo *devinfo);
+static u_int ahd_linux_user_dv_setting(struct ahd_softc *ahd);
+static void ahd_linux_setup_user_rd_strm_settings(struct ahd_softc *ahd);
+static void ahd_linux_device_queue_depth(struct ahd_softc *ahd,
+					 struct ahd_linux_device *dev);
+static struct ahd_linux_target*	ahd_linux_alloc_target(struct ahd_softc*,
+						       u_int, u_int);
+static void			ahd_linux_free_target(struct ahd_softc*,
+						      struct ahd_linux_target*);
+static struct ahd_linux_device*	ahd_linux_alloc_device(struct ahd_softc*,
+						       struct ahd_linux_target*,
+						       u_int);
+static void			ahd_linux_free_device(struct ahd_softc*,
+						      struct ahd_linux_device*);
+static void ahd_linux_run_device_queue(struct ahd_softc*,
+				       struct ahd_linux_device*);
+static void ahd_linux_setup_tag_info_global(char *p);
+static aic_option_callback_t ahd_linux_setup_tag_info;
+static aic_option_callback_t ahd_linux_setup_rd_strm_info;
+static aic_option_callback_t ahd_linux_setup_dv;
+static aic_option_callback_t ahd_linux_setup_iocell_info;
+static int ahd_linux_next_unit(void);
+static void ahd_runq_tasklet(unsigned long data);
+static int aic79xx_setup(char *c);
+
+/****************************** Inlines ***************************************/
+static __inline void ahd_schedule_completeq(struct ahd_softc *ahd);
+static __inline void ahd_schedule_runq(struct ahd_softc *ahd);
+static __inline void ahd_setup_runq_tasklet(struct ahd_softc *ahd);
+static __inline void ahd_teardown_runq_tasklet(struct ahd_softc *ahd);
+static __inline struct ahd_linux_device*
+		     ahd_linux_get_device(struct ahd_softc *ahd, u_int channel,
+					  u_int target, u_int lun, int alloc);
+static struct ahd_cmd *ahd_linux_run_complete_queue(struct ahd_softc *ahd);
+static __inline void ahd_linux_check_device_queue(struct ahd_softc *ahd,
+						  struct ahd_linux_device *dev);
+static __inline struct ahd_linux_device *
+		     ahd_linux_next_device_to_run(struct ahd_softc *ahd);
+static __inline void ahd_linux_run_device_queues(struct ahd_softc *ahd);
+static __inline void ahd_linux_unmap_scb(struct ahd_softc*, struct scb*);
+
+static __inline int ahd_linux_map_seg(struct ahd_softc *ahd, struct scb *scb,
+		 		      struct ahd_dma_seg *sg,
+				      bus_addr_t addr, bus_size_t len);
+
+static __inline void
+ahd_schedule_completeq(struct ahd_softc *ahd)
+{
+	if ((ahd->platform_data->flags & AHD_RUN_CMPLT_Q_TIMER) == 0) {
+		ahd->platform_data->flags |= AHD_RUN_CMPLT_Q_TIMER;
+		ahd->platform_data->completeq_timer.expires = jiffies;
+		add_timer(&ahd->platform_data->completeq_timer);
+	}
+}
+
+/*
+ * Must be called with our lock held.
+ */
+static __inline void
+ahd_schedule_runq(struct ahd_softc *ahd)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	tasklet_schedule(&ahd->platform_data->runq_tasklet);
+#else
+	/*
+	 * Tasklets are not available, so run inline.
+	 */
+	ahd_runq_tasklet((unsigned long)ahd);
+#endif
+}
+
+static __inline
+void ahd_setup_runq_tasklet(struct ahd_softc *ahd)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	tasklet_init(&ahd->platform_data->runq_tasklet, ahd_runq_tasklet,
+		     (unsigned long)ahd);
+#endif
+}
+
+static __inline void
+ahd_teardown_runq_tasklet(struct ahd_softc *ahd)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	tasklet_kill(&ahd->platform_data->runq_tasklet);
+#endif
+}
+
+static __inline struct ahd_linux_device*
+ahd_linux_get_device(struct ahd_softc *ahd, u_int channel, u_int target,
+		     u_int lun, int alloc)
+{
+	struct ahd_linux_target *targ;
+	struct ahd_linux_device *dev;
+	u_int target_offset;
+
+	target_offset = target;
+	if (channel != 0)
+		target_offset += 8;
+	targ = ahd->platform_data->targets[target_offset];
+	if (targ == NULL) {
+		if (alloc != 0) {
+			targ = ahd_linux_alloc_target(ahd, channel, target);
+			if (targ == NULL)
+				return (NULL);
+		} else
+			return (NULL);
+	}
+	dev = targ->devices[lun];
+	if (dev == NULL && alloc != 0)
+		dev = ahd_linux_alloc_device(ahd, targ, lun);
+	return (dev);
+}
+
+#define AHD_LINUX_MAX_RETURNED_ERRORS 4
+static struct ahd_cmd *
+ahd_linux_run_complete_queue(struct ahd_softc *ahd)
+{	
+	struct	ahd_cmd *acmd;
+	u_long	done_flags;
+	int	with_errors;
+
+	with_errors = 0;
+	ahd_done_lock(ahd, &done_flags);
+	while ((acmd = TAILQ_FIRST(&ahd->platform_data->completeq)) != NULL) {
+		Scsi_Cmnd *cmd;
+
+		if (with_errors > AHD_LINUX_MAX_RETURNED_ERRORS) {
+			/*
+			 * Linux uses stack recursion to requeue
+			 * commands that need to be retried.  Avoid
+			 * blowing out the stack by "spoon feeding"
+			 * commands that completed with error back
+			 * the operating system in case they are going
+			 * to be retried. "ick"
+			 */
+			ahd_schedule_completeq(ahd);
+			break;
+		}
+		TAILQ_REMOVE(&ahd->platform_data->completeq,
+			     acmd, acmd_links.tqe);
+		cmd = &acmd_scsi_cmd(acmd);
+		cmd->host_scribble = NULL;
+		if (ahd_cmd_get_transaction_status(cmd) != DID_OK
+		 || (cmd->result & 0xFF) != SCSI_STATUS_OK)
+			with_errors++;
+
+		cmd->scsi_done(cmd);
+	}
+	ahd_done_unlock(ahd, &done_flags);
+	return (acmd);
+}
+
+static __inline void
+ahd_linux_check_device_queue(struct ahd_softc *ahd,
+			     struct ahd_linux_device *dev)
+{
+	if ((dev->flags & AHD_DEV_FREEZE_TIL_EMPTY) != 0
+	 && dev->active == 0) {
+		dev->flags &= ~AHD_DEV_FREEZE_TIL_EMPTY;
+		dev->qfrozen--;
+	}
+
+	if (TAILQ_FIRST(&dev->busyq) == NULL
+	 || dev->openings == 0 || dev->qfrozen != 0)
+		return;
+
+	ahd_linux_run_device_queue(ahd, dev);
+}
+
+static __inline struct ahd_linux_device *
+ahd_linux_next_device_to_run(struct ahd_softc *ahd)
+{
+	
+	if ((ahd->flags & AHD_RESOURCE_SHORTAGE) != 0
+	 || (ahd->platform_data->qfrozen != 0
+	  && AHD_DV_SIMQ_FROZEN(ahd) == 0))
+		return (NULL);
+	return (TAILQ_FIRST(&ahd->platform_data->device_runq));
+}
+
+static __inline void
+ahd_linux_run_device_queues(struct ahd_softc *ahd)
+{
+	struct ahd_linux_device *dev;
+
+	while ((dev = ahd_linux_next_device_to_run(ahd)) != NULL) {
+		TAILQ_REMOVE(&ahd->platform_data->device_runq, dev, links);
+		dev->flags &= ~AHD_DEV_ON_RUN_LIST;
+		ahd_linux_check_device_queue(ahd, dev);
+	}
+}
+
+static __inline void
+ahd_linux_unmap_scb(struct ahd_softc *ahd, struct scb *scb)
+{
+	Scsi_Cmnd *cmd;
+	int direction;
+
+	cmd = scb->io_ctx;
+	direction = scsi_to_pci_dma_dir(cmd->sc_data_direction);
+	ahd_sync_sglist(ahd, scb, BUS_DMASYNC_POSTWRITE);
+	if (cmd->use_sg != 0) {
+		struct scatterlist *sg;
+
+		sg = (struct scatterlist *)cmd->request_buffer;
+		pci_unmap_sg(ahd->dev_softc, sg, cmd->use_sg, direction);
+	} else if (cmd->request_bufflen != 0) {
+		pci_unmap_single(ahd->dev_softc,
+				 scb->platform_data->buf_busaddr,
+				 cmd->request_bufflen, direction);
+	}
+}
+
+static __inline int
+ahd_linux_map_seg(struct ahd_softc *ahd, struct scb *scb,
+		  struct ahd_dma_seg *sg, bus_addr_t addr, bus_size_t len)
+{
+	int	 consumed;
+
+	if ((scb->sg_count + 1) > AHD_NSEG)
+		panic("Too few segs for dma mapping.  "
+		      "Increase AHD_NSEG\n");
+
+	consumed = 1;
+	sg->addr = ahd_htole32(addr & 0xFFFFFFFF);
+	scb->platform_data->xfer_len += len;
+
+	if (sizeof(bus_addr_t) > 4
+	 && (ahd->flags & AHD_39BIT_ADDRESSING) != 0)
+		len |= (addr >> 8) & AHD_SG_HIGH_ADDR_MASK;
+
+	sg->len = ahd_htole32(len);
+	return (consumed);
+}
+
+/******************************** Macros **************************************/
+#define BUILD_SCSIID(ahd, cmd)						\
+	((((cmd)->device->id << TID_SHIFT) & TID) | (ahd)->our_id)
+
+/************************  Host template entry points *************************/
+static int	   ahd_linux_detect(Scsi_Host_Template *);
+static const char *ahd_linux_info(struct Scsi_Host *);
+static int	   ahd_linux_queue(Scsi_Cmnd *, void (*)(Scsi_Cmnd *));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static int	   ahd_linux_slave_alloc(Scsi_Device *);
+static int	   ahd_linux_slave_configure(Scsi_Device *);
+static void	   ahd_linux_slave_destroy(Scsi_Device *);
+#if defined(__i386__)
+static int	   ahd_linux_biosparam(struct scsi_device*,
+				       struct block_device*, sector_t, int[]);
+#endif
+#else
+static int	   ahd_linux_release(struct Scsi_Host *);
+static void	   ahd_linux_select_queue_depth(struct Scsi_Host *host,
+						Scsi_Device *scsi_devs);
+#if defined(__i386__)
+static int	   ahd_linux_biosparam(Disk *, kdev_t, int[]);
+#endif
+#endif
+static int	   ahd_linux_bus_reset(Scsi_Cmnd *);
+static int	   ahd_linux_dev_reset(Scsi_Cmnd *);
+static int	   ahd_linux_abort(Scsi_Cmnd *);
+
+/*
+ * Calculate a safe value for AHD_NSEG (as expressed through ahd_linux_nseg).
+ *
+ * In pre-2.5.X...
+ * The midlayer allocates an S/G array dynamically when a command is issued
+ * using SCSI malloc.  This array, which is in an OS dependent format that
+ * must later be copied to our private S/G list, is sized to house just the
+ * number of segments needed for the current transfer.  Since the code that
+ * sizes the SCSI malloc pool does not take into consideration fragmentation
+ * of the pool, executing transactions numbering just a fraction of our
+ * concurrent transaction limit with SG list lengths aproaching AHC_NSEG will
+ * quickly depleat the SCSI malloc pool of usable space.  Unfortunately, the
+ * mid-layer does not properly handle this scsi malloc failures for the S/G
+ * array and the result can be a lockup of the I/O subsystem.  We try to size
+ * our S/G list so that it satisfies our drivers allocation requirements in
+ * addition to avoiding fragmentation of the SCSI malloc pool.
+ */
+static void
+ahd_linux_size_nseg(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	u_int cur_size;
+	u_int best_size;
+
+	/*
+	 * The SCSI allocator rounds to the nearest 512 bytes
+	 * an cannot allocate across a page boundary.  Our algorithm
+	 * is to start at 1K of scsi malloc space per-command and
+	 * loop through all factors of the PAGE_SIZE and pick the best.
+	 */
+	best_size = 0;
+	for (cur_size = 1024; cur_size <= PAGE_SIZE; cur_size *= 2) {
+		u_int nseg;
+
+		nseg = cur_size / sizeof(struct scatterlist);
+		if (nseg < AHD_LINUX_MIN_NSEG)
+			continue;
+
+		if (best_size == 0) {
+			best_size = cur_size;
+			ahd_linux_nseg = nseg;
+		} else {
+			u_int best_rem;
+			u_int cur_rem;
+
+			/*
+			 * Compare the traits of the current "best_size"
+			 * with the current size to determine if the
+			 * current size is a better size.
+			 */
+			best_rem = best_size % sizeof(struct scatterlist);
+			cur_rem = cur_size % sizeof(struct scatterlist);
+			if (cur_rem < best_rem) {
+				best_size = cur_size;
+				ahd_linux_nseg = nseg;
+			}
+		}
+	}
+#endif
+}
+
+/*
+ * Try to detect an Adaptec 79XX controller.
+ */
+static int
+ahd_linux_detect(Scsi_Host_Template *template)
+{
+	struct	ahd_softc *ahd;
+	int     found;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	/*
+	 * It is a bug that the upper layer takes
+	 * this lock just prior to calling us.
+	 */
+	spin_unlock_irq(&io_request_lock);
+#endif
+
+	/*
+	 * Sanity checking of Linux SCSI data structures so
+	 * that some of our hacks^H^H^H^H^Hassumptions aren't
+	 * violated.
+	 */
+	if (offsetof(struct ahd_cmd_internal, end)
+	  > offsetof(struct scsi_cmnd, host_scribble)) {
+		printf("ahd_linux_detect: SCSI data structures changed.\n");
+		printf("ahd_linux_detect: Unable to attach\n");
+		return (0);
+	}
+	/*
+	 * Determine an appropriate size for our Scatter Gatther lists.
+	 */
+	ahd_linux_size_nseg();
+#ifdef MODULE
+	/*
+	 * If we've been passed any parameters, process them now.
+	 */
+	if (aic79xx)
+		aic79xx_setup(aic79xx);
+	if (dummy_buffer[0] != 'P')
+		printk(KERN_WARNING
+"aic79xx: Please read the file /usr/src/linux/drivers/scsi/README.aic79xx\n"
+"aic79xx: to see the proper way to specify options to the aic79xx module\n"
+"aic79xx: Specifically, don't use any commas when passing arguments to\n"
+"aic79xx: insmod or else it might trash certain memory areas.\n");
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
+	template->proc_name = "aic79xx";
+#else
+	template->proc_dir = &proc_scsi_aic79xx;
+#endif
+
+	/*
+	 * Initialize our softc list lock prior to
+	 * probing for any adapters.
+	 */
+	ahd_list_lockinit();
+
+#ifdef CONFIG_PCI
+	ahd_linux_pci_init();
+#endif
+
+	/*
+	 * Register with the SCSI layer all
+	 * controllers we've found.
+	 */
+	found = 0;
+	TAILQ_FOREACH(ahd, &ahd_tailq, links) {
+
+		if (ahd_linux_register_host(ahd, template) == 0)
+			found++;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	spin_lock_irq(&io_request_lock);
+#endif
+	aic79xx_detect_complete++;
+	return (found);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+/*
+ * Free the passed in Scsi_Host memory structures prior to unloading the
+ * module.
+ */
+static int
+ahd_linux_release(struct Scsi_Host * host)
+{
+	struct ahd_softc *ahd;
+	u_long l;
+
+	ahd_list_lock(&l);
+	if (host != NULL) {
+
+		/*
+		 * We should be able to just perform
+		 * the free directly, but check our
+		 * list for extra sanity.
+		 */
+		ahd = ahd_find_softc(*(struct ahd_softc **)host->hostdata);
+		if (ahd != NULL) {
+			u_long s;
+
+			ahd_lock(ahd, &s);
+			ahd_intr_enable(ahd, FALSE);
+			ahd_unlock(ahd, &s);
+			ahd_free(ahd);
+		}
+	}
+	ahd_list_unlock(&l);
+	return (0);
+}
+#endif
+
+/*
+ * Return a string describing the driver.
+ */
+static const char *
+ahd_linux_info(struct Scsi_Host *host)
+{
+	static char buffer[512];
+	char	ahd_info[256];
+	char   *bp;
+	struct ahd_softc *ahd;
+
+	bp = &buffer[0];
+	ahd = *(struct ahd_softc **)host->hostdata;
+	memset(bp, 0, sizeof(buffer));
+	strcpy(bp, "Adaptec AIC79XX PCI-X SCSI HBA DRIVER, Rev ");
+	strcat(bp, AIC79XX_DRIVER_VERSION);
+	strcat(bp, "\n");
+	strcat(bp, "        <");
+	strcat(bp, ahd->description);
+	strcat(bp, ">\n");
+	strcat(bp, "        ");
+	ahd_controller_info(ahd, ahd_info);
+	strcat(bp, ahd_info);
+	strcat(bp, "\n");
+
+	return (bp);
+}
+
+/*
+ * Queue an SCB to the controller.
+ */
+static int
+ahd_linux_queue(Scsi_Cmnd * cmd, void (*scsi_done) (Scsi_Cmnd *))
+{
+	struct	 ahd_softc *ahd;
+	struct	 ahd_linux_device *dev;
+	u_long	 flags;
+
+	ahd = *(struct ahd_softc **)cmd->device->host->hostdata;
+
+	/*
+	 * Save the callback on completion function.
+	 */
+	cmd->scsi_done = scsi_done;
+
+	ahd_midlayer_entrypoint_lock(ahd, &flags);
+
+	/*
+	 * Close the race of a command that was in the process of
+	 * being queued to us just as our simq was frozen.  Let
+	 * DV commands through so long as we are only frozen to
+	 * perform DV.
+	 */
+	if (ahd->platform_data->qfrozen != 0
+	 && AHD_DV_CMD(cmd) == 0) {
+
+		ahd_cmd_set_transaction_status(cmd, CAM_REQUEUE_REQ);
+		ahd_linux_queue_cmd_complete(ahd, cmd);
+		ahd_schedule_completeq(ahd);
+		ahd_midlayer_entrypoint_unlock(ahd, &flags);
+		return (0);
+	}
+	dev = ahd_linux_get_device(ahd, cmd->device->channel,
+				   cmd->device->id, cmd->device->lun,
+				   /*alloc*/TRUE);
+	if (dev == NULL) {
+		ahd_cmd_set_transaction_status(cmd, CAM_RESRC_UNAVAIL);
+		ahd_linux_queue_cmd_complete(ahd, cmd);
+		ahd_schedule_completeq(ahd);
+		ahd_midlayer_entrypoint_unlock(ahd, &flags);
+		printf("%s: aic79xx_linux_queue - Unable to allocate device!\n",
+		       ahd_name(ahd));
+		return (0);
+	}
+	if (cmd->cmd_len > MAX_CDB_LEN)
+		return (-EINVAL);
+	cmd->result = CAM_REQ_INPROG << 16;
+	TAILQ_INSERT_TAIL(&dev->busyq, (struct ahd_cmd *)cmd, acmd_links.tqe);
+	if ((dev->flags & AHD_DEV_ON_RUN_LIST) == 0) {
+		TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq, dev, links);
+		dev->flags |= AHD_DEV_ON_RUN_LIST;
+		ahd_linux_run_device_queues(ahd);
+	}
+	ahd_midlayer_entrypoint_unlock(ahd, &flags);
+	return (0);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static int
+ahd_linux_slave_alloc(Scsi_Device *device)
+{
+	struct	ahd_softc *ahd;
+
+	ahd = *((struct ahd_softc **)device->host->hostdata);
+	if (bootverbose)
+		printf("%s: Slave Alloc %d\n", ahd_name(ahd), device->id);
+	return (0);
+}
+
+static int
+ahd_linux_slave_configure(Scsi_Device *device)
+{
+	struct	ahd_softc *ahd;
+	struct	ahd_linux_device *dev;
+	u_long	flags;
+
+	ahd = *((struct ahd_softc **)device->host->hostdata);
+	if (bootverbose)
+		printf("%s: Slave Configure %d\n", ahd_name(ahd), device->id);
+	ahd_midlayer_entrypoint_lock(ahd, &flags);
+	/*
+	 * Since Linux has attached to the device, configure
+	 * it so we don't free and allocate the device
+	 * structure on every command.
+	 */
+	dev = ahd_linux_get_device(ahd, device->channel,
+				   device->id, device->lun,
+				   /*alloc*/TRUE);
+	if (dev != NULL) {
+		dev->flags &= ~AHD_DEV_UNCONFIGURED;
+		dev->flags |= AHD_DEV_SLAVE_CONFIGURED;
+		dev->scsi_device = device;
+		ahd_linux_device_queue_depth(ahd, dev);
+	}
+	ahd_midlayer_entrypoint_unlock(ahd, &flags);
+	return (0);
+}
+
+static void
+ahd_linux_slave_destroy(Scsi_Device *device)
+{
+	struct	ahd_softc *ahd;
+	struct	ahd_linux_device *dev;
+	u_long	flags;
+
+	ahd = *((struct ahd_softc **)device->host->hostdata);
+	if (bootverbose)
+		printf("%s: Slave Destroy %d\n", ahd_name(ahd), device->id);
+	ahd_midlayer_entrypoint_lock(ahd, &flags);
+	dev = ahd_linux_get_device(ahd, device->channel,
+				   device->id, device->lun,
+					   /*alloc*/FALSE);
+
+	/*
+	 * Filter out "silly" deletions of real devices by only
+	 * deleting devices that have had slave_configure()
+	 * called on them.  All other devices that have not
+	 * been configured will automatically be deleted by
+	 * the refcounting process.
+	 */
+	if (dev != NULL
+	 && (dev->flags & AHD_DEV_SLAVE_CONFIGURED) != 0) {
+		dev->flags |= AHD_DEV_UNCONFIGURED;
+		if (TAILQ_EMPTY(&dev->busyq)
+		 && dev->active == 0
+		 && (dev->flags & AHD_DEV_TIMER_ACTIVE) == 0)
+			ahd_linux_free_device(ahd, dev);
+	}
+	ahd_midlayer_entrypoint_unlock(ahd, &flags);
+}
+#else
+/*
+ * Sets the queue depth for each SCSI device hanging
+ * off the input host adapter.
+ */
+static void
+ahd_linux_select_queue_depth(struct Scsi_Host * host,
+			     Scsi_Device * scsi_devs)
+{
+	Scsi_Device *device;
+	Scsi_Device *ldev;
+	struct	ahd_softc *ahd;
+	u_long	flags;
+
+	ahd = *((struct ahd_softc **)host->hostdata);
+	ahd_lock(ahd, &flags);
+	for (device = scsi_devs; device != NULL; device = device->next) {
+
+		/*
+		 * Watch out for duplicate devices.  This works around
+		 * some quirks in how the SCSI scanning code does its
+		 * device management.
+		 */
+		for (ldev = scsi_devs; ldev != device; ldev = ldev->next) {
+			if (ldev->host == device->host
+			 && ldev->channel == device->channel
+			 && ldev->id == device->id
+			 && ldev->lun == device->lun)
+				break;
+		}
+		/* Skip duplicate. */
+		if (ldev != device)
+			continue;
+
+		if (device->host == host) {
+			struct	 ahd_linux_device *dev;
+
+			/*
+			 * Since Linux has attached to the device, configure
+			 * it so we don't free and allocate the device
+			 * structure on every command.
+			 */
+			dev = ahd_linux_get_device(ahd, device->channel,
+						   device->id, device->lun,
+						   /*alloc*/TRUE);
+			if (dev != NULL) {
+				dev->flags &= ~AHD_DEV_UNCONFIGURED;
+				dev->scsi_device = device;
+				ahd_linux_device_queue_depth(ahd, dev);
+				device->queue_depth = dev->openings
+						    + dev->active;
+				if ((dev->flags & (AHD_DEV_Q_BASIC
+						| AHD_DEV_Q_TAGGED)) == 0) {
+					/*
+					 * We allow the OS to queue 2 untagged
+					 * transactions to us at any time even
+					 * though we can only execute them
+					 * serially on the controller/device.
+					 * This should remove some latency.
+					 */
+					device->queue_depth = 2;
+				}
+			}
+		}
+	}
+	ahd_unlock(ahd, &flags);
+}
+#endif
+
+#if defined(__i386__)
+/*
+ * Return the disk geometry for the given SCSI device.
+ */
+static int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+ahd_linux_biosparam(struct scsi_device *sdev, struct block_device *bdev,
+		    sector_t capacity, int geom[])
+{
+	uint8_t *bh;
+#else
+ahd_linux_biosparam(Disk *disk, kdev_t dev, int geom[])
+{
+	struct	scsi_device *sdev = disk->device;
+	u_long	capacity = disk->capacity;
+	struct	buffer_head *bh;
+#endif
+	int	 heads;
+	int	 sectors;
+	int	 cylinders;
+	int	 ret;
+	int	 extended;
+	struct	 ahd_softc *ahd;
+
+	ahd = *((struct ahd_softc **)sdev->host->hostdata);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	bh = scsi_bios_ptable(bdev);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,17)
+	bh = bread(MKDEV(MAJOR(dev), MINOR(dev) & ~0xf), 0, block_size(dev));
+#else
+	bh = bread(MKDEV(MAJOR(dev), MINOR(dev) & ~0xf), 0, 1024);
+#endif
+
+	if (bh) {
+		ret = scsi_partsize(bh, capacity,
+				    &geom[2], &geom[0], &geom[1]);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+		kfree(bh);
+#else
+		brelse(bh);
+#endif
+		if (ret != -1)
+			return (ret);
+	}
+	heads = 64;
+	sectors = 32;
+	cylinders = aic_sector_div(capacity, heads, sectors);
+
+	if (aic79xx_extended != 0)
+		extended = 1;
+	else
+		extended = (ahd->flags & AHD_EXTENDED_TRANS_A) != 0;
+	if (extended && cylinders >= 1024) {
+		heads = 255;
+		sectors = 63;
+		cylinders = aic_sector_div(capacity, heads, sectors);
+	}
+	geom[0] = heads;
+	geom[1] = sectors;
+	geom[2] = cylinders;
+	return (0);
+}
+#endif
+
+/*
+ * Abort the current SCSI command(s).
+ */
+static int
+ahd_linux_abort(Scsi_Cmnd *cmd)
+{
+	struct ahd_softc *ahd;
+	struct ahd_cmd *acmd;
+	struct ahd_cmd *list_acmd;
+	struct ahd_linux_device *dev;
+	struct scb *pending_scb;
+	u_long s;
+	u_int  saved_scbptr;
+	u_int  active_scbptr;
+	u_int  last_phase;
+	u_int  cdb_byte;
+	int    retval;
+	int    was_paused;
+	int    paused;
+	int    wait;
+	int    disconnected;
+	ahd_mode_state saved_modes;
+
+	pending_scb = NULL;
+	paused = FALSE;
+	wait = FALSE;
+	ahd = *(struct ahd_softc **)cmd->device->host->hostdata;
+	acmd = (struct ahd_cmd *)cmd;
+
+	printf("%s:%d:%d:%d: Attempting to abort cmd %p:",
+	       ahd_name(ahd), cmd->device->channel, cmd->device->id,
+	       cmd->device->lun, cmd);
+	for (cdb_byte = 0; cdb_byte < cmd->cmd_len; cdb_byte++)
+		printf(" 0x%x", cmd->cmnd[cdb_byte]);
+	printf("\n");
+
+	/*
+	 * In all versions of Linux, we have to work around
+	 * a major flaw in how the mid-layer is locked down
+	 * if we are to sleep successfully in our error handler
+	 * while allowing our interrupt handler to run.  Since
+	 * the midlayer acquires either the io_request_lock or
+	 * our lock prior to calling us, we must use the
+	 * spin_unlock_irq() method for unlocking our lock.
+	 * This will force interrupts to be enabled on the
+	 * current CPU.  Since the EH thread should not have
+	 * been running with CPU interrupts disabled other than
+	 * by acquiring either the io_request_lock or our own
+	 * lock, this *should* be safe.
+	 */
+	ahd_midlayer_entrypoint_lock(ahd, &s);
+
+	/*
+	 * First determine if we currently own this command.
+	 * Start by searching the device queue.  If not found
+	 * there, check the pending_scb list.  If not found
+	 * at all, and the system wanted us to just abort the
+	 * command, return success.
+	 */
+	dev = ahd_linux_get_device(ahd, cmd->device->channel,
+				   cmd->device->id, cmd->device->lun,
+				   /*alloc*/FALSE);
+
+	if (dev == NULL) {
+		/*
+		 * No target device for this command exists,
+		 * so we must not still own the command.
+		 */
+		printf("%s:%d:%d:%d: Is not an active device\n",
+		       ahd_name(ahd), cmd->device->channel, cmd->device->id,
+		       cmd->device->lun);
+		retval = SUCCESS;
+		goto no_cmd;
+	}
+
+	TAILQ_FOREACH(list_acmd, &dev->busyq, acmd_links.tqe) {
+		if (list_acmd == acmd)
+			break;
+	}
+
+	if (list_acmd != NULL) {
+		printf("%s:%d:%d:%d: Command found on device queue\n",
+		       ahd_name(ahd), cmd->device->channel, cmd->device->id,
+		       cmd->device->lun);
+		TAILQ_REMOVE(&dev->busyq, list_acmd, acmd_links.tqe);
+		cmd->result = DID_ABORT << 16;
+		ahd_linux_queue_cmd_complete(ahd, cmd);
+		retval = SUCCESS;
+		goto done;
+	}
+
+	/*
+	 * See if we can find a matching cmd in the pending list.
+	 */
+	LIST_FOREACH(pending_scb, &ahd->pending_scbs, pending_links) {
+		if (pending_scb->io_ctx == cmd)
+			break;
+	}
+
+	if (pending_scb == NULL) {
+		printf("%s:%d:%d:%d: Command not found\n",
+		       ahd_name(ahd), cmd->device->channel, cmd->device->id,
+		       cmd->device->lun);
+		goto no_cmd;
+	}
+
+	if ((pending_scb->flags & SCB_RECOVERY_SCB) != 0) {
+		/*
+		 * We can't queue two recovery actions using the same SCB
+		 */
+		retval = FAILED;
+		goto  done;
+	}
+
+	/*
+	 * Ensure that the card doesn't do anything
+	 * behind our back.  Also make sure that we
+	 * didn't "just" miss an interrupt that would
+	 * affect this cmd.
+	 */
+	was_paused = ahd_is_paused(ahd);
+	ahd_pause_and_flushwork(ahd);
+	paused = TRUE;
+
+	if ((pending_scb->flags & SCB_ACTIVE) == 0) {
+		printf("%s:%d:%d:%d: Command already completed\n",
+		       ahd_name(ahd), cmd->device->channel, cmd->device->id,
+		       cmd->device->lun);
+		goto no_cmd;
+	}
+
+	printf("%s: At time of recovery, card was %spaused\n",
+	       ahd_name(ahd), was_paused ? "" : "not ");
+	ahd_dump_card_state(ahd);
+
+	disconnected = TRUE;
+	if (ahd_search_qinfifo(ahd, cmd->device->id, cmd->device->channel + 'A',
+			       cmd->device->lun, SCB_GET_TAG(pending_scb),
+			       ROLE_INITIATOR, CAM_REQ_ABORTED,
+			       SEARCH_COMPLETE) > 0) {
+		printf("%s:%d:%d:%d: Cmd aborted from QINFIFO\n",
+		       ahd_name(ahd), cmd->device->channel, cmd->device->id,
+				cmd->device->lun);
+		retval = SUCCESS;
+		goto done;
+	}
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	last_phase = ahd_inb(ahd, LASTPHASE);
+	saved_scbptr = ahd_get_scbptr(ahd);
+	active_scbptr = saved_scbptr;
+	if (disconnected && (ahd_inb(ahd, SEQ_FLAGS) & NOT_IDENTIFIED) == 0) {
+		struct scb *bus_scb;
+
+		bus_scb = ahd_lookup_scb(ahd, active_scbptr);
+		if (bus_scb == pending_scb)
+			disconnected = FALSE;
+	}
+
+	/*
+	 * At this point, pending_scb is the scb associated with the
+	 * passed in command.  That command is currently active on the
+	 * bus or is in the disconnected state.
+	 */
+	if (last_phase != P_BUSFREE
+	 && SCB_GET_TAG(pending_scb) == active_scbptr) {
+
+		/*
+		 * We're active on the bus, so assert ATN
+		 * and hope that the target responds.
+		 */
+		pending_scb = ahd_lookup_scb(ahd, active_scbptr);
+		pending_scb->flags |= SCB_RECOVERY_SCB|SCB_ABORT;
+		ahd_outb(ahd, MSG_OUT, HOST_MSG);
+		ahd_outb(ahd, SCSISIGO, last_phase|ATNO);
+		printf("%s:%d:%d:%d: Device is active, asserting ATN\n",
+		       ahd_name(ahd), cmd->device->channel,
+		       cmd->device->id, cmd->device->lun);
+		wait = TRUE;
+	} else if (disconnected) {
+
+		/*
+		 * Actually re-queue this SCB in an attempt
+		 * to select the device before it reconnects.
+		 */
+		pending_scb->flags |= SCB_RECOVERY_SCB|SCB_ABORT;
+		ahd_set_scbptr(ahd, SCB_GET_TAG(pending_scb));
+		pending_scb->hscb->cdb_len = 0;
+		pending_scb->hscb->task_attribute = 0;
+		pending_scb->hscb->task_management = SIU_TASKMGMT_ABORT_TASK;
+
+		if ((pending_scb->flags & SCB_PACKETIZED) != 0) {
+			/*
+			 * Mark the SCB has having an outstanding
+			 * task management function.  Should the command
+			 * complete normally before the task management
+			 * function can be sent, the host will be notified
+			 * to abort our requeued SCB.
+			 */
+			ahd_outb(ahd, SCB_TASK_MANAGEMENT,
+				 pending_scb->hscb->task_management);
+		} else {
+			/*
+			 * If non-packetized, set the MK_MESSAGE control
+			 * bit indicating that we desire to send a message.
+			 * We also set the disconnected flag since there is
+			 * no guarantee that our SCB control byte matches
+			 * the version on the card.  We don't want the
+			 * sequencer to abort the command thinking an
+			 * unsolicited reselection occurred.
+			 */
+			pending_scb->hscb->control |= MK_MESSAGE|DISCONNECTED;
+
+			/*
+			 * The sequencer will never re-reference the
+			 * in-core SCB.  To make sure we are notified
+			 * during reslection, set the MK_MESSAGE flag in
+			 * the card's copy of the SCB.
+			 */
+			ahd_outb(ahd, SCB_CONTROL,
+				 ahd_inb(ahd, SCB_CONTROL)|MK_MESSAGE);
+		}
+
+		/*
+		 * Clear out any entries in the QINFIFO first
+		 * so we are the next SCB for this target
+		 * to run.
+		 */
+		ahd_search_qinfifo(ahd, cmd->device->id,
+				   cmd->device->channel + 'A', cmd->device->lun,
+				   SCB_LIST_NULL, ROLE_INITIATOR,
+				   CAM_REQUEUE_REQ, SEARCH_COMPLETE);
+		ahd_qinfifo_requeue_tail(ahd, pending_scb);
+		ahd_set_scbptr(ahd, saved_scbptr);
+		ahd_print_path(ahd, pending_scb);
+		printf("Device is disconnected, re-queuing SCB\n");
+		wait = TRUE;
+	} else {
+		printf("%s:%d:%d:%d: Unable to deliver message\n",
+		       ahd_name(ahd), cmd->device->channel,
+		       cmd->device->id, cmd->device->lun);
+		retval = FAILED;
+		goto done;
+	}
+
+no_cmd:
+	/*
+	 * Our assumption is that if we don't have the command, no
+	 * recovery action was required, so we return success.  Again,
+	 * the semantics of the mid-layer recovery engine are not
+	 * well defined, so this may change in time.
+	 */
+	retval = SUCCESS;
+done:
+	if (paused)
+		ahd_unpause(ahd);
+	if (wait) {
+		struct timer_list timer;
+		int ret;
+
+		pending_scb->platform_data->flags |= AHD_SCB_UP_EH_SEM;
+		spin_unlock_irq(&ahd->platform_data->spin_lock);
+		init_timer(&timer);
+		timer.data = (u_long)pending_scb;
+		timer.expires = jiffies + (5 * HZ);
+		timer.function = ahd_linux_sem_timeout;
+		add_timer(&timer);
+		printf("Recovery code sleeping\n");
+		down(&ahd->platform_data->eh_sem);
+		printf("Recovery code awake\n");
+        	ret = del_timer_sync(&timer);
+		if (ret == 0) {
+			printf("Timer Expired\n");
+			retval = FAILED;
+		}
+		spin_lock_irq(&ahd->platform_data->spin_lock);
+	}
+	ahd_schedule_runq(ahd);
+	ahd_linux_run_complete_queue(ahd);
+	ahd_midlayer_entrypoint_unlock(ahd, &s);
+	return (retval);
+}
+
+
+static void
+ahd_linux_dev_reset_complete(Scsi_Cmnd *cmd)
+{
+	free(cmd, M_DEVBUF);
+}
+
+/*
+ * Attempt to send a target reset message to the device that timed out.
+ */
+static int
+ahd_linux_dev_reset(Scsi_Cmnd *cmd)
+{
+	struct	ahd_softc *ahd;
+	struct	scsi_cmnd *recovery_cmd;
+	struct	ahd_linux_device *dev;
+	struct	ahd_initiator_tinfo *tinfo;
+	struct	ahd_tmode_tstate *tstate;
+	struct	scb *scb;
+	struct	hardware_scb *hscb;
+	u_long	s;
+	struct	timer_list timer;
+	int	retval;
+
+	ahd = *(struct ahd_softc **)cmd->device->host->hostdata;
+	recovery_cmd = malloc(sizeof(struct scsi_cmnd), M_DEVBUF, M_WAITOK);
+	memset(recovery_cmd, 0, sizeof(struct scsi_cmnd));
+	recovery_cmd->device = cmd->device;
+	recovery_cmd->scsi_done = ahd_linux_dev_reset_complete;
+#if AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_RECOVERY) != 0)
+		printf("%s:%d:%d:%d: Device reset called for cmd %p\n",
+		       ahd_name(ahd), cmd->device->channel, cmd->device->id,
+		       cmd->device->lun, cmd);
+#endif
+	ahd_midlayer_entrypoint_lock(ahd, &s);
+
+	dev = ahd_linux_get_device(ahd, cmd->device->channel, cmd->device->id,
+				   cmd->device->lun, /*alloc*/FALSE);
+	if (dev == NULL) {
+		ahd_midlayer_entrypoint_unlock(ahd, &s);
+		return (FAILED);
+	}
+	if ((scb = ahd_get_scb(ahd, AHD_NEVER_COL_IDX)) == NULL) {
+		ahd_midlayer_entrypoint_unlock(ahd, &s);
+		return (FAILED);
+	}
+	tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
+				    cmd->device->id, &tstate);
+	recovery_cmd->result = CAM_REQ_INPROG << 16;
+	recovery_cmd->host_scribble = (char *)scb;
+	scb->io_ctx = recovery_cmd;
+	scb->platform_data->dev = dev;
+	scb->sg_count = 0;
+	ahd_set_residual(scb, 0);
+	ahd_set_sense_residual(scb, 0);
+	hscb = scb->hscb;
+	hscb->control = 0;
+	hscb->scsiid = BUILD_SCSIID(ahd, cmd);
+	hscb->lun = cmd->device->lun;
+	hscb->cdb_len = 0;
+	hscb->task_management = SIU_TASKMGMT_LUN_RESET;
+	scb->flags |= SCB_DEVICE_RESET|SCB_RECOVERY_SCB|SCB_ACTIVE;
+	if ((tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
+		scb->flags |= SCB_PACKETIZED;
+	} else {
+		hscb->control |= MK_MESSAGE;
+	}
+	dev->openings--;
+	dev->active++;
+	dev->commands_issued++;
+	LIST_INSERT_HEAD(&ahd->pending_scbs, scb, pending_links);
+	ahd_queue_scb(ahd, scb);
+
+	scb->platform_data->flags |= AHD_SCB_UP_EH_SEM;
+	spin_unlock_irq(&ahd->platform_data->spin_lock);
+	init_timer(&timer);
+	timer.data = (u_long)scb;
+	timer.expires = jiffies + (5 * HZ);
+	timer.function = ahd_linux_sem_timeout;
+	add_timer(&timer);
+	printf("Recovery code sleeping\n");
+	down(&ahd->platform_data->eh_sem);
+	printf("Recovery code awake\n");
+	retval = SUCCESS;
+	if (del_timer_sync(&timer) == 0) {
+		printf("Timer Expired\n");
+		retval = FAILED;
+	}
+	spin_lock_irq(&ahd->platform_data->spin_lock);
+	ahd_schedule_runq(ahd);
+	ahd_linux_run_complete_queue(ahd);
+	ahd_midlayer_entrypoint_unlock(ahd, &s);
+	printf("%s: Device reset returning 0x%x\n", ahd_name(ahd), retval);
+	return (retval);
+}
+
+/*
+ * Reset the SCSI bus.
+ */
+static int
+ahd_linux_bus_reset(Scsi_Cmnd *cmd)
+{
+	struct ahd_softc *ahd;
+	u_long s;
+	int    found;
+
+	ahd = *(struct ahd_softc **)cmd->device->host->hostdata;
+#ifdef AHD_DEBUG
+	if ((ahd_debug & AHD_SHOW_RECOVERY) != 0)
+		printf("%s: Bus reset called for cmd %p\n",
+		       ahd_name(ahd), cmd);
+#endif
+	ahd_midlayer_entrypoint_lock(ahd, &s);
+	found = ahd_reset_channel(ahd, cmd->device->channel + 'A',
+				  /*initiate reset*/TRUE);
+	ahd_linux_run_complete_queue(ahd);
+	ahd_midlayer_entrypoint_unlock(ahd, &s);
+
+	if (bootverbose)
+		printf("%s: SCSI bus reset delivered. "
+		       "%d SCBs aborted.\n", ahd_name(ahd), found);
+
+	return (SUCCESS);
+}
+
+Scsi_Host_Template aic79xx_driver_template = {
+	.module			= THIS_MODULE,
+	.name			= "aic79xx",
+	.proc_info		= ahd_linux_proc_info,
+	.info			= ahd_linux_info,
+	.queuecommand		= ahd_linux_queue,
+	.eh_abort_handler	= ahd_linux_abort,
+	.eh_device_reset_handler = ahd_linux_dev_reset,
+	.eh_bus_reset_handler	= ahd_linux_bus_reset,
+#if defined(__i386__)
+	.bios_param		= ahd_linux_biosparam,
+#endif
+	.can_queue		= AHD_MAX_QUEUE,
+	.this_id		= -1,
+	.cmd_per_lun		= 2,
+	.use_clustering		= ENABLE_CLUSTERING,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,7)
+	/*
+	 * We can only map 16MB per-SG
+	 * so create a sector limit of
+	 * "16MB" in 2K sectors.
+	 */
+	.max_sectors		= 8192,
+#endif
+#if defined CONFIG_HIGHIO || LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,10)
+/* Assume RedHat Distribution with its different HIGHIO conventions. */
+	.can_dma_32		= 1,
+	.single_sg_okay		= 1,
+#else
+	.highmem_io		= 1,
+#endif
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	.slave_alloc		= ahd_linux_slave_alloc,
+	.slave_configure	= ahd_linux_slave_configure,
+	.slave_destroy		= ahd_linux_slave_destroy,
+#else
+	.detect			= ahd_linux_detect,
+	.release		= ahd_linux_release,
+	.select_queue_depths	= ahd_linux_select_queue_depth,
+	.use_new_eh_code	= 1,
+#endif
+};
+
+/**************************** Tasklet Handler *********************************/
+
+/*
+ * In 2.4.X and above, this routine is called from a tasklet,
+ * so we must re-acquire our lock prior to executing this code.
+ * In all prior kernels, ahd_schedule_runq() calls this routine
+ * directly and ahd_schedule_runq() is called with our lock held.
+ */
+static void
+ahd_runq_tasklet(unsigned long data)
+{
+	struct ahd_softc* ahd;
+	struct ahd_linux_device *dev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	u_long flags;
+#endif
+
+	ahd = (struct ahd_softc *)data;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	ahd_lock(ahd, &flags);
+#endif
+	while ((dev = ahd_linux_next_device_to_run(ahd)) != NULL) {
+	
+		TAILQ_REMOVE(&ahd->platform_data->device_runq, dev, links);
+		dev->flags &= ~AHD_DEV_ON_RUN_LIST;
+		ahd_linux_check_device_queue(ahd, dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+		/* Yeild to our interrupt handler */
+		ahd_unlock(ahd, &flags);
+		ahd_lock(ahd, &flags);
+#endif
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	ahd_unlock(ahd, &flags);
+#endif
+}
+
+/******************************** Bus DMA *************************************/
+int
+ahd_dma_tag_create(struct ahd_softc *ahd, bus_dma_tag_t parent,
+		   bus_size_t alignment, bus_size_t boundary,
+		   bus_addr_t lowaddr, bus_addr_t highaddr,
+		   bus_dma_filter_t *filter, void *filterarg,
+		   bus_size_t maxsize, int nsegments,
+		   bus_size_t maxsegsz, int flags, bus_dma_tag_t *ret_tag)
+{
+	bus_dma_tag_t dmat;
+
+	dmat = malloc(sizeof(*dmat), M_DEVBUF, M_NOWAIT);
+	if (dmat == NULL)
+		return (ENOMEM);
+
+	/*
+	 * Linux is very simplistic about DMA memory.  For now don't
+	 * maintain all specification information.  Once Linux supplies
+	 * better facilities for doing these operations, or the
+	 * needs of this particular driver change, we might need to do
+	 * more here.
+	 */
+	dmat->alignment = alignment;
+	dmat->boundary = boundary;
+	dmat->maxsize = maxsize;
+	*ret_tag = dmat;
+	return (0);
+}
+
+void
+ahd_dma_tag_destroy(struct ahd_softc *ahd, bus_dma_tag_t dmat)
+{
+	free(dmat, M_DEVBUF);
+}
+
+int
+ahd_dmamem_alloc(struct ahd_softc *ahd, bus_dma_tag_t dmat, void** vaddr,
+		 int flags, bus_dmamap_t *mapp)
+{
+	bus_dmamap_t map;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	map = malloc(sizeof(*map), M_DEVBUF, M_NOWAIT);
+	if (map == NULL)
+		return (ENOMEM);
+	/*
+	 * Although we can dma data above 4GB, our
+	 * "consistent" memory is below 4GB for
+	 * space efficiency reasons (only need a 4byte
+	 * address).  For this reason, we have to reset
+	 * our dma mask when doing allocations.
+	 */
+	if (ahd->dev_softc != NULL)
+		ahd_pci_set_dma_mask(ahd->dev_softc, 0xFFFFFFFF);
+	*vaddr = pci_alloc_consistent(ahd->dev_softc,
+				      dmat->maxsize, &map->bus_addr);
+	if (ahd->dev_softc != NULL)
+		ahd_pci_set_dma_mask(ahd->dev_softc,
+				     ahd->platform_data->hw_dma_mask);
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0) */
+	/*
+	 * At least in 2.2.14, malloc is a slab allocator so all
+	 * allocations are aligned.  We assume for these kernel versions
+	 * that all allocations will be bellow 4Gig, physically contiguous,
+	 * and accessible via DMA by the controller.
+	 */
+	map = NULL; /* No additional information to store */
+	*vaddr = malloc(dmat->maxsize, M_DEVBUF, M_NOWAIT);
+#endif
+	if (*vaddr == NULL)
+		return (ENOMEM);
+	*mapp = map;
+	return(0);
+}
+
+void
+ahd_dmamem_free(struct ahd_softc *ahd, bus_dma_tag_t dmat,
+		void* vaddr, bus_dmamap_t map)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	pci_free_consistent(ahd->dev_softc, dmat->maxsize,
+			    vaddr, map->bus_addr);
+#else
+	free(vaddr, M_DEVBUF);
+#endif
+}
+
+int
+ahd_dmamap_load(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map,
+		void *buf, bus_size_t buflen, bus_dmamap_callback_t *cb,
+		void *cb_arg, int flags)
+{
+	/*
+	 * Assume for now that this will only be used during
+	 * initialization and not for per-transaction buffer mapping.
+	 */
+	bus_dma_segment_t stack_sg;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	stack_sg.ds_addr = map->bus_addr;
+#else
+#define VIRT_TO_BUS(a) (uint32_t)virt_to_bus((void *)(a))
+	stack_sg.ds_addr = VIRT_TO_BUS(buf);
+#endif
+	stack_sg.ds_len = dmat->maxsize;
+	cb(cb_arg, &stack_sg, /*nseg*/1, /*error*/0);
+	return (0);
+}
+
+void
+ahd_dmamap_destroy(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map)
+{
+	/*
+	 * The map may is NULL in our < 2.3.X implementation.
+	 */
+	if (map != NULL)
+		free(map, M_DEVBUF);
+}
+
+int
+ahd_dmamap_unload(struct ahd_softc *ahd, bus_dma_tag_t dmat, bus_dmamap_t map)
+{
+	/* Nothing to do */
+	return (0);
+}
+
+/********************* Platform Dependent Functions ***************************/
+/*
+ * Compare "left hand" softc with "right hand" softc, returning:
+ * < 0 - lahd has a lower priority than rahd
+ *   0 - Softcs are equal
+ * > 0 - lahd has a higher priority than rahd
+ */
+int
+ahd_softc_comp(struct ahd_softc *lahd, struct ahd_softc *rahd)
+{
+	int	value;
+
+	/*
+	 * Under Linux, cards are ordered as follows:
+	 *	1) PCI devices that are marked as the boot controller.
+	 *	2) PCI devices with BIOS enabled sorted by bus/slot/func.
+	 *	3) All remaining PCI devices sorted by bus/slot/func.
+	 */
+#if 0
+	value = (lahd->flags & AHD_BOOT_CHANNEL)
+	      - (rahd->flags & AHD_BOOT_CHANNEL);
+	if (value != 0)
+		/* Controllers set for boot have a *higher* priority */
+		return (value);
+#endif
+
+	value = (lahd->flags & AHD_BIOS_ENABLED)
+	      - (rahd->flags & AHD_BIOS_ENABLED);
+	if (value != 0)
+		/* Controllers with BIOS enabled have a *higher* priority */
+		return (value);
+
+	/* Still equal.  Sort by bus/slot/func. */
+	if (aic79xx_reverse_scan != 0)
+		value = ahd_get_pci_bus(lahd->dev_softc)
+		      - ahd_get_pci_bus(rahd->dev_softc);
+	else
+		value = ahd_get_pci_bus(rahd->dev_softc)
+		      - ahd_get_pci_bus(lahd->dev_softc);
+	if (value != 0)
+		return (value);
+	if (aic79xx_reverse_scan != 0)
+		value = ahd_get_pci_slot(lahd->dev_softc)
+		      - ahd_get_pci_slot(rahd->dev_softc);
+	else
+		value = ahd_get_pci_slot(rahd->dev_softc)
+		      - ahd_get_pci_slot(lahd->dev_softc);
+	if (value != 0)
+		return (value);
+
+	value = rahd->channel - lahd->channel;
+	return (value);
+}
+
+static void
+ahd_linux_setup_tag_info(u_long arg, int instance, int targ, int32_t value)
+{
+
+	if ((instance >= 0) && (targ >= 0)
+	 && (instance < NUM_ELEMENTS(aic79xx_tag_info))
+	 && (targ < AHD_NUM_TARGETS)) {
+		aic79xx_tag_info[instance].tag_commands[targ] = value & 0x1FF;
+		if (bootverbose)
+			printf("tag_info[%d:%d] = %d\n", instance, targ, value);
+	}
+}
+
+static void
+ahd_linux_setup_rd_strm_info(u_long arg, int instance, int targ, int32_t value)
+{
+	if ((instance >= 0)
+	 && (instance < NUM_ELEMENTS(aic79xx_rd_strm_info))) {
+		aic79xx_rd_strm_info[instance] = value & 0xFFFF;
+		if (bootverbose)
+			printf("rd_strm[%d] = 0x%x\n", instance, value);
+	}
+}
+
+static void
+ahd_linux_setup_dv(u_long arg, int instance, int targ, int32_t value)
+{
+	if ((instance >= 0)
+	 && (instance < NUM_ELEMENTS(aic79xx_dv_settings))) {
+		aic79xx_dv_settings[instance] = value;
+		if (bootverbose)
+			printf("dv[%d] = %d\n", instance, value);
+	}
+}
+
+static void
+ahd_linux_setup_iocell_info(u_long index, int instance, int targ, int32_t value)
+{
+
+	if ((instance >= 0)
+	 && (instance < NUM_ELEMENTS(aic79xx_iocell_info))) {
+		uint8_t *iocell_info;
+
+		iocell_info = (uint8_t*)&aic79xx_iocell_info[instance];
+		iocell_info[index] = value & 0xFFFF;
+		if (bootverbose)
+			printf("iocell[%d:%ld] = %d\n", instance, index, value);
+	}
+}
+
+static void
+ahd_linux_setup_tag_info_global(char *p)
+{
+	int tags, i, j;
+
+	tags = simple_strtoul(p + 1, NULL, 0) & 0xff;
+	printf("Setting Global Tags= %d\n", tags);
+
+	for (i = 0; i < NUM_ELEMENTS(aic79xx_tag_info); i++) {
+		for (j = 0; j < AHD_NUM_TARGETS; j++) {
+			aic79xx_tag_info[i].tag_commands[j] = tags;
+		}
+	}
+}
+
+/*
+ * Handle Linux boot parameters. This routine allows for assigning a value
+ * to a parameter with a ':' between the parameter and the value.
+ * ie. aic79xx=stpwlev:1,extended
+ */
+static int
+aic79xx_setup(char *s)
+{
+	int	i, n;
+	char   *p;
+	char   *end;
+
+	static struct {
+		const char *name;
+		uint32_t *flag;
+	} options[] = {
+		{ "extended", &aic79xx_extended },
+		{ "no_reset", &aic79xx_no_reset },
+		{ "verbose", &aic79xx_verbose },
+		{ "attach_HostRAID", &ahd_attach_to_HostRAID_controllers },
+		{ "allow_memio", &aic79xx_allow_memio},
+#ifdef AHD_DEBUG
+		{ "debug", &ahd_debug },
+#endif
+		{ "reverse_scan", &aic79xx_reverse_scan },
+		{ "periodic_otag", &aic79xx_periodic_otag },
+		{ "pci_parity", &aic79xx_pci_parity },
+		{ "seltime", &aic79xx_seltime },
+		{ "tag_info", NULL },
+		{ "global_tag_depth", NULL},
+		{ "rd_strm", NULL },
+		{ "dv", NULL },
+		{ "slewrate", NULL },
+		{ "precomp", NULL },
+		{ "amplitude", NULL },
+	};
+
+	end = strchr(s, '\0');
+
+	/*
+	 * XXX ia64 gcc isn't smart enough to know that NUM_ELEMENTS
+	 * will never be 0 in this case.
+	 */      
+	n = 0;  
+
+	while ((p = strsep(&s, ",.")) != NULL) {
+		if (*p == '\0')
+			continue;
+		for (i = 0; i < NUM_ELEMENTS(options); i++) {
+
+			n = strlen(options[i].name);
+			if (strncmp(options[i].name, p, n) == 0)
+				break;
+		}
+		if (i == NUM_ELEMENTS(options))
+			continue;
+
+		if (strncmp(p, "global_tag_depth", n) == 0) {
+			ahd_linux_setup_tag_info_global(p + n);
+		} else if (strncmp(p, "tag_info", n) == 0) {
+			s = aic_parse_brace_option("tag_info", p + n, end,
+			    2, ahd_linux_setup_tag_info, 0);
+		} else if (strncmp(p, "rd_strm", n) == 0) {
+			s = aic_parse_brace_option("rd_strm", p + n, end,
+			    1, ahd_linux_setup_rd_strm_info, 0);
+		} else if (strncmp(p, "dv", n) == 0) {
+			s = aic_parse_brace_option("dv", p + n, end, 1,
+			    ahd_linux_setup_dv, 0);
+		} else if (strncmp(p, "slewrate", n) == 0) {
+			s = aic_parse_brace_option("slewrate",
+			    p + n, end, 1, ahd_linux_setup_iocell_info,
+			    AIC79XX_SLEWRATE_INDEX);
+		} else if (strncmp(p, "precomp", n) == 0) {
+			s = aic_parse_brace_option("precomp",
+			    p + n, end, 1, ahd_linux_setup_iocell_info,
+			    AIC79XX_PRECOMP_INDEX);
+		} else if (strncmp(p, "amplitude", n) == 0) {
+			s = aic_parse_brace_option("amplitude",
+			    p + n, end, 1, ahd_linux_setup_iocell_info,
+			    AIC79XX_AMPLITUDE_INDEX);
+		} else if (p[n] == ':') {
+			*(options[i].flag) = simple_strtoul(p + n + 1, NULL, 0);
+		} else if (!strncmp(p, "verbose", n)) {
+			*(options[i].flag) = 1;
+		} else {
+			*(options[i].flag) ^= 0xFFFFFFFF;
+		}
+	}
+	return 1;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
+__setup("aic79xx=", aic79xx_setup);
+#endif
+
+uint32_t aic79xx_verbose;
+
+int
+ahd_linux_register_host(struct ahd_softc *ahd, Scsi_Host_Template *template)
+{
+	char	buf[80];
+	struct	Scsi_Host *host;
+	char	*new_name;
+	u_long	s;
+	u_long	target;
+
+	template->name = ahd->description;
+	host = scsi_register(template, sizeof(struct ahd_softc *));
+	if (host == NULL)
+		return (ENOMEM);
+
+	*((struct ahd_softc **)host->hostdata) = ahd;
+	ahd_lock(ahd, &s);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	scsi_assign_lock(host, &ahd->platform_data->spin_lock);
+#elif AHD_SCSI_HAS_HOST_LOCK != 0
+	host->lock = &ahd->platform_data->spin_lock;
+#endif
+	ahd->platform_data->host = host;
+	host->can_queue = AHD_MAX_QUEUE;
+	host->cmd_per_lun = 2;
+	host->sg_tablesize = AHD_NSEG;
+	host->this_id = ahd->our_id;
+	host->irq = ahd->platform_data->irq;
+	host->max_id = (ahd->features & AHD_WIDE) ? 16 : 8;
+	host->max_lun = AHD_NUM_LUNS;
+	host->max_channel = 0;
+	host->sg_tablesize = AHD_NSEG;
+	ahd_set_unit(ahd, ahd_linux_next_unit());
+	sprintf(buf, "scsi%d", host->host_no);
+	new_name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
+	if (new_name != NULL) {
+		strcpy(new_name, buf);
+		ahd_set_name(ahd, new_name);
+	}
+	host->unique_id = ahd->unit;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,4) && \
+    LINUX_VERSION_CODE  < KERNEL_VERSION(2,5,0)
+	scsi_set_pci_device(host, ahd->dev_softc);
+#endif
+	ahd_linux_setup_user_rd_strm_settings(ahd);
+	ahd_linux_initialize_scsi_bus(ahd);
+	ahd_unlock(ahd, &s);
+	ahd->platform_data->dv_pid = kernel_thread(ahd_linux_dv_thread, ahd, 0);
+	ahd_lock(ahd, &s);
+	if (ahd->platform_data->dv_pid < 0) {
+		printf("%s: Failed to create DV thread, error= %d\n",
+		       ahd_name(ahd), ahd->platform_data->dv_pid);
+		return (-ahd->platform_data->dv_pid);
+	}
+	/*
+	 * Initially allocate *all* of our linux target objects
+	 * so that the DV thread will scan them all in parallel
+	 * just after driver initialization.  Any device that
+	 * does not exist will have its target object destroyed
+	 * by the selection timeout handler.  In the case of a
+	 * device that appears after the initial DV scan, async
+	 * negotiation will occur for the first command, and DV
+	 * will comence should that first command be successful.
+	 */
+	for (target = 0; target < host->max_id; target++) {
+
+		/*
+		 * Skip our own ID.  Some Compaq/HP storage devices
+		 * have enclosure management devices that respond to
+		 * single bit selection (i.e. selecting ourselves).
+		 * It is expected that either an external application
+		 * or a modified kernel will be used to probe this
+		 * ID if it is appropriate.  To accommodate these
+		 * installations, ahc_linux_alloc_target() will allocate
+		 * for our ID if asked to do so.
+		 */
+		if (target == ahd->our_id) 
+			continue;
+
+		ahd_linux_alloc_target(ahd, 0, target);
+	}
+	ahd_intr_enable(ahd, TRUE);
+	ahd_linux_start_dv(ahd);
+	ahd_unlock(ahd, &s);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	scsi_add_host(host, &ahd->dev_softc->dev);
+#endif
+	return (0);
+}
+
+uint64_t
+ahd_linux_get_memsize(void)
+{
+	struct sysinfo si;
+
+	si_meminfo(&si);
+	return ((uint64_t)si.totalram << PAGE_SHIFT);
+}
+
+/*
+ * Find the smallest available unit number to use
+ * for a new device.  We don't just use a static
+ * count to handle the "repeated hot-(un)plug"
+ * scenario.
+ */
+static int
+ahd_linux_next_unit(void)
+{
+	struct ahd_softc *ahd;
+	int unit;
+
+	unit = 0;
+retry:
+	TAILQ_FOREACH(ahd, &ahd_tailq, links) {
+		if (ahd->unit == unit) {
+			unit++;
+			goto retry;
+		}
+	}
+	return (unit);
+}
+
+/*
+ * Place the SCSI bus into a known state by either resetting it,
+ * or forcing transfer negotiations on the next command to any
+ * target.
+ */
+static void
+ahd_linux_initialize_scsi_bus(struct ahd_softc *ahd)
+{
+	u_int target_id;
+	u_int numtarg;
+
+	target_id = 0;
+	numtarg = 0;
+
+	if (aic79xx_no_reset != 0)
+		ahd->flags &= ~AHD_RESET_BUS_A;
+
+	if ((ahd->flags & AHD_RESET_BUS_A) != 0)
+		ahd_reset_channel(ahd, 'A', /*initiate_reset*/TRUE);
+	else
+		numtarg = (ahd->features & AHD_WIDE) ? 16 : 8;
+
+	/*
+	 * Force negotiation to async for all targets that
+	 * will not see an initial bus reset.
+	 */
+	for (; target_id < numtarg; target_id++) {
+		struct ahd_devinfo devinfo;
+		struct ahd_initiator_tinfo *tinfo;
+		struct ahd_tmode_tstate *tstate;
+
+		tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
+					    target_id, &tstate);
+		ahd_compile_devinfo(&devinfo, ahd->our_id, target_id,
+				    CAM_LUN_WILDCARD, 'A', ROLE_INITIATOR);
+		ahd_update_neg_request(ahd, &devinfo, tstate,
+				       tinfo, AHD_NEG_ALWAYS);
+	}
+	/* Give the bus some time to recover */
+	if ((ahd->flags & AHD_RESET_BUS_A) != 0) {
+		ahd_freeze_simq(ahd);
+		init_timer(&ahd->platform_data->reset_timer);
+		ahd->platform_data->reset_timer.data = (u_long)ahd;
+		ahd->platform_data->reset_timer.expires =
+		    jiffies + (AIC79XX_RESET_DELAY * HZ)/1000;
+		ahd->platform_data->reset_timer.function =
+		    (ahd_linux_callback_t *)ahd_release_simq;
+		add_timer(&ahd->platform_data->reset_timer);
+	}
+}
+
+int
+ahd_platform_alloc(struct ahd_softc *ahd, void *platform_arg)
+{
+	ahd->platform_data =
+	    malloc(sizeof(struct ahd_platform_data), M_DEVBUF, M_NOWAIT);
+	if (ahd->platform_data == NULL)
+		return (ENOMEM);
+	memset(ahd->platform_data, 0, sizeof(struct ahd_platform_data));
+	TAILQ_INIT(&ahd->platform_data->completeq);
+	TAILQ_INIT(&ahd->platform_data->device_runq);
+	ahd->platform_data->irq = AHD_LINUX_NOIRQ;
+	ahd->platform_data->hw_dma_mask = 0xFFFFFFFF;
+	ahd_lockinit(ahd);
+	ahd_done_lockinit(ahd);
+	init_timer(&ahd->platform_data->completeq_timer);
+	ahd->platform_data->completeq_timer.data = (u_long)ahd;
+	ahd->platform_data->completeq_timer.function =
+	    (ahd_linux_callback_t *)ahd_linux_thread_run_complete_queue;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	init_MUTEX_LOCKED(&ahd->platform_data->eh_sem);
+	init_MUTEX_LOCKED(&ahd->platform_data->dv_sem);
+	init_MUTEX_LOCKED(&ahd->platform_data->dv_cmd_sem);
+#else
+	ahd->platform_data->eh_sem = MUTEX_LOCKED;
+	ahd->platform_data->dv_sem = MUTEX_LOCKED;
+	ahd->platform_data->dv_cmd_sem = MUTEX_LOCKED;
+#endif
+	ahd_setup_runq_tasklet(ahd);
+	ahd->seltime = (aic79xx_seltime & 0x3) << 4;
+	return (0);
+}
+
+void
+ahd_platform_free(struct ahd_softc *ahd)
+{
+	struct ahd_linux_target *targ;
+	struct ahd_linux_device *dev;
+	int i, j;
+
+	if (ahd->platform_data != NULL) {
+		del_timer_sync(&ahd->platform_data->completeq_timer);
+		ahd_linux_kill_dv_thread(ahd);
+		ahd_teardown_runq_tasklet(ahd);
+		if (ahd->platform_data->host != NULL) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+			scsi_remove_host(ahd->platform_data->host);
+#endif
+			scsi_unregister(ahd->platform_data->host);
+		}
+
+		/* destroy all of the device and target objects */
+		for (i = 0; i < AHD_NUM_TARGETS; i++) {
+			targ = ahd->platform_data->targets[i];
+			if (targ != NULL) {
+				/* Keep target around through the loop. */
+				targ->refcount++;
+				for (j = 0; j < AHD_NUM_LUNS; j++) {
+
+					if (targ->devices[j] == NULL)
+						continue;
+					dev = targ->devices[j];
+					ahd_linux_free_device(ahd, dev);
+				}
+				/*
+				 * Forcibly free the target now that
+				 * all devices are gone.
+				 */
+				ahd_linux_free_target(ahd, targ);
+			}
+		}
+
+		if (ahd->platform_data->irq != AHD_LINUX_NOIRQ)
+			free_irq(ahd->platform_data->irq, ahd);
+		if (ahd->tags[0] == BUS_SPACE_PIO
+		 && ahd->bshs[0].ioport != 0)
+			release_region(ahd->bshs[0].ioport, 256);
+		if (ahd->tags[1] == BUS_SPACE_PIO
+		 && ahd->bshs[1].ioport != 0)
+			release_region(ahd->bshs[1].ioport, 256);
+		if (ahd->tags[0] == BUS_SPACE_MEMIO
+		 && ahd->bshs[0].maddr != NULL) {
+			u_long base_addr;
+
+			base_addr = (u_long)ahd->bshs[0].maddr;
+			base_addr &= PAGE_MASK;
+			iounmap((void *)base_addr);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+			release_mem_region(ahd->platform_data->mem_busaddr,
+					   0x1000);
+#endif
+		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0) && \
+    LINUX_VERSION_CODE  < KERNEL_VERSION(2,5,0)
+    		/*
+		 * In 2.4 we detach from the scsi midlayer before the PCI
+		 * layer invokes our remove callback.  No per-instance
+		 * detach is provided, so we must reach inside the PCI
+		 * subsystem's internals and detach our driver manually.
+		 */
+		if (ahd->dev_softc != NULL)
+			ahd->dev_softc->driver = NULL;
+#endif
+		free(ahd->platform_data, M_DEVBUF);
+	}
+}
+
+void
+ahd_platform_init(struct ahd_softc *ahd)
+{
+	/*
+	 * Lookup and commit any modified IO Cell options.
+	 */
+	if (ahd->unit < NUM_ELEMENTS(aic79xx_iocell_info)) {
+		struct ahd_linux_iocell_opts *iocell_opts;
+
+		iocell_opts = &aic79xx_iocell_info[ahd->unit];
+		if (iocell_opts->precomp != AIC79XX_DEFAULT_PRECOMP)
+			AHD_SET_PRECOMP(ahd, iocell_opts->precomp);
+		if (iocell_opts->slewrate != AIC79XX_DEFAULT_SLEWRATE)
+			AHD_SET_SLEWRATE(ahd, iocell_opts->slewrate);
+		if (iocell_opts->amplitude != AIC79XX_DEFAULT_AMPLITUDE)
+			AHD_SET_AMPLITUDE(ahd, iocell_opts->amplitude);
+	}
+
+}
+
+void
+ahd_platform_freeze_devq(struct ahd_softc *ahd, struct scb *scb)
+{
+	ahd_platform_abort_scbs(ahd, SCB_GET_TARGET(ahd, scb),
+				SCB_GET_CHANNEL(ahd, scb),
+				SCB_GET_LUN(scb), SCB_LIST_NULL,
+				ROLE_UNKNOWN, CAM_REQUEUE_REQ);
+}
+
+void
+ahd_platform_set_tags(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
+		      ahd_queue_alg alg)
+{
+	struct ahd_linux_device *dev;
+	int was_queuing;
+	int now_queuing;
+
+	dev = ahd_linux_get_device(ahd, devinfo->channel - 'A',
+				   devinfo->target,
+				   devinfo->lun, /*alloc*/FALSE);
+	if (dev == NULL)
+		return;
+	was_queuing = dev->flags & (AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED);
+	switch (alg) {
+	default:
+	case AHD_QUEUE_NONE:
+		now_queuing = 0;
+		break; 
+	case AHD_QUEUE_BASIC:
+		now_queuing = AHD_DEV_Q_BASIC;
+		break;
+	case AHD_QUEUE_TAGGED:
+		now_queuing = AHD_DEV_Q_TAGGED;
+		break;
+	}
+	if ((dev->flags & AHD_DEV_FREEZE_TIL_EMPTY) == 0
+	 && (was_queuing != now_queuing)
+	 && (dev->active != 0)) {
+		dev->flags |= AHD_DEV_FREEZE_TIL_EMPTY;
+		dev->qfrozen++;
+	}
+
+	dev->flags &= ~(AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED|AHD_DEV_PERIODIC_OTAG);
+	if (now_queuing) {
+		u_int usertags;
+
+		usertags = ahd_linux_user_tagdepth(ahd, devinfo);
+		if (!was_queuing) {
+			/*
+			 * Start out agressively and allow our
+			 * dynamic queue depth algorithm to take
+			 * care of the rest.
+			 */
+			dev->maxtags = usertags;
+			dev->openings = dev->maxtags - dev->active;
+		}
+		if (dev->maxtags == 0) {
+			/*
+			 * Queueing is disabled by the user.
+			 */
+			dev->openings = 1;
+		} else if (alg == AHD_QUEUE_TAGGED) {
+			dev->flags |= AHD_DEV_Q_TAGGED;
+			if (aic79xx_periodic_otag != 0)
+				dev->flags |= AHD_DEV_PERIODIC_OTAG;
+		} else
+			dev->flags |= AHD_DEV_Q_BASIC;
+	} else {
+		/* We can only have one opening. */
+		dev->maxtags = 0;
+		dev->openings =  1 - dev->active;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	if (dev->scsi_device != NULL) {
+		switch ((dev->flags & (AHD_DEV_Q_BASIC|AHD_DEV_Q_TAGGED))) {
+		case AHD_DEV_Q_BASIC:
+			scsi_adjust_queue_depth(dev->scsi_device,
+						MSG_SIMPLE_TASK,
+						dev->openings + dev->active);
+			break;
+		case AHD_DEV_Q_TAGGED:
+			scsi_adjust_queue_depth(dev->scsi_device,
+						MSG_ORDERED_TASK,
+						dev->openings + dev->active);
+			break;
+		default:
+			/*
+			 * We allow the OS to queue 2 untagged transactions to
+			 * us at any time even though we can only execute them
+			 * serially on the controller/device.  This should
+			 * remove some latency.
+			 */
+			scsi_adjust_queue_depth(dev->scsi_device,
+						/*NON-TAGGED*/0,
+						/*queue depth*/2);
+			break;
+		}
+	}
+#endif
+}
+
+int
+ahd_platform_abort_scbs(struct ahd_softc *ahd, int target, char channel,
+			int lun, u_int tag, role_t role, uint32_t status)
+{
+	int targ;
+	int maxtarg;
+	int maxlun;
+	int clun;
+	int count;
+
+	if (tag != SCB_LIST_NULL)
+		return (0);
+
+	targ = 0;
+	if (target != CAM_TARGET_WILDCARD) {
+		targ = target;
+		maxtarg = targ + 1;
+	} else {
+		maxtarg = (ahd->features & AHD_WIDE) ? 16 : 8;
+	}
+	clun = 0;
+	if (lun != CAM_LUN_WILDCARD) {
+		clun = lun;
+		maxlun = clun + 1;
+	} else {
+		maxlun = AHD_NUM_LUNS;
+	}
+
+	count = 0;
+	for (; targ < maxtarg; targ++) {
+
+		for (; clun < maxlun; clun++) {
+			struct ahd_linux_device *dev;
+			struct ahd_busyq *busyq;
+			struct ahd_cmd *acmd;
+
+			dev = ahd_linux_get_device(ahd, /*chan*/0, targ,
+						   clun, /*alloc*/FALSE);
+			if (dev == NULL)
+				continue;
+
+			busyq = &dev->busyq;
+			while ((acmd = TAILQ_FIRST(busyq)) != NULL) {
+				Scsi_Cmnd *cmd;
+
+				cmd = &acmd_scsi_cmd(acmd);
+				TAILQ_REMOVE(busyq, acmd,
+					     acmd_links.tqe);
+				count++;
+				cmd->result = status << 16;
+				ahd_linux_queue_cmd_complete(ahd, cmd);
+			}
+		}
+	}
+
+	return (count);
+}
+
+static void
+ahd_linux_thread_run_complete_queue(struct ahd_softc *ahd)
+{
+	u_long flags;
+
+	ahd_lock(ahd, &flags);
+	del_timer(&ahd->platform_data->completeq_timer);
+	ahd->platform_data->flags &= ~AHD_RUN_CMPLT_Q_TIMER;
+	ahd_linux_run_complete_queue(ahd);
+	ahd_unlock(ahd, &flags);
+}
+
+static void
+ahd_linux_start_dv(struct ahd_softc *ahd)
+{
+
+	/*
+	 * Freeze the simq and signal ahd_linux_queue to not let any
+	 * more commands through
+	 */
+	if ((ahd->platform_data->flags & AHD_DV_ACTIVE) == 0) {
+#ifdef AHD_DEBUG
+		if (ahd_debug & AHD_SHOW_DV)
+			printf("%s: Starting DV\n", ahd_name(ahd));
+#endif
+
+		ahd->platform_data->flags |= AHD_DV_ACTIVE;
+		ahd_freeze_simq(ahd);
+
+		/* Wake up the DV kthread */
+		up(&ahd->platform_data->dv_sem);
+	}
+}
+
+static int
+ahd_linux_dv_thread(void *data)
+{
+	struct	ahd_softc *ahd;
+	int	target;
+	u_long	s;
+
+	ahd = (struct ahd_softc *)data;
+
+#ifdef AHD_DEBUG
+	if (ahd_debug & AHD_SHOW_DV)
+		printf("In DV Thread\n");
+#endif
+
+	/*
+	 * Complete thread creation.
+	 */
+	lock_kernel();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,60)
+	/*
+	 * Don't care about any signals.
+	 */
+	siginitsetinv(&current->blocked, 0);
+
+	daemonize();
+	sprintf(current->comm, "ahd_dv_%d", ahd->unit);
+#else
+	daemonize("ahd_dv_%d", ahd->unit);
+#endif
+	unlock_kernel();
+
+	while (1) {
+		/*
+		 * Use down_interruptible() rather than down() to
+		 * avoid inclusion in the load average.
+		 */
+		down_interruptible(&ahd->platform_data->dv_sem);
+
+		/* Check to see if we've been signaled to exit */
+		ahd_lock(ahd, &s);
+		if ((ahd->platform_data->flags & AHD_DV_SHUTDOWN) != 0) {
+			ahd_unlock(ahd, &s);
+			break;
+		}
+		ahd_unlock(ahd, &s);
+
+#ifdef AHD_DEBUG
+		if (ahd_debug & AHD_SHOW_DV)
+			printf("%s: Beginning Domain Validation\n",
+			       ahd_name(ahd));
+#endif
+
+		/*
+		 * Wait for any pending commands to drain before proceeding.
+		 */
+		ahd_lock(ahd, &s);
+		while (LIST_FIRST(&ahd->pending_scbs) != NULL) {
+			ahd->platform_data->flags |= AHD_DV_WAIT_SIMQ_EMPTY;
+			ahd_unlock(ahd, &s);
+			down_interruptible(&ahd->platform_data->dv_sem);
+			ahd_lock(ahd, &s);
+		}
+
+		/*
+		 * Wait for the SIMQ to be released so that DV is the
+		 * only reason the queue is frozen.
+		 */
+		while (AHD_DV_SIMQ_FROZEN(ahd) == 0) {
+			ahd->platform_data->flags |= AHD_DV_WAIT_SIMQ_RELEASE;
+			ahd_unlock(ahd, &s);
+			down_interruptible(&ahd->platform_data->dv_sem);
+			ahd_lock(ahd, &s);
+		}
+		ahd_unlock(ahd, &s);
+
+		for (target = 0; target < AHD_NUM_TARGETS; target++)
+			ahd_linux_dv_target(ahd, target);
+
+		ahd_lock(ahd, &s);
+		ahd->platform_data->flags &= ~AHD_DV_ACTIVE;
+		ahd_unlock(ahd, &s);
+
+		/*
+		 * Release the SIMQ so that normal commands are
+		 * allowed to continue on the bus.
+		 */
+		ahd_release_simq(ahd);
+	}
+	up(&ahd->platform_data->eh_sem);
+	return (0);
+}
+
+static void
+ahd_linux_kill_dv_thread(struct ahd_softc *ahd)
+{
+	u_long s;
+
+	ahd_lock(ahd, &s);
+	if (ahd->platform_data->dv_pid != 0) {
+		ahd->platform_data->flags |= AHD_DV_SHUTDOWN;
+		ahd_unlock(ahd, &s);
+		up(&ahd->platform_data->dv_sem);
+
+		/*
+		 * Use the eh_sem as an indicator that the
+		 * dv thread is exiting.  Note that the dv
+		 * thread must still return after performing
+		 * the up on our semaphore before it has
+		 * completely exited this module.  Unfortunately,
+		 * there seems to be no easy way to wait for the
+		 * exit of a thread for which you are not the
+		 * parent (dv threads are parented by init).
+		 * Cross your fingers...
+		 */
+		down(&ahd->platform_data->eh_sem);
+
+		/*
+		 * Mark the dv thread as already dead.  This
+		 * avoids attempting to kill it a second time.
+		 * This is necessary because we must kill the
+		 * DV thread before calling ahd_free() in the
+		 * module shutdown case to avoid bogus locking
+		 * in the SCSI mid-layer, but we ahd_free() is
+		 * called without killing the DV thread in the
+		 * instance detach case, so ahd_platform_free()
+		 * calls us again to verify that the DV thread
+		 * is dead.
+		 */
+		ahd->platform_data->dv_pid = 0;
+	} else {
+		ahd_unlock(ahd, &s);
+	}
+}
+
+#define AHD_LINUX_DV_INQ_SHORT_LEN	36
+#define AHD_LINUX_DV_INQ_LEN		256
+#define AHD_LINUX_DV_TIMEOUT		(HZ / 4)
+
+#define AHD_SET_DV_STATE(ahd, targ, newstate) \
+	ahd_set_dv_state(ahd, targ, newstate, __LINE__)
+
+static __inline void
+ahd_set_dv_state(struct ahd_softc *ahd, struct ahd_linux_target *targ,
+		 ahd_dv_state newstate, u_int line)
+{
+	ahd_dv_state oldstate;
+
+	oldstate = targ->dv_state;
+#ifdef AHD_DEBUG
+	if (ahd_debug & AHD_SHOW_DV)
+		printf("%s:%d: Going from state %d to state %d\n",
+		       ahd_name(ahd), line, oldstate, newstate);
+#endif
+
+	if (oldstate == newstate)
+		targ->dv_state_retry++;
+	else
+		targ->dv_state_retry = 0;
+	targ->dv_state = newstate;
+}
+
+static void
+ahd_linux_dv_target(struct ahd_softc *ahd, u_int target_offset)
+{
+	struct	 ahd_devinfo devinfo;
+	struct	 ahd_linux_target *targ;
+	struct	 scsi_cmnd *cmd;
+	struct	 scsi_device *scsi_dev;
+	struct	 scsi_sense_data *sense;
+	uint8_t *buffer;
+	u_long	 s;
+	u_int	 timeout;
+	int	 echo_size;
+
+	sense = NULL;
+	buffer = NULL;
+	echo_size = 0;
+	ahd_lock(ahd, &s);
+	targ = ahd->platform_data->targets[target_offset];
+	if (targ == NULL || (targ->flags & AHD_DV_REQUIRED) == 0) {
+		ahd_unlock(ahd, &s);
+		return;
+	}
+	ahd_compile_devinfo(&devinfo, ahd->our_id, targ->target, /*lun*/0,
+			    targ->channel + 'A', ROLE_INITIATOR);
+#ifdef AHD_DEBUG
+	if (ahd_debug & AHD_SHOW_DV) {
+		ahd_print_devinfo(ahd, &devinfo);
+		printf("Performing DV\n");
+	}
+#endif
+
+	ahd_unlock(ahd, &s);
+
+	cmd = malloc(sizeof(struct scsi_cmnd), M_DEVBUF, M_WAITOK);
+	scsi_dev = malloc(sizeof(struct scsi_device), M_DEVBUF, M_WAITOK);
+	scsi_dev->host = ahd->platform_data->host;
+	scsi_dev->id = devinfo.target;
+	scsi_dev->lun = devinfo.lun;
+	scsi_dev->channel = devinfo.channel - 'A';
+	ahd->platform_data->dv_scsi_dev = scsi_dev;
+
+	AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_INQ_SHORT_ASYNC);
+
+	while (targ->dv_state != AHD_DV_STATE_EXIT) {
+		timeout = AHD_LINUX_DV_TIMEOUT;
+		switch (targ->dv_state) {
+		case AHD_DV_STATE_INQ_SHORT_ASYNC:
+		case AHD_DV_STATE_INQ_ASYNC:
+		case AHD_DV_STATE_INQ_ASYNC_VERIFY:
+			/*
+			 * Set things to async narrow to reduce the
+			 * chance that the INQ will fail.
+			 */
+			ahd_lock(ahd, &s);
+			ahd_set_syncrate(ahd, &devinfo, 0, 0, 0,
+					 AHD_TRANS_GOAL, /*paused*/FALSE);
+			ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+				      AHD_TRANS_GOAL, /*paused*/FALSE);
+			ahd_unlock(ahd, &s);
+			timeout = 10 * HZ;
+			targ->flags &= ~AHD_INQ_VALID;
+			/* FALLTHROUGH */
+		case AHD_DV_STATE_INQ_VERIFY:
+		{
+			u_int inq_len;
+
+			if (targ->dv_state == AHD_DV_STATE_INQ_SHORT_ASYNC)
+				inq_len = AHD_LINUX_DV_INQ_SHORT_LEN;
+			else
+				inq_len = targ->inq_data->additional_length + 5;
+			ahd_linux_dv_inq(ahd, cmd, &devinfo, targ, inq_len);
+			break;
+		}
+		case AHD_DV_STATE_TUR:
+		case AHD_DV_STATE_BUSY:
+			timeout = 5 * HZ;
+			ahd_linux_dv_tur(ahd, cmd, &devinfo);
+			break;
+		case AHD_DV_STATE_REBD:
+			ahd_linux_dv_rebd(ahd, cmd, &devinfo, targ);
+			break;
+		case AHD_DV_STATE_WEB:
+			ahd_linux_dv_web(ahd, cmd, &devinfo, targ);
+			break;
+
+		case AHD_DV_STATE_REB:
+			ahd_linux_dv_reb(ahd, cmd, &devinfo, targ);
+			break;
+
+		case AHD_DV_STATE_SU:
+			ahd_linux_dv_su(ahd, cmd, &devinfo, targ);
+			timeout = 50 * HZ;
+			break;
+
+		default:
+			ahd_print_devinfo(ahd, &devinfo);
+			printf("Unknown DV state %d\n", targ->dv_state);
+			goto out;
+		}
+
+		/* Queue the command and wait for it to complete */
+		/* Abuse eh_timeout in the scsi_cmnd struct for our purposes */
+		init_timer(&cmd->eh_timeout);
+#ifdef AHD_DEBUG
+		if ((ahd_debug & AHD_SHOW_MESSAGES) != 0)
+			/*
+			 * All of the printfs during negotiation
+			 * really slow down the negotiation.
+			 * Add a bit of time just to be safe.
+			 */
+			timeout += HZ;
+#endif
+		scsi_add_timer(cmd, timeout, ahd_linux_dv_timeout);
+		/*
+		 * In 2.5.X, it is assumed that all calls from the
+		 * "midlayer" (which we are emulating) will have the
+		 * ahd host lock held.  For other kernels, the
+		 * io_request_lock must be held.
+		 */
+#if AHD_SCSI_HAS_HOST_LOCK != 0
+		ahd_lock(ahd, &s);
+#else
+		spin_lock_irqsave(&io_request_lock, s);
+#endif
+		ahd_linux_queue(cmd, ahd_linux_dv_complete);
+#if AHD_SCSI_HAS_HOST_LOCK != 0
+		ahd_unlock(ahd, &s);
+#else
+		spin_unlock_irqrestore(&io_request_lock, s);
+#endif
+		down_interruptible(&ahd->platform_data->dv_cmd_sem);
+		/*
+		 * Wait for the SIMQ to be released so that DV is the
+		 * only reason the queue is frozen.
+		 */
+		ahd_lock(ahd, &s);
+		while (AHD_DV_SIMQ_FROZEN(ahd) == 0) {
+			ahd->platform_data->flags |= AHD_DV_WAIT_SIMQ_RELEASE;
+			ahd_unlock(ahd, &s);
+			down_interruptible(&ahd->platform_data->dv_sem);
+			ahd_lock(ahd, &s);
+		}
+		ahd_unlock(ahd, &s);
+
+		ahd_linux_dv_transition(ahd, cmd, &devinfo, targ);
+	}
+
+out:
+	if ((targ->flags & AHD_INQ_VALID) != 0
+	 && ahd_linux_get_device(ahd, devinfo.channel - 'A',
+				 devinfo.target, devinfo.lun,
+				 /*alloc*/FALSE) == NULL) {
+		/*
+		 * The DV state machine failed to configure this device.  
+		 * This is normal if DV is disabled.  Since we have inquiry
+		 * data, filter it and use the "optimistic" negotiation
+		 * parameters found in the inquiry string.
+		 */
+		ahd_linux_filter_inquiry(ahd, &devinfo);
+		if ((targ->flags & (AHD_BASIC_DV|AHD_ENHANCED_DV)) != 0) {
+			ahd_print_devinfo(ahd, &devinfo);
+			printf("DV failed to configure device.  "
+			       "Please file a bug report against "
+			       "this driver.\n");
+		}
+	}
+
+	if (cmd != NULL)
+		free(cmd, M_DEVBUF);
+
+	if (ahd->platform_data->dv_scsi_dev != NULL) {
+		free(ahd->platform_data->dv_scsi_dev, M_DEVBUF);
+		ahd->platform_data->dv_scsi_dev = NULL;
+	}
+
+	ahd_lock(ahd, &s);
+	if (targ->dv_buffer != NULL) {
+		free(targ->dv_buffer, M_DEVBUF);
+		targ->dv_buffer = NULL;
+	}
+	if (targ->dv_buffer1 != NULL) {
+		free(targ->dv_buffer1, M_DEVBUF);
+		targ->dv_buffer1 = NULL;
+	}
+	targ->flags &= ~AHD_DV_REQUIRED;
+	if (targ->refcount == 0)
+		ahd_linux_free_target(ahd, targ);
+	ahd_unlock(ahd, &s);
+}
+
+static void
+ahd_linux_dv_transition(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
+			struct ahd_devinfo *devinfo,
+			struct ahd_linux_target *targ)
+{
+	u_int32_t status;
+
+	status = aic_error_action(cmd, targ->inq_data,
+				  ahd_cmd_get_transaction_status(cmd),
+				  ahd_cmd_get_scsi_status(cmd));
+
+	
+#ifdef AHD_DEBUG
+	if (ahd_debug & AHD_SHOW_DV) {
+		ahd_print_devinfo(ahd, devinfo);
+		printf("Entering ahd_linux_dv_transition, state= %d, "
+		       "status= 0x%x, cmd->result= 0x%x\n", targ->dv_state,
+		       status, cmd->result);
+	}
+#endif
+
+	switch (targ->dv_state) {
+	case AHD_DV_STATE_INQ_SHORT_ASYNC:
+	case AHD_DV_STATE_INQ_ASYNC:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+		{
+			AHD_SET_DV_STATE(ahd, targ, targ->dv_state+1);
+			break;
+		}
+		case SS_INQ_REFRESH:
+			AHD_SET_DV_STATE(ahd, targ,
+					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		case SS_TUR:
+		case SS_RETRY:
+			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
+			if (ahd_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ)
+				targ->dv_state_retry--;
+			if ((status & SS_ERRMASK) == EBUSY)
+				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_BUSY);
+			if (targ->dv_state_retry < 10)
+				break;
+			/* FALLTHROUGH */
+		default:
+			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+#ifdef AHD_DEBUG
+			if (ahd_debug & AHD_SHOW_DV) {
+				ahd_print_devinfo(ahd, devinfo);
+				printf("Failed DV inquiry, skipping\n");
+			}
+#endif
+			break;
+		}
+		break;
+	case AHD_DV_STATE_INQ_ASYNC_VERIFY:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+		{
+			u_int xportflags;
+			u_int spi3data;
+
+			if (memcmp(targ->inq_data, targ->dv_buffer,
+				   AHD_LINUX_DV_INQ_LEN) != 0) {
+				/*
+				 * Inquiry data must have changed.
+				 * Try from the top again.
+				 */
+				AHD_SET_DV_STATE(ahd, targ,
+						 AHD_DV_STATE_INQ_SHORT_ASYNC);
+				break;
+			}
+
+			AHD_SET_DV_STATE(ahd, targ, targ->dv_state+1);
+			targ->flags |= AHD_INQ_VALID;
+			if (ahd_linux_user_dv_setting(ahd) == 0)
+				break;
+
+			xportflags = targ->inq_data->flags;
+			if ((xportflags & (SID_Sync|SID_WBus16)) == 0)
+				break;
+
+			spi3data = targ->inq_data->spi3data;
+			switch (spi3data & SID_SPI_CLOCK_DT_ST) {
+			default:
+			case SID_SPI_CLOCK_ST:
+				/* Assume only basic DV is supported. */
+				targ->flags |= AHD_BASIC_DV;
+				break;
+			case SID_SPI_CLOCK_DT:
+			case SID_SPI_CLOCK_DT_ST:
+				targ->flags |= AHD_ENHANCED_DV;
+				break;
+			}
+			break;
+		}
+		case SS_INQ_REFRESH:
+			AHD_SET_DV_STATE(ahd, targ,
+					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		case SS_TUR:
+		case SS_RETRY:
+			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
+			if (ahd_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ)
+				targ->dv_state_retry--;
+
+			if ((status & SS_ERRMASK) == EBUSY)
+				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_BUSY);
+			if (targ->dv_state_retry < 10)
+				break;
+			/* FALLTHROUGH */
+		default:
+			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+#ifdef AHD_DEBUG
+			if (ahd_debug & AHD_SHOW_DV) {
+				ahd_print_devinfo(ahd, devinfo);
+				printf("Failed DV inquiry, skipping\n");
+			}
+#endif
+			break;
+		}
+		break;
+	case AHD_DV_STATE_INQ_VERIFY:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+		{
+
+			if (memcmp(targ->inq_data, targ->dv_buffer,
+				   AHD_LINUX_DV_INQ_LEN) == 0) {
+				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+				break;
+			}
+
+#ifdef AHD_DEBUG
+			if (ahd_debug & AHD_SHOW_DV) {
+				int i;
+
+				ahd_print_devinfo(ahd, devinfo);
+				printf("Inquiry buffer mismatch:");
+				for (i = 0; i < AHD_LINUX_DV_INQ_LEN; i++) {
+					if ((i & 0xF) == 0)
+						printf("\n        ");
+					printf("0x%x:0x0%x ",
+					       ((uint8_t *)targ->inq_data)[i], 
+					       targ->dv_buffer[i]);
+				}
+				printf("\n");
+			}
+#endif
+
+			if (ahd_linux_dv_fallback(ahd, devinfo) != 0) {
+				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+				break;
+			}
+			/*
+			 * Do not count "falling back"
+			 * against our retries.
+			 */
+			targ->dv_state_retry = 0;
+			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
+			break;
+		}
+		case SS_INQ_REFRESH:
+			AHD_SET_DV_STATE(ahd, targ,
+					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		case SS_TUR:
+		case SS_RETRY:
+			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
+			if (ahd_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ) {
+				targ->dv_state_retry--;
+			} else if ((status & SSQ_FALLBACK) != 0) {
+				if (ahd_linux_dv_fallback(ahd, devinfo) != 0) {
+					AHD_SET_DV_STATE(ahd, targ,
+							 AHD_DV_STATE_EXIT);
+					break;
+				}
+				/*
+				 * Do not count "falling back"
+				 * against our retries.
+				 */
+				targ->dv_state_retry = 0;
+			} else if ((status & SS_ERRMASK) == EBUSY)
+				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_BUSY);
+			if (targ->dv_state_retry < 10)
+				break;
+			/* FALLTHROUGH */
+		default:
+			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+#ifdef AHD_DEBUG
+			if (ahd_debug & AHD_SHOW_DV) {
+				ahd_print_devinfo(ahd, devinfo);
+				printf("Failed DV inquiry, skipping\n");
+			}
+#endif
+			break;
+		}
+		break;
+
+	case AHD_DV_STATE_TUR:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+			if ((targ->flags & AHD_BASIC_DV) != 0) {
+				ahd_linux_filter_inquiry(ahd, devinfo);
+				AHD_SET_DV_STATE(ahd, targ,
+						 AHD_DV_STATE_INQ_VERIFY);
+			} else if ((targ->flags & AHD_ENHANCED_DV) != 0) {
+				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_REBD);
+			} else {
+				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			}
+			break;
+		case SS_RETRY:
+		case SS_TUR:
+			if ((status & SS_ERRMASK) == EBUSY) {
+				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_BUSY);
+				break;
+			}
+			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
+			if (ahd_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ) {
+				targ->dv_state_retry--;
+			} else if ((status & SSQ_FALLBACK) != 0) {
+				if (ahd_linux_dv_fallback(ahd, devinfo) != 0) {
+					AHD_SET_DV_STATE(ahd, targ,
+							 AHD_DV_STATE_EXIT);
+					break;
+				}
+				/*
+				 * Do not count "falling back"
+				 * against our retries.
+				 */
+				targ->dv_state_retry = 0;
+			}
+			if (targ->dv_state_retry >= 10) {
+#ifdef AHD_DEBUG
+				if (ahd_debug & AHD_SHOW_DV) {
+					ahd_print_devinfo(ahd, devinfo);
+					printf("DV TUR reties exhausted\n");
+				}
+#endif
+				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+				break;
+			}
+			if (status & SSQ_DELAY)
+				scsi_sleep(1 * HZ);
+
+			break;
+		case SS_START:
+			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_SU);
+			break;
+		case SS_INQ_REFRESH:
+			AHD_SET_DV_STATE(ahd, targ,
+					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		default:
+			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			break;
+		}
+		break;
+
+	case AHD_DV_STATE_REBD:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+		{
+			uint32_t echo_size;
+
+			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_WEB);
+			echo_size = scsi_3btoul(&targ->dv_buffer[1]);
+			echo_size &= 0x1FFF;
+#ifdef AHD_DEBUG
+			if (ahd_debug & AHD_SHOW_DV) {
+				ahd_print_devinfo(ahd, devinfo);
+				printf("Echo buffer size= %d\n", echo_size);
+			}
+#endif
+			if (echo_size == 0) {
+				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+				break;
+			}
+
+			/* Generate the buffer pattern */
+			targ->dv_echo_size = echo_size;
+			ahd_linux_generate_dv_pattern(targ);
+			/*
+			 * Setup initial negotiation values.
+			 */
+			ahd_linux_filter_inquiry(ahd, devinfo);
+			break;
+		}
+		case SS_INQ_REFRESH:
+			AHD_SET_DV_STATE(ahd, targ,
+					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		case SS_RETRY:
+			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
+			if (ahd_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ)
+				targ->dv_state_retry--;
+			if (targ->dv_state_retry <= 10)
+				break;
+#ifdef AHD_DEBUG
+			if (ahd_debug & AHD_SHOW_DV) {
+				ahd_print_devinfo(ahd, devinfo);
+				printf("DV REBD reties exhausted\n");
+			}
+#endif
+			/* FALLTHROUGH */
+		case SS_FATAL:
+		default:
+			/*
+			 * Setup initial negotiation values
+			 * and try level 1 DV.
+			 */
+			ahd_linux_filter_inquiry(ahd, devinfo);
+			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_INQ_VERIFY);
+			targ->dv_echo_size = 0;
+			break;
+		}
+		break;
+
+	case AHD_DV_STATE_WEB:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_REB);
+			break;
+		case SS_INQ_REFRESH:
+			AHD_SET_DV_STATE(ahd, targ,
+					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		case SS_RETRY:
+			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
+			if (ahd_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ) {
+				targ->dv_state_retry--;
+			} else if ((status & SSQ_FALLBACK) != 0) {
+				if (ahd_linux_dv_fallback(ahd, devinfo) != 0) {
+					AHD_SET_DV_STATE(ahd, targ,
+							 AHD_DV_STATE_EXIT);
+					break;
+				}
+				/*
+				 * Do not count "falling back"
+				 * against our retries.
+				 */
+				targ->dv_state_retry = 0;
+			}
+			if (targ->dv_state_retry <= 10)
+				break;
+			/* FALLTHROUGH */
+#ifdef AHD_DEBUG
+			if (ahd_debug & AHD_SHOW_DV) {
+				ahd_print_devinfo(ahd, devinfo);
+				printf("DV WEB reties exhausted\n");
+			}
+#endif
+		default:
+			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			break;
+		}
+		break;
+
+	case AHD_DV_STATE_REB:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+			if (memcmp(targ->dv_buffer, targ->dv_buffer1,
+				   targ->dv_echo_size) != 0) {
+				if (ahd_linux_dv_fallback(ahd, devinfo) != 0)
+					AHD_SET_DV_STATE(ahd, targ,
+							 AHD_DV_STATE_EXIT);
+				else
+					AHD_SET_DV_STATE(ahd, targ,
+							 AHD_DV_STATE_WEB);
+				break;
+			}
+			
+			if (targ->dv_buffer != NULL) {
+				free(targ->dv_buffer, M_DEVBUF);
+				targ->dv_buffer = NULL;
+			}
+			if (targ->dv_buffer1 != NULL) {
+				free(targ->dv_buffer1, M_DEVBUF);
+				targ->dv_buffer1 = NULL;
+			}
+			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			break;
+		case SS_INQ_REFRESH:
+			AHD_SET_DV_STATE(ahd, targ,
+					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		case SS_RETRY:
+			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
+			if (ahd_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ) {
+				targ->dv_state_retry--;
+			} else if ((status & SSQ_FALLBACK) != 0) {
+				if (ahd_linux_dv_fallback(ahd, devinfo) != 0) {
+					AHD_SET_DV_STATE(ahd, targ,
+							 AHD_DV_STATE_EXIT);
+					break;
+				}
+				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_WEB);
+			}
+			if (targ->dv_state_retry <= 10) {
+				if ((status & (SSQ_DELAY_RANDOM|SSQ_DELAY))!= 0)
+					scsi_sleep(ahd->our_id*HZ/10);
+				break;
+			}
+#ifdef AHD_DEBUG
+			if (ahd_debug & AHD_SHOW_DV) {
+				ahd_print_devinfo(ahd, devinfo);
+				printf("DV REB reties exhausted\n");
+			}
+#endif
+			/* FALLTHROUGH */
+		default:
+			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			break;
+		}
+		break;
+
+	case AHD_DV_STATE_SU:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+		case SS_INQ_REFRESH:
+			AHD_SET_DV_STATE(ahd, targ,
+					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		default:
+			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			break;
+		}
+		break;
+
+	case AHD_DV_STATE_BUSY:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+		case SS_INQ_REFRESH:
+			AHD_SET_DV_STATE(ahd, targ,
+					 AHD_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		case SS_TUR:
+		case SS_RETRY:
+			AHD_SET_DV_STATE(ahd, targ, targ->dv_state);
+			if (ahd_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ) {
+				targ->dv_state_retry--;
+			} else if (targ->dv_state_retry < 60) {
+				if ((status & SSQ_DELAY) != 0)
+					scsi_sleep(1 * HZ);
+			} else {
+#ifdef AHD_DEBUG
+				if (ahd_debug & AHD_SHOW_DV) {
+					ahd_print_devinfo(ahd, devinfo);
+					printf("DV BUSY reties exhausted\n");
+				}
+#endif
+				AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			}
+			break;
+		default:
+			AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+			break;
+		}
+		break;
+
+	default:
+		printf("%s: Invalid DV completion state %d\n", ahd_name(ahd),
+		       targ->dv_state);
+		AHD_SET_DV_STATE(ahd, targ, AHD_DV_STATE_EXIT);
+		break;
+	}
+}
+
+static void
+ahd_linux_dv_fill_cmd(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
+		      struct ahd_devinfo *devinfo)
+{
+	memset(cmd, 0, sizeof(struct scsi_cmnd));
+	cmd->device = ahd->platform_data->dv_scsi_dev;
+	cmd->scsi_done = ahd_linux_dv_complete;
+}
+
+/*
+ * Synthesize an inquiry command.  On the return trip, it'll be
+ * sniffed and the device transfer settings set for us.
+ */
+static void
+ahd_linux_dv_inq(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
+		 struct ahd_devinfo *devinfo, struct ahd_linux_target *targ,
+		 u_int request_length)
+{
+
+#ifdef AHD_DEBUG
+	if (ahd_debug & AHD_SHOW_DV) {
+		ahd_print_devinfo(ahd, devinfo);
+		printf("Sending INQ\n");
+	}
+#endif
+	if (targ->inq_data == NULL)
+		targ->inq_data = malloc(AHD_LINUX_DV_INQ_LEN,
+					M_DEVBUF, M_WAITOK);
+	if (targ->dv_state > AHD_DV_STATE_INQ_ASYNC) {
+		if (targ->dv_buffer != NULL)
+			free(targ->dv_buffer, M_DEVBUF);
+		targ->dv_buffer = malloc(AHD_LINUX_DV_INQ_LEN,
+					 M_DEVBUF, M_WAITOK);
+	}
+
+	ahd_linux_dv_fill_cmd(ahd, cmd, devinfo);
+	cmd->sc_data_direction = SCSI_DATA_READ;
+	cmd->cmd_len = 6;
+	cmd->cmnd[0] = INQUIRY;
+	cmd->cmnd[4] = request_length;
+	cmd->request_bufflen = request_length;
+	if (targ->dv_state > AHD_DV_STATE_INQ_ASYNC)
+		cmd->request_buffer = targ->dv_buffer;
+	else
+		cmd->request_buffer = targ->inq_data;
+	memset(cmd->request_buffer, 0, AHD_LINUX_DV_INQ_LEN);
+}
+
+static void
+ahd_linux_dv_tur(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
+		 struct ahd_devinfo *devinfo)
+{
+
+#ifdef AHD_DEBUG
+	if (ahd_debug & AHD_SHOW_DV) {
+		ahd_print_devinfo(ahd, devinfo);
+		printf("Sending TUR\n");
+	}
+#endif
+	/* Do a TUR to clear out any non-fatal transitional state */
+	ahd_linux_dv_fill_cmd(ahd, cmd, devinfo);
+	cmd->sc_data_direction = SCSI_DATA_NONE;
+	cmd->cmd_len = 6;
+	cmd->cmnd[0] = TEST_UNIT_READY;
+}
+
+#define AHD_REBD_LEN 4
+
+static void
+ahd_linux_dv_rebd(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
+		 struct ahd_devinfo *devinfo, struct ahd_linux_target *targ)
+{
+
+#ifdef AHD_DEBUG
+	if (ahd_debug & AHD_SHOW_DV) {
+		ahd_print_devinfo(ahd, devinfo);
+		printf("Sending REBD\n");
+	}
+#endif
+	if (targ->dv_buffer != NULL)
+		free(targ->dv_buffer, M_DEVBUF);
+	targ->dv_buffer = malloc(AHD_REBD_LEN, M_DEVBUF, M_WAITOK);
+	ahd_linux_dv_fill_cmd(ahd, cmd, devinfo);
+	cmd->sc_data_direction = SCSI_DATA_READ;
+	cmd->cmd_len = 10;
+	cmd->cmnd[0] = READ_BUFFER;
+	cmd->cmnd[1] = 0x0b;
+	scsi_ulto3b(AHD_REBD_LEN, &cmd->cmnd[6]);
+	cmd->request_bufflen = AHD_REBD_LEN;
+	cmd->underflow = cmd->request_bufflen;
+	cmd->request_buffer = targ->dv_buffer;
+}
+
+static void
+ahd_linux_dv_web(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
+		 struct ahd_devinfo *devinfo, struct ahd_linux_target *targ)
+{
+
+#ifdef AHD_DEBUG
+	if (ahd_debug & AHD_SHOW_DV) {
+		ahd_print_devinfo(ahd, devinfo);
+		printf("Sending WEB\n");
+	}
+#endif
+	ahd_linux_dv_fill_cmd(ahd, cmd, devinfo);
+	cmd->sc_data_direction = SCSI_DATA_WRITE;
+	cmd->cmd_len = 10;
+	cmd->cmnd[0] = WRITE_BUFFER;
+	cmd->cmnd[1] = 0x0a;
+	scsi_ulto3b(targ->dv_echo_size, &cmd->cmnd[6]);
+	cmd->request_bufflen = targ->dv_echo_size;
+	cmd->underflow = cmd->request_bufflen;
+	cmd->request_buffer = targ->dv_buffer;
+}
+
+static void
+ahd_linux_dv_reb(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
+		 struct ahd_devinfo *devinfo, struct ahd_linux_target *targ)
+{
+
+#ifdef AHD_DEBUG
+	if (ahd_debug & AHD_SHOW_DV) {
+		ahd_print_devinfo(ahd, devinfo);
+		printf("Sending REB\n");
+	}
+#endif
+	ahd_linux_dv_fill_cmd(ahd, cmd, devinfo);
+	cmd->sc_data_direction = SCSI_DATA_READ;
+	cmd->cmd_len = 10;
+	cmd->cmnd[0] = READ_BUFFER;
+	cmd->cmnd[1] = 0x0a;
+	scsi_ulto3b(targ->dv_echo_size, &cmd->cmnd[6]);
+	cmd->request_bufflen = targ->dv_echo_size;
+	cmd->underflow = cmd->request_bufflen;
+	cmd->request_buffer = targ->dv_buffer1;
+}
+
+static void
+ahd_linux_dv_su(struct ahd_softc *ahd, struct scsi_cmnd *cmd,
+		struct ahd_devinfo *devinfo,
+		struct ahd_linux_target *targ)
+{
+	u_int le;
+
+	le = SID_IS_REMOVABLE(targ->inq_data) ? SSS_LOEJ : 0;
+
+#ifdef AHD_DEBUG
+	if (ahd_debug & AHD_SHOW_DV) {
+		ahd_print_devinfo(ahd, devinfo);
+		printf("Sending SU\n");
+	}
+#endif
+	ahd_linux_dv_fill_cmd(ahd, cmd, devinfo);
+	cmd->sc_data_direction = SCSI_DATA_NONE;
+	cmd->cmd_len = 6;
+	cmd->cmnd[0] = START_STOP_UNIT;
+	cmd->cmnd[4] = le | SSS_START;
+}
+
+static __inline int
+ahd_linux_dv_fallback(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	u_long s;
+	int retval;
+
+	ahd_lock(ahd, &s);
+	retval = ahd_linux_fallback(ahd, devinfo);
+	ahd_unlock(ahd, &s);
+
+	return (retval);
+}
+
+static int
+ahd_linux_fallback(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	struct	ahd_linux_target *targ;
+	struct	ahd_initiator_tinfo *tinfo;
+	struct	ahd_transinfo *goal;
+	struct	ahd_tmode_tstate *tstate;
+	u_int	width;
+	u_int	period;
+	u_int	offset;
+	u_int	ppr_options;
+	u_int	cur_speed;
+	u_int	wide_speed;
+	u_int	narrow_speed;
+	u_int	fallback_speed;
+
+#ifdef AHD_DEBUG
+	if (ahd_debug & AHD_SHOW_DV) {
+		ahd_print_devinfo(ahd, devinfo);
+		printf("Trying to fallback\n");
+	}
+#endif
+	targ = ahd->platform_data->targets[devinfo->target_offset];
+	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel,
+				    devinfo->our_scsiid,
+				    devinfo->target, &tstate);
+	goal = &tinfo->goal;
+	width = goal->width;
+	period = goal->period;
+	offset = goal->offset;
+	ppr_options = goal->ppr_options;
+	if (offset == 0)
+		period = AHD_ASYNC_XFER_PERIOD;
+	if (targ->dv_next_narrow_period == 0)
+		targ->dv_next_narrow_period = MAX(period, AHD_SYNCRATE_ULTRA2);
+	if (targ->dv_next_wide_period == 0)
+		targ->dv_next_wide_period = period;
+	if (targ->dv_max_width == 0)
+		targ->dv_max_width = width;
+	if (targ->dv_max_ppr_options == 0)
+		targ->dv_max_ppr_options = ppr_options;
+	if (targ->dv_last_ppr_options == 0)
+		targ->dv_last_ppr_options = ppr_options;
+
+	cur_speed = aic_calc_speed(width, period, offset, AHD_SYNCRATE_MIN);
+	wide_speed = aic_calc_speed(MSG_EXT_WDTR_BUS_16_BIT,
+					  targ->dv_next_wide_period,
+					  MAX_OFFSET, AHD_SYNCRATE_MIN);
+	narrow_speed = aic_calc_speed(MSG_EXT_WDTR_BUS_8_BIT,
+					    targ->dv_next_narrow_period,
+					    MAX_OFFSET, AHD_SYNCRATE_MIN);
+	fallback_speed = aic_calc_speed(width, period+1, offset,
+					      AHD_SYNCRATE_MIN);
+#ifdef AHD_DEBUG
+	if (ahd_debug & AHD_SHOW_DV) {
+		printf("cur_speed= %d, wide_speed= %d, narrow_speed= %d, "
+		       "fallback_speed= %d\n", cur_speed, wide_speed,
+		       narrow_speed, fallback_speed);
+	}
+#endif
+
+	if (cur_speed > 160000) {
+		/*
+		 * Paced/DT/IU_REQ only transfer speeds.  All we
+		 * can do is fallback in terms of syncrate.
+		 */
+		period++;
+	} else if (cur_speed > 80000) {
+		if ((ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
+			/*
+			 * Try without IU_REQ as it may be confusing
+			 * an expander.
+			 */
+			ppr_options &= ~MSG_EXT_PPR_IU_REQ;
+		} else {
+			/*
+			 * Paced/DT only transfer speeds.  All we
+			 * can do is fallback in terms of syncrate.
+			 */
+			period++;
+			ppr_options = targ->dv_max_ppr_options;
+		}
+	} else if (cur_speed > 3300) {
+
+		/*
+		 * In this range we the following
+		 * options ordered from highest to
+		 * lowest desireability:
+		 *
+		 * o Wide/DT
+		 * o Wide/non-DT
+		 * o Narrow at a potentally higher sync rate.
+		 *
+		 * All modes are tested with and without IU_REQ
+		 * set since using IUs may confuse an expander.
+		 */
+		if ((ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
+
+			ppr_options &= ~MSG_EXT_PPR_IU_REQ;
+		} else if ((ppr_options & MSG_EXT_PPR_DT_REQ) != 0) {
+			/*
+			 * Try going non-DT.
+			 */
+			ppr_options = targ->dv_max_ppr_options;
+			ppr_options &= ~MSG_EXT_PPR_DT_REQ;
+		} else if (targ->dv_last_ppr_options != 0) {
+			/*
+			 * Try without QAS or any other PPR options.
+			 * We may need a non-PPR message to work with
+			 * an expander.  We look at the "last PPR options"
+			 * so we will perform this fallback even if the
+			 * target responded to our PPR negotiation with
+			 * no option bits set.
+			 */
+			ppr_options = 0;
+		} else if (width == MSG_EXT_WDTR_BUS_16_BIT) {
+			/*
+			 * If the next narrow speed is greater than
+			 * the next wide speed, fallback to narrow.
+			 * Otherwise fallback to the next DT/Wide setting.
+			 * The narrow async speed will always be smaller
+			 * than the wide async speed, so handle this case
+			 * specifically.
+			 */
+			ppr_options = targ->dv_max_ppr_options;
+			if (narrow_speed > fallback_speed
+			 || period >= AHD_ASYNC_XFER_PERIOD) {
+				targ->dv_next_wide_period = period+1;
+				width = MSG_EXT_WDTR_BUS_8_BIT;
+				period = targ->dv_next_narrow_period;
+			} else {
+				period++;
+			}
+		} else if ((ahd->features & AHD_WIDE) != 0
+			&& targ->dv_max_width != 0
+			&& wide_speed >= fallback_speed
+			&& (targ->dv_next_wide_period <= AHD_ASYNC_XFER_PERIOD
+			 || period >= AHD_ASYNC_XFER_PERIOD)) {
+
+			/*
+			 * We are narrow.  Try falling back
+			 * to the next wide speed with 
+			 * all supported ppr options set.
+			 */
+			targ->dv_next_narrow_period = period+1;
+			width = MSG_EXT_WDTR_BUS_16_BIT;
+			period = targ->dv_next_wide_period;
+			ppr_options = targ->dv_max_ppr_options;
+		} else {
+			/* Only narrow fallback is allowed. */
+			period++;
+			ppr_options = targ->dv_max_ppr_options;
+		}
+	} else {
+		return (-1);
+	}
+	offset = MAX_OFFSET;
+	ahd_find_syncrate(ahd, &period, &ppr_options, AHD_SYNCRATE_PACED);
+	ahd_set_width(ahd, devinfo, width, AHD_TRANS_GOAL, FALSE);
+	if (period == 0) {
+		period = 0;
+		offset = 0;
+		ppr_options = 0;
+		if (width == MSG_EXT_WDTR_BUS_8_BIT)
+			targ->dv_next_narrow_period = AHD_ASYNC_XFER_PERIOD;
+		else
+			targ->dv_next_wide_period = AHD_ASYNC_XFER_PERIOD;
+	}
+	ahd_set_syncrate(ahd, devinfo, period, offset,
+			 ppr_options, AHD_TRANS_GOAL, FALSE);
+	targ->dv_last_ppr_options = ppr_options;
+	return (0);
+}
+
+static void
+ahd_linux_dv_timeout(struct scsi_cmnd *cmd)
+{
+	struct	ahd_softc *ahd;
+	struct	scb *scb;
+	u_long	flags;
+
+	ahd = *((struct ahd_softc **)cmd->device->host->hostdata);
+	ahd_lock(ahd, &flags);
+
+#ifdef AHD_DEBUG
+	if (ahd_debug & AHD_SHOW_DV) {
+		printf("%s: Timeout while doing DV command %x.\n",
+		       ahd_name(ahd), cmd->cmnd[0]);
+		ahd_dump_card_state(ahd);
+	}
+#endif
+	
+	/*
+	 * Guard against "done race".  No action is
+	 * required if we just completed.
+	 */
+	if ((scb = (struct scb *)cmd->host_scribble) == NULL) {
+		ahd_unlock(ahd, &flags);
+		return;
+	}
+
+	/*
+	 * Command has not completed.  Mark this
+	 * SCB as having failing status prior to
+	 * resetting the bus, so we get the correct
+	 * error code.
+	 */
+	if ((scb->flags & SCB_SENSE) != 0)
+		ahd_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
+	else
+		ahd_set_transaction_status(scb, CAM_CMD_TIMEOUT);
+	ahd_reset_channel(ahd, cmd->device->channel + 'A', /*initiate*/TRUE);
+
+	/*
+	 * Add a minimal bus settle delay for devices that are slow to
+	 * respond after bus resets.
+	 */
+	ahd_freeze_simq(ahd);
+	init_timer(&ahd->platform_data->reset_timer);
+	ahd->platform_data->reset_timer.data = (u_long)ahd;
+	ahd->platform_data->reset_timer.expires = jiffies + HZ / 2;
+	ahd->platform_data->reset_timer.function =
+	    (ahd_linux_callback_t *)ahd_release_simq;
+	add_timer(&ahd->platform_data->reset_timer);
+	if (ahd_linux_next_device_to_run(ahd) != NULL)
+		ahd_schedule_runq(ahd);
+	ahd_linux_run_complete_queue(ahd);
+	ahd_unlock(ahd, &flags);
+}
+
+static void
+ahd_linux_dv_complete(struct scsi_cmnd *cmd)
+{
+	struct ahd_softc *ahd;
+
+	ahd = *((struct ahd_softc **)cmd->device->host->hostdata);
+
+	/* Delete the DV timer before it goes off! */
+	scsi_delete_timer(cmd);
+
+#ifdef AHD_DEBUG
+	if (ahd_debug & AHD_SHOW_DV)
+		printf("%s:%c:%d: Command completed, status= 0x%x\n",
+		       ahd_name(ahd), cmd->device->channel, cmd->device->id,
+		       cmd->result);
+#endif
+
+	/* Wake up the state machine */
+	up(&ahd->platform_data->dv_cmd_sem);
+}
+
+static void
+ahd_linux_generate_dv_pattern(struct ahd_linux_target *targ)
+{
+	uint16_t b;
+	u_int	 i;
+	u_int	 j;
+
+	if (targ->dv_buffer != NULL)
+		free(targ->dv_buffer, M_DEVBUF);
+	targ->dv_buffer = malloc(targ->dv_echo_size, M_DEVBUF, M_WAITOK);
+	if (targ->dv_buffer1 != NULL)
+		free(targ->dv_buffer1, M_DEVBUF);
+	targ->dv_buffer1 = malloc(targ->dv_echo_size, M_DEVBUF, M_WAITOK);
+
+	i = 0;
+
+	b = 0x0001;
+	for (j = 0 ; i < targ->dv_echo_size; j++) {
+		if (j < 32) {
+			/*
+			 * 32bytes of sequential numbers.
+			 */
+			targ->dv_buffer[i++] = j & 0xff;
+		} else if (j < 48) {
+			/*
+			 * 32bytes of repeating 0x0000, 0xffff.
+			 */
+			targ->dv_buffer[i++] = (j & 0x02) ? 0xff : 0x00;
+		} else if (j < 64) {
+			/*
+			 * 32bytes of repeating 0x5555, 0xaaaa.
+			 */
+			targ->dv_buffer[i++] = (j & 0x02) ? 0xaa : 0x55;
+		} else {
+			/*
+			 * Remaining buffer is filled with a repeating
+			 * patter of:
+			 *
+			 *	 0xffff
+			 *	~0x0001 << shifted once in each loop.
+			 */
+			if (j & 0x02) {
+				if (j & 0x01) {
+					targ->dv_buffer[i++] = ~(b >> 8) & 0xff;
+					b <<= 1;
+					if (b == 0x0000)
+						b = 0x0001;
+				} else {
+					targ->dv_buffer[i++] = (~b & 0xff);
+				}
+			} else {
+				targ->dv_buffer[i++] = 0xff;
+			}
+		}
+	}
+}
+
+static u_int
+ahd_linux_user_tagdepth(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	static int warned_user;
+	u_int tags;
+
+	tags = 0;
+	if ((ahd->user_discenable & devinfo->target_mask) != 0) {
+		if (ahd->unit >= NUM_ELEMENTS(aic79xx_tag_info)) {
+
+			if (warned_user == 0) {
+				printf(KERN_WARNING
+"aic79xx: WARNING: Insufficient tag_info instances\n"
+"aic79xx: for installed controllers.  Using defaults\n"
+"aic79xx: Please update the aic79xx_tag_info array in\n"
+"aic79xx: the aic79xx_osm.c source file.\n");
+				warned_user++;
+			}
+			tags = AHD_MAX_QUEUE;
+		} else {
+			adapter_tag_info_t *tag_info;
+
+			tag_info = &aic79xx_tag_info[ahd->unit];
+			tags = tag_info->tag_commands[devinfo->target_offset];
+			if (tags > AHD_MAX_QUEUE)
+				tags = AHD_MAX_QUEUE;
+		}
+	}
+	return (tags);
+}
+
+static u_int
+ahd_linux_user_dv_setting(struct ahd_softc *ahd)
+{
+	static int warned_user;
+	int dv;
+
+	if (ahd->unit >= NUM_ELEMENTS(aic79xx_dv_settings)) {
+
+		if (warned_user == 0) {
+			printf(KERN_WARNING
+"aic79xx: WARNING: Insufficient dv settings instances\n"
+"aic79xx: for installed controllers. Using defaults\n"
+"aic79xx: Please update the aic79xx_dv_settings array in"
+"aic79xx: the aic79xx_osm.c source file.\n");
+			warned_user++;
+		}
+		dv = -1;
+	} else {
+
+		dv = aic79xx_dv_settings[ahd->unit];
+	}
+
+	if (dv < 0) {
+		/*
+		 * Apply the default.
+		 */
+		dv = 1;
+		if (ahd->seep_config != 0)
+			dv = (ahd->seep_config->bios_control & CFENABLEDV);
+	}
+	return (dv);
+}
+
+static void
+ahd_linux_setup_user_rd_strm_settings(struct ahd_softc *ahd)
+{
+	static	int warned_user;
+	u_int	rd_strm_mask;
+	u_int	target_id;
+
+	/*
+	 * If we have specific read streaming info for this controller,
+	 * apply it.  Otherwise use the defaults.
+	 */
+	 if (ahd->unit >= NUM_ELEMENTS(aic79xx_rd_strm_info)) {
+
+		if (warned_user == 0) {
+
+			printf(KERN_WARNING
+"aic79xx: WARNING: Insufficient rd_strm instances\n"
+"aic79xx: for installed controllers. Using defaults\n"
+"aic79xx: Please update the aic79xx_rd_strm_info array\n"
+"aic79xx: in the aic79xx_osm.c source file.\n");
+			warned_user++;
+		}
+		rd_strm_mask = AIC79XX_CONFIGED_RD_STRM;
+	} else {
+
+		rd_strm_mask = aic79xx_rd_strm_info[ahd->unit];
+	}
+	for (target_id = 0; target_id < 16; target_id++) {
+		struct ahd_devinfo devinfo;
+		struct ahd_initiator_tinfo *tinfo;
+		struct ahd_tmode_tstate *tstate;
+
+		tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
+					    target_id, &tstate);
+		ahd_compile_devinfo(&devinfo, ahd->our_id, target_id,
+				    CAM_LUN_WILDCARD, 'A', ROLE_INITIATOR);
+		tinfo->user.ppr_options &= ~MSG_EXT_PPR_RD_STRM;
+		if ((rd_strm_mask & devinfo.target_mask) != 0)
+			tinfo->user.ppr_options |= MSG_EXT_PPR_RD_STRM;
+	}
+}
+
+/*
+ * Determines the queue depth for a given device.
+ */
+static void
+ahd_linux_device_queue_depth(struct ahd_softc *ahd,
+			     struct ahd_linux_device *dev)
+{
+	struct	ahd_devinfo devinfo;
+	u_int	tags;
+
+	ahd_compile_devinfo(&devinfo,
+			    ahd->our_id,
+			    dev->target->target, dev->lun,
+			    dev->target->channel == 0 ? 'A' : 'B',
+			    ROLE_INITIATOR);
+	tags = ahd_linux_user_tagdepth(ahd, &devinfo);
+	if (tags != 0
+	 && dev->scsi_device != NULL
+	 && dev->scsi_device->tagged_supported != 0) {
+
+		ahd_set_tags(ahd, &devinfo, AHD_QUEUE_TAGGED);
+		ahd_print_devinfo(ahd, &devinfo);
+		printf("Tagged Queuing enabled.  Depth %d\n", tags);
+	} else {
+		ahd_set_tags(ahd, &devinfo, AHD_QUEUE_NONE);
+	}
+}
+
+static void
+ahd_linux_run_device_queue(struct ahd_softc *ahd, struct ahd_linux_device *dev)
+{
+	struct	 ahd_cmd *acmd;
+	struct	 scsi_cmnd *cmd;
+	struct	 scb *scb;
+	struct	 hardware_scb *hscb;
+	struct	 ahd_initiator_tinfo *tinfo;
+	struct	 ahd_tmode_tstate *tstate;
+	u_int	 col_idx;
+	uint16_t mask;
+
+	if ((dev->flags & AHD_DEV_ON_RUN_LIST) != 0)
+		panic("running device on run list");
+
+	while ((acmd = TAILQ_FIRST(&dev->busyq)) != NULL
+	    && dev->openings > 0 && dev->qfrozen == 0) {
+
+		/*
+		 * Schedule us to run later.  The only reason we are not
+		 * running is because the whole controller Q is frozen.
+		 */
+		if (ahd->platform_data->qfrozen != 0
+		 && AHD_DV_SIMQ_FROZEN(ahd) == 0) {
+
+			TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq,
+					  dev, links);
+			dev->flags |= AHD_DEV_ON_RUN_LIST;
+			return;
+		}
+
+		cmd = &acmd_scsi_cmd(acmd);
+
+		/*
+		 * Get an scb to use.
+		 */
+		tinfo = ahd_fetch_transinfo(ahd, 'A', ahd->our_id,
+					    cmd->device->id, &tstate);
+		if ((dev->flags & (AHD_DEV_Q_TAGGED|AHD_DEV_Q_BASIC)) == 0
+		 || (tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
+			col_idx = AHD_NEVER_COL_IDX;
+		} else {
+			col_idx = AHD_BUILD_COL_IDX(cmd->device->id,
+						    cmd->device->lun);
+		}
+		if ((scb = ahd_get_scb(ahd, col_idx)) == NULL) {
+			TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq,
+					 dev, links);
+			dev->flags |= AHD_DEV_ON_RUN_LIST;
+			ahd->flags |= AHD_RESOURCE_SHORTAGE;
+			return;
+		}
+		TAILQ_REMOVE(&dev->busyq, acmd, acmd_links.tqe);
+		scb->io_ctx = cmd;
+		scb->platform_data->dev = dev;
+		hscb = scb->hscb;
+		cmd->host_scribble = (char *)scb;
+
+		/*
+		 * Fill out basics of the HSCB.
+		 */
+		hscb->control = 0;
+		hscb->scsiid = BUILD_SCSIID(ahd, cmd);
+		hscb->lun = cmd->device->lun;
+		scb->hscb->task_management = 0;
+		mask = SCB_GET_TARGET_MASK(ahd, scb);
+
+		if ((ahd->user_discenable & mask) != 0)
+			hscb->control |= DISCENB;
+
+	 	if (AHD_DV_CMD(cmd) != 0)
+			scb->flags |= SCB_SILENT;
+
+		if ((tinfo->curr.ppr_options & MSG_EXT_PPR_IU_REQ) != 0)
+			scb->flags |= SCB_PACKETIZED;
+
+		if ((tstate->auto_negotiate & mask) != 0) {
+			scb->flags |= SCB_AUTO_NEGOTIATE;
+			scb->hscb->control |= MK_MESSAGE;
+		}
+
+		if ((dev->flags & (AHD_DEV_Q_TAGGED|AHD_DEV_Q_BASIC)) != 0) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+			int	msg_bytes;
+			uint8_t tag_msgs[2];
+
+			msg_bytes = scsi_populate_tag_msg(cmd, tag_msgs);
+			if (msg_bytes && tag_msgs[0] != MSG_SIMPLE_TASK) {
+				hscb->control |= tag_msgs[0];
+				if (tag_msgs[0] == MSG_ORDERED_TASK)
+					dev->commands_since_idle_or_otag = 0;
+			} else
+#endif
+			if (dev->commands_since_idle_or_otag == AHD_OTAG_THRESH
+			 && (dev->flags & AHD_DEV_Q_TAGGED) != 0) {
+				hscb->control |= MSG_ORDERED_TASK;
+				dev->commands_since_idle_or_otag = 0;
+			} else {
+				hscb->control |= MSG_SIMPLE_TASK;
+			}
+		}
+
+		hscb->cdb_len = cmd->cmd_len;
+		memcpy(hscb->shared_data.idata.cdb, cmd->cmnd, hscb->cdb_len);
+
+		scb->sg_count = 0;
+		ahd_set_residual(scb, 0);
+		ahd_set_sense_residual(scb, 0);
+		if (cmd->use_sg != 0) {
+			void	*sg;
+			struct	 scatterlist *cur_seg;
+			u_int	 nseg;
+			int	 dir;
+
+			cur_seg = (struct scatterlist *)cmd->request_buffer;
+			dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
+			nseg = pci_map_sg(ahd->dev_softc, cur_seg,
+					  cmd->use_sg, dir);
+			scb->platform_data->xfer_len = 0;
+			for (sg = scb->sg_list; nseg > 0; nseg--, cur_seg++) {
+				bus_addr_t addr;
+				bus_size_t len;
+
+				addr = sg_dma_address(cur_seg);
+				len = sg_dma_len(cur_seg);
+				scb->platform_data->xfer_len += len;
+				sg = ahd_sg_setup(ahd, scb, sg, addr, len,
+						  /*last*/nseg == 1);
+			}
+		} else if (cmd->request_bufflen != 0) {
+			void *sg;
+			bus_addr_t addr;
+			int dir;
+
+			sg = scb->sg_list;
+			dir = scsi_to_pci_dma_dir(cmd->sc_data_direction);
+			addr = pci_map_single(ahd->dev_softc,
+					      cmd->request_buffer,
+					      cmd->request_bufflen, dir);
+			scb->platform_data->xfer_len = cmd->request_bufflen;
+			scb->platform_data->buf_busaddr = addr;
+			sg = ahd_sg_setup(ahd, scb, sg, addr,
+					  cmd->request_bufflen, /*last*/TRUE);
+		}
+
+		LIST_INSERT_HEAD(&ahd->pending_scbs, scb, pending_links);
+		dev->openings--;
+		dev->active++;
+		dev->commands_issued++;
+
+		/* Update the error counting bucket and dump if needed */
+		if (dev->target->cmds_since_error) {
+			dev->target->cmds_since_error++;
+			if (dev->target->cmds_since_error >
+			    AHD_LINUX_ERR_THRESH)
+				dev->target->cmds_since_error = 0;
+		}
+
+		if ((dev->flags & AHD_DEV_PERIODIC_OTAG) != 0)
+			dev->commands_since_idle_or_otag++;
+		scb->flags |= SCB_ACTIVE;
+		ahd_queue_scb(ahd, scb);
+	}
+}
+
+/*
+ * SCSI controller interrupt handler.
+ */
+irqreturn_t
+ahd_linux_isr(int irq, void *dev_id, struct pt_regs * regs)
+{
+	struct	ahd_softc *ahd;
+	u_long	flags;
+	int	ours;
+
+	ahd = (struct ahd_softc *) dev_id;
+	ahd_lock(ahd, &flags); 
+	ours = ahd_intr(ahd);
+	if (ahd_linux_next_device_to_run(ahd) != NULL)
+		ahd_schedule_runq(ahd);
+	ahd_linux_run_complete_queue(ahd);
+	ahd_unlock(ahd, &flags);
+	return IRQ_RETVAL(ours);
+}
+
+void
+ahd_platform_flushwork(struct ahd_softc *ahd)
+{
+
+	while (ahd_linux_run_complete_queue(ahd) != NULL)
+		;
+}
+
+static struct ahd_linux_target*
+ahd_linux_alloc_target(struct ahd_softc *ahd, u_int channel, u_int target)
+{
+	struct ahd_linux_target *targ;
+
+	targ = malloc(sizeof(*targ), M_DEVBUF, M_NOWAIT);
+	if (targ == NULL)
+		return (NULL);
+	memset(targ, 0, sizeof(*targ));
+	targ->channel = channel;
+	targ->target = target;
+	targ->ahd = ahd;
+	targ->flags = AHD_DV_REQUIRED;
+	ahd->platform_data->targets[target] = targ;
+	return (targ);
+}
+
+static void
+ahd_linux_free_target(struct ahd_softc *ahd, struct ahd_linux_target *targ)
+{
+	struct ahd_devinfo devinfo;
+	struct ahd_initiator_tinfo *tinfo;
+	struct ahd_tmode_tstate *tstate;
+	u_int our_id;
+	u_int target_offset;
+	char channel;
+
+	/*
+	 * Force a negotiation to async/narrow on any
+	 * future command to this device unless a bus
+	 * reset occurs between now and that command.
+	 */
+	channel = 'A' + targ->channel;
+	our_id = ahd->our_id;
+	target_offset = targ->target;
+	tinfo = ahd_fetch_transinfo(ahd, channel, our_id,
+				    targ->target, &tstate);
+	ahd_compile_devinfo(&devinfo, our_id, targ->target, CAM_LUN_WILDCARD,
+			    channel, ROLE_INITIATOR);
+	ahd_set_syncrate(ahd, &devinfo, 0, 0, 0,
+			 AHD_TRANS_GOAL, /*paused*/FALSE);
+	ahd_set_width(ahd, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+		      AHD_TRANS_GOAL, /*paused*/FALSE);
+	ahd_update_neg_request(ahd, &devinfo, tstate, tinfo, AHD_NEG_ALWAYS);
+ 	ahd->platform_data->targets[target_offset] = NULL;
+	if (targ->inq_data != NULL)
+		free(targ->inq_data, M_DEVBUF);
+	if (targ->dv_buffer != NULL)
+		free(targ->dv_buffer, M_DEVBUF);
+	if (targ->dv_buffer1 != NULL)
+		free(targ->dv_buffer1, M_DEVBUF);
+	free(targ, M_DEVBUF);
+}
+
+static struct ahd_linux_device*
+ahd_linux_alloc_device(struct ahd_softc *ahd,
+		 struct ahd_linux_target *targ, u_int lun)
+{
+	struct ahd_linux_device *dev;
+
+	dev = malloc(sizeof(*dev), M_DEVBUG, M_NOWAIT);
+	if (dev == NULL)
+		return (NULL);
+	memset(dev, 0, sizeof(*dev));
+	init_timer(&dev->timer);
+	TAILQ_INIT(&dev->busyq);
+	dev->flags = AHD_DEV_UNCONFIGURED;
+	dev->lun = lun;
+	dev->target = targ;
+
+	/*
+	 * We start out life using untagged
+	 * transactions of which we allow one.
+	 */
+	dev->openings = 1;
+
+	/*
+	 * Set maxtags to 0.  This will be changed if we
+	 * later determine that we are dealing with
+	 * a tagged queuing capable device.
+	 */
+	dev->maxtags = 0;
+	
+	targ->refcount++;
+	targ->devices[lun] = dev;
+	return (dev);
+}
+
+static void
+ahd_linux_free_device(struct ahd_softc *ahd, struct ahd_linux_device *dev)
+{
+	struct ahd_linux_target *targ;
+
+	del_timer(&dev->timer);
+	targ = dev->target;
+	targ->devices[dev->lun] = NULL;
+	free(dev, M_DEVBUF);
+	targ->refcount--;
+	if (targ->refcount == 0
+	 && (targ->flags & AHD_DV_REQUIRED) == 0)
+		ahd_linux_free_target(ahd, targ);
+}
+
+void
+ahd_send_async(struct ahd_softc *ahd, char channel,
+	       u_int target, u_int lun, ac_code code, void *arg)
+{
+	switch (code) {
+	case AC_TRANSFER_NEG:
+	{
+		char	buf[80];
+		struct	ahd_linux_target *targ;
+		struct	info_str info;
+		struct	ahd_initiator_tinfo *tinfo;
+		struct	ahd_tmode_tstate *tstate;
+
+		info.buffer = buf;
+		info.length = sizeof(buf);
+		info.offset = 0;
+		info.pos = 0;
+		tinfo = ahd_fetch_transinfo(ahd, channel, ahd->our_id,
+					    target, &tstate);
+
+		/*
+		 * Don't bother reporting results while
+		 * negotiations are still pending.
+		 */
+		if (tinfo->curr.period != tinfo->goal.period
+		 || tinfo->curr.width != tinfo->goal.width
+		 || tinfo->curr.offset != tinfo->goal.offset
+		 || tinfo->curr.ppr_options != tinfo->goal.ppr_options)
+			if (bootverbose == 0)
+				break;
+
+		/*
+		 * Don't bother reporting results that
+		 * are identical to those last reported.
+		 */
+		targ = ahd->platform_data->targets[target];
+		if (targ == NULL)
+			break;
+		if (tinfo->curr.period == targ->last_tinfo.period
+		 && tinfo->curr.width == targ->last_tinfo.width
+		 && tinfo->curr.offset == targ->last_tinfo.offset
+		 && tinfo->curr.ppr_options == targ->last_tinfo.ppr_options)
+			if (bootverbose == 0)
+				break;
+
+		targ->last_tinfo.period = tinfo->curr.period;
+		targ->last_tinfo.width = tinfo->curr.width;
+		targ->last_tinfo.offset = tinfo->curr.offset;
+		targ->last_tinfo.ppr_options = tinfo->curr.ppr_options;
+
+		printf("(%s:%c:", ahd_name(ahd), channel);
+		if (target == CAM_TARGET_WILDCARD)
+			printf("*): ");
+		else
+			printf("%d): ", target);
+		ahd_format_transinfo(&info, &tinfo->curr);
+		if (info.pos < info.length)
+			*info.buffer = '\0';
+		else
+			buf[info.length - 1] = '\0';
+		printf("%s", buf);
+		break;
+	}
+        case AC_SENT_BDR:
+	{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+		WARN_ON(lun != CAM_LUN_WILDCARD);
+		scsi_report_device_reset(ahd->platform_data->host,
+					 channel - 'A', target);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+		Scsi_Device *scsi_dev;
+
+		/*
+		 * Find the SCSI device associated with this
+		 * request and indicate that a UA is expected.
+		 */
+		for (scsi_dev = ahd->platform_data->host->host_queue;
+		     scsi_dev != NULL; scsi_dev = scsi_dev->next) {
+			if (channel - 'A' == scsi_dev->channel
+			 && target == scsi_dev->id
+			 && (lun == CAM_LUN_WILDCARD
+			  || lun == scsi_dev->lun)) {
+				scsi_dev->was_reset = 1;
+				scsi_dev->expecting_cc_ua = 1;
+			}
+		}
+#endif
+		break;
+	}
+        case AC_BUS_RESET:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+		if (ahd->platform_data->host != NULL) {
+			scsi_report_bus_reset(ahd->platform_data->host,
+					      channel - 'A');
+		}
+#endif
+                break;
+        default:
+                panic("ahd_send_async: Unexpected async event");
+        }
+}
+
+/*
+ * Calls the higher level scsi done function and frees the scb.
+ */
+void
+ahd_done(struct ahd_softc *ahd, struct scb *scb)
+{
+	Scsi_Cmnd *cmd;
+	struct	  ahd_linux_device *dev;
+
+	if ((scb->flags & SCB_ACTIVE) == 0) {
+		printf("SCB %d done'd twice\n", SCB_GET_TAG(scb));
+		ahd_dump_card_state(ahd);
+		panic("Stopping for safety");
+	}
+	LIST_REMOVE(scb, pending_links);
+	cmd = scb->io_ctx;
+	dev = scb->platform_data->dev;
+	dev->active--;
+	dev->openings++;
+	if ((cmd->result & (CAM_DEV_QFRZN << 16)) != 0) {
+		cmd->result &= ~(CAM_DEV_QFRZN << 16);
+		dev->qfrozen--;
+	}
+	ahd_linux_unmap_scb(ahd, scb);
+
+	/*
+	 * Guard against stale sense data.
+	 * The Linux mid-layer assumes that sense
+	 * was retrieved anytime the first byte of
+	 * the sense buffer looks "sane".
+	 */
+	cmd->sense_buffer[0] = 0;
+	if (ahd_get_transaction_status(scb) == CAM_REQ_INPROG) {
+		uint32_t amount_xferred;
+
+		amount_xferred =
+		    ahd_get_transfer_length(scb) - ahd_get_residual(scb);
+		if ((scb->flags & SCB_TRANSMISSION_ERROR) != 0) {
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_MISC) != 0) {
+				ahd_print_path(ahd, scb);
+				printf("Set CAM_UNCOR_PARITY\n");
+			}
+#endif
+			ahd_set_transaction_status(scb, CAM_UNCOR_PARITY);
+		} else if (amount_xferred < scb->io_ctx->underflow) {
+			u_int i;
+
+			ahd_print_path(ahd, scb);
+			printf("CDB:");
+			for (i = 0; i < scb->io_ctx->cmd_len; i++)
+				printf(" 0x%x", scb->io_ctx->cmnd[i]);
+			printf("\n");
+			ahd_print_path(ahd, scb);
+			printf("Saw underflow (%ld of %ld bytes). "
+			       "Treated as error\n",
+				ahd_get_residual(scb),
+				ahd_get_transfer_length(scb));
+			ahd_set_transaction_status(scb, CAM_DATA_RUN_ERR);
+		} else {
+			ahd_set_transaction_status(scb, CAM_REQ_CMP);
+		}
+	} else if (ahd_get_transaction_status(scb) == CAM_SCSI_STATUS_ERROR) {
+		ahd_linux_handle_scsi_status(ahd, dev, scb);
+	} else if (ahd_get_transaction_status(scb) == CAM_SEL_TIMEOUT) {
+		dev->flags |= AHD_DEV_UNCONFIGURED;
+		if (AHD_DV_CMD(cmd) == FALSE)
+			dev->target->flags &= ~AHD_DV_REQUIRED;
+	}
+	/*
+	 * Start DV for devices that require it assuming the first command
+	 * sent does not result in a selection timeout.
+	 */
+	if (ahd_get_transaction_status(scb) != CAM_SEL_TIMEOUT
+	 && (dev->target->flags & AHD_DV_REQUIRED) != 0)
+		ahd_linux_start_dv(ahd);
+
+	if (dev->openings == 1
+	 && ahd_get_transaction_status(scb) == CAM_REQ_CMP
+	 && ahd_get_scsi_status(scb) != SCSI_STATUS_QUEUE_FULL)
+		dev->tag_success_count++;
+	/*
+	 * Some devices deal with temporary internal resource
+	 * shortages by returning queue full.  When the queue
+	 * full occurrs, we throttle back.  Slowly try to get
+	 * back to our previous queue depth.
+	 */
+	if ((dev->openings + dev->active) < dev->maxtags
+	 && dev->tag_success_count > AHD_TAG_SUCCESS_INTERVAL) {
+		dev->tag_success_count = 0;
+		dev->openings++;
+	}
+
+	if (dev->active == 0)
+		dev->commands_since_idle_or_otag = 0;
+
+	if (TAILQ_EMPTY(&dev->busyq)) {
+		if ((dev->flags & AHD_DEV_UNCONFIGURED) != 0
+		 && dev->active == 0
+		 && (dev->flags & AHD_DEV_TIMER_ACTIVE) == 0)
+			ahd_linux_free_device(ahd, dev);
+	} else if ((dev->flags & AHD_DEV_ON_RUN_LIST) == 0) {
+		TAILQ_INSERT_TAIL(&ahd->platform_data->device_runq, dev, links);
+		dev->flags |= AHD_DEV_ON_RUN_LIST;
+	}
+
+	if ((scb->flags & SCB_RECOVERY_SCB) != 0) {
+		printf("Recovery SCB completes\n");
+		if (ahd_get_transaction_status(scb) == CAM_BDR_SENT
+		 || ahd_get_transaction_status(scb) == CAM_REQ_ABORTED)
+			ahd_set_transaction_status(scb, CAM_CMD_TIMEOUT);
+		if ((scb->platform_data->flags & AHD_SCB_UP_EH_SEM) != 0) {
+			scb->platform_data->flags &= ~AHD_SCB_UP_EH_SEM;
+			up(&ahd->platform_data->eh_sem);
+		}
+	}
+
+	ahd_free_scb(ahd, scb);
+	ahd_linux_queue_cmd_complete(ahd, cmd);
+
+	if ((ahd->platform_data->flags & AHD_DV_WAIT_SIMQ_EMPTY) != 0
+	 && LIST_FIRST(&ahd->pending_scbs) == NULL) {
+		ahd->platform_data->flags &= ~AHD_DV_WAIT_SIMQ_EMPTY;
+		up(&ahd->platform_data->dv_sem);
+	}
+}
+
+static void
+ahd_linux_handle_scsi_status(struct ahd_softc *ahd,
+			     struct ahd_linux_device *dev, struct scb *scb)
+{
+	struct	ahd_devinfo devinfo;
+
+	ahd_compile_devinfo(&devinfo,
+			    ahd->our_id,
+			    dev->target->target, dev->lun,
+			    dev->target->channel == 0 ? 'A' : 'B',
+			    ROLE_INITIATOR);
+	
+	/*
+	 * We don't currently trust the mid-layer to
+	 * properly deal with queue full or busy.  So,
+	 * when one occurs, we tell the mid-layer to
+	 * unconditionally requeue the command to us
+	 * so that we can retry it ourselves.  We also
+	 * implement our own throttling mechanism so
+	 * we don't clobber the device with too many
+	 * commands.
+	 */
+	switch (ahd_get_scsi_status(scb)) {
+	default:
+		break;
+	case SCSI_STATUS_CHECK_COND:
+	case SCSI_STATUS_CMD_TERMINATED:
+	{
+		Scsi_Cmnd *cmd;
+
+		/*
+		 * Copy sense information to the OS's cmd
+		 * structure if it is available.
+		 */
+		cmd = scb->io_ctx;
+		if ((scb->flags & (SCB_SENSE|SCB_PKT_SENSE)) != 0) {
+			struct scsi_status_iu_header *siu;
+			u_int sense_size;
+			u_int sense_offset;
+
+			if (scb->flags & SCB_SENSE) {
+				sense_size = MIN(sizeof(struct scsi_sense_data)
+					       - ahd_get_sense_residual(scb),
+						 sizeof(cmd->sense_buffer));
+				sense_offset = 0;
+			} else {
+				/*
+				 * Copy only the sense data into the provided
+				 * buffer.
+				 */
+				siu = (struct scsi_status_iu_header *)
+				    scb->sense_data;
+				sense_size = MIN(scsi_4btoul(siu->sense_length),
+						sizeof(cmd->sense_buffer));
+				sense_offset = SIU_SENSE_OFFSET(siu);
+			}
+
+			memset(cmd->sense_buffer, 0, sizeof(cmd->sense_buffer));
+			memcpy(cmd->sense_buffer,
+			       ahd_get_sense_buf(ahd, scb)
+			       + sense_offset, sense_size);
+			cmd->result |= (DRIVER_SENSE << 24);
+
+#ifdef AHD_DEBUG
+			if (ahd_debug & AHD_SHOW_SENSE) {
+				int i;
+
+				printf("Copied %d bytes of sense data at %d:",
+				       sense_size, sense_offset);
+				for (i = 0; i < sense_size; i++) {
+					if ((i & 0xF) == 0)
+						printf("\n");
+					printf("0x%x ", cmd->sense_buffer[i]);
+				}
+				printf("\n");
+			}
+#endif
+		}
+		break;
+	}
+	case SCSI_STATUS_QUEUE_FULL:
+	{
+		/*
+		 * By the time the core driver has returned this
+		 * command, all other commands that were queued
+		 * to us but not the device have been returned.
+		 * This ensures that dev->active is equal to
+		 * the number of commands actually queued to
+		 * the device.
+		 */
+		dev->tag_success_count = 0;
+		if (dev->active != 0) {
+			/*
+			 * Drop our opening count to the number
+			 * of commands currently outstanding.
+			 */
+			dev->openings = 0;
+#ifdef AHD_DEBUG
+			if ((ahd_debug & AHD_SHOW_QFULL) != 0) {
+				ahd_print_path(ahd, scb);
+				printf("Dropping tag count to %d\n",
+				       dev->active);
+			}
+#endif
+			if (dev->active == dev->tags_on_last_queuefull) {
+
+				dev->last_queuefull_same_count++;
+				/*
+				 * If we repeatedly see a queue full
+				 * at the same queue depth, this
+				 * device has a fixed number of tag
+				 * slots.  Lock in this tag depth
+				 * so we stop seeing queue fulls from
+				 * this device.
+				 */
+				if (dev->last_queuefull_same_count
+				 == AHD_LOCK_TAGS_COUNT) {
+					dev->maxtags = dev->active;
+					ahd_print_path(ahd, scb);
+					printf("Locking max tag count at %d\n",
+					       dev->active);
+				}
+			} else {
+				dev->tags_on_last_queuefull = dev->active;
+				dev->last_queuefull_same_count = 0;
+			}
+			ahd_set_transaction_status(scb, CAM_REQUEUE_REQ);
+			ahd_set_scsi_status(scb, SCSI_STATUS_OK);
+			ahd_platform_set_tags(ahd, &devinfo,
+				     (dev->flags & AHD_DEV_Q_BASIC)
+				   ? AHD_QUEUE_BASIC : AHD_QUEUE_TAGGED);
+			break;
+		}
+		/*
+		 * Drop down to a single opening, and treat this
+		 * as if the target returned BUSY SCSI status.
+		 */
+		dev->openings = 1;
+		ahd_platform_set_tags(ahd, &devinfo,
+			     (dev->flags & AHD_DEV_Q_BASIC)
+			   ? AHD_QUEUE_BASIC : AHD_QUEUE_TAGGED);
+		ahd_set_scsi_status(scb, SCSI_STATUS_BUSY);
+		/* FALLTHROUGH */
+	}
+	case SCSI_STATUS_BUSY:
+		/*
+		 * Set a short timer to defer sending commands for
+		 * a bit since Linux will not delay in this case.
+		 */
+		if ((dev->flags & AHD_DEV_TIMER_ACTIVE) != 0) {
+			printf("%s:%c:%d: Device Timer still active during "
+			       "busy processing\n", ahd_name(ahd),
+				dev->target->channel, dev->target->target);
+			break;
+		}
+		dev->flags |= AHD_DEV_TIMER_ACTIVE;
+		dev->qfrozen++;
+		init_timer(&dev->timer);
+		dev->timer.data = (u_long)dev;
+		dev->timer.expires = jiffies + (HZ/2);
+		dev->timer.function = ahd_linux_dev_timed_unfreeze;
+		add_timer(&dev->timer);
+		break;
+	}
+}
+
+static void
+ahd_linux_queue_cmd_complete(struct ahd_softc *ahd, Scsi_Cmnd *cmd)
+{
+	/*
+	 * Typically, the complete queue has very few entries
+	 * queued to it before the queue is emptied by
+	 * ahd_linux_run_complete_queue, so sorting the entries
+	 * by generation number should be inexpensive.
+	 * We perform the sort so that commands that complete
+	 * with an error are retuned in the order origionally
+	 * queued to the controller so that any subsequent retries
+	 * are performed in order.  The underlying ahd routines do
+	 * not guarantee the order that aborted commands will be
+	 * returned to us.
+	 */
+	struct ahd_completeq *completeq;
+	struct ahd_cmd *list_cmd;
+	struct ahd_cmd *acmd;
+
+	/*
+	 * Map CAM error codes into Linux Error codes.  We
+	 * avoid the conversion so that the DV code has the
+	 * full error information available when making
+	 * state change decisions.
+	 */
+	if (AHD_DV_CMD(cmd) == FALSE) {
+		uint32_t status;
+		u_int new_status;
+
+		status = ahd_cmd_get_transaction_status(cmd);
+		if (status != CAM_REQ_CMP) {
+			struct ahd_linux_device *dev;
+			struct ahd_devinfo devinfo;
+			cam_status cam_status;
+			uint32_t action;
+			u_int scsi_status;
+
+			dev = ahd_linux_get_device(ahd, cmd->device->channel,
+						   cmd->device->id,
+						   cmd->device->lun,
+						   /*alloc*/FALSE);
+
+			if (dev == NULL)
+				goto no_fallback;
+
+			ahd_compile_devinfo(&devinfo,
+					    ahd->our_id,
+					    dev->target->target, dev->lun,
+					    dev->target->channel == 0 ? 'A':'B',
+					    ROLE_INITIATOR);
+
+			scsi_status = ahd_cmd_get_scsi_status(cmd);
+			cam_status = ahd_cmd_get_transaction_status(cmd);
+			action = aic_error_action(cmd, dev->target->inq_data,
+						  cam_status, scsi_status);
+			if ((action & SSQ_FALLBACK) != 0) {
+
+				/* Update stats */
+				dev->target->errors_detected++;
+				if (dev->target->cmds_since_error == 0)
+					dev->target->cmds_since_error++;
+				else {
+					dev->target->cmds_since_error = 0;
+					ahd_linux_fallback(ahd, &devinfo);
+				}
+			}
+		}
+no_fallback:
+		switch (status) {
+		case CAM_REQ_INPROG:
+		case CAM_REQ_CMP:
+		case CAM_SCSI_STATUS_ERROR:
+			new_status = DID_OK;
+			break;
+		case CAM_REQ_ABORTED:
+			new_status = DID_ABORT;
+			break;
+		case CAM_BUSY:
+			new_status = DID_BUS_BUSY;
+			break;
+		case CAM_REQ_INVALID:
+		case CAM_PATH_INVALID:
+			new_status = DID_BAD_TARGET;
+			break;
+		case CAM_SEL_TIMEOUT:
+			new_status = DID_NO_CONNECT;
+			break;
+		case CAM_SCSI_BUS_RESET:
+		case CAM_BDR_SENT:
+			new_status = DID_RESET;
+			break;
+		case CAM_UNCOR_PARITY:
+			new_status = DID_PARITY;
+			break;
+		case CAM_CMD_TIMEOUT:
+			new_status = DID_TIME_OUT;
+			break;
+		case CAM_UA_ABORT:
+		case CAM_REQ_CMP_ERR:
+		case CAM_AUTOSENSE_FAIL:
+		case CAM_NO_HBA:
+		case CAM_DATA_RUN_ERR:
+		case CAM_UNEXP_BUSFREE:
+		case CAM_SEQUENCE_FAIL:
+		case CAM_CCB_LEN_ERR:
+		case CAM_PROVIDE_FAIL:
+		case CAM_REQ_TERMIO:
+		case CAM_UNREC_HBA_ERROR:
+		case CAM_REQ_TOO_BIG:
+			new_status = DID_ERROR;
+			break;
+		case CAM_REQUEUE_REQ:
+			/*
+			 * If we want the request requeued, make sure there
+			 * are sufficent retries.  In the old scsi error code,
+			 * we used to be able to specify a result code that
+			 * bypassed the retry count.  Now we must use this
+			 * hack.  We also "fake" a check condition with
+			 * a sense code of ABORTED COMMAND.  This seems to
+			 * evoke a retry even if this command is being sent
+			 * via the eh thread.  Ick!  Ick!  Ick!
+			 */
+			if (cmd->retries > 0)
+				cmd->retries--;
+			new_status = DID_OK;
+			ahd_cmd_set_scsi_status(cmd, SCSI_STATUS_CHECK_COND);
+			cmd->result |= (DRIVER_SENSE << 24);
+			memset(cmd->sense_buffer, 0,
+			       sizeof(cmd->sense_buffer));
+			cmd->sense_buffer[0] = SSD_ERRCODE_VALID
+					     | SSD_CURRENT_ERROR;
+			cmd->sense_buffer[2] = SSD_KEY_ABORTED_COMMAND;
+			break;
+		default:
+			/* We should never get here */
+			new_status = DID_ERROR;
+			break;
+		}
+
+		ahd_cmd_set_transaction_status(cmd, new_status);
+	}
+
+	completeq = &ahd->platform_data->completeq;
+	list_cmd = TAILQ_FIRST(completeq);
+	acmd = (struct ahd_cmd *)cmd;
+	while (list_cmd != NULL
+	    && acmd_scsi_cmd(list_cmd).serial_number
+	     < acmd_scsi_cmd(acmd).serial_number)
+		list_cmd = TAILQ_NEXT(list_cmd, acmd_links.tqe);
+	if (list_cmd != NULL)
+		TAILQ_INSERT_BEFORE(list_cmd, acmd, acmd_links.tqe);
+	else
+		TAILQ_INSERT_TAIL(completeq, acmd, acmd_links.tqe);
+}
+
+static void
+ahd_linux_filter_inquiry(struct ahd_softc *ahd, struct ahd_devinfo *devinfo)
+{
+	struct	scsi_inquiry_data *sid;
+	struct	ahd_initiator_tinfo *tinfo;
+	struct	ahd_transinfo *user;
+	struct	ahd_transinfo *goal;
+	struct	ahd_transinfo *curr;
+	struct	ahd_tmode_tstate *tstate;
+	struct	ahd_linux_device *dev;
+	u_int	width;
+	u_int	period;
+	u_int	offset;
+	u_int	ppr_options;
+	u_int	trans_version;
+	u_int	prot_version;
+
+	/*
+	 * Determine if this lun actually exists.  If so,
+	 * hold on to its corresponding device structure.
+	 * If not, make sure we release the device and
+	 * don't bother processing the rest of this inquiry
+	 * command.
+	 */
+	dev = ahd_linux_get_device(ahd, devinfo->channel - 'A',
+				   devinfo->target, devinfo->lun,
+				   /*alloc*/TRUE);
+
+	sid = (struct scsi_inquiry_data *)dev->target->inq_data;
+	if (SID_QUAL(sid) == SID_QUAL_LU_CONNECTED) {
+
+		dev->flags &= ~AHD_DEV_UNCONFIGURED;
+	} else {
+		dev->flags |= AHD_DEV_UNCONFIGURED;
+		return;
+	}
+
+	/*
+	 * Update our notion of this device's transfer
+	 * negotiation capabilities.
+	 */
+	tinfo = ahd_fetch_transinfo(ahd, devinfo->channel,
+				    devinfo->our_scsiid,
+				    devinfo->target, &tstate);
+	user = &tinfo->user;
+	goal = &tinfo->goal;
+	curr = &tinfo->curr;
+	width = user->width;
+	period = user->period;
+	offset = user->offset;
+	ppr_options = user->ppr_options;
+	trans_version = user->transport_version;
+	prot_version = MIN(user->protocol_version, SID_ANSI_REV(sid));
+
+	/*
+	 * Only attempt SPI3/4 once we've verified that
+	 * the device claims to support SPI3/4 features.
+	 */
+	if (prot_version < SCSI_REV_2)
+		trans_version = SID_ANSI_REV(sid);
+	else
+		trans_version = SCSI_REV_2;
+
+	if ((sid->flags & SID_WBus16) == 0)
+		width = MSG_EXT_WDTR_BUS_8_BIT;
+	if ((sid->flags & SID_Sync) == 0) {
+		period = 0;
+		offset = 0;
+		ppr_options = 0;
+	}
+	if ((sid->spi3data & SID_SPI_QAS) == 0)
+		ppr_options &= ~MSG_EXT_PPR_QAS_REQ;
+	if ((sid->spi3data & SID_SPI_CLOCK_DT) == 0)
+		ppr_options &= MSG_EXT_PPR_QAS_REQ;
+	if ((sid->spi3data & SID_SPI_IUS) == 0)
+		ppr_options &= (MSG_EXT_PPR_DT_REQ
+			      | MSG_EXT_PPR_QAS_REQ);
+
+	if (prot_version > SCSI_REV_2
+	 && ppr_options != 0)
+		trans_version = user->transport_version;
+
+	ahd_validate_width(ahd, /*tinfo limit*/NULL, &width, ROLE_UNKNOWN);
+	ahd_find_syncrate(ahd, &period, &ppr_options, AHD_SYNCRATE_MAX);
+	ahd_validate_offset(ahd, /*tinfo limit*/NULL, period,
+			    &offset, width, ROLE_UNKNOWN);
+	if (offset == 0 || period == 0) {
+		period = 0;
+		offset = 0;
+		ppr_options = 0;
+	}
+	/* Apply our filtered user settings. */
+	curr->transport_version = trans_version;
+	curr->protocol_version = prot_version;
+	ahd_set_width(ahd, devinfo, width, AHD_TRANS_GOAL, /*paused*/FALSE);
+	ahd_set_syncrate(ahd, devinfo, period, offset, ppr_options,
+			 AHD_TRANS_GOAL, /*paused*/FALSE);
+}
+
+void
+ahd_freeze_simq(struct ahd_softc *ahd)
+{
+	ahd->platform_data->qfrozen++;
+	if (ahd->platform_data->qfrozen == 1) {
+		scsi_block_requests(ahd->platform_data->host);
+		ahd_platform_abort_scbs(ahd, CAM_TARGET_WILDCARD, ALL_CHANNELS,
+					CAM_LUN_WILDCARD, SCB_LIST_NULL,
+					ROLE_INITIATOR, CAM_REQUEUE_REQ);
+	}
+}
+
+void
+ahd_release_simq(struct ahd_softc *ahd)
+{
+	u_long s;
+	int    unblock_reqs;
+
+	unblock_reqs = 0;
+	ahd_lock(ahd, &s);
+	if (ahd->platform_data->qfrozen > 0)
+		ahd->platform_data->qfrozen--;
+	if (ahd->platform_data->qfrozen == 0) {
+		unblock_reqs = 1;
+	}
+	if (AHD_DV_SIMQ_FROZEN(ahd)
+	 && ((ahd->platform_data->flags & AHD_DV_WAIT_SIMQ_RELEASE) != 0)) {
+		ahd->platform_data->flags &= ~AHD_DV_WAIT_SIMQ_RELEASE;
+		up(&ahd->platform_data->dv_sem);
+	}
+	ahd_schedule_runq(ahd);
+	ahd_unlock(ahd, &s);
+	/*
+	 * There is still a race here.  The mid-layer
+	 * should keep its own freeze count and use
+	 * a bottom half handler to run the queues
+	 * so we can unblock with our own lock held.
+	 */
+	if (unblock_reqs)
+		scsi_unblock_requests(ahd->platform_data->host);
+}
+
+static void
+ahd_linux_sem_timeout(u_long arg)
+{
+	struct	scb *scb;
+	struct	ahd_softc *ahd;
+	u_long	s;
+
+	scb = (struct scb *)arg;
+	ahd = scb->ahd_softc;
+	ahd_lock(ahd, &s);
+	if ((scb->platform_data->flags & AHD_SCB_UP_EH_SEM) != 0) {
+		scb->platform_data->flags &= ~AHD_SCB_UP_EH_SEM;
+		up(&ahd->platform_data->eh_sem);
+	}
+	ahd_unlock(ahd, &s);
+}
+
+static void
+ahd_linux_dev_timed_unfreeze(u_long arg)
+{
+	struct ahd_linux_device *dev;
+	struct ahd_softc *ahd;
+	u_long s;
+
+	dev = (struct ahd_linux_device *)arg;
+	ahd = dev->target->ahd;
+	ahd_lock(ahd, &s);
+	dev->flags &= ~AHD_DEV_TIMER_ACTIVE;
+	if (dev->qfrozen > 0)
+		dev->qfrozen--;
+	if (dev->qfrozen == 0
+	 && (dev->flags & AHD_DEV_ON_RUN_LIST) == 0)
+		ahd_linux_run_device_queue(ahd, dev);
+	if ((dev->flags & AHD_DEV_UNCONFIGURED) != 0
+	 && dev->active == 0)
+		ahd_linux_free_device(ahd, dev);
+	ahd_unlock(ahd, &s);
+}
+
+void
+ahd_platform_dump_card_state(struct ahd_softc *ahd)
+{
+	struct ahd_linux_device *dev;
+	int target;
+	int maxtarget;
+	int lun;
+	int i;
+
+	maxtarget = (ahd->features & AHD_WIDE) ? 15 : 7;
+	for (target = 0; target <=maxtarget; target++) {
+
+		for (lun = 0; lun < AHD_NUM_LUNS; lun++) {
+			struct ahd_cmd *acmd;
+
+			dev = ahd_linux_get_device(ahd, 0, target,
+						   lun, /*alloc*/FALSE);
+			if (dev == NULL)
+				continue;
+
+			printf("DevQ(%d:%d:%d): ", 0, target, lun);
+			i = 0;
+			TAILQ_FOREACH(acmd, &dev->busyq, acmd_links.tqe) {
+				if (i++ > AHD_SCB_MAX)
+					break;
+			}
+			printf("%d waiting\n", i);
+		}
+	}
+}
+
+static int __init
+ahd_linux_init(void)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+       return (ahd_linux_detect(&aic79xx_driver_template) ? 0 : -ENODEV);
+#else
+	scsi_register_module(MODULE_SCSI_HA, &aic79xx_driver_template);
+	if (aic79xx_driver_template.present == 0) {
+		scsi_unregister_module(MODULE_SCSI_HA,
+				       &aic79xx_driver_template);
+		return (-ENODEV);
+	}
+
+	return (0);
+#endif
+}
+
+static void __exit
+ahd_linux_exit(void)
+{
+	struct ahd_softc *ahd;
+	u_long l;
+
+	/*
+	 * Shutdown DV threads before going into the SCSI mid-layer.
+	 * This avoids situations where the mid-layer locks the entire
+	 * kernel so that waiting for our DV threads to exit leads
+	 * to deadlock.
+	 */
+	ahd_list_lock(&l);
+	TAILQ_FOREACH(ahd, &ahd_tailq, links) {
+
+		ahd_linux_kill_dv_thread(ahd);
+	}
+	ahd_list_unlock(&l);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	/*
+	 * In 2.4 we have to unregister from the PCI core _after_
+	 * unregistering from the scsi midlayer to avoid dangling
+	 * references.
+	 */
+	scsi_unregister_module(MODULE_SCSI_HA, &aic79xx_driver_template);
+#endif
+	ahd_linux_pci_exit();
+}
+
+module_init(ahd_linux_init);
+module_exit(ahd_linux_exit);
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic79xx_osm.h linux-5730/drivers/scsi/aic7xxx/aic79xx_osm.h
--- linux-5720/drivers/scsi/aic7xxx/aic79xx_osm.h
+++ linux-5730/drivers/scsi/aic7xxx/aic79xx_osm.h
@@ -0,0 +1,1236 @@
+/*
+ * Adaptec AIC79xx device driver for Linux.
+ *
+ * Copyright (c) 2000-2001 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm.h#135 $
+ *
+ */
+#ifndef _AIC79XX_LINUX_H_
+#define _AIC79XX_LINUX_H_
+
+#include <linux/types.h>
+#include <linux/blk.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#include <linux/smp_lock.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <asm/byteorder.h>
+#include <asm/io.h>
+
+#ifndef KERNEL_VERSION
+#define KERNEL_VERSION(x,y,z) (((x)<<16)+((y)<<8)+(z))
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+#include <linux/interrupt.h> /* For tasklet support. */
+#include <linux/config.h>
+#include <linux/slab.h>
+#else
+#include <linux/malloc.h>
+#endif
+
+/* Core SCSI definitions */
+#define AIC_LIB_PREFIX ahd
+#include "scsi.h"
+#include "hosts.h"
+
+/* Name space conflict with BSD queue macros */
+#ifdef LIST_HEAD
+#undef LIST_HEAD
+#endif
+
+#include "cam.h"
+#include "queue.h"
+#include "scsi_message.h"
+#include "scsi_iu.h"
+#include "aiclib.h"
+
+/*********************************** Debugging ********************************/
+#ifdef CONFIG_AIC79XX_DEBUG_ENABLE
+#ifdef CONFIG_AIC79XX_DEBUG_MASK
+#define AHD_DEBUG 1
+#define AHD_DEBUG_OPTS CONFIG_AIC79XX_DEBUG_MASK
+#else
+/*
+ * Compile in debugging code, but do not enable any printfs.
+ */
+#define AHD_DEBUG 1
+#define AHD_DEBUG_OPTS 0
+#endif
+/* No debugging code. */
+#endif
+
+/********************************** Misc Macros *******************************/
+#define	roundup(x, y)   ((((x)+((y)-1))/(y))*(y))
+#define	powerof2(x)	((((x)-1)&(x))==0)
+
+/************************* Forward Declarations *******************************/
+struct ahd_softc;
+typedef struct pci_dev *ahd_dev_softc_t;
+typedef Scsi_Cmnd      *ahd_io_ctx_t;
+
+/******************************* Byte Order ***********************************/
+#define ahd_htobe16(x)	cpu_to_be16(x)
+#define ahd_htobe32(x)	cpu_to_be32(x)
+#define ahd_htobe64(x)	cpu_to_be64(x)
+#define ahd_htole16(x)	cpu_to_le16(x)
+#define ahd_htole32(x)	cpu_to_le32(x)
+#define ahd_htole64(x)	cpu_to_le64(x)
+
+#define ahd_be16toh(x)	be16_to_cpu(x)
+#define ahd_be32toh(x)	be32_to_cpu(x)
+#define ahd_be64toh(x)	be64_to_cpu(x)
+#define ahd_le16toh(x)	le16_to_cpu(x)
+#define ahd_le32toh(x)	le32_to_cpu(x)
+#define ahd_le64toh(x)	le64_to_cpu(x)
+
+#ifndef LITTLE_ENDIAN
+#define LITTLE_ENDIAN 1234
+#endif
+
+#ifndef BIG_ENDIAN
+#define BIG_ENDIAN 4321
+#endif
+
+#ifndef BYTE_ORDER
+#if defined(__BIG_ENDIAN)
+#define BYTE_ORDER BIG_ENDIAN
+#endif
+#if defined(__LITTLE_ENDIAN)
+#define BYTE_ORDER LITTLE_ENDIAN
+#endif
+#endif /* BYTE_ORDER */
+
+/************************* Configuration Data *********************************/
+extern uint32_t aic79xx_allow_memio;
+extern int aic79xx_detect_complete;
+extern Scsi_Host_Template aic79xx_driver_template;
+
+/***************************** Bus Space/DMA **********************************/
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,2,17)
+typedef dma_addr_t bus_addr_t;
+#else
+typedef uint32_t bus_addr_t;
+#endif
+typedef uint32_t bus_size_t;
+
+typedef enum {
+	BUS_SPACE_MEMIO,
+	BUS_SPACE_PIO
+} bus_space_tag_t;
+
+typedef union {
+	u_long		  ioport;
+	volatile uint8_t *maddr;
+} bus_space_handle_t;
+
+typedef struct bus_dma_segment
+{
+	bus_addr_t	ds_addr;
+	bus_size_t	ds_len;
+} bus_dma_segment_t;
+
+struct ahd_linux_dma_tag
+{
+	bus_size_t	alignment;
+	bus_size_t	boundary;
+	bus_size_t	maxsize;
+};
+typedef struct ahd_linux_dma_tag* bus_dma_tag_t;
+
+struct ahd_linux_dmamap
+{
+	bus_addr_t	bus_addr;
+};
+typedef struct ahd_linux_dmamap* bus_dmamap_t;
+
+typedef int bus_dma_filter_t(void*, bus_addr_t);
+typedef void bus_dmamap_callback_t(void *, bus_dma_segment_t *, int, int);
+
+#define BUS_DMA_WAITOK		0x0
+#define BUS_DMA_NOWAIT		0x1
+#define BUS_DMA_ALLOCNOW	0x2
+#define BUS_DMA_LOAD_SEGS	0x4	/*
+					 * Argument is an S/G list not
+					 * a single buffer.
+					 */
+
+#define BUS_SPACE_MAXADDR	0xFFFFFFFF
+#define BUS_SPACE_MAXADDR_32BIT	0xFFFFFFFF
+#define BUS_SPACE_MAXSIZE_32BIT	0xFFFFFFFF
+
+int	ahd_dma_tag_create(struct ahd_softc *, bus_dma_tag_t /*parent*/,
+			   bus_size_t /*alignment*/, bus_size_t /*boundary*/,
+			   bus_addr_t /*lowaddr*/, bus_addr_t /*highaddr*/,
+			   bus_dma_filter_t*/*filter*/, void */*filterarg*/,
+			   bus_size_t /*maxsize*/, int /*nsegments*/,
+			   bus_size_t /*maxsegsz*/, int /*flags*/,
+			   bus_dma_tag_t */*dma_tagp*/);
+
+void	ahd_dma_tag_destroy(struct ahd_softc *, bus_dma_tag_t /*tag*/);
+
+int	ahd_dmamem_alloc(struct ahd_softc *, bus_dma_tag_t /*dmat*/,
+			 void** /*vaddr*/, int /*flags*/,
+			 bus_dmamap_t* /*mapp*/);
+
+void	ahd_dmamem_free(struct ahd_softc *, bus_dma_tag_t /*dmat*/,
+			void* /*vaddr*/, bus_dmamap_t /*map*/);
+
+void	ahd_dmamap_destroy(struct ahd_softc *, bus_dma_tag_t /*tag*/,
+			   bus_dmamap_t /*map*/);
+
+int	ahd_dmamap_load(struct ahd_softc *ahd, bus_dma_tag_t /*dmat*/,
+			bus_dmamap_t /*map*/, void * /*buf*/,
+			bus_size_t /*buflen*/, bus_dmamap_callback_t *,
+			void */*callback_arg*/, int /*flags*/);
+
+int	ahd_dmamap_unload(struct ahd_softc *, bus_dma_tag_t, bus_dmamap_t);
+
+/*
+ * Operations performed by ahd_dmamap_sync().
+ */
+#define BUS_DMASYNC_PREREAD	0x01	/* pre-read synchronization */
+#define BUS_DMASYNC_POSTREAD	0x02	/* post-read synchronization */
+#define BUS_DMASYNC_PREWRITE	0x04	/* pre-write synchronization */
+#define BUS_DMASYNC_POSTWRITE	0x08	/* post-write synchronization */
+
+/*
+ * XXX
+ * ahd_dmamap_sync is only used on buffers allocated with
+ * the pci_alloc_consistent() API.  Although I'm not sure how
+ * this works on architectures with a write buffer, Linux does
+ * not have an API to sync "coherent" memory.  Perhaps we need
+ * to do an mb()?
+ */
+#define ahd_dmamap_sync(ahd, dma_tag, dmamap, offset, len, op)
+
+/************************** Timer DataStructures ******************************/
+typedef struct timer_list ahd_timer_t;
+
+/********************************** Includes **********************************/
+#ifdef CONFIG_AIC79XX_REG_PRETTY_PRINT
+#define AIC_DEBUG_REGISTERS 1
+#else
+#define AIC_DEBUG_REGISTERS 0
+#endif
+#include "aic79xx.h"
+
+/***************************** Timer Facilities *******************************/
+#define ahd_timer_init init_timer
+#define ahd_timer_stop del_timer_sync
+typedef void ahd_linux_callback_t (u_long);  
+static __inline void ahd_timer_reset(ahd_timer_t *timer, u_int usec,
+				     ahd_callback_t *func, void *arg);
+static __inline void ahd_scb_timer_reset(struct scb *scb, u_int usec);
+
+static __inline void
+ahd_timer_reset(ahd_timer_t *timer, u_int usec, ahd_callback_t *func, void *arg)
+{
+	struct ahd_softc *ahd;
+
+	ahd = (struct ahd_softc *)arg;
+	del_timer(timer);
+	timer->data = (u_long)arg;
+	timer->expires = jiffies + (usec * HZ)/1000000;
+	timer->function = (ahd_linux_callback_t*)func;
+	add_timer(timer);
+}
+
+static __inline void
+ahd_scb_timer_reset(struct scb *scb, u_int usec)
+{
+	mod_timer(&scb->io_ctx->eh_timeout, jiffies + (usec * HZ)/1000000);
+}
+
+/***************************** SMP support ************************************/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,17)
+#include <linux/spinlock.h>
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,93)
+#include <linux/smp.h>
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) || defined(SCSI_HAS_HOST_LOCK))
+#define AHD_SCSI_HAS_HOST_LOCK 1
+#else
+#define AHD_SCSI_HAS_HOST_LOCK 0
+#endif
+
+#define AIC79XX_DRIVER_VERSION "1.3.10-RH1"
+
+/**************************** Front End Queues ********************************/
+/*
+ * Data structure used to cast the Linux struct scsi_cmnd to something
+ * that allows us to use the queue macros.  The linux structure has
+ * plenty of space to hold the links fields as required by the queue
+ * macros, but the queue macors require them to have the correct type.
+ */
+struct ahd_cmd_internal {
+	/* Area owned by the Linux scsi layer. */
+	uint8_t	private[offsetof(struct scsi_cmnd, SCp.Status)];
+	union {
+		STAILQ_ENTRY(ahd_cmd)	ste;
+		LIST_ENTRY(ahd_cmd)	le;
+		TAILQ_ENTRY(ahd_cmd)	tqe;
+	} links;
+	uint32_t			end;
+};
+
+struct ahd_cmd {
+	union {
+		struct ahd_cmd_internal	icmd;
+		struct scsi_cmnd	scsi_cmd;
+	} un;
+};
+
+#define acmd_icmd(cmd) ((cmd)->un.icmd)
+#define acmd_scsi_cmd(cmd) ((cmd)->un.scsi_cmd)
+#define acmd_links un.icmd.links
+
+/*************************** Device Data Structures ***************************/
+/*
+ * A per probed device structure used to deal with some error recovery
+ * scenarios that the Linux mid-layer code just doesn't know how to
+ * handle.  The structure allocated for a device only becomes persistent
+ * after a successfully completed inquiry command to the target when
+ * that inquiry data indicates a lun is present.
+ */
+TAILQ_HEAD(ahd_busyq, ahd_cmd);
+typedef enum {
+	AHD_DEV_UNCONFIGURED	 = 0x01,
+	AHD_DEV_FREEZE_TIL_EMPTY = 0x02, /* Freeze queue until active == 0 */
+	AHD_DEV_TIMER_ACTIVE	 = 0x04, /* Our timer is active */
+	AHD_DEV_ON_RUN_LIST	 = 0x08, /* Queued to be run later */
+	AHD_DEV_Q_BASIC		 = 0x10, /* Allow basic device queuing */
+	AHD_DEV_Q_TAGGED	 = 0x20, /* Allow full SCSI2 command queueing */
+	AHD_DEV_PERIODIC_OTAG	 = 0x40, /* Send OTAG to prevent starvation */
+	AHD_DEV_SLAVE_CONFIGURED = 0x80	 /* slave_configure() has been called */
+} ahd_linux_dev_flags;
+
+struct ahd_linux_target;
+struct ahd_linux_device {
+	TAILQ_ENTRY(ahd_linux_device) links;
+	struct			ahd_busyq busyq;
+
+	/*
+	 * The number of transactions currently
+	 * queued to the device.
+	 */
+	int			active;
+
+	/*
+	 * The currently allowed number of 
+	 * transactions that can be queued to
+	 * the device.  Must be signed for
+	 * conversion from tagged to untagged
+	 * mode where the device may have more
+	 * than one outstanding active transaction.
+	 */
+	int			openings;
+
+	/*
+	 * A positive count indicates that this
+	 * device's queue is halted.
+	 */
+	u_int			qfrozen;
+	
+	/*
+	 * Cumulative command counter.
+	 */
+	u_long			commands_issued;
+
+	/*
+	 * The number of tagged transactions when
+	 * running at our current opening level
+	 * that have been successfully received by
+	 * this device since the last QUEUE FULL.
+	 */
+	u_int			tag_success_count;
+#define AHD_TAG_SUCCESS_INTERVAL 50
+
+	ahd_linux_dev_flags	flags;
+
+	/*
+	 * Per device timer.
+	 */
+	struct timer_list	timer;
+
+	/*
+	 * The high limit for the tags variable.
+	 */
+	u_int			maxtags;
+
+	/*
+	 * The computed number of tags outstanding
+	 * at the time of the last QUEUE FULL event.
+	 */
+	u_int			tags_on_last_queuefull;
+
+	/*
+	 * How many times we have seen a queue full
+	 * with the same number of tags.  This is used
+	 * to stop our adaptive queue depth algorithm
+	 * on devices with a fixed number of tags.
+	 */
+	u_int			last_queuefull_same_count;
+#define AHD_LOCK_TAGS_COUNT 50
+
+	/*
+	 * How many transactions have been queued
+	 * without the device going idle.  We use
+	 * this statistic to determine when to issue
+	 * an ordered tag to prevent transaction
+	 * starvation.  This statistic is only updated
+	 * if the AHD_DEV_PERIODIC_OTAG flag is set
+	 * on this device.
+	 */
+	u_int			commands_since_idle_or_otag;
+#define AHD_OTAG_THRESH	500
+
+	int			lun;
+	Scsi_Device	       *scsi_device;
+	struct			ahd_linux_target *target;
+};
+
+typedef enum {
+	AHD_DV_REQUIRED		 = 0x01,
+	AHD_INQ_VALID		 = 0x02,
+	AHD_BASIC_DV		 = 0x04,
+	AHD_ENHANCED_DV		 = 0x08
+} ahd_linux_targ_flags;
+
+/* DV States */
+typedef enum {
+	AHD_DV_STATE_EXIT = 0,
+	AHD_DV_STATE_INQ_SHORT_ASYNC,
+	AHD_DV_STATE_INQ_ASYNC,
+	AHD_DV_STATE_INQ_ASYNC_VERIFY,
+	AHD_DV_STATE_TUR,
+	AHD_DV_STATE_REBD,
+	AHD_DV_STATE_INQ_VERIFY,
+	AHD_DV_STATE_WEB,
+	AHD_DV_STATE_REB,
+	AHD_DV_STATE_SU,
+	AHD_DV_STATE_BUSY
+} ahd_dv_state;
+
+struct ahd_linux_target {
+	struct ahd_linux_device	 *devices[AHD_NUM_LUNS];
+	int			  channel;
+	int			  target;
+	int			  refcount;
+	struct ahd_transinfo	  last_tinfo;
+	struct ahd_softc	 *ahd;
+	ahd_linux_targ_flags	  flags;
+	struct scsi_inquiry_data *inq_data;
+	/*
+	 * The next "fallback" period to use for narrow/wide transfers.
+	 */
+	uint8_t			  dv_next_narrow_period;
+	uint8_t			  dv_next_wide_period;
+	uint8_t			  dv_max_width;
+	uint8_t			  dv_max_ppr_options;
+	uint8_t			  dv_last_ppr_options;
+	u_int			  dv_echo_size;
+	ahd_dv_state		  dv_state;
+	u_int			  dv_state_retry;
+	uint8_t			 *dv_buffer;
+	uint8_t			 *dv_buffer1;
+
+	/*
+	 * Cumulative counter of errors.
+	 */
+	u_long			errors_detected;
+	u_long			cmds_since_error;
+};
+
+/********************* Definitions Required by the Core ***********************/
+/*
+ * Number of SG segments we require.  So long as the S/G segments for
+ * a particular transaction are allocated in a physically contiguous
+ * manner and are allocated below 4GB, the number of S/G segments is
+ * unrestricted.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+/*
+ * We dynamically adjust the number of segments in pre-2.5 kernels to
+ * avoid fragmentation issues in the SCSI mid-layer's private memory
+ * allocator.  See aic79xx_osm.c ahd_linux_size_nseg() for details.
+ */
+extern u_int ahd_linux_nseg;
+#define	AHD_NSEG ahd_linux_nseg
+#define	AHD_LINUX_MIN_NSEG 64
+#else
+#define	AHD_NSEG 128
+#endif
+
+/*
+ * Per-SCB OSM storage.
+ */
+typedef enum {
+	AHD_SCB_UP_EH_SEM = 0x1
+} ahd_linux_scb_flags;
+
+struct scb_platform_data {
+	struct ahd_linux_device	*dev;
+	bus_addr_t		 buf_busaddr;
+	uint32_t		 xfer_len;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
+	uint32_t		 resid;		/* Transfer residual */
+#endif
+	uint32_t		 sense_resid;	/* Auto-Sense residual */
+	ahd_linux_scb_flags	 flags;
+};
+
+/*
+ * Define a structure used for each host adapter.  All members are
+ * aligned on a boundary >= the size of the member to honor the
+ * alignment restrictions of the various platforms supported by
+ * this driver.
+ */
+typedef enum {
+	AHD_DV_WAIT_SIMQ_EMPTY	 = 0x01,
+	AHD_DV_WAIT_SIMQ_RELEASE = 0x02,
+	AHD_DV_ACTIVE		 = 0x04,
+	AHD_DV_SHUTDOWN		 = 0x08,
+	AHD_RUN_CMPLT_Q_TIMER	 = 0x10
+} ahd_linux_softc_flags;
+
+TAILQ_HEAD(ahd_completeq, ahd_cmd);
+
+struct ahd_platform_data {
+	/*
+	 * Fields accessed from interrupt context.
+	 */
+	struct ahd_linux_target *targets[AHD_NUM_TARGETS]; 
+	TAILQ_HEAD(, ahd_linux_device) device_runq;
+	struct ahd_completeq	 completeq;
+
+	spinlock_t		 spin_lock;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	struct tasklet_struct	 runq_tasklet;
+#endif
+	u_int			 qfrozen;
+	pid_t			 dv_pid;
+	struct timer_list	 completeq_timer;
+	struct timer_list	 reset_timer;
+	struct timer_list	 stats_timer;
+	struct semaphore	 eh_sem;
+	struct semaphore	 dv_sem;
+	struct semaphore	 dv_cmd_sem;	/* XXX This needs to be in
+						 * the target struct
+						 */
+	struct scsi_device	*dv_scsi_dev;
+	struct Scsi_Host        *host;		/* pointer to scsi host */
+#define AHD_LINUX_NOIRQ	((uint32_t)~0)
+	uint32_t		 irq;		/* IRQ for this adapter */
+	uint32_t		 bios_address;
+	uint32_t		 mem_busaddr;	/* Mem Base Addr */
+	bus_addr_t		 hw_dma_mask;
+	ahd_linux_softc_flags	 flags;
+};
+
+/************************** OS Utility Wrappers *******************************/
+#define printf printk
+#define M_NOWAIT GFP_ATOMIC
+#define M_WAITOK 0
+#define malloc(size, type, flags) kmalloc(size, flags)
+#define free(ptr, type) kfree(ptr)
+
+static __inline void ahd_delay(long);
+static __inline void
+ahd_delay(long usec)
+{
+	/*
+	 * udelay on Linux can have problems for
+	 * multi-millisecond waits.  Wait at most
+	 * 1024us per call.
+	 */
+	while (usec > 0) {
+		udelay(usec % 1024);
+		usec -= 1024;
+	}
+}
+
+
+/***************************** Low Level I/O **********************************/
+#if defined(__powerpc__) || defined(__i386__) || defined(__ia64__)
+#define MMAPIO
+#endif
+
+static __inline uint8_t ahd_inb(struct ahd_softc * ahd, long port);
+static __inline uint16_t ahd_inw_atomic(struct ahd_softc * ahd, long port);
+static __inline void ahd_outb(struct ahd_softc * ahd, long port, uint8_t val);
+static __inline void ahd_outw_atomic(struct ahd_softc * ahd,
+				     long port, uint16_t val);
+static __inline void ahd_outsb(struct ahd_softc * ahd, long port,
+			       uint8_t *, int count);
+static __inline void ahd_insb(struct ahd_softc * ahd, long port,
+			       uint8_t *, int count);
+
+static __inline uint8_t
+ahd_inb(struct ahd_softc * ahd, long port)
+{
+	uint8_t x;
+#ifdef MMAPIO
+
+	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
+		x = readb(ahd->bshs[0].maddr + port);
+	} else {
+		x = inb(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
+	}
+#else
+	x = inb(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
+#endif
+	mb();
+	return (x);
+}
+
+static __inline uint16_t
+ahd_inw_atomic(struct ahd_softc * ahd, long port)
+{
+	uint8_t x;
+#ifdef MMAPIO
+
+	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
+		x = readw(ahd->bshs[0].maddr + port);
+	} else {
+		x = inw(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
+	}
+#else
+	x = inw(ahd->bshs[(port) >> 8].ioport + ((port) & 0xFF));
+#endif
+	mb();
+	return (x);
+}
+
+static __inline void
+ahd_outb(struct ahd_softc * ahd, long port, uint8_t val)
+{
+#ifdef MMAPIO
+	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
+		writeb(val, ahd->bshs[0].maddr + port);
+	} else {
+		outb(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
+	}
+#else
+	outb(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
+#endif
+	mb();
+}
+
+static __inline void
+ahd_outw_atomic(struct ahd_softc * ahd, long port, uint16_t val)
+{
+#ifdef MMAPIO
+	if (ahd->tags[0] == BUS_SPACE_MEMIO) {
+		writew(val, ahd->bshs[0].maddr + port);
+	} else {
+		outw(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
+	}
+#else
+	outw(val, ahd->bshs[(port) >> 8].ioport + (port & 0xFF));
+#endif
+	mb();
+}
+
+static __inline void
+ahd_outsb(struct ahd_softc * ahd, long port, uint8_t *array, int count)
+{
+	int i;
+
+	/*
+	 * There is probably a more efficient way to do this on Linux
+	 * but we don't use this for anything speed critical and this
+	 * should work.
+	 */
+	for (i = 0; i < count; i++)
+		ahd_outb(ahd, port, *array++);
+}
+
+static __inline void
+ahd_insb(struct ahd_softc * ahd, long port, uint8_t *array, int count)
+{
+	int i;
+
+	/*
+	 * There is probably a more efficient way to do this on Linux
+	 * but we don't use this for anything speed critical and this
+	 * should work.
+	 */
+	for (i = 0; i < count; i++)
+		*array++ = ahd_inb(ahd, port);
+}
+
+/**************************** Initialization **********************************/
+int		ahd_linux_register_host(struct ahd_softc *,
+					Scsi_Host_Template *);
+
+uint64_t	ahd_linux_get_memsize(void);
+
+/*************************** Pretty Printing **********************************/
+struct info_str {
+	char *buffer;
+	int length;
+	off_t offset;
+	int pos;
+};
+
+void	ahd_format_transinfo(struct info_str *info,
+			     struct ahd_transinfo *tinfo);
+
+/******************************** Locking *************************************/
+/* Lock protecting internal data structures */
+static __inline void ahd_lockinit(struct ahd_softc *);
+static __inline void ahd_lock(struct ahd_softc *, unsigned long *flags);
+static __inline void ahd_unlock(struct ahd_softc *, unsigned long *flags);
+
+/* Lock acquisition and release of the above lock in midlayer entry points. */
+static __inline void ahd_midlayer_entrypoint_lock(struct ahd_softc *,
+						  unsigned long *flags);
+static __inline void ahd_midlayer_entrypoint_unlock(struct ahd_softc *,
+						    unsigned long *flags);
+
+/* Lock held during command compeletion to the upper layer */
+static __inline void ahd_done_lockinit(struct ahd_softc *);
+static __inline void ahd_done_lock(struct ahd_softc *, unsigned long *flags);
+static __inline void ahd_done_unlock(struct ahd_softc *, unsigned long *flags);
+
+/* Lock held during ahd_list manipulation and ahd softc frees */
+extern spinlock_t ahd_list_spinlock;
+static __inline void ahd_list_lockinit(void);
+static __inline void ahd_list_lock(unsigned long *flags);
+static __inline void ahd_list_unlock(unsigned long *flags);
+
+static __inline void
+ahd_lockinit(struct ahd_softc *ahd)
+{
+	spin_lock_init(&ahd->platform_data->spin_lock);
+}
+
+static __inline void
+ahd_lock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	spin_lock_irqsave(&ahd->platform_data->spin_lock, *flags);
+}
+
+static __inline void
+ahd_unlock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	spin_unlock_irqrestore(&ahd->platform_data->spin_lock, *flags);
+}
+
+static __inline void
+ahd_midlayer_entrypoint_lock(struct ahd_softc *ahd, unsigned long *flags)
+{
+	/*
+	 * In 2.5.X and some 2.4.X versions, the midlayer takes our
+	 * lock just before calling us, so we avoid locking again.
+	 * For other kernel versions, the io_request_lock is taken
+	 * just before our entry point is called.  In this case, we
+	 * trade the io_request_lock for our per-softc lock.
+	 */
+#if AHD_SCSI_HAS_HOST_LOCK == 0
+	spin_unlock(&io_request_lock);
+	spin_lock(&ahd->platform_data->spin_lock);
+#endif
+}
+
+static __inline void
+ahd_midlayer_entrypoint_unlock(struct ahd_softc *ahd, unsigned long *flags)
+{
+#if AHD_SCSI_HAS_HOST_LOCK == 0
+	spin_unlock(&ahd->platform_data->spin_lock);
+	spin_lock(&io_request_lock);
+#endif
+}
+
+static __inline void
+ahd_done_lockinit(struct ahd_softc *ahd)
+{
+	/*
+	 * In 2.5.X, our own lock is held during completions.
+	 * In previous versions, the io_request_lock is used.
+	 * In either case, we can't initialize this lock again.
+	 */
+}
+
+static __inline void
+ahd_done_lock(struct ahd_softc *ahd, unsigned long *flags)
+{
+#if AHD_SCSI_HAS_HOST_LOCK == 0
+	spin_lock(&io_request_lock);
+#endif
+}
+
+static __inline void
+ahd_done_unlock(struct ahd_softc *ahd, unsigned long *flags)
+{
+#if AHD_SCSI_HAS_HOST_LOCK == 0
+	spin_unlock(&io_request_lock);
+#endif
+}
+
+static __inline void
+ahd_list_lockinit()
+{
+	spin_lock_init(&ahd_list_spinlock);
+}
+
+static __inline void
+ahd_list_lock(unsigned long *flags)
+{
+	spin_lock_irqsave(&ahd_list_spinlock, *flags);
+}
+
+static __inline void
+ahd_list_unlock(unsigned long *flags)
+{
+	spin_unlock_irqrestore(&ahd_list_spinlock, *flags);
+}
+
+/******************************* PCI Definitions ******************************/
+/*
+ * PCIM_xxx: mask to locate subfield in register
+ * PCIR_xxx: config register offset
+ * PCIC_xxx: device class
+ * PCIS_xxx: device subclass
+ * PCIP_xxx: device programming interface
+ * PCIV_xxx: PCI vendor ID (only required to fixup ancient devices)
+ * PCID_xxx: device ID
+ */
+#define PCIR_DEVVENDOR		0x00
+#define PCIR_VENDOR		0x00
+#define PCIR_DEVICE		0x02
+#define PCIR_COMMAND		0x04
+#define PCIM_CMD_PORTEN		0x0001
+#define PCIM_CMD_MEMEN		0x0002
+#define PCIM_CMD_BUSMASTEREN	0x0004
+#define PCIM_CMD_MWRICEN	0x0010
+#define PCIM_CMD_PERRESPEN	0x0040
+#define	PCIM_CMD_SERRESPEN	0x0100
+#define PCIR_STATUS		0x06
+#define PCIR_REVID		0x08
+#define PCIR_PROGIF		0x09
+#define PCIR_SUBCLASS		0x0a
+#define PCIR_CLASS		0x0b
+#define PCIR_CACHELNSZ		0x0c
+#define PCIR_LATTIMER		0x0d
+#define PCIR_HEADERTYPE		0x0e
+#define PCIM_MFDEV		0x80
+#define PCIR_BIST		0x0f
+#define PCIR_CAP_PTR		0x34
+
+/* config registers for header type 0 devices */
+#define PCIR_MAPS	0x10
+#define PCIR_SUBVEND_0	0x2c
+#define PCIR_SUBDEV_0	0x2e
+
+/****************************** PCI-X definitions *****************************/
+#define PCIXR_COMMAND	0x96
+#define PCIXR_DEVADDR	0x98
+#define PCIXM_DEVADDR_FNUM	0x0003	/* Function Number */
+#define PCIXM_DEVADDR_DNUM	0x00F8	/* Device Number */
+#define PCIXM_DEVADDR_BNUM	0xFF00	/* Bus Number */
+#define PCIXR_STATUS	0x9A
+#define PCIXM_STATUS_64BIT	0x0001	/* Active 64bit connection to device. */
+#define PCIXM_STATUS_133CAP	0x0002	/* Device is 133MHz capable */
+#define PCIXM_STATUS_SCDISC	0x0004	/* Split Completion Discarded */
+#define PCIXM_STATUS_UNEXPSC	0x0008	/* Unexpected Split Completion */
+#define PCIXM_STATUS_CMPLEXDEV	0x0010	/* Device Complexity (set == bridge) */
+#define PCIXM_STATUS_MAXMRDBC	0x0060	/* Maximum Burst Read Count */
+#define PCIXM_STATUS_MAXSPLITS	0x0380	/* Maximum Split Transactions */
+#define PCIXM_STATUS_MAXCRDS	0x1C00	/* Maximum Cumulative Read Size */
+#define PCIXM_STATUS_RCVDSCEM	0x2000	/* Received a Split Comp w/Error msg */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+extern struct pci_driver aic79xx_pci_driver;
+#endif
+
+typedef enum
+{
+	AHD_POWER_STATE_D0,
+	AHD_POWER_STATE_D1,
+	AHD_POWER_STATE_D2,
+	AHD_POWER_STATE_D3
+} ahd_power_state;
+
+void ahd_power_state_change(struct ahd_softc *ahd,
+			    ahd_power_state new_state);
+
+/******************************* PCI Routines *********************************/
+int			 ahd_linux_pci_init(void);
+void			 ahd_linux_pci_exit(void);
+int			 ahd_pci_map_registers(struct ahd_softc *ahd);
+int			 ahd_pci_map_int(struct ahd_softc *ahd);
+
+static __inline uint32_t ahd_pci_read_config(ahd_dev_softc_t pci,
+					     int reg, int width);
+
+static __inline uint32_t
+ahd_pci_read_config(ahd_dev_softc_t pci, int reg, int width)
+{
+	switch (width) {
+	case 1:
+	{
+		uint8_t retval;
+
+		pci_read_config_byte(pci, reg, &retval);
+		return (retval);
+	}
+	case 2:
+	{
+		uint16_t retval;
+		pci_read_config_word(pci, reg, &retval);
+		return (retval);
+	}
+	case 4:
+	{
+		uint32_t retval;
+		pci_read_config_dword(pci, reg, &retval);
+		return (retval);
+	}
+	default:
+		panic("ahd_pci_read_config: Read size too big");
+		/* NOTREACHED */
+		return (0);
+	}
+}
+
+static __inline void ahd_pci_write_config(ahd_dev_softc_t pci,
+					  int reg, uint32_t value,
+					  int width);
+
+static __inline void
+ahd_pci_write_config(ahd_dev_softc_t pci, int reg, uint32_t value, int width)
+{
+	switch (width) {
+	case 1:
+		pci_write_config_byte(pci, reg, value);
+		break;
+	case 2:
+		pci_write_config_word(pci, reg, value);
+		break;
+	case 4:
+		pci_write_config_dword(pci, reg, value);
+		break;
+	default:
+		panic("ahd_pci_write_config: Write size too big");
+		/* NOTREACHED */
+	}
+}
+
+static __inline int ahd_get_pci_function(ahd_dev_softc_t);
+static __inline int
+ahd_get_pci_function(ahd_dev_softc_t pci)
+{
+	return (PCI_FUNC(pci->devfn));
+}
+
+static __inline int ahd_get_pci_slot(ahd_dev_softc_t);
+static __inline int
+ahd_get_pci_slot(ahd_dev_softc_t pci)
+{
+	return (PCI_SLOT(pci->devfn));
+}
+
+static __inline int ahd_get_pci_bus(ahd_dev_softc_t);
+static __inline int
+ahd_get_pci_bus(ahd_dev_softc_t pci)
+{
+	return (pci->bus->number);
+}
+
+static __inline void ahd_flush_device_writes(struct ahd_softc *);
+static __inline void
+ahd_flush_device_writes(struct ahd_softc *ahd)
+{
+	/* XXX Is this sufficient for all architectures??? */
+	ahd_inb(ahd, INTSTAT);
+}
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,3,0)
+#define pci_map_sg(pdev, sg_list, nseg, direction) (nseg)
+#define pci_unmap_sg(pdev, sg_list, nseg, direction)
+#define sg_dma_address(sg) (VIRT_TO_BUS((sg)->address))
+#define sg_dma_len(sg) ((sg)->length)
+#define pci_map_single(pdev, buffer, bufflen, direction) \
+	(VIRT_TO_BUS(buffer))
+#define pci_unmap_single(pdev, buffer, buflen, direction)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,3)
+#define ahd_pci_set_dma_mask pci_set_dma_mask
+#else
+/*
+ * Always "return" 0 for success.
+ */
+#define ahd_pci_set_dma_mask(dev_softc, mask)	\
+	(((dev_softc)->dma_mask = mask) && 0)
+#endif
+/**************************** Proc FS Support *********************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+int	ahd_linux_proc_info(char *, char **, off_t, int, int, int);
+#else
+int	ahd_linux_proc_info(struct Scsi_Host *, char *, char **,
+			    off_t, int, int);
+#endif
+
+/*************************** Domain Validation ********************************/
+#define AHD_DV_CMD(cmd) ((cmd)->scsi_done == ahd_linux_dv_complete)
+#define AHD_DV_SIMQ_FROZEN(ahd)					\
+	((((ahd)->platform_data->flags & AHD_DV_ACTIVE) != 0)	\
+	 && (ahd)->platform_data->qfrozen == 1)
+
+/*********************** Transaction Access Wrappers **************************/
+static __inline void ahd_cmd_set_transaction_status(Scsi_Cmnd *, uint32_t);
+static __inline void ahd_set_transaction_status(struct scb *, uint32_t);
+static __inline void ahd_cmd_set_scsi_status(Scsi_Cmnd *, uint32_t);
+static __inline void ahd_set_scsi_status(struct scb *, uint32_t);
+static __inline uint32_t ahd_cmd_get_transaction_status(Scsi_Cmnd *cmd);
+static __inline uint32_t ahd_get_transaction_status(struct scb *);
+static __inline uint32_t ahd_cmd_get_scsi_status(Scsi_Cmnd *cmd);
+static __inline uint32_t ahd_get_scsi_status(struct scb *);
+static __inline void ahd_set_transaction_tag(struct scb *, int, u_int);
+static __inline u_long ahd_get_transfer_length(struct scb *);
+static __inline int ahd_get_transfer_dir(struct scb *);
+static __inline void ahd_set_residual(struct scb *, u_long);
+static __inline void ahd_set_sense_residual(struct scb *scb, u_long resid);
+static __inline u_long ahd_get_residual(struct scb *);
+static __inline u_long ahd_get_sense_residual(struct scb *);
+static __inline int ahd_perform_autosense(struct scb *);
+static __inline uint32_t ahd_get_sense_bufsize(struct ahd_softc *,
+					       struct scb *);
+static __inline void ahd_notify_xfer_settings_change(struct ahd_softc *,
+						     struct ahd_devinfo *);
+static __inline void ahd_platform_scb_free(struct ahd_softc *ahd,
+					   struct scb *scb);
+static __inline void ahd_freeze_scb(struct scb *scb);
+
+static __inline
+void ahd_cmd_set_transaction_status(Scsi_Cmnd *cmd, uint32_t status)
+{
+	cmd->result &= ~(CAM_STATUS_MASK << 16);
+	cmd->result |= status << 16;
+}
+
+static __inline
+void ahd_set_transaction_status(struct scb *scb, uint32_t status)
+{
+	ahd_cmd_set_transaction_status(scb->io_ctx,status);
+}
+
+static __inline
+void ahd_cmd_set_scsi_status(Scsi_Cmnd *cmd, uint32_t status)
+{
+	cmd->result &= ~0xFFFF;
+	cmd->result |= status;
+}
+
+static __inline
+void ahd_set_scsi_status(struct scb *scb, uint32_t status)
+{
+	ahd_cmd_set_scsi_status(scb->io_ctx, status);
+}
+
+static __inline
+uint32_t ahd_cmd_get_transaction_status(Scsi_Cmnd *cmd)
+{
+	return ((cmd->result >> 16) & CAM_STATUS_MASK);
+}
+
+static __inline
+uint32_t ahd_get_transaction_status(struct scb *scb)
+{
+	return (ahd_cmd_get_transaction_status(scb->io_ctx));
+}
+
+static __inline
+uint32_t ahd_cmd_get_scsi_status(Scsi_Cmnd *cmd)
+{
+	return (cmd->result & 0xFFFF);
+}
+
+static __inline
+uint32_t ahd_get_scsi_status(struct scb *scb)
+{
+	return (ahd_cmd_get_scsi_status(scb->io_ctx));
+}
+
+static __inline
+void ahd_set_transaction_tag(struct scb *scb, int enabled, u_int type)
+{
+	/*
+	 * Nothing to do for linux as the incoming transaction
+	 * has no concept of tag/non tagged, etc.
+	 */
+}
+
+static __inline
+u_long ahd_get_transfer_length(struct scb *scb)
+{
+	return (scb->platform_data->xfer_len);
+}
+
+static __inline
+int ahd_get_transfer_dir(struct scb *scb)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,40)
+	return (scb->io_ctx->sc_data_direction);
+#else
+	if (scb->io_ctx->bufflen == 0)
+		return (CAM_DIR_NONE);
+
+	switch(scb->io_ctx->cmnd[0]) {
+	case 0x08:  /* READ(6)  */
+	case 0x28:  /* READ(10) */
+	case 0xA8:  /* READ(12) */
+		return (CAM_DIR_IN);
+        case 0x0A:  /* WRITE(6)  */
+        case 0x2A:  /* WRITE(10) */
+        case 0xAA:  /* WRITE(12) */
+		return (CAM_DIR_OUT);
+        default:
+		return (CAM_DIR_NONE);
+        }
+#endif
+}
+
+static __inline
+void ahd_set_residual(struct scb *scb, u_long resid)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	scb->io_ctx->resid = resid;
+#else
+	scb->platform_data->resid = resid;
+#endif
+}
+
+static __inline
+void ahd_set_sense_residual(struct scb *scb, u_long resid)
+{
+	scb->platform_data->sense_resid = resid;
+}
+
+static __inline
+u_long ahd_get_residual(struct scb *scb)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	return (scb->io_ctx->resid);
+#else
+	return (scb->platform_data->resid);
+#endif
+}
+
+static __inline
+u_long ahd_get_sense_residual(struct scb *scb)
+{
+	return (scb->platform_data->sense_resid);
+}
+
+static __inline
+int ahd_perform_autosense(struct scb *scb)
+{
+	/*
+	 * We always perform autosense in Linux.
+	 * On other platforms this is set on a
+	 * per-transaction basis.
+	 */
+	return (1);
+}
+
+static __inline uint32_t
+ahd_get_sense_bufsize(struct ahd_softc *ahd, struct scb *scb)
+{
+	return (sizeof(struct scsi_sense_data));
+}
+
+static __inline void
+ahd_notify_xfer_settings_change(struct ahd_softc *ahd,
+				struct ahd_devinfo *devinfo)
+{
+	/* Nothing to do here for linux */
+}
+
+static __inline void
+ahd_platform_scb_free(struct ahd_softc *ahd, struct scb *scb)
+{
+	ahd->flags &= ~AHD_RESOURCE_SHORTAGE;
+}
+
+int	ahd_platform_alloc(struct ahd_softc *ahd, void *platform_arg);
+void	ahd_platform_free(struct ahd_softc *ahd);
+void	ahd_platform_init(struct ahd_softc *ahd);
+void	ahd_platform_freeze_devq(struct ahd_softc *ahd, struct scb *scb);
+void	ahd_freeze_simq(struct ahd_softc *ahd);
+void	ahd_release_simq(struct ahd_softc *ahd);
+
+static __inline void
+ahd_freeze_scb(struct scb *scb)
+{
+	if ((scb->io_ctx->result & (CAM_DEV_QFRZN << 16)) == 0) {
+                scb->io_ctx->result |= CAM_DEV_QFRZN << 16;
+                scb->platform_data->dev->qfrozen++;
+        }
+}
+
+void	ahd_platform_set_tags(struct ahd_softc *ahd,
+			      struct ahd_devinfo *devinfo, ahd_queue_alg);
+int	ahd_platform_abort_scbs(struct ahd_softc *ahd, int target,
+				char channel, int lun, u_int tag,
+				role_t role, uint32_t status);
+irqreturn_t
+	ahd_linux_isr(int irq, void *dev_id, struct pt_regs * regs);
+void	ahd_platform_flushwork(struct ahd_softc *ahd);
+int	ahd_softc_comp(struct ahd_softc *, struct ahd_softc *);
+void	ahd_done(struct ahd_softc*, struct scb*);
+void	ahd_send_async(struct ahd_softc *, char channel,
+		       u_int target, u_int lun, ac_code, void *);
+void	ahd_print_path(struct ahd_softc *, struct scb *);
+void	ahd_platform_dump_card_state(struct ahd_softc *ahd);
+
+#ifdef CONFIG_PCI
+#define AHD_PCI_CONFIG 1
+#else
+#define AHD_PCI_CONFIG 0
+#endif
+#define bootverbose aic79xx_verbose
+extern uint32_t aic79xx_verbose;
+#endif /* _AIC79XX_LINUX_H_ */
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic79xx_osm_pci.c linux-5730/drivers/scsi/aic7xxx/aic79xx_osm_pci.c
--- linux-5720/drivers/scsi/aic7xxx/aic79xx_osm_pci.c
+++ linux-5730/drivers/scsi/aic7xxx/aic79xx_osm_pci.c
@@ -0,0 +1,451 @@
+/*
+ * Linux driver attachment glue for PCI based U320 controllers.
+ *
+ * Copyright (c) 2000-2001 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_osm_pci.c#24 $
+ */
+
+#include "aic79xx_osm.h"
+#include "aic79xx_inline.h"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+struct pci_device_id
+{
+};
+#endif
+
+static int	ahd_linux_pci_dev_probe(struct pci_dev *pdev,
+					const struct pci_device_id *ent);
+static int	ahd_linux_pci_reserve_io_regions(struct ahd_softc *ahd,
+						 u_long *base, u_long *base2);
+static int	ahd_linux_pci_reserve_mem_region(struct ahd_softc *ahd,
+						 u_long *bus_addr,
+						 uint8_t **maddr);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+static void	ahd_linux_pci_dev_remove(struct pci_dev *pdev);
+
+/* We do our own ID filtering.  So, grab all SCSI storage class devices. */
+static struct pci_device_id ahd_linux_pci_id_table[] = {
+	{
+		0x9005, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_STORAGE_SCSI << 8, 0xFFFF00, 0
+	},
+	{
+		0x9005, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_STORAGE_RAID << 8, 0xFFFF00, 0
+	},
+	{ 0 }
+};
+
+MODULE_DEVICE_TABLE(pci, ahd_linux_pci_id_table);
+
+struct pci_driver aic79xx_pci_driver = {
+	name:		"aic79xx",
+	probe:		ahd_linux_pci_dev_probe,
+	remove:		ahd_linux_pci_dev_remove,
+	id_table:	ahd_linux_pci_id_table
+};
+
+static void
+ahd_linux_pci_dev_remove(struct pci_dev *pdev)
+{
+	struct ahd_softc *ahd;
+	u_long l;
+
+	/*
+	 * We should be able to just perform
+	 * the free directly, but check our
+	 * list for extra sanity.
+	 */
+	ahd_list_lock(&l);
+	ahd = ahd_find_softc((struct ahd_softc *)pci_get_drvdata(pdev));
+	if (ahd != NULL) {
+		u_long s;
+
+		ahd_lock(ahd, &s);
+		ahd_intr_enable(ahd, FALSE);
+		ahd_unlock(ahd, &s);
+		ahd_free(ahd);
+	}
+	ahd_list_unlock(&l);
+}
+#endif /* !LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0) */
+
+static int
+ahd_linux_pci_dev_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	char		 buf[80];
+	struct		 ahd_softc *ahd;
+	ahd_dev_softc_t	 pci;
+	struct		 ahd_pci_identity *entry;
+	char		*name;
+	int		 error;
+
+	/*
+	 * Some BIOSen report the same device multiple times.
+	 */
+	TAILQ_FOREACH(ahd, &ahd_tailq, links) {
+		struct pci_dev *probed_pdev;
+
+		probed_pdev = ahd->dev_softc;
+		if (probed_pdev->bus->number == pdev->bus->number
+		 && probed_pdev->devfn == pdev->devfn)
+			break;
+	}
+	if (ahd != NULL) {
+		/* Skip duplicate. */
+		return (-ENODEV);
+	}
+
+	pci = pdev;
+	entry = ahd_find_pci_device(pci);
+	if (entry == NULL)
+		return (-ENODEV);
+
+	/*
+	 * Allocate a softc for this card and
+	 * set it up for attachment by our
+	 * common detect routine.
+	 */
+	sprintf(buf, "ahd_pci:%d:%d:%d",
+		ahd_get_pci_bus(pci),
+		ahd_get_pci_slot(pci),
+		ahd_get_pci_function(pci));
+	name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
+	if (name == NULL)
+		return (-ENOMEM);
+	strcpy(name, buf);
+	ahd = ahd_alloc(NULL, name);
+	if (ahd == NULL)
+		return (-ENOMEM);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	if (pci_enable_device(pdev)) {
+		ahd_free(ahd);
+		return (-ENODEV);
+	}
+	pci_set_master(pdev);
+
+	if (sizeof(bus_addr_t) > 4) {
+		uint64_t   memsize;
+		bus_addr_t mask_64bit;
+		bus_addr_t mask_39bit;
+
+		memsize = ahd_linux_get_memsize();
+		mask_64bit = (bus_addr_t)0xFFFFFFFFFFFFFFFFULL;
+		mask_39bit = (bus_addr_t)0x7FFFFFFFFFULL;
+		if (memsize >= 0x8000000000ULL
+	 	 && ahd_pci_set_dma_mask(pdev, mask_64bit) == 0) {
+			ahd->flags |= AHD_64BIT_ADDRESSING;
+			ahd->platform_data->hw_dma_mask = mask_64bit;
+		} else if (memsize > 0x80000000
+			&& ahd_pci_set_dma_mask(pdev, mask_39bit) == 0) {
+			ahd->flags |= AHD_39BIT_ADDRESSING;
+			ahd->platform_data->hw_dma_mask = mask_39bit;
+		}
+	} else {
+		ahd_pci_set_dma_mask(pdev, 0xFFFFFFFF);
+		ahd->platform_data->hw_dma_mask = 0xFFFFFFFF;
+	}
+#endif
+	ahd->dev_softc = pci;
+	error = ahd_pci_config(ahd, entry);
+	if (error != 0) {
+		ahd_free(ahd);
+		return (-error);
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	pci_set_drvdata(pdev, ahd);
+	if (aic79xx_detect_complete) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+		ahd_linux_register_host(ahd, &aic79xx_driver_template);
+#else
+		printf("aic79xx: ignoring PCI device found after "
+		       "initialization\n");
+		return (-ENODEV);
+#endif
+	}
+#endif
+	return (0);
+}
+
+int
+ahd_linux_pci_init(void)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	return (pci_module_init(&aic79xx_pci_driver));
+#else
+	struct pci_dev *pdev;
+	u_int class;
+	int found;
+
+	/* If we don't have a PCI bus, we can't find any adapters. */
+	if (pci_present() == 0)
+		return (0);
+
+	found = 0;
+	pdev = NULL;
+	class = PCI_CLASS_STORAGE_SCSI << 8;
+	while ((pdev = pci_find_class(class, pdev)) != NULL) {
+		ahd_dev_softc_t pci;
+		int error;
+
+		pci = pdev;
+		error = ahd_linux_pci_dev_probe(pdev, /*pci_devid*/NULL);
+		if (error == 0)
+			found++;
+	}
+	return (found);
+#endif
+}
+
+void
+ahd_linux_pci_exit(void)
+{
+	pci_unregister_driver(&aic79xx_pci_driver);
+}
+
+static int
+ahd_linux_pci_reserve_io_regions(struct ahd_softc *ahd, u_long *base,
+				 u_long *base2)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	*base = pci_resource_start(ahd->dev_softc, 0);
+	/*
+	 * This is really the 3rd bar and should be at index 2,
+	 * but the Linux PCI code doesn't know how to "count" 64bit
+	 * bars.
+	 */
+	*base2 = pci_resource_start(ahd->dev_softc, 3);
+#else
+	*base = ahd_pci_read_config(ahd->dev_softc, AHD_PCI_IOADDR0, 4);
+	*base2 = ahd_pci_read_config(ahd->dev_softc, AHD_PCI_IOADDR1, 4);
+	*base &= PCI_BASE_ADDRESS_IO_MASK;
+	*base2 &= PCI_BASE_ADDRESS_IO_MASK;
+#endif
+	if (*base == 0 || *base2 == 0)
+		return (ENOMEM);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
+	if (check_region(*base, 256) != 0
+	 || check_region(*base2, 256) != 0)
+		return (ENOMEM);
+	request_region(*base, 256, "aic79xx");
+	request_region(*base2, 256, "aic79xx");
+#else
+	if (request_region(*base, 256, "aic79xx") == 0)
+		return (ENOMEM);
+	if (request_region(*base2, 256, "aic79xx") == 0) {
+		release_region(*base2, 256);
+		return (ENOMEM);
+	}
+#endif
+	return (0);
+}
+
+static int
+ahd_linux_pci_reserve_mem_region(struct ahd_softc *ahd,
+				 u_long *bus_addr,
+				 uint8_t **maddr)
+{
+	u_long	start;
+	u_long	base_page;
+	u_long	base_offset;
+	int	error;
+
+	if (aic79xx_allow_memio == 0)
+		return (ENOMEM);
+
+	if ((ahd->bugs & AHD_PCIX_MMAPIO_BUG) != 0)
+		return (ENOMEM);
+
+	error = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	start = pci_resource_start(ahd->dev_softc, 1);
+	base_page = start & PAGE_MASK;
+	base_offset = start - base_page;
+#else
+	start = ahd_pci_read_config(ahd->dev_softc, PCIR_MAPS+4, 4);
+	base_offset = start & PCI_BASE_ADDRESS_MEM_MASK;
+	base_page = base_offset & PAGE_MASK;
+	base_offset -= base_page;
+#endif
+	if (start != 0) {
+		*bus_addr = start;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+		if (request_mem_region(start, 0x1000, "aic79xx") == 0)
+			error = ENOMEM;
+#endif
+		if (error == 0) {
+			*maddr = ioremap_nocache(base_page, base_offset + 256);
+			if (*maddr == NULL) {
+				error = ENOMEM;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+				release_mem_region(start, 0x1000);
+#endif
+			} else
+				*maddr += base_offset;
+		}
+	} else
+		error = ENOMEM;
+	return (error);
+}
+
+int
+ahd_pci_map_registers(struct ahd_softc *ahd)
+{
+	uint32_t command;
+	u_long	 base;
+	uint8_t	*maddr;
+	int	 error;
+
+	/*
+	 * If its allowed, we prefer memory mapped access.
+	 */
+	command = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, 4);
+	command &= ~(PCIM_CMD_PORTEN|PCIM_CMD_MEMEN);
+	base = 0;
+	maddr = NULL;
+#ifdef MMAPIO
+	error = ahd_linux_pci_reserve_mem_region(ahd, &base, &maddr);
+	if (error == 0) {
+		ahd->platform_data->mem_busaddr = base;
+		ahd->tags[0] = BUS_SPACE_MEMIO;
+		ahd->bshs[0].maddr = maddr;
+		ahd->tags[1] = BUS_SPACE_MEMIO;
+		ahd->bshs[1].maddr = maddr + 0x100;
+		ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
+				     command | PCIM_CMD_MEMEN, 4);
+
+		if (ahd_pci_test_register_access(ahd) != 0) {
+
+			printf("aic79xx: PCI Device %d:%d:%d "
+			       "failed memory mapped test.  Using PIO.\n",
+			       ahd_get_pci_bus(ahd->dev_softc),
+			       ahd_get_pci_slot(ahd->dev_softc),
+			       ahd_get_pci_function(ahd->dev_softc));
+			iounmap((void *)((u_long)maddr & PAGE_MASK));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+			release_mem_region(ahd->platform_data->mem_busaddr,
+					   0x1000);
+#endif
+			ahd->bshs[0].maddr = NULL;
+			maddr = NULL;
+		} else
+			command |= PCIM_CMD_MEMEN;
+	} else if (bootverbose) {
+		printf("aic79xx: PCI%d:%d:%d MEM region 0x%lx "
+		       "unavailable. Cannot memory map device.\n",
+		       ahd_get_pci_bus(ahd->dev_softc),
+		       ahd_get_pci_slot(ahd->dev_softc),
+		       ahd_get_pci_function(ahd->dev_softc),
+		       base);
+	}
+#endif
+
+	if (maddr == NULL) {
+		u_long	 base2;
+
+		error = ahd_linux_pci_reserve_io_regions(ahd, &base, &base2);
+		if (error == 0) {
+			ahd->tags[0] = BUS_SPACE_PIO;
+			ahd->tags[1] = BUS_SPACE_PIO;
+			ahd->bshs[0].ioport = base;
+			ahd->bshs[1].ioport = base2;
+			command |= PCIM_CMD_PORTEN;
+		} else {
+			printf("aic79xx: PCI%d:%d:%d IO regions 0x%lx and 0x%lx"
+			       "unavailable. Cannot map device.\n",
+			       ahd_get_pci_bus(ahd->dev_softc),
+			       ahd_get_pci_slot(ahd->dev_softc),
+			       ahd_get_pci_function(ahd->dev_softc),
+			       base, base2);
+		}
+	}
+	ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, command, 4);
+	return (error);
+}
+
+int
+ahd_pci_map_int(struct ahd_softc *ahd)
+{
+	int error;
+
+	error = request_irq(ahd->dev_softc->irq, ahd_linux_isr,
+			    SA_SHIRQ, "aic79xx", ahd);
+	if (error == 0)
+		ahd->platform_data->irq = ahd->dev_softc->irq;
+	
+	return (-error);
+}
+
+void
+ahd_power_state_change(struct ahd_softc *ahd, ahd_power_state new_state)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	pci_set_power_state(ahd->dev_softc, new_state);
+#else
+	uint32_t cap;
+	u_int cap_offset;
+
+	/*
+	 * Traverse the capability list looking for
+	 * the power management capability.
+	 */
+	cap = 0;
+	cap_offset = ahd_pci_read_config(ahd->dev_softc,
+					 PCIR_CAP_PTR, /*bytes*/1);
+	while (cap_offset != 0) {
+
+		cap = ahd_pci_read_config(ahd->dev_softc,
+					  cap_offset, /*bytes*/4);
+		if ((cap & 0xFF) == 1
+		 && ((cap >> 16) & 0x3) > 0) {
+			uint32_t pm_control;
+
+			pm_control = ahd_pci_read_config(ahd->dev_softc,
+							 cap_offset + 4,
+							 /*bytes*/4);
+			pm_control &= ~0x3;
+			pm_control |= new_state;
+			ahd_pci_write_config(ahd->dev_softc,
+					     cap_offset + 4,
+					     pm_control, /*bytes*/2);
+			break;
+		}
+		cap_offset = (cap >> 8) & 0xFF;
+	}
+#endif 
+}
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic79xx_pci.c linux-5730/drivers/scsi/aic7xxx/aic79xx_pci.c
--- linux-5720/drivers/scsi/aic7xxx/aic79xx_pci.c
+++ linux-5730/drivers/scsi/aic7xxx/aic79xx_pci.c
@@ -0,0 +1,1014 @@
+/*
+ * Product specific probe and attach routines for:
+ *	aic7901 and aic7902 SCSI controllers
+ *
+ * Copyright (c) 1994-2001 Justin T. Gibbs.
+ * Copyright (c) 2000-2002 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx_pci.c#75 $
+ *
+ * $FreeBSD$
+ */
+
+#ifdef __linux__
+#include "aic79xx_osm.h"
+#include "aic79xx_inline.h"
+#else
+#include <dev/aic7xxx/aic79xx_osm.h>
+#include <dev/aic7xxx/aic79xx_inline.h>
+#endif
+
+static __inline uint64_t
+ahd_compose_id(u_int device, u_int vendor, u_int subdevice, u_int subvendor)
+{
+	uint64_t id;
+
+	id = subvendor
+	   | (subdevice << 16)
+	   | ((uint64_t)vendor << 32)
+	   | ((uint64_t)device << 48);
+
+	return (id);
+}
+
+#define ID_ALL_MASK			0xFFFFFFFFFFFFFFFFull
+#define ID_ALL_IROC_MASK		0xFF7FFFFFFFFFFFFFull
+#define ID_DEV_VENDOR_MASK		0xFFFFFFFF00000000ull
+#define ID_9005_GENERIC_MASK		0xFFF0FFFF00000000ull
+#define ID_9005_GENERIC_IROC_MASK	0xFF70FFFF00000000ull
+
+#define ID_AIC7901			0x800F9005FFFF9005ull
+#define ID_AHA_29320A			0x8000900500609005ull
+#define ID_AHA_29320ALP			0x8017900500449005ull
+
+#define ID_AIC7901A			0x801E9005FFFF9005ull
+#define ID_AHA_29320			0x8012900500429005ull
+#define ID_AHA_29320B			0x8013900500439005ull
+#define ID_AHA_29320LP			0x8014900500449005ull
+
+#define ID_AIC7902			0x801F9005FFFF9005ull
+#define ID_AIC7902_B			0x801D9005FFFF9005ull
+#define ID_AHA_39320			0x8010900500409005ull
+#define ID_AHA_39320_B			0x8015900500409005ull
+#define ID_AHA_39320A			0x8016900500409005ull
+#define ID_AHA_39320D			0x8011900500419005ull
+#define ID_AHA_39320D_B			0x801C900500419005ull
+#define ID_AHA_39320D_HP		0x8011900500AC0E11ull
+#define ID_AHA_39320D_B_HP		0x801C900500AC0E11ull
+#define ID_AIC7902_PCI_REV_A4		0x3
+#define ID_AIC7902_PCI_REV_B0		0x10
+#define SUBID_HP			0x0E11
+
+#define DEVID_9005_HOSTRAID(id) ((id) & 0x80)
+
+#define DEVID_9005_TYPE(id) ((id) & 0xF)
+#define		DEVID_9005_TYPE_HBA		0x0	/* Standard Card */
+#define		DEVID_9005_TYPE_HBA_2EXT	0x1	/* 2 External Ports */
+#define		DEVID_9005_TYPE_IROC		0x8	/* Raid(0,1,10) Card */
+#define		DEVID_9005_TYPE_MB		0xF	/* On Motherboard */
+
+#define DEVID_9005_MFUNC(id) ((id) & 0x10)
+
+#define DEVID_9005_PACKETIZED(id) ((id) & 0x8000)
+
+#define SUBID_9005_TYPE(id) ((id) & 0xF)
+#define		SUBID_9005_TYPE_HBA		0x0	/* Standard Card */
+#define		SUBID_9005_TYPE_MB		0xF	/* On Motherboard */
+
+#define SUBID_9005_AUTOTERM(id)	(((id) & 0x10) == 0)
+
+#define SUBID_9005_LEGACYCONN_FUNC(id) ((id) & 0x20)
+
+#define SUBID_9005_SEEPTYPE(id) ((id) & 0x0C0) >> 6)
+#define		SUBID_9005_SEEPTYPE_NONE	0x0
+#define		SUBID_9005_SEEPTYPE_4K		0x1
+
+static ahd_device_setup_t ahd_aic7901_setup;
+static ahd_device_setup_t ahd_aic7901A_setup;
+static ahd_device_setup_t ahd_aic7902_setup;
+
+struct ahd_pci_identity ahd_pci_ident_table [] =
+{
+	/* aic7901 based controllers */
+	{
+		ID_AHA_29320A,
+		ID_ALL_MASK,
+		"Adaptec 29320A Ultra320 SCSI adapter",
+		ahd_aic7901_setup
+	},
+	{
+		ID_AHA_29320ALP,
+		ID_ALL_MASK,
+		"Adaptec 29320ALP Ultra320 SCSI adapter",
+		ahd_aic7901_setup
+	},
+	/* aic7902 based controllers */	
+	{
+		ID_AHA_29320,
+		ID_ALL_MASK,
+		"Adaptec 29320 Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	},
+	{
+		ID_AHA_29320B,
+		ID_ALL_MASK,
+		"Adaptec 29320B Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	},
+	{
+		ID_AHA_29320LP,
+		ID_ALL_MASK,
+		"Adaptec 29320LP Ultra320 SCSI adapter",
+		ahd_aic7901A_setup
+	},
+	{
+		ID_AHA_39320,
+		ID_ALL_MASK,
+		"Adaptec 39320 Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	},
+	{
+		ID_AHA_39320_B,
+		ID_ALL_MASK,
+		"Adaptec 39320 Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	},
+	{
+		ID_AHA_39320A,
+		ID_ALL_MASK,
+		"Adaptec 39320A Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	},
+	{
+		ID_AHA_39320D,
+		ID_ALL_MASK,
+		"Adaptec 39320D Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	},
+	{
+		ID_AHA_39320D_HP,
+		ID_ALL_MASK,
+		"Adaptec (HP OEM) 39320D Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	},
+	{
+		ID_AHA_39320D_B,
+		ID_ALL_MASK,
+		"Adaptec 39320D Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	},
+	{
+		ID_AHA_39320D_B_HP,
+		ID_ALL_MASK,
+		"Adaptec (HP OEM) 39320D Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	},
+	/* Generic chip probes for devices we don't know 'exactly' */
+	{
+		ID_AIC7901 & ID_9005_GENERIC_MASK,
+		ID_9005_GENERIC_MASK,
+		"Adaptec AIC7901 Ultra320 SCSI adapter",
+		ahd_aic7901_setup
+	},
+	{
+		ID_AIC7901A & ID_DEV_VENDOR_MASK,
+		ID_DEV_VENDOR_MASK,
+		"Adaptec AIC7901A Ultra320 SCSI adapter",
+		ahd_aic7901A_setup
+	},
+	{
+		ID_AIC7902 & ID_9005_GENERIC_MASK,
+		ID_9005_GENERIC_MASK,
+		"Adaptec AIC7902 Ultra320 SCSI adapter",
+		ahd_aic7902_setup
+	}
+};
+
+const u_int ahd_num_pci_devs = NUM_ELEMENTS(ahd_pci_ident_table);
+		
+#define	DEVCONFIG		0x40
+#define		PCIXINITPAT	0x0000E000ul
+#define			PCIXINIT_PCI33_66	0x0000E000ul
+#define			PCIXINIT_PCIX50_66	0x0000C000ul
+#define			PCIXINIT_PCIX66_100	0x0000A000ul
+#define			PCIXINIT_PCIX100_133	0x00008000ul
+#define	PCI_BUS_MODES_INDEX(devconfig)	\
+	(((devconfig) & PCIXINITPAT) >> 13)
+static const char *pci_bus_modes[] =
+{
+	"PCI bus mode unknown",
+	"PCI bus mode unknown",
+	"PCI bus mode unknown",
+	"PCI bus mode unknown",
+	"PCI-X 101-133Mhz",
+	"PCI-X 67-100Mhz",
+	"PCI-X 50-66Mhz",
+	"PCI 33 or 66Mhz"
+};
+
+#define		TESTMODE	0x00000800ul
+#define		IRDY_RST	0x00000200ul
+#define		FRAME_RST	0x00000100ul
+#define		PCI64BIT	0x00000080ul
+#define		MRDCEN		0x00000040ul
+#define		ENDIANSEL	0x00000020ul
+#define		MIXQWENDIANEN	0x00000008ul
+#define		DACEN		0x00000004ul
+#define		STPWLEVEL	0x00000002ul
+#define		QWENDIANSEL	0x00000001ul
+
+#define	DEVCONFIG1		0x44
+#define		PREQDIS		0x01
+
+#define	CSIZE_LATTIME		0x0c
+#define		CACHESIZE	0x000000fful
+#define		LATTIME		0x0000ff00ul
+
+static int	ahd_check_extport(struct ahd_softc *ahd);
+static void	ahd_configure_termination(struct ahd_softc *ahd,
+					  u_int adapter_control);
+static void	ahd_pci_split_intr(struct ahd_softc *ahd, u_int intstat);
+
+struct ahd_pci_identity *
+ahd_find_pci_device(ahd_dev_softc_t pci)
+{
+	uint64_t  full_id;
+	uint16_t  device;
+	uint16_t  vendor;
+	uint16_t  subdevice;
+	uint16_t  subvendor;
+	struct	  ahd_pci_identity *entry;
+	u_int	  i;
+
+	vendor = ahd_pci_read_config(pci, PCIR_DEVVENDOR, /*bytes*/2);
+	device = ahd_pci_read_config(pci, PCIR_DEVICE, /*bytes*/2);
+	subvendor = ahd_pci_read_config(pci, PCIR_SUBVEND_0, /*bytes*/2);
+	subdevice = ahd_pci_read_config(pci, PCIR_SUBDEV_0, /*bytes*/2);
+	full_id = ahd_compose_id(device,
+				 vendor,
+				 subdevice,
+				 subvendor);
+
+	/*
+	 * If we are configured to attach to HostRAID
+	 * controllers, mask out the IROC/HostRAID bit
+	 * in the 
+	 */
+	if (ahd_attach_to_HostRAID_controllers)
+		full_id &= ID_ALL_IROC_MASK;
+
+	for (i = 0; i < ahd_num_pci_devs; i++) {
+		entry = &ahd_pci_ident_table[i];
+		if (entry->full_id == (full_id & entry->id_mask)) {
+			/* Honor exclusion entries. */
+			if (entry->name == NULL)
+				return (NULL);
+			return (entry);
+		}
+	}
+	return (NULL);
+}
+
+int
+ahd_pci_config(struct ahd_softc *ahd, struct ahd_pci_identity *entry)
+{
+	struct scb_data *shared_scb_data;
+	u_long		 l;
+	u_int		 command;
+	uint32_t	 devconfig;
+	uint16_t	 device; 
+	uint16_t	 subvendor; 
+	int		 error;
+
+	shared_scb_data = NULL;
+	ahd->description = entry->name;
+	/*
+	 * Record if this is a HostRAID board.
+	 */
+	device = ahd_pci_read_config(ahd->dev_softc,
+				     PCIR_DEVICE, /*bytes*/2);
+	if (DEVID_9005_HOSTRAID(device))
+		ahd->flags |= AHD_HOSTRAID_BOARD;
+
+	/*
+	 * Record if this is an HP board.
+	 */
+	subvendor = ahd_pci_read_config(ahd->dev_softc,
+					PCIR_SUBVEND_0, /*bytes*/2);
+	if (subvendor == SUBID_HP)
+		ahd->flags |= AHD_HP_BOARD;
+
+	error = entry->setup(ahd);
+	if (error != 0)
+		return (error);
+	
+	devconfig = ahd_pci_read_config(ahd->dev_softc, DEVCONFIG, /*bytes*/4);
+	if ((devconfig & PCIXINITPAT) == PCIXINIT_PCI33_66) {
+		ahd->chip |= AHD_PCI;
+		/* Disable PCIX workarounds when running in PCI mode. */
+		ahd->bugs &= ~AHD_PCIX_BUG_MASK;
+	} else {
+		ahd->chip |= AHD_PCIX;
+	}
+	ahd->bus_description = pci_bus_modes[PCI_BUS_MODES_INDEX(devconfig)];
+
+	ahd_power_state_change(ahd, AHD_POWER_STATE_D0);
+
+	error = ahd_pci_map_registers(ahd);
+	if (error != 0)
+		return (error);
+
+	/*
+	 * If we need to support high memory, enable dual
+	 * address cycles.  This bit must be set to enable
+	 * high address bit generation even if we are on a
+	 * 64bit bus (PCI64BIT set in devconfig).
+	 */
+	if ((ahd->flags & (AHD_39BIT_ADDRESSING|AHD_64BIT_ADDRESSING)) != 0) {
+		uint32_t devconfig;
+
+		if (bootverbose)
+			printf("%s: Enabling 39Bit Addressing\n",
+			       ahd_name(ahd));
+		devconfig = ahd_pci_read_config(ahd->dev_softc,
+						DEVCONFIG, /*bytes*/4);
+		devconfig |= DACEN;
+		ahd_pci_write_config(ahd->dev_softc, DEVCONFIG,
+				     devconfig, /*bytes*/4);
+	}
+	
+	/* Ensure busmastering is enabled */
+	command = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, /*bytes*/2);
+	command |= PCIM_CMD_BUSMASTEREN;
+	ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, command, /*bytes*/2);
+
+	error = ahd_softc_init(ahd);
+	if (error != 0)
+		return (error);
+
+	ahd->bus_intr = ahd_pci_intr;
+
+	error = ahd_reset(ahd, /*reinit*/FALSE);
+	if (error != 0)
+		return (ENXIO);
+
+	ahd->pci_cachesize =
+	    ahd_pci_read_config(ahd->dev_softc, CSIZE_LATTIME,
+				/*bytes*/1) & CACHESIZE;
+	ahd->pci_cachesize *= 4;
+
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	/* See if we have a SEEPROM and perform auto-term */
+	error = ahd_check_extport(ahd);
+	if (error != 0)
+		return (error);
+
+	/* Core initialization */
+	error = ahd_init(ahd);
+	if (error != 0)
+		return (error);
+
+	/*
+	 * Allow interrupts now that we are completely setup.
+	 */
+	error = ahd_pci_map_int(ahd);
+	if (error != 0)
+		return (error);
+
+	ahd_list_lock(&l);
+	/*
+	 * Link this softc in with all other ahd instances.
+	 */
+	ahd_softc_insert(ahd);
+	ahd_list_unlock(&l);
+	return (0);
+}
+
+/*
+ * Perform some simple tests that should catch situations where
+ * our registers are invalidly mapped.
+ */
+int
+ahd_pci_test_register_access(struct ahd_softc *ahd)
+{
+	uint32_t cmd;
+	u_int	 targpcistat;
+	u_int	 pci_status1;
+	int	 error;
+	uint8_t	 hcntrl;
+
+	error = EIO;
+
+	/*
+	 * Enable PCI error interrupt status, but suppress NMIs
+	 * generated by SERR raised due to target aborts.
+	 */
+	cmd = ahd_pci_read_config(ahd->dev_softc, PCIR_COMMAND, /*bytes*/2);
+	ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND,
+			     cmd & ~PCIM_CMD_SERRESPEN, /*bytes*/2);
+
+	/*
+	 * First a simple test to see if any
+	 * registers can be read.  Reading
+	 * HCNTRL has no side effects and has
+	 * at least one bit that is guaranteed to
+	 * be zero so it is a good register to
+	 * use for this test.
+	 */
+	hcntrl = ahd_inb(ahd, HCNTRL);
+	if (hcntrl == 0xFF)
+		goto fail;
+
+	/*
+	 * Next create a situation where write combining
+	 * or read prefetching could be initiated by the
+	 * CPU or host bridge.  Our device does not support
+	 * either, so look for data corruption and/or flaged
+	 * PCI errors.  First pause without causing another
+	 * chip reset.
+	 */
+	hcntrl &= ~CHIPRST;
+	ahd_outb(ahd, HCNTRL, hcntrl|PAUSE);
+	while (ahd_is_paused(ahd) == 0)
+		;
+
+	/* Clear any PCI errors that occurred before our driver attached. */
+	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+	targpcistat = ahd_inb(ahd, TARGPCISTAT);
+	ahd_outb(ahd, TARGPCISTAT, targpcistat);
+	pci_status1 = ahd_pci_read_config(ahd->dev_softc,
+					  PCIR_STATUS + 1, /*bytes*/1);
+	ahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
+			     pci_status1, /*bytes*/1);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	ahd_outb(ahd, CLRINT, CLRPCIINT);
+
+	ahd_outb(ahd, SEQCTL0, PERRORDIS);
+	ahd_outl(ahd, SRAM_BASE, 0x5aa555aa);
+	if (ahd_inl(ahd, SRAM_BASE) != 0x5aa555aa)
+		goto fail;
+
+	if ((ahd_inb(ahd, INTSTAT) & PCIINT) != 0) {
+		u_int targpcistat;
+
+		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+		targpcistat = ahd_inb(ahd, TARGPCISTAT);
+		if ((targpcistat & STA) != 0)
+			goto fail;
+	}
+
+	error = 0;
+
+fail:
+	if ((ahd_inb(ahd, INTSTAT) & PCIINT) != 0) {
+
+		ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+		targpcistat = ahd_inb(ahd, TARGPCISTAT);
+
+		/* Silently clear any latched errors. */
+		ahd_outb(ahd, TARGPCISTAT, targpcistat);
+		pci_status1 = ahd_pci_read_config(ahd->dev_softc,
+						  PCIR_STATUS + 1, /*bytes*/1);
+		ahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
+				     pci_status1, /*bytes*/1);
+		ahd_outb(ahd, CLRINT, CLRPCIINT);
+	}
+	ahd_outb(ahd, SEQCTL0, PERRORDIS|FAILDIS);
+	ahd_pci_write_config(ahd->dev_softc, PCIR_COMMAND, cmd, /*bytes*/2);
+	return (error);
+}
+
+/*
+ * Check the external port logic for a serial eeprom
+ * and termination/cable detection contrls.
+ */
+static int
+ahd_check_extport(struct ahd_softc *ahd)
+{
+	struct	vpd_config vpd;
+	struct	seeprom_config *sc;
+	u_int	adapter_control;
+	int	have_seeprom;
+	int	error;
+
+	sc = ahd->seep_config;
+	have_seeprom = ahd_acquire_seeprom(ahd);
+	if (have_seeprom) {
+		u_int start_addr;
+
+		/*
+		 * Fetch VPD for this function and parse it.
+		 */
+		if (bootverbose) 
+			printf("%s: Reading VPD from SEEPROM...",
+			       ahd_name(ahd));
+
+		/* Address is always in units of 16bit words */
+		start_addr = ((2 * sizeof(*sc))
+			    + (sizeof(vpd) * (ahd->channel - 'A'))) / 2;
+
+		error = ahd_read_seeprom(ahd, (uint16_t *)&vpd,
+					 start_addr, sizeof(vpd)/2,
+					 /*bytestream*/TRUE);
+		if (error == 0)
+			error = ahd_parse_vpddata(ahd, &vpd);
+		if (bootverbose) 
+			printf("%s: VPD parsing %s\n",
+			       ahd_name(ahd),
+			       error == 0 ? "successful" : "failed");
+
+		if (bootverbose) 
+			printf("%s: Reading SEEPROM...", ahd_name(ahd));
+
+		/* Address is always in units of 16bit words */
+		start_addr = (sizeof(*sc) / 2) * (ahd->channel - 'A');
+
+		error = ahd_read_seeprom(ahd, (uint16_t *)sc,
+					 start_addr, sizeof(*sc)/2,
+					 /*bytestream*/FALSE);
+
+		if (error != 0) {
+			printf("Unable to read SEEPROM\n");
+			have_seeprom = 0;
+		} else {
+			have_seeprom = ahd_verify_cksum(sc);
+
+			if (bootverbose) {
+				if (have_seeprom == 0)
+					printf ("checksum error\n");
+				else
+					printf ("done.\n");
+			}
+		}
+		ahd_release_seeprom(ahd);
+	}
+
+	if (!have_seeprom) {
+		u_int	  nvram_scb;
+
+		/*
+		 * Pull scratch ram settings and treat them as
+		 * if they are the contents of an seeprom if
+		 * the 'ADPT', 'BIOS', or 'ASPI' signature is found
+		 * in SCB 0xFF.  We manually compose the data as 16bit
+		 * values to avoid endian issues.
+		 */
+		ahd_set_scbptr(ahd, 0xFF);
+		nvram_scb = ahd_inb_scbram(ahd, SCB_BASE + NVRAM_SCB_OFFSET);
+		if (nvram_scb != 0xFF
+		 && ((ahd_inb_scbram(ahd, SCB_BASE + 0) == 'A'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'D'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'P'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'T')
+		  || (ahd_inb_scbram(ahd, SCB_BASE + 0) == 'B'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'I'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'O'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'S')
+		  || (ahd_inb_scbram(ahd, SCB_BASE + 0) == 'A'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 1) == 'S'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 2) == 'P'
+		   && ahd_inb_scbram(ahd, SCB_BASE + 3) == 'I'))) {
+			uint16_t *sc_data;
+			int	  i;
+
+			ahd_set_scbptr(ahd, nvram_scb);
+			sc_data = (uint16_t *)sc;
+			for (i = 0; i < 64; i += 2)
+				*sc_data++ = ahd_inw_scbram(ahd, SCB_BASE+i);
+			have_seeprom = ahd_verify_cksum(sc);
+			if (have_seeprom)
+				ahd->flags |= AHD_SCB_CONFIG_USED;
+		}
+	}
+
+#if AHD_DEBUG
+	if (have_seeprom != 0
+	 && (ahd_debug & AHD_DUMP_SEEPROM) != 0) {
+		uint16_t *sc_data;
+		int	  i;
+
+		printf("%s: Seeprom Contents:", ahd_name(ahd));
+		sc_data = (uint16_t *)sc;
+		for (i = 0; i < (sizeof(*sc)); i += 2)
+			printf("\n\t0x%.4x", sc_data[i]);
+		printf("\n");
+	}
+#endif
+
+	if (!have_seeprom) {
+		if (bootverbose)
+			printf("%s: No SEEPROM available.\n", ahd_name(ahd));
+		ahd->flags |= AHD_USEDEFAULTS;
+		error = ahd_default_config(ahd);
+		adapter_control = CFAUTOTERM|CFSEAUTOTERM;
+		free(ahd->seep_config, M_DEVBUF);
+		ahd->seep_config = NULL;
+	} else {
+		error = ahd_parse_cfgdata(ahd, sc);
+		adapter_control = sc->adapter_control;
+	}
+	if (error != 0)
+		return (error);
+
+	ahd_configure_termination(ahd, adapter_control);
+
+	return (0);
+}
+
+static void
+ahd_configure_termination(struct ahd_softc *ahd, u_int adapter_control)
+{
+	int	 error;
+	u_int	 sxfrctl1;
+	uint8_t	 termctl;
+	uint32_t devconfig;
+
+	devconfig = ahd_pci_read_config(ahd->dev_softc, DEVCONFIG, /*bytes*/4);
+	devconfig &= ~STPWLEVEL;
+	if ((ahd->flags & AHD_STPWLEVEL_A) != 0)
+		devconfig |= STPWLEVEL;
+	if (bootverbose)
+		printf("%s: STPWLEVEL is %s\n",
+		       ahd_name(ahd), (devconfig & STPWLEVEL) ? "on" : "off");
+	ahd_pci_write_config(ahd->dev_softc, DEVCONFIG, devconfig, /*bytes*/4);
+ 
+	/* Make sure current sensing is off. */
+	if ((ahd->flags & AHD_CURRENT_SENSING) != 0) {
+		(void)ahd_write_flexport(ahd, FLXADDR_ROMSTAT_CURSENSECTL, 0);
+	}
+
+	/*
+	 * Read to sense.  Write to set.
+	 */
+	error = ahd_read_flexport(ahd, FLXADDR_TERMCTL, &termctl);
+	if ((adapter_control & CFAUTOTERM) == 0) {
+		if (bootverbose)
+			printf("%s: Manual Primary Termination\n",
+			       ahd_name(ahd));
+		termctl &= ~(FLX_TERMCTL_ENPRILOW|FLX_TERMCTL_ENPRIHIGH);
+		if ((adapter_control & CFSTERM) != 0)
+			termctl |= FLX_TERMCTL_ENPRILOW;
+		if ((adapter_control & CFWSTERM) != 0)
+			termctl |= FLX_TERMCTL_ENPRIHIGH;
+	} else if (error != 0) {
+		printf("%s: Primary Auto-Term Sensing failed! "
+		       "Using Defaults.\n", ahd_name(ahd));
+		termctl = FLX_TERMCTL_ENPRILOW|FLX_TERMCTL_ENPRIHIGH;
+	}
+
+	if ((adapter_control & CFSEAUTOTERM) == 0) {
+		if (bootverbose)
+			printf("%s: Manual Secondary Termination\n",
+			       ahd_name(ahd));
+		termctl &= ~(FLX_TERMCTL_ENSECLOW|FLX_TERMCTL_ENSECHIGH);
+		if ((adapter_control & CFSELOWTERM) != 0)
+			termctl |= FLX_TERMCTL_ENSECLOW;
+		if ((adapter_control & CFSEHIGHTERM) != 0)
+			termctl |= FLX_TERMCTL_ENSECHIGH;
+	} else if (error != 0) {
+		printf("%s: Secondary Auto-Term Sensing failed! "
+		       "Using Defaults.\n", ahd_name(ahd));
+		termctl |= FLX_TERMCTL_ENSECLOW|FLX_TERMCTL_ENSECHIGH;
+	}
+
+	/*
+	 * Now set the termination based on what we found.
+	 */
+	sxfrctl1 = ahd_inb(ahd, SXFRCTL1) & ~STPWEN;
+	if ((termctl & FLX_TERMCTL_ENPRILOW) != 0) {
+		ahd->flags |= AHD_TERM_ENB_A;
+		sxfrctl1 |= STPWEN;
+	}
+	/* Must set the latch once in order to be effective. */
+	ahd_outb(ahd, SXFRCTL1, sxfrctl1|STPWEN);
+	ahd_outb(ahd, SXFRCTL1, sxfrctl1);
+
+	error = ahd_write_flexport(ahd, FLXADDR_TERMCTL, termctl);
+	if (error != 0) {
+		printf("%s: Unable to set termination settings!\n",
+		       ahd_name(ahd));
+	} else if (bootverbose) {
+		printf("%s: Primary High byte termination %sabled\n",
+		       ahd_name(ahd),
+		       (termctl & FLX_TERMCTL_ENPRIHIGH) ? "En" : "Dis");
+
+		printf("%s: Primary Low byte termination %sabled\n",
+		       ahd_name(ahd),
+		       (termctl & FLX_TERMCTL_ENPRILOW) ? "En" : "Dis");
+
+		printf("%s: Secondary High byte termination %sabled\n",
+		       ahd_name(ahd),
+		       (termctl & FLX_TERMCTL_ENSECHIGH) ? "En" : "Dis");
+
+		printf("%s: Secondary Low byte termination %sabled\n",
+		       ahd_name(ahd),
+		       (termctl & FLX_TERMCTL_ENSECLOW) ? "En" : "Dis");
+	}
+	return;
+}
+
+#define	DPE	0x80
+#define SSE	0x40
+#define	RMA	0x20
+#define	RTA	0x10
+#define STA	0x08
+#define DPR	0x01
+
+static const char *split_status_source[] =
+{
+	"DFF0",
+	"DFF1",
+	"OVLY",
+	"CMC",
+};
+
+static const char *pci_status_source[] =
+{
+	"DFF0",
+	"DFF1",
+	"SG",
+	"CMC",
+	"OVLY",
+	"NONE",
+	"MSI",
+	"TARG"
+};
+
+static const char *split_status_strings[] =
+{
+	"%s: Received split response in %s.\n",
+	"%s: Received split completion error message in %s\n",
+	"%s: Receive overrun in %s\n",
+	"%s: Count not complete in %s\n",
+	"%s: Split completion data bucket in %s\n",
+	"%s: Split completion address error in %s\n",
+	"%s: Split completion byte count error in %s\n",
+	"%s: Signaled Target-abort to early terminate a split in %s\n"
+};
+
+static const char *pci_status_strings[] =
+{
+	"%s: Data Parity Error has been reported via PERR# in %s\n",
+	"%s: Target initial wait state error in %s\n",
+	"%s: Split completion read data parity error in %s\n",
+	"%s: Split completion address attribute parity error in %s\n",
+	"%s: Received a Target Abort in %s\n",
+	"%s: Received a Master Abort in %s\n",
+	"%s: Signal System Error Detected in %s\n",
+	"%s: Address or Write Phase Parity Error Detected in %s.\n"
+};
+
+void
+ahd_pci_intr(struct ahd_softc *ahd)
+{
+	uint8_t		pci_status[8];
+	ahd_mode_state	saved_modes;
+	u_int		pci_status1;
+	u_int		intstat;
+	u_int		i;
+	u_int		reg;
+	
+	intstat = ahd_inb(ahd, INTSTAT);
+
+	if ((intstat & SPLTINT) != 0)
+		ahd_pci_split_intr(ahd, intstat);
+
+	if ((intstat & PCIINT) == 0)
+		return;
+
+	printf("%s: PCI error Interrupt\n", ahd_name(ahd));
+	saved_modes = ahd_save_modes(ahd);
+	ahd_dump_card_state(ahd);
+	ahd_set_modes(ahd, AHD_MODE_CFG, AHD_MODE_CFG);
+	for (i = 0, reg = DF0PCISTAT; i < 8; i++, reg++) {
+
+		if (i == 5)
+			continue;
+		pci_status[i] = ahd_inb(ahd, reg);
+		/* Clear latched errors.  So our interrupt deasserts. */
+		ahd_outb(ahd, reg, pci_status[i]);
+	}
+
+	for (i = 0; i < 8; i++) {
+		u_int bit;
+	
+		if (i == 5)
+			continue;
+
+		for (bit = 0; bit < 8; bit++) {
+
+			if ((pci_status[i] & (0x1 << bit)) != 0) {
+				static const char *s;
+
+				s = pci_status_strings[bit];
+				if (i == 7/*TARG*/ && bit == 3)
+					s = "%s: Signaled Target Abort\n";
+				printf(s, ahd_name(ahd), pci_status_source[i]);
+			}
+		}	
+	}
+	pci_status1 = ahd_pci_read_config(ahd->dev_softc,
+					  PCIR_STATUS + 1, /*bytes*/1);
+	ahd_pci_write_config(ahd->dev_softc, PCIR_STATUS + 1,
+			     pci_status1, /*bytes*/1);
+	ahd_restore_modes(ahd, saved_modes);
+	ahd_outb(ahd, CLRINT, CLRPCIINT);
+	ahd_unpause(ahd);
+}
+
+static void
+ahd_pci_split_intr(struct ahd_softc *ahd, u_int intstat)
+{
+	uint8_t		split_status[4];
+	uint8_t		split_status1[4];
+	uint8_t		sg_split_status[2];
+	uint8_t		sg_split_status1[2];
+	ahd_mode_state	saved_modes;
+	u_int		i;
+	uint16_t	pcix_status;
+
+	/*
+	 * Check for splits in all modes.  Modes 0 and 1
+	 * additionally have SG engine splits to look at.
+	 */
+	pcix_status = ahd_pci_read_config(ahd->dev_softc, PCIXR_STATUS,
+					  /*bytes*/2);
+	printf("%s: PCI Split Interrupt - PCI-X status = 0x%x\n",
+	       ahd_name(ahd), pcix_status);
+	saved_modes = ahd_save_modes(ahd);
+	for (i = 0; i < 4; i++) {
+		ahd_set_modes(ahd, i, i);
+
+		split_status[i] = ahd_inb(ahd, DCHSPLTSTAT0);
+		split_status1[i] = ahd_inb(ahd, DCHSPLTSTAT1);
+		/* Clear latched errors.  So our interrupt deasserts. */
+		ahd_outb(ahd, DCHSPLTSTAT0, split_status[i]);
+		ahd_outb(ahd, DCHSPLTSTAT1, split_status1[i]);
+		if (i > 1)
+			continue;
+		sg_split_status[i] = ahd_inb(ahd, SGSPLTSTAT0);
+		sg_split_status1[i] = ahd_inb(ahd, SGSPLTSTAT1);
+		/* Clear latched errors.  So our interrupt deasserts. */
+		ahd_outb(ahd, SGSPLTSTAT0, sg_split_status[i]);
+		ahd_outb(ahd, SGSPLTSTAT1, sg_split_status1[i]);
+	}
+
+	for (i = 0; i < 4; i++) {
+		u_int bit;
+
+		for (bit = 0; bit < 8; bit++) {
+
+			if ((split_status[i] & (0x1 << bit)) != 0) {
+				static const char *s;
+
+				s = split_status_strings[bit];
+				printf(s, ahd_name(ahd),
+				       split_status_source[i]);
+			}
+
+			if (i > 1)
+				continue;
+
+			if ((sg_split_status[i] & (0x1 << bit)) != 0) {
+				static const char *s;
+
+				s = split_status_strings[bit];
+				printf(s, ahd_name(ahd), "SG");
+			}
+		}
+	}
+	/*
+	 * Clear PCI-X status bits.
+	 */
+	ahd_pci_write_config(ahd->dev_softc, PCIXR_STATUS,
+			     pcix_status, /*bytes*/2);
+	ahd_outb(ahd, CLRINT, CLRSPLTINT);
+	ahd_restore_modes(ahd, saved_modes);
+}
+
+static int
+ahd_aic7901_setup(struct ahd_softc *ahd)
+{
+	int error;
+
+	error = ahd_aic7902_setup(ahd);
+	if (error != 0)
+		return (error);
+	ahd->chip = AHD_AIC7901;
+	return (0);
+}
+
+static int
+ahd_aic7901A_setup(struct ahd_softc *ahd)
+{
+	int error;
+
+	error = ahd_aic7902_setup(ahd);
+	if (error != 0)
+		return (error);
+	ahd->chip = AHD_AIC7901A;
+	return (0);
+}
+
+static int
+ahd_aic7902_setup(struct ahd_softc *ahd)
+{
+	ahd_dev_softc_t pci;
+	u_int rev;
+
+	pci = ahd->dev_softc;
+	rev = ahd_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
+	if (rev < ID_AIC7902_PCI_REV_A4) {
+		printf("%s: Unable to attach to unsupported chip revision %d\n",
+		       ahd_name(ahd), rev);
+		ahd_pci_write_config(pci, PCIR_COMMAND, 0, /*bytes*/2);
+		return (ENXIO);
+	}
+	ahd->channel = ahd_get_pci_function(pci) + 'A';
+	ahd->chip = AHD_AIC7902;
+	ahd->features = AHD_AIC7902_FE;
+	if (rev < ID_AIC7902_PCI_REV_B0) {
+		/*
+		 * Enable A series workarounds.
+		 */
+		ahd->bugs |= AHD_SENT_SCB_UPDATE_BUG|AHD_ABORT_LQI_BUG
+			  |  AHD_PKT_BITBUCKET_BUG|AHD_LONG_SETIMO_BUG
+			  |  AHD_NLQICRC_DELAYED_BUG|AHD_SCSIRST_BUG
+			  |  AHD_LQO_ATNO_BUG|AHD_AUTOFLUSH_BUG
+			  |  AHD_CLRLQO_AUTOCLR_BUG|AHD_PCIX_MMAPIO_BUG
+			  |  AHD_PCIX_CHIPRST_BUG|AHD_PCIX_SCBRAM_RD_BUG
+			  |  AHD_PKTIZED_STATUS_BUG|AHD_PKT_LUN_BUG
+			  |  AHD_MDFF_WSCBPTR_BUG|AHD_REG_SLOW_SETTLE_BUG
+			  |  AHD_SET_MODE_BUG|AHD_BUSFREEREV_BUG
+			  |  AHD_NONPACKFIFO_BUG|AHD_PACED_NEGTABLE_BUG
+			  |  AHD_FAINT_LED_BUG;
+
+		/*
+		 * IO Cell paramter setup.
+		 */
+		AHD_SET_PRECOMP(ahd, AHD_PRECOMP_CUTBACK_29);
+
+		if ((ahd->flags & AHD_HP_BOARD) == 0)
+			AHD_SET_SLEWRATE(ahd, AHD_SLEWRATE_DEF_REVA);
+	} else {
+		u_int devconfig1;
+
+		ahd->features |= AHD_RTI|AHD_NEW_IOCELL_OPTS
+			      |  AHD_NEW_DFCNTRL_OPTS;
+		ahd->bugs |= AHD_LQOOVERRUN_BUG|AHD_ABORT_LQI_BUG
+			  |  AHD_INTCOLLISION_BUG|AHD_EARLY_REQ_BUG;
+
+		/*
+		 * IO Cell paramter setup.
+		 */
+		AHD_SET_PRECOMP(ahd, AHD_PRECOMP_CUTBACK_29);
+		AHD_SET_SLEWRATE(ahd, AHD_SLEWRATE_DEF_REVB);
+		AHD_SET_AMPLITUDE(ahd, AHD_AMPLITUDE_DEF);
+
+		/*
+		 * Set the PREQDIS bit for H2B which disables some workaround
+		 * that doesn't work on regular PCI busses.
+		 * XXX - Find out exactly what this does from the hardware
+		 * 	 folks!
+		 */
+		devconfig1 = ahd_pci_read_config(pci, DEVCONFIG1, /*bytes*/1);
+		ahd_pci_write_config(pci, DEVCONFIG1,
+				     devconfig1|PREQDIS, /*bytes*/1);
+		devconfig1 = ahd_pci_read_config(pci, DEVCONFIG1, /*bytes*/1);
+	}
+
+	return (0);
+}
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic79xx_proc.c linux-5730/drivers/scsi/aic7xxx/aic79xx_proc.c
--- linux-5720/drivers/scsi/aic7xxx/aic79xx_proc.c
+++ linux-5730/drivers/scsi/aic7xxx/aic79xx_proc.c
@@ -0,0 +1,362 @@
+/*
+ * Copyright (c) 2000-2001 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * String handling code courtesy of Gerard Roudier's <groudier@club-internet.fr>
+ * sym driver.
+ *
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic79xx_proc.c#19 $
+ */
+#include "aic79xx_osm.h"
+#include "aic79xx_inline.h"
+
+static void	copy_mem_info(struct info_str *info, char *data, int len);
+static int	copy_info(struct info_str *info, char *fmt, ...);
+static void	ahd_dump_target_state(struct ahd_softc *ahd,
+				      struct info_str *info,
+				      u_int our_id, char channel,
+				      u_int target_id, u_int target_offset);
+static void	ahd_dump_device_state(struct info_str *info,
+				      struct ahd_linux_device *dev);
+static int	ahd_proc_write_seeprom(struct ahd_softc *ahd,
+				       char *buffer, int length);
+
+static void
+copy_mem_info(struct info_str *info, char *data, int len)
+{
+	if (info->pos + len > info->offset + info->length)
+		len = info->offset + info->length - info->pos;
+
+	if (info->pos + len < info->offset) {
+		info->pos += len;
+		return;
+	}
+
+	if (info->pos < info->offset) {
+		off_t partial;
+
+		partial = info->offset - info->pos;
+		data += partial;
+		info->pos += partial;
+		len  -= partial;
+	}
+
+	if (len > 0) {
+		memcpy(info->buffer, data, len);
+		info->pos += len;
+		info->buffer += len;
+	}
+}
+
+static int
+copy_info(struct info_str *info, char *fmt, ...)
+{
+	va_list args;
+	char buf[256];
+	int len;
+
+	va_start(args, fmt);
+	len = vsprintf(buf, fmt, args);
+	va_end(args);
+
+	copy_mem_info(info, buf, len);
+	return (len);
+}
+
+void
+ahd_format_transinfo(struct info_str *info, struct ahd_transinfo *tinfo)
+{
+	u_int speed;
+	u_int freq;
+	u_int mb;
+
+	if (tinfo->period == AHD_PERIOD_UNKNOWN) {
+		copy_info(info, "Renegotiation Pending\n");
+		return;
+	}
+        speed = 3300;
+        freq = 0;
+	if (tinfo->offset != 0) {
+		freq = aic_calc_syncsrate(tinfo->period);
+		speed = freq;
+	}
+	speed *= (0x01 << tinfo->width);
+        mb = speed / 1000;
+        if (mb > 0)
+		copy_info(info, "%d.%03dMB/s transfers", mb, speed % 1000);
+        else
+		copy_info(info, "%dKB/s transfers", speed);
+
+	if (freq != 0) {
+		int	printed_options;
+
+		printed_options = 0;
+		copy_info(info, " (%d.%03dMHz", freq / 1000, freq % 1000);
+		if ((tinfo->ppr_options & MSG_EXT_PPR_RD_STRM) != 0) {
+			copy_info(info, " RDSTRM");
+			printed_options++;
+		}
+		if ((tinfo->ppr_options & MSG_EXT_PPR_DT_REQ) != 0) {
+			copy_info(info, "%s", printed_options ? "|DT" : " DT");
+			printed_options++;
+		}
+		if ((tinfo->ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
+			copy_info(info, "%s", printed_options ? "|IU" : " IU");
+			printed_options++;
+		}
+		if ((tinfo->ppr_options & MSG_EXT_PPR_RTI) != 0) {
+			copy_info(info, "%s",
+				  printed_options ? "|RTI" : " RTI");
+			printed_options++;
+		}
+		if ((tinfo->ppr_options & MSG_EXT_PPR_QAS_REQ) != 0) {
+			copy_info(info, "%s",
+				  printed_options ? "|QAS" : " QAS");
+			printed_options++;
+		}
+	}
+
+	if (tinfo->width > 0) {
+		if (freq != 0) {
+			copy_info(info, ", ");
+		} else {
+			copy_info(info, " (");
+		}
+		copy_info(info, "%dbit)", 8 * (0x01 << tinfo->width));
+	} else if (freq != 0) {
+		copy_info(info, ")");
+	}
+	copy_info(info, "\n");
+}
+
+static void
+ahd_dump_target_state(struct ahd_softc *ahd, struct info_str *info,
+		      u_int our_id, char channel, u_int target_id,
+		      u_int target_offset)
+{
+	struct	ahd_linux_target *targ;
+	struct	ahd_initiator_tinfo *tinfo;
+	struct	ahd_tmode_tstate *tstate;
+	int	lun;
+
+	tinfo = ahd_fetch_transinfo(ahd, channel, our_id,
+				    target_id, &tstate);
+	copy_info(info, "Target %d Negotiation Settings\n", target_id);
+	copy_info(info, "\tUser: ");
+	ahd_format_transinfo(info, &tinfo->user);
+	targ = ahd->platform_data->targets[target_offset];
+	if (targ == NULL)
+		return;
+
+	copy_info(info, "\tGoal: ");
+	ahd_format_transinfo(info, &tinfo->goal);
+	copy_info(info, "\tCurr: ");
+	ahd_format_transinfo(info, &tinfo->curr);
+	copy_info(info, "\tTransmission Errors %ld\n", targ->errors_detected);
+
+	for (lun = 0; lun < AHD_NUM_LUNS; lun++) {
+		struct ahd_linux_device *dev;
+
+		dev = targ->devices[lun];
+
+		if (dev == NULL)
+			continue;
+
+		ahd_dump_device_state(info, dev);
+	}
+}
+
+static void
+ahd_dump_device_state(struct info_str *info, struct ahd_linux_device *dev)
+{
+	copy_info(info, "\tChannel %c Target %d Lun %d Settings\n",
+		  dev->target->channel + 'A', dev->target->target, dev->lun);
+
+	copy_info(info, "\t\tCommands Queued %ld\n", dev->commands_issued);
+	copy_info(info, "\t\tCommands Active %d\n", dev->active);
+	copy_info(info, "\t\tCommand Openings %d\n", dev->openings);
+	copy_info(info, "\t\tMax Tagged Openings %d\n", dev->maxtags);
+	copy_info(info, "\t\tDevice Queue Frozen Count %d\n", dev->qfrozen);
+}
+
+static int
+ahd_proc_write_seeprom(struct ahd_softc *ahd, char *buffer, int length)
+{
+	ahd_mode_state saved_modes;
+	int have_seeprom;
+	u_long s;
+	int paused;
+	int written;
+
+	/* Default to failure. */
+	written = -EINVAL;
+	ahd_lock(ahd, &s);
+	paused = ahd_is_paused(ahd);
+	if (!paused)
+		ahd_pause(ahd);
+
+	saved_modes = ahd_save_modes(ahd);
+	ahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);
+	if (length != sizeof(struct seeprom_config)) {
+		printf("ahd_proc_write_seeprom: incorrect buffer size\n");
+		goto done;
+	}
+
+	have_seeprom = ahd_verify_cksum((struct seeprom_config*)buffer);
+	if (have_seeprom == 0) {
+		printf("ahd_proc_write_seeprom: cksum verification failed\n");
+		goto done;
+	}
+
+	have_seeprom = ahd_acquire_seeprom(ahd);
+	if (!have_seeprom) {
+		printf("ahd_proc_write_seeprom: No Serial EEPROM\n");
+		goto done;
+	} else {
+		u_int start_addr;
+
+		if (ahd->seep_config == NULL) {
+			ahd->seep_config = malloc(sizeof(*ahd->seep_config),
+						  M_DEVBUF, M_NOWAIT);
+			if (ahd->seep_config == NULL) {
+				printf("aic79xx: Unable to allocate serial "
+				       "eeprom buffer.  Write failing\n");
+				goto done;
+			}
+		}
+		printf("aic79xx: Writing Serial EEPROM\n");
+		start_addr = 32 * (ahd->channel - 'A');
+		ahd_write_seeprom(ahd, (u_int16_t *)buffer, start_addr,
+				  sizeof(struct seeprom_config)/2);
+		ahd_read_seeprom(ahd, (uint16_t *)ahd->seep_config,
+				 start_addr, sizeof(struct seeprom_config)/2,
+				 /*ByteStream*/FALSE);
+		ahd_release_seeprom(ahd);
+		written = length;
+	}
+
+done:
+	ahd_restore_modes(ahd, saved_modes);
+	if (!paused)
+		ahd_unpause(ahd);
+	ahd_unlock(ahd, &s);
+	return (written);
+}
+/*
+ * Return information to handle /proc support for the driver.
+ */
+int
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+ahd_linux_proc_info(char *buffer, char **start, off_t offset,
+		    int length, int hostno, int inout)
+#else
+ahd_linux_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
+		    off_t offset, int length, int inout)
+#endif
+{
+	struct	ahd_softc *ahd;
+	struct	info_str info;
+	char	ahd_info[256];
+	u_long	l;
+	u_int	max_targ;
+	u_int	i;
+	int	retval;
+
+	retval = -EINVAL;
+	ahd_list_lock(&l);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	TAILQ_FOREACH(ahd, &ahd_tailq, links) {
+		if (ahd->platform_data->host->host_no == hostno)
+			break;
+	}
+#else
+	ahd = ahd_find_softc(*(struct ahd_softc **)shost->hostdata);
+#endif
+
+	if (ahd == NULL)
+		goto done;
+
+	 /* Has data been written to the file? */ 
+	if (inout == TRUE) {
+		retval = ahd_proc_write_seeprom(ahd, buffer, length);
+		goto done;
+	}
+
+	if (start)
+		*start = buffer;
+
+	info.buffer	= buffer;
+	info.length	= length;
+	info.offset	= offset;
+	info.pos	= 0;
+
+	copy_info(&info, "Adaptec AIC79xx driver version: %s\n",
+		  AIC79XX_DRIVER_VERSION);
+	copy_info(&info, "%s\n", ahd->description);
+	ahd_controller_info(ahd, ahd_info);
+	copy_info(&info, "%s\n", ahd_info);
+	copy_info(&info, "Allocated SCBs: %d, SG List Length: %d\n\n",
+		  ahd->scb_data.numscbs, AHD_NSEG);
+
+	max_targ = 15;
+
+	if (ahd->seep_config == NULL)
+		copy_info(&info, "No Serial EEPROM\n");
+	else {
+		copy_info(&info, "Serial EEPROM:\n");
+		for (i = 0; i < sizeof(*ahd->seep_config)/2; i++) {
+			if (((i % 8) == 0) && (i != 0)) {
+				copy_info(&info, "\n");
+			}
+			copy_info(&info, "0x%.4x ",
+				  ((uint16_t*)ahd->seep_config)[i]);
+		}
+		copy_info(&info, "\n");
+	}
+	copy_info(&info, "\n");
+
+	if ((ahd->features & AHD_WIDE) == 0)
+		max_targ = 7;
+
+	for (i = 0; i <= max_targ; i++) {
+
+		ahd_dump_target_state(ahd, &info, ahd->our_id, 'A',
+				      /*target_id*/i, /*target_offset*/i);
+	}
+	retval = info.pos > info.offset ? info.pos - info.offset : 0;
+done:
+	ahd_list_unlock(&l);
+	return (retval);
+}
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic79xx_reg.h linux-5730/drivers/scsi/aic7xxx/aic79xx_reg.h
--- linux-5720/drivers/scsi/aic7xxx/aic79xx_reg.h
+++ linux-5730/drivers/scsi/aic7xxx/aic79xx_reg.h
@@ -0,0 +1,3776 @@
+/*
+ * DO NOT EDIT - This file is automatically generated
+ *		 from the following source files:
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#94 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#70 $
+ */
+typedef int (ahd_reg_print_t)(u_int, u_int *, u_int);
+typedef struct ahd_reg_parse_entry {
+	char	*name;
+	uint8_t	 value;
+	uint8_t	 mask;
+} ahd_reg_parse_entry_t;
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_mode_ptr_print;
+#else
+#define ahd_mode_ptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MODE_PTR", 0x00, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_intstat_print;
+#else
+#define ahd_intstat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "INTSTAT", 0x01, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqintcode_print;
+#else
+#define ahd_seqintcode_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQINTCODE", 0x02, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrint_print;
+#else
+#define ahd_clrint_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRINT", 0x03, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_error_print;
+#else
+#define ahd_error_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ERROR", 0x04, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrerr_print;
+#else
+#define ahd_clrerr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRERR", 0x04, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hcntrl_print;
+#else
+#define ahd_hcntrl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HCNTRL", 0x05, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hnscb_qoff_print;
+#else
+#define ahd_hnscb_qoff_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HNSCB_QOFF", 0x06, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hescb_qoff_print;
+#else
+#define ahd_hescb_qoff_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HESCB_QOFF", 0x08, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hs_mailbox_print;
+#else
+#define ahd_hs_mailbox_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HS_MAILBOX", 0x0b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrseqintstat_print;
+#else
+#define ahd_clrseqintstat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRSEQINTSTAT", 0x0c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqintstat_print;
+#else
+#define ahd_seqintstat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQINTSTAT", 0x0c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_swtimer_print;
+#else
+#define ahd_swtimer_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SWTIMER", 0x0e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_snscb_qoff_print;
+#else
+#define ahd_snscb_qoff_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SNSCB_QOFF", 0x10, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sescb_qoff_print;
+#else
+#define ahd_sescb_qoff_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SESCB_QOFF", 0x12, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sdscb_qoff_print;
+#else
+#define ahd_sdscb_qoff_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SDSCB_QOFF", 0x14, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_qoff_ctlsta_print;
+#else
+#define ahd_qoff_ctlsta_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "QOFF_CTLSTA", 0x16, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_intctl_print;
+#else
+#define ahd_intctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "INTCTL", 0x18, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfcntrl_print;
+#else
+#define ahd_dfcntrl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFCNTRL", 0x19, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dscommand0_print;
+#else
+#define ahd_dscommand0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DSCOMMAND0", 0x19, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfstatus_print;
+#else
+#define ahd_dfstatus_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFSTATUS", 0x1a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sg_cache_shadow_print;
+#else
+#define ahd_sg_cache_shadow_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SG_CACHE_SHADOW", 0x1b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_arbctl_print;
+#else
+#define ahd_arbctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ARBCTL", 0x1b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sg_cache_pre_print;
+#else
+#define ahd_sg_cache_pre_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SG_CACHE_PRE", 0x1b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqin_print;
+#else
+#define ahd_lqin_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQIN", 0x20, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_typeptr_print;
+#else
+#define ahd_typeptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "TYPEPTR", 0x20, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_tagptr_print;
+#else
+#define ahd_tagptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "TAGPTR", 0x21, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lunptr_print;
+#else
+#define ahd_lunptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LUNPTR", 0x22, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_datalenptr_print;
+#else
+#define ahd_datalenptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DATALENPTR", 0x23, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_statlenptr_print;
+#else
+#define ahd_statlenptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "STATLENPTR", 0x24, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmdlenptr_print;
+#else
+#define ahd_cmdlenptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMDLENPTR", 0x25, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_attrptr_print;
+#else
+#define ahd_attrptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ATTRPTR", 0x26, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_flagptr_print;
+#else
+#define ahd_flagptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FLAGPTR", 0x27, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmdptr_print;
+#else
+#define ahd_cmdptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMDPTR", 0x28, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_qnextptr_print;
+#else
+#define ahd_qnextptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "QNEXTPTR", 0x29, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_idptr_print;
+#else
+#define ahd_idptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "IDPTR", 0x2a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_abrtbyteptr_print;
+#else
+#define ahd_abrtbyteptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ABRTBYTEPTR", 0x2b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_abrtbitptr_print;
+#else
+#define ahd_abrtbitptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ABRTBITPTR", 0x2c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_maxcmdbytes_print;
+#else
+#define ahd_maxcmdbytes_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MAXCMDBYTES", 0x2d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_maxcmd2rcv_print;
+#else
+#define ahd_maxcmd2rcv_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MAXCMD2RCV", 0x2e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_shortthresh_print;
+#else
+#define ahd_shortthresh_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SHORTTHRESH", 0x2f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lunlen_print;
+#else
+#define ahd_lunlen_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LUNLEN", 0x30, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cdblimit_print;
+#else
+#define ahd_cdblimit_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CDBLIMIT", 0x31, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_maxcmd_print;
+#else
+#define ahd_maxcmd_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MAXCMD", 0x32, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_maxcmdcnt_print;
+#else
+#define ahd_maxcmdcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MAXCMDCNT", 0x33, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqrsvd01_print;
+#else
+#define ahd_lqrsvd01_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQRSVD01", 0x34, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqrsvd16_print;
+#else
+#define ahd_lqrsvd16_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQRSVD16", 0x35, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqrsvd17_print;
+#else
+#define ahd_lqrsvd17_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQRSVD17", 0x36, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmdrsvd0_print;
+#else
+#define ahd_cmdrsvd0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMDRSVD0", 0x37, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqctl0_print;
+#else
+#define ahd_lqctl0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQCTL0", 0x38, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqctl1_print;
+#else
+#define ahd_lqctl1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQCTL1", 0x38, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsbist0_print;
+#else
+#define ahd_scsbist0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSBIST0", 0x39, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqctl2_print;
+#else
+#define ahd_lqctl2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQCTL2", 0x39, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsbist1_print;
+#else
+#define ahd_scsbist1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSBIST1", 0x3a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsiseq0_print;
+#else
+#define ahd_scsiseq0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSISEQ0", 0x3a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsiseq1_print;
+#else
+#define ahd_scsiseq1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSISEQ1", 0x3b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sxfrctl0_print;
+#else
+#define ahd_sxfrctl0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SXFRCTL0", 0x3c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_businitid_print;
+#else
+#define ahd_businitid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "BUSINITID", 0x3c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dlcount_print;
+#else
+#define ahd_dlcount_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DLCOUNT", 0x3c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sxfrctl1_print;
+#else
+#define ahd_sxfrctl1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SXFRCTL1", 0x3d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_bustargid_print;
+#else
+#define ahd_bustargid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "BUSTARGID", 0x3e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sxfrctl2_print;
+#else
+#define ahd_sxfrctl2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SXFRCTL2", 0x3e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dffstat_print;
+#else
+#define ahd_dffstat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFFSTAT", 0x3f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsisigo_print;
+#else
+#define ahd_scsisigo_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSISIGO", 0x40, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_multargid_print;
+#else
+#define ahd_multargid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MULTARGID", 0x40, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsisigi_print;
+#else
+#define ahd_scsisigi_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSISIGI", 0x41, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsiphase_print;
+#else
+#define ahd_scsiphase_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSIPHASE", 0x42, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsidat0_img_print;
+#else
+#define ahd_scsidat0_img_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSIDAT0_IMG", 0x43, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsidat_print;
+#else
+#define ahd_scsidat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSIDAT", 0x44, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsibus_print;
+#else
+#define ahd_scsibus_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSIBUS", 0x46, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_targidin_print;
+#else
+#define ahd_targidin_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "TARGIDIN", 0x48, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_selid_print;
+#else
+#define ahd_selid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SELID", 0x49, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sblkctl_print;
+#else
+#define ahd_sblkctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SBLKCTL", 0x4a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_optionmode_print;
+#else
+#define ahd_optionmode_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OPTIONMODE", 0x4a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sstat0_print;
+#else
+#define ahd_sstat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SSTAT0", 0x4b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrsint0_print;
+#else
+#define ahd_clrsint0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRSINT0", 0x4b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_simode0_print;
+#else
+#define ahd_simode0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SIMODE0", 0x4b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrsint1_print;
+#else
+#define ahd_clrsint1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRSINT1", 0x4c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sstat1_print;
+#else
+#define ahd_sstat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SSTAT1", 0x4c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sstat2_print;
+#else
+#define ahd_sstat2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SSTAT2", 0x4d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrsint2_print;
+#else
+#define ahd_clrsint2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRSINT2", 0x4d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_simode2_print;
+#else
+#define ahd_simode2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SIMODE2", 0x4d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_perrdiag_print;
+#else
+#define ahd_perrdiag_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PERRDIAG", 0x4e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqistate_print;
+#else
+#define ahd_lqistate_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQISTATE", 0x4e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_soffcnt_print;
+#else
+#define ahd_soffcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SOFFCNT", 0x4f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqostate_print;
+#else
+#define ahd_lqostate_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQOSTATE", 0x4f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqistat0_print;
+#else
+#define ahd_lqistat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQISTAT0", 0x50, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrlqiint0_print;
+#else
+#define ahd_clrlqiint0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRLQIINT0", 0x50, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqimode0_print;
+#else
+#define ahd_lqimode0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQIMODE0", 0x50, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqimode1_print;
+#else
+#define ahd_lqimode1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQIMODE1", 0x51, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqistat1_print;
+#else
+#define ahd_lqistat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQISTAT1", 0x51, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrlqiint1_print;
+#else
+#define ahd_clrlqiint1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRLQIINT1", 0x51, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqistat2_print;
+#else
+#define ahd_lqistat2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQISTAT2", 0x52, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sstat3_print;
+#else
+#define ahd_sstat3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SSTAT3", 0x53, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_simode3_print;
+#else
+#define ahd_simode3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SIMODE3", 0x53, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrsint3_print;
+#else
+#define ahd_clrsint3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRSINT3", 0x53, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqomode0_print;
+#else
+#define ahd_lqomode0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQOMODE0", 0x54, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqostat0_print;
+#else
+#define ahd_lqostat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQOSTAT0", 0x54, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrlqoint0_print;
+#else
+#define ahd_clrlqoint0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRLQOINT0", 0x54, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqostat1_print;
+#else
+#define ahd_lqostat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQOSTAT1", 0x55, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrlqoint1_print;
+#else
+#define ahd_clrlqoint1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRLQOINT1", 0x55, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqomode1_print;
+#else
+#define ahd_lqomode1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQOMODE1", 0x55, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqostat2_print;
+#else
+#define ahd_lqostat2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQOSTAT2", 0x56, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_os_space_cnt_print;
+#else
+#define ahd_os_space_cnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OS_SPACE_CNT", 0x56, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_simode1_print;
+#else
+#define ahd_simode1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SIMODE1", 0x57, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_gsfifo_print;
+#else
+#define ahd_gsfifo_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "GSFIFO", 0x58, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dffsxfrctl_print;
+#else
+#define ahd_dffsxfrctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFFSXFRCTL", 0x5a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lqoscsctl_print;
+#else
+#define ahd_lqoscsctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LQOSCSCTL", 0x5a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_nextscb_print;
+#else
+#define ahd_nextscb_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NEXTSCB", 0x5a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_clrseqintsrc_print;
+#else
+#define ahd_clrseqintsrc_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CLRSEQINTSRC", 0x5b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqintsrc_print;
+#else
+#define ahd_seqintsrc_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQINTSRC", 0x5b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_currscb_print;
+#else
+#define ahd_currscb_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CURRSCB", 0x5c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqimode_print;
+#else
+#define ahd_seqimode_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQIMODE", 0x5c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_mdffstat_print;
+#else
+#define ahd_mdffstat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MDFFSTAT", 0x5d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_crccontrol_print;
+#else
+#define ahd_crccontrol_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CRCCONTROL", 0x5d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfftag_print;
+#else
+#define ahd_dfftag_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFFTAG", 0x5e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lastscb_print;
+#else
+#define ahd_lastscb_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LASTSCB", 0x5e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsitest_print;
+#else
+#define ahd_scsitest_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSITEST", 0x5e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_iopdnctl_print;
+#else
+#define ahd_iopdnctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "IOPDNCTL", 0x5f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_shaddr_print;
+#else
+#define ahd_shaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SHADDR", 0x60, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_negoaddr_print;
+#else
+#define ahd_negoaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NEGOADDR", 0x60, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dgrpcrci_print;
+#else
+#define ahd_dgrpcrci_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DGRPCRCI", 0x60, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_negperiod_print;
+#else
+#define ahd_negperiod_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NEGPERIOD", 0x61, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_packcrci_print;
+#else
+#define ahd_packcrci_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PACKCRCI", 0x62, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_negoffset_print;
+#else
+#define ahd_negoffset_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NEGOFFSET", 0x62, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_negppropts_print;
+#else
+#define ahd_negppropts_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NEGPPROPTS", 0x63, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_negconopts_print;
+#else
+#define ahd_negconopts_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NEGCONOPTS", 0x64, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_annexcol_print;
+#else
+#define ahd_annexcol_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ANNEXCOL", 0x65, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scschkn_print;
+#else
+#define ahd_scschkn_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSCHKN", 0x66, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_annexdat_print;
+#else
+#define ahd_annexdat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ANNEXDAT", 0x66, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_iownid_print;
+#else
+#define ahd_iownid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "IOWNID", 0x67, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_pll960ctl0_print;
+#else
+#define ahd_pll960ctl0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PLL960CTL0", 0x68, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_shcnt_print;
+#else
+#define ahd_shcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SHCNT", 0x68, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_townid_print;
+#else
+#define ahd_townid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "TOWNID", 0x69, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_pll960ctl1_print;
+#else
+#define ahd_pll960ctl1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PLL960CTL1", 0x69, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_pll960cnt0_print;
+#else
+#define ahd_pll960cnt0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PLL960CNT0", 0x6a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_xsig_print;
+#else
+#define ahd_xsig_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "XSIG", 0x6a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seloid_print;
+#else
+#define ahd_seloid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SELOID", 0x6b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_pll400ctl0_print;
+#else
+#define ahd_pll400ctl0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PLL400CTL0", 0x6c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_fairness_print;
+#else
+#define ahd_fairness_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FAIRNESS", 0x6c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_pll400ctl1_print;
+#else
+#define ahd_pll400ctl1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PLL400CTL1", 0x6d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_pll400cnt0_print;
+#else
+#define ahd_pll400cnt0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PLL400CNT0", 0x6e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_unfairness_print;
+#else
+#define ahd_unfairness_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "UNFAIRNESS", 0x6e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_haddr_print;
+#else
+#define ahd_haddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HADDR", 0x70, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_plldelay_print;
+#else
+#define ahd_plldelay_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PLLDELAY", 0x70, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hodmaadr_print;
+#else
+#define ahd_hodmaadr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HODMAADR", 0x70, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hodmacnt_print;
+#else
+#define ahd_hodmacnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HODMACNT", 0x78, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hcnt_print;
+#else
+#define ahd_hcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HCNT", 0x78, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_hodmaen_print;
+#else
+#define ahd_hodmaen_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "HODMAEN", 0x7a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sghaddr_print;
+#else
+#define ahd_sghaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGHADDR", 0x7c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scbhaddr_print;
+#else
+#define ahd_scbhaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCBHADDR", 0x7c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sghcnt_print;
+#else
+#define ahd_sghcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGHCNT", 0x84, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scbhcnt_print;
+#else
+#define ahd_scbhcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCBHCNT", 0x84, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dff_thrsh_print;
+#else
+#define ahd_dff_thrsh_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFF_THRSH", 0x88, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_romaddr_print;
+#else
+#define ahd_romaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ROMADDR", 0x8a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_romcntrl_print;
+#else
+#define ahd_romcntrl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ROMCNTRL", 0x8d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_romdata_print;
+#else
+#define ahd_romdata_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ROMDATA", 0x8e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcrxmsg0_print;
+#else
+#define ahd_cmcrxmsg0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCRXMSG0", 0x90, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_roenable_print;
+#else
+#define ahd_roenable_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ROENABLE", 0x90, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyrxmsg0_print;
+#else
+#define ahd_ovlyrxmsg0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYRXMSG0", 0x90, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dchrxmsg0_print;
+#else
+#define ahd_dchrxmsg0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHRXMSG0", 0x90, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyrxmsg1_print;
+#else
+#define ahd_ovlyrxmsg1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYRXMSG1", 0x91, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_nsenable_print;
+#else
+#define ahd_nsenable_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NSENABLE", 0x91, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dchrxmsg1_print;
+#else
+#define ahd_dchrxmsg1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHRXMSG1", 0x91, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcrxmsg1_print;
+#else
+#define ahd_cmcrxmsg1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCRXMSG1", 0x91, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dchrxmsg2_print;
+#else
+#define ahd_dchrxmsg2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHRXMSG2", 0x92, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyrxmsg2_print;
+#else
+#define ahd_ovlyrxmsg2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYRXMSG2", 0x92, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcrxmsg2_print;
+#else
+#define ahd_cmcrxmsg2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCRXMSG2", 0x92, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ost_print;
+#else
+#define ahd_ost_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OST", 0x92, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dchrxmsg3_print;
+#else
+#define ahd_dchrxmsg3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHRXMSG3", 0x93, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcrxmsg3_print;
+#else
+#define ahd_cmcrxmsg3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCRXMSG3", 0x93, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_pcixctl_print;
+#else
+#define ahd_pcixctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PCIXCTL", 0x93, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyrxmsg3_print;
+#else
+#define ahd_ovlyrxmsg3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYRXMSG3", 0x93, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyseqbcnt_print;
+#else
+#define ahd_ovlyseqbcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYSEQBCNT", 0x94, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcseqbcnt_print;
+#else
+#define ahd_cmcseqbcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCSEQBCNT", 0x94, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dchseqbcnt_print;
+#else
+#define ahd_dchseqbcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHSEQBCNT", 0x94, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcspltstat0_print;
+#else
+#define ahd_cmcspltstat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCSPLTSTAT0", 0x96, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyspltstat0_print;
+#else
+#define ahd_ovlyspltstat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYSPLTSTAT0", 0x96, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dchspltstat0_print;
+#else
+#define ahd_dchspltstat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHSPLTSTAT0", 0x96, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dchspltstat1_print;
+#else
+#define ahd_dchspltstat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DCHSPLTSTAT1", 0x97, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcspltstat1_print;
+#else
+#define ahd_cmcspltstat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCSPLTSTAT1", 0x97, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyspltstat1_print;
+#else
+#define ahd_ovlyspltstat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYSPLTSTAT1", 0x97, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgrxmsg0_print;
+#else
+#define ahd_sgrxmsg0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGRXMSG0", 0x98, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_slvspltoutadr0_print;
+#else
+#define ahd_slvspltoutadr0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SLVSPLTOUTADR0", 0x98, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgrxmsg1_print;
+#else
+#define ahd_sgrxmsg1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGRXMSG1", 0x99, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_slvspltoutadr1_print;
+#else
+#define ahd_slvspltoutadr1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SLVSPLTOUTADR1", 0x99, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgrxmsg2_print;
+#else
+#define ahd_sgrxmsg2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGRXMSG2", 0x9a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_slvspltoutadr2_print;
+#else
+#define ahd_slvspltoutadr2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SLVSPLTOUTADR2", 0x9a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgrxmsg3_print;
+#else
+#define ahd_sgrxmsg3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGRXMSG3", 0x9b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_slvspltoutadr3_print;
+#else
+#define ahd_slvspltoutadr3_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SLVSPLTOUTADR3", 0x9b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgseqbcnt_print;
+#else
+#define ahd_sgseqbcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGSEQBCNT", 0x9c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_slvspltoutattr0_print;
+#else
+#define ahd_slvspltoutattr0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SLVSPLTOUTATTR0", 0x9c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_slvspltoutattr1_print;
+#else
+#define ahd_slvspltoutattr1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SLVSPLTOUTATTR1", 0x9d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_slvspltoutattr2_print;
+#else
+#define ahd_slvspltoutattr2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SLVSPLTOUTATTR2", 0x9e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgspltstat0_print;
+#else
+#define ahd_sgspltstat0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGSPLTSTAT0", 0x9e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sfunct_print;
+#else
+#define ahd_sfunct_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SFUNCT", 0x9f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgspltstat1_print;
+#else
+#define ahd_sgspltstat1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGSPLTSTAT1", 0x9f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_df0pcistat_print;
+#else
+#define ahd_df0pcistat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DF0PCISTAT", 0xa0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_reg0_print;
+#else
+#define ahd_reg0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "REG0", 0xa0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_df1pcistat_print;
+#else
+#define ahd_df1pcistat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DF1PCISTAT", 0xa1, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sgpcistat_print;
+#else
+#define ahd_sgpcistat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SGPCISTAT", 0xa2, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_reg1_print;
+#else
+#define ahd_reg1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "REG1", 0xa2, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmcpcistat_print;
+#else
+#define ahd_cmcpcistat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMCPCISTAT", 0xa3, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlypcistat_print;
+#else
+#define ahd_ovlypcistat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYPCISTAT", 0xa4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_reg_isr_print;
+#else
+#define ahd_reg_isr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "REG_ISR", 0xa4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sg_state_print;
+#else
+#define ahd_sg_state_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SG_STATE", 0xa6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_msipcistat_print;
+#else
+#define ahd_msipcistat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MSIPCISTAT", 0xa6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_targpcistat_print;
+#else
+#define ahd_targpcistat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "TARGPCISTAT", 0xa7, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_data_count_odd_print;
+#else
+#define ahd_data_count_odd_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DATA_COUNT_ODD", 0xa7, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scbptr_print;
+#else
+#define ahd_scbptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCBPTR", 0xa8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccscbacnt_print;
+#else
+#define ahd_ccscbacnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSCBACNT", 0xab, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scbautoptr_print;
+#else
+#define ahd_scbautoptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCBAUTOPTR", 0xab, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccsgaddr_print;
+#else
+#define ahd_ccsgaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSGADDR", 0xac, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccscbaddr_print;
+#else
+#define ahd_ccscbaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSCBADDR", 0xac, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccscbadr_bk_print;
+#else
+#define ahd_ccscbadr_bk_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSCBADR_BK", 0xac, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmc_rambist_print;
+#else
+#define ahd_cmc_rambist_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMC_RAMBIST", 0xad, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccsgctl_print;
+#else
+#define ahd_ccsgctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSGCTL", 0xad, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccscbctl_print;
+#else
+#define ahd_ccscbctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSCBCTL", 0xad, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccsgram_print;
+#else
+#define ahd_ccsgram_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSGRAM", 0xb0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_flexadr_print;
+#else
+#define ahd_flexadr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FLEXADR", 0xb0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ccscbram_print;
+#else
+#define ahd_ccscbram_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CCSCBRAM", 0xb0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_flexcnt_print;
+#else
+#define ahd_flexcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FLEXCNT", 0xb3, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_flexdmastat_print;
+#else
+#define ahd_flexdmastat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FLEXDMASTAT", 0xb5, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_flexdata_print;
+#else
+#define ahd_flexdata_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FLEXDATA", 0xb6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_brddat_print;
+#else
+#define ahd_brddat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "BRDDAT", 0xb8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_brdctl_print;
+#else
+#define ahd_brdctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "BRDCTL", 0xb9, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seeadr_print;
+#else
+#define ahd_seeadr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEEADR", 0xba, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seedat_print;
+#else
+#define ahd_seedat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEEDAT", 0xbc, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seectl_print;
+#else
+#define ahd_seectl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEECTL", 0xbe, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seestat_print;
+#else
+#define ahd_seestat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEESTAT", 0xbe, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scbcnt_print;
+#else
+#define ahd_scbcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCBCNT", 0xbf, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfwaddr_print;
+#else
+#define ahd_dfwaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFWADDR", 0xc0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dspfltrctl_print;
+#else
+#define ahd_dspfltrctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DSPFLTRCTL", 0xc0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dspdatactl_print;
+#else
+#define ahd_dspdatactl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DSPDATACTL", 0xc1, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfraddr_print;
+#else
+#define ahd_dfraddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFRADDR", 0xc2, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dspreqctl_print;
+#else
+#define ahd_dspreqctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DSPREQCTL", 0xc2, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dspackctl_print;
+#else
+#define ahd_dspackctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DSPACKCTL", 0xc3, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfdat_print;
+#else
+#define ahd_dfdat_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFDAT", 0xc4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dspselect_print;
+#else
+#define ahd_dspselect_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DSPSELECT", 0xc4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_wrtbiasctl_print;
+#else
+#define ahd_wrtbiasctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "WRTBIASCTL", 0xc5, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_rcvrbiosctl_print;
+#else
+#define ahd_rcvrbiosctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "RCVRBIOSCTL", 0xc6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_wrtbiascalc_print;
+#else
+#define ahd_wrtbiascalc_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "WRTBIASCALC", 0xc7, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfptrs_print;
+#else
+#define ahd_dfptrs_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFPTRS", 0xc8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_rcvrbiascalc_print;
+#else
+#define ahd_rcvrbiascalc_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "RCVRBIASCALC", 0xc8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfbkptr_print;
+#else
+#define ahd_dfbkptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFBKPTR", 0xc9, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_skewcalc_print;
+#else
+#define ahd_skewcalc_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SKEWCALC", 0xc9, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfdbctl_print;
+#else
+#define ahd_dfdbctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFDBCTL", 0xcb, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfscnt_print;
+#else
+#define ahd_dfscnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFSCNT", 0xcc, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dfbcnt_print;
+#else
+#define ahd_dfbcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DFBCNT", 0xce, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ovlyaddr_print;
+#else
+#define ahd_ovlyaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "OVLYADDR", 0xd4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqctl0_print;
+#else
+#define ahd_seqctl0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQCTL0", 0xd6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqctl1_print;
+#else
+#define ahd_seqctl1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQCTL1", 0xd7, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_flags_print;
+#else
+#define ahd_flags_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FLAGS", 0xd8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqintctl_print;
+#else
+#define ahd_seqintctl_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQINTCTL", 0xd9, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seqram_print;
+#else
+#define ahd_seqram_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQRAM", 0xda, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_prgmcnt_print;
+#else
+#define ahd_prgmcnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "PRGMCNT", 0xde, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_accum_print;
+#else
+#define ahd_accum_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ACCUM", 0xe0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sindex_print;
+#else
+#define ahd_sindex_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SINDEX", 0xe2, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dindex_print;
+#else
+#define ahd_dindex_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DINDEX", 0xe4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_brkaddr1_print;
+#else
+#define ahd_brkaddr1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "BRKADDR1", 0xe6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_brkaddr0_print;
+#else
+#define ahd_brkaddr0_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "BRKADDR0", 0xe6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_allones_print;
+#else
+#define ahd_allones_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ALLONES", 0xe8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_allzeros_print;
+#else
+#define ahd_allzeros_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ALLZEROS", 0xea, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_none_print;
+#else
+#define ahd_none_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NONE", 0xea, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sindir_print;
+#else
+#define ahd_sindir_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SINDIR", 0xec, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dindir_print;
+#else
+#define ahd_dindir_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DINDIR", 0xed, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_function1_print;
+#else
+#define ahd_function1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "FUNCTION1", 0xf0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_stack_print;
+#else
+#define ahd_stack_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "STACK", 0xf2, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_curaddr_print;
+#else
+#define ahd_curaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CURADDR", 0xf4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_intvec1_addr_print;
+#else
+#define ahd_intvec1_addr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "INTVEC1_ADDR", 0xf4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_intvec2_addr_print;
+#else
+#define ahd_intvec2_addr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "INTVEC2_ADDR", 0xf6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lastaddr_print;
+#else
+#define ahd_lastaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LASTADDR", 0xf6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_longjmp_addr_print;
+#else
+#define ahd_longjmp_addr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LONGJMP_ADDR", 0xf8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_accum_save_print;
+#else
+#define ahd_accum_save_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ACCUM_SAVE", 0xfa, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_waiting_scb_tails_print;
+#else
+#define ahd_waiting_scb_tails_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "WAITING_SCB_TAILS", 0x100, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_ahd_pci_config_base_print;
+#else
+#define ahd_ahd_pci_config_base_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "AHD_PCI_CONFIG_BASE", 0x100, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_sram_base_print;
+#else
+#define ahd_sram_base_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SRAM_BASE", 0x100, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_waiting_tid_head_print;
+#else
+#define ahd_waiting_tid_head_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "WAITING_TID_HEAD", 0x120, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_waiting_tid_tail_print;
+#else
+#define ahd_waiting_tid_tail_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "WAITING_TID_TAIL", 0x122, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_next_queued_scb_addr_print;
+#else
+#define ahd_next_queued_scb_addr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "NEXT_QUEUED_SCB_ADDR", 0x124, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_complete_scb_head_print;
+#else
+#define ahd_complete_scb_head_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "COMPLETE_SCB_HEAD", 0x128, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_complete_scb_dmainprog_head_print;
+#else
+#define ahd_complete_scb_dmainprog_head_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "COMPLETE_SCB_DMAINPROG_HEAD", 0x12a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_complete_dma_scb_head_print;
+#else
+#define ahd_complete_dma_scb_head_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "COMPLETE_DMA_SCB_HEAD", 0x12c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_qfreeze_count_print;
+#else
+#define ahd_qfreeze_count_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "QFREEZE_COUNT", 0x12e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_saved_mode_print;
+#else
+#define ahd_saved_mode_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SAVED_MODE", 0x130, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_msg_out_print;
+#else
+#define ahd_msg_out_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "MSG_OUT", 0x131, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_dmaparams_print;
+#else
+#define ahd_dmaparams_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "DMAPARAMS", 0x132, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seq_flags_print;
+#else
+#define ahd_seq_flags_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQ_FLAGS", 0x133, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_saved_scsiid_print;
+#else
+#define ahd_saved_scsiid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SAVED_SCSIID", 0x134, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_saved_lun_print;
+#else
+#define ahd_saved_lun_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SAVED_LUN", 0x135, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_lastphase_print;
+#else
+#define ahd_lastphase_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LASTPHASE", 0x136, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_qoutfifo_entry_valid_tag_print;
+#else
+#define ahd_qoutfifo_entry_valid_tag_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "QOUTFIFO_ENTRY_VALID_TAG", 0x137, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_shared_data_addr_print;
+#else
+#define ahd_shared_data_addr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SHARED_DATA_ADDR", 0x138, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_qoutfifo_next_addr_print;
+#else
+#define ahd_qoutfifo_next_addr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "QOUTFIFO_NEXT_ADDR", 0x13c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_kernel_tqinpos_print;
+#else
+#define ahd_kernel_tqinpos_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "KERNEL_TQINPOS", 0x140, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_tqinpos_print;
+#else
+#define ahd_tqinpos_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "TQINPOS", 0x141, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_arg_1_print;
+#else
+#define ahd_arg_1_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ARG_1", 0x142, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_arg_2_print;
+#else
+#define ahd_arg_2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ARG_2", 0x143, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_last_msg_print;
+#else
+#define ahd_last_msg_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LAST_MSG", 0x144, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scsiseq_template_print;
+#else
+#define ahd_scsiseq_template_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCSISEQ_TEMPLATE", 0x145, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_initiator_tag_print;
+#else
+#define ahd_initiator_tag_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "INITIATOR_TAG", 0x146, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_seq_flags2_print;
+#else
+#define ahd_seq_flags2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SEQ_FLAGS2", 0x147, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_allocfifo_scbptr_print;
+#else
+#define ahd_allocfifo_scbptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "ALLOCFIFO_SCBPTR", 0x148, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_int_coalescing_timer_print;
+#else
+#define ahd_int_coalescing_timer_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "INT_COALESCING_TIMER", 0x14a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_int_coalescing_maxcmds_print;
+#else
+#define ahd_int_coalescing_maxcmds_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "INT_COALESCING_MAXCMDS", 0x14c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_int_coalescing_mincmds_print;
+#else
+#define ahd_int_coalescing_mincmds_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "INT_COALESCING_MINCMDS", 0x14d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmds_pending_print;
+#else
+#define ahd_cmds_pending_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMDS_PENDING", 0x14e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_int_coalescing_cmdcount_print;
+#else
+#define ahd_int_coalescing_cmdcount_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "INT_COALESCING_CMDCOUNT", 0x150, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_local_hs_mailbox_print;
+#else
+#define ahd_local_hs_mailbox_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "LOCAL_HS_MAILBOX", 0x151, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_cmdsize_table_print;
+#else
+#define ahd_cmdsize_table_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "CMDSIZE_TABLE", 0x152, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_base_print;
+#else
+#define ahd_scb_base_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_BASE", 0x180, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_residual_datacnt_print;
+#else
+#define ahd_scb_residual_datacnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_RESIDUAL_DATACNT", 0x180, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_residual_sgptr_print;
+#else
+#define ahd_scb_residual_sgptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_RESIDUAL_SGPTR", 0x184, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_scsi_status_print;
+#else
+#define ahd_scb_scsi_status_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_SCSI_STATUS", 0x188, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_target_phases_print;
+#else
+#define ahd_scb_target_phases_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_TARGET_PHASES", 0x189, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_target_data_dir_print;
+#else
+#define ahd_scb_target_data_dir_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_TARGET_DATA_DIR", 0x18a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_target_itag_print;
+#else
+#define ahd_scb_target_itag_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_TARGET_ITAG", 0x18b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_sense_busaddr_print;
+#else
+#define ahd_scb_sense_busaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_SENSE_BUSADDR", 0x18c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_tag_print;
+#else
+#define ahd_scb_tag_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_TAG", 0x190, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_control_print;
+#else
+#define ahd_scb_control_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_CONTROL", 0x192, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_scsiid_print;
+#else
+#define ahd_scb_scsiid_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_SCSIID", 0x193, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_lun_print;
+#else
+#define ahd_scb_lun_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_LUN", 0x194, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_task_attribute_print;
+#else
+#define ahd_scb_task_attribute_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_TASK_ATTRIBUTE", 0x195, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_cdb_len_print;
+#else
+#define ahd_scb_cdb_len_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_CDB_LEN", 0x196, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_task_management_print;
+#else
+#define ahd_scb_task_management_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_TASK_MANAGEMENT", 0x197, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_dataptr_print;
+#else
+#define ahd_scb_dataptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_DATAPTR", 0x198, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_datacnt_print;
+#else
+#define ahd_scb_datacnt_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_DATACNT", 0x1a0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_sgptr_print;
+#else
+#define ahd_scb_sgptr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_SGPTR", 0x1a4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_busaddr_print;
+#else
+#define ahd_scb_busaddr_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_BUSADDR", 0x1a8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_next_print;
+#else
+#define ahd_scb_next_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_NEXT", 0x1ac, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_next2_print;
+#else
+#define ahd_scb_next2_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_NEXT2", 0x1ae, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_spare_print;
+#else
+#define ahd_scb_spare_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_SPARE", 0x1b0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahd_reg_print_t ahd_scb_disconnected_lists_print;
+#else
+#define ahd_scb_disconnected_lists_print(regvalue, cur_col, wrap) \
+    ahd_print_register(NULL, 0, "SCB_DISCONNECTED_LISTS", 0x1b8, regvalue, cur_col, wrap)
+#endif
+
+
+#define	MODE_PTR        		0x00
+#define		DST_MODE        	0x70
+#define		SRC_MODE        	0x07
+
+#define	INTSTAT         		0x01
+#define		INT_PEND        	0xff
+#define		HWERRINT        	0x80
+#define		BRKADRINT       	0x40
+#define		SWTMINT         	0x20
+#define		PCIINT          	0x10
+#define		SCSIINT         	0x08
+#define		SEQINT          	0x04
+#define		CMDCMPLT        	0x02
+#define		SPLTINT         	0x01
+
+#define	SEQINTCODE      		0x02
+#define		BAD_SCB_STATUS  	0x1a
+#define		SAW_HWERR       	0x19
+#define		TRACEPOINT3     	0x18
+#define		TRACEPOINT2     	0x17
+#define		TRACEPOINT1     	0x16
+#define		TRACEPOINT0     	0x15
+#define		TASKMGMT_CMD_CMPLT_OKAY	0x14
+#define		TASKMGMT_FUNC_COMPLETE	0x13
+#define		ENTERING_NONPACK	0x12
+#define		CFG4OVERRUN     	0x11
+#define		STATUS_OVERRUN  	0x10
+#define		CFG4ISTAT_INTR  	0x0f
+#define		INVALID_SEQINT  	0x0e
+#define		ILLEGAL_PHASE   	0x0d
+#define		DUMP_CARD_STATE 	0x0c
+#define		MISSED_BUSFREE  	0x0b
+#define		MKMSG_FAILED    	0x0a
+#define		DATA_OVERRUN    	0x09
+#define		BAD_STATUS      	0x08
+#define		HOST_MSG_LOOP   	0x07
+#define		PDATA_REINIT    	0x06
+#define		IGN_WIDE_RES    	0x05
+#define		NO_MATCH        	0x04
+#define		PROTO_VIOLATION 	0x03
+#define		SEND_REJECT     	0x02
+#define		BAD_PHASE       	0x01
+#define		NO_SEQINT       	0x00
+
+#define	CLRINT          		0x03
+#define		CLRHWERRINT     	0x80
+#define		CLRBRKADRINT    	0x40
+#define		CLRSWTMINT      	0x20
+#define		CLRPCIINT       	0x10
+#define		CLRSCSIINT      	0x08
+#define		CLRSEQINT       	0x04
+#define		CLRCMDINT       	0x02
+#define		CLRSPLTINT      	0x01
+
+#define	ERROR           		0x04
+#define		CIOPARERR       	0x80
+#define		CIOACCESFAIL    	0x40
+#define		MPARERR         	0x20
+#define		DPARERR         	0x10
+#define		SQPARERR        	0x08
+#define		ILLOPCODE       	0x04
+#define		DSCTMOUT        	0x02
+
+#define	CLRERR          		0x04
+#define		CLRCIOPARERR    	0x80
+#define		CLRCIOACCESFAIL 	0x40
+#define		CLRMPARERR      	0x20
+#define		CLRDPARERR      	0x10
+#define		CLRSQPARERR     	0x08
+#define		CLRILLOPCODE    	0x04
+#define		CLRDSCTMOUT     	0x02
+
+#define	HCNTRL          		0x05
+#define		SEQ_RESET       	0x80
+#define		POWRDN          	0x40
+#define		SWINT           	0x10
+#define		SWTIMER_START_B 	0x08
+#define		PAUSE           	0x04
+#define		INTEN           	0x02
+#define		CHIPRST         	0x01
+#define		CHIPRSTACK      	0x01
+
+#define	HNSCB_QOFF      		0x06
+
+#define	HESCB_QOFF      		0x08
+
+#define	HS_MAILBOX      		0x0b
+#define		HOST_TQINPOS    	0x80
+#define		ENINT_COALESCE  	0x40
+
+#define	CLRSEQINTSTAT   		0x0c
+#define		CLRSEQ_SWTMRTO  	0x10
+#define		CLRSEQ_SEQINT   	0x08
+#define		CLRSEQ_SCSIINT  	0x04
+#define		CLRSEQ_PCIINT   	0x02
+#define		CLRSEQ_SPLTINT  	0x01
+
+#define	SEQINTSTAT      		0x0c
+#define		SEQ_SWTMRTO     	0x10
+#define		SEQ_SEQINT      	0x08
+#define		SEQ_SCSIINT     	0x04
+#define		SEQ_PCIINT      	0x02
+#define		SEQ_SPLTINT     	0x01
+
+#define	SWTIMER         		0x0e
+
+#define	SNSCB_QOFF      		0x10
+
+#define	SESCB_QOFF      		0x12
+
+#define	SDSCB_QOFF      		0x14
+
+#define	QOFF_CTLSTA     		0x16
+#define		EMPTY_SCB_AVAIL 	0x80
+#define		NEW_SCB_AVAIL   	0x40
+#define		SDSCB_ROLLOVR   	0x20
+#define		HS_MAILBOX_ACT  	0x10
+#define		SCB_QSIZE       	0x0f
+#define		SCB_QSIZE_16384 	0x0c
+#define		SCB_QSIZE_8192  	0x0b
+#define		SCB_QSIZE_4096  	0x0a
+#define		SCB_QSIZE_2048  	0x09
+#define		SCB_QSIZE_1024  	0x08
+#define		SCB_QSIZE_512   	0x07
+#define		SCB_QSIZE_256   	0x06
+#define		SCB_QSIZE_128   	0x05
+#define		SCB_QSIZE_64    	0x04
+#define		SCB_QSIZE_32    	0x03
+#define		SCB_QSIZE_16    	0x02
+#define		SCB_QSIZE_8     	0x01
+#define		SCB_QSIZE_4     	0x00
+
+#define	INTCTL          		0x18
+#define		SWTMINTMASK     	0x80
+#define		SWTMINTEN       	0x40
+#define		SWTIMER_START   	0x20
+#define		AUTOCLRCMDINT   	0x10
+#define		PCIINTEN        	0x08
+#define		SCSIINTEN       	0x04
+#define		SEQINTEN        	0x02
+#define		SPLTINTEN       	0x01
+
+#define	DFCNTRL         		0x19
+#define		SCSIENWRDIS     	0x40
+#define		SCSIENACK       	0x20
+#define		DIRECTIONACK    	0x04
+#define		FIFOFLUSHACK    	0x02
+#define		DIRECTIONEN     	0x01
+
+#define	DSCOMMAND0      		0x19
+#define		CACHETHEN       	0x80
+#define		DPARCKEN        	0x40
+#define		MPARCKEN        	0x20
+#define		EXTREQLCK       	0x10
+#define		DISABLE_TWATE   	0x02
+#define		CIOPARCKEN      	0x01
+
+#define	DFSTATUS        		0x1a
+#define		PRELOAD_AVAIL   	0x80
+#define		PKT_PRELOAD_AVAIL	0x40
+#define		MREQPEND        	0x10
+#define		HDONE           	0x08
+#define		DFTHRESH        	0x04
+#define		FIFOFULL        	0x02
+#define		FIFOEMP         	0x01
+
+#define	SG_CACHE_SHADOW 		0x1b
+#define		ODD_SEG         	0x04
+#define		LAST_SEG        	0x02
+#define		LAST_SEG_DONE   	0x01
+
+#define	ARBCTL          		0x1b
+#define		RESET_HARB      	0x80
+#define		RETRY_SWEN      	0x08
+#define		USE_TIME        	0x07
+
+#define	SG_CACHE_PRE    		0x1b
+
+#define	LQIN            		0x20
+
+#define	TYPEPTR         		0x20
+
+#define	TAGPTR          		0x21
+
+#define	LUNPTR          		0x22
+
+#define	DATALENPTR      		0x23
+
+#define	STATLENPTR      		0x24
+
+#define	CMDLENPTR       		0x25
+
+#define	ATTRPTR         		0x26
+
+#define	FLAGPTR         		0x27
+
+#define	CMDPTR          		0x28
+
+#define	QNEXTPTR        		0x29
+
+#define	IDPTR           		0x2a
+
+#define	ABRTBYTEPTR     		0x2b
+
+#define	ABRTBITPTR      		0x2c
+
+#define	MAXCMDBYTES     		0x2d
+
+#define	MAXCMD2RCV      		0x2e
+
+#define	SHORTTHRESH     		0x2f
+
+#define	LUNLEN          		0x30
+#define		TLUNLEN         	0xf0
+#define		ILUNLEN         	0x0f
+
+#define	CDBLIMIT        		0x31
+
+#define	MAXCMD          		0x32
+
+#define	MAXCMDCNT       		0x33
+
+#define	LQRSVD01        		0x34
+
+#define	LQRSVD16        		0x35
+
+#define	LQRSVD17        		0x36
+
+#define	CMDRSVD0        		0x37
+
+#define	LQCTL0          		0x38
+#define		LQITARGCLT      	0xc0
+#define		LQIINITGCLT     	0x30
+#define		LQ0TARGCLT      	0x0c
+#define		LQ0INITGCLT     	0x03
+
+#define	LQCTL1          		0x38
+#define		PCI2PCI         	0x04
+#define		SINGLECMD       	0x02
+#define		ABORTPENDING    	0x01
+
+#define	SCSBIST0        		0x39
+#define		GSBISTERR       	0x40
+#define		GSBISTDONE      	0x20
+#define		GSBISTRUN       	0x10
+#define		OSBISTERR       	0x04
+#define		OSBISTDONE      	0x02
+#define		OSBISTRUN       	0x01
+
+#define	LQCTL2          		0x39
+#define		LQIRETRY        	0x80
+#define		LQICONTINUE     	0x40
+#define		LQITOIDLE       	0x20
+#define		LQIPAUSE        	0x10
+#define		LQORETRY        	0x08
+#define		LQOCONTINUE     	0x04
+#define		LQOTOIDLE       	0x02
+#define		LQOPAUSE        	0x01
+
+#define	SCSBIST1        		0x3a
+#define		NTBISTERR       	0x04
+#define		NTBISTDONE      	0x02
+#define		NTBISTRUN       	0x01
+
+#define	SCSISEQ0        		0x3a
+#define		TEMODEO         	0x80
+#define		ENSELO          	0x40
+#define		ENARBO          	0x20
+#define		FORCEBUSFREE    	0x10
+#define		SCSIRSTO        	0x01
+
+#define	SCSISEQ1        		0x3b
+
+#define	SXFRCTL0        		0x3c
+#define		DFON            	0x80
+#define		DFPEXP          	0x40
+#define		BIOSCANCELEN    	0x10
+#define		SPIOEN          	0x08
+
+#define	BUSINITID       		0x3c
+
+#define	DLCOUNT         		0x3c
+
+#define	SXFRCTL1        		0x3d
+#define		BITBUCKET       	0x80
+#define		ENSACHK         	0x40
+#define		ENSPCHK         	0x20
+#define		STIMESEL        	0x18
+#define		ENSTIMER        	0x04
+#define		ACTNEGEN        	0x02
+#define		STPWEN          	0x01
+
+#define	BUSTARGID       		0x3e
+
+#define	SXFRCTL2        		0x3e
+#define		AUTORSTDIS      	0x10
+#define		CMDDMAEN        	0x08
+#define		ASU             	0x07
+
+#define	DFFSTAT         		0x3f
+#define		CURRFIFO        	0x03
+#define		FIFO1FREE       	0x20
+#define		FIFO0FREE       	0x10
+#define		CURRFIFO_NONE   	0x03
+#define		CURRFIFO_1      	0x01
+#define		CURRFIFO_0      	0x00
+
+#define	SCSISIGO        		0x40
+#define		CDO             	0x80
+#define		IOO             	0x40
+#define		MSGO            	0x20
+#define		ATNO            	0x10
+#define		SELO            	0x08
+#define		BSYO            	0x04
+#define		REQO            	0x02
+#define		ACKO            	0x01
+
+#define	MULTARGID       		0x40
+
+#define	SCSISIGI        		0x41
+#define		ATNI            	0x10
+#define		SELI            	0x08
+#define		BSYI            	0x04
+#define		REQI            	0x02
+#define		ACKI            	0x01
+
+#define	SCSIPHASE       		0x42
+#define		STATUS_PHASE    	0x20
+#define		COMMAND_PHASE   	0x10
+#define		MSG_IN_PHASE    	0x08
+#define		MSG_OUT_PHASE   	0x04
+#define		DATA_PHASE_MASK 	0x03
+#define		DATA_IN_PHASE   	0x02
+#define		DATA_OUT_PHASE  	0x01
+
+#define	SCSIDAT0_IMG    		0x43
+
+#define	SCSIDAT         		0x44
+
+#define	SCSIBUS         		0x46
+
+#define	TARGIDIN        		0x48
+#define		CLKOUT          	0x80
+#define		TARGID          	0x0f
+
+#define	SELID           		0x49
+#define		SELID_MASK      	0xf0
+#define		ONEBIT          	0x08
+
+#define	SBLKCTL         		0x4a
+#define		DIAGLEDEN       	0x80
+#define		DIAGLEDON       	0x40
+#define		ENAB40          	0x08
+#define		ENAB20          	0x04
+#define		SELWIDE         	0x02
+
+#define	OPTIONMODE      		0x4a
+#define		OPTIONMODE_DEFAULTS	0x02
+#define		BIOSCANCTL      	0x80
+#define		AUTOACKEN       	0x40
+#define		BIASCANCTL      	0x20
+#define		BUSFREEREV      	0x10
+#define		ENDGFORMCHK     	0x04
+#define		AUTO_MSGOUT_DE  	0x02
+
+#define	SSTAT0          		0x4b
+#define		TARGET          	0x80
+#define		SELDO           	0x40
+#define		SELDI           	0x20
+#define		SELINGO         	0x10
+#define		IOERR           	0x08
+#define		OVERRUN         	0x04
+#define		SPIORDY         	0x02
+#define		ARBDO           	0x01
+
+#define	CLRSINT0        		0x4b
+#define		CLRSELDO        	0x40
+#define		CLRSELDI        	0x20
+#define		CLRSELINGO      	0x10
+#define		CLRIOERR        	0x08
+#define		CLROVERRUN      	0x04
+#define		CLRSPIORDY      	0x02
+#define		CLRARBDO        	0x01
+
+#define	SIMODE0         		0x4b
+#define		ENSELDO         	0x40
+#define		ENSELDI         	0x20
+#define		ENSELINGO       	0x10
+#define		ENIOERR         	0x08
+#define		ENOVERRUN       	0x04
+#define		ENSPIORDY       	0x02
+#define		ENARBDO         	0x01
+
+#define	CLRSINT1        		0x4c
+#define		CLRSELTIMEO     	0x80
+#define		CLRATNO         	0x40
+#define		CLRSCSIRSTI     	0x20
+#define		CLRBUSFREE      	0x08
+#define		CLRSCSIPERR     	0x04
+#define		CLRSTRB2FAST    	0x02
+#define		CLRREQINIT      	0x01
+
+#define	SSTAT1          		0x4c
+#define		SELTO           	0x80
+#define		ATNTARG         	0x40
+#define		SCSIRSTI        	0x20
+#define		PHASEMIS        	0x10
+#define		BUSFREE         	0x08
+#define		SCSIPERR        	0x04
+#define		STRB2FAST       	0x02
+#define		REQINIT         	0x01
+
+#define	SSTAT2          		0x4d
+#define		BUSFREETIME     	0xc0
+#define		NONPACKREQ      	0x20
+#define		EXP_ACTIVE      	0x10
+#define		BSYX            	0x08
+#define		WIDE_RES        	0x04
+#define		SDONE           	0x02
+#define		DMADONE         	0x01
+#define		BUSFREE_DFF1    	0xc0
+#define		BUSFREE_DFF0    	0x80
+#define		BUSFREE_LQO     	0x40
+
+#define	CLRSINT2        		0x4d
+#define		CLRNONPACKREQ   	0x20
+#define		CLRWIDE_RES     	0x04
+#define		CLRSDONE        	0x02
+#define		CLRDMADONE      	0x01
+
+#define	SIMODE2         		0x4d
+#define		ENWIDE_RES      	0x04
+#define		ENSDONE         	0x02
+#define		ENDMADONE       	0x01
+
+#define	PERRDIAG        		0x4e
+#define		HIZERO          	0x80
+#define		HIPERR          	0x40
+#define		PREVPHASE       	0x20
+#define		PARITYERR       	0x10
+#define		AIPERR          	0x08
+#define		CRCERR          	0x04
+#define		DGFORMERR       	0x02
+#define		DTERR           	0x01
+
+#define	LQISTATE        		0x4e
+
+#define	SOFFCNT         		0x4f
+
+#define	LQOSTATE        		0x4f
+
+#define	LQISTAT0        		0x50
+#define		LQIATNQAS       	0x20
+#define		LQICRCT1        	0x10
+#define		LQICRCT2        	0x08
+#define		LQIBADLQT       	0x04
+#define		LQIATNLQ        	0x02
+#define		LQIATNCMD       	0x01
+
+#define	CLRLQIINT0      		0x50
+#define		CLRLQIATNQAS    	0x20
+#define		CLRLQICRCT1     	0x10
+#define		CLRLQICRCT2     	0x08
+#define		CLRLQIBADLQT    	0x04
+#define		CLRLQIATNLQ     	0x02
+#define		CLRLQIATNCMD    	0x01
+
+#define	LQIMODE0        		0x50
+#define		ENLQIATNQASK    	0x20
+#define		ENLQICRCT1      	0x10
+#define		ENLQICRCT2      	0x08
+#define		ENLQIBADLQT     	0x04
+#define		ENLQIATNLQ      	0x02
+#define		ENLQIATNCMD     	0x01
+
+#define	LQIMODE1        		0x51
+#define		ENLQIPHASE_LQ   	0x80
+#define		ENLQIPHASE_NLQ  	0x40
+#define		ENLIQABORT      	0x20
+#define		ENLQICRCI_LQ    	0x10
+#define		ENLQICRCI_NLQ   	0x08
+#define		ENLQIBADLQI     	0x04
+#define		ENLQIOVERI_LQ   	0x02
+#define		ENLQIOVERI_NLQ  	0x01
+
+#define	LQISTAT1        		0x51
+#define		LQIPHASE_LQ     	0x80
+#define		LQIPHASE_NLQ    	0x40
+#define		LQIABORT        	0x20
+#define		LQICRCI_LQ      	0x10
+#define		LQICRCI_NLQ     	0x08
+#define		LQIBADLQI       	0x04
+#define		LQIOVERI_LQ     	0x02
+#define		LQIOVERI_NLQ    	0x01
+
+#define	CLRLQIINT1      		0x51
+#define		CLRLQIPHASE_LQ  	0x80
+#define		CLRLQIPHASE_NLQ 	0x40
+#define		CLRLIQABORT     	0x20
+#define		CLRLQICRCI_LQ   	0x10
+#define		CLRLQICRCI_NLQ  	0x08
+#define		CLRLQIBADLQI    	0x04
+#define		CLRLQIOVERI_LQ  	0x02
+#define		CLRLQIOVERI_NLQ 	0x01
+
+#define	LQISTAT2        		0x52
+#define		PACKETIZED      	0x80
+#define		LQIPHASE_OUTPKT 	0x40
+#define		LQIWORKONLQ     	0x20
+#define		LQIWAITFIFO     	0x10
+#define		LQISTOPPKT      	0x08
+#define		LQISTOPLQ       	0x04
+#define		LQISTOPCMD      	0x02
+#define		LQIGSAVAIL      	0x01
+
+#define	SSTAT3          		0x53
+#define		NTRAMPERR       	0x02
+#define		OSRAMPERR       	0x01
+
+#define	SIMODE3         		0x53
+#define		ENNTRAMPERR     	0x02
+#define		ENOSRAMPERR     	0x01
+
+#define	CLRSINT3        		0x53
+#define		CLRNTRAMPERR    	0x02
+#define		CLROSRAMPERR    	0x01
+
+#define	LQOMODE0        		0x54
+#define		ENLQOTARGSCBPERR	0x10
+#define		ENLQOSTOPT2     	0x08
+#define		ENLQOATNLQ      	0x04
+#define		ENLQOATNPKT     	0x02
+#define		ENLQOTCRC       	0x01
+
+#define	LQOSTAT0        		0x54
+#define		LQOTARGSCBPERR  	0x10
+#define		LQOSTOPT2       	0x08
+#define		LQOATNLQ        	0x04
+#define		LQOATNPKT       	0x02
+#define		LQOTCRC         	0x01
+
+#define	CLRLQOINT0      		0x54
+#define		CLRLQOTARGSCBPERR	0x10
+#define		CLRLQOSTOPT2    	0x08
+#define		CLRLQOATNLQ     	0x04
+#define		CLRLQOATNPKT    	0x02
+#define		CLRLQOTCRC      	0x01
+
+#define	LQOSTAT1        		0x55
+#define		LQOINITSCBPERR  	0x10
+#define		LQOSTOPI2       	0x08
+#define		LQOBADQAS       	0x04
+#define		LQOBUSFREE      	0x02
+#define		LQOPHACHGINPKT  	0x01
+
+#define	CLRLQOINT1      		0x55
+#define		CLRLQOINITSCBPERR	0x10
+#define		CLRLQOSTOPI2    	0x08
+#define		CLRLQOBADQAS    	0x04
+#define		CLRLQOBUSFREE   	0x02
+#define		CLRLQOPHACHGINPKT	0x01
+
+#define	LQOMODE1        		0x55
+#define		ENLQOINITSCBPERR	0x10
+#define		ENLQOSTOPI2     	0x08
+#define		ENLQOBADQAS     	0x04
+#define		ENLQOBUSFREE    	0x02
+#define		ENLQOPHACHGINPKT	0x01
+
+#define	LQOSTAT2        		0x56
+#define		LQOPKT          	0xe0
+#define		LQOWAITFIFO     	0x10
+#define		LQOPHACHGOUTPKT 	0x02
+#define		LQOSTOP0        	0x01
+
+#define	OS_SPACE_CNT    		0x56
+
+#define	SIMODE1         		0x57
+#define		ENSELTIMO       	0x80
+#define		ENATNTARG       	0x40
+#define		ENSCSIRST       	0x20
+#define		ENPHASEMIS      	0x10
+#define		ENBUSFREE       	0x08
+#define		ENSCSIPERR      	0x04
+#define		ENSTRB2FAST     	0x02
+#define		ENREQINIT       	0x01
+
+#define	GSFIFO          		0x58
+
+#define	DFFSXFRCTL      		0x5a
+#define		DFFBITBUCKET    	0x08
+#define		CLRSHCNT        	0x04
+#define		CLRCHN          	0x02
+#define		RSTCHN          	0x01
+
+#define	LQOSCSCTL       		0x5a
+#define		LQOH2A_VERSION  	0x80
+#define		LQONOCHKOVER    	0x01
+
+#define	NEXTSCB         		0x5a
+
+#define	CLRSEQINTSRC    		0x5b
+#define		CLRCTXTDONE     	0x40
+#define		CLRSAVEPTRS     	0x20
+#define		CLRCFG4DATA     	0x10
+#define		CLRCFG4ISTAT    	0x08
+#define		CLRCFG4TSTAT    	0x04
+#define		CLRCFG4ICMD     	0x02
+#define		CLRCFG4TCMD     	0x01
+
+#define	SEQINTSRC       		0x5b
+#define		CTXTDONE        	0x40
+#define		SAVEPTRS        	0x20
+#define		CFG4DATA        	0x10
+#define		CFG4ISTAT       	0x08
+#define		CFG4TSTAT       	0x04
+#define		CFG4ICMD        	0x02
+#define		CFG4TCMD        	0x01
+
+#define	CURRSCB         		0x5c
+
+#define	SEQIMODE        		0x5c
+#define		ENCTXTDONE      	0x40
+#define		ENSAVEPTRS      	0x20
+#define		ENCFG4DATA      	0x10
+#define		ENCFG4ISTAT     	0x08
+#define		ENCFG4TSTAT     	0x04
+#define		ENCFG4ICMD      	0x02
+#define		ENCFG4TCMD      	0x01
+
+#define	MDFFSTAT        		0x5d
+#define		SHCNTNEGATIVE   	0x40
+#define		SHCNTMINUS1     	0x20
+#define		LASTSDONE       	0x10
+#define		SHVALID         	0x08
+#define		DLZERO          	0x04
+#define		DATAINFIFO      	0x02
+#define		FIFOFREE        	0x01
+
+#define	CRCCONTROL      		0x5d
+#define		CRCVALCHKEN     	0x40
+
+#define	DFFTAG          		0x5e
+
+#define	LASTSCB         		0x5e
+
+#define	SCSITEST        		0x5e
+#define		CNTRTEST        	0x08
+#define		SEL_TXPLL_DEBUG 	0x04
+
+#define	IOPDNCTL        		0x5f
+#define		DISABLE_OE      	0x80
+#define		PDN_IDIST       	0x04
+#define		PDN_DIFFSENSE   	0x01
+
+#define	SHADDR          		0x60
+
+#define	NEGOADDR        		0x60
+
+#define	DGRPCRCI        		0x60
+
+#define	NEGPERIOD       		0x61
+
+#define	PACKCRCI        		0x62
+
+#define	NEGOFFSET       		0x62
+
+#define	NEGPPROPTS      		0x63
+#define		PPROPT_PACE     	0x08
+#define		PPROPT_QAS      	0x04
+#define		PPROPT_DT       	0x02
+#define		PPROPT_IUT      	0x01
+
+#define	NEGCONOPTS      		0x64
+#define		ENSNAPSHOT      	0x40
+#define		RTI_WRTDIS      	0x20
+#define		RTI_OVRDTRN     	0x10
+#define		ENSLOWCRC       	0x08
+#define		ENAUTOATNI      	0x04
+#define		ENAUTOATNO      	0x02
+#define		WIDEXFER        	0x01
+
+#define	ANNEXCOL        		0x65
+
+#define	SCSCHKN         		0x66
+#define		STSELSKIDDIS    	0x40
+#define		CURRFIFODEF     	0x20
+#define		WIDERESEN       	0x10
+#define		SDONEMSKDIS     	0x08
+#define		DFFACTCLR       	0x04
+#define		SHVALIDSTDIS    	0x02
+#define		LSTSGCLRDIS     	0x01
+
+#define	ANNEXDAT        		0x66
+
+#define	IOWNID          		0x67
+
+#define	PLL960CTL0      		0x68
+
+#define	SHCNT           		0x68
+
+#define	TOWNID          		0x69
+
+#define	PLL960CTL1      		0x69
+
+#define	PLL960CNT0      		0x6a
+
+#define	XSIG            		0x6a
+
+#define	SELOID          		0x6b
+
+#define	PLL400CTL0      		0x6c
+#define		PLL_VCOSEL      	0x80
+#define		PLL_PWDN        	0x40
+#define		PLL_NS          	0x30
+#define		PLL_ENLUD       	0x08
+#define		PLL_ENLPF       	0x04
+#define		PLL_DLPF        	0x02
+#define		PLL_ENFBM       	0x01
+
+#define	FAIRNESS        		0x6c
+
+#define	PLL400CTL1      		0x6d
+#define		PLL_CNTEN       	0x80
+#define		PLL_CNTCLR      	0x40
+#define		PLL_RST         	0x01
+
+#define	PLL400CNT0      		0x6e
+
+#define	UNFAIRNESS      		0x6e
+
+#define	HADDR           		0x70
+
+#define	PLLDELAY        		0x70
+#define		SPLIT_DROP_REQ  	0x80
+
+#define	HODMAADR        		0x70
+
+#define	HODMACNT        		0x78
+
+#define	HCNT            		0x78
+
+#define	HODMAEN         		0x7a
+
+#define	SGHADDR         		0x7c
+
+#define	SCBHADDR        		0x7c
+
+#define	SGHCNT          		0x84
+
+#define	SCBHCNT         		0x84
+
+#define	DFF_THRSH       		0x88
+#define		WR_DFTHRSH      	0x70
+#define		RD_DFTHRSH      	0x07
+#define		WR_DFTHRSH_MAX  	0x70
+#define		WR_DFTHRSH_90   	0x60
+#define		WR_DFTHRSH_85   	0x50
+#define		WR_DFTHRSH_75   	0x40
+#define		WR_DFTHRSH_63   	0x30
+#define		WR_DFTHRSH_50   	0x20
+#define		WR_DFTHRSH_25   	0x10
+#define		RD_DFTHRSH_MAX  	0x07
+#define		RD_DFTHRSH_90   	0x06
+#define		RD_DFTHRSH_85   	0x05
+#define		RD_DFTHRSH_75   	0x04
+#define		RD_DFTHRSH_63   	0x03
+#define		RD_DFTHRSH_50   	0x02
+#define		RD_DFTHRSH_25   	0x01
+#define		WR_DFTHRSH_MIN  	0x00
+#define		RD_DFTHRSH_MIN  	0x00
+
+#define	ROMADDR         		0x8a
+
+#define	ROMCNTRL        		0x8d
+#define		ROMOP           	0xe0
+#define		ROMSPD          	0x18
+#define		REPEAT          	0x02
+#define		RDY             	0x01
+
+#define	ROMDATA         		0x8e
+
+#define	CMCRXMSG0       		0x90
+
+#define	ROENABLE        		0x90
+#define		MSIROEN         	0x20
+#define		OVLYROEN        	0x10
+#define		CMCROEN         	0x08
+#define		SGROEN          	0x04
+#define		DCH1ROEN        	0x02
+#define		DCH0ROEN        	0x01
+
+#define	OVLYRXMSG0      		0x90
+
+#define	DCHRXMSG0       		0x90
+
+#define	OVLYRXMSG1      		0x91
+
+#define	NSENABLE        		0x91
+#define		MSINSEN         	0x20
+#define		OVLYNSEN        	0x10
+#define		CMCNSEN         	0x08
+#define		SGNSEN          	0x04
+#define		DCH1NSEN        	0x02
+#define		DCH0NSEN        	0x01
+
+#define	DCHRXMSG1       		0x91
+
+#define	CMCRXMSG1       		0x91
+
+#define	DCHRXMSG2       		0x92
+
+#define	OVLYRXMSG2      		0x92
+
+#define	CMCRXMSG2       		0x92
+
+#define	OST             		0x92
+
+#define	DCHRXMSG3       		0x93
+
+#define	CMCRXMSG3       		0x93
+
+#define	PCIXCTL         		0x93
+#define		SERRPULSE       	0x80
+#define		UNEXPSCIEN      	0x20
+#define		SPLTSMADIS      	0x10
+#define		SPLTSTADIS      	0x08
+#define		SRSPDPEEN       	0x04
+#define		TSCSERREN       	0x02
+#define		CMPABCDIS       	0x01
+
+#define	OVLYRXMSG3      		0x93
+
+#define	OVLYSEQBCNT     		0x94
+
+#define	CMCSEQBCNT      		0x94
+
+#define	DCHSEQBCNT      		0x94
+
+#define	CMCSPLTSTAT0    		0x96
+
+#define	OVLYSPLTSTAT0   		0x96
+
+#define	DCHSPLTSTAT0    		0x96
+
+#define	DCHSPLTSTAT1    		0x97
+
+#define	CMCSPLTSTAT1    		0x97
+
+#define	OVLYSPLTSTAT1   		0x97
+
+#define	SGRXMSG0        		0x98
+#define		CDNUM           	0xf8
+#define		CFNUM           	0x07
+
+#define	SLVSPLTOUTADR0  		0x98
+#define		LOWER_ADDR      	0x7f
+
+#define	SGRXMSG1        		0x99
+#define		CBNUM           	0xff
+
+#define	SLVSPLTOUTADR1  		0x99
+#define		REQ_DNUM        	0xf8
+#define		REQ_FNUM        	0x07
+
+#define	SGRXMSG2        		0x9a
+#define		MINDEX          	0xff
+
+#define	SLVSPLTOUTADR2  		0x9a
+#define		REQ_BNUM        	0xff
+
+#define	SGRXMSG3        		0x9b
+#define		MCLASS          	0x0f
+
+#define	SLVSPLTOUTADR3  		0x9b
+#define		TAG_NUM         	0x1f
+#define		RLXORD          	0x10
+
+#define	SGSEQBCNT       		0x9c
+
+#define	SLVSPLTOUTATTR0 		0x9c
+#define		LOWER_BCNT      	0xff
+
+#define	SLVSPLTOUTATTR1 		0x9d
+#define		CMPLT_DNUM      	0xf8
+#define		CMPLT_FNUM      	0x07
+
+#define	SLVSPLTOUTATTR2 		0x9e
+#define		CMPLT_BNUM      	0xff
+
+#define	SGSPLTSTAT0     		0x9e
+#define		STAETERM        	0x80
+#define		SCBCERR         	0x40
+#define		SCADERR         	0x20
+#define		SCDATBUCKET     	0x10
+#define		CNTNOTCMPLT     	0x08
+#define		RXOVRUN         	0x04
+#define		RXSCEMSG        	0x02
+#define		RXSPLTRSP       	0x01
+
+#define	SFUNCT          		0x9f
+#define		TEST_GROUP      	0xf0
+#define		TEST_NUM        	0x0f
+
+#define	SGSPLTSTAT1     		0x9f
+#define		RXDATABUCKET    	0x01
+
+#define	DF0PCISTAT      		0xa0
+
+#define	REG0            		0xa0
+
+#define	DF1PCISTAT      		0xa1
+
+#define	SGPCISTAT       		0xa2
+
+#define	REG1            		0xa2
+
+#define	CMCPCISTAT      		0xa3
+
+#define	OVLYPCISTAT     		0xa4
+#define		SCAAPERR        	0x08
+#define		RDPERR          	0x04
+
+#define	REG_ISR         		0xa4
+
+#define	SG_STATE        		0xa6
+#define		FETCH_INPROG    	0x04
+#define		LOADING_NEEDED  	0x02
+#define		SEGS_AVAIL      	0x01
+
+#define	MSIPCISTAT      		0xa6
+#define		RMA             	0x20
+#define		RTA             	0x10
+#define		CLRPENDMSI      	0x08
+#define		DPR             	0x01
+
+#define	TARGPCISTAT     		0xa7
+#define		DPE             	0x80
+#define		SSE             	0x40
+#define		STA             	0x08
+#define		TWATERR         	0x02
+
+#define	DATA_COUNT_ODD  		0xa7
+
+#define	SCBPTR          		0xa8
+
+#define	CCSCBACNT       		0xab
+
+#define	SCBAUTOPTR      		0xab
+#define		AUSCBPTR_EN     	0x80
+#define		SCBPTR_ADDR     	0x38
+#define		SCBPTR_OFF      	0x07
+
+#define	CCSGADDR        		0xac
+
+#define	CCSCBADDR       		0xac
+
+#define	CCSCBADR_BK     		0xac
+
+#define	CMC_RAMBIST     		0xad
+#define		SG_ELEMENT_SIZE 	0x80
+#define		SCBRAMBIST_FAIL 	0x40
+#define		SG_BIST_FAIL    	0x20
+#define		SG_BIST_EN      	0x10
+#define		CMC_BUFFER_BIST_FAIL	0x02
+#define		CMC_BUFFER_BIST_EN	0x01
+
+#define	CCSGCTL         		0xad
+#define		CCSGEN          	0x0c
+#define		CCSGDONE        	0x80
+#define		SG_CACHE_AVAIL  	0x10
+#define		CCSGENACK       	0x08
+#define		SG_FETCH_REQ    	0x02
+#define		CCSGRESET       	0x01
+
+#define	CCSCBCTL        		0xad
+#define		CCSCBDONE       	0x80
+#define		ARRDONE         	0x40
+#define		CCARREN         	0x10
+#define		CCSCBEN         	0x08
+#define		CCSCBDIR        	0x04
+#define		CCSCBRESET      	0x01
+
+#define	CCSGRAM         		0xb0
+
+#define	FLEXADR         		0xb0
+
+#define	CCSCBRAM        		0xb0
+
+#define	FLEXCNT         		0xb3
+
+#define	FLEXDMASTAT     		0xb5
+#define		FLEXDMAERR      	0x02
+#define		FLEXDMADONE     	0x01
+
+#define	FLEXDATA        		0xb6
+
+#define	BRDDAT          		0xb8
+
+#define	BRDCTL          		0xb9
+#define		FLXARBACK       	0x80
+#define		FLXARBREQ       	0x40
+#define		BRDADDR         	0x38
+#define		BRDEN           	0x04
+#define		BRDRW           	0x02
+#define		BRDSTB          	0x01
+
+#define	SEEADR          		0xba
+
+#define	SEEDAT          		0xbc
+
+#define	SEECTL          		0xbe
+#define		SEEOP_EWEN      	0x40
+#define		SEEOP_WALL      	0x40
+#define		SEEOP_EWDS      	0x40
+#define		SEEOPCODE       	0x70
+#define		SEERST          	0x02
+#define		SEESTART        	0x01
+#define		SEEOP_ERASE     	0x70
+#define		SEEOP_READ      	0x60
+#define		SEEOP_WRITE     	0x50
+#define		SEEOP_ERAL      	0x40
+
+#define	SEESTAT         		0xbe
+#define		INIT_DONE       	0x80
+#define		LDALTID_L       	0x08
+#define		SEEARBACK       	0x04
+#define		SEEBUSY         	0x02
+
+#define	SCBCNT          		0xbf
+
+#define	DFWADDR         		0xc0
+
+#define	DSPFLTRCTL      		0xc0
+#define		FLTRDISABLE     	0x20
+#define		EDGESENSE       	0x10
+#define		DSPFCNTSEL      	0x0f
+
+#define	DSPDATACTL      		0xc1
+#define		BYPASSENAB      	0x80
+#define		DESQDIS         	0x10
+#define		RCVROFFSTDIS    	0x04
+#define		XMITOFFSTDIS    	0x02
+
+#define	DFRADDR         		0xc2
+
+#define	DSPREQCTL       		0xc2
+#define		MANREQCTL       	0xc0
+#define		MANREQDLY       	0x3f
+
+#define	DSPACKCTL       		0xc3
+#define		MANACKCTL       	0xc0
+#define		MANACKDLY       	0x3f
+
+#define	DFDAT           		0xc4
+
+#define	DSPSELECT       		0xc4
+#define		AUTOINCEN       	0x80
+#define		DSPSEL          	0x1f
+
+#define	WRTBIASCTL      		0xc5
+#define		AUTOXBCDIS      	0x80
+#define		XMITMANVAL      	0x3f
+
+#define	RCVRBIOSCTL     		0xc6
+#define		AUTORBCDIS      	0x80
+#define		RCVRMANVAL      	0x3f
+
+#define	WRTBIASCALC     		0xc7
+
+#define	DFPTRS          		0xc8
+
+#define	RCVRBIASCALC    		0xc8
+
+#define	DFBKPTR         		0xc9
+
+#define	SKEWCALC        		0xc9
+
+#define	DFDBCTL         		0xcb
+#define		DFF_CIO_WR_RDY  	0x20
+#define		DFF_CIO_RD_RDY  	0x10
+#define		DFF_DIR_ERR     	0x08
+#define		DFF_RAMBIST_FAIL	0x04
+#define		DFF_RAMBIST_DONE	0x02
+#define		DFF_RAMBIST_EN  	0x01
+
+#define	DFSCNT          		0xcc
+
+#define	DFBCNT          		0xce
+
+#define	OVLYADDR        		0xd4
+
+#define	SEQCTL0         		0xd6
+#define		PERRORDIS       	0x80
+#define		PAUSEDIS        	0x40
+#define		FAILDIS         	0x20
+#define		FASTMODE        	0x10
+#define		BRKADRINTEN     	0x08
+#define		STEP            	0x04
+#define		SEQRESET        	0x02
+#define		LOADRAM         	0x01
+
+#define	SEQCTL1         		0xd7
+#define		OVRLAY_DATA_CHK 	0x08
+#define		RAMBIST_DONE    	0x04
+#define		RAMBIST_FAIL    	0x02
+#define		RAMBIST_EN      	0x01
+
+#define	FLAGS           		0xd8
+#define		ZERO            	0x02
+#define		CARRY           	0x01
+
+#define	SEQINTCTL       		0xd9
+#define		INTVEC1DSL      	0x80
+#define		INT1_CONTEXT    	0x20
+#define		SCS_SEQ_INT1M1  	0x10
+#define		SCS_SEQ_INT1M0  	0x08
+#define		INTMASK2        	0x04
+#define		INTMASK1        	0x02
+#define		IRET            	0x01
+
+#define	SEQRAM          		0xda
+
+#define	PRGMCNT         		0xde
+
+#define	ACCUM           		0xe0
+
+#define	SINDEX          		0xe2
+
+#define	DINDEX          		0xe4
+
+#define	BRKADDR1        		0xe6
+#define		BRKDIS          	0x80
+
+#define	BRKADDR0        		0xe6
+
+#define	ALLONES         		0xe8
+
+#define	ALLZEROS        		0xea
+
+#define	NONE            		0xea
+
+#define	SINDIR          		0xec
+
+#define	DINDIR          		0xed
+
+#define	FUNCTION1       		0xf0
+
+#define	STACK           		0xf2
+
+#define	CURADDR         		0xf4
+
+#define	INTVEC1_ADDR    		0xf4
+
+#define	INTVEC2_ADDR    		0xf6
+
+#define	LASTADDR        		0xf6
+
+#define	LONGJMP_ADDR    		0xf8
+
+#define	ACCUM_SAVE      		0xfa
+
+#define	WAITING_SCB_TAILS		0x100
+
+#define	AHD_PCI_CONFIG_BASE		0x100
+
+#define	SRAM_BASE       		0x100
+
+#define	WAITING_TID_HEAD		0x120
+
+#define	WAITING_TID_TAIL		0x122
+
+#define	NEXT_QUEUED_SCB_ADDR		0x124
+
+#define	COMPLETE_SCB_HEAD		0x128
+
+#define	COMPLETE_SCB_DMAINPROG_HEAD		0x12a
+
+#define	COMPLETE_DMA_SCB_HEAD		0x12c
+
+#define	QFREEZE_COUNT   		0x12e
+
+#define	SAVED_MODE      		0x130
+
+#define	MSG_OUT         		0x131
+
+#define	DMAPARAMS       		0x132
+#define		PRELOADEN       	0x80
+#define		WIDEODD         	0x40
+#define		SCSIEN          	0x20
+#define		SDMAEN          	0x10
+#define		SDMAENACK       	0x10
+#define		HDMAENACK       	0x08
+#define		HDMAEN          	0x08
+#define		DIRECTION       	0x04
+#define		FIFOFLUSH       	0x02
+#define		FIFORESET       	0x01
+
+#define	SEQ_FLAGS       		0x133
+#define		NOT_IDENTIFIED  	0x80
+#define		NO_CDB_SENT     	0x40
+#define		TARGET_CMD_IS_TAGGED	0x40
+#define		DPHASE          	0x20
+#define		TARG_CMD_PENDING	0x10
+#define		CMDPHASE_PENDING	0x08
+#define		DPHASE_PENDING  	0x04
+#define		SPHASE_PENDING  	0x02
+#define		NO_DISCONNECT   	0x01
+
+#define	SAVED_SCSIID    		0x134
+
+#define	SAVED_LUN       		0x135
+
+#define	LASTPHASE       		0x136
+#define		PHASE_MASK      	0xe0
+#define		CDI             	0x80
+#define		IOI             	0x40
+#define		MSGI            	0x20
+#define		P_BUSFREE       	0x01
+#define		P_MESGIN        	0xe0
+#define		P_STATUS        	0xc0
+#define		P_MESGOUT       	0xa0
+#define		P_COMMAND       	0x80
+#define		P_DATAIN_DT     	0x60
+#define		P_DATAIN        	0x40
+#define		P_DATAOUT_DT    	0x20
+#define		P_DATAOUT       	0x00
+
+#define	QOUTFIFO_ENTRY_VALID_TAG		0x137
+
+#define	SHARED_DATA_ADDR		0x138
+
+#define	QOUTFIFO_NEXT_ADDR		0x13c
+
+#define	KERNEL_TQINPOS  		0x140
+
+#define	TQINPOS         		0x141
+
+#define	ARG_1           		0x142
+#define	RETURN_1        		0x142
+#define		SEND_MSG        	0x80
+#define		SEND_SENSE      	0x40
+#define		SEND_REJ        	0x20
+#define		MSGOUT_PHASEMIS 	0x10
+#define		EXIT_MSG_LOOP   	0x08
+#define		CONT_MSG_LOOP_WRITE	0x04
+#define		CONT_MSG_LOOP_READ	0x03
+#define		CONT_MSG_LOOP_TARG	0x02
+
+#define	ARG_2           		0x143
+#define	RETURN_2        		0x143
+
+#define	LAST_MSG        		0x144
+
+#define	SCSISEQ_TEMPLATE		0x145
+#define		MANUALCTL       	0x40
+#define		ENSELI          	0x20
+#define		ENRSELI         	0x10
+#define		MANUALP         	0x0c
+#define		ENAUTOATNP      	0x02
+#define		ALTSTIM         	0x01
+
+#define	INITIATOR_TAG   		0x146
+
+#define	SEQ_FLAGS2      		0x147
+#define		SELECTOUT_QFROZEN	0x04
+#define		TARGET_MSG_PENDING	0x02
+
+#define	ALLOCFIFO_SCBPTR		0x148
+
+#define	INT_COALESCING_TIMER		0x14a
+
+#define	INT_COALESCING_MAXCMDS		0x14c
+
+#define	INT_COALESCING_MINCMDS		0x14d
+
+#define	CMDS_PENDING    		0x14e
+
+#define	INT_COALESCING_CMDCOUNT		0x150
+
+#define	LOCAL_HS_MAILBOX		0x151
+
+#define	CMDSIZE_TABLE   		0x152
+
+#define	SCB_BASE        		0x180
+
+#define	SCB_RESIDUAL_DATACNT		0x180
+#define	SCB_CDB_STORE   		0x180
+#define	SCB_HOST_CDB_PTR		0x180
+
+#define	SCB_RESIDUAL_SGPTR		0x184
+#define		SG_ADDR_MASK    	0xf8
+#define		SG_OVERRUN_RESID	0x02
+
+#define	SCB_SCSI_STATUS 		0x188
+#define	SCB_HOST_CDB_LEN		0x188
+
+#define	SCB_TARGET_PHASES		0x189
+
+#define	SCB_TARGET_DATA_DIR		0x18a
+
+#define	SCB_TARGET_ITAG 		0x18b
+
+#define	SCB_SENSE_BUSADDR		0x18c
+#define	SCB_NEXT_COMPLETE		0x18c
+
+#define	SCB_TAG         		0x190
+#define	SCB_FIFO_USE_COUNT		0x190
+
+#define	SCB_CONTROL     		0x192
+#define		TARGET_SCB      	0x80
+#define		DISCENB         	0x40
+#define		TAG_ENB         	0x20
+#define		MK_MESSAGE      	0x10
+#define		STATUS_RCVD     	0x08
+#define		DISCONNECTED    	0x04
+#define		SCB_TAG_TYPE    	0x03
+
+#define	SCB_SCSIID      		0x193
+#define		TID             	0xf0
+#define		OID             	0x0f
+
+#define	SCB_LUN         		0x194
+#define		LID             	0xff
+
+#define	SCB_TASK_ATTRIBUTE		0x195
+#define		SCB_XFERLEN_ODD 	0x01
+
+#define	SCB_CDB_LEN     		0x196
+#define		SCB_CDB_LEN_PTR 	0x80
+
+#define	SCB_TASK_MANAGEMENT		0x197
+
+#define	SCB_DATAPTR     		0x198
+
+#define	SCB_DATACNT     		0x1a0
+#define		SG_LAST_SEG     	0x80
+#define		SG_HIGH_ADDR_BITS	0x7f
+
+#define	SCB_SGPTR       		0x1a4
+#define		SG_STATUS_VALID 	0x04
+#define		SG_FULL_RESID   	0x02
+#define		SG_LIST_NULL    	0x01
+
+#define	SCB_BUSADDR     		0x1a8
+
+#define	SCB_NEXT        		0x1ac
+#define	SCB_NEXT_SCB_BUSADDR		0x1ac
+
+#define	SCB_NEXT2       		0x1ae
+
+#define	SCB_SPARE       		0x1b0
+#define	SCB_PKT_LUN     		0x1b0
+
+#define	SCB_DISCONNECTED_LISTS		0x1b8
+
+
+#define	AHD_TIMER_US_PER_TICK	0x19
+#define	SCB_TRANSFER_SIZE_FULL_LUN	0x38
+#define	STATUS_QUEUE_FULL	0x28
+#define	STATUS_BUSY	0x08
+#define	MAX_OFFSET_NON_PACED	0x7f
+#define	MAX_OFFSET_PACED	0xfe
+#define	BUS_32_BIT	0x02
+#define	CCSGADDR_MAX	0x80
+#define	TID_SHIFT	0x04
+#define	MK_MESSAGE_BIT_OFFSET	0x04
+#define	WRTBIASCTL_HP_DEFAULT	0x00
+#define	SEEOP_EWDS_ADDR	0x00
+#define	AHD_AMPLITUDE_SHIFT	0x00
+#define	AHD_AMPLITUDE_MASK	0x07
+#define	AHD_ANNEXCOL_AMPLITUDE	0x06
+#define	AHD_SLEWRATE_DEF_REVA	0x08
+#define	AHD_SLEWRATE_SHIFT	0x03
+#define	AHD_SLEWRATE_MASK	0x78
+#define	AHD_PRECOMP_CUTBACK_29	0x06
+#define	AHD_NUM_PER_DEV_ANNEXCOLS	0x04
+#define	B_CURRFIFO_0	0x02
+#define	LUNLEN_SINGLE_LEVEL_LUN	0x0f
+#define	NVRAM_SCB_OFFSET	0x2c
+#define	AHD_TIMER_MAX_US	0x18ffe7
+#define	AHD_TIMER_MAX_TICKS	0xffff
+#define	STATUS_PKT_SENSE	0xff
+#define	CMD_GROUP_CODE_SHIFT	0x05
+#define	AHD_SENSE_BUFSIZE	0x100
+#define	MAX_OFFSET_PACED_BUG	0x7f
+#define	BUS_8_BIT	0x00
+#define	STIMESEL_BUG_ADJ	0x08
+#define	STIMESEL_MIN	0x18
+#define	STIMESEL_SHIFT	0x03
+#define	CCSGRAM_MAXSEGS	0x10
+#define	INVALID_ADDR	0x80
+#define	TARGET_CMD_CMPLT	0xfe
+#define	SEEOP_WRAL_ADDR	0x40
+#define	SEEOP_ERAL_ADDR	0x80
+#define	AHD_AMPLITUDE_DEF	0x07
+#define	AHD_SLEWRATE_DEF_REVB	0x08
+#define	AHD_PRECOMP_CUTBACK_37	0x07
+#define	AHD_PRECOMP_CUTBACK_17	0x04
+#define	AHD_PRECOMP_SHIFT	0x00
+#define	AHD_PRECOMP_MASK	0x07
+#define	AHD_ANNEXCOL_PRECOMP_SLEW	0x04
+#define	SRC_MODE_SHIFT	0x00
+#define	PKT_OVERRUN_BUFSIZE	0x200
+#define	SCB_TRANSFER_SIZE_1BYTE_LUN	0x30
+#define	TARGET_DATA_IN	0x01
+#define	HOST_MSG	0xff
+#define	MAX_OFFSET	0xfe
+#define	BUS_16_BIT	0x01
+#define	CCSCBADDR_MAX	0x80
+#define	NUMDSPS 	0x14
+#define	SEEOP_EWEN_ADDR	0xc0
+#define	AHD_ANNEXCOL_PER_DEV0	0x04
+#define	DST_MODE_SHIFT	0x04
+
+
+/* Downloaded Constant Definitions */
+#define	SCB_TRANSFER_SIZE	0x06
+#define	PKT_OVERRUN_BUFOFFSET	0x05
+#define	SG_SIZEOF	0x04
+#define	SG_PREFETCH_ADDR_MASK	0x03
+#define	SG_PREFETCH_ALIGN_MASK	0x02
+#define	SG_PREFETCH_CNT_LIMIT	0x01
+#define	SG_PREFETCH_CNT	0x00
+#define	DOWNLOAD_CONST_COUNT	0x07
+
+
+/* Exported Labels */
+#define	LABEL_seq_isr 	0x269
+#define	LABEL_timer_isr	0x265
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic79xx_reg_print.c linux-5730/drivers/scsi/aic7xxx/aic79xx_reg_print.c
--- linux-5720/drivers/scsi/aic7xxx/aic79xx_reg_print.c
+++ linux-5730/drivers/scsi/aic7xxx/aic79xx_reg_print.c
@@ -0,0 +1,3635 @@
+/*
+ * DO NOT EDIT - This file is automatically generated
+ *		 from the following source files:
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#94 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#70 $
+ */
+
+#include "aic79xx_osm.h"
+
+static ahd_reg_parse_entry_t MODE_PTR_parse_table[] = {
+	{ "SRC_MODE",		0x07, 0x07 },
+	{ "DST_MODE",		0x70, 0x70 }
+};
+
+int
+ahd_mode_ptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(MODE_PTR_parse_table, 2, "MODE_PTR",
+	    0x00, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t INTSTAT_parse_table[] = {
+	{ "SPLTINT",		0x01, 0x01 },
+	{ "CMDCMPLT",		0x02, 0x02 },
+	{ "SEQINT",		0x04, 0x04 },
+	{ "SCSIINT",		0x08, 0x08 },
+	{ "PCIINT",		0x10, 0x10 },
+	{ "SWTMINT",		0x20, 0x20 },
+	{ "BRKADRINT",		0x40, 0x40 },
+	{ "HWERRINT",		0x80, 0x80 },
+	{ "INT_PEND",		0xff, 0xff }
+};
+
+int
+ahd_intstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(INTSTAT_parse_table, 9, "INTSTAT",
+	    0x01, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQINTCODE_parse_table[] = {
+	{ "NO_SEQINT",		0x00, 0xff },
+	{ "BAD_PHASE",		0x01, 0xff },
+	{ "SEND_REJECT",	0x02, 0xff },
+	{ "PROTO_VIOLATION",	0x03, 0xff },
+	{ "NO_MATCH",		0x04, 0xff },
+	{ "IGN_WIDE_RES",	0x05, 0xff },
+	{ "PDATA_REINIT",	0x06, 0xff },
+	{ "HOST_MSG_LOOP",	0x07, 0xff },
+	{ "BAD_STATUS",		0x08, 0xff },
+	{ "DATA_OVERRUN",	0x09, 0xff },
+	{ "MKMSG_FAILED",	0x0a, 0xff },
+	{ "MISSED_BUSFREE",	0x0b, 0xff },
+	{ "DUMP_CARD_STATE",	0x0c, 0xff },
+	{ "ILLEGAL_PHASE",	0x0d, 0xff },
+	{ "INVALID_SEQINT",	0x0e, 0xff },
+	{ "CFG4ISTAT_INTR",	0x0f, 0xff },
+	{ "STATUS_OVERRUN",	0x10, 0xff },
+	{ "CFG4OVERRUN",	0x11, 0xff },
+	{ "ENTERING_NONPACK",	0x12, 0xff },
+	{ "TASKMGMT_FUNC_COMPLETE",0x13, 0xff },
+	{ "TASKMGMT_CMD_CMPLT_OKAY",0x14, 0xff },
+	{ "TRACEPOINT0",	0x15, 0xff },
+	{ "TRACEPOINT1",	0x16, 0xff },
+	{ "TRACEPOINT2",	0x17, 0xff },
+	{ "TRACEPOINT3",	0x18, 0xff },
+	{ "SAW_HWERR",		0x19, 0xff },
+	{ "BAD_SCB_STATUS",	0x1a, 0xff }
+};
+
+int
+ahd_seqintcode_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQINTCODE_parse_table, 27, "SEQINTCODE",
+	    0x02, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRINT_parse_table[] = {
+	{ "CLRSPLTINT",		0x01, 0x01 },
+	{ "CLRCMDINT",		0x02, 0x02 },
+	{ "CLRSEQINT",		0x04, 0x04 },
+	{ "CLRSCSIINT",		0x08, 0x08 },
+	{ "CLRPCIINT",		0x10, 0x10 },
+	{ "CLRSWTMINT",		0x20, 0x20 },
+	{ "CLRBRKADRINT",	0x40, 0x40 },
+	{ "CLRHWERRINT",	0x80, 0x80 }
+};
+
+int
+ahd_clrint_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRINT_parse_table, 8, "CLRINT",
+	    0x03, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t ERROR_parse_table[] = {
+	{ "DSCTMOUT",		0x02, 0x02 },
+	{ "ILLOPCODE",		0x04, 0x04 },
+	{ "SQPARERR",		0x08, 0x08 },
+	{ "DPARERR",		0x10, 0x10 },
+	{ "MPARERR",		0x20, 0x20 },
+	{ "CIOACCESFAIL",	0x40, 0x40 },
+	{ "CIOPARERR",		0x80, 0x80 }
+};
+
+int
+ahd_error_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(ERROR_parse_table, 7, "ERROR",
+	    0x04, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRERR_parse_table[] = {
+	{ "CLRDSCTMOUT",	0x02, 0x02 },
+	{ "CLRILLOPCODE",	0x04, 0x04 },
+	{ "CLRSQPARERR",	0x08, 0x08 },
+	{ "CLRDPARERR",		0x10, 0x10 },
+	{ "CLRMPARERR",		0x20, 0x20 },
+	{ "CLRCIOACCESFAIL",	0x40, 0x40 },
+	{ "CLRCIOPARERR",	0x80, 0x80 }
+};
+
+int
+ahd_clrerr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRERR_parse_table, 7, "CLRERR",
+	    0x04, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t HCNTRL_parse_table[] = {
+	{ "CHIPRST",		0x01, 0x01 },
+	{ "CHIPRSTACK",		0x01, 0x01 },
+	{ "INTEN",		0x02, 0x02 },
+	{ "PAUSE",		0x04, 0x04 },
+	{ "SWTIMER_START_B",	0x08, 0x08 },
+	{ "SWINT",		0x10, 0x10 },
+	{ "POWRDN",		0x40, 0x40 },
+	{ "SEQ_RESET",		0x80, 0x80 }
+};
+
+int
+ahd_hcntrl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(HCNTRL_parse_table, 8, "HCNTRL",
+	    0x05, regvalue, cur_col, wrap));
+}
+
+int
+ahd_hnscb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "HNSCB_QOFF",
+	    0x06, regvalue, cur_col, wrap));
+}
+
+int
+ahd_hescb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "HESCB_QOFF",
+	    0x08, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t HS_MAILBOX_parse_table[] = {
+	{ "ENINT_COALESCE",	0x40, 0x40 },
+	{ "HOST_TQINPOS",	0x80, 0x80 }
+};
+
+int
+ahd_hs_mailbox_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(HS_MAILBOX_parse_table, 2, "HS_MAILBOX",
+	    0x0b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRSEQINTSTAT_parse_table[] = {
+	{ "CLRSEQ_SPLTINT",	0x01, 0x01 },
+	{ "CLRSEQ_PCIINT",	0x02, 0x02 },
+	{ "CLRSEQ_SCSIINT",	0x04, 0x04 },
+	{ "CLRSEQ_SEQINT",	0x08, 0x08 },
+	{ "CLRSEQ_SWTMRTO",	0x10, 0x10 }
+};
+
+int
+ahd_clrseqintstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRSEQINTSTAT_parse_table, 5, "CLRSEQINTSTAT",
+	    0x0c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQINTSTAT_parse_table[] = {
+	{ "SEQ_SPLTINT",	0x01, 0x01 },
+	{ "SEQ_PCIINT",		0x02, 0x02 },
+	{ "SEQ_SCSIINT",	0x04, 0x04 },
+	{ "SEQ_SEQINT",		0x08, 0x08 },
+	{ "SEQ_SWTMRTO",	0x10, 0x10 }
+};
+
+int
+ahd_seqintstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQINTSTAT_parse_table, 5, "SEQINTSTAT",
+	    0x0c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_swtimer_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SWTIMER",
+	    0x0e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_snscb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SNSCB_QOFF",
+	    0x10, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sescb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SESCB_QOFF",
+	    0x12, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sdscb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SDSCB_QOFF",
+	    0x14, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t QOFF_CTLSTA_parse_table[] = {
+	{ "SCB_QSIZE_4",	0x00, 0x0f },
+	{ "SCB_QSIZE_8",	0x01, 0x0f },
+	{ "SCB_QSIZE_16",	0x02, 0x0f },
+	{ "SCB_QSIZE_32",	0x03, 0x0f },
+	{ "SCB_QSIZE_64",	0x04, 0x0f },
+	{ "SCB_QSIZE_128",	0x05, 0x0f },
+	{ "SCB_QSIZE_256",	0x06, 0x0f },
+	{ "SCB_QSIZE_512",	0x07, 0x0f },
+	{ "SCB_QSIZE_1024",	0x08, 0x0f },
+	{ "SCB_QSIZE_2048",	0x09, 0x0f },
+	{ "SCB_QSIZE_4096",	0x0a, 0x0f },
+	{ "SCB_QSIZE_8192",	0x0b, 0x0f },
+	{ "SCB_QSIZE_16384",	0x0c, 0x0f },
+	{ "SCB_QSIZE",		0x0f, 0x0f },
+	{ "HS_MAILBOX_ACT",	0x10, 0x10 },
+	{ "SDSCB_ROLLOVR",	0x20, 0x20 },
+	{ "NEW_SCB_AVAIL",	0x40, 0x40 },
+	{ "EMPTY_SCB_AVAIL",	0x80, 0x80 }
+};
+
+int
+ahd_qoff_ctlsta_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(QOFF_CTLSTA_parse_table, 18, "QOFF_CTLSTA",
+	    0x16, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t INTCTL_parse_table[] = {
+	{ "SPLTINTEN",		0x01, 0x01 },
+	{ "SEQINTEN",		0x02, 0x02 },
+	{ "SCSIINTEN",		0x04, 0x04 },
+	{ "PCIINTEN",		0x08, 0x08 },
+	{ "AUTOCLRCMDINT",	0x10, 0x10 },
+	{ "SWTIMER_START",	0x20, 0x20 },
+	{ "SWTMINTEN",		0x40, 0x40 },
+	{ "SWTMINTMASK",	0x80, 0x80 }
+};
+
+int
+ahd_intctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(INTCTL_parse_table, 8, "INTCTL",
+	    0x18, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DFCNTRL_parse_table[] = {
+	{ "DIRECTIONEN",	0x01, 0x01 },
+	{ "FIFOFLUSH",		0x02, 0x02 },
+	{ "FIFOFLUSHACK",	0x02, 0x02 },
+	{ "DIRECTION",		0x04, 0x04 },
+	{ "DIRECTIONACK",	0x04, 0x04 },
+	{ "HDMAEN",		0x08, 0x08 },
+	{ "HDMAENACK",		0x08, 0x08 },
+	{ "SCSIEN",		0x20, 0x20 },
+	{ "SCSIENACK",		0x20, 0x20 },
+	{ "SCSIENWRDIS",	0x40, 0x40 },
+	{ "PRELOADEN",		0x80, 0x80 }
+};
+
+int
+ahd_dfcntrl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DFCNTRL_parse_table, 11, "DFCNTRL",
+	    0x19, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DSCOMMAND0_parse_table[] = {
+	{ "CIOPARCKEN",		0x01, 0x01 },
+	{ "DISABLE_TWATE",	0x02, 0x02 },
+	{ "EXTREQLCK",		0x10, 0x10 },
+	{ "MPARCKEN",		0x20, 0x20 },
+	{ "DPARCKEN",		0x40, 0x40 },
+	{ "CACHETHEN",		0x80, 0x80 }
+};
+
+int
+ahd_dscommand0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DSCOMMAND0_parse_table, 6, "DSCOMMAND0",
+	    0x19, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DFSTATUS_parse_table[] = {
+	{ "FIFOEMP",		0x01, 0x01 },
+	{ "FIFOFULL",		0x02, 0x02 },
+	{ "DFTHRESH",		0x04, 0x04 },
+	{ "HDONE",		0x08, 0x08 },
+	{ "MREQPEND",		0x10, 0x10 },
+	{ "PKT_PRELOAD_AVAIL",	0x40, 0x40 },
+	{ "PRELOAD_AVAIL",	0x80, 0x80 }
+};
+
+int
+ahd_dfstatus_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DFSTATUS_parse_table, 7, "DFSTATUS",
+	    0x1a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SG_CACHE_SHADOW_parse_table[] = {
+	{ "LAST_SEG_DONE",	0x01, 0x01 },
+	{ "LAST_SEG",		0x02, 0x02 },
+	{ "ODD_SEG",		0x04, 0x04 },
+	{ "SG_ADDR_MASK",	0xf8, 0xf8 }
+};
+
+int
+ahd_sg_cache_shadow_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SG_CACHE_SHADOW_parse_table, 4, "SG_CACHE_SHADOW",
+	    0x1b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t ARBCTL_parse_table[] = {
+	{ "USE_TIME",		0x07, 0x07 },
+	{ "RETRY_SWEN",		0x08, 0x08 },
+	{ "RESET_HARB",		0x80, 0x80 }
+};
+
+int
+ahd_arbctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(ARBCTL_parse_table, 3, "ARBCTL",
+	    0x1b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SG_CACHE_PRE_parse_table[] = {
+	{ "LAST_SEG",		0x02, 0x02 },
+	{ "ODD_SEG",		0x04, 0x04 },
+	{ "SG_ADDR_MASK",	0xf8, 0xf8 }
+};
+
+int
+ahd_sg_cache_pre_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SG_CACHE_PRE_parse_table, 3, "SG_CACHE_PRE",
+	    0x1b, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lqin_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LQIN",
+	    0x20, regvalue, cur_col, wrap));
+}
+
+int
+ahd_typeptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "TYPEPTR",
+	    0x20, regvalue, cur_col, wrap));
+}
+
+int
+ahd_tagptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "TAGPTR",
+	    0x21, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lunptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LUNPTR",
+	    0x22, regvalue, cur_col, wrap));
+}
+
+int
+ahd_datalenptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DATALENPTR",
+	    0x23, regvalue, cur_col, wrap));
+}
+
+int
+ahd_statlenptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "STATLENPTR",
+	    0x24, regvalue, cur_col, wrap));
+}
+
+int
+ahd_cmdlenptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CMDLENPTR",
+	    0x25, regvalue, cur_col, wrap));
+}
+
+int
+ahd_attrptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ATTRPTR",
+	    0x26, regvalue, cur_col, wrap));
+}
+
+int
+ahd_flagptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "FLAGPTR",
+	    0x27, regvalue, cur_col, wrap));
+}
+
+int
+ahd_cmdptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CMDPTR",
+	    0x28, regvalue, cur_col, wrap));
+}
+
+int
+ahd_qnextptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "QNEXTPTR",
+	    0x29, regvalue, cur_col, wrap));
+}
+
+int
+ahd_idptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "IDPTR",
+	    0x2a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_abrtbyteptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ABRTBYTEPTR",
+	    0x2b, regvalue, cur_col, wrap));
+}
+
+int
+ahd_abrtbitptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ABRTBITPTR",
+	    0x2c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_maxcmdbytes_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "MAXCMDBYTES",
+	    0x2d, regvalue, cur_col, wrap));
+}
+
+int
+ahd_maxcmd2rcv_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "MAXCMD2RCV",
+	    0x2e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_shortthresh_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SHORTTHRESH",
+	    0x2f, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LUNLEN_parse_table[] = {
+	{ "ILUNLEN",		0x0f, 0x0f },
+	{ "TLUNLEN",		0xf0, 0xf0 }
+};
+
+int
+ahd_lunlen_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LUNLEN_parse_table, 2, "LUNLEN",
+	    0x30, regvalue, cur_col, wrap));
+}
+
+int
+ahd_cdblimit_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CDBLIMIT",
+	    0x31, regvalue, cur_col, wrap));
+}
+
+int
+ahd_maxcmd_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "MAXCMD",
+	    0x32, regvalue, cur_col, wrap));
+}
+
+int
+ahd_maxcmdcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "MAXCMDCNT",
+	    0x33, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lqrsvd01_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LQRSVD01",
+	    0x34, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lqrsvd16_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LQRSVD16",
+	    0x35, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lqrsvd17_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LQRSVD17",
+	    0x36, regvalue, cur_col, wrap));
+}
+
+int
+ahd_cmdrsvd0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CMDRSVD0",
+	    0x37, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQCTL0_parse_table[] = {
+	{ "LQ0INITGCLT",	0x03, 0x03 },
+	{ "LQ0TARGCLT",		0x0c, 0x0c },
+	{ "LQIINITGCLT",	0x30, 0x30 },
+	{ "LQITARGCLT",		0xc0, 0xc0 }
+};
+
+int
+ahd_lqctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQCTL0_parse_table, 4, "LQCTL0",
+	    0x38, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQCTL1_parse_table[] = {
+	{ "ABORTPENDING",	0x01, 0x01 },
+	{ "SINGLECMD",		0x02, 0x02 },
+	{ "PCI2PCI",		0x04, 0x04 }
+};
+
+int
+ahd_lqctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQCTL1_parse_table, 3, "LQCTL1",
+	    0x38, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSBIST0_parse_table[] = {
+	{ "OSBISTRUN",		0x01, 0x01 },
+	{ "OSBISTDONE",		0x02, 0x02 },
+	{ "OSBISTERR",		0x04, 0x04 },
+	{ "GSBISTRUN",		0x10, 0x10 },
+	{ "GSBISTDONE",		0x20, 0x20 },
+	{ "GSBISTERR",		0x40, 0x40 }
+};
+
+int
+ahd_scsbist0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSBIST0_parse_table, 6, "SCSBIST0",
+	    0x39, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQCTL2_parse_table[] = {
+	{ "LQOPAUSE",		0x01, 0x01 },
+	{ "LQOTOIDLE",		0x02, 0x02 },
+	{ "LQOCONTINUE",	0x04, 0x04 },
+	{ "LQORETRY",		0x08, 0x08 },
+	{ "LQIPAUSE",		0x10, 0x10 },
+	{ "LQITOIDLE",		0x20, 0x20 },
+	{ "LQICONTINUE",	0x40, 0x40 },
+	{ "LQIRETRY",		0x80, 0x80 }
+};
+
+int
+ahd_lqctl2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQCTL2_parse_table, 8, "LQCTL2",
+	    0x39, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSBIST1_parse_table[] = {
+	{ "NTBISTRUN",		0x01, 0x01 },
+	{ "NTBISTDONE",		0x02, 0x02 },
+	{ "NTBISTERR",		0x04, 0x04 }
+};
+
+int
+ahd_scsbist1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSBIST1_parse_table, 3, "SCSBIST1",
+	    0x3a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSISEQ0_parse_table[] = {
+	{ "SCSIRSTO",		0x01, 0x01 },
+	{ "FORCEBUSFREE",	0x10, 0x10 },
+	{ "ENARBO",		0x20, 0x20 },
+	{ "ENSELO",		0x40, 0x40 },
+	{ "TEMODEO",		0x80, 0x80 }
+};
+
+int
+ahd_scsiseq0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSISEQ0_parse_table, 5, "SCSISEQ0",
+	    0x3a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSISEQ1_parse_table[] = {
+	{ "ALTSTIM",		0x01, 0x01 },
+	{ "ENAUTOATNP",		0x02, 0x02 },
+	{ "MANUALP",		0x0c, 0x0c },
+	{ "ENRSELI",		0x10, 0x10 },
+	{ "ENSELI",		0x20, 0x20 },
+	{ "MANUALCTL",		0x40, 0x40 }
+};
+
+int
+ahd_scsiseq1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSISEQ1_parse_table, 6, "SCSISEQ1",
+	    0x3b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SXFRCTL0_parse_table[] = {
+	{ "SPIOEN",		0x08, 0x08 },
+	{ "BIOSCANCELEN",	0x10, 0x10 },
+	{ "DFPEXP",		0x40, 0x40 },
+	{ "DFON",		0x80, 0x80 }
+};
+
+int
+ahd_sxfrctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SXFRCTL0_parse_table, 4, "SXFRCTL0",
+	    0x3c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_businitid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "BUSINITID",
+	    0x3c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dlcount_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DLCOUNT",
+	    0x3c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SXFRCTL1_parse_table[] = {
+	{ "STPWEN",		0x01, 0x01 },
+	{ "ACTNEGEN",		0x02, 0x02 },
+	{ "ENSTIMER",		0x04, 0x04 },
+	{ "STIMESEL",		0x18, 0x18 },
+	{ "ENSPCHK",		0x20, 0x20 },
+	{ "ENSACHK",		0x40, 0x40 },
+	{ "BITBUCKET",		0x80, 0x80 }
+};
+
+int
+ahd_sxfrctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SXFRCTL1_parse_table, 7, "SXFRCTL1",
+	    0x3d, regvalue, cur_col, wrap));
+}
+
+int
+ahd_bustargid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "BUSTARGID",
+	    0x3e, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SXFRCTL2_parse_table[] = {
+	{ "ASU",		0x07, 0x07 },
+	{ "CMDDMAEN",		0x08, 0x08 },
+	{ "AUTORSTDIS",		0x10, 0x10 }
+};
+
+int
+ahd_sxfrctl2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SXFRCTL2_parse_table, 3, "SXFRCTL2",
+	    0x3e, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DFFSTAT_parse_table[] = {
+	{ "CURRFIFO_0",		0x00, 0x03 },
+	{ "CURRFIFO_1",		0x01, 0x03 },
+	{ "CURRFIFO_NONE",	0x03, 0x03 },
+	{ "FIFO0FREE",		0x10, 0x10 },
+	{ "FIFO1FREE",		0x20, 0x20 },
+	{ "CURRFIFO",		0x03, 0x03 }
+};
+
+int
+ahd_dffstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DFFSTAT_parse_table, 6, "DFFSTAT",
+	    0x3f, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSISIGO_parse_table[] = {
+	{ "P_DATAOUT",		0x00, 0xe0 },
+	{ "P_DATAOUT_DT",	0x20, 0xe0 },
+	{ "P_DATAIN",		0x40, 0xe0 },
+	{ "P_DATAIN_DT",	0x60, 0xe0 },
+	{ "P_COMMAND",		0x80, 0xe0 },
+	{ "P_MESGOUT",		0xa0, 0xe0 },
+	{ "P_STATUS",		0xc0, 0xe0 },
+	{ "P_MESGIN",		0xe0, 0xe0 },
+	{ "ACKO",		0x01, 0x01 },
+	{ "REQO",		0x02, 0x02 },
+	{ "BSYO",		0x04, 0x04 },
+	{ "SELO",		0x08, 0x08 },
+	{ "ATNO",		0x10, 0x10 },
+	{ "MSGO",		0x20, 0x20 },
+	{ "IOO",		0x40, 0x40 },
+	{ "CDO",		0x80, 0x80 },
+	{ "PHASE_MASK",		0xe0, 0xe0 }
+};
+
+int
+ahd_scsisigo_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSISIGO_parse_table, 17, "SCSISIGO",
+	    0x40, regvalue, cur_col, wrap));
+}
+
+int
+ahd_multargid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "MULTARGID",
+	    0x40, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSISIGI_parse_table[] = {
+	{ "P_DATAOUT",		0x00, 0xe0 },
+	{ "P_DATAOUT_DT",	0x20, 0xe0 },
+	{ "P_DATAIN",		0x40, 0xe0 },
+	{ "P_DATAIN_DT",	0x60, 0xe0 },
+	{ "P_COMMAND",		0x80, 0xe0 },
+	{ "P_MESGOUT",		0xa0, 0xe0 },
+	{ "P_STATUS",		0xc0, 0xe0 },
+	{ "P_MESGIN",		0xe0, 0xe0 },
+	{ "ACKI",		0x01, 0x01 },
+	{ "REQI",		0x02, 0x02 },
+	{ "BSYI",		0x04, 0x04 },
+	{ "SELI",		0x08, 0x08 },
+	{ "ATNI",		0x10, 0x10 },
+	{ "MSGI",		0x20, 0x20 },
+	{ "IOI",		0x40, 0x40 },
+	{ "CDI",		0x80, 0x80 },
+	{ "PHASE_MASK",		0xe0, 0xe0 }
+};
+
+int
+ahd_scsisigi_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSISIGI_parse_table, 17, "SCSISIGI",
+	    0x41, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSIPHASE_parse_table[] = {
+	{ "DATA_OUT_PHASE",	0x01, 0x03 },
+	{ "DATA_IN_PHASE",	0x02, 0x03 },
+	{ "DATA_PHASE_MASK",	0x03, 0x03 },
+	{ "MSG_OUT_PHASE",	0x04, 0x04 },
+	{ "MSG_IN_PHASE",	0x08, 0x08 },
+	{ "COMMAND_PHASE",	0x10, 0x10 },
+	{ "STATUS_PHASE",	0x20, 0x20 }
+};
+
+int
+ahd_scsiphase_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSIPHASE_parse_table, 7, "SCSIPHASE",
+	    0x42, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scsidat0_img_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCSIDAT0_IMG",
+	    0x43, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scsidat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCSIDAT",
+	    0x44, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scsibus_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCSIBUS",
+	    0x46, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t TARGIDIN_parse_table[] = {
+	{ "TARGID",		0x0f, 0x0f },
+	{ "CLKOUT",		0x80, 0x80 }
+};
+
+int
+ahd_targidin_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(TARGIDIN_parse_table, 2, "TARGIDIN",
+	    0x48, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SELID_parse_table[] = {
+	{ "ONEBIT",		0x08, 0x08 },
+	{ "SELID_MASK",		0xf0, 0xf0 }
+};
+
+int
+ahd_selid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SELID_parse_table, 2, "SELID",
+	    0x49, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SBLKCTL_parse_table[] = {
+	{ "SELWIDE",		0x02, 0x02 },
+	{ "ENAB20",		0x04, 0x04 },
+	{ "ENAB40",		0x08, 0x08 },
+	{ "DIAGLEDON",		0x40, 0x40 },
+	{ "DIAGLEDEN",		0x80, 0x80 }
+};
+
+int
+ahd_sblkctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SBLKCTL_parse_table, 5, "SBLKCTL",
+	    0x4a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OPTIONMODE_parse_table[] = {
+	{ "AUTO_MSGOUT_DE",	0x02, 0x02 },
+	{ "ENDGFORMCHK",	0x04, 0x04 },
+	{ "BUSFREEREV",		0x10, 0x10 },
+	{ "BIASCANCTL",		0x20, 0x20 },
+	{ "AUTOACKEN",		0x40, 0x40 },
+	{ "BIOSCANCTL",		0x80, 0x80 },
+	{ "OPTIONMODE_DEFAULTS",0x02, 0x02 }
+};
+
+int
+ahd_optionmode_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OPTIONMODE_parse_table, 7, "OPTIONMODE",
+	    0x4a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SSTAT0_parse_table[] = {
+	{ "ARBDO",		0x01, 0x01 },
+	{ "SPIORDY",		0x02, 0x02 },
+	{ "OVERRUN",		0x04, 0x04 },
+	{ "IOERR",		0x08, 0x08 },
+	{ "SELINGO",		0x10, 0x10 },
+	{ "SELDI",		0x20, 0x20 },
+	{ "SELDO",		0x40, 0x40 },
+	{ "TARGET",		0x80, 0x80 }
+};
+
+int
+ahd_sstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SSTAT0_parse_table, 8, "SSTAT0",
+	    0x4b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRSINT0_parse_table[] = {
+	{ "CLRARBDO",		0x01, 0x01 },
+	{ "CLRSPIORDY",		0x02, 0x02 },
+	{ "CLROVERRUN",		0x04, 0x04 },
+	{ "CLRIOERR",		0x08, 0x08 },
+	{ "CLRSELINGO",		0x10, 0x10 },
+	{ "CLRSELDI",		0x20, 0x20 },
+	{ "CLRSELDO",		0x40, 0x40 }
+};
+
+int
+ahd_clrsint0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRSINT0_parse_table, 7, "CLRSINT0",
+	    0x4b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SIMODE0_parse_table[] = {
+	{ "ENARBDO",		0x01, 0x01 },
+	{ "ENSPIORDY",		0x02, 0x02 },
+	{ "ENOVERRUN",		0x04, 0x04 },
+	{ "ENIOERR",		0x08, 0x08 },
+	{ "ENSELINGO",		0x10, 0x10 },
+	{ "ENSELDI",		0x20, 0x20 },
+	{ "ENSELDO",		0x40, 0x40 }
+};
+
+int
+ahd_simode0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SIMODE0_parse_table, 7, "SIMODE0",
+	    0x4b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRSINT1_parse_table[] = {
+	{ "CLRREQINIT",		0x01, 0x01 },
+	{ "CLRSTRB2FAST",	0x02, 0x02 },
+	{ "CLRSCSIPERR",	0x04, 0x04 },
+	{ "CLRBUSFREE",		0x08, 0x08 },
+	{ "CLRSCSIRSTI",	0x20, 0x20 },
+	{ "CLRATNO",		0x40, 0x40 },
+	{ "CLRSELTIMEO",	0x80, 0x80 }
+};
+
+int
+ahd_clrsint1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRSINT1_parse_table, 7, "CLRSINT1",
+	    0x4c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SSTAT1_parse_table[] = {
+	{ "REQINIT",		0x01, 0x01 },
+	{ "STRB2FAST",		0x02, 0x02 },
+	{ "SCSIPERR",		0x04, 0x04 },
+	{ "BUSFREE",		0x08, 0x08 },
+	{ "PHASEMIS",		0x10, 0x10 },
+	{ "SCSIRSTI",		0x20, 0x20 },
+	{ "ATNTARG",		0x40, 0x40 },
+	{ "SELTO",		0x80, 0x80 }
+};
+
+int
+ahd_sstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SSTAT1_parse_table, 8, "SSTAT1",
+	    0x4c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SSTAT2_parse_table[] = {
+	{ "BUSFREE_LQO",	0x40, 0xc0 },
+	{ "BUSFREE_DFF0",	0x80, 0xc0 },
+	{ "BUSFREE_DFF1",	0xc0, 0xc0 },
+	{ "DMADONE",		0x01, 0x01 },
+	{ "SDONE",		0x02, 0x02 },
+	{ "WIDE_RES",		0x04, 0x04 },
+	{ "BSYX",		0x08, 0x08 },
+	{ "EXP_ACTIVE",		0x10, 0x10 },
+	{ "NONPACKREQ",		0x20, 0x20 },
+	{ "BUSFREETIME",	0xc0, 0xc0 }
+};
+
+int
+ahd_sstat2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SSTAT2_parse_table, 10, "SSTAT2",
+	    0x4d, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRSINT2_parse_table[] = {
+	{ "CLRDMADONE",		0x01, 0x01 },
+	{ "CLRSDONE",		0x02, 0x02 },
+	{ "CLRWIDE_RES",	0x04, 0x04 },
+	{ "CLRNONPACKREQ",	0x20, 0x20 }
+};
+
+int
+ahd_clrsint2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRSINT2_parse_table, 4, "CLRSINT2",
+	    0x4d, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SIMODE2_parse_table[] = {
+	{ "ENDMADONE",		0x01, 0x01 },
+	{ "ENSDONE",		0x02, 0x02 },
+	{ "ENWIDE_RES",		0x04, 0x04 }
+};
+
+int
+ahd_simode2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SIMODE2_parse_table, 3, "SIMODE2",
+	    0x4d, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t PERRDIAG_parse_table[] = {
+	{ "DTERR",		0x01, 0x01 },
+	{ "DGFORMERR",		0x02, 0x02 },
+	{ "CRCERR",		0x04, 0x04 },
+	{ "AIPERR",		0x08, 0x08 },
+	{ "PARITYERR",		0x10, 0x10 },
+	{ "PREVPHASE",		0x20, 0x20 },
+	{ "HIPERR",		0x40, 0x40 },
+	{ "HIZERO",		0x80, 0x80 }
+};
+
+int
+ahd_perrdiag_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(PERRDIAG_parse_table, 8, "PERRDIAG",
+	    0x4e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lqistate_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LQISTATE",
+	    0x4e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_soffcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SOFFCNT",
+	    0x4f, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lqostate_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LQOSTATE",
+	    0x4f, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQISTAT0_parse_table[] = {
+	{ "LQIATNCMD",		0x01, 0x01 },
+	{ "LQIATNLQ",		0x02, 0x02 },
+	{ "LQIBADLQT",		0x04, 0x04 },
+	{ "LQICRCT2",		0x08, 0x08 },
+	{ "LQICRCT1",		0x10, 0x10 },
+	{ "LQIATNQAS",		0x20, 0x20 }
+};
+
+int
+ahd_lqistat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQISTAT0_parse_table, 6, "LQISTAT0",
+	    0x50, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRLQIINT0_parse_table[] = {
+	{ "CLRLQIATNCMD",	0x01, 0x01 },
+	{ "CLRLQIATNLQ",	0x02, 0x02 },
+	{ "CLRLQIBADLQT",	0x04, 0x04 },
+	{ "CLRLQICRCT2",	0x08, 0x08 },
+	{ "CLRLQICRCT1",	0x10, 0x10 },
+	{ "CLRLQIATNQAS",	0x20, 0x20 }
+};
+
+int
+ahd_clrlqiint0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRLQIINT0_parse_table, 6, "CLRLQIINT0",
+	    0x50, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQIMODE0_parse_table[] = {
+	{ "ENLQIATNCMD",	0x01, 0x01 },
+	{ "ENLQIATNLQ",		0x02, 0x02 },
+	{ "ENLQIBADLQT",	0x04, 0x04 },
+	{ "ENLQICRCT2",		0x08, 0x08 },
+	{ "ENLQICRCT1",		0x10, 0x10 },
+	{ "ENLQIATNQASK",	0x20, 0x20 }
+};
+
+int
+ahd_lqimode0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQIMODE0_parse_table, 6, "LQIMODE0",
+	    0x50, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQIMODE1_parse_table[] = {
+	{ "ENLQIOVERI_NLQ",	0x01, 0x01 },
+	{ "ENLQIOVERI_LQ",	0x02, 0x02 },
+	{ "ENLQIBADLQI",	0x04, 0x04 },
+	{ "ENLQICRCI_NLQ",	0x08, 0x08 },
+	{ "ENLQICRCI_LQ",	0x10, 0x10 },
+	{ "ENLIQABORT",		0x20, 0x20 },
+	{ "ENLQIPHASE_NLQ",	0x40, 0x40 },
+	{ "ENLQIPHASE_LQ",	0x80, 0x80 }
+};
+
+int
+ahd_lqimode1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQIMODE1_parse_table, 8, "LQIMODE1",
+	    0x51, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQISTAT1_parse_table[] = {
+	{ "LQIOVERI_NLQ",	0x01, 0x01 },
+	{ "LQIOVERI_LQ",	0x02, 0x02 },
+	{ "LQIBADLQI",		0x04, 0x04 },
+	{ "LQICRCI_NLQ",	0x08, 0x08 },
+	{ "LQICRCI_LQ",		0x10, 0x10 },
+	{ "LQIABORT",		0x20, 0x20 },
+	{ "LQIPHASE_NLQ",	0x40, 0x40 },
+	{ "LQIPHASE_LQ",	0x80, 0x80 }
+};
+
+int
+ahd_lqistat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQISTAT1_parse_table, 8, "LQISTAT1",
+	    0x51, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRLQIINT1_parse_table[] = {
+	{ "CLRLQIOVERI_NLQ",	0x01, 0x01 },
+	{ "CLRLQIOVERI_LQ",	0x02, 0x02 },
+	{ "CLRLQIBADLQI",	0x04, 0x04 },
+	{ "CLRLQICRCI_NLQ",	0x08, 0x08 },
+	{ "CLRLQICRCI_LQ",	0x10, 0x10 },
+	{ "CLRLIQABORT",	0x20, 0x20 },
+	{ "CLRLQIPHASE_NLQ",	0x40, 0x40 },
+	{ "CLRLQIPHASE_LQ",	0x80, 0x80 }
+};
+
+int
+ahd_clrlqiint1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRLQIINT1_parse_table, 8, "CLRLQIINT1",
+	    0x51, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQISTAT2_parse_table[] = {
+	{ "LQIGSAVAIL",		0x01, 0x01 },
+	{ "LQISTOPCMD",		0x02, 0x02 },
+	{ "LQISTOPLQ",		0x04, 0x04 },
+	{ "LQISTOPPKT",		0x08, 0x08 },
+	{ "LQIWAITFIFO",	0x10, 0x10 },
+	{ "LQIWORKONLQ",	0x20, 0x20 },
+	{ "LQIPHASE_OUTPKT",	0x40, 0x40 },
+	{ "PACKETIZED",		0x80, 0x80 }
+};
+
+int
+ahd_lqistat2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQISTAT2_parse_table, 8, "LQISTAT2",
+	    0x52, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SSTAT3_parse_table[] = {
+	{ "OSRAMPERR",		0x01, 0x01 },
+	{ "NTRAMPERR",		0x02, 0x02 }
+};
+
+int
+ahd_sstat3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SSTAT3_parse_table, 2, "SSTAT3",
+	    0x53, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SIMODE3_parse_table[] = {
+	{ "ENOSRAMPERR",	0x01, 0x01 },
+	{ "ENNTRAMPERR",	0x02, 0x02 }
+};
+
+int
+ahd_simode3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SIMODE3_parse_table, 2, "SIMODE3",
+	    0x53, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRSINT3_parse_table[] = {
+	{ "CLROSRAMPERR",	0x01, 0x01 },
+	{ "CLRNTRAMPERR",	0x02, 0x02 }
+};
+
+int
+ahd_clrsint3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRSINT3_parse_table, 2, "CLRSINT3",
+	    0x53, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQOMODE0_parse_table[] = {
+	{ "ENLQOTCRC",		0x01, 0x01 },
+	{ "ENLQOATNPKT",	0x02, 0x02 },
+	{ "ENLQOATNLQ",		0x04, 0x04 },
+	{ "ENLQOSTOPT2",	0x08, 0x08 },
+	{ "ENLQOTARGSCBPERR",	0x10, 0x10 }
+};
+
+int
+ahd_lqomode0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQOMODE0_parse_table, 5, "LQOMODE0",
+	    0x54, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQOSTAT0_parse_table[] = {
+	{ "LQOTCRC",		0x01, 0x01 },
+	{ "LQOATNPKT",		0x02, 0x02 },
+	{ "LQOATNLQ",		0x04, 0x04 },
+	{ "LQOSTOPT2",		0x08, 0x08 },
+	{ "LQOTARGSCBPERR",	0x10, 0x10 }
+};
+
+int
+ahd_lqostat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQOSTAT0_parse_table, 5, "LQOSTAT0",
+	    0x54, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRLQOINT0_parse_table[] = {
+	{ "CLRLQOTCRC",		0x01, 0x01 },
+	{ "CLRLQOATNPKT",	0x02, 0x02 },
+	{ "CLRLQOATNLQ",	0x04, 0x04 },
+	{ "CLRLQOSTOPT2",	0x08, 0x08 },
+	{ "CLRLQOTARGSCBPERR",	0x10, 0x10 }
+};
+
+int
+ahd_clrlqoint0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRLQOINT0_parse_table, 5, "CLRLQOINT0",
+	    0x54, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQOSTAT1_parse_table[] = {
+	{ "LQOPHACHGINPKT",	0x01, 0x01 },
+	{ "LQOBUSFREE",		0x02, 0x02 },
+	{ "LQOBADQAS",		0x04, 0x04 },
+	{ "LQOSTOPI2",		0x08, 0x08 },
+	{ "LQOINITSCBPERR",	0x10, 0x10 }
+};
+
+int
+ahd_lqostat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQOSTAT1_parse_table, 5, "LQOSTAT1",
+	    0x55, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRLQOINT1_parse_table[] = {
+	{ "CLRLQOPHACHGINPKT",	0x01, 0x01 },
+	{ "CLRLQOBUSFREE",	0x02, 0x02 },
+	{ "CLRLQOBADQAS",	0x04, 0x04 },
+	{ "CLRLQOSTOPI2",	0x08, 0x08 },
+	{ "CLRLQOINITSCBPERR",	0x10, 0x10 }
+};
+
+int
+ahd_clrlqoint1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRLQOINT1_parse_table, 5, "CLRLQOINT1",
+	    0x55, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQOMODE1_parse_table[] = {
+	{ "ENLQOPHACHGINPKT",	0x01, 0x01 },
+	{ "ENLQOBUSFREE",	0x02, 0x02 },
+	{ "ENLQOBADQAS",	0x04, 0x04 },
+	{ "ENLQOSTOPI2",	0x08, 0x08 },
+	{ "ENLQOINITSCBPERR",	0x10, 0x10 }
+};
+
+int
+ahd_lqomode1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQOMODE1_parse_table, 5, "LQOMODE1",
+	    0x55, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQOSTAT2_parse_table[] = {
+	{ "LQOSTOP0",		0x01, 0x01 },
+	{ "LQOPHACHGOUTPKT",	0x02, 0x02 },
+	{ "LQOWAITFIFO",	0x10, 0x10 },
+	{ "LQOPKT",		0xe0, 0xe0 }
+};
+
+int
+ahd_lqostat2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQOSTAT2_parse_table, 4, "LQOSTAT2",
+	    0x56, regvalue, cur_col, wrap));
+}
+
+int
+ahd_os_space_cnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "OS_SPACE_CNT",
+	    0x56, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SIMODE1_parse_table[] = {
+	{ "ENREQINIT",		0x01, 0x01 },
+	{ "ENSTRB2FAST",	0x02, 0x02 },
+	{ "ENSCSIPERR",		0x04, 0x04 },
+	{ "ENBUSFREE",		0x08, 0x08 },
+	{ "ENPHASEMIS",		0x10, 0x10 },
+	{ "ENSCSIRST",		0x20, 0x20 },
+	{ "ENATNTARG",		0x40, 0x40 },
+	{ "ENSELTIMO",		0x80, 0x80 }
+};
+
+int
+ahd_simode1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SIMODE1_parse_table, 8, "SIMODE1",
+	    0x57, regvalue, cur_col, wrap));
+}
+
+int
+ahd_gsfifo_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "GSFIFO",
+	    0x58, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DFFSXFRCTL_parse_table[] = {
+	{ "RSTCHN",		0x01, 0x01 },
+	{ "CLRCHN",		0x02, 0x02 },
+	{ "CLRSHCNT",		0x04, 0x04 },
+	{ "DFFBITBUCKET",	0x08, 0x08 }
+};
+
+int
+ahd_dffsxfrctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DFFSXFRCTL_parse_table, 4, "DFFSXFRCTL",
+	    0x5a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LQOSCSCTL_parse_table[] = {
+	{ "LQONOCHKOVER",	0x01, 0x01 },
+	{ "LQOH2A_VERSION",	0x80, 0x80 }
+};
+
+int
+ahd_lqoscsctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LQOSCSCTL_parse_table, 2, "LQOSCSCTL",
+	    0x5a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_nextscb_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "NEXTSCB",
+	    0x5a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CLRSEQINTSRC_parse_table[] = {
+	{ "CLRCFG4TCMD",	0x01, 0x01 },
+	{ "CLRCFG4ICMD",	0x02, 0x02 },
+	{ "CLRCFG4TSTAT",	0x04, 0x04 },
+	{ "CLRCFG4ISTAT",	0x08, 0x08 },
+	{ "CLRCFG4DATA",	0x10, 0x10 },
+	{ "CLRSAVEPTRS",	0x20, 0x20 },
+	{ "CLRCTXTDONE",	0x40, 0x40 }
+};
+
+int
+ahd_clrseqintsrc_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CLRSEQINTSRC_parse_table, 7, "CLRSEQINTSRC",
+	    0x5b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQINTSRC_parse_table[] = {
+	{ "CFG4TCMD",		0x01, 0x01 },
+	{ "CFG4ICMD",		0x02, 0x02 },
+	{ "CFG4TSTAT",		0x04, 0x04 },
+	{ "CFG4ISTAT",		0x08, 0x08 },
+	{ "CFG4DATA",		0x10, 0x10 },
+	{ "SAVEPTRS",		0x20, 0x20 },
+	{ "CTXTDONE",		0x40, 0x40 }
+};
+
+int
+ahd_seqintsrc_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQINTSRC_parse_table, 7, "SEQINTSRC",
+	    0x5b, regvalue, cur_col, wrap));
+}
+
+int
+ahd_currscb_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CURRSCB",
+	    0x5c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQIMODE_parse_table[] = {
+	{ "ENCFG4TCMD",		0x01, 0x01 },
+	{ "ENCFG4ICMD",		0x02, 0x02 },
+	{ "ENCFG4TSTAT",	0x04, 0x04 },
+	{ "ENCFG4ISTAT",	0x08, 0x08 },
+	{ "ENCFG4DATA",		0x10, 0x10 },
+	{ "ENSAVEPTRS",		0x20, 0x20 },
+	{ "ENCTXTDONE",		0x40, 0x40 }
+};
+
+int
+ahd_seqimode_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQIMODE_parse_table, 7, "SEQIMODE",
+	    0x5c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t MDFFSTAT_parse_table[] = {
+	{ "FIFOFREE",		0x01, 0x01 },
+	{ "DATAINFIFO",		0x02, 0x02 },
+	{ "DLZERO",		0x04, 0x04 },
+	{ "SHVALID",		0x08, 0x08 },
+	{ "LASTSDONE",		0x10, 0x10 },
+	{ "SHCNTMINUS1",	0x20, 0x20 },
+	{ "SHCNTNEGATIVE",	0x40, 0x40 }
+};
+
+int
+ahd_mdffstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(MDFFSTAT_parse_table, 7, "MDFFSTAT",
+	    0x5d, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CRCCONTROL_parse_table[] = {
+	{ "CRCVALCHKEN",	0x40, 0x40 }
+};
+
+int
+ahd_crccontrol_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CRCCONTROL_parse_table, 1, "CRCCONTROL",
+	    0x5d, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfftag_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFFTAG",
+	    0x5e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lastscb_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LASTSCB",
+	    0x5e, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSITEST_parse_table[] = {
+	{ "SEL_TXPLL_DEBUG",	0x04, 0x04 },
+	{ "CNTRTEST",		0x08, 0x08 }
+};
+
+int
+ahd_scsitest_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSITEST_parse_table, 2, "SCSITEST",
+	    0x5e, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t IOPDNCTL_parse_table[] = {
+	{ "PDN_DIFFSENSE",	0x01, 0x01 },
+	{ "PDN_IDIST",		0x04, 0x04 },
+	{ "DISABLE_OE",		0x80, 0x80 }
+};
+
+int
+ahd_iopdnctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(IOPDNCTL_parse_table, 3, "IOPDNCTL",
+	    0x5f, regvalue, cur_col, wrap));
+}
+
+int
+ahd_shaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SHADDR",
+	    0x60, regvalue, cur_col, wrap));
+}
+
+int
+ahd_negoaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "NEGOADDR",
+	    0x60, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dgrpcrci_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DGRPCRCI",
+	    0x60, regvalue, cur_col, wrap));
+}
+
+int
+ahd_negperiod_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "NEGPERIOD",
+	    0x61, regvalue, cur_col, wrap));
+}
+
+int
+ahd_packcrci_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "PACKCRCI",
+	    0x62, regvalue, cur_col, wrap));
+}
+
+int
+ahd_negoffset_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "NEGOFFSET",
+	    0x62, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t NEGPPROPTS_parse_table[] = {
+	{ "PPROPT_IUT",		0x01, 0x01 },
+	{ "PPROPT_DT",		0x02, 0x02 },
+	{ "PPROPT_QAS",		0x04, 0x04 },
+	{ "PPROPT_PACE",	0x08, 0x08 }
+};
+
+int
+ahd_negppropts_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NEGPPROPTS_parse_table, 4, "NEGPPROPTS",
+	    0x63, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t NEGCONOPTS_parse_table[] = {
+	{ "WIDEXFER",		0x01, 0x01 },
+	{ "ENAUTOATNO",		0x02, 0x02 },
+	{ "ENAUTOATNI",		0x04, 0x04 },
+	{ "ENSLOWCRC",		0x08, 0x08 },
+	{ "RTI_OVRDTRN",	0x10, 0x10 },
+	{ "RTI_WRTDIS",		0x20, 0x20 },
+	{ "ENSNAPSHOT",		0x40, 0x40 }
+};
+
+int
+ahd_negconopts_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NEGCONOPTS_parse_table, 7, "NEGCONOPTS",
+	    0x64, regvalue, cur_col, wrap));
+}
+
+int
+ahd_annexcol_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ANNEXCOL",
+	    0x65, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSCHKN_parse_table[] = {
+	{ "LSTSGCLRDIS",	0x01, 0x01 },
+	{ "SHVALIDSTDIS",	0x02, 0x02 },
+	{ "DFFACTCLR",		0x04, 0x04 },
+	{ "SDONEMSKDIS",	0x08, 0x08 },
+	{ "WIDERESEN",		0x10, 0x10 },
+	{ "CURRFIFODEF",	0x20, 0x20 },
+	{ "STSELSKIDDIS",	0x40, 0x40 }
+};
+
+int
+ahd_scschkn_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSCHKN_parse_table, 7, "SCSCHKN",
+	    0x66, regvalue, cur_col, wrap));
+}
+
+int
+ahd_annexdat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ANNEXDAT",
+	    0x66, regvalue, cur_col, wrap));
+}
+
+int
+ahd_iownid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "IOWNID",
+	    0x67, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t PLL960CTL0_parse_table[] = {
+	{ "PLL_ENFBM",		0x01, 0x01 },
+	{ "PLL_DLPF",		0x02, 0x02 },
+	{ "PLL_ENLPF",		0x04, 0x04 },
+	{ "PLL_ENLUD",		0x08, 0x08 },
+	{ "PLL_NS",		0x30, 0x30 },
+	{ "PLL_PWDN",		0x40, 0x40 },
+	{ "PLL_VCOSEL",		0x80, 0x80 }
+};
+
+int
+ahd_pll960ctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(PLL960CTL0_parse_table, 7, "PLL960CTL0",
+	    0x68, regvalue, cur_col, wrap));
+}
+
+int
+ahd_shcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SHCNT",
+	    0x68, regvalue, cur_col, wrap));
+}
+
+int
+ahd_townid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "TOWNID",
+	    0x69, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t PLL960CTL1_parse_table[] = {
+	{ "PLL_RST",		0x01, 0x01 },
+	{ "PLL_CNTCLR",		0x40, 0x40 },
+	{ "PLL_CNTEN",		0x80, 0x80 }
+};
+
+int
+ahd_pll960ctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(PLL960CTL1_parse_table, 3, "PLL960CTL1",
+	    0x69, regvalue, cur_col, wrap));
+}
+
+int
+ahd_pll960cnt0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "PLL960CNT0",
+	    0x6a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_xsig_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "XSIG",
+	    0x6a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_seloid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SELOID",
+	    0x6b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t PLL400CTL0_parse_table[] = {
+	{ "PLL_ENFBM",		0x01, 0x01 },
+	{ "PLL_DLPF",		0x02, 0x02 },
+	{ "PLL_ENLPF",		0x04, 0x04 },
+	{ "PLL_ENLUD",		0x08, 0x08 },
+	{ "PLL_NS",		0x30, 0x30 },
+	{ "PLL_PWDN",		0x40, 0x40 },
+	{ "PLL_VCOSEL",		0x80, 0x80 }
+};
+
+int
+ahd_pll400ctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(PLL400CTL0_parse_table, 7, "PLL400CTL0",
+	    0x6c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_fairness_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "FAIRNESS",
+	    0x6c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t PLL400CTL1_parse_table[] = {
+	{ "PLL_RST",		0x01, 0x01 },
+	{ "PLL_CNTCLR",		0x40, 0x40 },
+	{ "PLL_CNTEN",		0x80, 0x80 }
+};
+
+int
+ahd_pll400ctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(PLL400CTL1_parse_table, 3, "PLL400CTL1",
+	    0x6d, regvalue, cur_col, wrap));
+}
+
+int
+ahd_pll400cnt0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "PLL400CNT0",
+	    0x6e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_unfairness_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "UNFAIRNESS",
+	    0x6e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_haddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "HADDR",
+	    0x70, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t PLLDELAY_parse_table[] = {
+	{ "SPLIT_DROP_REQ",	0x80, 0x80 }
+};
+
+int
+ahd_plldelay_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(PLLDELAY_parse_table, 1, "PLLDELAY",
+	    0x70, regvalue, cur_col, wrap));
+}
+
+int
+ahd_hodmaadr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "HODMAADR",
+	    0x70, regvalue, cur_col, wrap));
+}
+
+int
+ahd_hodmacnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "HODMACNT",
+	    0x78, regvalue, cur_col, wrap));
+}
+
+int
+ahd_hcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "HCNT",
+	    0x78, regvalue, cur_col, wrap));
+}
+
+int
+ahd_hodmaen_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "HODMAEN",
+	    0x7a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sghaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SGHADDR",
+	    0x7c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scbhaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCBHADDR",
+	    0x7c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sghcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SGHCNT",
+	    0x84, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scbhcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCBHCNT",
+	    0x84, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DFF_THRSH_parse_table[] = {
+	{ "WR_DFTHRSH_MIN",	0x00, 0x70 },
+	{ "RD_DFTHRSH_MIN",	0x00, 0x07 },
+	{ "RD_DFTHRSH_25",	0x01, 0x07 },
+	{ "RD_DFTHRSH_50",	0x02, 0x07 },
+	{ "RD_DFTHRSH_63",	0x03, 0x07 },
+	{ "RD_DFTHRSH_75",	0x04, 0x07 },
+	{ "RD_DFTHRSH_85",	0x05, 0x07 },
+	{ "RD_DFTHRSH_90",	0x06, 0x07 },
+	{ "RD_DFTHRSH_MAX",	0x07, 0x07 },
+	{ "WR_DFTHRSH_25",	0x10, 0x70 },
+	{ "WR_DFTHRSH_50",	0x20, 0x70 },
+	{ "WR_DFTHRSH_63",	0x30, 0x70 },
+	{ "WR_DFTHRSH_75",	0x40, 0x70 },
+	{ "WR_DFTHRSH_85",	0x50, 0x70 },
+	{ "WR_DFTHRSH_90",	0x60, 0x70 },
+	{ "WR_DFTHRSH_MAX",	0x70, 0x70 },
+	{ "RD_DFTHRSH",		0x07, 0x07 },
+	{ "WR_DFTHRSH",		0x70, 0x70 }
+};
+
+int
+ahd_dff_thrsh_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DFF_THRSH_parse_table, 18, "DFF_THRSH",
+	    0x88, regvalue, cur_col, wrap));
+}
+
+int
+ahd_romaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ROMADDR",
+	    0x8a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t ROMCNTRL_parse_table[] = {
+	{ "RDY",		0x01, 0x01 },
+	{ "REPEAT",		0x02, 0x02 },
+	{ "ROMSPD",		0x18, 0x18 },
+	{ "ROMOP",		0xe0, 0xe0 }
+};
+
+int
+ahd_romcntrl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(ROMCNTRL_parse_table, 4, "ROMCNTRL",
+	    0x8d, regvalue, cur_col, wrap));
+}
+
+int
+ahd_romdata_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ROMDATA",
+	    0x8e, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMCRXMSG0_parse_table[] = {
+	{ "CFNUM",		0x07, 0x07 },
+	{ "CDNUM",		0xf8, 0xf8 }
+};
+
+int
+ahd_cmcrxmsg0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMCRXMSG0_parse_table, 2, "CMCRXMSG0",
+	    0x90, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t ROENABLE_parse_table[] = {
+	{ "DCH0ROEN",		0x01, 0x01 },
+	{ "DCH1ROEN",		0x02, 0x02 },
+	{ "SGROEN",		0x04, 0x04 },
+	{ "CMCROEN",		0x08, 0x08 },
+	{ "OVLYROEN",		0x10, 0x10 },
+	{ "MSIROEN",		0x20, 0x20 }
+};
+
+int
+ahd_roenable_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(ROENABLE_parse_table, 6, "ROENABLE",
+	    0x90, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OVLYRXMSG0_parse_table[] = {
+	{ "CFNUM",		0x07, 0x07 },
+	{ "CDNUM",		0xf8, 0xf8 }
+};
+
+int
+ahd_ovlyrxmsg0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYRXMSG0_parse_table, 2, "OVLYRXMSG0",
+	    0x90, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DCHRXMSG0_parse_table[] = {
+	{ "CFNUM",		0x07, 0x07 },
+	{ "CDNUM",		0xf8, 0xf8 }
+};
+
+int
+ahd_dchrxmsg0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DCHRXMSG0_parse_table, 2, "DCHRXMSG0",
+	    0x90, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OVLYRXMSG1_parse_table[] = {
+	{ "CBNUM",		0xff, 0xff }
+};
+
+int
+ahd_ovlyrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYRXMSG1_parse_table, 1, "OVLYRXMSG1",
+	    0x91, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t NSENABLE_parse_table[] = {
+	{ "DCH0NSEN",		0x01, 0x01 },
+	{ "DCH1NSEN",		0x02, 0x02 },
+	{ "SGNSEN",		0x04, 0x04 },
+	{ "CMCNSEN",		0x08, 0x08 },
+	{ "OVLYNSEN",		0x10, 0x10 },
+	{ "MSINSEN",		0x20, 0x20 }
+};
+
+int
+ahd_nsenable_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NSENABLE_parse_table, 6, "NSENABLE",
+	    0x91, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DCHRXMSG1_parse_table[] = {
+	{ "CBNUM",		0xff, 0xff }
+};
+
+int
+ahd_dchrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DCHRXMSG1_parse_table, 1, "DCHRXMSG1",
+	    0x91, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMCRXMSG1_parse_table[] = {
+	{ "CBNUM",		0xff, 0xff }
+};
+
+int
+ahd_cmcrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMCRXMSG1_parse_table, 1, "CMCRXMSG1",
+	    0x91, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DCHRXMSG2_parse_table[] = {
+	{ "MINDEX",		0xff, 0xff }
+};
+
+int
+ahd_dchrxmsg2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DCHRXMSG2_parse_table, 1, "DCHRXMSG2",
+	    0x92, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OVLYRXMSG2_parse_table[] = {
+	{ "MINDEX",		0xff, 0xff }
+};
+
+int
+ahd_ovlyrxmsg2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYRXMSG2_parse_table, 1, "OVLYRXMSG2",
+	    0x92, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMCRXMSG2_parse_table[] = {
+	{ "MINDEX",		0xff, 0xff }
+};
+
+int
+ahd_cmcrxmsg2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMCRXMSG2_parse_table, 1, "CMCRXMSG2",
+	    0x92, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ost_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "OST",
+	    0x92, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DCHRXMSG3_parse_table[] = {
+	{ "MCLASS",		0x0f, 0x0f }
+};
+
+int
+ahd_dchrxmsg3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DCHRXMSG3_parse_table, 1, "DCHRXMSG3",
+	    0x93, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMCRXMSG3_parse_table[] = {
+	{ "MCLASS",		0x0f, 0x0f }
+};
+
+int
+ahd_cmcrxmsg3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMCRXMSG3_parse_table, 1, "CMCRXMSG3",
+	    0x93, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t PCIXCTL_parse_table[] = {
+	{ "CMPABCDIS",		0x01, 0x01 },
+	{ "TSCSERREN",		0x02, 0x02 },
+	{ "SRSPDPEEN",		0x04, 0x04 },
+	{ "SPLTSTADIS",		0x08, 0x08 },
+	{ "SPLTSMADIS",		0x10, 0x10 },
+	{ "UNEXPSCIEN",		0x20, 0x20 },
+	{ "SERRPULSE",		0x80, 0x80 }
+};
+
+int
+ahd_pcixctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(PCIXCTL_parse_table, 7, "PCIXCTL",
+	    0x93, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OVLYRXMSG3_parse_table[] = {
+	{ "MCLASS",		0x0f, 0x0f }
+};
+
+int
+ahd_ovlyrxmsg3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYRXMSG3_parse_table, 1, "OVLYRXMSG3",
+	    0x93, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ovlyseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "OVLYSEQBCNT",
+	    0x94, regvalue, cur_col, wrap));
+}
+
+int
+ahd_cmcseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CMCSEQBCNT",
+	    0x94, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dchseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DCHSEQBCNT",
+	    0x94, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMCSPLTSTAT0_parse_table[] = {
+	{ "RXSPLTRSP",		0x01, 0x01 },
+	{ "RXSCEMSG",		0x02, 0x02 },
+	{ "RXOVRUN",		0x04, 0x04 },
+	{ "CNTNOTCMPLT",	0x08, 0x08 },
+	{ "SCDATBUCKET",	0x10, 0x10 },
+	{ "SCADERR",		0x20, 0x20 },
+	{ "SCBCERR",		0x40, 0x40 },
+	{ "STAETERM",		0x80, 0x80 }
+};
+
+int
+ahd_cmcspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMCSPLTSTAT0_parse_table, 8, "CMCSPLTSTAT0",
+	    0x96, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OVLYSPLTSTAT0_parse_table[] = {
+	{ "RXSPLTRSP",		0x01, 0x01 },
+	{ "RXSCEMSG",		0x02, 0x02 },
+	{ "RXOVRUN",		0x04, 0x04 },
+	{ "CNTNOTCMPLT",	0x08, 0x08 },
+	{ "SCDATBUCKET",	0x10, 0x10 },
+	{ "SCADERR",		0x20, 0x20 },
+	{ "SCBCERR",		0x40, 0x40 },
+	{ "STAETERM",		0x80, 0x80 }
+};
+
+int
+ahd_ovlyspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYSPLTSTAT0_parse_table, 8, "OVLYSPLTSTAT0",
+	    0x96, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DCHSPLTSTAT0_parse_table[] = {
+	{ "RXSPLTRSP",		0x01, 0x01 },
+	{ "RXSCEMSG",		0x02, 0x02 },
+	{ "RXOVRUN",		0x04, 0x04 },
+	{ "CNTNOTCMPLT",	0x08, 0x08 },
+	{ "SCDATBUCKET",	0x10, 0x10 },
+	{ "SCADERR",		0x20, 0x20 },
+	{ "SCBCERR",		0x40, 0x40 },
+	{ "STAETERM",		0x80, 0x80 }
+};
+
+int
+ahd_dchspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DCHSPLTSTAT0_parse_table, 8, "DCHSPLTSTAT0",
+	    0x96, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DCHSPLTSTAT1_parse_table[] = {
+	{ "RXDATABUCKET",	0x01, 0x01 }
+};
+
+int
+ahd_dchspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DCHSPLTSTAT1_parse_table, 1, "DCHSPLTSTAT1",
+	    0x97, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMCSPLTSTAT1_parse_table[] = {
+	{ "RXDATABUCKET",	0x01, 0x01 }
+};
+
+int
+ahd_cmcspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMCSPLTSTAT1_parse_table, 1, "CMCSPLTSTAT1",
+	    0x97, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OVLYSPLTSTAT1_parse_table[] = {
+	{ "RXDATABUCKET",	0x01, 0x01 }
+};
+
+int
+ahd_ovlyspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYSPLTSTAT1_parse_table, 1, "OVLYSPLTSTAT1",
+	    0x97, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SGRXMSG0_parse_table[] = {
+	{ "CFNUM",		0x07, 0x07 },
+	{ "CDNUM",		0xf8, 0xf8 }
+};
+
+int
+ahd_sgrxmsg0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SGRXMSG0_parse_table, 2, "SGRXMSG0",
+	    0x98, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SLVSPLTOUTADR0_parse_table[] = {
+	{ "LOWER_ADDR",		0x7f, 0x7f }
+};
+
+int
+ahd_slvspltoutadr0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SLVSPLTOUTADR0_parse_table, 1, "SLVSPLTOUTADR0",
+	    0x98, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SGRXMSG1_parse_table[] = {
+	{ "CBNUM",		0xff, 0xff }
+};
+
+int
+ahd_sgrxmsg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SGRXMSG1_parse_table, 1, "SGRXMSG1",
+	    0x99, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SLVSPLTOUTADR1_parse_table[] = {
+	{ "REQ_FNUM",		0x07, 0x07 },
+	{ "REQ_DNUM",		0xf8, 0xf8 }
+};
+
+int
+ahd_slvspltoutadr1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SLVSPLTOUTADR1_parse_table, 2, "SLVSPLTOUTADR1",
+	    0x99, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SGRXMSG2_parse_table[] = {
+	{ "MINDEX",		0xff, 0xff }
+};
+
+int
+ahd_sgrxmsg2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SGRXMSG2_parse_table, 1, "SGRXMSG2",
+	    0x9a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SLVSPLTOUTADR2_parse_table[] = {
+	{ "REQ_BNUM",		0xff, 0xff }
+};
+
+int
+ahd_slvspltoutadr2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SLVSPLTOUTADR2_parse_table, 1, "SLVSPLTOUTADR2",
+	    0x9a, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SGRXMSG3_parse_table[] = {
+	{ "MCLASS",		0x0f, 0x0f }
+};
+
+int
+ahd_sgrxmsg3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SGRXMSG3_parse_table, 1, "SGRXMSG3",
+	    0x9b, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SLVSPLTOUTADR3_parse_table[] = {
+	{ "RLXORD",		0x10, 0x10 },
+	{ "TAG_NUM",		0x1f, 0x1f }
+};
+
+int
+ahd_slvspltoutadr3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SLVSPLTOUTADR3_parse_table, 2, "SLVSPLTOUTADR3",
+	    0x9b, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sgseqbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SGSEQBCNT",
+	    0x9c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SLVSPLTOUTATTR0_parse_table[] = {
+	{ "LOWER_BCNT",		0xff, 0xff }
+};
+
+int
+ahd_slvspltoutattr0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SLVSPLTOUTATTR0_parse_table, 1, "SLVSPLTOUTATTR0",
+	    0x9c, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SLVSPLTOUTATTR1_parse_table[] = {
+	{ "CMPLT_FNUM",		0x07, 0x07 },
+	{ "CMPLT_DNUM",		0xf8, 0xf8 }
+};
+
+int
+ahd_slvspltoutattr1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SLVSPLTOUTATTR1_parse_table, 2, "SLVSPLTOUTATTR1",
+	    0x9d, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SLVSPLTOUTATTR2_parse_table[] = {
+	{ "CMPLT_BNUM",		0xff, 0xff }
+};
+
+int
+ahd_slvspltoutattr2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SLVSPLTOUTATTR2_parse_table, 1, "SLVSPLTOUTATTR2",
+	    0x9e, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SGSPLTSTAT0_parse_table[] = {
+	{ "RXSPLTRSP",		0x01, 0x01 },
+	{ "RXSCEMSG",		0x02, 0x02 },
+	{ "RXOVRUN",		0x04, 0x04 },
+	{ "CNTNOTCMPLT",	0x08, 0x08 },
+	{ "SCDATBUCKET",	0x10, 0x10 },
+	{ "SCADERR",		0x20, 0x20 },
+	{ "SCBCERR",		0x40, 0x40 },
+	{ "STAETERM",		0x80, 0x80 }
+};
+
+int
+ahd_sgspltstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SGSPLTSTAT0_parse_table, 8, "SGSPLTSTAT0",
+	    0x9e, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SFUNCT_parse_table[] = {
+	{ "TEST_NUM",		0x0f, 0x0f },
+	{ "TEST_GROUP",		0xf0, 0xf0 }
+};
+
+int
+ahd_sfunct_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SFUNCT_parse_table, 2, "SFUNCT",
+	    0x9f, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SGSPLTSTAT1_parse_table[] = {
+	{ "RXDATABUCKET",	0x01, 0x01 }
+};
+
+int
+ahd_sgspltstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SGSPLTSTAT1_parse_table, 1, "SGSPLTSTAT1",
+	    0x9f, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DF0PCISTAT_parse_table[] = {
+	{ "DPR",		0x01, 0x01 },
+	{ "TWATERR",		0x02, 0x02 },
+	{ "RDPERR",		0x04, 0x04 },
+	{ "SCAAPERR",		0x08, 0x08 },
+	{ "RTA",		0x10, 0x10 },
+	{ "RMA",		0x20, 0x20 },
+	{ "SSE",		0x40, 0x40 },
+	{ "DPE",		0x80, 0x80 }
+};
+
+int
+ahd_df0pcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DF0PCISTAT_parse_table, 8, "DF0PCISTAT",
+	    0xa0, regvalue, cur_col, wrap));
+}
+
+int
+ahd_reg0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "REG0",
+	    0xa0, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DF1PCISTAT_parse_table[] = {
+	{ "DPR",		0x01, 0x01 },
+	{ "TWATERR",		0x02, 0x02 },
+	{ "RDPERR",		0x04, 0x04 },
+	{ "SCAAPERR",		0x08, 0x08 },
+	{ "RTA",		0x10, 0x10 },
+	{ "RMA",		0x20, 0x20 },
+	{ "SSE",		0x40, 0x40 },
+	{ "DPE",		0x80, 0x80 }
+};
+
+int
+ahd_df1pcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DF1PCISTAT_parse_table, 8, "DF1PCISTAT",
+	    0xa1, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SGPCISTAT_parse_table[] = {
+	{ "DPR",		0x01, 0x01 },
+	{ "RDPERR",		0x04, 0x04 },
+	{ "SCAAPERR",		0x08, 0x08 },
+	{ "RTA",		0x10, 0x10 },
+	{ "RMA",		0x20, 0x20 },
+	{ "SSE",		0x40, 0x40 },
+	{ "DPE",		0x80, 0x80 }
+};
+
+int
+ahd_sgpcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SGPCISTAT_parse_table, 7, "SGPCISTAT",
+	    0xa2, regvalue, cur_col, wrap));
+}
+
+int
+ahd_reg1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "REG1",
+	    0xa2, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMCPCISTAT_parse_table[] = {
+	{ "DPR",		0x01, 0x01 },
+	{ "TWATERR",		0x02, 0x02 },
+	{ "RDPERR",		0x04, 0x04 },
+	{ "SCAAPERR",		0x08, 0x08 },
+	{ "RTA",		0x10, 0x10 },
+	{ "RMA",		0x20, 0x20 },
+	{ "SSE",		0x40, 0x40 },
+	{ "DPE",		0x80, 0x80 }
+};
+
+int
+ahd_cmcpcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMCPCISTAT_parse_table, 8, "CMCPCISTAT",
+	    0xa3, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t OVLYPCISTAT_parse_table[] = {
+	{ "DPR",		0x01, 0x01 },
+	{ "RDPERR",		0x04, 0x04 },
+	{ "SCAAPERR",		0x08, 0x08 },
+	{ "RTA",		0x10, 0x10 },
+	{ "RMA",		0x20, 0x20 },
+	{ "SSE",		0x40, 0x40 },
+	{ "DPE",		0x80, 0x80 }
+};
+
+int
+ahd_ovlypcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(OVLYPCISTAT_parse_table, 7, "OVLYPCISTAT",
+	    0xa4, regvalue, cur_col, wrap));
+}
+
+int
+ahd_reg_isr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "REG_ISR",
+	    0xa4, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SG_STATE_parse_table[] = {
+	{ "SEGS_AVAIL",		0x01, 0x01 },
+	{ "LOADING_NEEDED",	0x02, 0x02 },
+	{ "FETCH_INPROG",	0x04, 0x04 }
+};
+
+int
+ahd_sg_state_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SG_STATE_parse_table, 3, "SG_STATE",
+	    0xa6, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t MSIPCISTAT_parse_table[] = {
+	{ "DPR",		0x01, 0x01 },
+	{ "TWATERR",		0x02, 0x02 },
+	{ "CLRPENDMSI",		0x08, 0x08 },
+	{ "RTA",		0x10, 0x10 },
+	{ "RMA",		0x20, 0x20 },
+	{ "SSE",		0x40, 0x40 }
+};
+
+int
+ahd_msipcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(MSIPCISTAT_parse_table, 6, "MSIPCISTAT",
+	    0xa6, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t TARGPCISTAT_parse_table[] = {
+	{ "TWATERR",		0x02, 0x02 },
+	{ "STA",		0x08, 0x08 },
+	{ "SSE",		0x40, 0x40 },
+	{ "DPE",		0x80, 0x80 }
+};
+
+int
+ahd_targpcistat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(TARGPCISTAT_parse_table, 4, "TARGPCISTAT",
+	    0xa7, regvalue, cur_col, wrap));
+}
+
+int
+ahd_data_count_odd_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DATA_COUNT_ODD",
+	    0xa7, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scbptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCBPTR",
+	    0xa8, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ccscbacnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CCSCBACNT",
+	    0xab, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCBAUTOPTR_parse_table[] = {
+	{ "SCBPTR_OFF",		0x07, 0x07 },
+	{ "SCBPTR_ADDR",	0x38, 0x38 },
+	{ "AUSCBPTR_EN",	0x80, 0x80 }
+};
+
+int
+ahd_scbautoptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCBAUTOPTR_parse_table, 3, "SCBAUTOPTR",
+	    0xab, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ccsgaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CCSGADDR",
+	    0xac, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ccscbaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CCSCBADDR",
+	    0xac, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ccscbadr_bk_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CCSCBADR_BK",
+	    0xac, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CMC_RAMBIST_parse_table[] = {
+	{ "CMC_BUFFER_BIST_EN",	0x01, 0x01 },
+	{ "CMC_BUFFER_BIST_FAIL",0x02, 0x02 },
+	{ "SG_BIST_EN",		0x10, 0x10 },
+	{ "SG_BIST_FAIL",	0x20, 0x20 },
+	{ "SCBRAMBIST_FAIL",	0x40, 0x40 },
+	{ "SG_ELEMENT_SIZE",	0x80, 0x80 }
+};
+
+int
+ahd_cmc_rambist_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CMC_RAMBIST_parse_table, 6, "CMC_RAMBIST",
+	    0xad, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CCSGCTL_parse_table[] = {
+	{ "CCSGRESET",		0x01, 0x01 },
+	{ "SG_FETCH_REQ",	0x02, 0x02 },
+	{ "CCSGENACK",		0x08, 0x08 },
+	{ "SG_CACHE_AVAIL",	0x10, 0x10 },
+	{ "CCSGDONE",		0x80, 0x80 },
+	{ "CCSGEN",		0x0c, 0x0c }
+};
+
+int
+ahd_ccsgctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CCSGCTL_parse_table, 6, "CCSGCTL",
+	    0xad, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t CCSCBCTL_parse_table[] = {
+	{ "CCSCBRESET",		0x01, 0x01 },
+	{ "CCSCBDIR",		0x04, 0x04 },
+	{ "CCSCBEN",		0x08, 0x08 },
+	{ "CCARREN",		0x10, 0x10 },
+	{ "ARRDONE",		0x40, 0x40 },
+	{ "CCSCBDONE",		0x80, 0x80 }
+};
+
+int
+ahd_ccscbctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(CCSCBCTL_parse_table, 6, "CCSCBCTL",
+	    0xad, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ccsgram_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CCSGRAM",
+	    0xb0, regvalue, cur_col, wrap));
+}
+
+int
+ahd_flexadr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "FLEXADR",
+	    0xb0, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ccscbram_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CCSCBRAM",
+	    0xb0, regvalue, cur_col, wrap));
+}
+
+int
+ahd_flexcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "FLEXCNT",
+	    0xb3, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t FLEXDMASTAT_parse_table[] = {
+	{ "FLEXDMADONE",	0x01, 0x01 },
+	{ "FLEXDMAERR",		0x02, 0x02 }
+};
+
+int
+ahd_flexdmastat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(FLEXDMASTAT_parse_table, 2, "FLEXDMASTAT",
+	    0xb5, regvalue, cur_col, wrap));
+}
+
+int
+ahd_flexdata_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "FLEXDATA",
+	    0xb6, regvalue, cur_col, wrap));
+}
+
+int
+ahd_brddat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "BRDDAT",
+	    0xb8, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t BRDCTL_parse_table[] = {
+	{ "BRDSTB",		0x01, 0x01 },
+	{ "BRDRW",		0x02, 0x02 },
+	{ "BRDEN",		0x04, 0x04 },
+	{ "BRDADDR",		0x38, 0x38 },
+	{ "FLXARBREQ",		0x40, 0x40 },
+	{ "FLXARBACK",		0x80, 0x80 }
+};
+
+int
+ahd_brdctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(BRDCTL_parse_table, 6, "BRDCTL",
+	    0xb9, regvalue, cur_col, wrap));
+}
+
+int
+ahd_seeadr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SEEADR",
+	    0xba, regvalue, cur_col, wrap));
+}
+
+int
+ahd_seedat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SEEDAT",
+	    0xbc, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEECTL_parse_table[] = {
+	{ "SEEOP_ERAL",		0x40, 0x70 },
+	{ "SEEOP_WRITE",	0x50, 0x70 },
+	{ "SEEOP_READ",		0x60, 0x70 },
+	{ "SEEOP_ERASE",	0x70, 0x70 },
+	{ "SEESTART",		0x01, 0x01 },
+	{ "SEERST",		0x02, 0x02 },
+	{ "SEEOPCODE",		0x70, 0x70 },
+	{ "SEEOP_EWEN",		0x40, 0x40 },
+	{ "SEEOP_WALL",		0x40, 0x40 },
+	{ "SEEOP_EWDS",		0x40, 0x40 }
+};
+
+int
+ahd_seectl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEECTL_parse_table, 10, "SEECTL",
+	    0xbe, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEESTAT_parse_table[] = {
+	{ "SEESTART",		0x01, 0x01 },
+	{ "SEEBUSY",		0x02, 0x02 },
+	{ "SEEARBACK",		0x04, 0x04 },
+	{ "LDALTID_L",		0x08, 0x08 },
+	{ "SEEOPCODE",		0x70, 0x70 },
+	{ "INIT_DONE",		0x80, 0x80 }
+};
+
+int
+ahd_seestat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEESTAT_parse_table, 6, "SEESTAT",
+	    0xbe, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCBCNT",
+	    0xbf, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfwaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFWADDR",
+	    0xc0, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DSPFLTRCTL_parse_table[] = {
+	{ "DSPFCNTSEL",		0x0f, 0x0f },
+	{ "EDGESENSE",		0x10, 0x10 },
+	{ "FLTRDISABLE",	0x20, 0x20 }
+};
+
+int
+ahd_dspfltrctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DSPFLTRCTL_parse_table, 3, "DSPFLTRCTL",
+	    0xc0, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DSPDATACTL_parse_table[] = {
+	{ "XMITOFFSTDIS",	0x02, 0x02 },
+	{ "RCVROFFSTDIS",	0x04, 0x04 },
+	{ "DESQDIS",		0x10, 0x10 },
+	{ "BYPASSENAB",		0x80, 0x80 }
+};
+
+int
+ahd_dspdatactl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DSPDATACTL_parse_table, 4, "DSPDATACTL",
+	    0xc1, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfraddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFRADDR",
+	    0xc2, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DSPREQCTL_parse_table[] = {
+	{ "MANREQDLY",		0x3f, 0x3f },
+	{ "MANREQCTL",		0xc0, 0xc0 }
+};
+
+int
+ahd_dspreqctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DSPREQCTL_parse_table, 2, "DSPREQCTL",
+	    0xc2, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DSPACKCTL_parse_table[] = {
+	{ "MANACKDLY",		0x3f, 0x3f },
+	{ "MANACKCTL",		0xc0, 0xc0 }
+};
+
+int
+ahd_dspackctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DSPACKCTL_parse_table, 2, "DSPACKCTL",
+	    0xc3, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfdat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFDAT",
+	    0xc4, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DSPSELECT_parse_table[] = {
+	{ "DSPSEL",		0x1f, 0x1f },
+	{ "AUTOINCEN",		0x80, 0x80 }
+};
+
+int
+ahd_dspselect_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DSPSELECT_parse_table, 2, "DSPSELECT",
+	    0xc4, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t WRTBIASCTL_parse_table[] = {
+	{ "XMITMANVAL",		0x3f, 0x3f },
+	{ "AUTOXBCDIS",		0x80, 0x80 }
+};
+
+int
+ahd_wrtbiasctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(WRTBIASCTL_parse_table, 2, "WRTBIASCTL",
+	    0xc5, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t RCVRBIOSCTL_parse_table[] = {
+	{ "RCVRMANVAL",		0x3f, 0x3f },
+	{ "AUTORBCDIS",		0x80, 0x80 }
+};
+
+int
+ahd_rcvrbiosctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(RCVRBIOSCTL_parse_table, 2, "RCVRBIOSCTL",
+	    0xc6, regvalue, cur_col, wrap));
+}
+
+int
+ahd_wrtbiascalc_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "WRTBIASCALC",
+	    0xc7, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfptrs_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFPTRS",
+	    0xc8, regvalue, cur_col, wrap));
+}
+
+int
+ahd_rcvrbiascalc_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "RCVRBIASCALC",
+	    0xc8, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfbkptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFBKPTR",
+	    0xc9, regvalue, cur_col, wrap));
+}
+
+int
+ahd_skewcalc_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SKEWCALC",
+	    0xc9, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DFDBCTL_parse_table[] = {
+	{ "DFF_RAMBIST_EN",	0x01, 0x01 },
+	{ "DFF_RAMBIST_DONE",	0x02, 0x02 },
+	{ "DFF_RAMBIST_FAIL",	0x04, 0x04 },
+	{ "DFF_DIR_ERR",	0x08, 0x08 },
+	{ "DFF_CIO_RD_RDY",	0x10, 0x10 },
+	{ "DFF_CIO_WR_RDY",	0x20, 0x20 }
+};
+
+int
+ahd_dfdbctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DFDBCTL_parse_table, 6, "DFDBCTL",
+	    0xcb, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfscnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFSCNT",
+	    0xcc, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dfbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DFBCNT",
+	    0xce, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ovlyaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "OVLYADDR",
+	    0xd4, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQCTL0_parse_table[] = {
+	{ "LOADRAM",		0x01, 0x01 },
+	{ "SEQRESET",		0x02, 0x02 },
+	{ "STEP",		0x04, 0x04 },
+	{ "BRKADRINTEN",	0x08, 0x08 },
+	{ "FASTMODE",		0x10, 0x10 },
+	{ "FAILDIS",		0x20, 0x20 },
+	{ "PAUSEDIS",		0x40, 0x40 },
+	{ "PERRORDIS",		0x80, 0x80 }
+};
+
+int
+ahd_seqctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQCTL0_parse_table, 8, "SEQCTL0",
+	    0xd6, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQCTL1_parse_table[] = {
+	{ "RAMBIST_EN",		0x01, 0x01 },
+	{ "RAMBIST_FAIL",	0x02, 0x02 },
+	{ "RAMBIST_DONE",	0x04, 0x04 },
+	{ "OVRLAY_DATA_CHK",	0x08, 0x08 }
+};
+
+int
+ahd_seqctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQCTL1_parse_table, 4, "SEQCTL1",
+	    0xd7, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t FLAGS_parse_table[] = {
+	{ "CARRY",		0x01, 0x01 },
+	{ "ZERO",		0x02, 0x02 }
+};
+
+int
+ahd_flags_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(FLAGS_parse_table, 2, "FLAGS",
+	    0xd8, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQINTCTL_parse_table[] = {
+	{ "IRET",		0x01, 0x01 },
+	{ "INTMASK1",		0x02, 0x02 },
+	{ "INTMASK2",		0x04, 0x04 },
+	{ "SCS_SEQ_INT1M0",	0x08, 0x08 },
+	{ "SCS_SEQ_INT1M1",	0x10, 0x10 },
+	{ "INT1_CONTEXT",	0x20, 0x20 },
+	{ "INTVEC1DSL",		0x80, 0x80 }
+};
+
+int
+ahd_seqintctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQINTCTL_parse_table, 7, "SEQINTCTL",
+	    0xd9, regvalue, cur_col, wrap));
+}
+
+int
+ahd_seqram_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SEQRAM",
+	    0xda, regvalue, cur_col, wrap));
+}
+
+int
+ahd_prgmcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "PRGMCNT",
+	    0xde, regvalue, cur_col, wrap));
+}
+
+int
+ahd_accum_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ACCUM",
+	    0xe0, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sindex_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SINDEX",
+	    0xe2, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dindex_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DINDEX",
+	    0xe4, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t BRKADDR1_parse_table[] = {
+	{ "BRKDIS",		0x80, 0x80 }
+};
+
+int
+ahd_brkaddr1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(BRKADDR1_parse_table, 1, "BRKADDR1",
+	    0xe6, regvalue, cur_col, wrap));
+}
+
+int
+ahd_brkaddr0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "BRKADDR0",
+	    0xe6, regvalue, cur_col, wrap));
+}
+
+int
+ahd_allones_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ALLONES",
+	    0xe8, regvalue, cur_col, wrap));
+}
+
+int
+ahd_allzeros_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ALLZEROS",
+	    0xea, regvalue, cur_col, wrap));
+}
+
+int
+ahd_none_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "NONE",
+	    0xea, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sindir_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SINDIR",
+	    0xec, regvalue, cur_col, wrap));
+}
+
+int
+ahd_dindir_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "DINDIR",
+	    0xed, regvalue, cur_col, wrap));
+}
+
+int
+ahd_function1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "FUNCTION1",
+	    0xf0, regvalue, cur_col, wrap));
+}
+
+int
+ahd_stack_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "STACK",
+	    0xf2, regvalue, cur_col, wrap));
+}
+
+int
+ahd_curaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CURADDR",
+	    0xf4, regvalue, cur_col, wrap));
+}
+
+int
+ahd_intvec1_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "INTVEC1_ADDR",
+	    0xf4, regvalue, cur_col, wrap));
+}
+
+int
+ahd_intvec2_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "INTVEC2_ADDR",
+	    0xf6, regvalue, cur_col, wrap));
+}
+
+int
+ahd_lastaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LASTADDR",
+	    0xf6, regvalue, cur_col, wrap));
+}
+
+int
+ahd_longjmp_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LONGJMP_ADDR",
+	    0xf8, regvalue, cur_col, wrap));
+}
+
+int
+ahd_accum_save_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ACCUM_SAVE",
+	    0xfa, regvalue, cur_col, wrap));
+}
+
+int
+ahd_waiting_scb_tails_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "WAITING_SCB_TAILS",
+	    0x100, regvalue, cur_col, wrap));
+}
+
+int
+ahd_ahd_pci_config_base_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "AHD_PCI_CONFIG_BASE",
+	    0x100, regvalue, cur_col, wrap));
+}
+
+int
+ahd_sram_base_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SRAM_BASE",
+	    0x100, regvalue, cur_col, wrap));
+}
+
+int
+ahd_waiting_tid_head_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "WAITING_TID_HEAD",
+	    0x120, regvalue, cur_col, wrap));
+}
+
+int
+ahd_waiting_tid_tail_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "WAITING_TID_TAIL",
+	    0x122, regvalue, cur_col, wrap));
+}
+
+int
+ahd_next_queued_scb_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "NEXT_QUEUED_SCB_ADDR",
+	    0x124, regvalue, cur_col, wrap));
+}
+
+int
+ahd_complete_scb_head_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "COMPLETE_SCB_HEAD",
+	    0x128, regvalue, cur_col, wrap));
+}
+
+int
+ahd_complete_scb_dmainprog_head_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "COMPLETE_SCB_DMAINPROG_HEAD",
+	    0x12a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_complete_dma_scb_head_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "COMPLETE_DMA_SCB_HEAD",
+	    0x12c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_qfreeze_count_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "QFREEZE_COUNT",
+	    0x12e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_saved_mode_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SAVED_MODE",
+	    0x130, regvalue, cur_col, wrap));
+}
+
+int
+ahd_msg_out_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "MSG_OUT",
+	    0x131, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t DMAPARAMS_parse_table[] = {
+	{ "FIFORESET",		0x01, 0x01 },
+	{ "FIFOFLUSH",		0x02, 0x02 },
+	{ "DIRECTION",		0x04, 0x04 },
+	{ "HDMAEN",		0x08, 0x08 },
+	{ "HDMAENACK",		0x08, 0x08 },
+	{ "SDMAEN",		0x10, 0x10 },
+	{ "SDMAENACK",		0x10, 0x10 },
+	{ "SCSIEN",		0x20, 0x20 },
+	{ "WIDEODD",		0x40, 0x40 },
+	{ "PRELOADEN",		0x80, 0x80 }
+};
+
+int
+ahd_dmaparams_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(DMAPARAMS_parse_table, 10, "DMAPARAMS",
+	    0x132, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQ_FLAGS_parse_table[] = {
+	{ "NO_DISCONNECT",	0x01, 0x01 },
+	{ "SPHASE_PENDING",	0x02, 0x02 },
+	{ "DPHASE_PENDING",	0x04, 0x04 },
+	{ "CMDPHASE_PENDING",	0x08, 0x08 },
+	{ "TARG_CMD_PENDING",	0x10, 0x10 },
+	{ "DPHASE",		0x20, 0x20 },
+	{ "NO_CDB_SENT",	0x40, 0x40 },
+	{ "TARGET_CMD_IS_TAGGED",0x40, 0x40 },
+	{ "NOT_IDENTIFIED",	0x80, 0x80 }
+};
+
+int
+ahd_seq_flags_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQ_FLAGS_parse_table, 9, "SEQ_FLAGS",
+	    0x133, regvalue, cur_col, wrap));
+}
+
+int
+ahd_saved_scsiid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SAVED_SCSIID",
+	    0x134, regvalue, cur_col, wrap));
+}
+
+int
+ahd_saved_lun_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SAVED_LUN",
+	    0x135, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t LASTPHASE_parse_table[] = {
+	{ "P_DATAOUT",		0x00, 0xe0 },
+	{ "P_DATAOUT_DT",	0x20, 0xe0 },
+	{ "P_DATAIN",		0x40, 0xe0 },
+	{ "P_DATAIN_DT",	0x60, 0xe0 },
+	{ "P_COMMAND",		0x80, 0xe0 },
+	{ "P_MESGOUT",		0xa0, 0xe0 },
+	{ "P_STATUS",		0xc0, 0xe0 },
+	{ "P_MESGIN",		0xe0, 0xe0 },
+	{ "P_BUSFREE",		0x01, 0x01 },
+	{ "MSGI",		0x20, 0x20 },
+	{ "IOI",		0x40, 0x40 },
+	{ "CDI",		0x80, 0x80 },
+	{ "PHASE_MASK",		0xe0, 0xe0 }
+};
+
+int
+ahd_lastphase_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(LASTPHASE_parse_table, 13, "LASTPHASE",
+	    0x136, regvalue, cur_col, wrap));
+}
+
+int
+ahd_qoutfifo_entry_valid_tag_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "QOUTFIFO_ENTRY_VALID_TAG",
+	    0x137, regvalue, cur_col, wrap));
+}
+
+int
+ahd_shared_data_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SHARED_DATA_ADDR",
+	    0x138, regvalue, cur_col, wrap));
+}
+
+int
+ahd_qoutfifo_next_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "QOUTFIFO_NEXT_ADDR",
+	    0x13c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_kernel_tqinpos_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "KERNEL_TQINPOS",
+	    0x140, regvalue, cur_col, wrap));
+}
+
+int
+ahd_tqinpos_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "TQINPOS",
+	    0x141, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t ARG_1_parse_table[] = {
+	{ "CONT_MSG_LOOP_TARG",	0x02, 0x02 },
+	{ "CONT_MSG_LOOP_READ",	0x03, 0x03 },
+	{ "CONT_MSG_LOOP_WRITE",0x04, 0x04 },
+	{ "EXIT_MSG_LOOP",	0x08, 0x08 },
+	{ "MSGOUT_PHASEMIS",	0x10, 0x10 },
+	{ "SEND_REJ",		0x20, 0x20 },
+	{ "SEND_SENSE",		0x40, 0x40 },
+	{ "SEND_MSG",		0x80, 0x80 }
+};
+
+int
+ahd_arg_1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(ARG_1_parse_table, 8, "ARG_1",
+	    0x142, regvalue, cur_col, wrap));
+}
+
+int
+ahd_arg_2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ARG_2",
+	    0x143, regvalue, cur_col, wrap));
+}
+
+int
+ahd_last_msg_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LAST_MSG",
+	    0x144, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCSISEQ_TEMPLATE_parse_table[] = {
+	{ "ALTSTIM",		0x01, 0x01 },
+	{ "ENAUTOATNP",		0x02, 0x02 },
+	{ "MANUALP",		0x0c, 0x0c },
+	{ "ENRSELI",		0x10, 0x10 },
+	{ "ENSELI",		0x20, 0x20 },
+	{ "MANUALCTL",		0x40, 0x40 }
+};
+
+int
+ahd_scsiseq_template_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCSISEQ_TEMPLATE_parse_table, 6, "SCSISEQ_TEMPLATE",
+	    0x145, regvalue, cur_col, wrap));
+}
+
+int
+ahd_initiator_tag_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "INITIATOR_TAG",
+	    0x146, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SEQ_FLAGS2_parse_table[] = {
+	{ "TARGET_MSG_PENDING",	0x02, 0x02 },
+	{ "SELECTOUT_QFROZEN",	0x04, 0x04 }
+};
+
+int
+ahd_seq_flags2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SEQ_FLAGS2_parse_table, 2, "SEQ_FLAGS2",
+	    0x147, regvalue, cur_col, wrap));
+}
+
+int
+ahd_allocfifo_scbptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "ALLOCFIFO_SCBPTR",
+	    0x148, regvalue, cur_col, wrap));
+}
+
+int
+ahd_int_coalescing_timer_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "INT_COALESCING_TIMER",
+	    0x14a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_int_coalescing_maxcmds_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "INT_COALESCING_MAXCMDS",
+	    0x14c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_int_coalescing_mincmds_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "INT_COALESCING_MINCMDS",
+	    0x14d, regvalue, cur_col, wrap));
+}
+
+int
+ahd_cmds_pending_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CMDS_PENDING",
+	    0x14e, regvalue, cur_col, wrap));
+}
+
+int
+ahd_int_coalescing_cmdcount_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "INT_COALESCING_CMDCOUNT",
+	    0x150, regvalue, cur_col, wrap));
+}
+
+int
+ahd_local_hs_mailbox_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "LOCAL_HS_MAILBOX",
+	    0x151, regvalue, cur_col, wrap));
+}
+
+int
+ahd_cmdsize_table_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "CMDSIZE_TABLE",
+	    0x152, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_base_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_BASE",
+	    0x180, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_residual_datacnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_RESIDUAL_DATACNT",
+	    0x180, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCB_RESIDUAL_SGPTR_parse_table[] = {
+	{ "SG_LIST_NULL",	0x01, 0x01 },
+	{ "SG_OVERRUN_RESID",	0x02, 0x02 },
+	{ "SG_ADDR_MASK",	0xf8, 0xf8 }
+};
+
+int
+ahd_scb_residual_sgptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCB_RESIDUAL_SGPTR_parse_table, 3, "SCB_RESIDUAL_SGPTR",
+	    0x184, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_scsi_status_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_SCSI_STATUS",
+	    0x188, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_target_phases_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_TARGET_PHASES",
+	    0x189, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_target_data_dir_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_TARGET_DATA_DIR",
+	    0x18a, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_target_itag_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_TARGET_ITAG",
+	    0x18b, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_sense_busaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_SENSE_BUSADDR",
+	    0x18c, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_tag_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_TAG",
+	    0x190, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCB_CONTROL_parse_table[] = {
+	{ "SCB_TAG_TYPE",	0x03, 0x03 },
+	{ "DISCONNECTED",	0x04, 0x04 },
+	{ "STATUS_RCVD",	0x08, 0x08 },
+	{ "MK_MESSAGE",		0x10, 0x10 },
+	{ "TAG_ENB",		0x20, 0x20 },
+	{ "DISCENB",		0x40, 0x40 },
+	{ "TARGET_SCB",		0x80, 0x80 }
+};
+
+int
+ahd_scb_control_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCB_CONTROL_parse_table, 7, "SCB_CONTROL",
+	    0x192, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCB_SCSIID_parse_table[] = {
+	{ "OID",		0x0f, 0x0f },
+	{ "TID",		0xf0, 0xf0 }
+};
+
+int
+ahd_scb_scsiid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCB_SCSIID_parse_table, 2, "SCB_SCSIID",
+	    0x193, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCB_LUN_parse_table[] = {
+	{ "LID",		0xff, 0xff }
+};
+
+int
+ahd_scb_lun_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCB_LUN_parse_table, 1, "SCB_LUN",
+	    0x194, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCB_TASK_ATTRIBUTE_parse_table[] = {
+	{ "SCB_XFERLEN_ODD",	0x01, 0x01 }
+};
+
+int
+ahd_scb_task_attribute_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCB_TASK_ATTRIBUTE_parse_table, 1, "SCB_TASK_ATTRIBUTE",
+	    0x195, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCB_CDB_LEN_parse_table[] = {
+	{ "SCB_CDB_LEN_PTR",	0x80, 0x80 }
+};
+
+int
+ahd_scb_cdb_len_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCB_CDB_LEN_parse_table, 1, "SCB_CDB_LEN",
+	    0x196, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_task_management_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_TASK_MANAGEMENT",
+	    0x197, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_dataptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_DATAPTR",
+	    0x198, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCB_DATACNT_parse_table[] = {
+	{ "SG_HIGH_ADDR_BITS",	0x7f, 0x7f },
+	{ "SG_LAST_SEG",	0x80, 0x80 }
+};
+
+int
+ahd_scb_datacnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCB_DATACNT_parse_table, 2, "SCB_DATACNT",
+	    0x1a0, regvalue, cur_col, wrap));
+}
+
+static ahd_reg_parse_entry_t SCB_SGPTR_parse_table[] = {
+	{ "SG_LIST_NULL",	0x01, 0x01 },
+	{ "SG_FULL_RESID",	0x02, 0x02 },
+	{ "SG_STATUS_VALID",	0x04, 0x04 }
+};
+
+int
+ahd_scb_sgptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(SCB_SGPTR_parse_table, 3, "SCB_SGPTR",
+	    0x1a4, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_busaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_BUSADDR",
+	    0x1a8, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_next_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_NEXT",
+	    0x1ac, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_next2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_NEXT2",
+	    0x1ae, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_spare_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_SPARE",
+	    0x1b0, regvalue, cur_col, wrap));
+}
+
+int
+ahd_scb_disconnected_lists_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahd_print_register(NULL, 0, "SCB_DISCONNECTED_LISTS",
+	    0x1b8, regvalue, cur_col, wrap));
+}
+
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic79xx_seq.h linux-5730/drivers/scsi/aic7xxx/aic79xx_seq.h
--- linux-5720/drivers/scsi/aic7xxx/aic79xx_seq.h
+++ linux-5730/drivers/scsi/aic7xxx/aic79xx_seq.h
@@ -0,0 +1,1139 @@
+/*
+ * DO NOT EDIT - This file is automatically generated
+ *		 from the following source files:
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.seq#94 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic79xx.reg#70 $
+ */
+static uint8_t seqprog[] = {
+	0xff, 0x02, 0x06, 0x78,
+	0x00, 0xea, 0x50, 0x59,
+	0x01, 0xea, 0x04, 0x30,
+	0xff, 0x04, 0x0c, 0x78,
+	0x19, 0xea, 0x50, 0x59,
+	0x19, 0xea, 0x04, 0x00,
+	0x33, 0xea, 0x44, 0x59,
+	0x33, 0xea, 0x00, 0x00,
+	0x60, 0x3a, 0x1a, 0x68,
+	0x04, 0x47, 0x1b, 0x68,
+	0xff, 0x21, 0x1b, 0x70,
+	0x40, 0x4b, 0x92, 0x69,
+	0x00, 0xe2, 0x54, 0x59,
+	0x40, 0x4b, 0x92, 0x69,
+	0x20, 0x4b, 0x82, 0x69,
+	0xfc, 0x42, 0x24, 0x78,
+	0x10, 0x40, 0x24, 0x78,
+	0x00, 0xe2, 0xc4, 0x5d,
+	0x20, 0x4d, 0x28, 0x78,
+	0x00, 0xe2, 0xc4, 0x5d,
+	0x30, 0x3f, 0xc0, 0x09,
+	0x30, 0xe0, 0x30, 0x60,
+	0x7f, 0x4a, 0x94, 0x08,
+	0x00, 0xe2, 0x32, 0x40,
+	0xc0, 0x4a, 0x94, 0x00,
+	0x00, 0xe2, 0x3e, 0x58,
+	0x00, 0xe2, 0x56, 0x58,
+	0x00, 0xe2, 0x66, 0x58,
+	0x00, 0xe2, 0x06, 0x40,
+	0x33, 0xea, 0x44, 0x59,
+	0x33, 0xea, 0x00, 0x00,
+	0x01, 0x52, 0x64, 0x78,
+	0x02, 0x58, 0x50, 0x31,
+	0xff, 0xea, 0x10, 0x0b,
+	0xff, 0x97, 0x4f, 0x78,
+	0x50, 0x4b, 0x4a, 0x68,
+	0xbf, 0x3a, 0x74, 0x08,
+	0x14, 0xea, 0x50, 0x59,
+	0x14, 0xea, 0x04, 0x00,
+	0x08, 0x92, 0x25, 0x03,
+	0xff, 0x90, 0x3f, 0x68,
+	0x00, 0xe2, 0x56, 0x5b,
+	0x00, 0xe2, 0x3e, 0x40,
+	0x00, 0xea, 0x44, 0x59,
+	0x01, 0xea, 0x00, 0x30,
+	0x80, 0xf9, 0x5e, 0x68,
+	0x00, 0xe2, 0x42, 0x59,
+	0x11, 0xea, 0x44, 0x59,
+	0x11, 0xea, 0x00, 0x00,
+	0x80, 0xf9, 0x42, 0x79,
+	0xff, 0xea, 0xd4, 0x0d,
+	0x22, 0xea, 0x44, 0x59,
+	0x22, 0xea, 0x00, 0x00,
+	0x10, 0x16, 0x70, 0x78,
+	0x01, 0x0b, 0xa2, 0x32,
+	0x10, 0x16, 0x2c, 0x00,
+	0x18, 0xad, 0x00, 0x79,
+	0x04, 0xad, 0xca, 0x68,
+	0x80, 0xad, 0x64, 0x78,
+	0x10, 0xad, 0x98, 0x78,
+	0xff, 0x88, 0x83, 0x68,
+	0xe7, 0xad, 0x5a, 0x09,
+	0x02, 0x8c, 0x59, 0x32,
+	0x02, 0x28, 0x19, 0x33,
+	0x02, 0xa8, 0x50, 0x36,
+	0x33, 0xea, 0x44, 0x59,
+	0x33, 0xea, 0x00, 0x00,
+	0x40, 0x3a, 0x64, 0x68,
+	0x50, 0x4b, 0x64, 0x68,
+	0x22, 0xea, 0x44, 0x59,
+	0x22, 0xea, 0x00, 0x00,
+	0xe7, 0xad, 0x5a, 0x09,
+	0x02, 0x8c, 0x59, 0x32,
+	0x1a, 0xea, 0x50, 0x59,
+	0x1a, 0xea, 0x04, 0x00,
+	0xff, 0xea, 0xd4, 0x0d,
+	0xe7, 0xad, 0x5a, 0x09,
+	0x00, 0xe2, 0xa6, 0x58,
+	0xff, 0xea, 0x56, 0x02,
+	0x04, 0x7c, 0x78, 0x32,
+	0x20, 0x16, 0x64, 0x78,
+	0x04, 0x38, 0x79, 0x32,
+	0x80, 0x37, 0x6f, 0x16,
+	0xff, 0x2d, 0xb5, 0x60,
+	0xff, 0x29, 0xb5, 0x60,
+	0x40, 0x51, 0xc5, 0x78,
+	0xff, 0x4f, 0xb5, 0x68,
+	0xff, 0x4d, 0xc1, 0x19,
+	0x00, 0x4e, 0xd5, 0x19,
+	0x00, 0xe2, 0xc4, 0x50,
+	0x01, 0x4c, 0xc1, 0x31,
+	0x00, 0x50, 0xd5, 0x19,
+	0x00, 0xe2, 0xc4, 0x48,
+	0x80, 0x18, 0x64, 0x78,
+	0x02, 0x4a, 0x1d, 0x30,
+	0x10, 0xea, 0x18, 0x00,
+	0x60, 0x18, 0x30, 0x00,
+	0x7f, 0x18, 0x30, 0x0c,
+	0x02, 0xea, 0x02, 0x00,
+	0xff, 0xea, 0xa0, 0x0a,
+	0x80, 0x18, 0x30, 0x04,
+	0x40, 0xad, 0x64, 0x78,
+	0xe7, 0xad, 0x5a, 0x09,
+	0x02, 0xa8, 0x40, 0x31,
+	0xff, 0xea, 0xc0, 0x09,
+	0x01, 0x4e, 0x9d, 0x1a,
+	0x00, 0x4f, 0x9f, 0x22,
+	0x01, 0x94, 0x6d, 0x33,
+	0x01, 0xea, 0x20, 0x33,
+	0x04, 0xac, 0x49, 0x32,
+	0xff, 0xea, 0x5a, 0x03,
+	0xff, 0xea, 0x5e, 0x03,
+	0x01, 0x10, 0xd4, 0x31,
+	0x10, 0x92, 0xf5, 0x68,
+	0x3d, 0x93, 0xc5, 0x29,
+	0xfe, 0xe2, 0xc4, 0x09,
+	0x01, 0xea, 0xc6, 0x01,
+	0x02, 0xe2, 0xc8, 0x31,
+	0x02, 0xec, 0x50, 0x31,
+	0x02, 0xa0, 0xda, 0x31,
+	0xff, 0xa9, 0xf4, 0x70,
+	0x02, 0xa0, 0x58, 0x37,
+	0xff, 0x21, 0xfd, 0x70,
+	0x02, 0x22, 0x51, 0x31,
+	0x02, 0xa0, 0x5c, 0x33,
+	0x02, 0xa0, 0x44, 0x36,
+	0x02, 0xa0, 0x40, 0x32,
+	0x02, 0xa0, 0x44, 0x36,
+	0x04, 0x47, 0x05, 0x69,
+	0x40, 0x16, 0x30, 0x69,
+	0xff, 0x2d, 0x35, 0x61,
+	0xff, 0x29, 0x65, 0x70,
+	0x01, 0x37, 0xc1, 0x31,
+	0x02, 0x28, 0x55, 0x32,
+	0x01, 0xea, 0x5a, 0x01,
+	0x04, 0x3c, 0xf9, 0x30,
+	0x02, 0x28, 0x51, 0x31,
+	0x01, 0xa8, 0x60, 0x31,
+	0x00, 0xa9, 0x60, 0x01,
+	0x01, 0x14, 0xd4, 0x31,
+	0x01, 0x50, 0xa1, 0x1a,
+	0xff, 0x4e, 0x9d, 0x1a,
+	0xff, 0x4f, 0x9f, 0x22,
+	0xff, 0x8d, 0x29, 0x71,
+	0x80, 0xac, 0x28, 0x71,
+	0x20, 0x16, 0x28, 0x69,
+	0x02, 0x8c, 0x51, 0x31,
+	0x00, 0xe2, 0x12, 0x41,
+	0x01, 0xac, 0x08, 0x31,
+	0x09, 0xea, 0x5a, 0x01,
+	0x02, 0x8c, 0x51, 0x32,
+	0xff, 0xea, 0x1a, 0x07,
+	0x04, 0x24, 0xf9, 0x30,
+	0x1d, 0xea, 0x3a, 0x41,
+	0x02, 0x2c, 0x51, 0x31,
+	0x04, 0xa8, 0xf9, 0x30,
+	0x19, 0xea, 0x3a, 0x41,
+	0x06, 0xea, 0x08, 0x81,
+	0x01, 0xe2, 0x5a, 0x35,
+	0x02, 0xf2, 0xf0, 0x35,
+	0x02, 0xf2, 0xf0, 0x31,
+	0x02, 0xf8, 0xe4, 0x35,
+	0x80, 0xea, 0xb2, 0x01,
+	0x01, 0xe2, 0x00, 0x30,
+	0xff, 0xea, 0xb2, 0x0d,
+	0x80, 0xea, 0xb2, 0x01,
+	0x11, 0x00, 0x00, 0x10,
+	0xff, 0xea, 0xb2, 0x0d,
+	0x01, 0xe2, 0x04, 0x30,
+	0x01, 0xea, 0x04, 0x34,
+	0x02, 0x20, 0xbd, 0x30,
+	0x02, 0x20, 0xb9, 0x30,
+	0x02, 0x20, 0x51, 0x31,
+	0x4c, 0x93, 0xd7, 0x28,
+	0x10, 0x92, 0x63, 0x79,
+	0x01, 0x6b, 0xc0, 0x30,
+	0x02, 0x64, 0xc8, 0x00,
+	0x40, 0x3a, 0x74, 0x04,
+	0x00, 0xe2, 0x56, 0x58,
+	0x33, 0xea, 0x44, 0x59,
+	0x33, 0xea, 0x00, 0x00,
+	0x30, 0x3f, 0xc0, 0x09,
+	0x30, 0xe0, 0x64, 0x61,
+	0x20, 0x3f, 0x7a, 0x69,
+	0x10, 0x3f, 0x64, 0x79,
+	0x02, 0xea, 0x7e, 0x00,
+	0x00, 0xea, 0x44, 0x59,
+	0x01, 0xea, 0x00, 0x30,
+	0x02, 0x48, 0x51, 0x35,
+	0x01, 0xea, 0x7e, 0x00,
+	0x11, 0xea, 0x44, 0x59,
+	0x11, 0xea, 0x00, 0x00,
+	0x02, 0x48, 0x51, 0x35,
+	0x08, 0xea, 0x98, 0x00,
+	0x08, 0x57, 0xae, 0x00,
+	0x08, 0x3c, 0x78, 0x00,
+	0xf0, 0x49, 0x68, 0x0a,
+	0x0f, 0x67, 0xc0, 0x09,
+	0x00, 0x34, 0x69, 0x02,
+	0x20, 0xea, 0x96, 0x00,
+	0x00, 0xe2, 0xf8, 0x41,
+	0x40, 0x3a, 0xae, 0x69,
+	0x02, 0x55, 0x06, 0x68,
+	0x02, 0x56, 0xae, 0x69,
+	0xff, 0x5b, 0xae, 0x61,
+	0x02, 0x20, 0x51, 0x31,
+	0x80, 0xea, 0xb2, 0x01,
+	0x44, 0xea, 0x00, 0x00,
+	0x01, 0x33, 0xc0, 0x31,
+	0x33, 0xea, 0x00, 0x00,
+	0xff, 0xea, 0xb2, 0x09,
+	0xff, 0xe0, 0xc0, 0x19,
+	0xff, 0xe0, 0xb0, 0x79,
+	0x02, 0xac, 0x51, 0x31,
+	0x00, 0xe2, 0xa6, 0x41,
+	0x02, 0x5e, 0x50, 0x31,
+	0x02, 0xa8, 0xb8, 0x30,
+	0x02, 0x5c, 0x50, 0x31,
+	0xff, 0xad, 0xc1, 0x71,
+	0x02, 0xac, 0x41, 0x31,
+	0x02, 0x22, 0x51, 0x31,
+	0x02, 0xa0, 0x5c, 0x33,
+	0x02, 0xa0, 0x44, 0x32,
+	0x00, 0xe2, 0xca, 0x41,
+	0x10, 0x92, 0xcb, 0x69,
+	0x3d, 0x93, 0xc9, 0x29,
+	0x01, 0xe4, 0xc8, 0x01,
+	0x01, 0xea, 0xca, 0x01,
+	0xff, 0xea, 0xda, 0x01,
+	0x02, 0x20, 0x51, 0x31,
+	0x02, 0xae, 0x41, 0x32,
+	0xff, 0x21, 0xd3, 0x61,
+	0xff, 0xea, 0x46, 0x02,
+	0x02, 0x5c, 0x50, 0x31,
+	0x40, 0xea, 0x96, 0x00,
+	0x02, 0x56, 0xcc, 0x6d,
+	0x01, 0x55, 0xcc, 0x6d,
+	0x10, 0x92, 0xdf, 0x79,
+	0x10, 0x40, 0xe8, 0x69,
+	0x01, 0x56, 0xe8, 0x79,
+	0xff, 0x97, 0x07, 0x78,
+	0x13, 0xea, 0x50, 0x59,
+	0x13, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x06, 0x40,
+	0xbf, 0x3a, 0x74, 0x08,
+	0x08, 0xea, 0x98, 0x00,
+	0x08, 0x57, 0xae, 0x00,
+	0x01, 0x93, 0x69, 0x32,
+	0x01, 0x94, 0x6b, 0x32,
+	0x40, 0xea, 0x66, 0x02,
+	0x08, 0x3c, 0x78, 0x00,
+	0x80, 0xea, 0x62, 0x02,
+	0x00, 0xe2, 0xb8, 0x5b,
+	0x01, 0x36, 0xc1, 0x31,
+	0x9f, 0xe0, 0x4c, 0x7c,
+	0x80, 0xe0, 0x0c, 0x72,
+	0xa0, 0xe0, 0x44, 0x72,
+	0xc0, 0xe0, 0x3a, 0x72,
+	0xe0, 0xe0, 0x74, 0x72,
+	0x01, 0xea, 0x50, 0x59,
+	0x01, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0xf8, 0x41,
+	0x80, 0x33, 0x13, 0x7a,
+	0x03, 0xea, 0x50, 0x59,
+	0x03, 0xea, 0x04, 0x00,
+	0xee, 0x00, 0x1a, 0x6a,
+	0x05, 0xea, 0xb4, 0x00,
+	0x33, 0xea, 0x44, 0x59,
+	0x33, 0xea, 0x00, 0x00,
+	0x02, 0xa8, 0x90, 0x32,
+	0x00, 0xe2, 0x6a, 0x59,
+	0xef, 0x96, 0xd5, 0x19,
+	0x00, 0xe2, 0x2a, 0x52,
+	0x09, 0x80, 0xe1, 0x30,
+	0x02, 0xea, 0x36, 0x00,
+	0xa8, 0xea, 0x32, 0x00,
+	0x00, 0xe2, 0x30, 0x42,
+	0x01, 0x96, 0xd1, 0x30,
+	0x10, 0x80, 0x89, 0x31,
+	0x20, 0xea, 0x32, 0x00,
+	0xbf, 0x33, 0x67, 0x0a,
+	0x20, 0x19, 0x32, 0x6a,
+	0x02, 0x4d, 0xf8, 0x69,
+	0x40, 0x33, 0x67, 0x02,
+	0x00, 0xe2, 0xf8, 0x41,
+	0x80, 0x33, 0xb5, 0x6a,
+	0x01, 0x44, 0x10, 0x33,
+	0x08, 0x92, 0x25, 0x03,
+	0x00, 0xe2, 0xf8, 0x41,
+	0x10, 0xea, 0x80, 0x00,
+	0x01, 0x31, 0xc5, 0x31,
+	0x80, 0xe2, 0x60, 0x62,
+	0x10, 0x92, 0x85, 0x6a,
+	0xc0, 0x94, 0xc5, 0x01,
+	0x40, 0x92, 0x51, 0x6a,
+	0xbf, 0xe2, 0xc4, 0x09,
+	0x20, 0x92, 0x65, 0x7a,
+	0x01, 0xe2, 0x88, 0x30,
+	0x00, 0xe2, 0xb8, 0x5b,
+	0xa0, 0x36, 0x6d, 0x62,
+	0x23, 0x92, 0x89, 0x08,
+	0x00, 0xe2, 0xb8, 0x5b,
+	0xa0, 0x36, 0x6d, 0x62,
+	0x00, 0xa8, 0x64, 0x42,
+	0xff, 0xe2, 0x64, 0x62,
+	0x00, 0xe2, 0x84, 0x42,
+	0x40, 0xea, 0x98, 0x00,
+	0x01, 0xe2, 0x88, 0x30,
+	0x00, 0xe2, 0xb8, 0x5b,
+	0xa0, 0x36, 0x43, 0x72,
+	0x40, 0xea, 0x98, 0x00,
+	0x01, 0x31, 0x89, 0x32,
+	0x08, 0xea, 0x62, 0x02,
+	0x00, 0xe2, 0xf8, 0x41,
+	0xe0, 0xea, 0xd4, 0x5b,
+	0x80, 0xe0, 0xc0, 0x6a,
+	0x04, 0xe0, 0x66, 0x73,
+	0x02, 0xe0, 0x96, 0x73,
+	0x00, 0xea, 0x1e, 0x73,
+	0x03, 0xe0, 0xa6, 0x73,
+	0x23, 0xe0, 0x96, 0x72,
+	0x08, 0xe0, 0xbc, 0x72,
+	0x00, 0xe2, 0xb8, 0x5b,
+	0x07, 0xea, 0x50, 0x59,
+	0x07, 0xea, 0x04, 0x00,
+	0x08, 0x42, 0xf9, 0x71,
+	0x04, 0x42, 0x93, 0x62,
+	0x01, 0x43, 0x89, 0x30,
+	0x00, 0xe2, 0x84, 0x42,
+	0x01, 0x44, 0xd4, 0x31,
+	0x00, 0xe2, 0x84, 0x42,
+	0x01, 0x00, 0x60, 0x32,
+	0x33, 0xea, 0x44, 0x59,
+	0x33, 0xea, 0x00, 0x00,
+	0x4c, 0x34, 0xc1, 0x28,
+	0x01, 0x64, 0xc0, 0x31,
+	0x00, 0x30, 0x45, 0x59,
+	0x01, 0x30, 0x01, 0x30,
+	0x01, 0xe0, 0xba, 0x7a,
+	0xa0, 0xea, 0xca, 0x5b,
+	0x01, 0xa0, 0xba, 0x62,
+	0x01, 0x84, 0xaf, 0x7a,
+	0x01, 0x95, 0xbd, 0x6a,
+	0x05, 0xea, 0x50, 0x59,
+	0x05, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0xbc, 0x42,
+	0x03, 0xea, 0x50, 0x59,
+	0x03, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0xbc, 0x42,
+	0x07, 0xea, 0xdc, 0x5b,
+	0x01, 0x44, 0xd4, 0x31,
+	0x00, 0xe2, 0xf8, 0x41,
+	0x3f, 0xe0, 0x6a, 0x0a,
+	0xc0, 0x34, 0xc1, 0x09,
+	0x00, 0x35, 0x51, 0x01,
+	0xff, 0xea, 0x52, 0x09,
+	0x30, 0x34, 0xc5, 0x09,
+	0x3d, 0xe2, 0xc4, 0x29,
+	0xb8, 0xe2, 0xc4, 0x19,
+	0x01, 0xea, 0xc6, 0x01,
+	0x02, 0xe2, 0xc8, 0x31,
+	0x02, 0xec, 0x40, 0x31,
+	0xff, 0xa1, 0xdc, 0x72,
+	0x02, 0xe8, 0xda, 0x31,
+	0x02, 0xa0, 0x50, 0x31,
+	0x00, 0xe2, 0xfe, 0x42,
+	0x80, 0x33, 0x67, 0x02,
+	0x01, 0x44, 0xd4, 0x31,
+	0x00, 0xe2, 0xb8, 0x5b,
+	0x01, 0x33, 0x67, 0x02,
+	0xe0, 0x36, 0x19, 0x63,
+	0x02, 0x33, 0x67, 0x02,
+	0x20, 0x46, 0x12, 0x63,
+	0xff, 0xea, 0x52, 0x09,
+	0xa8, 0xea, 0xca, 0x5b,
+	0x04, 0x92, 0xf9, 0x7a,
+	0x01, 0x34, 0xc1, 0x31,
+	0x00, 0x93, 0xf9, 0x62,
+	0x01, 0x35, 0xc1, 0x31,
+	0x00, 0x94, 0x03, 0x73,
+	0x01, 0xa9, 0x52, 0x11,
+	0xff, 0xa9, 0xee, 0x6a,
+	0x00, 0xe2, 0x12, 0x43,
+	0x10, 0x33, 0x67, 0x02,
+	0x04, 0x92, 0x13, 0x7b,
+	0xfb, 0x92, 0x25, 0x0b,
+	0xff, 0xea, 0x66, 0x0a,
+	0x01, 0xa4, 0x0d, 0x6b,
+	0x02, 0xa8, 0x90, 0x32,
+	0x00, 0xe2, 0x6a, 0x59,
+	0x10, 0x92, 0xbd, 0x7a,
+	0xff, 0xea, 0xdc, 0x5b,
+	0x00, 0xe2, 0xbc, 0x42,
+	0x04, 0xea, 0x50, 0x59,
+	0x04, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0xbc, 0x42,
+	0x04, 0xea, 0x50, 0x59,
+	0x04, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0xf8, 0x41,
+	0x08, 0x92, 0xb5, 0x7a,
+	0xc0, 0x33, 0x29, 0x7b,
+	0x80, 0x33, 0xb5, 0x6a,
+	0xff, 0x88, 0x29, 0x6b,
+	0x40, 0x33, 0xb5, 0x6a,
+	0x10, 0x92, 0x2f, 0x7b,
+	0x0a, 0xea, 0x50, 0x59,
+	0x0a, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x4e, 0x5b,
+	0x00, 0xe2, 0x82, 0x43,
+	0x50, 0x4b, 0x36, 0x6b,
+	0xbf, 0x3a, 0x74, 0x08,
+	0x01, 0xe0, 0xf4, 0x31,
+	0xff, 0xea, 0xc0, 0x09,
+	0x01, 0x2e, 0x5d, 0x1a,
+	0x00, 0x2f, 0x5f, 0x22,
+	0x04, 0x47, 0x8f, 0x02,
+	0x01, 0xfa, 0xc0, 0x35,
+	0x02, 0xa8, 0x84, 0x32,
+	0x02, 0xea, 0xb4, 0x00,
+	0x33, 0xea, 0x44, 0x59,
+	0x33, 0xea, 0x00, 0x00,
+	0x02, 0x42, 0x51, 0x31,
+	0xff, 0x90, 0x65, 0x68,
+	0xff, 0x88, 0x5b, 0x6b,
+	0x01, 0xa4, 0x57, 0x6b,
+	0x02, 0xa4, 0x5f, 0x6b,
+	0x01, 0x84, 0x5f, 0x7b,
+	0x02, 0x28, 0x19, 0x33,
+	0x02, 0xa8, 0x50, 0x36,
+	0xff, 0x88, 0x5f, 0x73,
+	0x00, 0xe2, 0x32, 0x5b,
+	0x02, 0xa8, 0x20, 0x33,
+	0x02, 0x2c, 0x19, 0x33,
+	0x02, 0xa8, 0x58, 0x32,
+	0x04, 0xa4, 0x49, 0x07,
+	0xc0, 0x33, 0xb5, 0x6a,
+	0x04, 0x92, 0x25, 0x03,
+	0x20, 0x92, 0x83, 0x6b,
+	0x02, 0xa8, 0x40, 0x31,
+	0xc0, 0x34, 0xc1, 0x09,
+	0x00, 0x35, 0x51, 0x01,
+	0xff, 0xea, 0x52, 0x09,
+	0x30, 0x34, 0xc5, 0x09,
+	0x3d, 0xe2, 0xc4, 0x29,
+	0xb8, 0xe2, 0xc4, 0x19,
+	0x01, 0xea, 0xc6, 0x01,
+	0x02, 0xe2, 0xc8, 0x31,
+	0x02, 0xa0, 0xda, 0x31,
+	0x02, 0xa0, 0x50, 0x31,
+	0xf7, 0x57, 0xae, 0x08,
+	0x08, 0xea, 0x98, 0x00,
+	0x01, 0x44, 0xd4, 0x31,
+	0xee, 0x00, 0x8c, 0x6b,
+	0x02, 0xea, 0xb4, 0x00,
+	0x00, 0xe2, 0xb4, 0x5b,
+	0x09, 0x4c, 0x8e, 0x7b,
+	0x08, 0x4c, 0x06, 0x68,
+	0x0b, 0xea, 0x50, 0x59,
+	0x0b, 0xea, 0x04, 0x00,
+	0x01, 0x44, 0xd4, 0x31,
+	0x20, 0x33, 0xf9, 0x79,
+	0x00, 0xe2, 0x9e, 0x5b,
+	0x00, 0xe2, 0xf8, 0x41,
+	0x01, 0x84, 0xa3, 0x7b,
+	0x01, 0xa4, 0x49, 0x07,
+	0x08, 0x60, 0x30, 0x33,
+	0x08, 0x80, 0x41, 0x37,
+	0xdf, 0x33, 0x67, 0x0a,
+	0xee, 0x00, 0xb0, 0x6b,
+	0x05, 0xea, 0xb4, 0x00,
+	0x33, 0xea, 0x44, 0x59,
+	0x33, 0xea, 0x00, 0x00,
+	0x00, 0xe2, 0x6a, 0x59,
+	0x00, 0xe2, 0xbc, 0x42,
+	0x01, 0xea, 0x6c, 0x02,
+	0xc0, 0xea, 0x66, 0x06,
+	0xff, 0x42, 0xc4, 0x6b,
+	0x01, 0x41, 0xb8, 0x6b,
+	0x02, 0x41, 0xb8, 0x7b,
+	0xff, 0x42, 0xc4, 0x6b,
+	0x01, 0x41, 0xb8, 0x6b,
+	0x02, 0x41, 0xb8, 0x7b,
+	0xff, 0x42, 0xc4, 0x7b,
+	0x04, 0x4c, 0xb8, 0x6b,
+	0xe0, 0x41, 0x6c, 0x0e,
+	0x01, 0x44, 0xd4, 0x31,
+	0xff, 0x42, 0xcc, 0x7b,
+	0x04, 0x4c, 0xcc, 0x6b,
+	0xe0, 0x41, 0x6c, 0x0a,
+	0xe0, 0x36, 0xf9, 0x61,
+	0xff, 0xea, 0xca, 0x09,
+	0x01, 0xe2, 0xc8, 0x31,
+	0x01, 0x46, 0xda, 0x35,
+	0x01, 0x44, 0xd4, 0x35,
+	0x10, 0xea, 0x80, 0x00,
+	0x01, 0xe2, 0x62, 0x36,
+	0x04, 0xa6, 0xe4, 0x7b,
+	0xff, 0xea, 0x5a, 0x09,
+	0xff, 0xea, 0x4c, 0x0d,
+	0x01, 0xa6, 0x02, 0x6c,
+	0x10, 0xad, 0x64, 0x78,
+	0x80, 0xad, 0xfa, 0x6b,
+	0x08, 0xad, 0x64, 0x68,
+	0x04, 0x84, 0xf9, 0x30,
+	0x00, 0xea, 0x08, 0x81,
+	0xff, 0xea, 0xd4, 0x09,
+	0x02, 0x84, 0xf9, 0x88,
+	0x0d, 0xea, 0x5a, 0x01,
+	0x04, 0xa6, 0x4c, 0x05,
+	0x04, 0xa6, 0x64, 0x78,
+	0xff, 0xea, 0x5a, 0x09,
+	0x03, 0x84, 0x59, 0x89,
+	0x03, 0xea, 0x4c, 0x01,
+	0x80, 0x1a, 0x64, 0x78,
+	0x08, 0x19, 0x64, 0x78,
+	0x08, 0xb0, 0xe0, 0x30,
+	0x04, 0xb0, 0xe0, 0x30,
+	0x03, 0xb0, 0xf0, 0x30,
+	0x01, 0xb0, 0x06, 0x33,
+	0x7f, 0x83, 0xe9, 0x08,
+	0x04, 0xac, 0x58, 0x19,
+	0xff, 0xea, 0xc0, 0x09,
+	0x04, 0x84, 0x09, 0x9b,
+	0x00, 0x85, 0x0b, 0x23,
+	0x00, 0x86, 0x0d, 0x23,
+	0x00, 0x87, 0x0f, 0x23,
+	0x01, 0x84, 0xc5, 0x31,
+	0x80, 0x83, 0x25, 0x7c,
+	0x02, 0xe2, 0xc4, 0x01,
+	0xff, 0xea, 0x4c, 0x09,
+	0x01, 0xe2, 0x36, 0x30,
+	0xc8, 0x19, 0x32, 0x00,
+	0x88, 0x19, 0x32, 0x00,
+	0x01, 0xac, 0xd4, 0x99,
+	0x00, 0xe2, 0x64, 0x50,
+	0xfe, 0xa6, 0x4c, 0x0d,
+	0x0b, 0x98, 0xe1, 0x30,
+	0xfd, 0xa4, 0x49, 0x09,
+	0x80, 0xa3, 0x39, 0x7c,
+	0x02, 0xa4, 0x48, 0x01,
+	0x01, 0xa4, 0x36, 0x30,
+	0xa8, 0xea, 0x32, 0x00,
+	0xfd, 0xa4, 0x49, 0x0b,
+	0x05, 0xa3, 0x07, 0x33,
+	0x80, 0x83, 0x45, 0x6c,
+	0x02, 0xea, 0x4c, 0x05,
+	0xff, 0xea, 0x4c, 0x0d,
+	0x00, 0xe2, 0x3e, 0x59,
+	0x02, 0xa6, 0xe6, 0x6b,
+	0x80, 0xf9, 0xf2, 0x05,
+	0xc0, 0x33, 0x53, 0x7c,
+	0x03, 0xea, 0x50, 0x59,
+	0x03, 0xea, 0x04, 0x00,
+	0x20, 0x33, 0x77, 0x7c,
+	0x01, 0x84, 0x5d, 0x6c,
+	0x06, 0xea, 0x50, 0x59,
+	0x06, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x7a, 0x44,
+	0x01, 0x00, 0x60, 0x32,
+	0xee, 0x00, 0x66, 0x6c,
+	0x05, 0xea, 0xb4, 0x00,
+	0x33, 0xea, 0x44, 0x59,
+	0x33, 0xea, 0x00, 0x00,
+	0x80, 0x3d, 0x7a, 0x00,
+	0xfc, 0x42, 0x68, 0x7c,
+	0x7f, 0x3d, 0x7a, 0x08,
+	0x00, 0x30, 0x45, 0x59,
+	0x01, 0x30, 0x01, 0x30,
+	0x09, 0xea, 0x50, 0x59,
+	0x09, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0xf8, 0x41,
+	0x01, 0xa4, 0x5d, 0x6c,
+	0x00, 0xe2, 0x30, 0x5c,
+	0x20, 0x33, 0x67, 0x02,
+	0x01, 0x00, 0x60, 0x32,
+	0x02, 0xa6, 0x82, 0x7c,
+	0x00, 0xe2, 0x46, 0x5c,
+	0x00, 0xe2, 0x56, 0x58,
+	0x00, 0xe2, 0x66, 0x58,
+	0x00, 0xe2, 0x3a, 0x58,
+	0x00, 0x30, 0x45, 0x59,
+	0x01, 0x30, 0x01, 0x30,
+	0x20, 0x19, 0x82, 0x6c,
+	0x00, 0xe2, 0xb2, 0x5c,
+	0x04, 0x19, 0x9c, 0x6c,
+	0x02, 0x19, 0x32, 0x00,
+	0x01, 0x84, 0x9d, 0x7c,
+	0x01, 0x1b, 0x96, 0x7c,
+	0x01, 0x1a, 0x9c, 0x6c,
+	0x00, 0xe2, 0x4c, 0x44,
+	0x80, 0x4b, 0xa2, 0x6c,
+	0x01, 0x4c, 0x9e, 0x7c,
+	0x03, 0x42, 0x4c, 0x6c,
+	0x00, 0xe2, 0xe0, 0x5b,
+	0x80, 0xf9, 0xf2, 0x01,
+	0x04, 0x33, 0xf9, 0x79,
+	0x00, 0xe2, 0xf8, 0x41,
+	0x08, 0x5d, 0xba, 0x6c,
+	0x00, 0xe2, 0x56, 0x58,
+	0x00, 0x30, 0x45, 0x59,
+	0x01, 0x30, 0x01, 0x30,
+	0x02, 0x1b, 0xaa, 0x7c,
+	0x08, 0x5d, 0xb8, 0x7c,
+	0x03, 0x68, 0x00, 0x37,
+	0x01, 0x84, 0x09, 0x07,
+	0x80, 0x1b, 0xc4, 0x7c,
+	0x80, 0x84, 0xc5, 0x6c,
+	0xff, 0x85, 0x0b, 0x1b,
+	0xff, 0x86, 0x0d, 0x23,
+	0xff, 0x87, 0x0f, 0x23,
+	0xf8, 0x1b, 0x08, 0x0b,
+	0xff, 0xea, 0x06, 0x0b,
+	0x03, 0x68, 0x00, 0x37,
+	0x00, 0xe2, 0xc4, 0x58,
+	0x10, 0xea, 0x18, 0x00,
+	0xf9, 0xd9, 0xb2, 0x0d,
+	0x01, 0xd9, 0xb2, 0x05,
+	0x01, 0x52, 0x48, 0x31,
+	0x20, 0xa4, 0xee, 0x7c,
+	0x20, 0x5b, 0xee, 0x7c,
+	0x80, 0xf9, 0xfc, 0x7c,
+	0x02, 0xea, 0xb4, 0x00,
+	0x11, 0x00, 0x00, 0x10,
+	0x04, 0x19, 0x08, 0x7d,
+	0xdf, 0x19, 0x32, 0x08,
+	0x60, 0x5b, 0xe6, 0x6c,
+	0x01, 0x4c, 0xe2, 0x7c,
+	0x20, 0x19, 0x32, 0x00,
+	0x01, 0xd9, 0xb2, 0x05,
+	0x02, 0xea, 0xb4, 0x00,
+	0x01, 0xd9, 0xb2, 0x05,
+	0x10, 0x5b, 0x00, 0x6d,
+	0x08, 0x5b, 0x0a, 0x6d,
+	0x20, 0x5b, 0xfa, 0x6c,
+	0x02, 0x5b, 0x2a, 0x6d,
+	0x0e, 0xea, 0x50, 0x59,
+	0x0e, 0xea, 0x04, 0x00,
+	0x80, 0xf9, 0xea, 0x6c,
+	0xdf, 0x5c, 0xb8, 0x08,
+	0x01, 0xd9, 0xb2, 0x05,
+	0x01, 0xa4, 0xe5, 0x6d,
+	0x00, 0xe2, 0x30, 0x5c,
+	0x00, 0xe2, 0x34, 0x5d,
+	0x01, 0x90, 0x21, 0x1b,
+	0x01, 0xd9, 0xb2, 0x05,
+	0x00, 0xe2, 0x32, 0x5b,
+	0xf3, 0x96, 0xd5, 0x19,
+	0x00, 0xe2, 0x18, 0x55,
+	0x80, 0x96, 0x19, 0x6d,
+	0x0f, 0xea, 0x50, 0x59,
+	0x0f, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x20, 0x45,
+	0x04, 0x8c, 0xe1, 0x30,
+	0x01, 0xea, 0xf2, 0x00,
+	0x02, 0xea, 0x36, 0x00,
+	0xa8, 0xea, 0x32, 0x00,
+	0xff, 0x97, 0x27, 0x7d,
+	0x14, 0xea, 0x50, 0x59,
+	0x14, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x96, 0x5d,
+	0x01, 0xd9, 0xb2, 0x05,
+	0x09, 0x80, 0xe1, 0x30,
+	0x02, 0xea, 0x36, 0x00,
+	0xa8, 0xea, 0x32, 0x00,
+	0x00, 0xe2, 0x8e, 0x5d,
+	0x01, 0xd9, 0xb2, 0x05,
+	0x02, 0xa6, 0x44, 0x7d,
+	0x00, 0xe2, 0x3e, 0x59,
+	0x20, 0x5b, 0x52, 0x6d,
+	0xfc, 0x42, 0x3e, 0x7d,
+	0x10, 0x40, 0x40, 0x6d,
+	0x20, 0x4d, 0x42, 0x7d,
+	0x08, 0x5d, 0x52, 0x6d,
+	0x02, 0xa6, 0xe6, 0x6b,
+	0x00, 0xe2, 0x3e, 0x59,
+	0x20, 0x5b, 0x52, 0x6d,
+	0x01, 0x1b, 0x72, 0x6d,
+	0xfc, 0x42, 0x4e, 0x7d,
+	0x10, 0x40, 0x50, 0x6d,
+	0x20, 0x4d, 0x64, 0x78,
+	0x08, 0x5d, 0x64, 0x78,
+	0x02, 0x19, 0x32, 0x00,
+	0x01, 0x5b, 0x40, 0x31,
+	0x00, 0xe2, 0xb2, 0x5c,
+	0x00, 0xe2, 0x9e, 0x5b,
+	0x20, 0xea, 0xb6, 0x00,
+	0x00, 0xe2, 0xe0, 0x5b,
+	0x20, 0x5c, 0xb8, 0x00,
+	0x04, 0x19, 0x68, 0x6d,
+	0x01, 0x1a, 0x68, 0x6d,
+	0x00, 0xe2, 0x3e, 0x59,
+	0x01, 0x1a, 0x64, 0x78,
+	0x80, 0xf9, 0xf2, 0x01,
+	0x20, 0xa0, 0xcc, 0x7d,
+	0xff, 0x90, 0x21, 0x1b,
+	0x08, 0x92, 0x43, 0x6b,
+	0x02, 0xea, 0xb4, 0x04,
+	0x01, 0xa4, 0x49, 0x03,
+	0x40, 0x5b, 0x82, 0x6d,
+	0x00, 0xe2, 0x3e, 0x59,
+	0x40, 0x5b, 0x82, 0x6d,
+	0x04, 0x5d, 0xe6, 0x7d,
+	0x01, 0x1a, 0xe6, 0x7d,
+	0x20, 0x4d, 0x64, 0x78,
+	0x40, 0x5b, 0xcc, 0x7d,
+	0x04, 0x5d, 0xe6, 0x7d,
+	0x01, 0x1a, 0xe6, 0x7d,
+	0x80, 0xf9, 0xf2, 0x01,
+	0xff, 0x90, 0x21, 0x1b,
+	0x08, 0x92, 0x43, 0x6b,
+	0x02, 0xea, 0xb4, 0x04,
+	0x00, 0xe2, 0x3e, 0x59,
+	0x01, 0x1b, 0x64, 0x78,
+	0x80, 0xf9, 0xf2, 0x01,
+	0x02, 0xea, 0xb4, 0x04,
+	0x00, 0xe2, 0x3e, 0x59,
+	0x01, 0x1b, 0xaa, 0x6d,
+	0x40, 0x5b, 0xb8, 0x7d,
+	0x01, 0x1b, 0xaa, 0x6d,
+	0x02, 0x19, 0x32, 0x00,
+	0x01, 0x1a, 0x64, 0x78,
+	0x80, 0xf9, 0xf2, 0x01,
+	0xff, 0xea, 0x10, 0x03,
+	0x08, 0x92, 0x25, 0x03,
+	0x00, 0xe2, 0x42, 0x43,
+	0x01, 0x1a, 0xb4, 0x7d,
+	0x40, 0x5b, 0xb0, 0x7d,
+	0x01, 0x1a, 0x9e, 0x6d,
+	0xfc, 0x42, 0x64, 0x78,
+	0x01, 0x1a, 0xb8, 0x6d,
+	0x10, 0xea, 0x50, 0x59,
+	0x10, 0xea, 0x04, 0x00,
+	0xfc, 0x42, 0x64, 0x78,
+	0x10, 0x40, 0xbe, 0x6d,
+	0x20, 0x4d, 0x64, 0x78,
+	0x40, 0x5b, 0x9e, 0x6d,
+	0x01, 0x1a, 0x64, 0x78,
+	0x01, 0x90, 0x21, 0x1b,
+	0x30, 0x3f, 0xc0, 0x09,
+	0x30, 0xe0, 0x64, 0x60,
+	0x40, 0x4b, 0x64, 0x68,
+	0xff, 0xea, 0x52, 0x01,
+	0xee, 0x00, 0xd2, 0x6d,
+	0x80, 0xf9, 0xf2, 0x01,
+	0xff, 0x90, 0x21, 0x1b,
+	0x02, 0xea, 0xb4, 0x00,
+	0x20, 0xea, 0x9a, 0x00,
+	0xf3, 0x42, 0xde, 0x6d,
+	0x12, 0xea, 0x50, 0x59,
+	0x12, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0xf8, 0x41,
+	0x0d, 0xea, 0x50, 0x59,
+	0x0d, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0xf8, 0x41,
+	0x01, 0x90, 0x21, 0x1b,
+	0x11, 0xea, 0x50, 0x59,
+	0x11, 0xea, 0x04, 0x00,
+	0x00, 0xe2, 0x32, 0x5b,
+	0x08, 0x5a, 0xb4, 0x00,
+	0x00, 0xe2, 0x0c, 0x5e,
+	0xa8, 0xea, 0x32, 0x00,
+	0x00, 0xe2, 0x3e, 0x59,
+	0x80, 0x1a, 0xfa, 0x7d,
+	0x00, 0xe2, 0x0c, 0x5e,
+	0x80, 0x19, 0x32, 0x00,
+	0x40, 0x5b, 0x00, 0x6e,
+	0x08, 0x5a, 0x00, 0x7e,
+	0x20, 0x4d, 0x64, 0x78,
+	0x02, 0x84, 0x09, 0x03,
+	0x40, 0x5b, 0xcc, 0x7d,
+	0xff, 0x90, 0x21, 0x1b,
+	0x80, 0xf9, 0xf2, 0x01,
+	0x08, 0x92, 0x43, 0x6b,
+	0x02, 0xea, 0xb4, 0x04,
+	0x01, 0x38, 0xe1, 0x30,
+	0x05, 0x39, 0xe3, 0x98,
+	0x01, 0xe0, 0xf4, 0x31,
+	0xff, 0xea, 0xc0, 0x09,
+	0x00, 0x3a, 0xe5, 0x20,
+	0x00, 0x3b, 0xe7, 0x20,
+	0x01, 0xfa, 0xc0, 0x31,
+	0x04, 0xea, 0xe8, 0x30,
+	0xff, 0xea, 0xf0, 0x08,
+	0x02, 0xea, 0xf2, 0x00,
+	0xff, 0xea, 0xf4, 0x0c
+};
+
+typedef int ahd_patch_func_t (struct ahd_softc *ahd);
+static ahd_patch_func_t ahd_patch22_func;
+
+static int
+ahd_patch22_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch21_func;
+
+static int
+ahd_patch21_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_PKT_BITBUCKET_BUG) == 0);
+}
+
+static ahd_patch_func_t ahd_patch20_func;
+
+static int
+ahd_patch20_func(struct ahd_softc *ahd)
+{
+	return ((ahd->features & AHD_RTI) == 0);
+}
+
+static ahd_patch_func_t ahd_patch19_func;
+
+static int
+ahd_patch19_func(struct ahd_softc *ahd)
+{
+	return ((ahd->flags & AHD_INITIATORROLE) != 0);
+}
+
+static ahd_patch_func_t ahd_patch18_func;
+
+static int
+ahd_patch18_func(struct ahd_softc *ahd)
+{
+	return ((ahd->flags & AHD_TARGETROLE) != 0);
+}
+
+static ahd_patch_func_t ahd_patch17_func;
+
+static int
+ahd_patch17_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_AUTOFLUSH_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch16_func;
+
+static int
+ahd_patch16_func(struct ahd_softc *ahd)
+{
+	return ((ahd->features & AHD_NEW_DFCNTRL_OPTS) != 0);
+}
+
+static ahd_patch_func_t ahd_patch15_func;
+
+static int
+ahd_patch15_func(struct ahd_softc *ahd)
+{
+	return ((ahd->flags & AHD_39BIT_ADDRESSING) != 0);
+}
+
+static ahd_patch_func_t ahd_patch14_func;
+
+static int
+ahd_patch14_func(struct ahd_softc *ahd)
+{
+	return ((ahd->flags & AHD_64BIT_ADDRESSING) != 0);
+}
+
+static ahd_patch_func_t ahd_patch13_func;
+
+static int
+ahd_patch13_func(struct ahd_softc *ahd)
+{
+	return ((ahd->features & AHD_NEW_DFCNTRL_OPTS) == 0);
+}
+
+static ahd_patch_func_t ahd_patch12_func;
+
+static int
+ahd_patch12_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_REG_SLOW_SETTLE_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch11_func;
+
+static int
+ahd_patch11_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_EARLY_REQ_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch10_func;
+
+static int
+ahd_patch10_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_BUSFREEREV_BUG) == 0);
+}
+
+static ahd_patch_func_t ahd_patch9_func;
+
+static int
+ahd_patch9_func(struct ahd_softc *ahd)
+{
+	return ((ahd->flags & AHD_SEQUENCER_DEBUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch8_func;
+
+static int
+ahd_patch8_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_LQO_ATNO_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch7_func;
+
+static int
+ahd_patch7_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_BUSFREEREV_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch6_func;
+
+static int
+ahd_patch6_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_NONPACKFIFO_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch5_func;
+
+static int
+ahd_patch5_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_SENT_SCB_UPDATE_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch4_func;
+
+static int
+ahd_patch4_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_PKT_LUN_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch3_func;
+
+static int
+ahd_patch3_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_FAINT_LED_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch2_func;
+
+static int
+ahd_patch2_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_SET_MODE_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch1_func;
+
+static int
+ahd_patch1_func(struct ahd_softc *ahd)
+{
+	return ((ahd->bugs & AHD_INTCOLLISION_BUG) != 0);
+}
+
+static ahd_patch_func_t ahd_patch0_func;
+
+static int
+ahd_patch0_func(struct ahd_softc *ahd)
+{
+	return (0);
+}
+
+static struct patch {
+	ahd_patch_func_t		*patch_func;
+	uint32_t		 begin		:10,
+				 skip_instr	:10,
+				 skip_patch	:12;
+} patches[] = {
+	{ ahd_patch1_func, 0, 3, 3 },
+	{ ahd_patch1_func, 1, 1, 2 },
+	{ ahd_patch0_func, 2, 1, 1 },
+	{ ahd_patch1_func, 3, 3, 3 },
+	{ ahd_patch1_func, 4, 1, 2 },
+	{ ahd_patch0_func, 5, 1, 1 },
+	{ ahd_patch2_func, 6, 1, 2 },
+	{ ahd_patch0_func, 7, 1, 1 },
+	{ ahd_patch3_func, 20, 5, 1 },
+	{ ahd_patch2_func, 29, 1, 2 },
+	{ ahd_patch0_func, 30, 1, 1 },
+	{ ahd_patch1_func, 37, 1, 2 },
+	{ ahd_patch0_func, 38, 1, 1 },
+	{ ahd_patch2_func, 43, 1, 2 },
+	{ ahd_patch0_func, 44, 1, 1 },
+	{ ahd_patch2_func, 47, 1, 2 },
+	{ ahd_patch0_func, 48, 1, 1 },
+	{ ahd_patch2_func, 51, 1, 2 },
+	{ ahd_patch0_func, 52, 1, 1 },
+	{ ahd_patch2_func, 65, 1, 2 },
+	{ ahd_patch0_func, 66, 1, 1 },
+	{ ahd_patch2_func, 69, 1, 2 },
+	{ ahd_patch0_func, 70, 1, 1 },
+	{ ahd_patch1_func, 73, 1, 2 },
+	{ ahd_patch0_func, 74, 1, 1 },
+	{ ahd_patch4_func, 107, 1, 1 },
+	{ ahd_patch2_func, 162, 6, 1 },
+	{ ahd_patch1_func, 168, 2, 1 },
+	{ ahd_patch5_func, 170, 1, 1 },
+	{ ahd_patch2_func, 179, 1, 2 },
+	{ ahd_patch0_func, 180, 1, 1 },
+	{ ahd_patch6_func, 181, 2, 2 },
+	{ ahd_patch0_func, 183, 6, 3 },
+	{ ahd_patch2_func, 186, 1, 2 },
+	{ ahd_patch0_func, 187, 1, 1 },
+	{ ahd_patch2_func, 190, 1, 2 },
+	{ ahd_patch0_func, 191, 1, 1 },
+	{ ahd_patch7_func, 193, 2, 1 },
+	{ ahd_patch5_func, 201, 16, 2 },
+	{ ahd_patch0_func, 217, 1, 1 },
+	{ ahd_patch8_func, 237, 2, 1 },
+	{ ahd_patch1_func, 241, 1, 2 },
+	{ ahd_patch0_func, 242, 1, 1 },
+	{ ahd_patch7_func, 245, 2, 1 },
+	{ ahd_patch1_func, 259, 1, 2 },
+	{ ahd_patch0_func, 260, 1, 1 },
+	{ ahd_patch1_func, 263, 1, 2 },
+	{ ahd_patch0_func, 264, 1, 1 },
+	{ ahd_patch2_func, 267, 1, 2 },
+	{ ahd_patch0_func, 268, 1, 1 },
+	{ ahd_patch1_func, 323, 1, 2 },
+	{ ahd_patch0_func, 324, 1, 1 },
+	{ ahd_patch2_func, 332, 1, 2 },
+	{ ahd_patch0_func, 333, 1, 1 },
+	{ ahd_patch2_func, 336, 1, 2 },
+	{ ahd_patch0_func, 337, 1, 1 },
+	{ ahd_patch1_func, 343, 1, 2 },
+	{ ahd_patch0_func, 344, 1, 1 },
+	{ ahd_patch1_func, 346, 1, 2 },
+	{ ahd_patch0_func, 347, 1, 1 },
+	{ ahd_patch9_func, 366, 1, 1 },
+	{ ahd_patch9_func, 369, 1, 1 },
+	{ ahd_patch9_func, 371, 1, 1 },
+	{ ahd_patch9_func, 383, 1, 1 },
+	{ ahd_patch1_func, 393, 1, 2 },
+	{ ahd_patch0_func, 394, 1, 1 },
+	{ ahd_patch1_func, 396, 1, 2 },
+	{ ahd_patch0_func, 397, 1, 1 },
+	{ ahd_patch1_func, 405, 1, 2 },
+	{ ahd_patch0_func, 406, 1, 1 },
+	{ ahd_patch2_func, 419, 1, 2 },
+	{ ahd_patch0_func, 420, 1, 1 },
+	{ ahd_patch10_func, 450, 1, 1 },
+	{ ahd_patch1_func, 457, 1, 2 },
+	{ ahd_patch0_func, 458, 1, 1 },
+	{ ahd_patch2_func, 470, 1, 2 },
+	{ ahd_patch0_func, 471, 1, 1 },
+	{ ahd_patch11_func, 476, 6, 2 },
+	{ ahd_patch0_func, 482, 1, 1 },
+	{ ahd_patch12_func, 505, 1, 1 },
+	{ ahd_patch13_func, 514, 1, 1 },
+	{ ahd_patch14_func, 515, 1, 2 },
+	{ ahd_patch0_func, 516, 1, 1 },
+	{ ahd_patch15_func, 519, 1, 1 },
+	{ ahd_patch14_func, 520, 1, 1 },
+	{ ahd_patch16_func, 531, 1, 2 },
+	{ ahd_patch0_func, 532, 1, 1 },
+	{ ahd_patch1_func, 551, 1, 2 },
+	{ ahd_patch0_func, 552, 1, 1 },
+	{ ahd_patch1_func, 555, 1, 2 },
+	{ ahd_patch0_func, 556, 1, 1 },
+	{ ahd_patch2_func, 561, 1, 2 },
+	{ ahd_patch0_func, 562, 1, 1 },
+	{ ahd_patch2_func, 566, 1, 2 },
+	{ ahd_patch0_func, 567, 1, 1 },
+	{ ahd_patch1_func, 568, 1, 2 },
+	{ ahd_patch0_func, 569, 1, 1 },
+	{ ahd_patch2_func, 580, 1, 2 },
+	{ ahd_patch0_func, 581, 1, 1 },
+	{ ahd_patch17_func, 585, 1, 1 },
+	{ ahd_patch18_func, 590, 1, 1 },
+	{ ahd_patch19_func, 591, 2, 1 },
+	{ ahd_patch18_func, 595, 1, 2 },
+	{ ahd_patch0_func, 596, 1, 1 },
+	{ ahd_patch2_func, 599, 1, 2 },
+	{ ahd_patch0_func, 600, 1, 1 },
+	{ ahd_patch2_func, 615, 1, 2 },
+	{ ahd_patch0_func, 616, 1, 1 },
+	{ ahd_patch20_func, 617, 14, 1 },
+	{ ahd_patch1_func, 635, 1, 2 },
+	{ ahd_patch0_func, 636, 1, 1 },
+	{ ahd_patch20_func, 637, 1, 1 },
+	{ ahd_patch1_func, 649, 1, 2 },
+	{ ahd_patch0_func, 650, 1, 1 },
+	{ ahd_patch1_func, 657, 1, 2 },
+	{ ahd_patch0_func, 658, 1, 1 },
+	{ ahd_patch17_func, 681, 1, 1 },
+	{ ahd_patch17_func, 719, 1, 1 },
+	{ ahd_patch1_func, 730, 1, 2 },
+	{ ahd_patch0_func, 731, 1, 1 },
+	{ ahd_patch1_func, 748, 1, 2 },
+	{ ahd_patch0_func, 749, 1, 1 },
+	{ ahd_patch1_func, 751, 1, 2 },
+	{ ahd_patch0_func, 752, 1, 1 },
+	{ ahd_patch1_func, 755, 1, 2 },
+	{ ahd_patch0_func, 756, 1, 1 },
+	{ ahd_patch21_func, 758, 1, 2 },
+	{ ahd_patch0_func, 759, 2, 1 },
+	{ ahd_patch22_func, 762, 4, 2 },
+	{ ahd_patch0_func, 766, 1, 1 },
+	{ ahd_patch22_func, 774, 11, 1 }
+};
+
+static struct cs {
+	uint16_t	begin;
+	uint16_t	end;
+} critical_sections[] = {
+	{ 11, 12 },
+	{ 13, 14 },
+	{ 29, 42 },
+	{ 56, 59 },
+	{ 101, 128 },
+	{ 129, 157 },
+	{ 159, 162 },
+	{ 170, 178 },
+	{ 201, 250 },
+	{ 681, 697 },
+	{ 697, 711 },
+	{ 721, 725 }
+};
+
+static const int num_critical_sections = sizeof(critical_sections)
+				       / sizeof(*critical_sections);
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx.h linux-5730/drivers/scsi/aic7xxx/aic7xxx.h
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx.h
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx.h
@@ -37,9 +37,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.h#45 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.h#79 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.h,v 1.16.2.13 2002/04/29 19:36:29 gibbs Exp $
+ * $FreeBSD$
  */
 
 #ifndef _AIC7XXX_H_
@@ -93,11 +93,19 @@ struct seeprom_descriptor;
 #define	SCB_GET_CHANNEL(ahc, scb) \
 	SCSIID_CHANNEL(ahc, (scb)->hscb->scsiid)
 #define	SCB_GET_LUN(scb) \
-	((scb)->hscb->lun)
+	((scb)->hscb->lun & LID)
 #define SCB_GET_TARGET_OFFSET(ahc, scb)	\
 	(SCB_GET_TARGET(ahc, scb) + (SCB_IS_SCSIBUS_B(ahc, scb) ? 8 : 0))
 #define SCB_GET_TARGET_MASK(ahc, scb) \
 	(0x01 << (SCB_GET_TARGET_OFFSET(ahc, scb)))
+#ifdef AHC_DEBUG
+#define SCB_IS_SILENT(scb)					\
+	((ahc_debug & AHC_SHOW_MASKED_ERRORS) == 0		\
+      && (((scb)->flags & SCB_SILENT) != 0))
+#else
+#define SCB_IS_SILENT(scb)					\
+	(((scb)->flags & SCB_SILENT) != 0)
+#endif
 #define TCL_TARGET_OFFSET(tcl) \
 	((((tcl) >> 4) & TID) >> 4)
 #define TCL_LUN(tcl) \
@@ -171,7 +179,7 @@ struct seeprom_descriptor;
 #define AHC_TMODE_CMDS	256
 
 /* Reset line assertion time in us */
-#define AHC_BUSRESET_DELAY	250
+#define AHC_BUSRESET_DELAY	25
 
 /******************* Chip Characteristics/Operating Settings  *****************/
 /*
@@ -310,11 +318,11 @@ typedef enum {
  */
 typedef enum {
 	AHC_FNONE	      = 0x000,
-	AHC_PRIMARY_CHANNEL   = 0x003,/*
+	AHC_PRIMARY_CHANNEL   = 0x003,  /*
 					 * The channel that should
 					 * be probed first.
 					 */
-	AHC_USEDEFAULTS	      = 0x004,/*
+	AHC_USEDEFAULTS	      = 0x004,  /*
 					 * For cards without an seeprom
 					 * or a BIOS to initialize the chip's
 					 * SRAM, we use the default target
@@ -322,29 +330,29 @@ typedef enum {
 					 */
 	AHC_SEQUENCER_DEBUG   = 0x008,
 	AHC_SHARED_SRAM	      = 0x010,
-	AHC_LARGE_SEEPROM     = 0x020,/* Uses C56_66 not C46 */
+	AHC_LARGE_SEEPROM     = 0x020,  /* Uses C56_66 not C46 */
 	AHC_RESET_BUS_A	      = 0x040,
 	AHC_RESET_BUS_B	      = 0x080,
 	AHC_EXTENDED_TRANS_A  = 0x100,
 	AHC_EXTENDED_TRANS_B  = 0x200,
 	AHC_TERM_ENB_A	      = 0x400,
 	AHC_TERM_ENB_B	      = 0x800,
-	AHC_INITIATORROLE     = 0x1000,/*
+	AHC_INITIATORROLE     = 0x1000,  /*
 					  * Allow initiator operations on
 					  * this controller.
 					  */
-	AHC_TARGETROLE	      = 0x2000,/*
+	AHC_TARGETROLE	      = 0x2000,  /*
 					  * Allow target operations on this
 					  * controller.
 					  */
 	AHC_NEWEEPROM_FMT     = 0x4000,
 	AHC_RESOURCE_SHORTAGE = 0x8000,
-	AHC_TQINFIFO_BLOCKED  = 0x10000,/* Blocked waiting for ATIOs */
-	AHC_INT50_SPEEDFLEX   = 0x20000,/*
+	AHC_TQINFIFO_BLOCKED  = 0x10000,  /* Blocked waiting for ATIOs */
+	AHC_INT50_SPEEDFLEX   = 0x20000,  /*
 					   * Internal 50pin connector
 					   * sits behind an aic3860
 					   */
-	AHC_SCB_BTT	      = 0x40000,/*
+	AHC_SCB_BTT	      = 0x40000,  /*
 					   * The busy targets table is
 					   * stored in SCB space rather
 					   * than SRAM.
@@ -355,14 +363,17 @@ typedef enum {
 	AHC_EDGE_INTERRUPT    = 0x800000,  /* Device uses edge triggered ints */
 	AHC_39BIT_ADDRESSING  = 0x1000000, /* Use 39 bit addressing scheme. */
 	AHC_LSCBS_ENABLED     = 0x2000000, /* 64Byte SCBs enabled */
-	AHC_SCB_CONFIG_USED   = 0x4000000  /* No SEEPROM but SCB2 had info. */
+	AHC_SCB_CONFIG_USED   = 0x4000000, /* No SEEPROM but SCB2 had info. */
+	AHC_NO_BIOS_INIT      = 0x8000000, /* No BIOS left over settings. */
+	AHC_DISABLE_PCI_PERR  = 0x10000000,
+	AHC_HAS_TERM_LOGIC    = 0x20000000
 } ahc_flag;
 
 /************************* Hardware  SCB Definition ***************************/
 
 /*
  * The driver keeps up to MAX_SCB scb structures per card in memory.  The SCB
- * consists of a "hardware SCB" mirroring the fields availible on the card
+ * consists of a "hardware SCB" mirroring the fields available on the card
  * and additional information the kernel stores for each transaction.
  *
  * To minimize space utilization, a portion of the hardware scb stores
@@ -534,10 +545,27 @@ typedef enum {
 	SCB_RECOVERY_SCB	= 0x0020,
 	SCB_AUTO_NEGOTIATE	= 0x0040,/* Negotiate to achieve goal. */
 	SCB_NEGOTIATE		= 0x0080,/* Negotiation forced for command. */
-	SCB_ABORT		= 0x1000,
-	SCB_UNTAGGEDQ		= 0x2000,
-	SCB_ACTIVE		= 0x4000,
-	SCB_TARGET_IMMEDIATE	= 0x8000
+	SCB_ABORT		= 0x0100,
+	SCB_UNTAGGEDQ		= 0x0200,
+	SCB_ACTIVE		= 0x0400,
+	SCB_TARGET_IMMEDIATE	= 0x0800,
+	SCB_TRANSMISSION_ERROR	= 0x1000,/*
+					  * We detected a parity or CRC
+					  * error that has effected the
+					  * payload of the command.  This
+					  * flag is checked when normal
+					  * status is returned to catch
+					  * the case of a target not
+					  * responding to our attempt
+					  * to report the error.
+					  */
+	SCB_TARGET_SCB		= 0x2000,
+	SCB_SILENT		= 0x4000 /*
+					  * Be quiet about transmission type
+					  * errors.  They are expected and we
+					  * don't want to upset the user.  This
+					  * flag is typically used during DV.
+					  */
 } scb_flag;
 
 struct scb {
@@ -662,6 +690,11 @@ struct ahc_tmode_lstate;
 #define AHC_TRANS_GOAL		0x04	/* Modify negotiation goal */
 #define AHC_TRANS_USER		0x08	/* Modify user negotiation settings */
 
+#define AHC_WIDTH_UNKNOWN	0xFF
+#define AHC_PERIOD_UNKNOWN	0xFF
+#define AHC_OFFSET_UNKNOWN	0xFF
+#define AHC_PPR_OPTS_UNKNOWN	0xFF
+
 /*
  * Transfer Negotiation Information.
  */
@@ -716,10 +749,9 @@ struct ahc_syncrate {
 	char *rate;
 };
 
-/*
- * The synchronouse transfer rate table.
- */
-extern struct ahc_syncrate ahc_syncrates[];
+/* Safe and valid period for async negotiations. */
+#define	AHC_ASYNC_XFER_PERIOD 0x45
+#define	AHC_ULTRA2_XFER_PERIOD 0x0a
 
 /*
  * Indexes into our table of syncronous transfer rates.
@@ -728,6 +760,8 @@ extern struct ahc_syncrate ahc_syncrates
 #define AHC_SYNCRATE_ULTRA2	1
 #define AHC_SYNCRATE_ULTRA	3
 #define AHC_SYNCRATE_FAST	6
+#define AHC_SYNCRATE_MAX	AHC_SYNCRATE_DT
+#define	AHC_SYNCRATE_MIN	13
 
 /***************************** Lookup Tables **********************************/
 /*
@@ -802,7 +836,7 @@ struct seeprom_config {
 #define		CFSEAUTOTERM	0x0400	/* Ultra2 Perform secondary Auto Term*/
 #define		CFSELOWTERM	0x0800	/* Ultra2 secondary low term */
 #define		CFSEHIGHTERM	0x1000	/* Ultra2 secondary high term */
-#define		CFDOMAINVAL	0x4000	/* Perform Domain Validation*/
+#define		CFENABLEDV	0x4000	/* Perform Domain Validation*/
 
 /*
  * Bus Release Time, Host Adapter ID
@@ -844,31 +878,40 @@ typedef enum {
 /*********************** Software Configuration Structure *********************/
 TAILQ_HEAD(scb_tailq, scb);
 
-struct ahc_suspend_channel_state {
-	uint8_t	scsiseq;
-	uint8_t	sxfrctl0;
-	uint8_t	sxfrctl1;
-	uint8_t	simode0;
-	uint8_t	simode1;
-	uint8_t	seltimer;
-	uint8_t	seqctl;
-};
-
-struct ahc_suspend_state {
-	struct	ahc_suspend_channel_state channel[2];
-	uint8_t	optionmode;
-	uint8_t	dscommand0;
-	uint8_t	dspcistatus;
-	/* hsmailbox */
-	uint8_t	crccontrol1;
-	uint8_t	scbbaddr;
-	/* Host and sequencer SCB counts */
-	uint8_t	dff_thrsh;
-	uint8_t	*scratch_ram;
-	uint8_t	*btt;
+struct ahc_aic7770_softc {
+	/*
+	 * Saved register state used for chip_init().
+	 */
+	uint8_t busspd;
+	uint8_t bustime;
+};
+
+struct ahc_pci_softc {
+	/*
+	 * Saved register state used for chip_init().
+	 */
+	uint32_t  devconfig;
+	uint16_t  targcrccnt;
+	uint8_t   command;
+	uint8_t   csize_lattime;
+	uint8_t   optionmode;
+	uint8_t   crccontrol1;
+	uint8_t   dscommand0;
+	uint8_t   dspcistatus;
+	uint8_t   scbbaddr;
+	uint8_t   dff_thrsh;
+};
+
+union ahc_bus_softc {
+	struct ahc_aic7770_softc aic7770_softc;
+	struct ahc_pci_softc pci_softc;
 };
 
 typedef void (*ahc_bus_intr_t)(struct ahc_softc *);
+typedef int (*ahc_bus_chip_init_t)(struct ahc_softc *);
+typedef int (*ahc_bus_suspend_t)(struct ahc_softc *);
+typedef int (*ahc_bus_resume_t)(struct ahc_softc *);
+typedef void ahc_callback_t (void *);
 
 struct ahc_softc {
 	bus_space_tag_t           tag;
@@ -903,6 +946,11 @@ struct ahc_softc {
 	struct scb_tailq	  untagged_queues[AHC_NUM_TARGETS];
 
 	/*
+	 * Bus attachment specific data.
+	 */
+	union ahc_bus_softc	  bus_softc;
+
+	/*
 	 * Platform specific data.
 	 */
 	struct ahc_platform_data *platform_data;
@@ -918,6 +966,22 @@ struct ahc_softc {
 	ahc_bus_intr_t		  bus_intr;
 
 	/*
+	 * Bus specific initialization required
+	 * after a chip reset.
+	 */
+	ahc_bus_chip_init_t	  bus_chip_init;
+
+	/*
+	 * Bus specific suspend routine.
+	 */
+	ahc_bus_suspend_t	  bus_suspend;
+
+	/*
+	 * Bus specific resume routine.
+	 */
+	ahc_bus_resume_t	  bus_resume;
+
+	/*
 	 * Target mode related state kept on a per enabled lun basis.
 	 * Targets that are not enabled will have null entries.
 	 * As an initiator, we keep one target entry for our initiator
@@ -983,6 +1047,11 @@ struct ahc_softc {
 	uint8_t			  tqinfifonext;
 
 	/*
+	 * Cached copy of the sequencer control register.
+	 */
+	uint8_t			  seqctl;
+
+	/*
 	 * Incoming and outgoing message handling.
 	 */
 	uint8_t			  send_msg_perror;
@@ -1009,9 +1078,6 @@ struct ahc_softc {
 	 */
 	bus_addr_t		  dma_bug_buf;
 
-	/* Information saved through suspend/resume cycles */
-	struct ahc_suspend_state  suspend_state;
-
 	/* Number of enabled target mode device on this card */
 	u_int			  enabled_luns;
 
@@ -1021,6 +1087,17 @@ struct ahc_softc {
 	/* PCI cacheline size. */
 	u_int			  pci_cachesize;
 
+	/*
+	 * Count of parity errors we have seen as a target.
+	 * We auto-disable parity error checking after seeing
+	 * AHC_PCI_TARGET_PERR_THRESH number of errors.
+	 */
+	u_int			  pci_target_perr_count;
+#define		AHC_PCI_TARGET_PERR_THRESH	10
+
+	/* Maximum number of sequencer instructions supported. */
+	u_int			  instruction_ram_size;
+
 	/* Per-Unit descriptive information */
 	const char		 *description;
 	char			 *name;
@@ -1066,17 +1143,17 @@ struct ahc_pci_identity {
 	char			*name;
 	ahc_device_setup_t	*setup;
 };
-extern struct ahc_pci_identity ahc_pci_ident_table [];
+extern struct ahc_pci_identity ahc_pci_ident_table[];
 extern const u_int ahc_num_pci_devs;
 
 /***************************** VL/EISA Declarations ***************************/
 struct aic7770_identity {
 	uint32_t		 full_id;
 	uint32_t		 id_mask;
-	char			*name;
+	const char		*name;
 	ahc_device_setup_t	*setup;
 };
-extern struct aic7770_identity aic7770_ident_table [];
+extern struct aic7770_identity aic7770_ident_table[];
 extern const int ahc_num_aic7770_devs;
 
 #define AHC_EISA_SLOT_OFFSET	0xc00
@@ -1093,6 +1170,7 @@ void			ahc_busy_tcl(struct ahc_softc *ah
 struct ahc_pci_identity	*ahc_find_pci_device(ahc_dev_softc_t);
 int			 ahc_pci_config(struct ahc_softc *,
 					struct ahc_pci_identity *);
+int			 ahc_pci_test_register_access(struct ahc_softc *);
 
 /*************************** EISA/VL Front End ********************************/
 struct aic7770_identity *aic7770_find_device(uint32_t);
@@ -1115,6 +1193,7 @@ int		ahc_match_scb(struct ahc_softc *ahc
 struct ahc_softc	*ahc_alloc(void *platform_arg, char *name);
 int			 ahc_softc_init(struct ahc_softc *);
 void			 ahc_controller_info(struct ahc_softc *ahc, char *buf);
+int			 ahc_chip_init(struct ahc_softc *ahc);
 int			 ahc_init(struct ahc_softc *ahc);
 void			 ahc_intr_enable(struct ahc_softc *ahc, int enable);
 void			 ahc_pause_and_flushwork(struct ahc_softc *ahc);
@@ -1126,11 +1205,10 @@ void			 ahc_set_unit(struct ahc_softc *,
 void			 ahc_set_name(struct ahc_softc *, char *);
 void			 ahc_alloc_scbs(struct ahc_softc *ahc);
 void			 ahc_free(struct ahc_softc *ahc);
-int			 ahc_reset(struct ahc_softc *ahc);
+int			 ahc_reset(struct ahc_softc *ahc, int reinit);
 void			 ahc_shutdown(void *arg);
 
 /*************************** Interrupt Services *******************************/
-void			ahc_pci_intr(struct ahc_softc *ahc);
 void			ahc_clear_intstat(struct ahc_softc *ahc);
 void			ahc_run_qoutfifo(struct ahc_softc *ahc);
 #ifdef AHC_TARGET_MODE
@@ -1191,11 +1269,20 @@ void			ahc_validate_width(struct ahc_sof
 					   struct ahc_initiator_tinfo *tinfo,
 					   u_int *bus_width,
 					   role_t role);
+/*
+ * Negotiation types.  These are used to qualify if we should renegotiate
+ * even if our goal and current transport parameters are identical.
+ */
+typedef enum {
+	AHC_NEG_TO_GOAL,	/* Renegotiate only if goal and curr differ. */
+	AHC_NEG_IF_NON_ASYNC,	/* Renegotiate so long as goal is non-async. */
+	AHC_NEG_ALWAYS		/* Renegotiat even if goal is async. */
+} ahc_neg_type;
 int			ahc_update_neg_request(struct ahc_softc*,
 					       struct ahc_devinfo*,
 					       struct ahc_tmode_tstate*,
 					       struct ahc_initiator_tinfo*,
-					       int /*force*/);
+					       ahc_neg_type);
 void			ahc_set_width(struct ahc_softc *ahc,
 				      struct ahc_devinfo *devinfo,
 				      u_int width, u_int type, int paused);
@@ -1232,12 +1319,32 @@ cam_status	ahc_find_tmode_devs(struct ah
 #endif
 /******************************* Debug ***************************************/
 #ifdef AHC_DEBUG
-extern int ahc_debug;
-#define	AHC_SHOWMISC	0x1
-#define	AHC_SHOWSENSE	0x2
+extern uint32_t ahc_debug;
+#define	AHC_SHOW_MISC		0x0001
+#define	AHC_SHOW_SENSE		0x0002
+#define AHC_DUMP_SEEPROM	0x0004
+#define AHC_SHOW_TERMCTL	0x0008
+#define AHC_SHOW_MEMORY		0x0010
+#define AHC_SHOW_MESSAGES	0x0020
+#define	AHC_SHOW_DV		0x0040
+#define AHC_SHOW_SELTO		0x0080
+#define AHC_SHOW_QFULL		0x0200
+#define AHC_SHOW_QUEUE		0x0400
+#define AHC_SHOW_TQIN		0x0800
+#define AHC_SHOW_MASKED_ERRORS	0x1000
+#define AHC_DEBUG_SEQUENCER	0x2000
 #endif
 void			ahc_print_scb(struct scb *scb);
+void			ahc_print_devinfo(struct ahc_softc *ahc,
+					  struct ahc_devinfo *dev);
 void			ahc_dump_card_state(struct ahc_softc *ahc);
+int			ahc_print_register(ahc_reg_parse_entry_t *table,
+					   u_int num_entries,
+					   const char *name,
+					   u_int address,
+					   u_int value,
+					   u_int *cur_column,
+					   u_int wrap_point);
 /******************************* SEEPROM *************************************/
 int		ahc_acquire_seeprom(struct ahc_softc *ahc,
 				    struct seeprom_descriptor *sd);
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx.reg linux-5730/drivers/scsi/aic7xxx/aic7xxx.reg
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx.reg
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx.reg
@@ -37,9 +37,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.reg,v 1.20.2.11 2002/04/29 19:36:30 gibbs Exp $
+ * $FreeBSD$
  */
-VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#30 $"
+VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#39 $"
 
 /*
  * This file is processed by the aic7xxx_asm utility for use in assembling
@@ -57,14 +57,14 @@ VERSION = "$Id: //depot/aic7xxx/aic7xxx/
 register SCSISEQ {
 	address			0x000
 	access_mode RW
-	bit	TEMODE		0x80
-	bit	ENSELO		0x40
-	bit	ENSELI		0x20
-	bit	ENRSELI		0x10
-	bit	ENAUTOATNO	0x08
-	bit	ENAUTOATNI	0x04
-	bit	ENAUTOATNP	0x02
-	bit	SCSIRSTO	0x01
+	field	TEMODE		0x80
+	field	ENSELO		0x40
+	field	ENSELI		0x20
+	field	ENRSELI		0x10
+	field	ENAUTOATNO	0x08
+	field	ENAUTOATNI	0x04
+	field	ENAUTOATNP	0x02
+	field	SCSIRSTO	0x01
 }
 
 /*
@@ -74,13 +74,13 @@ register SCSISEQ {
 register SXFRCTL0 {
 	address			0x001
 	access_mode RW
-	bit	DFON		0x80
-	bit	DFPEXP		0x40
-	bit	FAST20		0x20
-	bit	CLRSTCNT	0x10
-	bit	SPIOEN		0x08
-	bit	SCAMEN		0x04
-	bit	CLRCHN		0x02
+	field	DFON		0x80
+	field	DFPEXP		0x40
+	field	FAST20		0x20
+	field	CLRSTCNT	0x10
+	field	SPIOEN		0x08
+	field	SCAMEN		0x04
+	field	CLRCHN		0x02
 }
 
 /*
@@ -90,13 +90,13 @@ register SXFRCTL0 {
 register SXFRCTL1 {
 	address			0x002
 	access_mode RW
-	bit	BITBUCKET	0x80
-	bit	SWRAPEN		0x40
-	bit	ENSPCHK		0x20
+	field	BITBUCKET	0x80
+	field	SWRAPEN		0x40
+	field	ENSPCHK		0x20
 	mask	STIMESEL	0x18
-	bit	ENSTIMER	0x04
-	bit	ACTNEGEN	0x02
-	bit	STPWEN		0x01	/* Powered Termination */
+	field	ENSTIMER	0x04
+	field	ACTNEGEN	0x02
+	field	STPWEN		0x01	/* Powered Termination */
 }
 
 /*
@@ -106,14 +106,14 @@ register SXFRCTL1 {
 register SCSISIGI {
 	address			0x003
 	access_mode RO
-	bit	CDI		0x80
-	bit	IOI		0x40
-	bit	MSGI		0x20
-	bit	ATNI		0x10
-	bit	SELI		0x08
-	bit	BSYI		0x04
-	bit	REQI		0x02
-	bit	ACKI		0x01
+	field	CDI		0x80
+	field	IOI		0x40
+	field	MSGI		0x20
+	field	ATNI		0x10
+	field	SELI		0x08
+	field	BSYI		0x04
+	field	REQI		0x02
+	field	ACKI		0x01
 /*
  * Possible phases in SCSISIGI
  */
@@ -137,14 +137,14 @@ register SCSISIGI {
 register SCSISIGO {
 	address			0x003
 	access_mode WO
-	bit	CDO		0x80
-	bit	IOO		0x40
-	bit	MSGO		0x20
-	bit	ATNO		0x10
-	bit	SELO		0x08
-	bit	BSYO		0x04
-	bit	REQO		0x02
-	bit	ACKO		0x01
+	field	CDO		0x80
+	field	IOO		0x40
+	field	MSGO		0x20
+	field	ATNO		0x10
+	field	SELO		0x08
+	field	BSYO		0x04
+	field	REQO		0x02
+	field	ACKO		0x01
 /*
  * Possible phases to write into SCSISIG0
  */
@@ -167,9 +167,9 @@ register SCSISIGO {
 register SCSIRATE {
 	address			0x004
 	access_mode RW
-	bit	WIDEXFER	0x80		/* Wide transfer control */
-	bit	ENABLE_CRC	0x40		/* CRC for D-Phases */
-	bit	SINGLE_EDGE	0x10		/* Disable DT Transfers */
+	field	WIDEXFER	0x80		/* Wide transfer control */
+	field	ENABLE_CRC	0x40		/* CRC for D-Phases */
+	field	SINGLE_EDGE	0x10		/* Disable DT Transfers */
 	mask	SXFR		0x70		/* Sync transfer rate */
 	mask	SXFR_ULTRA2	0x0f		/* Sync transfer rate */
 	mask	SOFS		0x0f		/* Sync offset */
@@ -185,7 +185,7 @@ register SCSIID	{
 	access_mode RW
 	mask	TID		0xf0		/* Target ID mask */
 	mask	TWIN_TID	0x70
-	bit	TWIN_CHNLB	0x80
+	field	TWIN_CHNLB	0x80
 	mask	OID		0x0f		/* Our ID mask */
 	/*
 	 * SCSI Maximum Offset (p. 4-61 aic7890/91 Data Book)
@@ -225,18 +225,27 @@ register STCNT {
 	access_mode RW
 }
 
+/* ALT_MODE registers (Ultra2 and Ultra160 chips) */
+register SXFRCTL2 {
+	address			0x013
+	access_mode RW
+	field	AUTORSTDIS	0x10
+	field	CMDDMAEN	0x08
+	mask	ASYNC_SETUP	0x07
+}
+
 /* ALT_MODE register on Ultra160 chips */
 register OPTIONMODE {
 	address			0x008
 	access_mode RW
-	bit	AUTORATEEN		0x80
-	bit	AUTOACKEN		0x40
-	bit	ATNMGMNTEN		0x20
-	bit	BUSFREEREV		0x10
-	bit	EXPPHASEDIS		0x08
-	bit	SCSIDATL_IMGEN		0x04
-	bit	AUTO_MSGOUT_DE		0x02
-	bit	DIS_MSGIN_DUALEDGE	0x01
+	field	AUTORATEEN		0x80
+	field	AUTOACKEN		0x40
+	field	ATNMGMNTEN		0x20
+	field	BUSFREEREV		0x10
+	field	EXPPHASEDIS		0x08
+	field	SCSIDATL_IMGEN		0x04
+	field	AUTO_MSGOUT_DE		0x02
+	field	DIS_MSGIN_DUALEDGE	0x01
 	mask	OPTIONMODE_DEFAULTS	AUTO_MSGOUT_DE|DIS_MSGIN_DUALEDGE
 }
 
@@ -254,12 +263,12 @@ register TARGCRCCNT {
 register CLRSINT0 {
 	address			0x00b
 	access_mode WO
-	bit	CLRSELDO	0x40
-	bit	CLRSELDI	0x20
-	bit	CLRSELINGO	0x10
-	bit	CLRSWRAP	0x08
-	bit	CLRIOERR	0x08	/* Ultra2 Only */
-	bit	CLRSPIORDY	0x02
+	field	CLRSELDO	0x40
+	field	CLRSELDI	0x20
+	field	CLRSELINGO	0x10
+	field	CLRSWRAP	0x08
+	field	CLRIOERR	0x08	/* Ultra2 Only */
+	field	CLRSPIORDY	0x02
 }
 
 /*
@@ -270,15 +279,15 @@ register CLRSINT0 {
 register SSTAT0	{
 	address			0x00b
 	access_mode RO
-	bit	TARGET		0x80	/* Board acting as target */
-	bit	SELDO		0x40	/* Selection Done */
-	bit	SELDI		0x20	/* Board has been selected */
-	bit	SELINGO		0x10	/* Selection In Progress */
-	bit	SWRAP		0x08	/* 24bit counter wrap */
-	bit	IOERR		0x08	/* LVD Tranceiver mode changed */
-	bit	SDONE		0x04	/* STCNT = 0x000000 */
-	bit	SPIORDY		0x02	/* SCSI PIO Ready */
-	bit	DMADONE		0x01	/* DMA transfer completed */
+	field	TARGET		0x80	/* Board acting as target */
+	field	SELDO		0x40	/* Selection Done */
+	field	SELDI		0x20	/* Board has been selected */
+	field	SELINGO		0x10	/* Selection In Progress */
+	field	SWRAP		0x08	/* 24bit counter wrap */
+	field	IOERR		0x08	/* LVD Tranceiver mode changed */
+	field	SDONE		0x04	/* STCNT = 0x000000 */
+	field	SPIORDY		0x02	/* SCSI PIO Ready */
+	field	DMADONE		0x01	/* DMA transfer completed */
 }
 
 /*
@@ -288,13 +297,13 @@ register SSTAT0	{
 register CLRSINT1 {
 	address			0x00c
 	access_mode WO
-	bit	CLRSELTIMEO	0x80
-	bit	CLRATNO		0x40
-	bit	CLRSCSIRSTI	0x20
-	bit	CLRBUSFREE	0x08
-	bit	CLRSCSIPERR	0x04
-	bit	CLRPHASECHG	0x02
-	bit	CLRREQINIT	0x01
+	field	CLRSELTIMEO	0x80
+	field	CLRATNO		0x40
+	field	CLRSCSIRSTI	0x20
+	field	CLRBUSFREE	0x08
+	field	CLRSCSIPERR	0x04
+	field	CLRPHASECHG	0x02
+	field	CLRREQINIT	0x01
 }
 
 /*
@@ -303,14 +312,14 @@ register CLRSINT1 {
 register SSTAT1	{
 	address			0x00c
 	access_mode RO
-	bit	SELTO		0x80
-	bit	ATNTARG 	0x40
-	bit	SCSIRSTI	0x20
-	bit	PHASEMIS	0x10
-	bit	BUSFREE		0x08
-	bit	SCSIPERR	0x04
-	bit	PHASECHG	0x02
-	bit	REQINIT		0x01
+	field	SELTO		0x80
+	field	ATNTARG 	0x40
+	field	SCSIRSTI	0x20
+	field	PHASEMIS	0x10
+	field	BUSFREE		0x08
+	field	SCSIPERR	0x04
+	field	PHASECHG	0x02
+	field	REQINIT		0x01
 }
 
 /*
@@ -319,13 +328,13 @@ register SSTAT1	{
 register SSTAT2 {
 	address			0x00d
 	access_mode RO
-	bit	OVERRUN		0x80
-	bit	SHVALID		0x40	/* Shaddow Layer non-zero */
-	bit	EXP_ACTIVE	0x10	/* SCSI Expander Active */
-	bit	CRCVALERR	0x08	/* CRC doesn't match (U3 only) */
-	bit	CRCENDERR	0x04	/* No terminal CRC packet (U3 only) */
-	bit	CRCREQERR	0x02	/* Illegal CRC packet req (U3 only) */
-	bit	DUAL_EDGE_ERR	0x01	/* Incorrect data phase (U3 only) */
+	field	OVERRUN		0x80
+	field	SHVALID		0x40	/* Shaddow Layer non-zero */
+	field	EXP_ACTIVE	0x10	/* SCSI Expander Active */
+	field	CRCVALERR	0x08	/* CRC doesn't match (U3 only) */
+	field	CRCENDERR	0x04	/* No terminal CRC packet (U3 only) */
+	field	CRCREQERR	0x02	/* Illegal CRC packet req (U3 only) */
+	field	DUAL_EDGE_ERR	0x01	/* Incorrect data phase (U3 only) */
 	mask	SFCNT		0x1f
 }
 
@@ -358,14 +367,14 @@ register SCSIID_ULTRA2 {
 register SIMODE0 {
 	address			0x010
 	access_mode RW
-	bit	ENSELDO		0x40
-	bit	ENSELDI		0x20
-	bit	ENSELINGO	0x10
-	bit	ENSWRAP		0x08
-	bit	ENIOERR		0x08	/* LVD Tranceiver mode changes */
-	bit	ENSDONE		0x04
-	bit	ENSPIORDY	0x02
-	bit	ENDMADONE	0x01
+	field	ENSELDO		0x40
+	field	ENSELDI		0x20
+	field	ENSELINGO	0x10
+	field	ENSWRAP		0x08
+	field	ENIOERR		0x08	/* LVD Tranceiver mode changes */
+	field	ENSDONE		0x04
+	field	ENSPIORDY	0x02
+	field	ENDMADONE	0x01
 }
 
 /*
@@ -376,14 +385,14 @@ register SIMODE0 {
 register SIMODE1 {
 	address			0x011
 	access_mode RW
-	bit	ENSELTIMO	0x80
-	bit	ENATNTARG	0x40
-	bit	ENSCSIRST	0x20
-	bit	ENPHASEMIS	0x10
-	bit	ENBUSFREE	0x08
-	bit	ENSCSIPERR	0x04
-	bit	ENPHASECHG	0x02
-	bit	ENREQINIT	0x01
+	field	ENSELTIMO	0x80
+	field	ENATNTARG	0x40
+	field	ENSCSIRST	0x20
+	field	ENPHASEMIS	0x10
+	field	ENBUSFREE	0x08
+	field	ENSCSIPERR	0x04
+	field	ENPHASECHG	0x02
+	field	ENREQINIT	0x01
 }
 
 /*
@@ -420,12 +429,12 @@ register SHADDR {
 register SELTIMER {
 	address			0x018
 	access_mode RW
-	bit	STAGE6		0x20
-	bit	STAGE5		0x10
-	bit	STAGE4		0x08
-	bit	STAGE3		0x04
-	bit	STAGE2		0x02
-	bit	STAGE1		0x01
+	field	STAGE6		0x20
+	field	STAGE5		0x10
+	field	STAGE4		0x08
+	field	STAGE3		0x04
+	field	STAGE2		0x02
+	field	STAGE1		0x01
 	alias	TARGIDIN
 }
 
@@ -438,16 +447,16 @@ register SELID {
 	address			0x019
 	access_mode RW
 	mask	SELID_MASK	0xf0
-	bit	ONEBIT		0x08
+	field	ONEBIT		0x08
 }
 
 register SCAMCTL {
 	address			0x01a
 	access_mode RW
-	bit	ENSCAMSELO	0x80
-	bit	CLRSCAMSELID	0x40
-	bit	ALTSTIM		0x20
-	bit	DFLTTID		0x10
+	field	ENSCAMSELO	0x80
+	field	CLRSCAMSELID	0x40
+	field	ALTSTIM		0x20
+	field	DFLTTID		0x10
 	mask	SCAMLVL		0x03
 }
 
@@ -471,32 +480,32 @@ register TARGID {
 register SPIOCAP {
 	address			0x01b
 	access_mode RW
-	bit	SOFT1		0x80
-	bit	SOFT0		0x40
-	bit	SOFTCMDEN	0x20	
-	bit	EXT_BRDCTL	0x10	/* External Board control */
-	bit	SEEPROM		0x08	/* External serial eeprom logic */
-	bit	EEPROM		0x04	/* Writable external BIOS ROM */
-	bit	ROM		0x02	/* Logic for accessing external ROM */
-	bit	SSPIOCPS	0x01	/* Termination and cable detection */
+	field	SOFT1		0x80
+	field	SOFT0		0x40
+	field	SOFTCMDEN	0x20	
+	field	EXT_BRDCTL	0x10	/* External Board control */
+	field	SEEPROM		0x08	/* External serial eeprom logic */
+	field	EEPROM		0x04	/* Writable external BIOS ROM */
+	field	ROM		0x02	/* Logic for accessing external ROM */
+	field	SSPIOCPS	0x01	/* Termination and cable detection */
 }
 
 register BRDCTL	{
 	address			0x01d
-	bit	BRDDAT7		0x80
-	bit	BRDDAT6		0x40
-	bit	BRDDAT5		0x20
-	bit	BRDSTB		0x10
-	bit	BRDCS		0x08
-	bit	BRDRW		0x04
-	bit	BRDCTL1		0x02
-	bit	BRDCTL0		0x01
+	field	BRDDAT7		0x80
+	field	BRDDAT6		0x40
+	field	BRDDAT5		0x20
+	field	BRDSTB		0x10
+	field	BRDCS		0x08
+	field	BRDRW		0x04
+	field	BRDCTL1		0x02
+	field	BRDCTL0		0x01
 	/* 7890 Definitions */
-	bit	BRDDAT4		0x10
-	bit	BRDDAT3		0x08
-	bit	BRDDAT2		0x04
-	bit	BRDRW_ULTRA2	0x02
-	bit	BRDSTB_ULTRA2	0x01
+	field	BRDDAT4		0x10
+	field	BRDDAT3		0x08
+	field	BRDDAT2		0x04
+	field	BRDRW_ULTRA2	0x02
+	field	BRDSTB_ULTRA2	0x01
 }
 
 /*
@@ -525,14 +534,14 @@ register BRDCTL	{
  */
 register SEECTL {
 	address			0x01e
-	bit	EXTARBACK	0x80
-	bit	EXTARBREQ	0x40
-	bit	SEEMS		0x20
-	bit	SEERDY		0x10
-	bit	SEECS		0x08
-	bit	SEECK		0x04
-	bit	SEEDO		0x02
-	bit	SEEDI		0x01
+	field	EXTARBACK	0x80
+	field	EXTARBREQ	0x40
+	field	SEEMS		0x20
+	field	SEERDY		0x10
+	field	SEECS		0x08
+	field	SEECK		0x04
+	field	SEEDO		0x02
+	field	SEEDI		0x01
 }
 /*
  * SCSI Block Control (p. 3-32)
@@ -544,14 +553,14 @@ register SEECTL {
 register SBLKCTL {
 	address			0x01f
 	access_mode RW
-	bit	DIAGLEDEN	0x80	/* Aic78X0 only */
-	bit	DIAGLEDON	0x40	/* Aic78X0 only */
-	bit	AUTOFLUSHDIS	0x20
-	bit	SELBUSB		0x08
-	bit	ENAB40		0x08	/* LVD transceiver active */
-	bit	ENAB20		0x04	/* SE/HVD transceiver active */
-	bit	SELWIDE		0x02
-	bit	XCVR		0x01	/* External transceiver active */
+	field	DIAGLEDEN	0x80	/* Aic78X0 only */
+	field	DIAGLEDON	0x40	/* Aic78X0 only */
+	field	AUTOFLUSHDIS	0x20
+	field	SELBUSB		0x08
+	field	ENAB40		0x08	/* LVD transceiver active */
+	field	ENAB20		0x04	/* SE/HVD transceiver active */
+	field	SELWIDE		0x02
+	field	XCVR		0x01	/* External transceiver active */
 }
 
 /*
@@ -561,14 +570,14 @@ register SBLKCTL {
 register SEQCTL {
 	address			0x060
 	access_mode RW
-	bit	PERRORDIS	0x80
-	bit	PAUSEDIS	0x40
-	bit	FAILDIS		0x20
-	bit	FASTMODE	0x10
-	bit	BRKADRINTEN	0x08
-	bit	STEP		0x04
-	bit	SEQRESET	0x02
-	bit	LOADRAM		0x01
+	field	PERRORDIS	0x80
+	field	PAUSEDIS	0x40
+	field	FAILDIS		0x20
+	field	FASTMODE	0x10
+	field	BRKADRINTEN	0x08
+	field	STEP		0x04
+	field	SEQRESET	0x02
+	field	LOADRAM		0x01
 }
 
 /*
@@ -640,8 +649,8 @@ register NONE {
 register FLAGS {
 	address			0x06b
 	access_mode RO
-	bit	ZERO		0x02
-	bit	CARRY		0x01
+	field	ZERO		0x02
+	field	CARRY		0x01
 }
 
 register SINDIR	{
@@ -664,14 +673,16 @@ register STACK {
 	access_mode RO
 }
 
+const	STACK_SIZE	4
+
 /*
  * Board Control (p. 3-43)
  */
 register BCTL {
 	address			0x084
 	access_mode RW
-	bit	ACE		0x08
-	bit	ENABLE		0x01
+	field	ACE		0x08
+	field	ENABLE		0x01
 }
 
 /*
@@ -681,23 +692,23 @@ register BCTL {
 register DSCOMMAND0 {
 	address			0x084
 	access_mode RW
-	bit	CACHETHEN	0x80	/* Cache Threshold enable */
-	bit	DPARCKEN	0x40	/* Data Parity Check Enable */
-	bit	MPARCKEN	0x20	/* Memory Parity Check Enable */
-	bit	EXTREQLCK	0x10	/* External Request Lock */
+	field	CACHETHEN	0x80	/* Cache Threshold enable */
+	field	DPARCKEN	0x40	/* Data Parity Check Enable */
+	field	MPARCKEN	0x20	/* Memory Parity Check Enable */
+	field	EXTREQLCK	0x10	/* External Request Lock */
 	/* aic7890/91/96/97 only */
-	bit	INTSCBRAMSEL	0x08	/* Internal SCB RAM Select */
-	bit	RAMPS		0x04	/* External SCB RAM Present */
-	bit	USCBSIZE32	0x02	/* Use 32byte SCB Page Size */
-	bit	CIOPARCKEN	0x01	/* Internal bus parity error enable */
+	field	INTSCBRAMSEL	0x08	/* Internal SCB RAM Select */
+	field	RAMPS		0x04	/* External SCB RAM Present */
+	field	USCBSIZE32	0x02	/* Use 32byte SCB Page Size */
+	field	CIOPARCKEN	0x01	/* Internal bus parity error enable */
 }
 
 register DSCOMMAND1 {
 	address			0x085
 	access_mode RW
 	mask	DSLATT		0xfc	/* PCI latency timer (non-ultra2) */
-	bit	HADDLDSEL1	0x02	/* Host Address Load Select Bits */
-	bit	HADDLDSEL0	0x01
+	field	HADDLDSEL1	0x02	/* Host Address Load Select Bits */
+	field	HADDLDSEL0	0x01
 }
 
 /*
@@ -747,13 +758,13 @@ const	SEQ_MAILBOX_SHIFT	0
 register HCNTRL {
 	address			0x087
 	access_mode RW
-	bit	POWRDN		0x40
-	bit	SWINT		0x10
-	bit	IRQMS		0x08
-	bit	PAUSE		0x04
-	bit	INTEN		0x02
-	bit	CHIPRST		0x01
-	bit	CHIPRSTACK	0x01
+	field	POWRDN		0x40
+	field	SWINT		0x10
+	field	IRQMS		0x08
+	field	PAUSE		0x04
+	field	INTEN		0x02
+	field	CHIPRST		0x01
+	field	CHIPRSTACK	0x01
 }
 
 /*
@@ -789,13 +800,13 @@ register SCBPTR {
 register INTSTAT {
 	address			0x091
 	access_mode RW
-	bit	BRKADRINT 0x08
-	bit	SCSIINT	  0x04
-	bit	CMDCMPLT  0x02
-	bit	SEQINT    0x01
+	field	BRKADRINT 0x08
+	field	SCSIINT	  0x04
+	field	CMDCMPLT  0x02
+	field	SEQINT    0x01
 	mask	BAD_PHASE	SEQINT		/* unknown scsi bus phase */
 	mask	SEND_REJECT	0x10|SEQINT	/* sending a message reject */
-	mask	NO_IDENT	0x20|SEQINT	/* no IDENTIFY after reconnect*/
+	mask	PROTO_VIOLATION	0x20|SEQINT	/* SCSI protocol violation */ 
 	mask	NO_MATCH	0x30|SEQINT	/* no cmd match for reconnect */
 	mask	IGN_WIDE_RES	0x40|SEQINT	/* Complex IGN Wide Res Msg */
 	mask	PDATA_REINIT	0x50|SEQINT	/*
@@ -858,14 +869,14 @@ register INTSTAT {
 register ERROR {
 	address			0x092
 	access_mode RO
-	bit	CIOPARERR	0x80	/* Ultra2 only */
-	bit	PCIERRSTAT	0x40	/* PCI only */
-	bit	MPARERR		0x20	/* PCI only */
-	bit	DPARERR		0x10	/* PCI only */
-	bit	SQPARERR	0x08
-	bit	ILLOPCODE	0x04
-	bit	ILLSADDR	0x02
-	bit	ILLHADDR	0x01
+	field	CIOPARERR	0x80	/* Ultra2 only */
+	field	PCIERRSTAT	0x40	/* PCI only */
+	field	MPARERR		0x20	/* PCI only */
+	field	DPARERR		0x10	/* PCI only */
+	field	SQPARERR	0x08
+	field	ILLOPCODE	0x04
+	field	ILLSADDR	0x02
+	field	ILLHADDR	0x01
 }
 
 /*
@@ -874,39 +885,39 @@ register ERROR {
 register CLRINT {
 	address			0x092
 	access_mode WO
-	bit	CLRPARERR	0x10	/* PCI only */
-	bit	CLRBRKADRINT	0x08
-	bit	CLRSCSIINT      0x04
-	bit	CLRCMDINT 	0x02
-	bit	CLRSEQINT 	0x01
+	field	CLRPARERR	0x10	/* PCI only */
+	field	CLRBRKADRINT	0x08
+	field	CLRSCSIINT      0x04
+	field	CLRCMDINT 	0x02
+	field	CLRSEQINT 	0x01
 }
 
 register DFCNTRL {
 	address			0x093
 	access_mode RW
-	bit	PRELOADEN	0x80	/* aic7890 only */
-	bit	WIDEODD		0x40
-	bit	SCSIEN		0x20
-	bit	SDMAEN		0x10
-	bit	SDMAENACK	0x10
-	bit	HDMAEN		0x08
-	bit	HDMAENACK	0x08
-	bit	DIRECTION	0x04
-	bit	FIFOFLUSH	0x02
-	bit	FIFORESET	0x01
+	field	PRELOADEN	0x80	/* aic7890 only */
+	field	WIDEODD		0x40
+	field	SCSIEN		0x20
+	field	SDMAEN		0x10
+	field	SDMAENACK	0x10
+	field	HDMAEN		0x08
+	field	HDMAENACK	0x08
+	field	DIRECTION	0x04
+	field	FIFOFLUSH	0x02
+	field	FIFORESET	0x01
 }
 
 register DFSTATUS {
 	address			0x094
 	access_mode RO
-	bit	PRELOAD_AVAIL	0x80
-	bit	DFCACHETH	0x40
-	bit	FIFOQWDEMP	0x20
-	bit	MREQPEND	0x10
-	bit	HDONE		0x08
-	bit	DFTHRESH	0x04
-	bit	FIFOFULL	0x02
-	bit	FIFOEMP		0x01
+	field	PRELOAD_AVAIL	0x80
+	field	DFCACHETH	0x40
+	field	FIFOQWDEMP	0x20
+	field	MREQPEND	0x10
+	field	HDONE		0x08
+	field	DFTHRESH	0x04
+	field	FIFOFULL	0x02
+	field	FIFOEMP		0x01
 }
 
 register DFWADDR {
@@ -932,7 +943,7 @@ register DFDAT {
 register SCBCNT {
 	address			0x09a
 	access_mode RW
-	bit	SCBAUTO		0x80
+	field	SCBAUTO		0x80
 	mask	SCBCNT_MASK	0x1f
 }
 
@@ -966,12 +977,12 @@ register QOUTFIFO {
 register CRCCONTROL1 {
 	address			0x09d
 	access_mode RW
-	bit	CRCONSEEN		0x80
-	bit	CRCVALCHKEN		0x40
-	bit	CRCENDCHKEN		0x20
-	bit	CRCREQCHKEN		0x10
-	bit	TARGCRCENDEN		0x08
-	bit	TARGCRCCNTEN		0x04
+	field	CRCONSEEN		0x80
+	field	CRCVALCHKEN		0x40
+	field	CRCENDCHKEN		0x20
+	field	CRCREQCHKEN		0x10
+	field	TARGCRCENDEN		0x08
+	field	TARGCRCCNTEN		0x04
 }
 
 
@@ -987,12 +998,12 @@ register QOUTCNT {
 register SCSIPHASE {
 	address			0x09e
 	access_mode RO
-	bit	STATUS_PHASE	0x20
-	bit	COMMAND_PHASE	0x10
-	bit	MSG_IN_PHASE	0x08
-	bit	MSG_OUT_PHASE	0x04
-	bit	DATA_IN_PHASE	0x02
-	bit	DATA_OUT_PHASE	0x01
+	field	STATUS_PHASE	0x20
+	field	COMMAND_PHASE	0x10
+	field	MSG_IN_PHASE	0x08
+	field	MSG_OUT_PHASE	0x04
+	field	DATA_IN_PHASE	0x02
+	field	DATA_OUT_PHASE	0x01
 	mask	DATA_PHASE_MASK	0x03
 }
 
@@ -1002,7 +1013,7 @@ register SCSIPHASE {
 register SFUNCT {
 	address			0x09f
 	access_mode RW
-	bit	ALT_MODE	0x80
+	field	ALT_MODE	0x80
 }
 
 /*
@@ -1041,34 +1052,36 @@ scb {
 		 * the data address.
 		 */
 		size	4
-		bit	SG_LAST_SEG		0x80	/* In the fourth byte */
+		field	SG_LAST_SEG		0x80	/* In the fourth byte */
 		mask	SG_HIGH_ADDR_BITS	0x7F	/* In the fourth byte */
 	}
 	SCB_SGPTR {
 		size	4
-		bit	SG_RESID_VALID	0x04	/* In the first byte */
-		bit	SG_FULL_RESID	0x02	/* In the first byte */
-		bit	SG_LIST_NULL	0x01	/* In the first byte */
+		field	SG_RESID_VALID	0x04	/* In the first byte */
+		field	SG_FULL_RESID	0x02	/* In the first byte */
+		field	SG_LIST_NULL	0x01	/* In the first byte */
 	}
 	SCB_CONTROL {
 		size	1
-		bit	TARGET_SCB			0x80
-		bit	DISCENB				0x40
-		bit	TAG_ENB				0x20
-		bit	MK_MESSAGE			0x10
-		bit	ULTRAENB			0x08
-		bit	DISCONNECTED			0x04
+		field	TARGET_SCB			0x80
+		field	STATUS_RCVD			0x80
+		field	DISCENB				0x40
+		field	TAG_ENB				0x20
+		field	MK_MESSAGE			0x10
+		field	ULTRAENB			0x08
+		field	DISCONNECTED			0x04
 		mask	SCB_TAG_TYPE			0x03
 	}
 	SCB_SCSIID {
 		size	1
-		bit	TWIN_CHNLB			0x80
+		field	TWIN_CHNLB			0x80
 		mask	TWIN_TID			0x70
 		mask	TID				0xf0
 		mask	OID				0x0f
 	}
 	SCB_LUN {
-		mask	LID				0xff
+		field	SCB_XFERLEN_ODD			0x80
+		mask	LID				0x3f
 		size	1
 	}
 	SCB_TAG {
@@ -1105,18 +1118,18 @@ const	SG_SIZEOF	0x08		/* sizeof(struct a
 register SEECTL_2840 {
 	address			0x0c0
 	access_mode RW
-	bit	CS_2840		0x04
-	bit	CK_2840		0x02
-	bit	DO_2840		0x01
+	field	CS_2840		0x04
+	field	CK_2840		0x02
+	field	DO_2840		0x01
 }
 
 register STATUS_2840 {
 	address			0x0c1
 	access_mode RW
-	bit	EEPROM_TF	0x80
+	field	EEPROM_TF	0x80
 	mask	BIOS_SEL	0x60
 	mask	ADSEL		0x1e
-	bit	DI_2840		0x01
+	field	DI_2840		0x01
 }
 
 /* --------------------- AIC-7870-only definitions -------------------- */
@@ -1140,10 +1153,10 @@ register CCSGADDR {
 
 register CCSGCTL {
 	address			0x0EB
-	bit	CCSGDONE	0x80
-	bit	CCSGEN		0x08
-	bit	SG_FETCH_NEEDED 0x02	/* Bit used for software state */
-	bit	CCSGRESET	0x01
+	field	CCSGDONE	0x80
+	field	CCSGEN		0x08
+	field	SG_FETCH_NEEDED 0x02	/* Bit used for software state */
+	field	CCSGRESET	0x01
 }
 
 register CCSCBCNT {
@@ -1152,12 +1165,12 @@ register CCSCBCNT {
 
 register CCSCBCTL {
 	address			0x0EE
-	bit	CCSCBDONE	0x80
-	bit	ARRDONE		0x40	/* SCB Array prefetch done */
-	bit	CCARREN		0x10
-	bit	CCSCBEN		0x08
-	bit	CCSCBDIR	0x04
-	bit	CCSCBRESET	0x01
+	field	CCSCBDONE	0x80
+	field	ARRDONE		0x40	/* SCB Array prefetch done */
+	field	CCARREN		0x10
+	field	CCSCBEN		0x08
+	field	CCSCBDIR	0x04
+	field	CCSCBRESET	0x01
 }
 
 register CCSCBADDR {
@@ -1194,9 +1207,9 @@ register SDSCB_QOFF {
 
 register QOFF_CTLSTA {
 	address			0x0FA
-	bit	SCB_AVAIL	0x40
-	bit	SNSCB_ROLLOVER	0x20
-	bit	SDSCB_ROLLOVER	0x10
+	field	SCB_AVAIL	0x40
+	field	SNSCB_ROLLOVER	0x20
+	field	SDSCB_ROLLOVER	0x10
 	mask	SCB_QSIZE	0x07
 	mask	SCB_QSIZE_256	0x06
 }
@@ -1227,18 +1240,16 @@ register SG_CACHE_PRE {
 	access_mode WO
 	address			0x0fc
 	mask	SG_ADDR_MASK	0xf8
-	bit	ODD_SEG		0x04
-	bit	LAST_SEG	0x02
-	bit	LAST_SEG_DONE	0x01
+	field	LAST_SEG	0x02
+	field	LAST_SEG_DONE	0x01
 }
 
 register SG_CACHE_SHADOW {
 	access_mode RO
 	address			0x0fc
 	mask	SG_ADDR_MASK	0xf8
-	bit	ODD_SEG		0x04
-	bit	LAST_SEG	0x02
-	bit	LAST_SEG_DONE	0x01
+	field	LAST_SEG	0x02
+	field	LAST_SEG_DONE	0x01
 }
 /* ---------------------- Scratch RAM Offsets ------------------------- */
 /* These offsets are either to values that are initialized by the board's
@@ -1295,6 +1306,7 @@ scratch_ram {
 	 */
 	MWI_RESIDUAL {
 		size		1
+		alias	TARG_IMMEDIATE_SCB
 	}
 	/*
 	 * SCBID of the next SCB to be started by the controller.
@@ -1312,28 +1324,29 @@ scratch_ram {
 	/* Parameters for DMA Logic */
 	DMAPARAMS {
 		size		1
-		bit	PRELOADEN	0x80
-		bit	WIDEODD		0x40
-		bit	SCSIEN		0x20
-		bit	SDMAEN		0x10
-		bit	SDMAENACK	0x10
-		bit	HDMAEN		0x08
-		bit	HDMAENACK	0x08
-		bit	DIRECTION	0x04	/* Set indicates PCI->SCSI */
-		bit	FIFOFLUSH	0x02
-		bit	FIFORESET	0x01
+		field	PRELOADEN	0x80
+		field	WIDEODD		0x40
+		field	SCSIEN		0x20
+		field	SDMAEN		0x10
+		field	SDMAENACK	0x10
+		field	HDMAEN		0x08
+		field	HDMAENACK	0x08
+		field	DIRECTION	0x04	/* Set indicates PCI->SCSI */
+		field	FIFOFLUSH	0x02
+		field	FIFORESET	0x01
 	}
 	SEQ_FLAGS {
 		size		1
-		bit	IDENTIFY_SEEN		0x80
-		bit	TARGET_CMD_IS_TAGGED	0x40
-		bit	DPHASE			0x20
+		field	NOT_IDENTIFIED		0x80
+		field	NO_CDB_SENT		0x40
+		field	TARGET_CMD_IS_TAGGED	0x40
+		field	DPHASE			0x20
 		/* Target flags */
-		bit	TARG_CMD_PENDING	0x10
-		bit	CMDPHASE_PENDING	0x08
-		bit	DPHASE_PENDING		0x04
-		bit	SPHASE_PENDING		0x02
-		bit	NO_DISCONNECT		0x01
+		field	TARG_CMD_PENDING	0x10
+		field	CMDPHASE_PENDING	0x08
+		field	DPHASE_PENDING		0x04
+		field	SPHASE_PENDING		0x02
+		field	NO_DISCONNECT		0x01
 	}
 	/*
 	 * Temporary storage for the
@@ -1351,9 +1364,9 @@ scratch_ram {
 	 */
 	LASTPHASE {
 		size		1
-		bit	CDI		0x80
-		bit	IOI		0x40
-		bit	MSGI		0x20
+		field	CDI		0x80
+		field	IOI		0x40
+		field	MSGI		0x20
 		mask	PHASE_MASK	CDI|IOI|MSGI
 		mask	P_DATAOUT	0x00
 		mask	P_DATAIN	IOI
@@ -1457,20 +1470,12 @@ scratch_ram {
 	 */
 	SCSISEQ_TEMPLATE {
 		size		1
-		bit	ENSELO		0x40
-		bit	ENSELI		0x20
-		bit	ENRSELI		0x10
-		bit	ENAUTOATNO	0x08
-		bit	ENAUTOATNI	0x04
-		bit	ENAUTOATNP	0x02
-	}
-
-	/*
-	 * Track whether the transfer byte count for
-	 * the current data phase is odd.
-	 */
-	DATA_COUNT_ODD {
-		size		1
+		field	ENSELO		0x40
+		field	ENSELI		0x20
+		field	ENRSELI		0x10
+		field	ENAUTOATNO	0x08
+		field	ENAUTOATNI	0x04
+		field	ENAUTOATNP	0x02
 	}
 }
 
@@ -1488,14 +1493,14 @@ scratch_ram {
 	 */
 	HA_274_BIOSGLOBAL {
 		size	1
-		bit	HA_274_EXTENDED_TRANS	0x01
+		field	HA_274_EXTENDED_TRANS	0x01
 		alias	INITIATOR_TAG
 	}
 
 	SEQ_FLAGS2 {
 		size	1
-		bit	SCB_DMA			0x01
-		bit	TARGET_MSG_PENDING	0x02
+		field	SCB_DMA			0x01
+		field	TARGET_MSG_PENDING	0x02
 	}
 }
 
@@ -1513,16 +1518,16 @@ scratch_ram {
 	 */
 	SCSICONF {
 		size		1
-		bit	TERM_ENB	0x80
-		bit	RESET_SCSI	0x40
-		bit	ENSPCHK		0x20
+		field	TERM_ENB	0x80
+		field	RESET_SCSI	0x40
+		field	ENSPCHK		0x20
 		mask	HSCSIID		0x07	/* our SCSI ID */
 		mask	HWSCSIID	0x0f	/* our SCSI ID if Wide Bus */
 	}
 	INTDEF {
 		address		0x05c
 		size		1
-		bit	EDGE_TRIG	0x80
+		field	EDGE_TRIG	0x80
 		mask	VECTOR		0x0f
 	}
 	HOSTCONF {
@@ -1534,7 +1539,7 @@ scratch_ram {
 		size		1
 		mask	BIOSMODE		0x30
 		mask	BIOSDISABLED		0x30	
-		bit	CHANNEL_B_PRIMARY	0x08
+		field	CHANNEL_B_PRIMARY	0x08
 	}
 }
 
@@ -1566,6 +1571,7 @@ const BUS_32_BIT		0x02
 const MAX_OFFSET_8BIT		0x0f
 const MAX_OFFSET_16BIT		0x08
 const MAX_OFFSET_ULTRA2		0x7f
+const MAX_OFFSET		0x7f
 const HOST_MSG			0xff
 
 /* Target mode command processing constants */
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx.seq linux-5730/drivers/scsi/aic7xxx/aic7xxx.seq
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx.seq
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx.seq
@@ -37,11 +37,12 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.seq,v 1.94.2.16 2002/04/29 19:36:30 gibbs Exp $
+ * $FreeBSD$
  */
 
-VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#43 $"
+VERSION = "$Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#56 $"
 PATCH_ARG_LIST = "struct ahc_softc *ahc"
+PREFIX = "ahc_"
 
 #include "aic7xxx.reg"
 #include "scsi_message.h"
@@ -69,7 +70,7 @@ bus_free_sel:
 	 * Turn off the selection hardware.  We need to reset the
 	 * selection request in order to perform a new selection.
 	 */
-	and	SCSISEQ, TEMODE|ENSELI|ENRSELI|ENAUTOATNP, SCSISEQ;
+	and	SCSISEQ, TEMODE|ENSELI|ENRSELI|ENAUTOATNP;
 	and	SIMODE1, ~ENBUSFREE;
 poll_for_work:
 	call	clear_target_state;
@@ -192,7 +193,7 @@ select_in:
 		 * Setup the DMA for sending the identify and
 		 * command information.
 		 */
-		or	SEQ_FLAGS, CMDPHASE_PENDING;
+		mvi	SEQ_FLAGS, CMDPHASE_PENDING;
 
 		mov     A, TQINPOS;
 		if ((ahc->features & AHC_CMD_CHAN) != 0) {
@@ -305,7 +306,7 @@ ident_messages_done:
 		} else {
 			mvi	DFDAT, SCB_LIST_NULL;
 		}
-		or	SEQ_FLAGS, TARG_CMD_PENDING|IDENTIFY_SEEN;
+		or	SEQ_FLAGS, TARG_CMD_PENDING;
 		test	SEQ_FLAGS2, TARGET_MSG_PENDING
 			jnz target_mesgout_pending;
 		test	SCSISIGI, ATNI jnz target_mesgout_continue;
@@ -389,13 +390,8 @@ initialize_scsiid:
 	}
 
 /*
- * Initialize transfer settings and clear the SCSI channel.
- * SINDEX should contain any additional bit's the client wants
- * set in SXFRCTL0.  We also assume that the current SCB is
- * a valid SCB for the target we wish to talk to.
+ * Initialize transfer settings with SCB provided settings.
  */
-initialize_channel:
-	or	SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
 set_transfer_settings:
 	if ((ahc->features & AHC_ULTRA) != 0) {
 		test	SCB_CONTROL, ULTRAENB jz . + 2;
@@ -441,11 +437,19 @@ select_out:
 	mov	SCBPTR, WAITING_SCBH;
 	mov	WAITING_SCBH,SCB_NEXT;
 	mov	SAVED_SCSIID, SCB_SCSIID;
-	mov	SAVED_LUN, SCB_LUN;
-	call	initialize_channel;
+	and	SAVED_LUN, LID, SCB_LUN;
+	call	set_transfer_settings;
 	if ((ahc->flags & AHC_TARGETROLE) != 0) {
 		test	SSTAT0, TARGET	jz initiator_select;
 
+		or	SXFRCTL0, CLRSTCNT|CLRCHN;
+
+		/*
+		 * Put tag in connonical location since not
+		 * all connections have an SCB.
+		 */
+		mov	INITIATOR_TAG, SCB_TARGET_ITAG;
+
 		/*
 		 * We've just re-selected an initiator.
 		 * Assert BSY and setup the phase for
@@ -457,7 +461,7 @@ select_out:
 		/*
 		 * Start out with a simple identify message.
 		 */
-		or	SCB_LUN, MSG_IDENTIFYFLAG call target_outb;
+		or	SAVED_LUN, MSG_IDENTIFYFLAG call target_outb;
 
 		/*
 		 * If we are the result of a tagged command, send
@@ -491,15 +495,16 @@ target_ITloop:
 		 * on the state of NO_DISCONNECT.
 		 */
 		test	SEQ_FLAGS, NO_DISCONNECT jz target_disconnect; 
-		mov	RETURN_1, ALLZEROS;
+		mvi	TARG_IMMEDIATE_SCB, SCB_LIST_NULL;
 		call	complete_target_cmd;
-		cmp	RETURN_1, CONT_MSG_LOOP jne .;
 		if ((ahc->flags & AHC_PAGESCBS) != 0) {
 			mov	ALLZEROS	call	get_free_or_disc_scb;
 		}
+		cmp	TARG_IMMEDIATE_SCB, SCB_LIST_NULL je .;
 		mvi	DMAPARAMS, HDMAEN|DIRECTION|FIFORESET;
-		mov	SCB_TAG	 call dma_scb;
+		mov	TARG_IMMEDIATE_SCB call dma_scb;
 		call	set_transfer_settings;
+		or	SXFRCTL0, CLRSTCNT|CLRCHN;
 		jmp	target_synccmd;
 
 target_mesgout:
@@ -507,6 +512,7 @@ target_mesgout:
 target_mesgout_continue:
 		call	target_inb;
 target_mesgout_pending:
+		and	SEQ_FLAGS2, ~TARGET_MSG_PENDING;
 		/* Local Processing goes here... */
 		jmp	host_target_message_loop;
 		
@@ -636,13 +642,14 @@ complete_target_cmd:
 
 if ((ahc->flags & AHC_INITIATORROLE) != 0) {
 initiator_select:
+	or	SXFRCTL0, SPIOEN|CLRSTCNT|CLRCHN;
 	/*
 	 * As soon as we get a successful selection, the target
 	 * should go into the message out phase since we have ATN
 	 * asserted.
 	 */
 	mvi	MSG_OUT, MSG_IDENTIFYFLAG;
-	or	SEQ_FLAGS, IDENTIFY_SEEN;
+	mvi	SEQ_FLAGS, NO_CDB_SENT;
 	mvi	CLRSINT0, CLRSELDO;
 
 	/*
@@ -701,7 +708,7 @@ clear_target_state:
 	}
 	mvi	LASTPHASE, P_BUSFREE;
 	/* clear target specific flags */
-	clr	SEQ_FLAGS ret;
+	mvi	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT ret;
 
 sg_advance:
 	clr	A;			/* add sizeof(struct scatter) */
@@ -761,16 +768,12 @@ idle_sg_avail:
 		/* Does the hardware have space for another SG entry? */
 		test	DFSTATUS, PRELOAD_AVAIL jz return;
 		bmov 	HADDR, CCSGRAM, 7;
-		test	HCNT[0], 0x1 jz . + 2;
-		xor	DATA_COUNT_ODD, 0x1;
 		bmov	SCB_RESIDUAL_DATACNT[3], CCSGRAM, 1;
 		if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
 			mov	SCB_RESIDUAL_DATACNT[3] call set_hhaddr;
 		}
 		call	sg_advance;
 		mov	SINDEX, SCB_RESIDUAL_SGPTR[0];
-		test	DATA_COUNT_ODD, 0x1 jz . + 2;
-		or	SINDEX, ODD_SEG;
 		test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
 		or	SINDEX, LAST_SEG;
 		mov	SG_CACHE_PRE, SINDEX;
@@ -815,9 +818,9 @@ calc_mwi_residual_final:
 }
 
 p_data:
-	test	SEQ_FLAGS,IDENTIFY_SEEN	jnz p_data_okay;
-	mvi	NO_IDENT jmp set_seqint;
-p_data_okay:
+	test	SEQ_FLAGS,NOT_IDENTIFIED|NO_CDB_SENT jz p_data_allowed;
+	mvi	PROTO_VIOLATION call set_seqint;
+p_data_allowed:
 	if ((ahc->features & AHC_ULTRA2) != 0) {
 		mvi	DMAPARAMS, PRELOADEN|SCSIEN|HDMAEN;
 	} else {
@@ -868,7 +871,6 @@ data_phase_initialize:
 		call	calc_mwi_residual;
 	}
 	and	SCB_RESIDUAL_SGPTR[0], ~SG_FULL_RESID;
-	and	DATA_COUNT_ODD, 0x1, HCNT[0];
 
 	if ((ahc->features & AHC_ULTRA2) == 0) {
 		if ((ahc->features & AHC_CMD_CHAN) != 0) {
@@ -903,8 +905,6 @@ data_phase_inbounds:
 		mov	SINDEX, SCB_RESIDUAL_SGPTR[0];
 		test	SCB_RESIDUAL_DATACNT[3], SG_LAST_SEG jz . + 2;
 		or	SINDEX, LAST_SEG;
-		test	DATA_COUNT_ODD, 0x1 jz . + 2;
-		or	SINDEX, ODD_SEG;
 		mov	SG_CACHE_PRE, SINDEX;
 		mov	DFCNTRL, DMAPARAMS;
 ultra2_dma_loop:
@@ -999,10 +999,8 @@ sgptr_fixup:
 		adc	SCB_RESIDUAL_SGPTR[3], -1;
 sgptr_fixup_done:
 		and	SCB_RESIDUAL_SGPTR[0], SG_ADDR_MASK, SG_CACHE_SHADOW;
-		clr	DATA_COUNT_ODD;
-		test	SG_CACHE_SHADOW, ODD_SEG jz . + 2;
-		or	DATA_COUNT_ODD, 0x1;
-		clr	SCB_RESIDUAL_DATACNT[3]; /* We are not the last seg */
+		/* We are not the last seg */
+		and	SCB_RESIDUAL_DATACNT[3], ~SG_LAST_SEG;
 residuals_correct:
 		/*
 		 * Go ahead and shut down the DMA engine now.
@@ -1046,11 +1044,19 @@ ultra2_fifoflush:
 			 * LAST_SEG_DONE to come true on a completed transfer
 			 * and then test to see if the data FIFO is non-empty.
 			 */
-			test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 4;
+			test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL
+				jz ultra2_wait_fifoemp;
 			test	SG_CACHE_SHADOW, LAST_SEG_DONE jz .;
+			/*
+			 * FIFOEMP can lag LAST_SEG_DONE.  Wait a few
+			 * clocks before calling this an overrun.
+			 */
+			test	DFSTATUS, FIFOEMP jnz ultra2_fifoempty;
+			test	DFSTATUS, FIFOEMP jnz ultra2_fifoempty;
 			test	DFSTATUS, FIFOEMP jnz ultra2_fifoempty;
 			/* Overrun */
 			jmp	data_phase_loop;
+ultra2_wait_fifoemp:
 			test	DFSTATUS, FIFOEMP jz .;
 		}
 ultra2_fifoempty:
@@ -1239,9 +1245,6 @@ sg_load_done:
 		} else {
 			call	set_stcnt_from_hcnt;
 		}
-		/* Track odd'ness */
-		test	HCNT[0], 0x1 jz . + 2;
-		xor	DATA_COUNT_ODD, 0x1;
 
 		if ((ahc->flags & AHC_TARGETROLE) != 0) {
 			test	SSTAT0, TARGET jnz data_phase_loop;
@@ -1343,7 +1346,7 @@ residual_update_done:
 		 */
 		test	DFCNTRL, DIRECTION jz target_ITloop;
 		test	SSTAT1, REQINIT	jnz .;
-		test	DATA_COUNT_ODD, 0x1 jz target_ITloop;
+		test	SCB_LUN, SCB_XFERLEN_ODD jz target_ITloop;
 		test	SCSIRATE, WIDEXFER jz target_ITloop;
 		/*
 		 * Issue an Ignore Wide Residue Message.
@@ -1361,8 +1364,8 @@ if ((ahc->flags & AHC_INITIATORROLE) != 
  * Command phase.  Set up the DMA registers and let 'er rip.
  */
 p_command:
-	test	SEQ_FLAGS,IDENTIFY_SEEN	jnz p_command_okay;
-	mvi	NO_IDENT jmp set_seqint;
+	test	SEQ_FLAGS, NOT_IDENTIFIED jz p_command_okay;
+	mvi	PROTO_VIOLATION call set_seqint;
 p_command_okay:
 
 	if ((ahc->features & AHC_ULTRA2) != 0) {
@@ -1394,7 +1397,7 @@ p_command_from_host:
 		}
 		mvi	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN|DIRECTION|FIFORESET);
 	}
-	jmp	p_command_loop;
+	jmp	p_command_xfer;
 p_command_embedded:
 	/*
 	 * The data fifo seems to require 4 byte aligned
@@ -1432,24 +1435,28 @@ p_command_embedded:
 		call	copy_to_fifo_6;
 		or	DFCNTRL, FIFOFLUSH;
 	}
-p_command_loop:
+p_command_xfer:
+	and	SEQ_FLAGS, ~NO_CDB_SENT;
 	if ((ahc->features & AHC_DT) == 0) {
 		test	SSTAT0, SDONE jnz . + 2;
-		test    SSTAT1, PHASEMIS jz p_command_loop;
+		test    SSTAT1, PHASEMIS jz . - 1;
 		/*
 		 * Wait for our ACK to go-away on it's own
 		 * instead of being killed by SCSIEN getting cleared.
 		 */
 		test	SCSISIGI, ACKI jnz .;
 	} else {
-		test	DFCNTRL, SCSIEN jnz p_command_loop;
+		test	DFCNTRL, SCSIEN jnz .;
 	}
+	test	SSTAT0, SDONE jnz p_command_successful;
+	/*
+	 * Don't allow a data phase if the command
+	 * was not fully transferred.
+	 */
+	or	SEQ_FLAGS, NO_CDB_SENT;
+p_command_successful:
 	and	DFCNTRL, ~(SCSIEN|SDMAEN|HDMAEN);
 	test	DFCNTRL, (SCSIEN|SDMAEN|HDMAEN) jnz .;
-	if ((ahc->features & AHC_ULTRA2) != 0) {
-		/* Drop any residual from the S/G Preload queue */
-		or	SXFRCTL0, CLRSTCNT;
-	}
 	jmp	ITloop;
 
 /*
@@ -1457,10 +1464,10 @@ p_command_loop:
  * and store it into the SCB.
  */
 p_status:
-	test	SEQ_FLAGS,IDENTIFY_SEEN	jnz p_status_okay;
-	mvi	NO_IDENT jmp set_seqint;
+	test	SEQ_FLAGS, NOT_IDENTIFIED jnz mesgin_proto_violation;
 p_status_okay:
 	mov	SCB_SCSI_STATUS, SCSIDATL;
+	or	SCB_CONTROL, STATUS_RCVD;
 	jmp	ITloop;
 
 /*
@@ -1499,7 +1506,7 @@ p_mesgout:
 	cmp	SINDEX, MSG_IDENTIFYFLAG jne p_mesgout_from_host;
 	test	SCB_CONTROL,MK_MESSAGE	jnz host_message_loop;
 p_mesgout_identify:
-	or	SINDEX, MSG_IDENTIFYFLAG|DISCENB, SCB_LUN;
+	or	SINDEX, MSG_IDENTIFYFLAG|DISCENB, SAVED_LUN;
 	test	SCB_CONTROL, DISCENB jnz . + 2;
 	and	SINDEX, ~DISCENB;
 /*
@@ -1576,18 +1583,20 @@ if ((ahc->features & AHC_WIDE) != 0) {
 	mvi	ARG_1	call inb_next;
 	cmp	ARG_1, 0x01 jne mesgin_reject;
 	test	SCB_RESIDUAL_SGPTR[0], SG_LIST_NULL jz . + 2;
-	test	DATA_COUNT_ODD, 0x1	jz mesgin_done;
+	test	SCB_LUN, SCB_XFERLEN_ODD jnz mesgin_done;
 	mvi	IGN_WIDE_RES call set_seqint;
 	jmp	mesgin_done;
 }
 
+mesgin_proto_violation:
+	mvi	PROTO_VIOLATION call set_seqint;
+	jmp	mesgin_done;
 mesgin_reject:
 	mvi	MSG_MESSAGE_REJECT	call mk_mesg;
 mesgin_done:
 	mov	NONE,SCSIDATL;		/*dummy read from latch to ACK*/
 	jmp	ITloop;
 
-mesgin_complete:
 /*
  * We received a "command complete" message.  Put the SCB_TAG into the QOUTFIFO,
  * and trigger a completion interrupt.  Before doing so, check to see if there
@@ -1600,27 +1609,49 @@ mesgin_complete:
  * it to the QINFIFO and tell us not to post to the QOUTFIFO by setting 
  * RETURN_1 to SEND_SENSE.
  */
+mesgin_complete:
 
-/*
- * If ATN is raised, we still want to give the target a message.
- * Perhaps there was a parity error on this last message byte.
- * Either way, the target should take us to message out phase
- * and then attempt to complete the command again.  We should use a
- * critical section here to guard against a timeout triggering
- * for this command and setting ATN while we are still processing
- * the completion.
+	/*
+	 * If ATN is raised, we still want to give the target a message.
+	 * Perhaps there was a parity error on this last message byte.
+	 * Either way, the target should take us to message out phase
+	 * and then attempt to complete the command again.  We should use a
+	 * critical section here to guard against a timeout triggering
+	 * for this command and setting ATN while we are still processing
+	 * the completion.
 	test	SCSISIGI, ATNI jnz mesgin_done;
- */
+	 */
 
-/*
- * See if we attempted to deliver a message but the target ingnored us.
- */
+	/*
+	 * If we are identified and have successfully sent the CDB,
+	 * any status will do.  Optimize this fast path.
+	 */
+	test	SCB_CONTROL, STATUS_RCVD jz mesgin_proto_violation;
+	test	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT jz complete_accepted; 
+
+	/*
+	 * If the target never sent an identify message but instead went
+	 * to mesgin to give an invalid message, let the host abort us.
+	 */
+	test	SEQ_FLAGS, NOT_IDENTIFIED jnz mesgin_proto_violation;
+
+	/*
+	 * If we recevied good status but never successfully sent the
+	 * cdb, abort the command.
+	 */
+	test	SCB_SCSI_STATUS,0xff	jnz complete_accepted;
+	test	SEQ_FLAGS, NO_CDB_SENT jnz mesgin_proto_violation;
+
+complete_accepted:
+	/*
+	 * See if we attempted to deliver a message but the target ingnored us.
+	 */
 	test	SCB_CONTROL, MK_MESSAGE jz . + 2;
 	mvi	MKMSG_FAILED call set_seqint;
 
-/*
- * Check for residuals
- */
+	/*
+	 * Check for residuals
+	 */
 	test	SCB_SGPTR, SG_LIST_NULL jnz check_status;/* No xfer */
 	test	SCB_SGPTR, SG_FULL_RESID jnz upload_scb;/* Never xfered */
 	test	SCB_RESIDUAL_SGPTR, SG_LIST_NULL jz upload_scb;
@@ -1673,14 +1704,15 @@ mesgin_disconnect:
 	 * XXX - Wait for more testing.
 	test	SCSISIGI, ATNI jnz mesgin_done;
 	 */
-
+	test	SEQ_FLAGS, NOT_IDENTIFIED|NO_CDB_SENT
+		jnz mesgin_proto_violation;
 	or	SCB_CONTROL,DISCONNECTED;
 	if ((ahc->flags & AHC_PAGESCBS) != 0) {
 		call	add_scb_to_disc_list;
 	}
 	test	SCB_CONTROL, TAG_ENB jnz await_busfree;
 	mov	ARG_1, SCB_TAG;
-	mov	SAVED_LUN, SCB_LUN;
+	and	SAVED_LUN, LID, SCB_LUN;
 	mov	SCB_SCSIID	call set_busy_target;
 	jmp	await_busfree;
 
@@ -1741,7 +1773,8 @@ mesgin_sdptrs_full:
  * Restore pointers message?  Data pointers are recopied from the
  * SCB anytime we enter a data phase for the first time, so all
  * we need to do is clear the DPHASE flag and let the data phase
- * code do the rest.
+ * code do the rest.  We also reset/reallocate the FIFO to make
+ * sure we have a clean start for the next data or command phase.
  */
 mesgin_rdptrs:
 	and	SEQ_FLAGS, ~DPHASE;		/*
@@ -1749,6 +1782,7 @@ mesgin_rdptrs:
 						 * the next time through
 						 * the dataphase.
 						 */
+	or	SXFRCTL0, CLRSTCNT|CLRCHN;
 	jmp	mesgin_done;
 
 /*
@@ -1776,7 +1810,7 @@ mesgin_identify:
 	 * transactions by first looking at the transaction stored in
 	 * the busy target array.  If there is no untagged transaction
 	 * for this target or the transaction is for a different lun, then
-	 * this must be an untagged transaction.
+	 * this must be a tagged transaction.
 	 */
 	shr	SINDEX, 4, SAVED_SCSIID;
 	and	SAVED_LUN, MSG_IDENTIFY_LUNMASK, A;
@@ -1821,7 +1855,7 @@ mesgin_identify:
 		 * at a time.  So, if the lun doesn't match, look
 		 * for a tag message.
 		 */
-		mov	A, SCB_LUN;
+		and	A, LID, SCB_LUN;
 		cmp	SAVED_LUN, A	je setup_SCB_id_lun_okay;
 		if ((ahc->flags & AHC_PAGESCBS) != 0) {
 			/*
@@ -1879,7 +1913,7 @@ setup_SCB:
 		or	SEQ_FLAGS, 0x8;
 	}
 setup_SCB_id_okay:
-	mov	A, SCB_LUN;
+	and	A, LID, SCB_LUN;
 	cmp	SAVED_LUN, A	jne not_found_cleanup_scb;
 setup_SCB_id_lun_okay:
 	if ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0) {
@@ -1897,7 +1931,7 @@ setup_SCB_id_lun_okay:
 		mov	SCBPTR, A;
 	}
 setup_SCB_tagged:
-	mvi	SEQ_FLAGS,IDENTIFY_SEEN;	/* make note of IDENTIFY */
+	clr	SEQ_FLAGS;	/* make note of IDENTIFY */
 	call	set_transfer_settings;
 	/* See if the host wants to send a message upon reconnection */
 	test	SCB_CONTROL, MK_MESSAGE jz mesgin_done;
@@ -2218,9 +2252,9 @@ dma_scb_fromhost:
 			 * available data to force the chip to
 			 * continue the transfer.  This does not
 			 * happen for SCSI transfers as the SCSI module
-			 * will drain the FIFO as data is made available.
+			 * will drain the FIFO as data are made available.
 			 * When the hang occurs, we know that a multiple
-			 * of 8 bytes are in the FIFO because the PCI
+			 * of 8 bytes is in the FIFO because the PCI
 			 * module has an 8 byte input latch that only
 			 * dumps to the FIFO when HCNT == 0 or the
 			 * latch is full.
@@ -2257,7 +2291,6 @@ dma_scb_hang_dma_done:
 		} else {
 			call	dma_finish;
 		}
-		/* If we were putting the SCB, we are done */
 		call	dfdat_in_8;
 		call	dfdat_in_8;
 		call	dfdat_in_8;
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx_93cx6.c linux-5730/drivers/scsi/aic7xxx/aic7xxx_93cx6.c
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx_93cx6.c
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx_93cx6.c
@@ -28,9 +28,9 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#15 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.c#17 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx_93cx6.c,v 1.8.2.5 2002/04/29 19:36:31 gibbs Exp $
+ * $FreeBSD$
  */
 
 /*
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx_93cx6.h linux-5730/drivers/scsi/aic7xxx/aic7xxx_93cx6.h
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx_93cx6.h
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx_93cx6.h
@@ -38,9 +38,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.h#10 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx_93cx6.h#12 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx_93cx6.h,v 1.7.2.3 2002/04/29 19:36:31 gibbs Exp $
+ * $FreeBSD$
  */
 #ifndef _AIC7XXX_93CX6_H_
 #define _AIC7XXX_93CX6_H_
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx_core.c linux-5730/drivers/scsi/aic7xxx/aic7xxx_core.c
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx_core.c
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx_core.c
@@ -1,8 +1,8 @@
 /*
  * Core routines and tables shareable across OS platforms.
  *
- * Copyright (c) 1994-2001 Justin T. Gibbs.
- * Copyright (c) 2000-2001 Adaptec Inc.
+ * Copyright (c) 1994-2002 Justin T. Gibbs.
+ * Copyright (c) 2000-2002 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -37,9 +37,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.c#69 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.c#133 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx.c,v 1.41.2.22 2002/04/29 19:36:26 gibbs Exp $
+ * $FreeBSD$
  */
 
 #ifdef __linux__
@@ -144,7 +144,8 @@ static struct ahc_syncrate ahc_syncrates
 #include "aic7xxx_seq.h"
 
 /**************************** Function Declarations ***************************/
-static void		ahc_force_renegotiation(struct ahc_softc *ahc);
+static void		ahc_force_renegotiation(struct ahc_softc *ahc,
+						struct ahc_devinfo *devinfo);
 static struct ahc_tmode_tstate*
 			ahc_alloc_tstate(struct ahc_softc *ahc,
 					 u_int scsi_id, char channel);
@@ -181,6 +182,7 @@ static void		ahc_construct_ppr(struct ah
 					  u_int period, u_int offset,
 					  u_int bus_width, u_int ppr_options);
 static void		ahc_clear_msg_state(struct ahc_softc *ahc);
+static void		ahc_handle_proto_violation(struct ahc_softc *ahc);
 static void		ahc_handle_message_phase(struct ahc_softc *ahc);
 typedef enum {
 	AHCMSG_1B,
@@ -200,7 +202,7 @@ static void		ahc_handle_devreset(struct 
 					    struct ahc_devinfo *devinfo,
 					    cam_status status, char *message,
 					    int verbose_level);
-#if AHC_TARGET_MODE
+#ifdef AHC_TARGET_MODE
 static void		ahc_setup_target_msgin(struct ahc_softc *ahc,
 					       struct ahc_devinfo *devinfo,
 					       struct scb *scb);
@@ -223,7 +225,7 @@ static void		ahc_reset_current_bus(struc
 #ifdef AHC_DUMP_SEQ
 static void		ahc_dumpseq(struct ahc_softc *ahc);
 #endif
-static void		ahc_loadseq(struct ahc_softc *ahc);
+static int		ahc_loadseq(struct ahc_softc *ahc);
 static int		ahc_check_patch(struct ahc_softc *ahc,
 					struct patch **start_patch,
 					u_int start_instr, u_int *skip_addr);
@@ -289,7 +291,7 @@ ahc_restart(struct ahc_softc *ahc)
 			 ahc_inb(ahc, SEQ_FLAGS2) & ~SCB_DMA);
 	}
 	ahc_outb(ahc, MWI_RESIDUAL, 0);
-	ahc_outb(ahc, SEQCTL, FASTMODE);
+	ahc_outb(ahc, SEQCTL, ahc->seqctl);
 	ahc_outb(ahc, SEQADDR0, 0);
 	ahc_outb(ahc, SEQADDR1, 0);
 	ahc_unpause(ahc);
@@ -330,7 +332,7 @@ ahc_run_qoutfifo(struct ahc_softc *ahc)
 			printf("%s: WARNING no command for scb %d "
 			       "(cmdcmplt)\nQOUTPOS = %d\n",
 			       ahc_name(ahc), scb_index,
-			       ahc->qoutfifonext - 1);
+			       (ahc->qoutfifonext - 1) & 0xFF);
 			continue;
 		}
 
@@ -388,7 +390,7 @@ ahc_handle_brkadrint(struct ahc_softc *a
 
 	ahc_dump_card_state(ahc);
 
-	/* Tell everyone that this HBA is no longer availible */
+	/* Tell everyone that this HBA is no longer available */
 	ahc_abort_scbs(ahc, CAM_TARGET_WILDCARD, ALL_CHANNELS,
 		       CAM_LUN_WILDCARD, SCB_LIST_NULL, ROLE_UNKNOWN,
 		       CAM_NO_HBA);
@@ -437,10 +439,10 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 		scb_index = ahc_inb(ahc, SCB_TAG);
 		scb = ahc_lookup_scb(ahc, scb_index);
 		if (scb == NULL) {
-			printf("%s:%c:%d: ahc_intr - referenced scb "
+			ahc_print_devinfo(ahc, &devinfo);
+			printf("ahc_intr - referenced scb "
 			       "not valid during seqint 0x%x scb(%d)\n",
-			       ahc_name(ahc), devinfo.channel,
-			       devinfo.target, intstat, scb_index);
+			       intstat, scb_index);
 			ahc_dump_card_state(ahc);
 			panic("for safety");
 			goto unpause;
@@ -478,7 +480,7 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 			struct ahc_tmode_tstate *tstate;
 			struct ahc_transinfo *tinfo;
 #ifdef AHC_DEBUG
-			if (ahc_debug & AHC_SHOWSENSE) {
+			if (ahc_debug & AHC_SHOW_SENSE) {
 				ahc_print_path(ahc, scb);
 				printf("SCB %d: requests Check Status\n",
 				       scb->hscb->tag);
@@ -501,7 +503,7 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 			 */
 			ahc_update_residual(ahc, scb);
 #ifdef AHC_DEBUG
-			if (ahc_debug & AHC_SHOWSENSE) {
+			if (ahc_debug & AHC_SHOW_SENSE) {
 				ahc_print_path(ahc, scb);
 				printf("Sending Sense\n");
 			}
@@ -545,7 +547,7 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 			 == ahc_get_transfer_length(scb)) {
 				ahc_update_neg_request(ahc, &devinfo,
 						       tstate, targ_info,
-						       /*force*/TRUE);
+						       AHC_NEG_IF_NON_ASYNC);
 			}
 			if (tstate->auto_negotiate & devinfo.target_mask) {
 				hscb->control |= MK_MESSAGE;
@@ -561,16 +563,11 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 			scb->flags |= SCB_SENSE;
 			ahc_qinfifo_requeue_tail(ahc, scb);
 			ahc_outb(ahc, RETURN_1, SEND_SENSE);
-#ifdef __FreeBSD__
 			/*
 			 * Ensure we have enough time to actually
 			 * retrieve the sense.
 			 */
-			untimeout(ahc_timeout, (caddr_t)scb,
-				  scb->io_ctx->ccb_h.timeout_ch);
-			scb->io_ctx->ccb_h.timeout_ch =
-			    timeout(ahc_timeout, (caddr_t)scb, 5 * hz);
-#endif
+			ahc_scb_timer_reset(scb, 5 * 1000000);
 			break;
 		}
 		default:
@@ -624,27 +621,10 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 		       ahc_name(ahc), devinfo.channel, devinfo.target, rejbyte);
 		break; 
 	}
-	case NO_IDENT: 
+	case PROTO_VIOLATION:
 	{
-		/*
-		 * The reconnecting target either did not send an identify
-		 * message, or did, but we didn't find an SCB to match and
-		 * before it could respond to our ATN/abort, it hit a dataphase.
-		 * The only safe thing to do is to blow it away with a bus
-		 * reset.
-		 */
-		int found;
-
-		printf("%s:%c:%d: Target did not send an IDENTIFY message. "
-		       "LASTPHASE = 0x%x, SAVED_SCSIID == 0x%x\n",
-		       ahc_name(ahc), devinfo.channel, devinfo.target,
-		       ahc_inb(ahc, LASTPHASE), ahc_inb(ahc, SAVED_SCSIID));
-		found = ahc_reset_channel(ahc, devinfo.channel, 
-					  /*initiate reset*/TRUE);
-		printf("%s: Issued Channel %c Bus Reset. "
-		       "%d SCBs aborted\n", ahc_name(ahc), devinfo.channel,
-		       found);
-		return;
+		ahc_handle_proto_violation(ahc);
+		break;
 	}
 	case IGN_WIDE_RES:
 		ahc_handle_ign_wide_residue(ahc, &devinfo);
@@ -725,7 +705,7 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 					ahc->msgin_index = 0;
 				}
 			}
-#if AHC_TARGET_MODE
+#ifdef AHC_TARGET_MODE
 			else {
 				if (bus_phase == P_MESGOUT) {
 					ahc->msg_type =
@@ -772,7 +752,44 @@ ahc_handle_seqint(struct ahc_softc *ahc,
 				ahc_outb(ahc, LASTPHASE, curphase);
 				ahc_outb(ahc, SCSISIGO, curphase);
 			}
-			ahc_inb(ahc, SCSIDATL);
+			if ((ahc_inb(ahc, SCSISIGI) & (CDI|MSGI)) == 0) {
+				int wait;
+
+				/*
+				 * In a data phase.  Faster to bitbucket
+				 * the data than to individually ack each
+				 * byte.  This is also the only strategy
+				 * that will work with AUTOACK enabled.
+				 */
+				ahc_outb(ahc, SXFRCTL1,
+					 ahc_inb(ahc, SXFRCTL1) | BITBUCKET);
+				wait = 5000;
+				while (--wait != 0) {
+					if ((ahc_inb(ahc, SCSISIGI)
+					  & (CDI|MSGI)) != 0)
+						break;
+					ahc_delay(100);
+				}
+				ahc_outb(ahc, SXFRCTL1,
+					 ahc_inb(ahc, SXFRCTL1) & ~BITBUCKET);
+				if (wait == 0) {
+					struct	scb *scb;
+					u_int	scb_index;
+
+					ahc_print_devinfo(ahc, &devinfo);
+					printf("Unable to clear parity error.  "
+					       "Resetting bus.\n");
+					scb_index = ahc_inb(ahc, SCB_TAG);
+					scb = ahc_lookup_scb(ahc, scb_index);
+					if (scb != NULL)
+						ahc_set_transaction_status(scb,
+						    CAM_UNCOR_PARITY);
+					ahc_reset_channel(ahc, devinfo.channel, 
+							  /*init reset*/TRUE);
+				}
+			} else {
+				ahc_inb(ahc, SCSIDATL);
+			}
 		}
 		break;
 	}
@@ -942,9 +959,6 @@ ahc_handle_scsiint(struct ahc_softc *ahc
 	char	cur_channel;
 	char	intr_channel;
 
-	/* Make sure the sequencer is in a safe location. */
-	ahc_clear_critical_section(ahc);
-
 	if ((ahc->features & AHC_TWIN) != 0
 	 && ((ahc_inb(ahc, SBLKCTL) & SELBUSB) != 0))
 		cur_channel = 'B';
@@ -973,10 +987,13 @@ ahc_handle_scsiint(struct ahc_softc *ahc
 		}
 	}
 
+	/* Make sure the sequencer is in a safe location. */
+	ahc_clear_critical_section(ahc);
+
 	scb_index = ahc_inb(ahc, SCB_TAG);
 	scb = ahc_lookup_scb(ahc, scb_index);
 	if (scb != NULL
-	 && (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) == 0)
+	 && (ahc_inb(ahc, SEQ_FLAGS) & NOT_IDENTIFIED) != 0)
 		scb = NULL;
 
 	if ((ahc->features & AHC_ULTRA2) != 0
@@ -1016,13 +1033,15 @@ ahc_handle_scsiint(struct ahc_softc *ahc
 		 * we should look at the last phase the sequencer recorded,
 		 * or the current phase presented on the bus.
 		 */
-		u_int mesg_out;
-		u_int curphase;
-		u_int errorphase;
-		u_int lastphase;
-		u_int scsirate;
-		u_int i;
-		u_int sstat2;
+		struct	ahc_devinfo devinfo;
+		u_int	mesg_out;
+		u_int	curphase;
+		u_int	errorphase;
+		u_int	lastphase;
+		u_int	scsirate;
+		u_int	i;
+		u_int	sstat2;
+		int	silent;
 
 		lastphase = ahc_inb(ahc, LASTPHASE);
 		curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
@@ -1050,29 +1069,47 @@ ahc_handle_scsiint(struct ahc_softc *ahc
 				break;
 		}
 		mesg_out = ahc_phase_table[i].mesg_out;
-		if (scb != NULL)
-			ahc_print_path(ahc, scb);
-		else
+		silent = FALSE;
+		if (scb != NULL) {
+			if (SCB_IS_SILENT(scb))
+				silent = TRUE;
+			else
+				ahc_print_path(ahc, scb);
+			scb->flags |= SCB_TRANSMISSION_ERROR;
+		} else
 			printf("%s:%c:%d: ", ahc_name(ahc), intr_channel,
 			       SCSIID_TARGET(ahc, ahc_inb(ahc, SAVED_SCSIID)));
 		scsirate = ahc_inb(ahc, SCSIRATE);
-		printf("parity error detected %s. "
-		       "SEQADDR(0x%x) SCSIRATE(0x%x)\n",
-		       ahc_phase_table[i].phasemsg,
-		       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8),
-		       scsirate);
-
-		if ((ahc->features & AHC_DT) != 0) {
+		if (silent == FALSE) {
+			printf("parity error detected %s. "
+			       "SEQADDR(0x%x) SCSIRATE(0x%x)\n",
+			       ahc_phase_table[i].phasemsg,
+			       ahc_inw(ahc, SEQADDR0),
+			       scsirate);
+			if ((ahc->features & AHC_DT) != 0) {
+				if ((sstat2 & CRCVALERR) != 0)
+					printf("\tCRC Value Mismatch\n");
+				if ((sstat2 & CRCENDERR) != 0)
+					printf("\tNo terminal CRC packet "
+					       "recevied\n");
+				if ((sstat2 & CRCREQERR) != 0)
+					printf("\tIllegal CRC packet "
+					       "request\n");
+				if ((sstat2 & DUAL_EDGE_ERR) != 0)
+					printf("\tUnexpected %sDT Data Phase\n",
+					       (scsirate & SINGLE_EDGE)
+					     ? "" : "non-");
+			}
+		}
 
-			if ((sstat2 & CRCVALERR) != 0)
-				printf("\tCRC Value Mismatch\n");
-			if ((sstat2 & CRCENDERR) != 0)
-				printf("\tNo terminal CRC packet recevied\n");
-			if ((sstat2 & CRCREQERR) != 0)
-				printf("\tIllegal CRC packet request\n");
-			if ((sstat2 & DUAL_EDGE_ERR) != 0)
-				printf("\tUnexpected %sDT Data Phase\n",
-				       (scsirate & SINGLE_EDGE) ? "" : "non-");
+		if ((ahc->features & AHC_DT) != 0
+		 && (sstat2 & DUAL_EDGE_ERR) != 0) {
+			/*
+			 * This error applies regardless of
+			 * data direction, so ignore the value
+			 * in the phase table.
+			 */
+			mesg_out = MSG_INITIATOR_DET_ERR;
 		}
 
 		/*
@@ -1093,7 +1130,9 @@ ahc_handle_scsiint(struct ahc_softc *ahc
 		 * case we are out of sync for some external reason
 		 * unknown (or unreported) by the target.
 		 */
-		ahc_force_renegotiation(ahc);
+		ahc_fetch_devinfo(ahc, &devinfo);
+		ahc_force_renegotiation(ahc, &devinfo);
+
 		ahc_outb(ahc, CLRINT, CLRSCSIINT);
 		ahc_unpause(ahc);
 	} else if ((status & SELTO) != 0) {
@@ -1128,31 +1167,42 @@ ahc_handle_scsiint(struct ahc_softc *ahc
 			printf("%s: ahc_intr - referenced scb not "
 			       "valid during SELTO scb(%d, %d)\n",
 			       ahc_name(ahc), scbptr, scb_index);
+			ahc_dump_card_state(ahc);
 		} else {
+			struct ahc_devinfo devinfo;
+#ifdef AHC_DEBUG
+			if ((ahc_debug & AHC_SHOW_SELTO) != 0) {
+				ahc_print_path(ahc, scb);
+				printf("Saw Selection Timeout for SCB 0x%x\n",
+				       scb_index);
+			}
+#endif
+			/*
+			 * Force a renegotiation with this target just in
+			 * case the cable was pulled and will later be
+			 * re-attached.  The target may forget its negotiation
+			 * settings with us should it attempt to reselect
+			 * during the interruption.  The target will not issue
+			 * a unit attention in this case, so we must always
+			 * renegotiate.
+			 */
+			ahc_scb_devinfo(ahc, &devinfo, scb);
+			ahc_force_renegotiation(ahc, &devinfo);
 			ahc_set_transaction_status(scb, CAM_SEL_TIMEOUT);
 			ahc_freeze_devq(ahc, scb);
 		}
 		ahc_outb(ahc, CLRINT, CLRSCSIINT);
-		/*
-		 * Force a renegotiation with this target just in
-		 * case the cable was pulled and will later be
-		 * re-attached.  The target may forget its negotiation
-		 * settings with us should it attempt to reselect
-		 * during the interruption.  The target will not issue
-		 * a unit attention in this case, so we must always
-		 * renegotiate.
-		 */
-		ahc_force_renegotiation(ahc);
 		ahc_restart(ahc);
 	} else if ((status & BUSFREE) != 0
 		&& (ahc_inb(ahc, SIMODE1) & ENBUSFREE) != 0) {
-		u_int lastphase;
-		u_int saved_scsiid;
-		u_int saved_lun;
-		u_int target;
-		u_int initiator_role_id;
-		char channel;
-		int printerror;
+		struct	ahc_devinfo devinfo;
+		u_int	lastphase;
+		u_int	saved_scsiid;
+		u_int	saved_lun;
+		u_int	target;
+		u_int	initiator_role_id;
+		char	channel;
+		int	printerror;
 
 		/*
 		 * Clear our selection hardware as soon as possible.
@@ -1184,13 +1234,13 @@ ahc_handle_scsiint(struct ahc_softc *ahc
 		target = SCSIID_TARGET(ahc, saved_scsiid);
 		initiator_role_id = SCSIID_OUR_ID(saved_scsiid);
 		channel = SCSIID_CHANNEL(ahc, saved_scsiid);
+		ahc_compile_devinfo(&devinfo, initiator_role_id,
+				    target, saved_lun, channel, ROLE_INITIATOR);
 		printerror = 1;
 
 		if (lastphase == P_MESGOUT) {
-			struct ahc_devinfo devinfo;
 			u_int tag;
 
-			ahc_fetch_devinfo(ahc, &devinfo);
 			tag = SCB_LIST_NULL;
 			if (ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT_TAG, TRUE)
 			 || ahc_sent_msg(ahc, AHCMSG_1B, MSG_ABORT, TRUE)) {
@@ -1254,17 +1304,23 @@ ahc_handle_scsiint(struct ahc_softc *ahc
 				ahc_qinfifo_requeue_tail(ahc, scb);
 				printerror = 0;
 			} else if (ahc_sent_msg(ahc, AHCMSG_EXT,
-						MSG_EXT_WDTR, FALSE)
-				|| ahc_sent_msg(ahc, AHCMSG_EXT,
-						MSG_EXT_SDTR, FALSE)) {
+						MSG_EXT_WDTR, FALSE)) {
 				/*
-				 * Negotiation Rejected.  Go-async and
+				 * Negotiation Rejected.  Go-narrow and
 				 * retry command.
 				 */
 				ahc_set_width(ahc, &devinfo,
 					      MSG_EXT_WDTR_BUS_8_BIT,
 					      AHC_TRANS_CUR|AHC_TRANS_GOAL,
 					      /*paused*/TRUE);
+				ahc_qinfifo_requeue_tail(ahc, scb);
+				printerror = 0;
+			} else if (ahc_sent_msg(ahc, AHCMSG_EXT,
+						MSG_EXT_SDTR, FALSE)) {
+				/*
+				 * Negotiation Rejected.  Go-async and
+				 * retry command.
+				 */
 				ahc_set_syncrate(ahc, &devinfo,
 						/*syncrate*/NULL,
 						/*period*/0, /*offset*/0,
@@ -1301,13 +1357,15 @@ ahc_handle_scsiint(struct ahc_softc *ahc
 				if (lastphase == ahc_phase_table[i].phase)
 					break;
 			}
-			/*
-			 * Renegotiate with this device at the
-			 * next oportunity just in case this busfree
-			 * is due to a negotiation mismatch with the
-			 * device.
-			 */
-			ahc_force_renegotiation(ahc);
+			if (lastphase != P_BUSFREE) {
+				/*
+				 * Renegotiate with this device at the
+				 * next oportunity just in case this busfree
+				 * is due to a negotiation mismatch with the
+				 * device.
+				 */
+				ahc_force_renegotiation(ahc, &devinfo);
+			}
 			printf("Unexpected busfree %s\n"
 			       "SEQADDR == 0x%x\n",
 			       ahc_phase_table[i].phasemsg,
@@ -1328,20 +1386,18 @@ ahc_handle_scsiint(struct ahc_softc *ahc
  * a command to the current device.
  */
 static void
-ahc_force_renegotiation(struct ahc_softc *ahc)
+ahc_force_renegotiation(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
 {
-	struct	ahc_devinfo devinfo;
 	struct	ahc_initiator_tinfo *targ_info;
 	struct	ahc_tmode_tstate *tstate;
 
-	ahc_fetch_devinfo(ahc, &devinfo);
 	targ_info = ahc_fetch_transinfo(ahc,
-					devinfo.channel,
-					devinfo.our_scsiid,
-					devinfo.target,
+					devinfo->channel,
+					devinfo->our_scsiid,
+					devinfo->target,
 					&tstate);
-	ahc_update_neg_request(ahc, &devinfo, tstate,
-			       targ_info, /*force*/TRUE);
+	ahc_update_neg_request(ahc, devinfo, tstate,
+			       targ_info, AHC_NEG_IF_NON_ASYNC);
 }
 
 #define AHC_MAX_STEPS 2000
@@ -1404,11 +1460,26 @@ ahc_clear_critical_section(struct ahc_so
 			simode0 = ahc_inb(ahc, SIMODE0);
 			ahc_outb(ahc, SIMODE0, 0);
 			simode1 = ahc_inb(ahc, SIMODE1);
-			ahc_outb(ahc, SIMODE1, 0);
+			if ((ahc->features & AHC_DT) != 0)
+				/*
+				 * On DT class controllers, we
+				 * use the enhanced busfree logic.
+				 * Unfortunately we cannot re-enable
+				 * busfree detection within the
+				 * current connection, so we must
+				 * leave it on while single stepping.
+				 */
+				ahc_outb(ahc, SIMODE1, ENBUSFREE);
+			else
+				ahc_outb(ahc, SIMODE1, 0);
 			ahc_outb(ahc, CLRINT, CLRSCSIINT);
-			ahc_outb(ahc, SEQCTL, ahc_inb(ahc, SEQCTL) | STEP);
+			ahc_outb(ahc, SEQCTL, ahc->seqctl | STEP);
 			stepping = TRUE;
 		}
+		if ((ahc->features & AHC_DT) != 0) {
+			ahc_outb(ahc, CLRSINT1, CLRBUSFREE);
+			ahc_outb(ahc, CLRINT, CLRSCSIINT);
+		}
 		ahc_outb(ahc, HCNTRL, ahc->unpause);
 		while (!ahc_is_paused(ahc))
 			ahc_delay(200);
@@ -1416,7 +1487,7 @@ ahc_clear_critical_section(struct ahc_so
 	if (stepping) {
 		ahc_outb(ahc, SIMODE0, simode0);
 		ahc_outb(ahc, SIMODE1, simode1);
-		ahc_outb(ahc, SEQCTL, ahc_inb(ahc, SEQCTL) & ~STEP);
+		ahc_outb(ahc, SEQCTL, ahc->seqctl);
 	}
 }
 
@@ -1439,7 +1510,7 @@ ahc_clear_intstat(struct ahc_softc *ahc)
 
 /**************************** Debugging Routines ******************************/
 #ifdef AHC_DEBUG
-int ahc_debug = AHC_DEBUG;
+uint32_t ahc_debug = AHC_DEBUG_OPTS;
 #endif
 
 void
@@ -1496,7 +1567,8 @@ ahc_alloc_tstate(struct ahc_softc *ahc, 
 	 && ahc->enabled_targets[scsi_id] != master_tstate)
 		panic("%s: ahc_alloc_tstate - Target already allocated",
 		      ahc_name(ahc));
-	tstate = malloc(sizeof(*tstate), M_DEVBUF, M_NOWAIT);
+	tstate = (struct ahc_tmode_tstate*)malloc(sizeof(*tstate),
+						   M_DEVBUF, M_NOWAIT);
 	if (tstate == NULL)
 		return (NULL);
 
@@ -1593,6 +1665,10 @@ ahc_devlimited_syncrate(struct ahc_softc
 	else 
 		transinfo = &tinfo->goal;
 	*ppr_options &= transinfo->ppr_options;
+	if (transinfo->width == MSG_EXT_WDTR_BUS_8_BIT) {
+		maxsync = MAX(maxsync, AHC_SYNCRATE_ULTRA2);
+		*ppr_options &= ~MSG_EXT_PPR_DT_REQ;
+	}
 	if (transinfo->period == 0) {
 		*period = 0;
 		*ppr_options = 0;
@@ -1769,17 +1845,29 @@ ahc_validate_width(struct ahc_softc *ahc
 int
 ahc_update_neg_request(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
 		       struct ahc_tmode_tstate *tstate,
-		       struct ahc_initiator_tinfo *tinfo, int force)
+		       struct ahc_initiator_tinfo *tinfo, ahc_neg_type neg_type)
 {
 	u_int auto_negotiate_orig;
 
 	auto_negotiate_orig = tstate->auto_negotiate;
+	if (neg_type == AHC_NEG_ALWAYS) {
+		/*
+		 * Force our "current" settings to be
+		 * unknown so that unless a bus reset
+		 * occurs the need to renegotiate is
+		 * recorded persistently.
+		 */
+		if ((ahc->features & AHC_WIDE) != 0)
+			tinfo->curr.width = AHC_WIDTH_UNKNOWN;
+		tinfo->curr.period = AHC_PERIOD_UNKNOWN;
+		tinfo->curr.offset = AHC_OFFSET_UNKNOWN;
+	}
 	if (tinfo->curr.period != tinfo->goal.period
 	 || tinfo->curr.width != tinfo->goal.width
 	 || tinfo->curr.offset != tinfo->goal.offset
 	 || tinfo->curr.ppr_options != tinfo->goal.ppr_options
-	 || (force
-	  && (tinfo->goal.period != 0
+	 || (neg_type == AHC_NEG_IF_NON_ASYNC
+	  && (tinfo->goal.offset != 0
 	   || tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT
 	   || tinfo->goal.ppr_options != 0)))
 		tstate->auto_negotiate |= devinfo->target_mask;
@@ -1910,7 +1998,7 @@ ahc_set_syncrate(struct ahc_softc *ahc, 
 	}
 
 	update_needed += ahc_update_neg_request(ahc, devinfo, tstate,
-						tinfo, /*force*/FALSE);
+						tinfo, AHC_NEG_TO_GOAL);
 
 	if (update_needed)
 		ahc_update_pending_scbs(ahc);
@@ -1972,7 +2060,7 @@ ahc_set_width(struct ahc_softc *ahc, str
 	}
 
 	update_needed += ahc_update_neg_request(ahc, devinfo, tstate,
-						tinfo, /*force*/FALSE);
+						tinfo, AHC_NEG_TO_GOAL);
 	if (update_needed)
 		ahc_update_pending_scbs(ahc);
 }
@@ -2086,7 +2174,8 @@ ahc_fetch_devinfo(struct ahc_softc *ahc,
 
 	if (role == ROLE_TARGET
 	 && (ahc->features & AHC_MULTI_TID) != 0
-	 && (ahc_inb(ahc, SEQ_FLAGS) & CMDPHASE_PENDING) != 0) {
+	 && (ahc_inb(ahc, SEQ_FLAGS)
+ 	   & (CMDPHASE_PENDING|TARG_CMD_PENDING|NO_DISCONNECT)) != 0) {
 		/* We were selected, so pull our id from TARGIDIN */
 		our_id = ahc_inb(ahc, TARGIDIN) & OID;
 	} else if ((ahc->features & AHC_ULTRA2) != 0)
@@ -2136,6 +2225,13 @@ ahc_compile_devinfo(struct ahc_devinfo *
 	devinfo->target_mask = (0x01 << devinfo->target_offset);
 }
 
+void
+ahc_print_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
+{
+	printf("%s:%c:%d:%d: ", ahc_name(ahc), devinfo->channel,
+	       devinfo->target, devinfo->lun);
+}
+
 static void
 ahc_scb_devinfo(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
 		struct scb *scb)
@@ -2145,7 +2241,7 @@ ahc_scb_devinfo(struct ahc_softc *ahc, s
 
 	our_id = SCSIID_OUR_ID(scb->hscb->scsiid);
 	role = ROLE_INITIATOR;
-	if ((scb->hscb->control & TARGET_SCB) != 0)
+	if ((scb->flags & SCB_TARGET_SCB) != 0)
 		role = ROLE_TARGET;
 	ahc_compile_devinfo(devinfo, our_id, SCB_GET_TARGET(ahc, scb),
 			    SCB_GET_LUN(scb), SCB_GET_CHANNEL(ahc, scb), role);
@@ -2270,7 +2366,6 @@ ahc_build_transfer_msg(struct ahc_softc 
 	int	dowide;
 	int	dosync;
 	int	doppr;
-	int	use_ppr;
 	u_int	period;
 	u_int	ppr_options;
 	u_int	offset;
@@ -2284,6 +2379,7 @@ ahc_build_transfer_msg(struct ahc_softc 
 	 * may change.
 	 */
 	period = tinfo->goal.period;
+	offset = tinfo->goal.offset;
 	ppr_options = tinfo->goal.ppr_options;
 	/* Target initiated PPR is not allowed in the SCSI spec */
 	if (devinfo->role == ROLE_TARGET)
@@ -2291,24 +2387,38 @@ ahc_build_transfer_msg(struct ahc_softc 
 	rate = ahc_devlimited_syncrate(ahc, tinfo, &period,
 				       &ppr_options, devinfo->role);
 	dowide = tinfo->curr.width != tinfo->goal.width;
-	dosync = tinfo->curr.period != period;
-	doppr = tinfo->curr.ppr_options != ppr_options;
+	dosync = tinfo->curr.offset != offset || tinfo->curr.period != period;
+	/*
+	 * Only use PPR if we have options that need it, even if the device
+	 * claims to support it.  There might be an expander in the way
+	 * that doesn't.
+	 */
+	doppr = ppr_options != 0;
 
 	if (!dowide && !dosync && !doppr) {
 		dowide = tinfo->goal.width != MSG_EXT_WDTR_BUS_8_BIT;
-		dosync = tinfo->goal.period != 0;
-		doppr = tinfo->goal.ppr_options != 0;
+		dosync = tinfo->goal.offset != 0;
 	}
 
 	if (!dowide && !dosync && !doppr) {
-		panic("ahc_intr: AWAITING_MSG for negotiation, "
-		      "but no negotiation needed\n");	
+		/*
+		 * Force async with a WDTR message if we have a wide bus,
+		 * or just issue an SDTR with a 0 offset.
+		 */
+		if ((ahc->features & AHC_WIDE) != 0)
+			dowide = 1;
+		else
+			dosync = 1;
+
+		if (bootverbose) {
+			ahc_print_devinfo(ahc, devinfo);
+			printf("Ensuring async\n");
+		}
 	}
 
-	use_ppr = (tinfo->curr.transport_version >= 3) || doppr;
 	/* Target initiated PPR is not allowed in the SCSI spec */
 	if (devinfo->role == ROLE_TARGET)
-		use_ppr = 0;
+		doppr = 0;
 
 	/*
 	 * Both the PPR message and SDTR message require the
@@ -2318,14 +2428,14 @@ ahc_build_transfer_msg(struct ahc_softc 
 	 * Regardless, guarantee that if we are using WDTR and SDTR
 	 * messages that WDTR comes first.
 	 */
-	if (use_ppr || (dosync && !dowide)) {
+	if (doppr || (dosync && !dowide)) {
 
 		offset = tinfo->goal.offset;
 		ahc_validate_offset(ahc, tinfo, rate, &offset,
-				    use_ppr ? tinfo->goal.width
-					    : tinfo->curr.width,
+				    doppr ? tinfo->goal.width
+					  : tinfo->curr.width,
 				    devinfo->role);
-		if (use_ppr) {
+		if (doppr) {
 			ahc_construct_ppr(ahc, devinfo, period, offset,
 					  tinfo->goal.width, ppr_options);
 		} else {
@@ -2344,6 +2454,8 @@ static void
 ahc_construct_sdtr(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
 		   u_int period, u_int offset)
 {
+	if (offset == 0)
+		period = AHC_ASYNC_XFER_PERIOD;
 	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
 	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR_LEN;
 	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_SDTR;
@@ -2386,6 +2498,8 @@ ahc_construct_ppr(struct ahc_softc *ahc,
 		  u_int period, u_int offset, u_int bus_width,
 		  u_int ppr_options)
 {
+	if (offset == 0)
+		period = AHC_ASYNC_XFER_PERIOD;
 	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXTENDED;
 	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_PPR_LEN;
 	ahc->msgout_buf[ahc->msgout_index++] = MSG_EXT_PPR;
@@ -2424,6 +2538,100 @@ ahc_clear_msg_state(struct ahc_softc *ah
 		 ahc_inb(ahc, SEQ_FLAGS2) & ~TARGET_MSG_PENDING);
 }
 
+static void
+ahc_handle_proto_violation(struct ahc_softc *ahc)
+{
+	struct	ahc_devinfo devinfo;
+	struct	scb *scb;
+	u_int	scbid;
+	u_int	seq_flags;
+	u_int	curphase;
+	u_int	lastphase;
+	int	found;
+
+	ahc_fetch_devinfo(ahc, &devinfo);
+	scbid = ahc_inb(ahc, SCB_TAG);
+	scb = ahc_lookup_scb(ahc, scbid);
+	seq_flags = ahc_inb(ahc, SEQ_FLAGS);
+	curphase = ahc_inb(ahc, SCSISIGI) & PHASE_MASK;
+	lastphase = ahc_inb(ahc, LASTPHASE);
+	if ((seq_flags & NOT_IDENTIFIED) != 0) {
+
+		/*
+		 * The reconnecting target either did not send an
+		 * identify message, or did, but we didn't find an SCB
+		 * to match.
+		 */
+		ahc_print_devinfo(ahc, &devinfo);
+		printf("Target did not send an IDENTIFY message. "
+		       "LASTPHASE = 0x%x.\n", lastphase);
+		scb = NULL;
+	} else if (scb == NULL) {
+		/*
+		 * We don't seem to have an SCB active for this
+		 * transaction.  Print an error and reset the bus.
+		 */
+		ahc_print_devinfo(ahc, &devinfo);
+		printf("No SCB found during protocol violation\n");
+		goto proto_violation_reset;
+	} else {
+		ahc_set_transaction_status(scb, CAM_SEQUENCE_FAIL);
+		if ((seq_flags & NO_CDB_SENT) != 0) {
+			ahc_print_path(ahc, scb);
+			printf("No or incomplete CDB sent to device.\n");
+		} else if ((ahc_inb(ahc, SCB_CONTROL) & STATUS_RCVD) == 0) {
+			/*
+			 * The target never bothered to provide status to
+			 * us prior to completing the command.  Since we don't
+			 * know the disposition of this command, we must attempt
+			 * to abort it.  Assert ATN and prepare to send an abort
+			 * message.
+			 */
+			ahc_print_path(ahc, scb);
+			printf("Completed command without status.\n");
+		} else {
+			ahc_print_path(ahc, scb);
+			printf("Unknown protocol violation.\n");
+			ahc_dump_card_state(ahc);
+		}
+	}
+	if ((lastphase & ~P_DATAIN_DT) == 0
+	 || lastphase == P_COMMAND) {
+proto_violation_reset:
+		/*
+		 * Target either went directly to data/command
+		 * phase or didn't respond to our ATN.
+		 * The only safe thing to do is to blow
+		 * it away with a bus reset.
+		 */
+		found = ahc_reset_channel(ahc, 'A', TRUE);
+		printf("%s: Issued Channel %c Bus Reset. "
+		       "%d SCBs aborted\n", ahc_name(ahc), 'A', found);
+	} else {
+		/*
+		 * Leave the selection hardware off in case
+		 * this abort attempt will affect yet to
+		 * be sent commands.
+		 */
+		ahc_outb(ahc, SCSISEQ,
+			 ahc_inb(ahc, SCSISEQ) & ~ENSELO);
+		ahc_assert_atn(ahc);
+		ahc_outb(ahc, MSG_OUT, HOST_MSG);
+		if (scb == NULL) {
+			ahc_print_devinfo(ahc, &devinfo);
+			ahc->msgout_buf[0] = MSG_ABORT_TASK;
+			ahc->msgout_len = 1;
+			ahc->msgout_index = 0;
+			ahc->msg_type = MSG_TYPE_INITIATOR_MSGOUT;
+		} else {
+			ahc_print_path(ahc, scb);
+			scb->flags |= SCB_ABORT;
+		}
+		printf("Protocol violation %s.  Attempting to abort.\n",
+		       ahc_lookup_phase_entry(curphase)->phasemsg);
+	}
+}
+
 /*
  * Manual message loop handler.
  */
@@ -2449,8 +2657,21 @@ reswitch:
 		if (ahc->msgout_len == 0)
 			panic("HOST_MSG_LOOP interrupt with no active message");
 
+#ifdef AHC_DEBUG
+		if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
+			ahc_print_devinfo(ahc, &devinfo);
+			printf("INITIATOR_MSG_OUT");
+		}
+#endif
 		phasemis = bus_phase != P_MESGOUT;
 		if (phasemis) {
+#ifdef AHC_DEBUG
+			if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
+				printf(" PHASEMIS %s\n",
+				       ahc_lookup_phase_entry(bus_phase)
+							     ->phasemsg);
+			}
+#endif
 			if (bus_phase == P_MESGIN) {
 				/*
 				 * Change gears and see if
@@ -2471,6 +2692,10 @@ reswitch:
 		if (ahc->send_msg_perror) {
 			ahc_outb(ahc, CLRSINT1, CLRATNO);
 			ahc_outb(ahc, CLRSINT1, CLRREQINIT);
+#ifdef AHC_DEBUG
+			if ((ahc_debug & AHC_SHOW_MESSAGES) != 0)
+				printf(" byte 0x%x\n", ahc->send_msg_perror);
+#endif
 			ahc_outb(ahc, SCSIDATL, MSG_PARITY_ERROR);
 			break;
 		}
@@ -2497,6 +2722,11 @@ reswitch:
 		 * the next byte on the bus.
 		 */
 		ahc_outb(ahc, CLRSINT1, CLRREQINIT);
+#ifdef AHC_DEBUG
+		if ((ahc_debug & AHC_SHOW_MESSAGES) != 0)
+			printf(" byte 0x%x\n",
+			       ahc->msgout_buf[ahc->msgout_index]);
+#endif
 		ahc_outb(ahc, SCSIDATL, ahc->msgout_buf[ahc->msgout_index++]);
 		break;
 	}
@@ -2505,9 +2735,21 @@ reswitch:
 		int phasemis;
 		int message_done;
 
+#ifdef AHC_DEBUG
+		if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
+			ahc_print_devinfo(ahc, &devinfo);
+			printf("INITIATOR_MSG_IN");
+		}
+#endif
 		phasemis = bus_phase != P_MESGIN;
-
 		if (phasemis) {
+#ifdef AHC_DEBUG
+			if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
+				printf(" PHASEMIS %s\n",
+				       ahc_lookup_phase_entry(bus_phase)
+							     ->phasemsg);
+			}
+#endif
 			ahc->msgin_index = 0;
 			if (bus_phase == P_MESGOUT
 			 && (ahc->send_msg_perror == TRUE
@@ -2522,6 +2764,11 @@ reswitch:
 
 		/* Pull the byte in without acking it */
 		ahc->msgin_buf[ahc->msgin_index] = ahc_inb(ahc, SCSIBUSL);
+#ifdef AHC_DEBUG
+		if ((ahc_debug & AHC_SHOW_MESSAGES) != 0)
+			printf(" byte 0x%x\n",
+			       ahc->msgin_buf[ahc->msgin_index]);
+#endif
 
 		message_done = ahc_parse_msg(ahc, &devinfo);
 
@@ -2537,8 +2784,15 @@ reswitch:
 			 * assert ATN so the target takes us to the
 			 * message out phase.
 			 */
-			if (ahc->msgout_len != 0)
+			if (ahc->msgout_len != 0) {
+#ifdef AHC_DEBUG
+				if ((ahc_debug & AHC_SHOW_MESSAGES) != 0) {
+					ahc_print_devinfo(ahc, &devinfo);
+					printf("Asserting ATN for response\n");
+				}
+#endif
 				ahc_assert_atn(ahc);
+			}
 		} else 
 			ahc->msgin_index++;
 
@@ -2748,9 +3002,9 @@ ahc_parse_msg(struct ahc_softc *ahc, str
 	targ_scsirate = tinfo->scsirate;
 
 	/*
-	 * Parse as much of the message as is availible,
+	 * Parse as much of the message as is available,
 	 * rejecting it if we don't support it.  When
-	 * the entire message is availible and has been
+	 * the entire message is available and has been
 	 * handled, return MSGLOOP_MSGCOMPLETE, indicating
 	 * that we have parsed an entire message.
 	 *
@@ -2929,23 +3183,30 @@ ahc_parse_msg(struct ahc_softc *ahc, str
 				response = TRUE;
 				sending_reply = TRUE;
 			}
+			/*
+			 * After a wide message, we are async, but
+			 * some devices don't seem to honor this portion
+			 * of the spec.  Force a renegotiation of the
+			 * sync component of our transfer agreement even
+			 * if our goal is async.  By updating our width
+			 * after forcing the negotiation, we avoid
+			 * renegotiating for width.
+			 */
+			ahc_update_neg_request(ahc, devinfo, tstate,
+					       tinfo, AHC_NEG_ALWAYS);
 			ahc_set_width(ahc, devinfo, bus_width,
 				      AHC_TRANS_ACTIVE|AHC_TRANS_GOAL,
 				      /*paused*/TRUE);
-			/* After a wide message, we are async */
-			ahc_set_syncrate(ahc, devinfo,
-					 /*syncrate*/NULL, /*period*/0,
-					 /*offset*/0, /*ppr_options*/0,
-					 AHC_TRANS_ACTIVE, /*paused*/TRUE);
 			if (sending_reply == FALSE && reject == FALSE) {
 
-				if (tinfo->goal.period) {
-					ahc->msgout_index = 0;
-					ahc->msgout_len = 0;
-					ahc_build_transfer_msg(ahc, devinfo);
-					ahc->msgout_index = 0;
-					response = TRUE;
-				}
+				/*
+				 * We will always have an SDTR to send.
+				 */
+				ahc->msgout_index = 0;
+				ahc->msgout_len = 0;
+				ahc_build_transfer_msg(ahc, devinfo);
+				ahc->msgout_index = 0;
+				response = TRUE;
 			}
 			done = MSGLOOP_MSGCOMPLETE;
 			break;
@@ -3204,7 +3465,7 @@ ahc_handle_msg_reject(struct ahc_softc *
 		 * but rejected our response, we already cleared the
 		 * sync rate before sending our WDTR.
 		 */
-		if (tinfo->goal.period) {
+		if (tinfo->goal.offset != tinfo->curr.offset) {
 
 			/* Start the sync negotiation */
 			ahc->msgout_index = 0;
@@ -3326,7 +3587,7 @@ ahc_handle_ign_wide_residue(struct ahc_s
 
 		sgptr = ahc_inb(ahc, SCB_RESIDUAL_SGPTR);
 		if ((sgptr & SG_LIST_NULL) != 0
-		 && ahc_inb(ahc, DATA_COUNT_ODD) == 1) {
+		 && (ahc_inb(ahc, SCB_LUN) & SCB_XFERLEN_ODD) != 0) {
 			/*
 			 * If the residual occurred on the last
 			 * transfer and the transfer request was
@@ -3339,25 +3600,27 @@ ahc_handle_ign_wide_residue(struct ahc_s
 			uint32_t data_addr;
 			uint32_t sglen;
 
-			/* Pull in the rest of the sgptr */
-			sgptr |= (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 3) << 24)
-			      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 2) << 16)
-			      | (ahc_inb(ahc, SCB_RESIDUAL_SGPTR + 1) << 8);
-			sgptr &= SG_PTR_MASK;
-			data_cnt = (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+3) << 24)
-				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+2) << 16)
-				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT+1) << 8)
-				 | (ahc_inb(ahc, SCB_RESIDUAL_DATACNT));
-
-			data_addr = (ahc_inb(ahc, SHADDR + 3) << 24)
-				  | (ahc_inb(ahc, SHADDR + 2) << 16)
-				  | (ahc_inb(ahc, SHADDR + 1) << 8)
-				  | (ahc_inb(ahc, SHADDR));
+			/* Pull in all of the sgptr */
+			sgptr = ahc_inl(ahc, SCB_RESIDUAL_SGPTR);
+			data_cnt = ahc_inl(ahc, SCB_RESIDUAL_DATACNT);
+
+			if ((sgptr & SG_LIST_NULL) != 0) {
+				/*
+				 * The residual data count is not updated
+				 * for the command run to completion case.
+				 * Explicitly zero the count.
+				 */
+				data_cnt &= ~AHC_SG_LEN_MASK;
+			}
+
+			data_addr = ahc_inl(ahc, SHADDR);
 
 			data_cnt += 1;
 			data_addr -= 1;
+			sgptr &= SG_PTR_MASK;
 
 			sg = ahc_sg_bus_to_virt(scb, sgptr);
+
 			/*
 			 * The residual sg ptr points to the next S/G
 			 * to load so we must go back one.
@@ -3383,19 +3646,17 @@ ahc_handle_ign_wide_residue(struct ahc_s
 				 */
 				sg++;
 				sgptr = ahc_sg_virt_to_bus(scb, sg);
-				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 3,
-					 sgptr >> 24);
-				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 2,
-					 sgptr >> 16);
-				ahc_outb(ahc, SCB_RESIDUAL_SGPTR + 1,
-					 sgptr >> 8);
-				ahc_outb(ahc, SCB_RESIDUAL_SGPTR, sgptr);
 			}
-
-			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 3, data_cnt >> 24);
-			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 2, data_cnt >> 16);
-			ahc_outb(ahc, SCB_RESIDUAL_DATACNT + 1, data_cnt >> 8);
-			ahc_outb(ahc, SCB_RESIDUAL_DATACNT, data_cnt);
+			ahc_outl(ahc, SCB_RESIDUAL_SGPTR, sgptr);
+			ahc_outl(ahc, SCB_RESIDUAL_DATACNT, data_cnt);
+			/*
+			 * Toggle the "oddness" of the transfer length
+			 * to handle this mid-transfer ignore wide
+			 * residue.  This ensures that the oddness is
+			 * correct for subsequent data transfers.
+			 */
+			ahc_outb(ahc, SCB_LUN,
+				 ahc_inb(ahc, SCB_LUN) ^ SCB_XFERLEN_ODD);
 		}
 	}
 }
@@ -3579,6 +3840,12 @@ ahc_alloc(void *platform_arg, char *name
 	ahc->features = AHC_FENONE;
 	ahc->bugs = AHC_BUGNONE;
 	ahc->flags = AHC_FNONE;
+	/*
+	 * Default to all error reporting enabled with the
+	 * sequencer operating at its fastest speed.
+	 * The bus attach code may modify this.
+	 */
+	ahc->seqctl = FASTMODE;
 
 	for (i = 0; i < AHC_NUM_TARGETS; i++)
 		TAILQ_INIT(&ahc->untagged_queues[i]);
@@ -3658,7 +3925,7 @@ ahc_softc_insert(struct ahc_softc *ahc)
 	 */
 	list_ahc = TAILQ_FIRST(&ahc_tailq);
 	while (list_ahc != NULL
-	    && ahc_softc_comp(list_ahc, ahc) <= 0)
+	    && ahc_softc_comp(ahc, list_ahc) <= 0)
 		list_ahc = TAILQ_NEXT(list_ahc, links);
 	if (list_ahc != NULL)
 		TAILQ_INSERT_BEFORE(list_ahc, ahc, links);
@@ -3702,7 +3969,6 @@ ahc_free(struct ahc_softc *ahc)
 {
 	int i;
 
-	ahc_fini_scbdata(ahc);
 	switch (ahc->init_level) {
 	default:
 	case 5:
@@ -3734,12 +4000,13 @@ ahc_free(struct ahc_softc *ahc)
 	ahc_dma_tag_destroy(ahc, ahc->parent_dmat);
 #endif
 	ahc_platform_free(ahc);
+	ahc_fini_scbdata(ahc);
 	for (i = 0; i < AHC_NUM_TARGETS; i++) {
 		struct ahc_tmode_tstate *tstate;
 
 		tstate = ahc->enabled_targets[i];
 		if (tstate != NULL) {
-#if AHC_TARGET_MODE
+#ifdef AHC_TARGET_MODE
 			int j;
 
 			for (j = 0; j < AHC_NUM_LUNS; j++) {
@@ -3755,7 +4022,7 @@ ahc_free(struct ahc_softc *ahc)
 			free(tstate, M_DEVBUF);
 		}
 	}
-#if AHC_TARGET_MODE
+#ifdef AHC_TARGET_MODE
 	if (ahc->black_hole != NULL) {
 		xpt_free_path(ahc->black_hole->path);
 		free(ahc->black_hole, M_DEVBUF);
@@ -3780,7 +4047,7 @@ ahc_shutdown(void *arg)
 	ahc = (struct ahc_softc *)arg;
 
 	/* This will reset most registers to 0, but not all */
-	ahc_reset(ahc);
+	ahc_reset(ahc, /*reinit*/FALSE);
 	ahc_outb(ahc, SCSISEQ, 0);
 	ahc_outb(ahc, SXFRCTL0, 0);
 	ahc_outb(ahc, DSPCISTATUS, 0);
@@ -3791,13 +4058,19 @@ ahc_shutdown(void *arg)
 
 /*
  * Reset the controller and record some information about it
- * that is only available just after a reset.
+ * that is only available just after a reset.  If "reinit" is
+ * non-zero, this reset occured after initial configuration
+ * and the caller requests that the chip be fully reinitialized
+ * to a runable state.  Chip interrupts are *not* enabled after
+ * a reinitialization.  The caller must enable interrupts via
+ * ahc_intr_enable().
  */
 int
-ahc_reset(struct ahc_softc *ahc)
+ahc_reset(struct ahc_softc *ahc, int reinit)
 {
 	u_int	sblkctl;
 	u_int	sxfrctl1_a, sxfrctl1_b;
+	int	error;
 	int	wait;
 	
 	/*
@@ -3806,6 +4079,14 @@ ahc_reset(struct ahc_softc *ahc)
 	 * to disturb the integrity of the bus.
 	 */
 	ahc_pause(ahc);
+	if ((ahc_inb(ahc, HCNTRL) & CHIPRST) != 0) {
+		/*
+		 * The chip has not been initialized since
+		 * PCI/EISA/VLB bus reset.  Don't trust
+		 * "left over BIOS data".
+		 */
+		ahc->flags |= AHC_NO_BIOS_INIT;
+	}
 	sxfrctl1_b = 0;
 	if ((ahc->chip & AHC_CHIPID_MASK) == AHC_AIC7770) {
 		u_int sblkctl;
@@ -3821,7 +4102,7 @@ ahc_reset(struct ahc_softc *ahc)
 	}
 	sxfrctl1_a = ahc_inb(ahc, SXFRCTL1);
 
-	ahc_outb_reset(ahc, HCNTRL, CHIPRST | ahc->pause);
+	ahc_outb(ahc, HCNTRL, CHIPRST | ahc->pause);
 
 	/*
 	 * Ensure that the reset has finished.  We delay 1000us
@@ -3880,12 +4161,19 @@ ahc_reset(struct ahc_softc *ahc)
 	}
 	ahc_outb(ahc, SXFRCTL1, sxfrctl1_a);
 
+	error = 0;
+	if (reinit != 0)
+		/*
+		 * If a recovery action has forced a chip reset,
+		 * re-initialize the chip to our liking.
+		 */
+		error = ahc->bus_chip_init(ahc);
 #ifdef AHC_DUMP_SEQ
-	if (ahc->init_level == 0)
+	else 
 		ahc_dumpseq(ahc);
 #endif
 
-	return (0);
+	return (error);
 }
 
 /*
@@ -3955,6 +4243,14 @@ ahc_build_free_scb_list(struct ahc_softc
 		ahc_outb(ahc, SCB_LUN, 0xFF);
 	}
 
+	if ((ahc->flags & AHC_PAGESCBS) != 0) {
+		/* SCB 0 heads the free list. */
+		ahc_outb(ahc, FREE_SCBH, 0);
+	} else {
+		/* No free list. */
+		ahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);
+	}
+
 	/* Make sure that the last SCB terminates the free list */
 	ahc_outb(ahc, SCBPTR, i-1);
 	ahc_outb(ahc, SCB_NEXT, SCB_LIST_NULL);
@@ -3980,20 +4276,11 @@ ahc_init_scbdata(struct ahc_softc *ahc)
 	/* Determine the number of hardware SCBs and initialize them */
 
 	scb_data->maxhscbs = ahc_probe_scbs(ahc);
-	if ((ahc->flags & AHC_PAGESCBS) != 0) {
-		/* SCB 0 heads the free list */
-		ahc_outb(ahc, FREE_SCBH, 0);
-	} else {
-		ahc_outb(ahc, FREE_SCBH, SCB_LIST_NULL);
-	}
-
 	if (ahc->scb_data->maxhscbs == 0) {
 		printf("%s: No SCB space found\n", ahc_name(ahc));
 		return (ENXIO);
 	}
 
-	ahc_build_free_scb_list(ahc);
-
 	/*
 	 * Create our DMA tags.  These tags define the kinds of device
 	 * accessible memory allocations and memory mappings we will
@@ -4069,7 +4356,7 @@ ahc_init_scbdata(struct ahc_softc *ahc)
 	scb_data->init_level++;
 
 	/* DMA tag for our S/G structures.  We allocate in page sized chunks */
-	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
+	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/8,
 			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
 			       /*lowaddr*/BUS_SPACE_MAXADDR_32BIT,
 			       /*highaddr*/BUS_SPACE_MAXADDR,
@@ -4095,10 +4382,9 @@ ahc_init_scbdata(struct ahc_softc *ahc)
 	}
 
 	/*
-	 * Tell the sequencer which SCB will be the next one it receives.
+	 * Reserve the next queued SCB.
 	 */
 	ahc->next_queued_scb = ahc_get_scb(ahc);
-	ahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);
 
 	/*
 	 * Note that we were successfull
@@ -4283,60 +4569,242 @@ ahc_controller_info(struct ahc_softc *ah
 		sprintf(buf, "%d SCBs", ahc->scb_data->maxhscbs);
 }
 
-/*
- * Start the board, ready for normal operation
- */
 int
-ahc_init(struct ahc_softc *ahc)
+ahc_chip_init(struct ahc_softc *ahc)
 {
-	int	 max_targ;
-	int	 i;
 	int	 term;
+	int	 error;
+	u_int	 i;
 	u_int	 scsi_conf;
 	u_int	 scsiseq_template;
-	u_int	 ultraenb;
-	u_int	 discenable;
-	u_int	 tagenable;
-	size_t	 driver_data_size;
 	uint32_t physaddr;
 
-#ifdef AHC_DEBUG_SEQUENCER
-	ahc->flags |= AHC_SEQUENCER_DEBUG;
-#endif
+	ahc_outb(ahc, SEQ_FLAGS, 0);
+	ahc_outb(ahc, SEQ_FLAGS2, 0);
 
-#ifdef AHC_PRINT_SRAM
-	printf("Scratch Ram:");
-	for (i = 0x20; i < 0x5f; i++) {
-		if (((i % 8) == 0) && (i != 0)) {
-			printf ("\n              ");
-		}
-		printf (" 0x%x", ahc_inb(ahc, i));
-	}
-	if ((ahc->features & AHC_MORE_SRAM) != 0) {
-		for (i = 0x70; i < 0x7f; i++) {
-			if (((i % 8) == 0) && (i != 0)) {
-				printf ("\n              ");
-			}
-			printf (" 0x%x", ahc_inb(ahc, i));
-		}
-	}
-	printf ("\n");
-	/*
-	 * Reading uninitialized scratch ram may
-	 * generate parity errors.
-	 */
-	ahc_outb(ahc, CLRINT, CLRPARERR);
-	ahc_outb(ahc, CLRINT, CLRBRKADRINT);
-#endif
-	max_targ = 15;
+	/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels*/
+	if (ahc->features & AHC_TWIN) {
+
+		/*
+		 * Setup Channel B first.
+		 */
+		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
+		term = (ahc->flags & AHC_TERM_ENB_B) != 0 ? STPWEN : 0;
+		ahc_outb(ahc, SCSIID, ahc->our_id_b);
+		scsi_conf = ahc_inb(ahc, SCSICONF + 1);
+		ahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))
+					|term|ahc->seltime_b|ENSTIMER|ACTNEGEN);
+		if ((ahc->features & AHC_ULTRA2) != 0)
+			ahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);
+		ahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);
+		ahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);
+
+		/* Select Channel A */
+		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
+	}
+	term = (ahc->flags & AHC_TERM_ENB_A) != 0 ? STPWEN : 0;
+	if ((ahc->features & AHC_ULTRA2) != 0)
+		ahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);
+	else
+		ahc_outb(ahc, SCSIID, ahc->our_id);
+	scsi_conf = ahc_inb(ahc, SCSICONF);
+	ahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))
+				|term|ahc->seltime
+				|ENSTIMER|ACTNEGEN);
+	if ((ahc->features & AHC_ULTRA2) != 0)
+		ahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);
+	ahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);
+	ahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);
+
+	/* There are no untagged SCBs active yet. */
+	for (i = 0; i < 16; i++) {
+		ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, 0));
+		if ((ahc->flags & AHC_SCB_BTT) != 0) {
+			int lun;
+
+			/*
+			 * The SCB based BTT allows an entry per
+			 * target and lun pair.
+			 */
+			for (lun = 1; lun < AHC_NUM_LUNS; lun++)
+				ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, lun));
+		}
+	}
+
+	/* All of our queues are empty */
+	for (i = 0; i < 256; i++)
+		ahc->qoutfifo[i] = SCB_LIST_NULL;
+	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_PREREAD);
+
+	for (i = 0; i < 256; i++)
+		ahc->qinfifo[i] = SCB_LIST_NULL;
+
+	if ((ahc->features & AHC_MULTI_TID) != 0) {
+		ahc_outb(ahc, TARGID, 0);
+		ahc_outb(ahc, TARGID + 1, 0);
+	}
 
 	/*
-	 * Assume we have a board at this stage and it has been reset.
-	 */
-	if ((ahc->flags & AHC_USEDEFAULTS) != 0)
-		ahc->our_id = ahc->our_id_b = 7;
-	
-	/*
+	 * Tell the sequencer where it can find our arrays in memory.
+	 */
+	physaddr = ahc->scb_data->hscb_busaddr;
+	ahc_outb(ahc, HSCB_ADDR, physaddr & 0xFF);
+	ahc_outb(ahc, HSCB_ADDR + 1, (physaddr >> 8) & 0xFF);
+	ahc_outb(ahc, HSCB_ADDR + 2, (physaddr >> 16) & 0xFF);
+	ahc_outb(ahc, HSCB_ADDR + 3, (physaddr >> 24) & 0xFF);
+
+	physaddr = ahc->shared_data_busaddr;
+	ahc_outb(ahc, SHARED_DATA_ADDR, physaddr & 0xFF);
+	ahc_outb(ahc, SHARED_DATA_ADDR + 1, (physaddr >> 8) & 0xFF);
+	ahc_outb(ahc, SHARED_DATA_ADDR + 2, (physaddr >> 16) & 0xFF);
+	ahc_outb(ahc, SHARED_DATA_ADDR + 3, (physaddr >> 24) & 0xFF);
+
+	/*
+	 * Initialize the group code to command length table.
+	 * This overrides the values in TARG_SCSIRATE, so only
+	 * setup the table after we have processed that information.
+	 */
+	ahc_outb(ahc, CMDSIZE_TABLE, 5);
+	ahc_outb(ahc, CMDSIZE_TABLE + 1, 9);
+	ahc_outb(ahc, CMDSIZE_TABLE + 2, 9);
+	ahc_outb(ahc, CMDSIZE_TABLE + 3, 0);
+	ahc_outb(ahc, CMDSIZE_TABLE + 4, 15);
+	ahc_outb(ahc, CMDSIZE_TABLE + 5, 11);
+	ahc_outb(ahc, CMDSIZE_TABLE + 6, 0);
+	ahc_outb(ahc, CMDSIZE_TABLE + 7, 0);
+		
+	if ((ahc->features & AHC_HS_MAILBOX) != 0)
+		ahc_outb(ahc, HS_MAILBOX, 0);
+
+	/* Tell the sequencer of our initial queue positions */
+	if ((ahc->features & AHC_TARGETMODE) != 0) {
+		ahc->tqinfifonext = 1;
+		ahc_outb(ahc, KERNEL_TQINPOS, ahc->tqinfifonext - 1);
+		ahc_outb(ahc, TQINPOS, ahc->tqinfifonext);
+	}
+	ahc->qinfifonext = 0;
+	ahc->qoutfifonext = 0;
+	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
+		ahc_outb(ahc, QOFF_CTLSTA, SCB_QSIZE_256);
+		ahc_outb(ahc, HNSCB_QOFF, ahc->qinfifonext);
+		ahc_outb(ahc, SNSCB_QOFF, ahc->qinfifonext);
+		ahc_outb(ahc, SDSCB_QOFF, 0);
+	} else {
+		ahc_outb(ahc, KERNEL_QINPOS, ahc->qinfifonext);
+		ahc_outb(ahc, QINPOS, ahc->qinfifonext);
+		ahc_outb(ahc, QOUTPOS, ahc->qoutfifonext);
+	}
+
+	/* We don't have any waiting selections */
+	ahc_outb(ahc, WAITING_SCBH, SCB_LIST_NULL);
+
+	/* Our disconnection list is empty too */
+	ahc_outb(ahc, DISCONNECTED_SCBH, SCB_LIST_NULL);
+
+	/* Message out buffer starts empty */
+	ahc_outb(ahc, MSG_OUT, MSG_NOOP);
+
+	/*
+	 * Setup the allowed SCSI Sequences based on operational mode.
+	 * If we are a target, we'll enalbe select in operations once
+	 * we've had a lun enabled.
+	 */
+	scsiseq_template = ENSELO|ENAUTOATNO|ENAUTOATNP;
+	if ((ahc->flags & AHC_INITIATORROLE) != 0)
+		scsiseq_template |= ENRSELI;
+	ahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq_template);
+
+	/* Initialize our list of free SCBs. */
+	ahc_build_free_scb_list(ahc);
+
+	/*
+	 * Tell the sequencer which SCB will be the next one it receives.
+	 */
+	ahc_outb(ahc, NEXT_QUEUED_SCB, ahc->next_queued_scb->hscb->tag);
+
+	/*
+	 * Load the Sequencer program and Enable the adapter
+	 * in "fast" mode.
+	 */
+	if (bootverbose)
+		printf("%s: Downloading Sequencer Program...",
+		       ahc_name(ahc));
+
+	error = ahc_loadseq(ahc);
+	if (error != 0)
+		return (error);
+
+	if ((ahc->features & AHC_ULTRA2) != 0) {
+		int wait;
+
+		/*
+		 * Wait for up to 500ms for our transceivers
+		 * to settle.  If the adapter does not have
+		 * a cable attached, the transceivers may
+		 * never settle, so don't complain if we
+		 * fail here.
+		 */
+		for (wait = 5000;
+		     (ahc_inb(ahc, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;
+		     wait--)
+			ahc_delay(100);
+	}
+	ahc_restart(ahc);
+	return (0);
+}
+
+/*
+ * Start the board, ready for normal operation
+ */
+int
+ahc_init(struct ahc_softc *ahc)
+{
+	int	 max_targ;
+	u_int	 i;
+	u_int	 scsi_conf;
+	u_int	 ultraenb;
+	u_int	 discenable;
+	u_int	 tagenable;
+	size_t	 driver_data_size;
+
+#ifdef AHC_DEBUG
+	if ((ahc_debug & AHC_DEBUG_SEQUENCER) != 0)
+		ahc->flags |= AHC_SEQUENCER_DEBUG;
+#endif
+
+#ifdef AHC_PRINT_SRAM
+	printf("Scratch Ram:");
+	for (i = 0x20; i < 0x5f; i++) {
+		if (((i % 8) == 0) && (i != 0)) {
+			printf ("\n              ");
+		}
+		printf (" 0x%x", ahc_inb(ahc, i));
+	}
+	if ((ahc->features & AHC_MORE_SRAM) != 0) {
+		for (i = 0x70; i < 0x7f; i++) {
+			if (((i % 8) == 0) && (i != 0)) {
+				printf ("\n              ");
+			}
+			printf (" 0x%x", ahc_inb(ahc, i));
+		}
+	}
+	printf ("\n");
+	/*
+	 * Reading uninitialized scratch ram may
+	 * generate parity errors.
+	 */
+	ahc_outb(ahc, CLRINT, CLRPARERR);
+	ahc_outb(ahc, CLRINT, CLRBRKADRINT);
+#endif
+	max_targ = 15;
+
+	/*
+	 * Assume we have a board at this stage and it has been reset.
+	 */
+	if ((ahc->flags & AHC_USEDEFAULTS) != 0)
+		ahc->our_id = ahc->our_id_b = 7;
+	
+	/*
 	 * Default to allowing initiator operations.
 	 */
 	ahc->flags |= AHC_INITIATORROLE;
@@ -4351,10 +4819,13 @@ ahc_init(struct ahc_softc *ahc)
 	/* DMA tag for mapping buffers into device visible space. */
 	if (ahc_dma_tag_create(ahc, ahc->parent_dmat, /*alignment*/1,
 			       /*boundary*/BUS_SPACE_MAXADDR_32BIT + 1,
-			       /*lowaddr*/BUS_SPACE_MAXADDR,
+			       /*lowaddr*/ahc->flags & AHC_39BIT_ADDRESSING
+					? (bus_addr_t)0x7FFFFFFFFFULL
+					: BUS_SPACE_MAXADDR_32BIT,
 			       /*highaddr*/BUS_SPACE_MAXADDR,
 			       /*filter*/NULL, /*filterarg*/NULL,
-			       /*maxsize*/MAXBSIZE, /*nsegments*/AHC_NSEG,
+			       /*maxsize*/(AHC_NSEG - 1) * PAGE_SIZE,
+			       /*nsegments*/AHC_NSEG,
 			       /*maxsegsz*/AHC_MAXTRANSFER_SIZE,
 			       /*flags*/BUS_DMA_ALLOCNOW,
 			       &ahc->buffer_dmat) != 0) {
@@ -4414,9 +4885,6 @@ ahc_init(struct ahc_softc *ahc)
 		for (i = 0; i < AHC_TMODE_CMDS; i++)
 			ahc->targetcmds[i].cmd_valid = 0;
 		ahc_sync_tqinfifo(ahc, BUS_DMASYNC_PREREAD);
-		ahc->tqinfifonext = 1;
-		ahc_outb(ahc, KERNEL_TQINPOS, ahc->tqinfifonext - 1);
-		ahc_outb(ahc, TQINPOS, ahc->tqinfifonext);
 		ahc->qoutfifo = (uint8_t *)&ahc->targetcmds[256];
 	}
 	ahc->qinfifo = &ahc->qoutfifo[256];
@@ -4447,9 +4915,6 @@ ahc_init(struct ahc_softc *ahc)
 		}
 	}
 
-	ahc_outb(ahc, SEQ_FLAGS, 0);
-	ahc_outb(ahc, SEQ_FLAGS2, 0);
-
 	if (ahc->scb_data->maxhscbs < AHC_SCB_MAX_ALLOC) {
 		ahc->flags |= AHC_PAGESCBS;
 	} else {
@@ -4457,63 +4922,32 @@ ahc_init(struct ahc_softc *ahc)
 	}
 
 #ifdef AHC_DEBUG
-	if (ahc_debug & AHC_SHOWMISC) {
-		printf("%s: hardware scb %d bytes; kernel scb %d bytes; "
-		       "ahc_dma %d bytes\n",
+	if (ahc_debug & AHC_SHOW_MISC) {
+		printf("%s: hardware scb %u bytes; kernel scb %u bytes; "
+		       "ahc_dma %u bytes\n",
 			ahc_name(ahc),
-			sizeof(struct hardware_scb),
-			sizeof(struct scb),
-			sizeof(struct ahc_dma_seg));
+			(u_int)sizeof(struct hardware_scb),
+			(u_int)sizeof(struct scb),
+			(u_int)sizeof(struct ahc_dma_seg));
 	}
 #endif /* AHC_DEBUG */
 
-	/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels*/
+	/*
+	 * Look at the information that board initialization or
+	 * the board bios has left us.
+	 */
 	if (ahc->features & AHC_TWIN) {
-
-		/*
-		 * The device is gated to channel B after a chip reset,
-		 * so set those values first
-		 */
-		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
-		term = (ahc->flags & AHC_TERM_ENB_B) != 0 ? STPWEN : 0;
-		ahc_outb(ahc, SCSIID, ahc->our_id_b);
 		scsi_conf = ahc_inb(ahc, SCSICONF + 1);
-		ahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))
-					|term|ahc->seltime_b|ENSTIMER|ACTNEGEN);
-		if ((ahc->features & AHC_ULTRA2) != 0)
-			ahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);
-		ahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);
-		ahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);
-
 		if ((scsi_conf & RESET_SCSI) != 0
 		 && (ahc->flags & AHC_INITIATORROLE) != 0)
 			ahc->flags |= AHC_RESET_BUS_B;
-
-		/* Select Channel A */
-		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
 	}
-	term = (ahc->flags & AHC_TERM_ENB_A) != 0 ? STPWEN : 0;
-	if ((ahc->features & AHC_ULTRA2) != 0)
-		ahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);
-	else
-		ahc_outb(ahc, SCSIID, ahc->our_id);
-	scsi_conf = ahc_inb(ahc, SCSICONF);
-	ahc_outb(ahc, SXFRCTL1, (scsi_conf & (ENSPCHK|STIMESEL))
-				|term|ahc->seltime
-				|ENSTIMER|ACTNEGEN);
-	if ((ahc->features & AHC_ULTRA2) != 0)
-		ahc_outb(ahc, SIMODE0, ahc_inb(ahc, SIMODE0)|ENIOERR);
-	ahc_outb(ahc, SIMODE1, ENSELTIMO|ENSCSIRST|ENSCSIPERR);
-	ahc_outb(ahc, SXFRCTL0, DFON|SPIOEN);
 
+	scsi_conf = ahc_inb(ahc, SCSICONF);
 	if ((scsi_conf & RESET_SCSI) != 0
 	 && (ahc->flags & AHC_INITIATORROLE) != 0)
 		ahc->flags |= AHC_RESET_BUS_A;
 
-	/*
-	 * Look at the information that board initialization or
-	 * the board bios has left us.
-	 */
 	ultraenb = 0;	
 	tagenable = ALL_TARGETS_MASK;
 
@@ -4565,7 +4999,7 @@ ahc_init(struct ahc_softc *ahc)
 			 * connection type we have with the target.
 			 */
 			tinfo->user.period = ahc_syncrates->period;
-			tinfo->user.offset = ~0;
+			tinfo->user.offset = MAX_OFFSET;
 		} else {
 			u_int scsirate;
 			uint16_t mask;
@@ -4600,7 +5034,7 @@ ahc_init(struct ahc_softc *ahc)
 				if (offset == 0)
 					tinfo->user.period = 0;
 				else
-					tinfo->user.offset = ~0;
+					tinfo->user.offset = MAX_OFFSET;
 				if ((scsirate & SXFR_ULTRA2) <= 8/*10MHz*/
 				 && (ahc->features & AHC_DT) != 0)
 					tinfo->user.ppr_options =
@@ -4618,7 +5052,7 @@ ahc_init(struct ahc_softc *ahc)
 						   ? AHC_SYNCRATE_ULTRA
 						   : AHC_SYNCRATE_FAST);
 				if (tinfo->user.period != 0)
-					tinfo->user.offset = ~0;
+					tinfo->user.offset = MAX_OFFSET;
 			}
 			if (tinfo->user.period == 0)
 				tinfo->user.offset = 0;
@@ -4635,132 +5069,12 @@ ahc_init(struct ahc_softc *ahc)
 			tinfo->curr.protocol_version = 2;
 			tinfo->curr.transport_version = 2;
 		}
-		tstate->ultraenb = ultraenb;
+		tstate->ultraenb = 0;
 	}
 	ahc->user_discenable = discenable;
 	ahc->user_tagenable = tagenable;
 
-	/* There are no untagged SCBs active yet. */
-	for (i = 0; i < 16; i++) {
-		ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, 0));
-		if ((ahc->flags & AHC_SCB_BTT) != 0) {
-			int lun;
-
-			/*
-			 * The SCB based BTT allows an entry per
-			 * target and lun pair.
-			 */
-			for (lun = 1; lun < AHC_NUM_LUNS; lun++)
-				ahc_unbusy_tcl(ahc, BUILD_TCL(i << 4, lun));
-		}
-	}
-
-	/* All of our queues are empty */
-	for (i = 0; i < 256; i++)
-		ahc->qoutfifo[i] = SCB_LIST_NULL;
-	ahc_sync_qoutfifo(ahc, BUS_DMASYNC_PREREAD);
-
-	for (i = 0; i < 256; i++)
-		ahc->qinfifo[i] = SCB_LIST_NULL;
-
-	if ((ahc->features & AHC_MULTI_TID) != 0) {
-		ahc_outb(ahc, TARGID, 0);
-		ahc_outb(ahc, TARGID + 1, 0);
-	}
-
-	/*
-	 * Tell the sequencer where it can find our arrays in memory.
-	 */
-	physaddr = ahc->scb_data->hscb_busaddr;
-	ahc_outb(ahc, HSCB_ADDR, physaddr & 0xFF);
-	ahc_outb(ahc, HSCB_ADDR + 1, (physaddr >> 8) & 0xFF);
-	ahc_outb(ahc, HSCB_ADDR + 2, (physaddr >> 16) & 0xFF);
-	ahc_outb(ahc, HSCB_ADDR + 3, (physaddr >> 24) & 0xFF);
-
-	physaddr = ahc->shared_data_busaddr;
-	ahc_outb(ahc, SHARED_DATA_ADDR, physaddr & 0xFF);
-	ahc_outb(ahc, SHARED_DATA_ADDR + 1, (physaddr >> 8) & 0xFF);
-	ahc_outb(ahc, SHARED_DATA_ADDR + 2, (physaddr >> 16) & 0xFF);
-	ahc_outb(ahc, SHARED_DATA_ADDR + 3, (physaddr >> 24) & 0xFF);
-
-	/*
-	 * Initialize the group code to command length table.
-	 * This overrides the values in TARG_SCSIRATE, so only
-	 * setup the table after we have processed that information.
-	 */
-	ahc_outb(ahc, CMDSIZE_TABLE, 5);
-	ahc_outb(ahc, CMDSIZE_TABLE + 1, 9);
-	ahc_outb(ahc, CMDSIZE_TABLE + 2, 9);
-	ahc_outb(ahc, CMDSIZE_TABLE + 3, 0);
-	ahc_outb(ahc, CMDSIZE_TABLE + 4, 15);
-	ahc_outb(ahc, CMDSIZE_TABLE + 5, 11);
-	ahc_outb(ahc, CMDSIZE_TABLE + 6, 0);
-	ahc_outb(ahc, CMDSIZE_TABLE + 7, 0);
-		
-	/* Tell the sequencer of our initial queue positions */
-	ahc_outb(ahc, KERNEL_QINPOS, 0);
-	ahc_outb(ahc, QINPOS, 0);
-	ahc_outb(ahc, QOUTPOS, 0);
-
-	/*
-	 * Use the built in queue management registers
-	 * if they are available.
-	 */
-	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
-		ahc_outb(ahc, QOFF_CTLSTA, SCB_QSIZE_256);
-		ahc_outb(ahc, SDSCB_QOFF, 0);
-		ahc_outb(ahc, SNSCB_QOFF, 0);
-		ahc_outb(ahc, HNSCB_QOFF, 0);
-	}
-
-
-	/* We don't have any waiting selections */
-	ahc_outb(ahc, WAITING_SCBH, SCB_LIST_NULL);
-
-	/* Our disconnection list is empty too */
-	ahc_outb(ahc, DISCONNECTED_SCBH, SCB_LIST_NULL);
-
-	/* Message out buffer starts empty */
-	ahc_outb(ahc, MSG_OUT, MSG_NOOP);
-
-	/*
-	 * Setup the allowed SCSI Sequences based on operational mode.
-	 * If we are a target, we'll enalbe select in operations once
-	 * we've had a lun enabled.
-	 */
-	scsiseq_template = ENSELO|ENAUTOATNO|ENAUTOATNP;
-	if ((ahc->flags & AHC_INITIATORROLE) != 0)
-		scsiseq_template |= ENRSELI;
-	ahc_outb(ahc, SCSISEQ_TEMPLATE, scsiseq_template);
-
-	/*
-	 * Load the Sequencer program and Enable the adapter
-	 * in "fast" mode.
-	 */
-	if (bootverbose)
-		printf("%s: Downloading Sequencer Program...",
-		       ahc_name(ahc));
-
-	ahc_loadseq(ahc);
-
-	if ((ahc->features & AHC_ULTRA2) != 0) {
-		int wait;
-
-		/*
-		 * Wait for up to 500ms for our transceivers
-		 * to settle.  If the adapter does not have
-		 * a cable attached, the tranceivers may
-		 * never settle, so don't complain if we
-		 * fail here.
-		 */
-		ahc_pause(ahc);
-		for (wait = 5000;
-		     (ahc_inb(ahc, SBLKCTL) & (ENAB40|ENAB20)) == 0 && wait;
-		     wait--)
-			ahc_delay(100);
-		ahc_unpause(ahc);
-	}
-	return (0);
+	return (ahc->bus_chip_init(ahc));
 }
 
 void
@@ -4792,21 +5106,27 @@ ahc_pause_and_flushwork(struct ahc_softc
 {
 	int intstat;
 	int maxloops;
+	int paused;
 
 	maxloops = 1000;
 	ahc->flags |= AHC_ALL_INTERRUPTS;
-	intstat = 0;
+	paused = FALSE;
 	do {
+		if (paused)
+			ahc_unpause(ahc);
 		ahc_intr(ahc);
 		ahc_pause(ahc);
+		paused = TRUE;
+		ahc_outb(ahc, SCSISEQ, ahc_inb(ahc, SCSISEQ) & ~ENSELO);
 		ahc_clear_critical_section(ahc);
-		if (intstat == 0xFF && (ahc->features & AHC_REMOVABLE) != 0)
-			break;
-		maxloops--;
-	} while (((intstat = ahc_inb(ahc, INTSTAT)) & INT_PEND) && --maxloops);
+		intstat = ahc_inb(ahc, INTSTAT);
+	} while (--maxloops
+	      && (intstat != 0xFF || (ahc->features & AHC_REMOVABLE) == 0)
+	      && ((intstat & INT_PEND) != 0
+	       || (ahc_inb(ahc, SSTAT0) & (SELDO|SELINGO)) != 0));
 	if (maxloops == 0) {
 		printf("Infinite interrupt loop, INTSTAT = %x",
-		      ahc_inb(ahc, INTSTAT));
+		       ahc_inb(ahc, INTSTAT));
 	}
 	ahc_platform_flushwork(ahc);
 	ahc->flags &= ~AHC_ALL_INTERRUPTS;
@@ -4815,87 +5135,25 @@ ahc_pause_and_flushwork(struct ahc_softc
 int
 ahc_suspend(struct ahc_softc *ahc)
 {
-	uint8_t *ptr;
-	int	 i;
 
 	ahc_pause_and_flushwork(ahc);
 
-	if (LIST_FIRST(&ahc->pending_scbs) != NULL)
+	if (LIST_FIRST(&ahc->pending_scbs) != NULL) {
+		ahc_unpause(ahc);
 		return (EBUSY);
+	}
 
-#if AHC_TARGET_MODE
+#ifdef AHC_TARGET_MODE
 	/*
 	 * XXX What about ATIOs that have not yet been serviced?
 	 * Perhaps we should just refuse to be suspended if we
 	 * are acting in a target role.
 	 */
-	if (ahc->pending_device != NULL)
+	if (ahc->pending_device != NULL) {
+		ahc_unpause(ahc);
 		return (EBUSY);
-#endif
-
-	/* Save volatile registers */
-	if ((ahc->features & AHC_TWIN) != 0) {
-		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
-		ahc->suspend_state.channel[1].scsiseq = ahc_inb(ahc, SCSISEQ);
-		ahc->suspend_state.channel[1].sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
-		ahc->suspend_state.channel[1].sxfrctl1 = ahc_inb(ahc, SXFRCTL1);
-		ahc->suspend_state.channel[1].simode0 = ahc_inb(ahc, SIMODE0);
-		ahc->suspend_state.channel[1].simode1 = ahc_inb(ahc, SIMODE1);
-		ahc->suspend_state.channel[1].seltimer = ahc_inb(ahc, SELTIMER);
-		ahc->suspend_state.channel[1].seqctl = ahc_inb(ahc, SEQCTL);
-		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
-	}
-	ahc->suspend_state.channel[0].scsiseq = ahc_inb(ahc, SCSISEQ);
-	ahc->suspend_state.channel[0].sxfrctl0 = ahc_inb(ahc, SXFRCTL0);
-	ahc->suspend_state.channel[0].sxfrctl1 = ahc_inb(ahc, SXFRCTL1);
-	ahc->suspend_state.channel[0].simode0 = ahc_inb(ahc, SIMODE0);
-	ahc->suspend_state.channel[0].simode1 = ahc_inb(ahc, SIMODE1);
-	ahc->suspend_state.channel[0].seltimer = ahc_inb(ahc, SELTIMER);
-	ahc->suspend_state.channel[0].seqctl = ahc_inb(ahc, SEQCTL);
-
-	if ((ahc->chip & AHC_PCI) != 0) {
-		ahc->suspend_state.dscommand0 = ahc_inb(ahc, DSCOMMAND0);
-		ahc->suspend_state.dspcistatus = ahc_inb(ahc, DSPCISTATUS);
-	}
-
-	if ((ahc->features & AHC_DT) != 0) {
-		u_int sfunct;
-
-		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
-		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
-		ahc->suspend_state.optionmode = ahc_inb(ahc, OPTIONMODE);
-		ahc_outb(ahc, SFUNCT, sfunct);
-		ahc->suspend_state.crccontrol1 = ahc_inb(ahc, CRCCONTROL1);
-	}
-
-	if ((ahc->features & AHC_MULTI_FUNC) != 0)
-		ahc->suspend_state.scbbaddr = ahc_inb(ahc, SCBBADDR);
-
-	if ((ahc->features & AHC_ULTRA2) != 0)
-		ahc->suspend_state.dff_thrsh = ahc_inb(ahc, DFF_THRSH);
-
-	ptr = ahc->suspend_state.scratch_ram;
-	for (i = 0; i < 64; i++)
-		*ptr++ = ahc_inb(ahc, SRAM_BASE + i);
-
-	if ((ahc->features & AHC_MORE_SRAM) != 0) {
-		for (i = 0; i < 16; i++)
-			*ptr++ = ahc_inb(ahc, TARG_OFFSET + i);
-	}
-
-	ptr = ahc->suspend_state.btt;
-	if ((ahc->flags & AHC_SCB_BTT) != 0) {
-		for (i = 0;i < AHC_NUM_TARGETS; i++) {
-			int j;
-
-			for (j = 0;j < AHC_NUM_LUNS; j++) {
-				u_int tcl;
-
-				tcl = BUILD_TCL(i << 4, j);
-				*ptr = ahc_index_busy_tcl(ahc, tcl);
-			}
-		}
 	}
+#endif
 	ahc_shutdown(ahc);
 	return (0);
 }
@@ -4903,81 +5161,10 @@ ahc_suspend(struct ahc_softc *ahc)
 int
 ahc_resume(struct ahc_softc *ahc)
 {
-	uint8_t *ptr;
-	int	 i;
-
-	ahc_reset(ahc);
-
-	ahc_build_free_scb_list(ahc);
-
-	/* Restore volatile registers */
-	if ((ahc->features & AHC_TWIN) != 0) {
-		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) | SELBUSB);
-		ahc_outb(ahc, SCSIID, ahc->our_id);
-		ahc_outb(ahc, SCSISEQ, ahc->suspend_state.channel[1].scsiseq);
-		ahc_outb(ahc, SXFRCTL0, ahc->suspend_state.channel[1].sxfrctl0);
-		ahc_outb(ahc, SXFRCTL1, ahc->suspend_state.channel[1].sxfrctl1);
-		ahc_outb(ahc, SIMODE0, ahc->suspend_state.channel[1].simode0);
-		ahc_outb(ahc, SIMODE1, ahc->suspend_state.channel[1].simode1);
-		ahc_outb(ahc, SELTIMER, ahc->suspend_state.channel[1].seltimer);
-		ahc_outb(ahc, SEQCTL, ahc->suspend_state.channel[1].seqctl);
-		ahc_outb(ahc, SBLKCTL, ahc_inb(ahc, SBLKCTL) & ~SELBUSB);
-	}
-	ahc_outb(ahc, SCSISEQ, ahc->suspend_state.channel[0].scsiseq);
-	ahc_outb(ahc, SXFRCTL0, ahc->suspend_state.channel[0].sxfrctl0);
-	ahc_outb(ahc, SXFRCTL1, ahc->suspend_state.channel[0].sxfrctl1);
-	ahc_outb(ahc, SIMODE0, ahc->suspend_state.channel[0].simode0);
-	ahc_outb(ahc, SIMODE1, ahc->suspend_state.channel[0].simode1);
-	ahc_outb(ahc, SELTIMER, ahc->suspend_state.channel[0].seltimer);
-	ahc_outb(ahc, SEQCTL, ahc->suspend_state.channel[0].seqctl);
-	if ((ahc->features & AHC_ULTRA2) != 0)
-		ahc_outb(ahc, SCSIID_ULTRA2, ahc->our_id);
-	else
-		ahc_outb(ahc, SCSIID, ahc->our_id);
-
-	if ((ahc->chip & AHC_PCI) != 0) {
-		ahc_outb(ahc, DSCOMMAND0, ahc->suspend_state.dscommand0);
-		ahc_outb(ahc, DSPCISTATUS, ahc->suspend_state.dspcistatus);
-	}
-
-	if ((ahc->features & AHC_DT) != 0) {
-		u_int sfunct;
 
-		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
-		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
-		ahc_outb(ahc, OPTIONMODE, ahc->suspend_state.optionmode);
-		ahc_outb(ahc, SFUNCT, sfunct);
-		ahc_outb(ahc, CRCCONTROL1, ahc->suspend_state.crccontrol1);
-	}
-
-	if ((ahc->features & AHC_MULTI_FUNC) != 0)
-		ahc_outb(ahc, SCBBADDR, ahc->suspend_state.scbbaddr);
-
-	if ((ahc->features & AHC_ULTRA2) != 0)
-		ahc_outb(ahc, DFF_THRSH, ahc->suspend_state.dff_thrsh);
-
-	ptr = ahc->suspend_state.scratch_ram;
-	for (i = 0; i < 64; i++)
-		ahc_outb(ahc, SRAM_BASE + i, *ptr++);
-
-	if ((ahc->features & AHC_MORE_SRAM) != 0) {
-		for (i = 0; i < 16; i++)
-			ahc_outb(ahc, TARG_OFFSET + i, *ptr++);
-	}
-
-	ptr = ahc->suspend_state.btt;
-	if ((ahc->flags & AHC_SCB_BTT) != 0) {
-		for (i = 0;i < AHC_NUM_TARGETS; i++) {
-			int j;
-
-			for (j = 0;j < AHC_NUM_LUNS; j++) {
-				u_int tcl;
-
-				tcl = BUILD_TCL(i << 4, j);
-				ahc_busy_tcl(ahc, tcl, *ptr);
-			}
-		}
-	}
+	ahc_reset(ahc, /*reinit*/TRUE);
+	ahc_intr_enable(ahc, TRUE); 
+	ahc_restart(ahc);
 	return (0);
 }
 
@@ -5059,7 +5246,7 @@ ahc_match_scb(struct ahc_softc *ahc, str
 	if (match != 0)
 		match = ((lun == slun) || (lun == CAM_LUN_WILDCARD));
 	if (match != 0) {
-#if AHC_TARGET_MODE
+#ifdef AHC_TARGET_MODE
 		int group;
 
 		group = XPT_FC_GROUP(scb->io_ctx->ccb_h.func_code);
@@ -5139,8 +5326,8 @@ ahc_qinfifo_requeue(struct ahc_softc *ah
 static int
 ahc_qinfifo_count(struct ahc_softc *ahc)
 {
-	u_int8_t qinpos;
-	u_int8_t diff;
+	uint8_t qinpos;
+	uint8_t diff;
 
 	if ((ahc->features & AHC_QUEUE_REGS) != 0) {
 		qinpos = ahc_inb(ahc, SNSCB_QOFF);
@@ -5444,6 +5631,7 @@ ahc_search_untagged_queues(struct ahc_so
 				break;
 			}
 			case SEARCH_REMOVE:
+				scb->flags &= ~SCB_UNTAGGEDQ;
 				TAILQ_REMOVE(untagged_q, scb, links.tqe);
 				break;
 			case SEARCH_COUNT:
@@ -5801,7 +5989,7 @@ ahc_reset_channel(struct ahc_softc *ahc,
 	 * before the reset occurred.
 	 */
 	ahc_run_qoutfifo(ahc);
-#if AHC_TARGET_MODE
+#ifdef AHC_TARGET_MODE
 	/*
 	 * XXX - In Twin mode, the tqinfifo may have commands
 	 *	 for an unaffected channel in it.  However, if
@@ -5833,7 +6021,7 @@ ahc_reset_channel(struct ahc_softc *ahc,
 		 */
 		ahc_outb(ahc, SBLKCTL, sblkctl ^ SELBUSB);
 		simode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);
-#if AHC_TARGET_MODE
+#ifdef AHC_TARGET_MODE
 		/*
 		 * Bus resets clear ENSELI, so we cannot
 		 * defer re-enabling bus reset interrupts
@@ -5852,7 +6040,7 @@ ahc_reset_channel(struct ahc_softc *ahc,
 	} else {
 		/* Case 2: A command from this bus is active or we're idle */
 		simode1 = ahc_inb(ahc, SIMODE1) & ~(ENBUSFREE|ENSCSIRST);
-#if AHC_TARGET_MODE
+#ifdef AHC_TARGET_MODE
 		/*
 		 * Bus resets clear ENSELI, so we cannot
 		 * defer re-enabling bus reset interrupts
@@ -6017,9 +6205,10 @@ ahc_calc_residual(struct ahc_softc *ahc,
 		ahc_set_sense_residual(scb, resid);
 
 #ifdef AHC_DEBUG
-	if ((ahc_debug & AHC_SHOWMISC) != 0) {
+	if ((ahc_debug & AHC_SHOW_MISC) != 0) {
 		ahc_print_path(ahc, scb);
-		printf("Handled Residual of %d bytes\n", resid);
+		printf("Handled %sResidual of %d bytes\n",
+		       (scb->flags & SCB_SENSE) ? "Sense " : "", resid);
 	}
 #endif
 }
@@ -6120,19 +6309,11 @@ void
 ahc_dumpseq(struct ahc_softc* ahc)
 {
 	int i;
-	int max_prog;
-
-	if ((ahc->chip & AHC_BUS_MASK) < AHC_PCI)
-		max_prog = 448;
-	else if ((ahc->features & AHC_ULTRA2) != 0)
-		max_prog = 768;
-	else
-		max_prog = 512;
 
 	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE|LOADRAM);
 	ahc_outb(ahc, SEQADDR0, 0);
 	ahc_outb(ahc, SEQADDR1, 0);
-	for (i = 0; i < max_prog; i++) {
+	for (i = 0; i < ahc->instruction_ram_size; i++) {
 		uint8_t ins_bytes[4];
 
 		ahc_insb(ahc, SEQRAM, ins_bytes, 4);
@@ -6144,7 +6325,7 @@ ahc_dumpseq(struct ahc_softc* ahc)
 }
 #endif
 
-static void
+static int
 ahc_loadseq(struct ahc_softc *ahc)
 {
 	struct	cs cs_table[num_critical_sections];
@@ -6154,9 +6335,9 @@ ahc_loadseq(struct ahc_softc *ahc)
 	u_int	cs_count;
 	u_int	cur_cs;
 	u_int	i;
-	int	downloaded;
 	u_int	skip_addr;
 	u_int	sg_prefetch_cnt;
+	int	downloaded;
 	uint8_t	download_consts[7];
 
 	/*
@@ -6197,6 +6378,19 @@ ahc_loadseq(struct ahc_softc *ahc)
 			 */
 			continue;
 		}
+
+		if (downloaded == ahc->instruction_ram_size) {
+			/*
+			 * We're about to exceed the instruction
+			 * storage capacity for this chip.  Fail
+			 * the load.
+			 */
+			printf("\n%s: Program too large for instruction memory "
+			       "size of %d!\n", ahc_name(ahc),
+			       ahc->instruction_ram_size);
+			return (ENOMEM);
+		}
+
 		/*
 		 * Move through the CS table until we find a CS
 		 * that might apply to this instruction.
@@ -6232,10 +6426,13 @@ ahc_loadseq(struct ahc_softc *ahc)
 		memcpy(ahc->critical_sections, cs_table, cs_count);
 	}
 	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS|FASTMODE);
-	ahc_restart(ahc);
 
-	if (bootverbose)
+	if (bootverbose) {
 		printf(" %d instructions downloaded\n", downloaded);
+		printf("%s: Features 0x%x, Bugs 0x%x, Flags 0x%x\n",
+		       ahc_name(ahc), ahc->features, ahc->bugs, ahc->flags);
+	}
+	return (0);
 }
 
 static int
@@ -6399,14 +6596,64 @@ ahc_download_instr(struct ahc_softc *ahc
 	}
 }
 
+int
+ahc_print_register(ahc_reg_parse_entry_t *table, u_int num_entries,
+		   const char *name, u_int address, u_int value,
+		   u_int *cur_column, u_int wrap_point)
+{
+	int	printed;
+	u_int	printed_mask;
+
+	if (cur_column != NULL && *cur_column >= wrap_point) {
+		printf("\n");
+		*cur_column = 0;
+	}
+	printed = printf("%s[0x%x]", name, value);
+	if (table == NULL) {
+		printed += printf(" ");
+		*cur_column += printed;
+		return (printed);
+	}
+	printed_mask = 0;
+	while (printed_mask != 0xFF) {
+		int entry;
+
+		for (entry = 0; entry < num_entries; entry++) {
+			if (((value & table[entry].mask)
+			  != table[entry].value)
+			 || ((printed_mask & table[entry].mask)
+			  == table[entry].mask))
+				continue;
+
+			printed += printf("%s%s",
+					  printed_mask == 0 ? ":(" : "|",
+					  table[entry].name);
+			printed_mask |= table[entry].mask;
+			
+			break;
+		}
+		if (entry >= num_entries)
+			break;
+	}
+	if (printed_mask != 0)
+		printed += printf(") ");
+	else
+		printed += printf(" ");
+	if (cur_column != NULL)
+		*cur_column += printed;
+	return (printed);
+}
+
 void
 ahc_dump_card_state(struct ahc_softc *ahc)
 {
-	struct scb *scb;
-	struct scb_tailq *untagged_q;
-	int target;
-	int maxtarget;
-	int i;
+	struct	scb *scb;
+	struct	scb_tailq *untagged_q;
+	u_int	cur_col;
+	int	paused;
+	int	target;
+	int	maxtarget;
+	int	i;
 	uint8_t last_phase;
 	uint8_t qinpos;
 	uint8_t qintail;
@@ -6414,33 +6661,53 @@ ahc_dump_card_state(struct ahc_softc *ah
 	uint8_t scb_index;
 	uint8_t saved_scbptr;
 
-	saved_scbptr = ahc_inb(ahc, SCBPTR);
+	if (ahc_is_paused(ahc)) {
+		paused = 1;
+	} else {
+		paused = 0;
+		ahc_pause(ahc);
+	}
 
+	saved_scbptr = ahc_inb(ahc, SCBPTR);
 	last_phase = ahc_inb(ahc, LASTPHASE);
-	printf("%s: Dumping Card State %s, at SEQADDR 0x%x\n",
+	printf(">>>>>>>>>>>>>>>>>> Dump Card State Begins <<<<<<<<<<<<<<<<<\n"
+	       "%s: Dumping Card State %s, at SEQADDR 0x%x\n",
 	       ahc_name(ahc), ahc_lookup_phase_entry(last_phase)->phasemsg,
 	       ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));
+	if (paused)
+		printf("Card was paused\n");
 	printf("ACCUM = 0x%x, SINDEX = 0x%x, DINDEX = 0x%x, ARG_2 = 0x%x\n",
 	       ahc_inb(ahc, ACCUM), ahc_inb(ahc, SINDEX), ahc_inb(ahc, DINDEX),
 	       ahc_inb(ahc, ARG_2));
 	printf("HCNT = 0x%x SCBPTR = 0x%x\n", ahc_inb(ahc, HCNT),
 	       ahc_inb(ahc, SCBPTR));
-	printf("SCSISEQ = 0x%x, SBLKCTL = 0x%x\n",
-	       ahc_inb(ahc, SCSISEQ), ahc_inb(ahc, SBLKCTL));
-	printf(" DFCNTRL = 0x%x, DFSTATUS = 0x%x\n",
-	       ahc_inb(ahc, DFCNTRL), ahc_inb(ahc, DFSTATUS));
-	printf("LASTPHASE = 0x%x, SCSISIGI = 0x%x, SXFRCTL0 = 0x%x\n",
-	       last_phase, ahc_inb(ahc, SCSISIGI), ahc_inb(ahc, SXFRCTL0));
-	printf("SSTAT0 = 0x%x, SSTAT1 = 0x%x\n",
-	       ahc_inb(ahc, SSTAT0), ahc_inb(ahc, SSTAT1));
+	cur_col = 0;
 	if ((ahc->features & AHC_DT) != 0)
-		printf("SCSIPHASE = 0x%x\n", ahc_inb(ahc, SCSIPHASE));
-	printf("STACK == 0x%x, 0x%x, 0x%x, 0x%x\n",
-		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
-		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
-		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8),
-		ahc_inb(ahc, STACK) | (ahc_inb(ahc, STACK) << 8));
-	printf("SCB count = %d\n", ahc->scb_data->numscbs);
+		ahc_scsiphase_print(ahc_inb(ahc, SCSIPHASE), &cur_col, 50);
+	ahc_scsisigi_print(ahc_inb(ahc, SCSISIGI), &cur_col, 50);
+	ahc_error_print(ahc_inb(ahc, ERROR), &cur_col, 50);
+	ahc_scsibusl_print(ahc_inb(ahc, SCSIBUSL), &cur_col, 50);
+	ahc_lastphase_print(ahc_inb(ahc, LASTPHASE), &cur_col, 50);
+	ahc_scsiseq_print(ahc_inb(ahc, SCSISEQ), &cur_col, 50);
+	ahc_sblkctl_print(ahc_inb(ahc, SBLKCTL), &cur_col, 50);
+	ahc_scsirate_print(ahc_inb(ahc, SCSIRATE), &cur_col, 50);
+	ahc_seqctl_print(ahc_inb(ahc, SEQCTL), &cur_col, 50);
+	ahc_seq_flags_print(ahc_inb(ahc, SEQ_FLAGS), &cur_col, 50);
+	ahc_sstat0_print(ahc_inb(ahc, SSTAT0), &cur_col, 50);
+	ahc_sstat1_print(ahc_inb(ahc, SSTAT1), &cur_col, 50);
+	ahc_sstat2_print(ahc_inb(ahc, SSTAT2), &cur_col, 50);
+	ahc_sstat3_print(ahc_inb(ahc, SSTAT3), &cur_col, 50);
+	ahc_simode0_print(ahc_inb(ahc, SIMODE0), &cur_col, 50);
+	ahc_simode1_print(ahc_inb(ahc, SIMODE1), &cur_col, 50);
+	ahc_sxfrctl0_print(ahc_inb(ahc, SXFRCTL0), &cur_col, 50);
+	ahc_dfcntrl_print(ahc_inb(ahc, DFCNTRL), &cur_col, 50);
+	ahc_dfstatus_print(ahc_inb(ahc, DFSTATUS), &cur_col, 50);
+	if (cur_col != 0)
+		printf("\n");
+	printf("STACK:");
+	for (i = 0; i < STACK_SIZE; i++)
+	       printf(" 0x%x", ahc_inb(ahc, STACK)|(ahc_inb(ahc, STACK) << 8));
+	printf("\nSCB count = %d\n", ahc->scb_data->numscbs);
 	printf("Kernel NEXTQSCB = %d\n", ahc->next_queued_scb->hscb->tag);
 	printf("Card NEXTQSCB = %d\n", ahc_inb(ahc, NEXT_QUEUED_SCB));
 	/* QINFIFO */
@@ -6500,11 +6767,12 @@ ahc_dump_card_state(struct ahc_softc *ah
 	printf("Sequencer SCB Info: ");
 	for (i = 0; i < ahc->scb_data->maxhscbs; i++) {
 		ahc_outb(ahc, SCBPTR, i);
-		printf("%d(c 0x%x, s 0x%x, l %d, t 0x%x) ",
-		       i, ahc_inb(ahc, SCB_CONTROL),
-		       ahc_inb(ahc, SCB_SCSIID),
-		       ahc_inb(ahc, SCB_LUN),
-		       ahc_inb(ahc, SCB_TAG));
+		cur_col = printf("\n%3d ", i);
+
+		ahc_scb_control_print(ahc_inb(ahc, SCB_CONTROL), &cur_col, 60);
+		ahc_scb_scsiid_print(ahc_inb(ahc, SCB_SCSIID), &cur_col, 60);
+		ahc_scb_lun_print(ahc_inb(ahc, SCB_LUN), &cur_col, 60);
+		ahc_scb_tag_print(ahc_inb(ahc, SCB_TAG), &cur_col, 60);
 	}
 	printf("\n");
 
@@ -6513,14 +6781,17 @@ ahc_dump_card_state(struct ahc_softc *ah
 	LIST_FOREACH(scb, &ahc->pending_scbs, pending_links) {
 		if (i++ > 256)
 			break;
-		if (scb != LIST_FIRST(&ahc->pending_scbs))
-			printf(", ");
-		printf("%d(c 0x%x, s 0x%x, l %d)", scb->hscb->tag,
-		       scb->hscb->control, scb->hscb->scsiid, scb->hscb->lun);
+		cur_col = printf("\n%3d ", scb->hscb->tag);
+		ahc_scb_control_print(scb->hscb->control, &cur_col, 60);
+		ahc_scb_scsiid_print(scb->hscb->scsiid, &cur_col, 60);
+		ahc_scb_lun_print(scb->hscb->lun, &cur_col, 60);
 		if ((ahc->flags & AHC_PAGESCBS) == 0) {
 			ahc_outb(ahc, SCBPTR, scb->hscb->tag);
-			printf("(0x%x, 0x%x)", ahc_inb(ahc, SCB_CONTROL),
-			       ahc_inb(ahc, SCB_TAG));
+			printf("(");
+			ahc_scb_control_print(ahc_inb(ahc, SCB_CONTROL),
+					      &cur_col, 60);
+			ahc_scb_tag_print(ahc_inb(ahc, SCB_TAG), &cur_col, 60);
+			printf(")");
 		}
 	}
 	printf("\n");
@@ -6550,7 +6821,10 @@ ahc_dump_card_state(struct ahc_softc *ah
 	}
 
 	ahc_platform_dump_card_state(ahc);
+	printf("\n<<<<<<<<<<<<<<<<< Dump Card State Ends >>>>>>>>>>>>>>>>>>\n");
 	ahc_outb(ahc, SCBPTR, saved_scbptr);
+	if (paused == 0)
+		ahc_unpause(ahc);
 }
 
 /************************* Target Mode ****************************************/
@@ -6603,10 +6877,12 @@ ahc_handle_en_lun(struct ahc_softc *ahc,
 	struct	   ahc_tmode_lstate *lstate;
 	struct	   ccb_en_lun *cel;
 	cam_status status;
+	u_long	   s;
 	u_int	   target;
 	u_int	   lun;
 	u_int	   target_mask;
-	u_long	   s;
+	u_int	   our_id;
+	int	   error;
 	char	   channel;
 
 	status = ahc_find_tmode_devs(ahc, sim, ccb, &tstate, &lstate,
@@ -6617,15 +6893,33 @@ ahc_handle_en_lun(struct ahc_softc *ahc,
 		return;
 	}
 
-	if ((ahc->features & AHC_MULTIROLE) != 0) {
-		u_int	   our_id;
+	if (cam_sim_bus(sim) == 0)
+		our_id = ahc->our_id;
+	else
+		our_id = ahc->our_id_b;
 
-		if (cam_sim_bus(sim) == 0)
-			our_id = ahc->our_id;
-		else
-			our_id = ahc->our_id_b;
+	if (ccb->ccb_h.target_id != our_id) {
+		/*
+		 * our_id represents our initiator ID, or
+		 * the ID of the first target to have an
+		 * enabled lun in target mode.  There are
+		 * two cases that may preclude enabling a
+		 * target id other than our_id.
+		 *
+		 *   o our_id is for an active initiator role.
+		 *     Since the hardware does not support
+		 *     reselections to the initiator role at
+		 *     anything other than our_id, and our_id
+		 *     is used by the hardware to indicate the
+		 *     ID to use for both select-out and
+		 *     reselect-out operations, the only target
+		 *     ID we can support in this mode is our_id.
+		 *
+		 *   o The MULTARGID feature is not available and
+		 *     a previous target mode ID has been enabled.
+		 */
+		if ((ahc->features & AHC_MULTIROLE) != 0) {
 
-		if (ccb->ccb_h.target_id != our_id) {
 			if ((ahc->features & AHC_MULTI_TID) != 0
 		   	 && (ahc->flags & AHC_INITIATORROLE) != 0) {
 				/*
@@ -6647,6 +6941,10 @@ ahc_handle_en_lun(struct ahc_softc *ahc,
 				 */
 				status = CAM_TID_INVALID;
 			}
+		} else if ((ahc->features & AHC_MULTI_TID) == 0
+			&& ahc->enabled_luns > 0) {
+
+			status = CAM_TID_INVALID;
 		}
 	}
 
@@ -6661,7 +6959,8 @@ ahc_handle_en_lun(struct ahc_softc *ahc,
 	 */
 	if ((ahc->flags & AHC_TARGETROLE) == 0
 	 && ccb->ccb_h.target_id != CAM_TARGET_WILDCARD) {
-		u_long	s;
+		u_long	 s;
+		ahc_flag saved_flags;
 
 		printf("Configuring Target Mode\n");
 		ahc_lock(ahc, &s);
@@ -6670,11 +6969,29 @@ ahc_handle_en_lun(struct ahc_softc *ahc,
 			ahc_unlock(ahc, &s);
 			return;
 		}
+		saved_flags = ahc->flags;
 		ahc->flags |= AHC_TARGETROLE;
 		if ((ahc->features & AHC_MULTIROLE) == 0)
 			ahc->flags &= ~AHC_INITIATORROLE;
 		ahc_pause(ahc);
-		ahc_loadseq(ahc);
+		error = ahc_loadseq(ahc);
+		if (error != 0) {
+			/*
+			 * Restore original configuration and notify
+			 * the caller that we cannot support target mode.
+			 * Since the adapter started out in this
+			 * configuration, the firmware load will succeed,
+			 * so there is no point in checking ahc_loadseq's
+			 * return value.
+			 */
+			ahc->flags = saved_flags;
+			(void)ahc_loadseq(ahc);
+			ahc_restart(ahc);
+			ahc_unlock(ahc, &s);
+			ccb->ccb_h.status = CAM_FUNC_NOTAVAIL;
+			return;
+		}
+		ahc_restart(ahc);
 		ahc_unlock(ahc, &s);
 	}
 	cel = &ccb->cel;
@@ -6909,8 +7226,16 @@ ahc_handle_en_lun(struct ahc_softc *ahc,
 				printf("Configuring Initiator Mode\n");
 				ahc->flags &= ~AHC_TARGETROLE;
 				ahc->flags |= AHC_INITIATORROLE;
-				ahc_pause(ahc);
-				ahc_loadseq(ahc);
+				/*
+				 * Returning to a configuration that
+				 * fit previously will always succeed.
+				 */
+				(void)ahc_loadseq(ahc);
+				ahc_restart(ahc);
+				/*
+				 * Unpaused.  The extra unpause
+				 * that follows is harmless.
+				 */
 			}
 		}
 		ahc_unpause(ahc);
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx_host.h linux-5730/drivers/scsi/aic7xxx/aic7xxx_host.h
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx_host.h
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx_host.h
@@ -1,96 +0,0 @@
-/*
- * Adaptec AIC7xxx device driver host template for Linux.
- *
- * Copyright (c) 2000-2001 Adaptec Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions, and the following disclaimer,
- *    without modification.
- * 2. Redistributions in binary form must reproduce at minimum a disclaimer
- *    substantially similar to the "NO WARRANTY" disclaimer below
- *    ("Disclaimer") and any redistribution must be conditioned upon
- *    including a substantially similar Disclaimer requirement for further
- *    binary redistribution.
- * 3. Neither the names of the above-listed copyright holders nor the names
- *    of any contributors may be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * Alternatively, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") version 2 as published by the Free
- * Software Foundation.
- *
- * NO WARRANTY
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
- * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGES.
- *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_host.h#9 $
- */
-
-#ifndef _AIC7XXX_HOST_H_
-#define _AIC7XXX_HOST_H_
-
-int		 ahc_linux_proc_info(char *, char **, off_t, int, int, int);
-int		 ahc_linux_queue(Scsi_Cmnd *, void (*)(Scsi_Cmnd *));
-int		 ahc_linux_detect(Scsi_Host_Template *);
-int		 ahc_linux_release(struct Scsi_Host *);
-const char	*ahc_linux_info(struct Scsi_Host *);
-int		 ahc_linux_biosparam(Disk *, kdev_t, int[]);
-int		 ahc_linux_bus_reset(Scsi_Cmnd *);
-int		 ahc_linux_dev_reset(Scsi_Cmnd *);
-int		 ahc_linux_abort(Scsi_Cmnd *);
-
-#if defined(__i386__)
-#  define AIC7XXX_BIOSPARAM ahc_linux_biosparam
-#else
-#  define AIC7XXX_BIOSPARAM NULL
-#endif
-
-/*
- * Scsi_Host_Template (see hosts.h) for AIC-7xxx - some fields
- * to do with card config are filled in after the card is detected.
- */
-#define AIC7XXX	{						\
-	next: NULL,						\
-	module: NULL,						\
-	proc_dir: NULL,						\
-	proc_info: ahc_linux_proc_info,				\
-	name: NULL,						\
-	detect: ahc_linux_detect,				\
-	release: ahc_linux_release,				\
-	info: ahc_linux_info,					\
-	command: NULL,						\
-	queuecommand: ahc_linux_queue,				\
-	eh_strategy_handler: NULL,				\
-	eh_abort_handler: ahc_linux_abort,			\
-	eh_device_reset_handler: ahc_linux_dev_reset,		\
-	eh_bus_reset_handler: ahc_linux_bus_reset,		\
-	eh_host_reset_handler: NULL,				\
-	abort: NULL,						\
-	reset: NULL,						\
-	slave_attach: NULL,					\
-	bios_param: AIC7XXX_BIOSPARAM,				\
-	can_queue: AHC_MAX_QUEUE,/* max simultaneous cmds     */\
-	this_id: -1,		 /* scsi id of host adapter   */\
-	sg_tablesize: AHC_NSEG,	 /* max scatter-gather cmds   */\
-	cmd_per_lun: 2,		 /* cmds per lun	      */\
-	present: 0,		 /* number of 7xxx's present  */\
-	unchecked_isa_dma: 0,	 /* no memory DMA restrictions*/\
-	use_clustering: ENABLE_CLUSTERING,			\
-	use_new_eh_code: 1,					\
-	highmem_io: 1,						\
-}
-
-#endif /* _AIC7XXX_HOST_H_ */
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx_inline.h linux-5730/drivers/scsi/aic7xxx/aic7xxx_inline.h
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx_inline.h
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx_inline.h
@@ -37,9 +37,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#35 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx_inline.h#43 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx_inline.h,v 1.2.2.11 2002/04/29 19:36:31 gibbs Exp $
+ * $FreeBSD$
  */
 
 #ifndef _AIC7XXX_INLINE_H_
@@ -238,6 +238,18 @@ static __inline struct ahc_initiator_tin
 					    char channel, u_int our_id,
 					    u_int remote_id,
 					    struct ahc_tmode_tstate **tstate);
+static __inline uint16_t
+			ahc_inw(struct ahc_softc *ahc, u_int port);
+static __inline void	ahc_outw(struct ahc_softc *ahc, u_int port,
+				 u_int value);
+static __inline uint32_t
+			ahc_inl(struct ahc_softc *ahc, u_int port);
+static __inline void	ahc_outl(struct ahc_softc *ahc, u_int port,
+				 uint32_t value);
+static __inline uint64_t
+			ahc_inq(struct ahc_softc *ahc, u_int port);
+static __inline void	ahc_outq(struct ahc_softc *ahc, u_int port,
+				 uint64_t value);
 static __inline struct scb*
 			ahc_get_scb(struct ahc_softc *ahc);
 static __inline void	ahc_free_scb(struct ahc_softc *ahc, struct scb *scb);
@@ -285,6 +297,63 @@ ahc_fetch_transinfo(struct ahc_softc *ah
 	return (&(*tstate)->transinfo[remote_id]);
 }
 
+static __inline uint16_t
+ahc_inw(struct ahc_softc *ahc, u_int port)
+{
+	return ((ahc_inb(ahc, port+1) << 8) | ahc_inb(ahc, port));
+}
+
+static __inline void
+ahc_outw(struct ahc_softc *ahc, u_int port, u_int value)
+{
+	ahc_outb(ahc, port, value & 0xFF);
+	ahc_outb(ahc, port+1, (value >> 8) & 0xFF);
+}
+
+static __inline uint32_t
+ahc_inl(struct ahc_softc *ahc, u_int port)
+{
+	return ((ahc_inb(ahc, port))
+	      | (ahc_inb(ahc, port+1) << 8)
+	      | (ahc_inb(ahc, port+2) << 16)
+	      | (ahc_inb(ahc, port+3) << 24));
+}
+
+static __inline void
+ahc_outl(struct ahc_softc *ahc, u_int port, uint32_t value)
+{
+	ahc_outb(ahc, port, (value) & 0xFF);
+	ahc_outb(ahc, port+1, ((value) >> 8) & 0xFF);
+	ahc_outb(ahc, port+2, ((value) >> 16) & 0xFF);
+	ahc_outb(ahc, port+3, ((value) >> 24) & 0xFF);
+}
+
+static __inline uint64_t
+ahc_inq(struct ahc_softc *ahc, u_int port)
+{
+	return ((ahc_inb(ahc, port))
+	      | (ahc_inb(ahc, port+1) << 8)
+	      | (ahc_inb(ahc, port+2) << 16)
+	      | (ahc_inb(ahc, port+3) << 24)
+	      | (((uint64_t)ahc_inb(ahc, port+4)) << 32)
+	      | (((uint64_t)ahc_inb(ahc, port+5)) << 40)
+	      | (((uint64_t)ahc_inb(ahc, port+6)) << 48)
+	      | (((uint64_t)ahc_inb(ahc, port+7)) << 56));
+}
+
+static __inline void
+ahc_outq(struct ahc_softc *ahc, u_int port, uint64_t value)
+{
+	ahc_outb(ahc, port, value & 0xFF);
+	ahc_outb(ahc, port+1, (value >> 8) & 0xFF);
+	ahc_outb(ahc, port+2, (value >> 16) & 0xFF);
+	ahc_outb(ahc, port+3, (value >> 24) & 0xFF);
+	ahc_outb(ahc, port+4, (value >> 32) & 0xFF);
+	ahc_outb(ahc, port+5, (value >> 40) & 0xFF);
+	ahc_outb(ahc, port+6, (value >> 48) & 0xFF);
+	ahc_outb(ahc, port+7, (value >> 56) & 0xFF);
+}
+
 /*
  * Get a free scb. If there are none, see if we can allocate a new SCB.
  */
@@ -386,12 +455,19 @@ ahc_queue_scb(struct ahc_softc *ahc, str
 		      scb->hscb->tag, scb->hscb->next);
 
 	/*
+	 * Setup data "oddness".
+	 */
+	scb->hscb->lun &= LID;
+	if (ahc_get_transfer_length(scb) & 0x1)
+		scb->hscb->lun |= SCB_XFERLEN_ODD;
+
+	/*
 	 * Keep a history of SCBs we've downloaded in the qinfifo.
 	 */
 	ahc->qinfifo[ahc->qinfifonext++] = scb->hscb->tag;
 
 	/*
-	 * Make sure our data is consistant from the
+	 * Make sure our data is consistent from the
 	 * perspective of the adapter.
 	 */
 	ahc_sync_scb(ahc, scb, BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
@@ -431,7 +507,7 @@ ahc_get_sense_bufaddr(struct ahc_softc *
 static __inline void	ahc_sync_qoutfifo(struct ahc_softc *ahc, int op);
 static __inline void	ahc_sync_tqinfifo(struct ahc_softc *ahc, int op);
 static __inline u_int	ahc_check_cmdcmpltqueues(struct ahc_softc *ahc);
-static __inline void	ahc_intr(struct ahc_softc *ahc);
+static __inline int	ahc_intr(struct ahc_softc *ahc);
 
 static __inline void
 ahc_sync_qoutfifo(struct ahc_softc *ahc, int op)
@@ -489,11 +565,20 @@ ahc_check_cmdcmpltqueues(struct ahc_soft
 /*
  * Catch an interrupt from the adapter
  */
-static __inline void
+static __inline int
 ahc_intr(struct ahc_softc *ahc)
 {
 	u_int	intstat;
 
+	if ((ahc->pause & INTEN) == 0) {
+		/*
+		 * Our interrupt is not enabled on the chip
+		 * and may be disabled for re-entrancy reasons,
+		 * so just return.  This is likely just a shared
+		 * interrupt.
+		 */
+		return (0);
+	}
 	/*
 	 * Instead of directly reading the interrupt status register,
 	 * infer the cause of the interrupt by checking our in-core
@@ -507,6 +592,20 @@ ahc_intr(struct ahc_softc *ahc)
 		intstat = ahc_inb(ahc, INTSTAT);
 	}
 
+	if ((intstat & INT_PEND) == 0) {
+#if AHC_PCI_CONFIG > 0
+		if (ahc->unsolicited_ints > 500) {
+			ahc->unsolicited_ints = 0;
+			if ((ahc->chip & AHC_PCI) != 0
+			 && (ahc_inb(ahc, ERROR) & PCIERRSTAT) != 0)
+				ahc->bus_intr(ahc);
+		}
+#endif
+		ahc->unsolicited_ints++;
+		return (0);
+	}
+	ahc->unsolicited_ints = 0;
+
 	if (intstat & CMDCMPLT) {
 		ahc_outb(ahc, CLRINT, CLRCMDINT);
 
@@ -526,38 +625,25 @@ ahc_intr(struct ahc_softc *ahc)
 #endif
 	}
 
-	if (intstat == 0xFF && (ahc->features & AHC_REMOVABLE) != 0)
-		/* Hot eject */
-		return;
-
-	if ((intstat & INT_PEND) == 0) {
-#if AHC_PCI_CONFIG > 0
-		if (ahc->unsolicited_ints > 500) {
-			ahc->unsolicited_ints = 0;
-			if ((ahc->chip & AHC_PCI) != 0
-			 && (ahc_inb(ahc, ERROR) & PCIERRSTAT) != 0)
-				ahc->bus_intr(ahc);
-		}
-#endif
-		ahc->unsolicited_ints++;
-		return;
-	}
-	ahc->unsolicited_ints = 0;
-
-	if (intstat & BRKADRINT) {
+	/*
+	 * Handle statuses that may invalidate our cached
+	 * copy of INTSTAT separately.
+	 */
+	if (intstat == 0xFF && (ahc->features & AHC_REMOVABLE) != 0) {
+		/* Hot eject.  Do nothing */
+	} else if (intstat & BRKADRINT) {
 		ahc_handle_brkadrint(ahc);
-		/* Fatal error, no more interrupts to handle. */
-		return;
-	}
+	} else if ((intstat & (SEQINT|SCSIINT)) != 0) {
 
-	if ((intstat & (SEQINT|SCSIINT)) != 0)
 		ahc_pause_bug_fix(ahc);
 
-	if ((intstat & SEQINT) != 0)
-		ahc_handle_seqint(ahc, intstat);
+		if ((intstat & SEQINT) != 0)
+			ahc_handle_seqint(ahc, intstat);
 
-	if ((intstat & SCSIINT) != 0)
-		ahc_handle_scsiint(ahc, intstat);
+		if ((intstat & SCSIINT) != 0)
+			ahc_handle_scsiint(ahc, intstat);
+	}
+	return (1);
 }
 
 #endif  /* _AIC7XXX_INLINE_H_ */
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx_osm.c linux-5730/drivers/scsi/aic7xxx/aic7xxx_osm.c
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx_osm.c
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx_osm.c
@@ -1,7 +1,7 @@
 /*
  * Adaptec AIC7xxx device driver for Linux.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#103 $
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.c#234 $
  *
  * Copyright (c) 1994 John Aycock
  *   The University of Calgary Department of Computer Science.
@@ -108,7 +108,7 @@
  * but are not limited to:
  *
  *  1: Import of the latest FreeBSD sequencer code for this driver
- *  2: Modification of kernel code to accomodate different sequencer semantics
+ *  2: Modification of kernel code to accommodate different sequencer semantics
  *  3: Extensive changes throughout kernel portion of driver to improve
  *     abort/reset processing and error hanndling
  *  4: Other work contributed by various people on the Internet
@@ -119,36 +119,37 @@
  *
  */
 
-/*
- * This is the only file where module.h should
- * embed module global version info.
- */
-#define AHC_MODVERSION_FILE
-
 #include "aic7xxx_osm.h"
 #include "aic7xxx_inline.h"
+#include <scsi/scsicam.h>
+
+/*
+ * Include aiclib.c as part of our
+ * "module dependencies are hard" work around.
+ */
+#include "aiclib.c"
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
 #include <linux/init.h>		/* __setup */
 #endif
 
-#include "../sd.h"		/* For geometry detection */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+#include "sd.h"			/* For geometry detection */
+#endif
 
 #include <linux/mm.h>		/* For fetching system memory size */
 #include <linux/blk.h>		/* For block_size() */
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
 /*
  * Lock protecting manipulation of the ahc softc list.
  */
 spinlock_t ahc_list_spinlock;
-#endif
 
-/*
- * To generate the correct addresses for the controller to issue
- * on the bus.  Originally added for DEC Alpha support.
- */
-#define VIRT_TO_BUS(a) (uint32_t)virt_to_bus((void *)(a))
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+/* For dynamic sglist size calculation. */
+u_int ahc_linux_nseg;
+#endif
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
 struct proc_dir_entry proc_scsi_aic7xxx = {
@@ -280,6 +281,39 @@ static adapter_tag_info_t aic7xxx_tag_in
 };
 
 /*
+ * DV option:
+ *
+ * positive value = DV Enabled
+ * zero		  = DV Disabled
+ * negative value = DV Default for adapter type/seeprom
+ */
+#ifdef CONFIG_AIC7XXX_DV_SETTING
+#define AIC7XXX_CONFIGED_DV CONFIG_AIC7XXX_DV_SETTING
+#else
+#define AIC7XXX_CONFIGED_DV -1
+#endif
+
+static int8_t aic7xxx_dv_settings[] =
+{
+	AIC7XXX_CONFIGED_DV,
+	AIC7XXX_CONFIGED_DV,
+	AIC7XXX_CONFIGED_DV,
+	AIC7XXX_CONFIGED_DV,
+	AIC7XXX_CONFIGED_DV,
+	AIC7XXX_CONFIGED_DV,
+	AIC7XXX_CONFIGED_DV,
+	AIC7XXX_CONFIGED_DV,
+	AIC7XXX_CONFIGED_DV,
+	AIC7XXX_CONFIGED_DV,
+	AIC7XXX_CONFIGED_DV,
+	AIC7XXX_CONFIGED_DV,
+	AIC7XXX_CONFIGED_DV,
+	AIC7XXX_CONFIGED_DV,
+	AIC7XXX_CONFIGED_DV,
+	AIC7XXX_CONFIGED_DV
+};
+
+/*
  * There should be a specific return value for this in scsi.h, but
  * it seems that most drivers ignore it.
  */
@@ -325,31 +359,26 @@ static uint32_t aic7xxx_no_reset;
  * disabled at the very end.  That should fix everyone up unless there are
  * really strange cirumstances.
  */
-static int aic7xxx_reverse_scan = 0;
+static uint32_t aic7xxx_reverse_scan;
 
 /*
  * Should we force EXTENDED translation on a controller.
  *     0 == Use whatever is in the SEEPROM or default to off
  *     1 == Use whatever is in the SEEPROM or default to on
  */
-static uint32_t aic7xxx_extended = 0;
+static uint32_t aic7xxx_extended;
 
 /*
  * PCI bus parity checking of the Adaptec controllers.  This is somewhat
  * dubious at best.  To my knowledge, this option has never actually
  * solved a PCI parity problem, but on certain machines with broken PCI
- * chipset configurations, it can generate tons of false error messages.
+ * chipset configurations where stray PCI transactions with bad parity are
+ * the norm rather than the exception, the error messages can be overwelming.
  * It's included in the driver for completeness.
- *   0 = Shut off PCI parity check
- *  -1 = Normal polarity pci parity checking
- *   1 = reverse polarity pci parity checking
- *
- * NOTE: you can't actually pass -1 on the lilo prompt.  So, to set this
- * variable to -1 you would actually want to simply pass the variable
- * name without a number.  That will invert the 0 which will result in
- * -1.
+ *   0	   = Shut off PCI parity check
+ *   non-0 = reverse polarity pci parity checking
  */
-static int aic7xxx_pci_parity = 0;
+static uint32_t aic7xxx_pci_parity = ~0;
 
 /*
  * Certain newer motherboards have put new PCI based devices into the
@@ -362,15 +391,20 @@ static int aic7xxx_pci_parity = 0;
  * would result in never finding any devices :)
  */
 #ifndef CONFIG_AIC7XXX_PROBE_EISA_VL
-#define CONFIG_AIC7XXX_PROBE_EISA_VL n
-#endif
-#if CONFIG_AIC7XXX_PROBE_EISA_VL == n
-static int aic7xxx_no_probe = 1;
+uint32_t aic7xxx_probe_eisa_vl;
 #else
-static int aic7xxx_no_probe;
+uint32_t aic7xxx_probe_eisa_vl = ~0;
 #endif
 
 /*
+ * There are lots of broken chipsets in the world.  Some of them will
+ * violate the PCI spec when we issue byte sized memory writes to our
+ * controller.  I/O mapped register access, if allowed by the given
+ * platform, will work in almost all cases.
+ */
+uint32_t aic7xxx_allow_memio = ~0;
+
+/*
  * aic7xxx_detect() has been run, so register all device arrivals
  * immediately with the system rather than deferring to the sorted
  * attachment performed by aic7xxx_detect().
@@ -387,7 +421,7 @@ int aic7xxx_detect_complete;
  * We default to 256ms because some older devices need a longer time
  * to respond to initial selection.
  */
-static int aic7xxx_seltime = 0x00;
+static uint32_t aic7xxx_seltime;
 
 /*
  * Certain devices do not perform any aging on commands.  Should the
@@ -397,7 +431,7 @@ static int aic7xxx_seltime = 0x00;
  * force all outstanding transactions to be serviced prior to a new
  * transaction.
  */
-int aic7xxx_periodic_otag;
+uint32_t aic7xxx_periodic_otag;
 
 /*
  * Module information and settable options.
@@ -413,49 +447,99 @@ static char dummy_buffer[60] = "Please d
 
 MODULE_AUTHOR("Maintainer: Justin T. Gibbs <gibbs@scsiguy.com>");
 MODULE_DESCRIPTION("Adaptec Aic77XX/78XX SCSI Host Bus Adapter driver");
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,10)
+#ifdef MODULE_LICENSE
 MODULE_LICENSE("Dual BSD/GPL");
 #endif
 MODULE_PARM(aic7xxx, "s");
-MODULE_PARM_DESC(aic7xxx, "period delimited, options string.\n"
+MODULE_PARM_DESC(aic7xxx,
+"period delimited, options string.\n"
 "	verbose			Enable verbose/diagnostic logging\n"
-"	no_probe		Disable EISA/VLB controller probing\n"
+"	allow_memio		Allow device registers to be memory mapped\n"
+"	debug			Bitmask of debug values to enable\n"
+"	no_probe		Toggle EISA/VLB controller probing\n"
+"	probe_eisa_vl		Toggle EISA/VLB controller probing\n"
 "	no_reset		Supress initial bus resets\n"
 "	extended		Enable extended geometry on all controllers\n"
-"	periodic_otag		Send an ordered tagged transaction periodically\n"
-"				to prevent tag starvation.  This may be\n"
-"				required by some older disk drives/RAID arrays.\n"
+"	periodic_otag		Send an ordered tagged transaction\n"
+"				periodically to prevent tag starvation.\n"
+"				This may be required by some older disk\n"
+"				drives or RAID arrays.\n"
 "	reverse_scan		Sort PCI devices highest Bus/Slot to lowest\n"
 "	tag_info:<tag_str>	Set per-target tag depth\n"
-"	seltime:<int>		Selection Timeout(0/256ms,1/128ms,2/64ms,3/32ms)\n"
+"	global_tag_depth:<int>	Global tag depth for every target\n"
+"				on every bus\n"
+"	dv:<dv_settings>	Set per-controller Domain Validation Setting.\n"
+"	seltime:<int>		Selection Timeout\n"
+"				(0/256ms,1/128ms,2/64ms,3/32ms)\n"
 "\n"
 "	Sample /etc/modules.conf line:\n"
-"		Enable verbose logging\n"
-"		Disable EISA/VLB probing\n"
-"		Set tag depth on Controller 2/Target 2 to 10 tags\n"
-"		Shorten the selection timeout to 128ms from its default of 256\n"
+"		Toggle EISA/VLB probing\n"
+"		Set tag depth on Controller 1/Target 1 to 10 tags\n"
+"		Shorten the selection timeout to 128ms\n"
 "\n"
-"	options aic7xxx='\"verbose.no_probe.tag_info:{{}.{}.{..10}}.seltime:1\"'"
+"	options aic7xxx 'aic7xxx=probe_eisa_vl.tag_info:{{}.{.10}}.seltime:1'\n"
 );
 #endif
 
 static void ahc_linux_handle_scsi_status(struct ahc_softc *,
 					 struct ahc_linux_device *,
 					 struct scb *);
-static void ahc_linux_filter_command(struct ahc_softc*, Scsi_Cmnd*,
-				     struct scb*);
+static void ahc_linux_queue_cmd_complete(struct ahc_softc *ahc,
+					 Scsi_Cmnd *cmd);
+static void ahc_linux_filter_inquiry(struct ahc_softc*, struct ahc_devinfo*);
 static void ahc_linux_sem_timeout(u_long arg);
-static void ahc_linux_freeze_sim_queue(struct ahc_softc *ahc);
-static void ahc_linux_release_sim_queue(u_long arg);
+static void ahc_linux_freeze_simq(struct ahc_softc *ahc);
+static void ahc_linux_release_simq(u_long arg);
 static void ahc_linux_dev_timed_unfreeze(u_long arg);
 static int  ahc_linux_queue_recovery_cmd(Scsi_Cmnd *cmd, scb_flag flag);
 static void ahc_linux_initialize_scsi_bus(struct ahc_softc *ahc);
-static void ahc_linux_select_queue_depth(struct Scsi_Host *host,
-					 Scsi_Device *scsi_devs);
+static void ahc_linux_size_nseg(void);
+static void ahc_linux_thread_run_complete_queue(struct ahc_softc *ahc);
+static void ahc_linux_start_dv(struct ahc_softc *ahc);
+static void ahc_linux_dv_timeout(struct scsi_cmnd *cmd);
+static int  ahc_linux_dv_thread(void *data);
+static void ahc_linux_kill_dv_thread(struct ahc_softc *ahc);
+static void ahc_linux_dv_target(struct ahc_softc *ahc, u_int target);
+static void ahc_linux_dv_transition(struct ahc_softc *ahc,
+				    struct scsi_cmnd *cmd,
+				    struct ahc_devinfo *devinfo,
+				    struct ahc_linux_target *targ);
+static void ahc_linux_dv_fill_cmd(struct ahc_softc *ahc,
+				  struct scsi_cmnd *cmd,
+				  struct ahc_devinfo *devinfo);
+static void ahc_linux_dv_inq(struct ahc_softc *ahc,
+			     struct scsi_cmnd *cmd,
+			     struct ahc_devinfo *devinfo,
+			     struct ahc_linux_target *targ,
+			     u_int request_length);
+static void ahc_linux_dv_tur(struct ahc_softc *ahc,
+			     struct scsi_cmnd *cmd,
+			     struct ahc_devinfo *devinfo);
+static void ahc_linux_dv_rebd(struct ahc_softc *ahc,
+			      struct scsi_cmnd *cmd,
+			      struct ahc_devinfo *devinfo,
+			      struct ahc_linux_target *targ);
+static void ahc_linux_dv_web(struct ahc_softc *ahc,
+			     struct scsi_cmnd *cmd,
+			     struct ahc_devinfo *devinfo,
+			     struct ahc_linux_target *targ);
+static void ahc_linux_dv_reb(struct ahc_softc *ahc,
+			     struct scsi_cmnd *cmd,
+			     struct ahc_devinfo *devinfo,
+			     struct ahc_linux_target *targ);
+static void ahc_linux_dv_su(struct ahc_softc *ahc,
+			    struct scsi_cmnd *cmd,
+			    struct ahc_devinfo *devinfo,
+			    struct ahc_linux_target *targ);
+static int ahc_linux_fallback(struct ahc_softc *ahc,
+			      struct ahc_devinfo *devinfo);
+static void ahc_linux_dv_complete(Scsi_Cmnd *cmd);
+static void ahc_linux_generate_dv_pattern(struct ahc_linux_target *targ);
 static u_int ahc_linux_user_tagdepth(struct ahc_softc *ahc,
 				     struct ahc_devinfo *devinfo);
+static u_int ahc_linux_user_dv_setting(struct ahc_softc *ahc);
 static void ahc_linux_device_queue_depth(struct ahc_softc *ahc,
-					 Scsi_Device *device);
+					 struct ahc_linux_device *dev);
 static struct ahc_linux_target*	ahc_linux_alloc_target(struct ahc_softc*,
 						       u_int, u_int);
 static void			ahc_linux_free_target(struct ahc_softc*,
@@ -467,34 +551,60 @@ static void			ahc_linux_free_device(stru
 						      struct ahc_linux_device*);
 static void ahc_linux_run_device_queue(struct ahc_softc*,
 				       struct ahc_linux_device*);
-static void ahc_linux_setup_tag_info(char *p, char *end);
-static int ahc_linux_next_unit(void);
+static void ahc_linux_setup_tag_info_global(char *p);
+static aic_option_callback_t ahc_linux_setup_tag_info;
+static aic_option_callback_t ahc_linux_setup_dv;
+static int  aic7xxx_setup(char *s);
+static int  ahc_linux_next_unit(void);
 static void ahc_runq_tasklet(unsigned long data);
-static int ahc_linux_halt(struct notifier_block *nb, u_long event, void *buf);
+static struct ahc_cmd *ahc_linux_run_complete_queue(struct ahc_softc *ahc);
 
+/********************************* Inlines ************************************/
+static __inline void ahc_schedule_runq(struct ahc_softc *ahc);
 static __inline struct ahc_linux_device*
 		     ahc_linux_get_device(struct ahc_softc *ahc, u_int channel,
 					  u_int target, u_int lun, int alloc);
-static __inline void ahc_linux_queue_cmd_complete(struct ahc_softc *ahc,
-						  Scsi_Cmnd *cmd);
-static __inline void ahc_linux_run_complete_queue(struct ahc_softc *ahc,
-						  struct ahc_cmd *acmd);
+static __inline void ahc_schedule_completeq(struct ahc_softc *ahc);
 static __inline void ahc_linux_check_device_queue(struct ahc_softc *ahc,
 						  struct ahc_linux_device *dev);
 static __inline struct ahc_linux_device *
 		     ahc_linux_next_device_to_run(struct ahc_softc *ahc);
 static __inline void ahc_linux_run_device_queues(struct ahc_softc *ahc);
-static __inline void ahc_linux_sniff_command(struct ahc_softc*, Scsi_Cmnd*,
-					     struct scb*);
 static __inline void ahc_linux_unmap_scb(struct ahc_softc*, struct scb*);
 
 static __inline int ahc_linux_map_seg(struct ahc_softc *ahc, struct scb *scb,
 		 		      struct ahc_dma_seg *sg,
 				      bus_addr_t addr, bus_size_t len);
 
+static __inline void
+ahc_schedule_completeq(struct ahc_softc *ahc)
+{
+	if ((ahc->platform_data->flags & AHC_RUN_CMPLT_Q_TIMER) == 0) {
+		ahc->platform_data->flags |= AHC_RUN_CMPLT_Q_TIMER;
+		ahc->platform_data->completeq_timer.expires = jiffies;
+		add_timer(&ahc->platform_data->completeq_timer);
+	}
+}
+
+/*
+ * Must be called with our lock held.
+ */
+static __inline void
+ahc_schedule_runq(struct ahc_softc *ahc)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	tasklet_schedule(&ahc->platform_data->runq_tasklet);
+#else
+	/*
+	 * Tasklets are not available, so run inline.
+	 */
+	ahc_runq_tasklet((unsigned long)ahc);
+#endif
+}
+
 static __inline struct ahc_linux_device*
 ahc_linux_get_device(struct ahc_softc *ahc, u_int channel, u_int target,
-	       u_int lun, int alloc)
+		     u_int lun, int alloc)
 {
 	struct ahc_linux_target *targ;
 	struct ahc_linux_device *dev;
@@ -518,62 +628,43 @@ ahc_linux_get_device(struct ahc_softc *a
 	return (dev);
 }
 
-static __inline void
-ahc_linux_queue_cmd_complete(struct ahc_softc *ahc, Scsi_Cmnd *cmd)
+#define AHC_LINUX_MAX_RETURNED_ERRORS 4
+static struct ahc_cmd *
+ahc_linux_run_complete_queue(struct ahc_softc *ahc)
 {
-	/*
-	 * Typically, the complete queue has very few entries
-	 * queued to it before the queue is emptied by
-	 * ahc_linux_run_complete_queue, so sorting the entries
-	 * by generation number should be inexpensive.
-	 * We perform the sort so that commands that complete
-	 * with an error are retuned in the order origionally
-	 * queued to the controller so that any subsequent retries
-	 * are performed in order.  The underlying ahc routines do
-	 * not guarantee the order that aborted commands will be
-	 * returned to us.
-	 */
-	struct ahc_completeq *completeq;
-	struct ahc_cmd *list_cmd;
-	struct ahc_cmd *acmd;
-
-	/*
-	 * If we want the request requeued, make sure there
-	 * are sufficent retries.  In the old scsi error code,
-	 * we used to be able to specify a result code that
-	 * bypassed the retry count.  Now we must use this
-	 * hack.
-	 */
-	if (cmd->result == (CAM_REQUEUE_REQ << 16))
-		cmd->retries--;
-	completeq = &ahc->platform_data->completeq;
-	list_cmd = TAILQ_FIRST(completeq);
-	acmd = (struct ahc_cmd *)cmd;
-	while (list_cmd != NULL
-	    && acmd_scsi_cmd(list_cmd).serial_number
-	     < acmd_scsi_cmd(acmd).serial_number)
-		list_cmd = TAILQ_NEXT(list_cmd, acmd_links.tqe);
-	if (list_cmd != NULL)
-		TAILQ_INSERT_BEFORE(list_cmd, acmd, acmd_links.tqe);
-	else
-		TAILQ_INSERT_TAIL(completeq, acmd, acmd_links.tqe);
-}
-
-static __inline void
-ahc_linux_run_complete_queue(struct ahc_softc *ahc, struct ahc_cmd *acmd)
-{	
-	u_long done_flags;
+	struct	ahc_cmd *acmd;
+	u_long	done_flags;
+	int	with_errors;
 
+	with_errors = 0;
 	ahc_done_lock(ahc, &done_flags);
-	while (acmd != NULL) {
+	while ((acmd = TAILQ_FIRST(&ahc->platform_data->completeq)) != NULL) {
 		Scsi_Cmnd *cmd;
 
+		if (with_errors > AHC_LINUX_MAX_RETURNED_ERRORS) {
+			/*
+			 * Linux uses stack recursion to requeue
+			 * commands that need to be retried.  Avoid
+			 * blowing out the stack by "spoon feeding"
+			 * commands that completed with error back
+			 * the operating system in case they are going
+			 * to be retried. "ick"
+			 */
+			ahc_schedule_completeq(ahc);
+			break;
+		}
+		TAILQ_REMOVE(&ahc->platform_data->completeq,
+			     acmd, acmd_links.tqe);
 		cmd = &acmd_scsi_cmd(acmd);
-		acmd = TAILQ_NEXT(acmd, acmd_links.tqe);
 		cmd->host_scribble = NULL;
+		if (ahc_cmd_get_transaction_status(cmd) != DID_OK
+		 || (cmd->result & 0xFF) != SCSI_STATUS_OK)
+			with_errors++;
+
 		cmd->scsi_done(cmd);
 	}
 	ahc_done_unlock(ahc, &done_flags);
+	return (acmd);
 }
 
 static __inline void
@@ -598,7 +689,8 @@ ahc_linux_next_device_to_run(struct ahc_
 {
 	
 	if ((ahc->flags & AHC_RESOURCE_SHORTAGE) != 0
-	 || ahc->platform_data->qfrozen != 0)
+	 || (ahc->platform_data->qfrozen != 0
+	  && AHC_DV_SIMQ_FROZEN(ahc) == 0))
 		return (NULL);
 	return (TAILQ_FIRST(&ahc->platform_data->device_runq));
 }
@@ -616,19 +708,6 @@ ahc_linux_run_device_queues(struct ahc_s
 }
 
 static __inline void
-ahc_linux_sniff_command(struct ahc_softc *ahc, Scsi_Cmnd *cmd, struct scb *scb)
-{
-	/*
-	 * Determine whether we care to filter
-	 * information out of this command.  If so,
-	 * pass it on to ahc_linux_filter_command() for more
-	 * heavy weight processing.
-	 */
-	if (cmd->cmnd[0] == INQUIRY)
-		ahc_linux_filter_command(ahc, cmd, scb);
-}
-
-static __inline void
 ahc_linux_unmap_scb(struct ahc_softc *ahc, struct scb *scb)
 {
 	Scsi_Cmnd *cmd;
@@ -662,906 +741,2808 @@ ahc_linux_map_seg(struct ahc_softc *ahc,
 	consumed = 1;
 	sg->addr = ahc_htole32(addr & 0xFFFFFFFF);
 	scb->platform_data->xfer_len += len;
+
 	if (sizeof(bus_addr_t) > 4
-	 && (ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
-		/*
-		 * Due to DAC restrictions, we can't
-		 * cross a 4GB boundary.
-		 */
-		if ((addr ^ (addr + len - 1)) & ~0xFFFFFFFF) {
-			struct	 ahc_dma_seg *next_sg;
-			uint32_t next_len;
-
-			printf("Crossed Seg\n");
-			if ((scb->sg_count + 2) > AHC_NSEG)
-				panic("Too few segs for dma mapping.  "
-				      "Increase AHC_NSEG\n");
-
-			consumed++;
-			next_sg = sg + 1;
-			next_sg->addr = 0;
-			next_len = 0x100000000 - (addr & 0xFFFFFFFF);
-			len -= next_len;
-			next_len |= ((addr >> 8) + 0x1000000) & 0x7F000000;
-			next_sg->len = ahc_htole32(next_len);
-		}
-		len |= (addr >> 8) & 0x7F000000;
-	}
+	 && (ahc->flags & AHC_39BIT_ADDRESSING) != 0)
+		len |= (addr >> 8) & AHC_SG_HIGH_ADDR_MASK;
+
 	sg->len = ahc_htole32(len);
 	return (consumed);
 }
 
-/**************************** Tasklet Handler *********************************/
+/************************  Host template entry points *************************/
+static int	   ahc_linux_detect(Scsi_Host_Template *);
+static int	   ahc_linux_queue(Scsi_Cmnd *, void (*)(Scsi_Cmnd *));
+static const char *ahc_linux_info(struct Scsi_Host *);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static int	   ahc_linux_slave_alloc(Scsi_Device *);
+static int	   ahc_linux_slave_configure(Scsi_Device *);
+static void	   ahc_linux_slave_destroy(Scsi_Device *);
+#if defined(__i386__)
+static int	   ahc_linux_biosparam(struct scsi_device*,
+				       struct block_device*,
+				       sector_t, int[]);
+#endif
+#else
+static int	   ahc_linux_release(struct Scsi_Host *);
+static void	   ahc_linux_select_queue_depth(struct Scsi_Host *host,
+						Scsi_Device *scsi_devs);
+#if defined(__i386__)
+static int	   ahc_linux_biosparam(Disk *, kdev_t, int[]);
+#endif
+#endif
+static int	   ahc_linux_bus_reset(Scsi_Cmnd *);
+static int	   ahc_linux_dev_reset(Scsi_Cmnd *);
+static int	   ahc_linux_abort(Scsi_Cmnd *);
 
+/*
+ * Calculate a safe value for AHC_NSEG (as expressed through ahc_linux_nseg).
+ *
+ * In pre-2.5.X...
+ * The midlayer allocates an S/G array dynamically when a command is issued
+ * using SCSI malloc.  This array, which is in an OS dependent format that
+ * must later be copied to our private S/G list, is sized to house just the
+ * number of segments needed for the current transfer.  Since the code that
+ * sizes the SCSI malloc pool does not take into consideration fragmentation
+ * of the pool, executing transactions numbering just a fraction of our
+ * concurrent transaction limit with list lengths aproaching AHC_NSEG will
+ * quickly depleat the SCSI malloc pool of usable space.  Unfortunately, the
+ * mid-layer does not properly handle this scsi malloc failures for the S/G
+ * array and the result can be a lockup of the I/O subsystem.  We try to size
+ * our S/G list so that it satisfies our drivers allocation requirements in
+ * addition to avoiding fragmentation of the SCSI malloc pool.
+ */
 static void
-ahc_runq_tasklet(unsigned long data)
+ahc_linux_size_nseg(void)
 {
-	struct ahc_softc* ahc;
-	struct ahc_linux_device *dev;
-	u_long flags;
-
-	ahc = (struct ahc_softc *)data;
-	ahc_lock(ahc, &flags);
-	while ((dev = ahc_linux_next_device_to_run(ahc)) != NULL) {
-	
-		TAILQ_REMOVE(&ahc->platform_data->device_runq, dev, links);
-		dev->flags &= ~AHC_DEV_ON_RUN_LIST;
-		ahc_linux_check_device_queue(ahc, dev);
-		/* Yeild to our interrupt handler */
-		ahc_unlock(ahc, &flags);
-		ahc_lock(ahc, &flags);
-	}
-	ahc_unlock(ahc, &flags);
-}
-
-/************************ Shutdown/halt/reboot hook ***************************/
-#include <linux/notifier.h>
-#include <linux/reboot.h>
-
-static struct notifier_block ahc_linux_notifier = {
-	ahc_linux_halt, NULL, 0
-};
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	u_int cur_size;
+	u_int best_size;
 
-static int ahc_linux_halt(struct notifier_block *nb, u_long event, void *buf)
-{
-	struct ahc_softc *ahc;
+	/*
+	 * The SCSI allocator rounds to the nearest 512 bytes
+	 * an cannot allocate across a page boundary.  Our algorithm
+	 * is to start at 1K of scsi malloc space per-command and
+	 * loop through all factors of the PAGE_SIZE and pick the best.
+	 */
+	best_size = 0;
+	for (cur_size = 1024; cur_size <= PAGE_SIZE; cur_size *= 2) {
+		u_int nseg;
+
+		nseg = cur_size / sizeof(struct scatterlist);
+		if (nseg < AHC_LINUX_MIN_NSEG)
+			continue;
+
+		if (best_size == 0) {
+			best_size = cur_size;
+			ahc_linux_nseg = nseg;
+		} else {
+			u_int best_rem;
+			u_int cur_rem;
 
-	if (event == SYS_DOWN || event == SYS_HALT) {
-		TAILQ_FOREACH(ahc, &ahc_tailq, links) {
-			ahc_shutdown(ahc);
+			/*
+			 * Compare the traits of the current "best_size"
+			 * with the current size to determine if the
+			 * current size is a better size.
+			 */
+			best_rem = best_size % sizeof(struct scatterlist);
+			cur_rem = cur_size % sizeof(struct scatterlist);
+			if (cur_rem < best_rem) {
+				best_size = cur_size;
+				ahc_linux_nseg = nseg;
+			}
 		}
 	}
-	return (NOTIFY_OK);
+#endif
 }
 
-/******************************** Macros **************************************/
-#define BUILD_SCSIID(ahc, cmd)						\
-	((((cmd)->target << TID_SHIFT) & TID)				\
-	| (((cmd)->channel == 0) ? (ahc)->our_id : (ahc)->our_id_b)	\
-	| (((cmd)->channel == 0) ? 0 : TWIN_CHNLB))
-
-/******************************** Bus DMA *************************************/
-int
-ahc_dma_tag_create(struct ahc_softc *ahc, bus_dma_tag_t parent,
-		   bus_size_t alignment, bus_size_t boundary,
-		   bus_addr_t lowaddr, bus_addr_t highaddr,
-		   bus_dma_filter_t *filter, void *filterarg,
-		   bus_size_t maxsize, int nsegments,
-		   bus_size_t maxsegsz, int flags, bus_dma_tag_t *ret_tag)
+/*
+ * Try to detect an Adaptec 7XXX controller.
+ */
+static int
+ahc_linux_detect(Scsi_Host_Template *template)
 {
-	bus_dma_tag_t dmat;
-
-	dmat = malloc(sizeof(*dmat), M_DEVBUF, M_NOWAIT);
-	if (dmat == NULL)
-		return (ENOMEM);
+	struct	ahc_softc *ahc;
+	int     found;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 	/*
-	 * Linux is very simplistic about DMA memory.  For now don't
-	 * maintain all specification information.  Once Linux supplies
-	 * better facilities for doing these operations, or the
-	 * needs of this particular driver change, we might need to do
-	 * more here.
+	 * It is a bug that the upper layer takes
+	 * this lock just prior to calling us.
 	 */
-	dmat->alignment = alignment;
-	dmat->boundary = boundary;
-	dmat->maxsize = maxsize;
-	*ret_tag = dmat;
-	return (0);
-}
-
-void
-ahc_dma_tag_destroy(struct ahc_softc *ahc, bus_dma_tag_t dmat)
-{
-	free(dmat, M_DEVBUF);
-}
-
-int
-ahc_dmamem_alloc(struct ahc_softc *ahc, bus_dma_tag_t dmat, void** vaddr,
-		 int flags, bus_dmamap_t *mapp)
-{
-	bus_dmamap_t map;
+	spin_unlock_irq(&io_request_lock);
+#endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	map = malloc(sizeof(*map), M_DEVBUF, M_NOWAIT);
-	if (map == NULL)
-		return (ENOMEM);
 	/*
-	 * Although we can dma data above 4GB, our
-	 * "consistent" memory is below 4GB for
-	 * space efficiency reasons (only need a 4byte
-	 * address).  For this reason, we have to reset
-	 * our dma mask when doing allocations.
+	 * Sanity checking of Linux SCSI data structures so
+	 * that some of our hacks^H^H^H^H^Hassumptions aren't
+	 * violated.
 	 */
-	if (ahc->dev_softc != NULL) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,3)
-		pci_set_dma_mask(ahc->dev_softc, 0xFFFFFFFF);
-#else
-		ahc->dev_softc->dma_mask = 0xFFFFFFFF;
-#endif
-	}
-	*vaddr = pci_alloc_consistent(ahc->dev_softc,
-				      dmat->maxsize, &map->bus_addr);
-	if (ahc->dev_softc != NULL) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,3)
-		pci_set_dma_mask(ahc->dev_softc,
-				 ahc->platform_data->hw_dma_mask);
-#else
-		ahc->dev_softc->dma_mask = ahc->platform_data->hw_dma_mask;
-#endif
+	if (offsetof(struct ahc_cmd_internal, end)
+	  > offsetof(struct scsi_cmnd, host_scribble)) {
+		printf("ahc_linux_detect: SCSI data structures changed.\n");
+		printf("ahc_linux_detect: Unable to attach\n");
+		return (0);
 	}
-#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0) */
+	ahc_linux_size_nseg();
+#ifdef MODULE
 	/*
-	 * At least in 2.2.14, malloc is a slab allocator so all
-	 * allocations are aligned.  We assume for these kernel versions
-	 * that all allocations will be bellow 4Gig, physically contiguous,
-	 * and accessable via DMA by the controller.
+	 * If we've been passed any parameters, process them now.
 	 */
-	map = NULL; /* No additional information to store */
-	*vaddr = malloc(dmat->maxsize, M_DEVBUF, M_NOWAIT);
+	if (aic7xxx)
+		aic7xxx_setup(aic7xxx);
+	if (dummy_buffer[0] != 'P')
+		printk(KERN_WARNING
+"aic7xxx: Please read the file /usr/src/linux/drivers/scsi/README.aic7xxx\n"
+"aic7xxx: to see the proper way to specify options to the aic7xxx module\n"
+"aic7xxx: Specifically, don't use any commas when passing arguments to\n"
+"aic7xxx: insmod or else it might trash certain memory areas.\n");
 #endif
-	if (*vaddr == NULL)
-		return (ENOMEM);
-	*mapp = map;
-	return(0);
-}
 
-void
-ahc_dmamem_free(struct ahc_softc *ahc, bus_dma_tag_t dmat,
-		void* vaddr, bus_dmamap_t map)
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	pci_free_consistent(ahc->dev_softc, dmat->maxsize,
-			    vaddr, map->bus_addr);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
+	template->proc_name = "aic7xxx";
 #else
-	free(vaddr, M_DEVBUF);
+	template->proc_dir = &proc_scsi_aic7xxx;
 #endif
-}
 
-int
-ahc_dmamap_load(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map,
-		void *buf, bus_size_t buflen, bus_dmamap_callback_t *cb,
-		void *cb_arg, int flags)
-{
 	/*
-	 * Assume for now that this will only be used during
-	 * initialization and not for per-transaction buffer mapping.
+	 * Initialize our softc list lock prior to
+	 * probing for any adapters.
 	 */
-	bus_dma_segment_t stack_sg;
+	ahc_list_lockinit();
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	stack_sg.ds_addr = map->bus_addr;
-#else
-	stack_sg.ds_addr = VIRT_TO_BUS(buf);
+#ifdef CONFIG_PCI
+	ahc_linux_pci_init();
+#endif
+
+#ifdef CONFIG_EISA
+	ahc_linux_eisa_init();
 #endif
-	stack_sg.ds_len = dmat->maxsize;
-	cb(cb_arg, &stack_sg, /*nseg*/1, /*error*/0);
-	return (0);
-}
 
-void
-ahc_dmamap_destroy(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map)
-{
 	/*
-	 * The map may is NULL in our < 2.3.X implementation.
+	 * Register with the SCSI layer all
+	 * controllers we've found.
 	 */
-	if (map != NULL)
-		free(map, M_DEVBUF);
-}
+	found = 0;
+	TAILQ_FOREACH(ahc, &ahc_tailq, links) {
 
-int
-ahc_dmamap_unload(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map)
-{
-	/* Nothing to do */
-	return (0);
+		if (ahc_linux_register_host(ahc, template) == 0)
+			found++;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	spin_lock_irq(&io_request_lock);
+#endif
+	aic7xxx_detect_complete++;
+	return (found);
 }
 
-/********************* Platform Dependent Functions ***************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+/*
+ * Free the passed in Scsi_Host memory structures prior to unloading the
+ * module.
+ */
 int
-ahc_softc_comp(struct ahc_softc *lahc, struct ahc_softc *rahc)
+ahc_linux_release(struct Scsi_Host * host)
 {
-	int	value;
-	int	rvalue;
-	int	lvalue;
-
-	/*
-	 * Under Linux, cards are ordered as follows:
-	 *	1) VLB/EISA BIOS enabled devices sorted by BIOS address.
-	 *	2) PCI devices with BIOS enabled sorted by bus/slot/func.
-	 *	3) All remaining VLB/EISA devices sorted by ioport.
-	 *	4) All remaining PCI devices sorted by bus/slot/func.
-	 */
-	value = (lahc->flags & AHC_BIOS_ENABLED)
-	      - (rahc->flags & AHC_BIOS_ENABLED);
-	if (value != 0)
-		/* Controllers with BIOS enabled have a *higher* priority */
-		return (-value);
-
-	/*
-	 * Same BIOS setting, now sort based on bus type.
-	 * EISA and VL controllers sort together.  EISA/VL
-	 * have higher priority than PCI.
-	 */
-	rvalue = (rahc->chip & AHC_BUS_MASK);
- 	if (rvalue == AHC_VL)
-		rvalue = AHC_EISA;
-	lvalue = (lahc->chip & AHC_BUS_MASK);
- 	if (lvalue == AHC_VL)
-		lvalue = AHC_EISA;
-	value = lvalue - rvalue;
-	if (value != 0)
-		return (value);
+	struct ahc_softc *ahc;
+	u_long l;
 
-	/* Still equal.  Sort by BIOS address, ioport, or bus/slot/func. */
-	switch (rvalue) {
-	case AHC_PCI:
-	{
-		char primary_channel;
+	ahc_list_lock(&l);
+	if (host != NULL) {
 
-		if (aic7xxx_reverse_scan != 0)
-			value = ahc_get_pci_bus(rahc->dev_softc)
-			      - ahc_get_pci_bus(lahc->dev_softc);
-		else
-			value = ahc_get_pci_bus(lahc->dev_softc)
-			      - ahc_get_pci_bus(rahc->dev_softc);
-		if (value != 0)
-			break;
-		if (aic7xxx_reverse_scan != 0)
-			value = ahc_get_pci_slot(rahc->dev_softc)
-			      - ahc_get_pci_slot(lahc->dev_softc);
-		else
-			value = ahc_get_pci_slot(lahc->dev_softc)
-			      - ahc_get_pci_slot(rahc->dev_softc);
-		if (value != 0)
-			break;
 		/*
-		 * On multi-function devices, the user can choose
-		 * to have function 1 probed before function 0.
-		 * Give whichever channel is the primary channel
-		 * the lowest priority.
+		 * We should be able to just perform
+		 * the free directly, but check our
+		 * list for extra sanity.
 		 */
-		primary_channel = (lahc->flags & AHC_PRIMARY_CHANNEL) + 'A';
-		value = 1;
-		if (lahc->channel == primary_channel)
-			value = -1;
-		break;
-	}
-	case AHC_EISA:
-		if ((rahc->flags & AHC_BIOS_ENABLED) != 0) {
-			value = lahc->platform_data->bios_address
-			      - rahc->platform_data->bios_address; 
-		} else {
-			value = lahc->bsh.ioport
-			      - rahc->bsh.ioport; 
+		ahc = ahc_find_softc(*(struct ahc_softc **)host->hostdata);
+		if (ahc != NULL) {
+			u_long s;
+
+			ahc_lock(ahc, &s);
+			ahc_intr_enable(ahc, FALSE);
+			ahc_unlock(ahc, &s);
+			ahc_free(ahc);
 		}
-		break;
-	default:
-		panic("ahc_softc_sort: invalid bus type");
 	}
-	return (value);
+	ahc_list_unlock(&l);
+	return (0);
 }
+#endif
 
-static void
-ahc_linux_setup_tag_info(char *p, char *end)
+/*
+ * Return a string describing the driver.
+ */
+static const char *
+ahc_linux_info(struct Scsi_Host *host)
 {
-	char	*base;
-	char	*tok;
-	char	*tok_end;
-	char	*tok_end2;
-	int      i;
-	int      instance;
-	int	 targ;
-	int	 done;
-	char	 tok_list[] = {'.', ',', '{', '}', '\0'};
+	static char buffer[512];
+	char	ahc_info[256];
+	char   *bp;
+	struct ahc_softc *ahc;
 
-	if (*p != ':')
-		return;
+	bp = &buffer[0];
+	ahc = *(struct ahc_softc **)host->hostdata;
+	memset(bp, 0, sizeof(buffer));
+	strcpy(bp, "Adaptec AIC7XXX EISA/VLB/PCI SCSI HBA DRIVER, Rev ");
+	strcat(bp, AIC7XXX_DRIVER_VERSION);
+	strcat(bp, "\n");
+	strcat(bp, "        <");
+	strcat(bp, ahc->description);
+	strcat(bp, ">\n");
+	strcat(bp, "        ");
+	ahc_controller_info(ahc, ahc_info);
+	strcat(bp, ahc_info);
+	strcat(bp, "\n");
 
-	instance = -1;
-	targ = -1;
-	done = FALSE;
-	base = p;
-	/* Forward us just past the ':' */
-	tok = base + 1;
-	tok_end = strchr(tok, '\0');
-	if (tok_end < end)
-		*tok_end = ',';
-	while (!done) {
-		switch (*tok) {
-		case '{':
-			if (instance == -1)
-				instance = 0;
-			else if (targ == -1)
-				targ = 0;
-			tok++;
-			break;
-		case '}':
-			if (targ != -1)
-				targ = -1;
-			else if (instance != -1)
-				instance = -1;
-			tok++;
-			break;
-		case ',':
-		case '.':
-			if (instance == -1)
-				done = TRUE;
-			else if (targ >= 0)
-				targ++;
-			else if (instance >= 0)
-				instance++;
-			if ((targ >= AHC_NUM_TARGETS) ||
-			    (instance >= NUM_ELEMENTS(aic7xxx_tag_info)))
-				done = TRUE;
-			tok++;
-			if (!done) {
-				base = tok;
-			}
-			break;
-		case '\0':
-			done = TRUE;
-			break;
-		default:
-			done = TRUE;
-			tok_end = strchr(tok, '\0');
-			for (i = 0; tok_list[i]; i++) {
-				tok_end2 = strchr(tok, tok_list[i]);
-				if ((tok_end2) && (tok_end2 < tok_end)) {
-					tok_end = tok_end2;
-					done = FALSE;
-				}
-			}
-			if ((instance >= 0) && (targ >= 0)
-			 && (instance < NUM_ELEMENTS(aic7xxx_tag_info))
-			 && (targ < AHC_NUM_TARGETS)) {
-				aic7xxx_tag_info[instance].tag_commands[targ] =
-				    simple_strtoul(tok, NULL, 0) & 0xff;
-			}
-			tok = tok_end;
-			break;
-		}
-	}
-	while ((p != base) && (p != NULL))
-		p = strtok(NULL, ",.");
+	return (bp);
 }
 
 /*
- * Handle Linux boot parameters. This routine allows for assigning a value
- * to a parameter with a ':' between the parameter and the value.
- * ie. aic7xxx=stpwlev:1,extended
+ * Queue an SCB to the controller.
  */
-int
-aic7xxx_setup(char *s)
+static int
+ahc_linux_queue(Scsi_Cmnd * cmd, void (*scsi_done) (Scsi_Cmnd *))
 {
-	int	i, n;
-	char   *p;
-	char   *end;
+	struct	 ahc_softc *ahc;
+	struct	 ahc_linux_device *dev;
+	u_long	 flags;
 
-	static struct {
-		const char *name;
-		uint32_t *flag;
-	} options[] = {
-		{ "extended", &aic7xxx_extended },
-		{ "no_reset", &aic7xxx_no_reset },
-		{ "verbose", &aic7xxx_verbose },
-		{ "reverse_scan", &aic7xxx_reverse_scan },
-		{ "no_probe", &aic7xxx_no_probe },
-		{ "periodic_otag", &aic7xxx_periodic_otag },
-		{ "pci_parity", &aic7xxx_pci_parity },
-		{ "seltime", &aic7xxx_seltime },
-		{ "tag_info", NULL }
-	};
+	ahc = *(struct ahc_softc **)cmd->device->host->hostdata;
 
-	end = strchr(s, '\0');
+	/*
+	 * Save the callback on completion function.
+	 */
+	cmd->scsi_done = scsi_done;
 
-	for (p = strtok(s, ",."); p; p = strtok(NULL, ",.")) {
-		for (i = 0; i < NUM_ELEMENTS(options); i++) {
-			n = strlen(options[i].name);
+	ahc_midlayer_entrypoint_lock(ahc, &flags);
 
-			if (strncmp(options[i].name, p, n) != 0)
-				continue;
+	/*
+	 * Close the race of a command that was in the process of
+	 * being queued to us just as our simq was frozen.  Let
+	 * DV commands through so long as we are only frozen to
+	 * perform DV.
+	 */
+	if (ahc->platform_data->qfrozen != 0
+	 && AHC_DV_CMD(cmd) == 0) {
 
-			if (strncmp(p, "tag_info", n) == 0) {
-				ahc_linux_setup_tag_info(p + n, end);
-			} else if (p[n] == ':') {
-				*(options[i].flag) =
-				    simple_strtoul(p + n + 1, NULL, 0);
-			} else if (!strncmp(p, "verbose", n)) {
-				*(options[i].flag) = 1;
-			} else {
-				*(options[i].flag) = ~(*(options[i].flag));
-			}
-			break;
-		}
+		ahc_cmd_set_transaction_status(cmd, CAM_REQUEUE_REQ);
+		ahc_linux_queue_cmd_complete(ahc, cmd);
+		ahc_schedule_completeq(ahc);
+		ahc_midlayer_entrypoint_unlock(ahc, &flags);
+		return (0);
 	}
-	return 1;
+	dev = ahc_linux_get_device(ahc, cmd->device->channel, cmd->device->id,
+				   cmd->device->lun, /*alloc*/TRUE);
+	if (dev == NULL) {
+		ahc_cmd_set_transaction_status(cmd, CAM_RESRC_UNAVAIL);
+		ahc_linux_queue_cmd_complete(ahc, cmd);
+		ahc_schedule_completeq(ahc);
+		ahc_midlayer_entrypoint_unlock(ahc, &flags);
+		printf("%s: aic7xxx_linux_queue - Unable to allocate device!\n",
+		       ahc_name(ahc));
+		return (0);
+	}
+	cmd->result = CAM_REQ_INPROG << 16;
+	TAILQ_INSERT_TAIL(&dev->busyq, (struct ahc_cmd *)cmd, acmd_links.tqe);
+	if ((dev->flags & AHC_DEV_ON_RUN_LIST) == 0) {
+		TAILQ_INSERT_TAIL(&ahc->platform_data->device_runq, dev, links);
+		dev->flags |= AHC_DEV_ON_RUN_LIST;
+		ahc_linux_run_device_queues(ahc);
+	}
+	ahc_midlayer_entrypoint_unlock(ahc, &flags);
+	return (0);
 }
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
-__setup("aic7xxx=", aic7xxx_setup);
-#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static int
+ahc_linux_slave_alloc(Scsi_Device *device)
+{
+	struct	ahc_softc *ahc;
 
-int aic7xxx_verbose;
+	ahc = *((struct ahc_softc **)device->host->hostdata);
+	if (bootverbose)
+		printf("%s: Slave Alloc %d\n", ahc_name(ahc), device->id);
+	return (0);
+}
 
-/*
- * Try to detect an Adaptec 7XXX controller.
- */
-int
-ahc_linux_detect(Scsi_Host_Template *template)
+static int
+ahc_linux_slave_configure(Scsi_Device *device)
 {
 	struct	ahc_softc *ahc;
-	int     found;
+	struct	ahc_linux_device *dev;
+	u_long	flags;
 
+	ahc = *((struct ahc_softc **)device->host->hostdata);
+	if (bootverbose)
+		printf("%s: Slave Configure %d\n", ahc_name(ahc), device->id);
+	ahc_midlayer_entrypoint_lock(ahc, &flags);
 	/*
-	 * It is a bug that the upper layer takes
-	 * this lock just prior to calling us.
+	 * Since Linux has attached to the device, configure
+	 * it so we don't free and allocate the device
+	 * structure on every command.
 	 */
-	spin_unlock_irq(&io_request_lock);
+	dev = ahc_linux_get_device(ahc, device->channel,
+				   device->id, device->lun,
+				   /*alloc*/TRUE);
+	if (dev != NULL) {
+		dev->flags &= ~AHC_DEV_UNCONFIGURED;
+		dev->scsi_device = device;
+		ahc_linux_device_queue_depth(ahc, dev);
+	}
+	ahc_midlayer_entrypoint_unlock(ahc, &flags);
+	return (0);
+}
+
+static void
+ahc_linux_slave_destroy(Scsi_Device *device)
+{
+	struct	ahc_softc *ahc;
+	struct	ahc_linux_device *dev;
+	u_long	flags;
 
+	ahc = *((struct ahc_softc **)device->host->hostdata);
+	if (bootverbose)
+		printf("%s: Slave Destroy %d\n", ahc_name(ahc), device->id);
+	ahc_midlayer_entrypoint_lock(ahc, &flags);
+	dev = ahc_linux_get_device(ahc, device->channel,
+				   device->id, device->lun,
+					   /*alloc*/FALSE);
 	/*
-	 * Sanity checking of Linux SCSI data structures so
-	 * that some of our hacks^H^H^H^H^Hassumptions aren't
-	 * violated.
+	 * Filter out "silly" deletions of real devices by only
+	 * deleting devices that have had slave_configure()
+	 * called on them.  All other devices that have not
+	 * been configured will automatically be deleted by
+	 * the refcounting process.
 	 */
-	if (offsetof(struct ahc_cmd_internal, end)
-	  > offsetof(struct scsi_cmnd, host_scribble)) {
-		printf("ahc_linux_detect: SCSI data structures changed.\n");
-		printf("ahc_linux_detect: Unable to attach\n");
-		return (0);
+	if (dev != NULL
+	 && (dev->flags & AHC_DEV_SLAVE_CONFIGURED) != 0) {
+		dev->flags |= AHC_DEV_UNCONFIGURED;
+		if (TAILQ_EMPTY(&dev->busyq)
+		 && dev->active == 0
+	 	 && (dev->flags & AHC_DEV_TIMER_ACTIVE) == 0)
+			ahc_linux_free_device(ahc, dev);
 	}
-#ifdef MODULE
-	/*
-	 * If we've been passed any parameters, process them now.
-	 */
-	if (aic7xxx)
-		aic7xxx_setup(aic7xxx);
-	if (dummy_buffer[0] != 'P')
-		printk(KERN_WARNING
-"aic7xxx: Please read the file /usr/src/linux/drivers/scsi/README.aic7xxx\n"
-"aic7xxx: to see the proper way to specify options to the aic7xxx module\n"
-"aic7xxx: Specifically, don't use any commas when passing arguments to\n"
-"aic7xxx: insmod or else it might trash certain memory areas.\n");
+	ahc_midlayer_entrypoint_unlock(ahc, &flags);
+}
+#else
+/*
+ * Sets the queue depth for each SCSI device hanging
+ * off the input host adapter.
+ */
+static void
+ahc_linux_select_queue_depth(struct Scsi_Host *host, Scsi_Device *scsi_devs)
+{
+	Scsi_Device *device;
+	Scsi_Device *ldev;
+	struct	ahc_softc *ahc;
+	u_long	flags;
+
+	ahc = *((struct ahc_softc **)host->hostdata);
+	ahc_lock(ahc, &flags);
+	for (device = scsi_devs; device != NULL; device = device->next) {
+
+		/*
+		 * Watch out for duplicate devices.  This works around
+		 * some quirks in how the SCSI scanning code does its
+		 * device management.
+		 */
+		for (ldev = scsi_devs; ldev != device; ldev = ldev->next) {
+			if (ldev->host == device->host
+			 && ldev->channel == device->channel
+			 && ldev->id == device->id
+			 && ldev->lun == device->lun)
+				break;
+		}
+		/* Skip duplicate. */
+		if (ldev != device)
+			continue;
+
+		if (device->host == host) {
+			struct	 ahc_linux_device *dev;
+
+			/*
+			 * Since Linux has attached to the device, configure
+			 * it so we don't free and allocate the device
+			 * structure on every command.
+			 */
+			dev = ahc_linux_get_device(ahc, device->channel,
+						   device->id, device->lun,
+						   /*alloc*/TRUE);
+			if (dev != NULL) {
+				dev->flags &= ~AHC_DEV_UNCONFIGURED;
+				dev->scsi_device = device;
+				ahc_linux_device_queue_depth(ahc, dev);
+				device->queue_depth = dev->openings
+						    + dev->active;
+				if ((dev->flags & (AHC_DEV_Q_BASIC
+						| AHC_DEV_Q_TAGGED)) == 0) {
+					/*
+					 * We allow the OS to queue 2 untagged
+					 * transactions to us at any time even
+					 * though we can only execute them
+					 * serially on the controller/device.
+					 * This should remove some latency.
+					 */
+					device->queue_depth = 2;
+				}
+			}
+		}
+	}
+	ahc_unlock(ahc, &flags);
+}
 #endif
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
-	template->proc_name = "aic7xxx";
+#if defined(__i386__)
+/*
+ * Return the disk geometry for the given SCSI device.
+ */
+static int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+ahc_linux_biosparam(struct scsi_device *sdev, struct block_device *bdev,
+		    sector_t capacity, int geom[])
+{
+	uint8_t *bh;
 #else
-	template->proc_dir = &proc_scsi_aic7xxx;
+ahc_linux_biosparam(Disk *disk, kdev_t dev, int geom[])
+{
+	struct	scsi_device *sdev = disk->device;
+	u_long	capacity = disk->capacity;
+	struct	buffer_head *bh;
+#endif
+	int	 heads;
+	int	 sectors;
+	int	 cylinders;
+	int	 ret;
+	int	 extended;
+	struct	 ahc_softc *ahc;
+	u_int	 channel;
+
+	ahc = *((struct ahc_softc **)sdev->host->hostdata);
+	channel = sdev->channel;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	bh = scsi_bios_ptable(bdev);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,17)
+	bh = bread(MKDEV(MAJOR(dev), MINOR(dev) & ~0xf), 0, block_size(dev));
+#else
+	bh = bread(MKDEV(MAJOR(dev), MINOR(dev) & ~0xf), 0, 1024);
+#endif
+
+	if (bh) {
+		ret = scsi_partsize(bh, capacity,
+				    &geom[2], &geom[0], &geom[1]);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+		kfree(bh);
+#else
+		brelse(bh);
+#endif
+		if (ret != -1)
+			return (ret);
+	}
+	heads = 64;
+	sectors = 32;
+	cylinders = aic_sector_div(capacity, heads, sectors);
+
+	if (aic7xxx_extended != 0)
+		extended = 1;
+	else if (channel == 0)
+		extended = (ahc->flags & AHC_EXTENDED_TRANS_A) != 0;
+	else
+		extended = (ahc->flags & AHC_EXTENDED_TRANS_B) != 0;
+	if (extended && cylinders >= 1024) {
+		heads = 255;
+		sectors = 63;
+		cylinders = aic_sector_div(capacity, heads, sectors);
+	}
+	geom[0] = heads;
+	geom[1] = sectors;
+	geom[2] = cylinders;
+	return (0);
+}
 #endif
 
+/*
+ * Abort the current SCSI command(s).
+ */
+static int
+ahc_linux_abort(Scsi_Cmnd *cmd)
+{
+	int error;
+
+	error = ahc_linux_queue_recovery_cmd(cmd, SCB_ABORT);
+	if (error != 0)
+		printf("aic7xxx_abort returns 0x%x\n", error);
+	return (error);
+}
+
+/*
+ * Attempt to send a target reset message to the device that timed out.
+ */
+static int
+ahc_linux_dev_reset(Scsi_Cmnd *cmd)
+{
+	int error;
+
+	error = ahc_linux_queue_recovery_cmd(cmd, SCB_DEVICE_RESET);
+	if (error != 0)
+		printf("aic7xxx_dev_reset returns 0x%x\n", error);
+	return (error);
+}
+
+/*
+ * Reset the SCSI bus.
+ */
+static int
+ahc_linux_bus_reset(Scsi_Cmnd *cmd)
+{
+	struct ahc_softc *ahc;
+	u_long s;
+	int    found;
+
+	ahc = *(struct ahc_softc **)cmd->device->host->hostdata;
+	ahc_midlayer_entrypoint_lock(ahc, &s);
+	found = ahc_reset_channel(ahc, cmd->device->channel + 'A',
+				  /*initiate reset*/TRUE);
+	ahc_linux_run_complete_queue(ahc);
+	ahc_midlayer_entrypoint_unlock(ahc, &s);
+
+	if (bootverbose)
+		printf("%s: SCSI bus reset delivered. "
+		       "%d SCBs aborted.\n", ahc_name(ahc), found);
+
+	return SUCCESS;
+}
+
+Scsi_Host_Template aic7xxx_driver_template = {
+	.module			= THIS_MODULE,
+	.name			= "aic7xxx",
+	.proc_info		= ahc_linux_proc_info,
+	.info			= ahc_linux_info,
+	.queuecommand		= ahc_linux_queue,
+	.eh_abort_handler	= ahc_linux_abort,
+	.eh_device_reset_handler = ahc_linux_dev_reset,
+	.eh_bus_reset_handler	= ahc_linux_bus_reset,
+#if defined(__i386__)
+	.bios_param		= ahc_linux_biosparam,
+#endif
+	.can_queue		= AHC_MAX_QUEUE,
+	.this_id		= -1,
+	.cmd_per_lun		= 2,
+	.use_clustering		= ENABLE_CLUSTERING,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,7)
 	/*
 	 * We can only map 16MB per-SG
 	 * so create a sector limit of
 	 * "16MB" in 2K sectors.
 	 */
-	template->max_sectors = 8192;
+	.max_sectors		= 8192,
 #endif
-
-	/*
-	 * Initialize our softc list lock prior to
-	 * probing for any adapters.
-	 */
-	ahc_list_lockinit();
-
-#ifdef CONFIG_PCI
-	ahc_linux_pci_probe(template);
+#if defined CONFIG_HIGHIO || LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,10)
+/* Assume RedHat Distribution with its different HIGHIO conventions. */
+	.can_dma_32		= 1,
+	.single_sg_okay		= 1,
+#else
+	.highmem_io		= 1,
+#endif
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	.slave_alloc		= ahc_linux_slave_alloc,
+	.slave_configure	= ahc_linux_slave_configure,
+	.slave_destroy		= ahc_linux_slave_destroy,
+#else
+	.detect			= ahc_linux_detect,
+	.release		= ahc_linux_release,
+	.select_queue_depths	= ahc_linux_select_queue_depth,
+	.use_new_eh_code	= 1,
 #endif
+};
 
-	if (aic7xxx_no_probe == 0)
-		aic7770_linux_probe(template);
+/**************************** Tasklet Handler *********************************/
 
-	/*
-	 * Register with the SCSI layer all
-	 * controllers we've found.
-	 */
-	spin_lock_irq(&io_request_lock);
-	found = 0;
-	TAILQ_FOREACH(ahc, &ahc_tailq, links) {
+/*
+ * In 2.4.X and above, this routine is called from a tasklet,
+ * so we must re-acquire our lock prior to executing this code.
+ * In all prior kernels, ahc_schedule_runq() calls this routine
+ * directly and ahc_schedule_runq() is called with our lock held.
+ */
+static void
+ahc_runq_tasklet(unsigned long data)
+{
+	struct ahc_softc* ahc;
+	struct ahc_linux_device *dev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	u_long flags;
+#endif
 
-		if (ahc_linux_register_host(ahc, template) == 0)
-			found++;
+	ahc = (struct ahc_softc *)data;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	ahc_lock(ahc, &flags);
+#endif
+	while ((dev = ahc_linux_next_device_to_run(ahc)) != NULL) {
+	
+		TAILQ_REMOVE(&ahc->platform_data->device_runq, dev, links);
+		dev->flags &= ~AHC_DEV_ON_RUN_LIST;
+		ahc_linux_check_device_queue(ahc, dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+		/* Yeild to our interrupt handler */
+		ahc_unlock(ahc, &flags);
+		ahc_lock(ahc, &flags);
+#endif
 	}
-	aic7xxx_detect_complete++;
-	return (found);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	ahc_unlock(ahc, &flags);
+#endif
 }
 
+/******************************** Macros **************************************/
+#define BUILD_SCSIID(ahc, cmd)						    \
+	((((cmd)->device->id << TID_SHIFT) & TID)			    \
+	| (((cmd)->device->channel == 0) ? (ahc)->our_id : (ahc)->our_id_b) \
+	| (((cmd)->device->channel == 0) ? 0 : TWIN_CHNLB))
+
+/******************************** Bus DMA *************************************/
 int
-ahc_linux_register_host(struct ahc_softc *ahc, Scsi_Host_Template *template)
+ahc_dma_tag_create(struct ahc_softc *ahc, bus_dma_tag_t parent,
+		   bus_size_t alignment, bus_size_t boundary,
+		   bus_addr_t lowaddr, bus_addr_t highaddr,
+		   bus_dma_filter_t *filter, void *filterarg,
+		   bus_size_t maxsize, int nsegments,
+		   bus_size_t maxsegsz, int flags, bus_dma_tag_t *ret_tag)
 {
-	char  buf[80];
-	struct Scsi_Host *host;
-	char *new_name;
-	u_long s;
-
+	bus_dma_tag_t dmat;
 
-	template->name = ahc->description;
-	host = scsi_register(template, sizeof(struct ahc_softc *));
-	if (host == NULL)
+	dmat = malloc(sizeof(*dmat), M_DEVBUF, M_NOWAIT);
+	if (dmat == NULL)
 		return (ENOMEM);
 
-	ahc_lock(ahc, &s);
-	*((struct ahc_softc **)host->hostdata) = ahc;
-	ahc->platform_data->host = host;
-	host->can_queue = AHC_MAX_QUEUE;
-	host->cmd_per_lun = 2;
-	host->sg_tablesize = AHC_NSEG;
-	host->select_queue_depths = ahc_linux_select_queue_depth;
-	/* XXX No way to communicate the ID for multiple channels */
-	host->this_id = ahc->our_id;
-	host->irq = ahc->platform_data->irq;
-	host->max_id = (ahc->features & AHC_WIDE) ? 16 : 8;
-	host->max_lun = AHC_NUM_LUNS;
-	host->max_channel = (ahc->features & AHC_TWIN) ? 1 : 0;
-	ahc_set_unit(ahc, ahc_linux_next_unit());
-	sprintf(buf, "scsi%d", host->host_no);
-	new_name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
-	if (new_name != NULL) {
-		strcpy(new_name, buf);
-		ahc_set_name(ahc, new_name);
-	}
-	host->unique_id = ahc->unit;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,4)
-	scsi_set_pci_device(host, ahc->dev_softc);
-#endif
-	ahc_linux_initialize_scsi_bus(ahc);
-	ahc_unlock(ahc, &s);
+	/*
+	 * Linux is very simplistic about DMA memory.  For now don't
+	 * maintain all specification information.  Once Linux supplies
+	 * better facilities for doing these operations, or the
+	 * needs of this particular driver change, we might need to do
+	 * more here.
+	 */
+	dmat->alignment = alignment;
+	dmat->boundary = boundary;
+	dmat->maxsize = maxsize;
+	*ret_tag = dmat;
 	return (0);
 }
 
-uint64_t
-ahc_linux_get_memsize()
+void
+ahc_dma_tag_destroy(struct ahc_softc *ahc, bus_dma_tag_t dmat)
 {
-	struct sysinfo si;
-
-	si_meminfo(&si);
-	return (si.totalram << PAGE_SHIFT);
+	free(dmat, M_DEVBUF);
 }
 
-/*
- * Find the smallest available unit number to use
- * for a new device.  We don't just use a static
- * count to handle the "repeated hot-(un)plug"
- * scenario.
- */
-static int
-ahc_linux_next_unit()
+int
+ahc_dmamem_alloc(struct ahc_softc *ahc, bus_dma_tag_t dmat, void** vaddr,
+		 int flags, bus_dmamap_t *mapp)
 {
-	struct ahc_softc *ahc;
-	int unit;
+	bus_dmamap_t map;
 
-	unit = 0;
-retry:
-	TAILQ_FOREACH(ahc, &ahc_tailq, links) {
-		if (ahc->unit == unit) {
-			unit++;
-			goto retry;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	map = malloc(sizeof(*map), M_DEVBUF, M_NOWAIT);
+	if (map == NULL)
+		return (ENOMEM);
+	/*
+	 * Although we can dma data above 4GB, our
+	 * "consistent" memory is below 4GB for
+	 * space efficiency reasons (only need a 4byte
+	 * address).  For this reason, we have to reset
+	 * our dma mask when doing allocations.
+	 */
+	if (ahc->dev_softc != NULL)
+		ahc_pci_set_dma_mask(ahc->dev_softc, 0xFFFFFFFF);
+	*vaddr = pci_alloc_consistent(ahc->dev_softc,
+				      dmat->maxsize, &map->bus_addr);
+	if (ahc->dev_softc != NULL)
+		ahc_pci_set_dma_mask(ahc->dev_softc,
+				     ahc->platform_data->hw_dma_mask);
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0) */
+	/*
+	 * At least in 2.2.14, malloc is a slab allocator so all
+	 * allocations are aligned.  We assume for these kernel versions
+	 * that all allocations will be bellow 4Gig, physically contiguous,
+	 * and accessible via DMA by the controller.
+	 */
+	map = NULL; /* No additional information to store */
+	*vaddr = malloc(dmat->maxsize, M_DEVBUF, M_NOWAIT);
+#endif
+	if (*vaddr == NULL)
+		return (ENOMEM);
+	*mapp = map;
+	return(0);
+}
+
+void
+ahc_dmamem_free(struct ahc_softc *ahc, bus_dma_tag_t dmat,
+		void* vaddr, bus_dmamap_t map)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	pci_free_consistent(ahc->dev_softc, dmat->maxsize,
+			    vaddr, map->bus_addr);
+#else
+	free(vaddr, M_DEVBUF);
+#endif
+}
+
+int
+ahc_dmamap_load(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map,
+		void *buf, bus_size_t buflen, bus_dmamap_callback_t *cb,
+		void *cb_arg, int flags)
+{
+	/*
+	 * Assume for now that this will only be used during
+	 * initialization and not for per-transaction buffer mapping.
+	 */
+	bus_dma_segment_t stack_sg;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	stack_sg.ds_addr = map->bus_addr;
+#else
+#define VIRT_TO_BUS(a) (uint32_t)virt_to_bus((void *)(a))
+	stack_sg.ds_addr = VIRT_TO_BUS(buf);
+#endif
+	stack_sg.ds_len = dmat->maxsize;
+	cb(cb_arg, &stack_sg, /*nseg*/1, /*error*/0);
+	return (0);
+}
+
+void
+ahc_dmamap_destroy(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map)
+{
+	/*
+	 * The map may is NULL in our < 2.3.X implementation.
+	 */
+	if (map != NULL)
+		free(map, M_DEVBUF);
+}
+
+int
+ahc_dmamap_unload(struct ahc_softc *ahc, bus_dma_tag_t dmat, bus_dmamap_t map)
+{
+	/* Nothing to do */
+	return (0);
+}
+
+/********************* Platform Dependent Functions ***************************/
+/*
+ * Compare "left hand" softc with "right hand" softc, returning:
+ * < 0 - lahc has a lower priority than rahc
+ *   0 - Softcs are equal
+ * > 0 - lahc has a higher priority than rahc
+ */
+int
+ahc_softc_comp(struct ahc_softc *lahc, struct ahc_softc *rahc)
+{
+	int	value;
+	int	rvalue;
+	int	lvalue;
+
+	/*
+	 * Under Linux, cards are ordered as follows:
+	 *	1) VLB/EISA BIOS enabled devices sorted by BIOS address.
+	 *	2) PCI devices with BIOS enabled sorted by bus/slot/func.
+	 *	3) All remaining VLB/EISA devices sorted by ioport.
+	 *	4) All remaining PCI devices sorted by bus/slot/func.
+	 */
+	value = (lahc->flags & AHC_BIOS_ENABLED)
+	      - (rahc->flags & AHC_BIOS_ENABLED);
+	if (value != 0)
+		/* Controllers with BIOS enabled have a *higher* priority */
+		return (value);
+
+	/*
+	 * Same BIOS setting, now sort based on bus type.
+	 * EISA and VL controllers sort together.  EISA/VL
+	 * have higher priority than PCI.
+	 */
+	rvalue = (rahc->chip & AHC_BUS_MASK);
+ 	if (rvalue == AHC_VL)
+		rvalue = AHC_EISA;
+	lvalue = (lahc->chip & AHC_BUS_MASK);
+ 	if (lvalue == AHC_VL)
+		lvalue = AHC_EISA;
+	value = rvalue - lvalue;
+	if (value != 0)
+		return (value);
+
+	/* Still equal.  Sort by BIOS address, ioport, or bus/slot/func. */
+	switch (rvalue) {
+	case AHC_PCI:
+	{
+		char primary_channel;
+
+		if (aic7xxx_reverse_scan != 0)
+			value = ahc_get_pci_bus(lahc->dev_softc)
+			      - ahc_get_pci_bus(rahc->dev_softc);
+		else
+			value = ahc_get_pci_bus(rahc->dev_softc)
+			      - ahc_get_pci_bus(lahc->dev_softc);
+		if (value != 0)
+			break;
+		if (aic7xxx_reverse_scan != 0)
+			value = ahc_get_pci_slot(lahc->dev_softc)
+			      - ahc_get_pci_slot(rahc->dev_softc);
+		else
+			value = ahc_get_pci_slot(rahc->dev_softc)
+			      - ahc_get_pci_slot(lahc->dev_softc);
+		if (value != 0)
+			break;
+		/*
+		 * On multi-function devices, the user can choose
+		 * to have function 1 probed before function 0.
+		 * Give whichever channel is the primary channel
+		 * the highest priority.
+		 */
+		primary_channel = (lahc->flags & AHC_PRIMARY_CHANNEL) + 'A';
+		value = -1;
+		if (lahc->channel == primary_channel)
+			value = 1;
+		break;
+	}
+	case AHC_EISA:
+		if ((rahc->flags & AHC_BIOS_ENABLED) != 0) {
+			value = rahc->platform_data->bios_address
+			      - lahc->platform_data->bios_address; 
+		} else {
+			value = rahc->bsh.ioport
+			      - lahc->bsh.ioport; 
+		}
+		break;
+	default:
+		panic("ahc_softc_sort: invalid bus type");
+	}
+	return (value);
+}
+
+static void
+ahc_linux_setup_tag_info_global(char *p)
+{
+	int tags, i, j;
+
+	tags = simple_strtoul(p + 1, NULL, 0) & 0xff;
+	printf("Setting Global Tags= %d\n", tags);
+
+	for (i = 0; i < NUM_ELEMENTS(aic7xxx_tag_info); i++) {
+		for (j = 0; j < AHC_NUM_TARGETS; j++) {
+			aic7xxx_tag_info[i].tag_commands[j] = tags;
+		}
+	}
+}
+
+static void
+ahc_linux_setup_tag_info(u_long arg, int instance, int targ, int32_t value)
+{
+
+	if ((instance >= 0) && (targ >= 0)
+	 && (instance < NUM_ELEMENTS(aic7xxx_tag_info))
+	 && (targ < AHC_NUM_TARGETS)) {
+		aic7xxx_tag_info[instance].tag_commands[targ] = value & 0xff;
+		if (bootverbose)
+			printf("tag_info[%d:%d] = %d\n", instance, targ, value);
+	}
+}
+
+static void
+ahc_linux_setup_dv(u_long arg, int instance, int targ, int32_t value)
+{
+
+	if ((instance >= 0)
+	 && (instance < NUM_ELEMENTS(aic7xxx_dv_settings))) {
+		aic7xxx_dv_settings[instance] = value;
+		if (bootverbose)
+			printf("dv[%d] = %d\n", instance, value);
+	}
+}
+
+/*
+ * Handle Linux boot parameters. This routine allows for assigning a value
+ * to a parameter with a ':' between the parameter and the value.
+ * ie. aic7xxx=stpwlev:1,extended
+ */
+static int
+aic7xxx_setup(char *s)
+{
+	int	i, n;
+	char   *p;
+	char   *end;
+
+	static struct {
+		const char *name;
+		uint32_t *flag;
+	} options[] = {
+		{ "extended", &aic7xxx_extended },
+		{ "no_reset", &aic7xxx_no_reset },
+		{ "verbose", &aic7xxx_verbose },
+		{ "allow_memio", &aic7xxx_allow_memio},
+#ifdef AHC_DEBUG
+		{ "debug", &ahc_debug },
+#endif
+		{ "reverse_scan", &aic7xxx_reverse_scan },
+		{ "no_probe", &aic7xxx_probe_eisa_vl },
+		{ "probe_eisa_vl", &aic7xxx_probe_eisa_vl },
+		{ "periodic_otag", &aic7xxx_periodic_otag },
+		{ "pci_parity", &aic7xxx_pci_parity },
+		{ "seltime", &aic7xxx_seltime },
+		{ "tag_info", NULL },
+		{ "global_tag_depth", NULL },
+		{ "dv", NULL }
+	};
+
+	end = strchr(s, '\0');
+
+	/*
+	 * XXX ia64 gcc isn't smart enough to know that NUM_ELEMENTS
+	 * will never be 0 in this case.
+	 */
+	n = 0;
+
+	while ((p = strsep(&s, ",.")) != NULL) {
+		if (*p == '\0')
+			continue;
+		for (i = 0; i < NUM_ELEMENTS(options); i++) {
+
+			n = strlen(options[i].name);
+			if (strncmp(options[i].name, p, n) == 0)
+				break;
+		}
+		if (i == NUM_ELEMENTS(options))
+			continue;
+
+		if (strncmp(p, "global_tag_depth", n) == 0) {
+			ahc_linux_setup_tag_info_global(p + n);
+		} else if (strncmp(p, "tag_info", n) == 0) {
+			s = aic_parse_brace_option("tag_info", p + n, end,
+			    2, ahc_linux_setup_tag_info, 0);
+		} else if (strncmp(p, "dv", n) == 0) {
+			s = aic_parse_brace_option("dv", p + n, end, 1,
+			    ahc_linux_setup_dv, 0);
+		} else if (p[n] == ':') {
+			*(options[i].flag) = simple_strtoul(p + n + 1, NULL, 0);
+		} else if (strncmp(p, "verbose", n) == 0) {
+			*(options[i].flag) = 1;
+		} else {
+			*(options[i].flag) ^= 0xFFFFFFFF;
+		}
+	}
+	return 1;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,3,0)
+__setup("aic7xxx=", aic7xxx_setup);
+#endif
+
+uint32_t aic7xxx_verbose;
+
+int
+ahc_linux_register_host(struct ahc_softc *ahc, Scsi_Host_Template *template)
+{
+	char	 buf[80];
+	struct	 Scsi_Host *host;
+	char	*new_name;
+	u_long	 s;
+	u_int	 targ_offset;
+
+	template->name = ahc->description;
+	host = scsi_register(template, sizeof(struct ahc_softc *));
+	if (host == NULL)
+		return (ENOMEM);
+
+	*((struct ahc_softc **)host->hostdata) = ahc;
+	ahc_lock(ahc, &s);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	scsi_assign_lock(host, &ahc->platform_data->spin_lock);
+#elif AHC_SCSI_HAS_HOST_LOCK != 0
+	host->lock = &ahc->platform_data->spin_lock;
+#endif
+	ahc->platform_data->host = host;
+	host->can_queue = AHC_MAX_QUEUE;
+	host->cmd_per_lun = 2;
+	/* XXX No way to communicate the ID for multiple channels */
+	host->this_id = ahc->our_id;
+	host->irq = ahc->platform_data->irq;
+	host->max_id = (ahc->features & AHC_WIDE) ? 16 : 8;
+	host->max_lun = AHC_NUM_LUNS;
+	host->max_channel = (ahc->features & AHC_TWIN) ? 1 : 0;
+	host->sg_tablesize = AHC_NSEG;
+	ahc_set_unit(ahc, ahc_linux_next_unit());
+	sprintf(buf, "scsi%d", host->host_no);
+	new_name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
+	if (new_name != NULL) {
+		strcpy(new_name, buf);
+		ahc_set_name(ahc, new_name);
+	}
+	host->unique_id = ahc->unit;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,4) && \
+    LINUX_VERSION_CODE  < KERNEL_VERSION(2,5,0)
+	scsi_set_pci_device(host, ahc->dev_softc);
+#endif
+	ahc_linux_initialize_scsi_bus(ahc);
+	ahc_unlock(ahc, &s);
+	ahc->platform_data->dv_pid = kernel_thread(ahc_linux_dv_thread, ahc, 0);
+	ahc_lock(ahc, &s);
+	if (ahc->platform_data->dv_pid < 0) {
+		printf("%s: Failed to create DV thread, error= %d\n",
+		       ahc_name(ahc), ahc->platform_data->dv_pid);
+		return (-ahc->platform_data->dv_pid);
+	}
+	/*
+	 * Initially allocate *all* of our linux target objects
+	 * so that the DV thread will scan them all in parallel
+	 * just after driver initialization.  Any device that
+	 * does not exist will have its target object destroyed
+	 * by the selection timeout handler.  In the case of a
+	 * device that appears after the initial DV scan, async
+	 * negotiation will occur for the first command, and DV
+	 * will comence should that first command be successful.
+	 */
+	for (targ_offset = 0;
+	     targ_offset < host->max_id * (host->max_channel + 1);
+	     targ_offset++) {
+		u_int channel;
+		u_int target;
+
+		channel = 0;
+		target = targ_offset;
+		if (target > 7
+		 && (ahc->features & AHC_TWIN) != 0) {
+			channel = 1;
+			target &= 0x7;
+		}
+		/*
+		 * Skip our own ID.  Some Compaq/HP storage devices
+		 * have enclosure management devices that respond to
+		 * single bit selection (i.e. selecting ourselves).
+		 * It is expected that either an external application
+		 * or a modified kernel will be used to probe this
+		 * ID if it is appropriate.  To accommodate these
+		 * installations, ahc_linux_alloc_target() will allocate
+		 * for our ID if asked to do so.
+		 */
+		if ((channel == 0 && target == ahc->our_id)
+		 || (channel == 1 && target == ahc->our_id_b))
+			continue;
+
+		ahc_linux_alloc_target(ahc, channel, target);
+	}
+	ahc_intr_enable(ahc, TRUE);
+	ahc_linux_start_dv(ahc);
+	ahc_unlock(ahc, &s);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	scsi_add_host(host, (ahc->dev_softc ? &ahc->dev_softc->dev : NULL));
+#endif
+	return (0);
+}
+
+uint64_t
+ahc_linux_get_memsize(void)
+{
+	struct sysinfo si;
+
+	si_meminfo(&si);
+	return ((uint64_t)si.totalram << PAGE_SHIFT);
+}
+
+/*
+ * Find the smallest available unit number to use
+ * for a new device.  We don't just use a static
+ * count to handle the "repeated hot-(un)plug"
+ * scenario.
+ */
+static int
+ahc_linux_next_unit(void)
+{
+	struct ahc_softc *ahc;
+	int unit;
+
+	unit = 0;
+retry:
+	TAILQ_FOREACH(ahc, &ahc_tailq, links) {
+		if (ahc->unit == unit) {
+			unit++;
+			goto retry;
+		}
+	}
+	return (unit);
+}
+
+/*
+ * Place the SCSI bus into a known state by either resetting it,
+ * or forcing transfer negotiations on the next command to any
+ * target.
+ */
+void
+ahc_linux_initialize_scsi_bus(struct ahc_softc *ahc)
+{
+	int i;
+	int numtarg;
+
+	i = 0;
+	numtarg = 0;
+
+	if (aic7xxx_no_reset != 0)
+		ahc->flags &= ~(AHC_RESET_BUS_A|AHC_RESET_BUS_B);
+
+	if ((ahc->flags & AHC_RESET_BUS_A) != 0)
+		ahc_reset_channel(ahc, 'A', /*initiate_reset*/TRUE);
+	else
+		numtarg = (ahc->features & AHC_WIDE) ? 16 : 8;
+
+	if ((ahc->features & AHC_TWIN) != 0) {
+
+		if ((ahc->flags & AHC_RESET_BUS_B) != 0) {
+			ahc_reset_channel(ahc, 'B', /*initiate_reset*/TRUE);
+		} else {
+			if (numtarg == 0)
+				i = 8;
+			numtarg += 8;
+		}
+	}
+
+	/*
+	 * Force negotiation to async for all targets that
+	 * will not see an initial bus reset.
+	 */
+	for (; i < numtarg; i++) {
+		struct ahc_devinfo devinfo;
+		struct ahc_initiator_tinfo *tinfo;
+		struct ahc_tmode_tstate *tstate;
+		u_int our_id;
+		u_int target_id;
+		char channel;
+
+		channel = 'A';
+		our_id = ahc->our_id;
+		target_id = i;
+		if (i > 7 && (ahc->features & AHC_TWIN) != 0) {
+			channel = 'B';
+			our_id = ahc->our_id_b;
+			target_id = i % 8;
+		}
+		tinfo = ahc_fetch_transinfo(ahc, channel, our_id,
+					    target_id, &tstate);
+		ahc_compile_devinfo(&devinfo, our_id, target_id,
+				    CAM_LUN_WILDCARD, channel, ROLE_INITIATOR);
+		ahc_update_neg_request(ahc, &devinfo, tstate,
+				       tinfo, AHC_NEG_ALWAYS);
+	}
+	/* Give the bus some time to recover */
+	if ((ahc->flags & (AHC_RESET_BUS_A|AHC_RESET_BUS_B)) != 0) {
+		ahc_linux_freeze_simq(ahc);
+		init_timer(&ahc->platform_data->reset_timer);
+		ahc->platform_data->reset_timer.data = (u_long)ahc;
+		ahc->platform_data->reset_timer.expires =
+		    jiffies + (AIC7XXX_RESET_DELAY * HZ)/1000;
+		ahc->platform_data->reset_timer.function =
+		    ahc_linux_release_simq;
+		add_timer(&ahc->platform_data->reset_timer);
+	}
+}
+
+int
+ahc_platform_alloc(struct ahc_softc *ahc, void *platform_arg)
+{
+
+	ahc->platform_data =
+	    malloc(sizeof(struct ahc_platform_data), M_DEVBUF, M_NOWAIT);
+	if (ahc->platform_data == NULL)
+		return (ENOMEM);
+	memset(ahc->platform_data, 0, sizeof(struct ahc_platform_data));
+	TAILQ_INIT(&ahc->platform_data->completeq);
+	TAILQ_INIT(&ahc->platform_data->device_runq);
+	ahc->platform_data->irq = AHC_LINUX_NOIRQ;
+	ahc->platform_data->hw_dma_mask = 0xFFFFFFFF;
+	ahc_lockinit(ahc);
+	ahc_done_lockinit(ahc);
+	init_timer(&ahc->platform_data->completeq_timer);
+	ahc->platform_data->completeq_timer.data = (u_long)ahc;
+	ahc->platform_data->completeq_timer.function =
+	    (ahc_linux_callback_t *)ahc_linux_thread_run_complete_queue;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+	init_MUTEX_LOCKED(&ahc->platform_data->eh_sem);
+	init_MUTEX_LOCKED(&ahc->platform_data->dv_sem);
+	init_MUTEX_LOCKED(&ahc->platform_data->dv_cmd_sem);
+#else
+	ahc->platform_data->eh_sem = MUTEX_LOCKED;
+	ahc->platform_data->dv_sem = MUTEX_LOCKED;
+	ahc->platform_data->dv_cmd_sem = MUTEX_LOCKED;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+	tasklet_init(&ahc->platform_data->runq_tasklet, ahc_runq_tasklet,
+		     (unsigned long)ahc);
+#endif
+	ahc->seltime = (aic7xxx_seltime & 0x3) << 4;
+	ahc->seltime_b = (aic7xxx_seltime & 0x3) << 4;
+	if (aic7xxx_pci_parity == 0)
+		ahc->flags |= AHC_DISABLE_PCI_PERR;
+
+	return (0);
+}
+
+void
+ahc_platform_free(struct ahc_softc *ahc)
+{
+	struct ahc_linux_target *targ;
+	struct ahc_linux_device *dev;
+	int i, j;
+
+	if (ahc->platform_data != NULL) {
+		del_timer_sync(&ahc->platform_data->completeq_timer);
+		ahc_linux_kill_dv_thread(ahc);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+		tasklet_kill(&ahc->platform_data->runq_tasklet);
+#endif
+		if (ahc->platform_data->host != NULL) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+			scsi_remove_host(ahc->platform_data->host);
+#endif
+			scsi_unregister(ahc->platform_data->host);
+		}
+
+		/* destroy all of the device and target objects */
+		for (i = 0; i < AHC_NUM_TARGETS; i++) {
+			targ = ahc->platform_data->targets[i];
+			if (targ != NULL) {
+				/* Keep target around through the loop. */
+				targ->refcount++;
+				for (j = 0; j < AHC_NUM_LUNS; j++) {
+
+					if (targ->devices[j] == NULL)
+						continue;
+					dev = targ->devices[j];
+					ahc_linux_free_device(ahc, dev);
+				}
+				/*
+				 * Forcibly free the target now that
+				 * all devices are gone.
+				 */
+				ahc_linux_free_target(ahc, targ);
+ 			}
+ 		}
+
+		if (ahc->platform_data->irq != AHC_LINUX_NOIRQ)
+			free_irq(ahc->platform_data->irq, ahc);
+		if (ahc->tag == BUS_SPACE_PIO
+		 && ahc->bsh.ioport != 0)
+			release_region(ahc->bsh.ioport, 256);
+		if (ahc->tag == BUS_SPACE_MEMIO
+		 && ahc->bsh.maddr != NULL) {
+			u_long base_addr;
+
+			base_addr = (u_long)ahc->bsh.maddr;
+			base_addr &= PAGE_MASK;
+			iounmap((void *)base_addr);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
+			release_mem_region(ahc->platform_data->mem_busaddr,
+					   0x1000);
+#endif
+		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0) && \
+    LINUX_VERSION_CODE  < KERNEL_VERSION(2,5,0)
+		/*
+		 * In 2.4 we detach from the scsi midlayer before the PCI
+		 * layer invokes our remove callback.  No per-instance
+		 * detach is provided, so we must reach inside the PCI
+		 * subsystem's internals and detach our driver manually.
+		 */
+		if (ahc->dev_softc != NULL)
+			ahc->dev_softc->driver = NULL;
+#endif
+		free(ahc->platform_data, M_DEVBUF);
+	}
+}
+
+void
+ahc_platform_freeze_devq(struct ahc_softc *ahc, struct scb *scb)
+{
+	ahc_platform_abort_scbs(ahc, SCB_GET_TARGET(ahc, scb),
+				SCB_GET_CHANNEL(ahc, scb),
+				SCB_GET_LUN(scb), SCB_LIST_NULL,
+				ROLE_UNKNOWN, CAM_REQUEUE_REQ);
+}
+
+void
+ahc_platform_set_tags(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
+		      ahc_queue_alg alg)
+{
+	struct ahc_linux_device *dev;
+	int was_queuing;
+	int now_queuing;
+
+	dev = ahc_linux_get_device(ahc, devinfo->channel - 'A',
+				   devinfo->target,
+				   devinfo->lun, /*alloc*/FALSE);
+	if (dev == NULL)
+		return;
+	was_queuing = dev->flags & (AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED);
+	switch (alg) {
+	default:
+	case AHC_QUEUE_NONE:
+		now_queuing = 0;
+		break; 
+	case AHC_QUEUE_BASIC:
+		now_queuing = AHC_DEV_Q_BASIC;
+		break;
+	case AHC_QUEUE_TAGGED:
+		now_queuing = AHC_DEV_Q_TAGGED;
+		break;
+	}
+	if ((dev->flags & AHC_DEV_FREEZE_TIL_EMPTY) == 0
+	 && (was_queuing != now_queuing)
+	 && (dev->active != 0)) {
+		dev->flags |= AHC_DEV_FREEZE_TIL_EMPTY;
+		dev->qfrozen++;
+	}
+
+	dev->flags &= ~(AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED|AHC_DEV_PERIODIC_OTAG);
+	if (now_queuing) {
+		u_int usertags;
+
+		usertags = ahc_linux_user_tagdepth(ahc, devinfo);
+		if (!was_queuing) {
+			/*
+			 * Start out agressively and allow our
+			 * dynamic queue depth algorithm to take
+			 * care of the rest.
+			 */
+			dev->maxtags = usertags;
+			dev->openings = dev->maxtags - dev->active;
+		}
+		if (dev->maxtags == 0) {
+			/*
+			 * Queueing is disabled by the user.
+			 */
+			dev->openings = 1;
+		} else if (alg == AHC_QUEUE_TAGGED) {
+			dev->flags |= AHC_DEV_Q_TAGGED;
+			if (aic7xxx_periodic_otag != 0)
+				dev->flags |= AHC_DEV_PERIODIC_OTAG;
+		} else
+			dev->flags |= AHC_DEV_Q_BASIC;
+	} else {
+		/* We can only have one opening. */
+		dev->maxtags = 0;
+		dev->openings =  1 - dev->active;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	if (dev->scsi_device != NULL) {
+		switch ((dev->flags & (AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED))) {
+		case AHC_DEV_Q_BASIC:
+			scsi_adjust_queue_depth(dev->scsi_device,
+						MSG_SIMPLE_TASK,
+						dev->openings + dev->active);
+			break;
+		case AHC_DEV_Q_TAGGED:
+			scsi_adjust_queue_depth(dev->scsi_device,
+						MSG_ORDERED_TASK,
+						dev->openings + dev->active);
+			break;
+		default:
+			/*
+			 * We allow the OS to queue 2 untagged transactions to
+			 * us at any time even though we can only execute them
+			 * serially on the controller/device.  This should
+			 * remove some latency.
+			 */
+			scsi_adjust_queue_depth(dev->scsi_device,
+						/*NON-TAGGED*/0,
+						/*queue depth*/2);
+			break;
+		}
+	}
+#endif
+}
+
+int
+ahc_platform_abort_scbs(struct ahc_softc *ahc, int target, char channel,
+			int lun, u_int tag, role_t role, uint32_t status)
+{
+	int chan;
+	int maxchan;
+	int targ;
+	int maxtarg;
+	int clun;
+	int maxlun;
+	int count;
+
+	if (tag != SCB_LIST_NULL)
+		return (0);
+
+	chan = 0;
+	if (channel != ALL_CHANNELS) {
+		chan = channel - 'A';
+		maxchan = chan + 1;
+	} else {
+		maxchan = (ahc->features & AHC_TWIN) ? 2 : 1;
+	}
+	targ = 0;
+	if (target != CAM_TARGET_WILDCARD) {
+		targ = target;
+		maxtarg = targ + 1;
+	} else {
+		maxtarg = (ahc->features & AHC_WIDE) ? 16 : 8;
+	}
+	clun = 0;
+	if (lun != CAM_LUN_WILDCARD) {
+		clun = lun;
+		maxlun = clun + 1;
+	} else {
+		maxlun = AHC_NUM_LUNS;
+	}
+
+	count = 0;
+	for (; chan < maxchan; chan++) {
+
+		for (; targ < maxtarg; targ++) {
+
+			for (; clun < maxlun; clun++) {
+				struct ahc_linux_device *dev;
+				struct ahc_busyq *busyq;
+				struct ahc_cmd *acmd;
+
+				dev = ahc_linux_get_device(ahc, chan,
+							   targ, clun,
+							   /*alloc*/FALSE);
+				if (dev == NULL)
+					continue;
+
+				busyq = &dev->busyq;
+				while ((acmd = TAILQ_FIRST(busyq)) != NULL) {
+					Scsi_Cmnd *cmd;
+
+					cmd = &acmd_scsi_cmd(acmd);
+					TAILQ_REMOVE(busyq, acmd,
+						     acmd_links.tqe);
+					count++;
+					cmd->result = status << 16;
+					ahc_linux_queue_cmd_complete(ahc, cmd);
+				}
+			}
+		}
+	}
+
+	return (count);
+}
+
+static void
+ahc_linux_thread_run_complete_queue(struct ahc_softc *ahc)
+{
+	u_long flags;
+
+	ahc_lock(ahc, &flags);
+	del_timer(&ahc->platform_data->completeq_timer);
+	ahc->platform_data->flags &= ~AHC_RUN_CMPLT_Q_TIMER;
+	ahc_linux_run_complete_queue(ahc);
+	ahc_unlock(ahc, &flags);
+}
+
+static void
+ahc_linux_start_dv(struct ahc_softc *ahc)
+{
+
+	/*
+	 * Freeze the simq and signal ahc_linux_queue to not let any
+	 * more commands through.
+	 */
+	if ((ahc->platform_data->flags & AHC_DV_ACTIVE) == 0) {
+#ifdef AHC_DEBUG
+		if (ahc_debug & AHC_SHOW_DV)
+			printf("%s: Waking DV thread\n", ahc_name(ahc));
+#endif
+
+		ahc->platform_data->flags |= AHC_DV_ACTIVE;
+		ahc_linux_freeze_simq(ahc);
+
+		/* Wake up the DV kthread */
+		up(&ahc->platform_data->dv_sem);
+	}
+}
+
+static void
+ahc_linux_kill_dv_thread(struct ahc_softc *ahc)
+{
+	u_long s;
+
+	ahc_lock(ahc, &s);
+	if (ahc->platform_data->dv_pid != 0) {
+		ahc->platform_data->flags |= AHC_DV_SHUTDOWN;
+		ahc_unlock(ahc, &s);
+		up(&ahc->platform_data->dv_sem);
+
+		/*
+		 * Use the eh_sem as an indicator that the
+		 * dv thread is exiting.  Note that the dv
+		 * thread must still return after performing
+		 * the up on our semaphore before it has
+		 * completely exited this module.  Unfortunately,
+		 * there seems to be no easy way to wait for the
+		 * exit of a thread for which you are not the
+		 * parent (dv threads are parented by init).
+		 * Cross your fingers...
+		 */
+		down(&ahc->platform_data->eh_sem);
+
+		/*
+		 * Mark the dv thread as already dead.  This
+		 * avoids attempting to kill it a second time.
+		 * This is necessary because we must kill the
+		 * DV thread before calling ahc_free() in the
+		 * module shutdown case to avoid bogus locking
+		 * in the SCSI mid-layer, but we ahc_free() is
+		 * called without killing the DV thread in the
+		 * instance detach case, so ahc_platform_free()
+		 * calls us again to verify that the DV thread
+		 * is dead.
+		 */
+		ahc->platform_data->dv_pid = 0;
+	} else {
+		ahc_unlock(ahc, &s);
+	}
+}
+
+static int
+ahc_linux_dv_thread(void *data)
+{
+	struct	ahc_softc *ahc;
+	int	target;
+	u_long	s;
+
+	ahc = (struct ahc_softc *)data;
+
+#ifdef AHC_DEBUG
+	if (ahc_debug & AHC_SHOW_DV)
+		printf("Launching DV Thread\n");
+#endif
+
+	/*
+	 * Complete thread creation.
+	 */
+	lock_kernel();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	/*
+	 * Don't care about any signals.
+	 */
+	siginitsetinv(&current->blocked, 0);
+
+	daemonize();
+	sprintf(current->comm, "ahc_dv_%d", ahc->unit);
+#else
+	daemonize("ahc_dv_%d", ahc->unit);
+#endif
+	unlock_kernel();
+
+	while (1) {
+		/*
+		 * Use down_interruptible() rather than down() to
+		 * avoid inclusion in the load average.
+		 */
+		down_interruptible(&ahc->platform_data->dv_sem);
+
+		/* Check to see if we've been signaled to exit */
+		ahc_lock(ahc, &s);
+		if ((ahc->platform_data->flags & AHC_DV_SHUTDOWN) != 0) {
+			ahc_unlock(ahc, &s);
+			break;
+		}
+		ahc_unlock(ahc, &s);
+
+#ifdef AHC_DEBUG
+		if (ahc_debug & AHC_SHOW_DV)
+			printf("%s: Beginning Domain Validation\n",
+			       ahc_name(ahc));
+#endif
+
+		/*
+		 * Wait for any pending commands to drain before proceeding.
+		 */
+		ahc_lock(ahc, &s);
+		while (LIST_FIRST(&ahc->pending_scbs) != NULL) {
+			ahc->platform_data->flags |= AHC_DV_WAIT_SIMQ_EMPTY;
+			ahc_unlock(ahc, &s);
+			down_interruptible(&ahc->platform_data->dv_sem);
+			ahc_lock(ahc, &s);
+		}
+
+		/*
+		 * Wait for the SIMQ to be released so that DV is the
+		 * only reason the queue is frozen.
+		 */
+		while (AHC_DV_SIMQ_FROZEN(ahc) == 0) {
+			ahc->platform_data->flags |= AHC_DV_WAIT_SIMQ_RELEASE;
+			ahc_unlock(ahc, &s);
+			down_interruptible(&ahc->platform_data->dv_sem);
+			ahc_lock(ahc, &s);
+		}
+		ahc_unlock(ahc, &s);
+
+		for (target = 0; target < AHC_NUM_TARGETS; target++)
+			ahc_linux_dv_target(ahc, target);
+
+		ahc_lock(ahc, &s);
+		ahc->platform_data->flags &= ~AHC_DV_ACTIVE;
+		ahc_unlock(ahc, &s);
+
+		/*
+		 * Release the SIMQ so that normal commands are
+		 * allowed to continue on the bus.
+		 */
+		ahc_linux_release_simq((u_long)ahc);
+	}
+	up(&ahc->platform_data->eh_sem);
+	return (0);
+}
+
+#define AHC_LINUX_DV_INQ_SHORT_LEN	36
+#define AHC_LINUX_DV_INQ_LEN		256
+#define AHC_LINUX_DV_TIMEOUT		(HZ / 4)
+
+#define AHC_SET_DV_STATE(ahc, targ, newstate) \
+	ahc_set_dv_state(ahc, targ, newstate, __LINE__)
+
+static __inline void
+ahc_set_dv_state(struct ahc_softc *ahc, struct ahc_linux_target *targ,
+		 ahc_dv_state newstate, u_int line)
+{
+	ahc_dv_state oldstate;
+
+	oldstate = targ->dv_state;
+#ifdef AHC_DEBUG
+	if (ahc_debug & AHC_SHOW_DV)
+		printf("%s:%d: Going from state %d to state %d\n",
+		       ahc_name(ahc), line, oldstate, newstate);
+#endif
+
+	if (oldstate == newstate)
+		targ->dv_state_retry++;
+	else
+		targ->dv_state_retry = 0;
+	targ->dv_state = newstate;
+}
+
+static void
+ahc_linux_dv_target(struct ahc_softc *ahc, u_int target_offset)
+{
+	struct	 ahc_devinfo devinfo;
+	struct	 ahc_linux_target *targ;
+	struct	 scsi_cmnd *cmd;
+	struct	 scsi_device *scsi_dev;
+	struct	 scsi_sense_data *sense;
+	uint8_t *buffer;
+	u_long	 s;
+	u_int	 timeout;
+	int	 echo_size;
+
+	sense = NULL;
+	buffer = NULL;
+	echo_size = 0;
+	ahc_lock(ahc, &s);
+	targ = ahc->platform_data->targets[target_offset];
+	if (targ == NULL || (targ->flags & AHC_DV_REQUIRED) == 0) {
+		ahc_unlock(ahc, &s);
+		return;
+	}
+	ahc_compile_devinfo(&devinfo,
+			    targ->channel == 0 ? ahc->our_id : ahc->our_id_b,
+			    targ->target, /*lun*/0, targ->channel + 'A',
+			    ROLE_INITIATOR);
+#ifdef AHC_DEBUG
+	if (ahc_debug & AHC_SHOW_DV) {
+		ahc_print_devinfo(ahc, &devinfo);
+		printf("Performing DV\n");
+	}
+#endif
+
+	ahc_unlock(ahc, &s);
+
+	cmd = malloc(sizeof(struct scsi_cmnd), M_DEVBUF, M_WAITOK);
+	scsi_dev = malloc(sizeof(struct scsi_device), M_DEVBUF, M_WAITOK);
+	scsi_dev->host = ahc->platform_data->host;
+	scsi_dev->id = devinfo.target;
+	scsi_dev->lun = devinfo.lun;
+	scsi_dev->channel = devinfo.channel - 'A';
+	ahc->platform_data->dv_scsi_dev = scsi_dev;
+
+	AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_INQ_SHORT_ASYNC);
+
+	while (targ->dv_state != AHC_DV_STATE_EXIT) {
+		timeout = AHC_LINUX_DV_TIMEOUT;
+		switch (targ->dv_state) {
+		case AHC_DV_STATE_INQ_SHORT_ASYNC:
+		case AHC_DV_STATE_INQ_ASYNC:
+		case AHC_DV_STATE_INQ_ASYNC_VERIFY:
+			/*
+			 * Set things to async narrow to reduce the
+			 * chance that the INQ will fail.
+			 */
+			ahc_lock(ahc, &s);
+			ahc_set_syncrate(ahc, &devinfo, NULL, 0, 0, 0,
+					 AHC_TRANS_GOAL, /*paused*/FALSE);
+			ahc_set_width(ahc, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+				      AHC_TRANS_GOAL, /*paused*/FALSE);
+			ahc_unlock(ahc, &s);
+			timeout = 10 * HZ;
+			targ->flags &= ~AHC_INQ_VALID;
+			/* FALLTHROUGH */
+		case AHC_DV_STATE_INQ_VERIFY:
+		{
+			u_int inq_len;
+
+			if (targ->dv_state == AHC_DV_STATE_INQ_SHORT_ASYNC)
+				inq_len = AHC_LINUX_DV_INQ_SHORT_LEN;
+			else
+				inq_len = targ->inq_data->additional_length + 5;
+			ahc_linux_dv_inq(ahc, cmd, &devinfo, targ, inq_len);
+			break;
+		}
+		case AHC_DV_STATE_TUR:
+		case AHC_DV_STATE_BUSY:
+			timeout = 5 * HZ;
+			ahc_linux_dv_tur(ahc, cmd, &devinfo);
+			break;
+		case AHC_DV_STATE_REBD:
+			ahc_linux_dv_rebd(ahc, cmd, &devinfo, targ);
+			break;
+		case AHC_DV_STATE_WEB:
+			ahc_linux_dv_web(ahc, cmd, &devinfo, targ);
+			break;
+
+		case AHC_DV_STATE_REB:
+			ahc_linux_dv_reb(ahc, cmd, &devinfo, targ);
+			break;
+
+		case AHC_DV_STATE_SU:
+			ahc_linux_dv_su(ahc, cmd, &devinfo, targ);
+			timeout = 50 * HZ;
+			break;
+
+		default:
+			ahc_print_devinfo(ahc, &devinfo);
+			printf("Unknown DV state %d\n", targ->dv_state);
+			goto out;
+		}
+
+		/* Queue the command and wait for it to complete */
+		/* Abuse eh_timeout in the scsi_cmnd struct for our purposes */
+		init_timer(&cmd->eh_timeout);
+#ifdef AHC_DEBUG
+		if ((ahc_debug & AHC_SHOW_MESSAGES) != 0)
+			/*
+			 * All of the printfs during negotiation
+			 * really slow down the negotiation.
+			 * Add a bit of time just to be safe.
+			 */
+			timeout += HZ;
+#endif
+		scsi_add_timer(cmd, timeout, ahc_linux_dv_timeout);
+		/*
+		 * In 2.5.X, it is assumed that all calls from the
+		 * "midlayer" (which we are emulating) will have the
+		 * ahc host lock held.  For other kernels, the
+		 * io_request_lock must be held.
+		 */
+#if AHC_SCSI_HAS_HOST_LOCK != 0
+		ahc_lock(ahc, &s);
+#else
+		spin_lock_irqsave(&io_request_lock, s);
+#endif
+		ahc_linux_queue(cmd, ahc_linux_dv_complete);
+#if AHC_SCSI_HAS_HOST_LOCK != 0
+		ahc_unlock(ahc, &s);
+#else
+		spin_unlock_irqrestore(&io_request_lock, s);
+#endif
+		down_interruptible(&ahc->platform_data->dv_cmd_sem);
+		/*
+		 * Wait for the SIMQ to be released so that DV is the
+		 * only reason the queue is frozen.
+		 */
+		ahc_lock(ahc, &s);
+		while (AHC_DV_SIMQ_FROZEN(ahc) == 0) {
+			ahc->platform_data->flags |= AHC_DV_WAIT_SIMQ_RELEASE;
+			ahc_unlock(ahc, &s);
+			down_interruptible(&ahc->platform_data->dv_sem);
+			ahc_lock(ahc, &s);
+		}
+		ahc_unlock(ahc, &s);
+
+		ahc_linux_dv_transition(ahc, cmd, &devinfo, targ);
+	}
+
+out:
+	if ((targ->flags & AHC_INQ_VALID) != 0
+	 && ahc_linux_get_device(ahc, devinfo.channel - 'A',
+				 devinfo.target, devinfo.lun,
+				 /*alloc*/FALSE) == NULL) {
+		/*
+		 * The DV state machine failed to configure this device.  
+		 * This is normal if DV is disabled.  Since we have inquiry
+		 * data, filter it and use the "optimistic" negotiation
+		 * parameters found in the inquiry string.
+		 */
+		ahc_linux_filter_inquiry(ahc, &devinfo);
+		if ((targ->flags & (AHC_BASIC_DV|AHC_ENHANCED_DV)) != 0) {
+			ahc_print_devinfo(ahc, &devinfo);
+			printf("DV failed to configure device.  "
+			       "Please file a bug report against "
+			       "this driver.\n");
+		}
+	}
+
+	if (cmd != NULL)
+		free(cmd, M_DEVBUF);
+
+	if (ahc->platform_data->dv_scsi_dev != NULL) {
+		free(ahc->platform_data->dv_scsi_dev, M_DEVBUF);
+		ahc->platform_data->dv_scsi_dev = NULL;
+	}
+
+	ahc_lock(ahc, &s);
+	if (targ->dv_buffer != NULL) {
+		free(targ->dv_buffer, M_DEVBUF);
+		targ->dv_buffer = NULL;
+	}
+	if (targ->dv_buffer1 != NULL) {
+		free(targ->dv_buffer1, M_DEVBUF);
+		targ->dv_buffer1 = NULL;
+	}
+	targ->flags &= ~AHC_DV_REQUIRED;
+	if (targ->refcount == 0)
+		ahc_linux_free_target(ahc, targ);
+	ahc_unlock(ahc, &s);
+}
+
+static void
+ahc_linux_dv_transition(struct ahc_softc *ahc, struct scsi_cmnd *cmd,
+			struct ahc_devinfo *devinfo,
+			struct ahc_linux_target *targ)
+{
+	u_int32_t status;
+
+	status = aic_error_action(cmd, targ->inq_data,
+				  ahc_cmd_get_transaction_status(cmd),
+				  ahc_cmd_get_scsi_status(cmd));
+	
+#ifdef AHC_DEBUG
+	if (ahc_debug & AHC_SHOW_DV) {
+		ahc_print_devinfo(ahc, devinfo);
+		printf("Entering ahc_linux_dv_transition, state= %d, "
+		       "status= 0x%x, cmd->result= 0x%x\n", targ->dv_state,
+		       status, cmd->result);
+	}
+#endif
+
+	switch (targ->dv_state) {
+	case AHC_DV_STATE_INQ_SHORT_ASYNC:
+	case AHC_DV_STATE_INQ_ASYNC:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+		{
+			AHC_SET_DV_STATE(ahc, targ, targ->dv_state+1);
+			break;
+		}
+		case SS_INQ_REFRESH:
+			AHC_SET_DV_STATE(ahc, targ,
+					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		case SS_TUR:
+		case SS_RETRY:
+			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
+			if (ahc_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ)
+				targ->dv_state_retry--;
+			if ((status & SS_ERRMASK) == EBUSY)
+				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_BUSY);
+			if (targ->dv_state_retry < 10)
+				break;
+			/* FALLTHROUGH */
+		default:
+			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+#ifdef AHC_DEBUG
+			if (ahc_debug & AHC_SHOW_DV) {
+				ahc_print_devinfo(ahc, devinfo);
+				printf("Failed DV inquiry, skipping\n");
+			}
+#endif
+			break;
+		}
+		break;
+	case AHC_DV_STATE_INQ_ASYNC_VERIFY:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+		{
+			u_int xportflags;
+			u_int spi3data;
+
+			if (memcmp(targ->inq_data, targ->dv_buffer,
+				   AHC_LINUX_DV_INQ_LEN) != 0) {
+				/*
+				 * Inquiry data must have changed.
+				 * Try from the top again.
+				 */
+				AHC_SET_DV_STATE(ahc, targ,
+						 AHC_DV_STATE_INQ_SHORT_ASYNC);
+				break;
+			}
+
+			AHC_SET_DV_STATE(ahc, targ, targ->dv_state+1);
+			targ->flags |= AHC_INQ_VALID;
+			if (ahc_linux_user_dv_setting(ahc) == 0)
+				break;
+
+			xportflags = targ->inq_data->flags;
+			if ((xportflags & (SID_Sync|SID_WBus16)) == 0)
+				break;
+
+			spi3data = targ->inq_data->spi3data;
+			switch (spi3data & SID_SPI_CLOCK_DT_ST) {
+			default:
+			case SID_SPI_CLOCK_ST:
+				/* Assume only basic DV is supported. */
+				targ->flags |= AHC_BASIC_DV;
+				break;
+			case SID_SPI_CLOCK_DT:
+			case SID_SPI_CLOCK_DT_ST:
+				targ->flags |= AHC_ENHANCED_DV;
+				break;
+			}
+			break;
+		}
+		case SS_INQ_REFRESH:
+			AHC_SET_DV_STATE(ahc, targ,
+					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		case SS_TUR:
+		case SS_RETRY:
+			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
+			if (ahc_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ)
+				targ->dv_state_retry--;
+
+			if ((status & SS_ERRMASK) == EBUSY)
+				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_BUSY);
+			if (targ->dv_state_retry < 10)
+				break;
+			/* FALLTHROUGH */
+		default:
+			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+#ifdef AHC_DEBUG
+			if (ahc_debug & AHC_SHOW_DV) {
+				ahc_print_devinfo(ahc, devinfo);
+				printf("Failed DV inquiry, skipping\n");
+			}
+#endif
+			break;
+		}
+		break;
+	case AHC_DV_STATE_INQ_VERIFY:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+		{
+
+			if (memcmp(targ->inq_data, targ->dv_buffer,
+				   AHC_LINUX_DV_INQ_LEN) == 0) {
+				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+				break;
+			}
+#ifdef AHC_DEBUG
+			if (ahc_debug & AHC_SHOW_DV) {
+				int i;
+
+				ahc_print_devinfo(ahc, devinfo);
+				printf("Inquiry buffer mismatch:");
+				for (i = 0; i < AHC_LINUX_DV_INQ_LEN; i++) {
+					if ((i & 0xF) == 0)
+						printf("\n        ");
+					printf("0x%x:0x0%x ",
+					       ((uint8_t *)targ->inq_data)[i], 
+					       targ->dv_buffer[i]);
+				}
+				printf("\n");
+			}
+#endif
+
+			if (ahc_linux_fallback(ahc, devinfo) != 0) {
+				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+				break;
+			}
+			/*
+			 * Do not count "falling back"
+			 * against our retries.
+			 */
+			targ->dv_state_retry = 0;
+			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
+			break;
+		}
+		case SS_INQ_REFRESH:
+			AHC_SET_DV_STATE(ahc, targ,
+					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		case SS_TUR:
+		case SS_RETRY:
+			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
+			if (ahc_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ) {
+				targ->dv_state_retry--;
+			} else if ((status & SSQ_FALLBACK) != 0) {
+				if (ahc_linux_fallback(ahc, devinfo) != 0) {
+					AHC_SET_DV_STATE(ahc, targ,
+							 AHC_DV_STATE_EXIT);
+					break;
+				}
+				/*
+				 * Do not count "falling back"
+				 * against our retries.
+				 */
+				targ->dv_state_retry = 0;
+			} else if ((status & SS_ERRMASK) == EBUSY)
+				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_BUSY);
+			if (targ->dv_state_retry < 10)
+				break;
+			/* FALLTHROUGH */
+		default:
+			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+#ifdef AHC_DEBUG
+			if (ahc_debug & AHC_SHOW_DV) {
+				ahc_print_devinfo(ahc, devinfo);
+				printf("Failed DV inquiry, skipping\n");
+			}
+#endif
+			break;
+		}
+		break;
+
+	case AHC_DV_STATE_TUR:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+			if ((targ->flags & AHC_BASIC_DV) != 0) {
+				ahc_linux_filter_inquiry(ahc, devinfo);
+				AHC_SET_DV_STATE(ahc, targ,
+						 AHC_DV_STATE_INQ_VERIFY);
+			} else if ((targ->flags & AHC_ENHANCED_DV) != 0) {
+				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_REBD);
+			} else {
+				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			}
+			break;
+		case SS_RETRY:
+		case SS_TUR:
+			if ((status & SS_ERRMASK) == EBUSY) {
+				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_BUSY);
+				break;
+			}
+			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
+			if (ahc_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ) {
+				targ->dv_state_retry--;
+			} else if ((status & SSQ_FALLBACK) != 0) {
+				if (ahc_linux_fallback(ahc, devinfo) != 0) {
+					AHC_SET_DV_STATE(ahc, targ,
+							 AHC_DV_STATE_EXIT);
+					break;
+				}
+				/*
+				 * Do not count "falling back"
+				 * against our retries.
+				 */
+				targ->dv_state_retry = 0;
+			}
+			if (targ->dv_state_retry >= 10) {
+#ifdef AHC_DEBUG
+				if (ahc_debug & AHC_SHOW_DV) {
+					ahc_print_devinfo(ahc, devinfo);
+					printf("DV TUR reties exhausted\n");
+				}
+#endif
+				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+				break;
+			}
+			if (status & SSQ_DELAY)
+				scsi_sleep(1 * HZ);
+
+			break;
+		case SS_START:
+			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_SU);
+			break;
+		case SS_INQ_REFRESH:
+			AHC_SET_DV_STATE(ahc, targ,
+					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		default:
+			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			break;
+		}
+		break;
+
+	case AHC_DV_STATE_REBD:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+		{
+			uint32_t echo_size;
+
+			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_WEB);
+			echo_size = scsi_3btoul(&targ->dv_buffer[1]);
+			echo_size &= 0x1FFF;
+#ifdef AHC_DEBUG
+			if (ahc_debug & AHC_SHOW_DV) {
+				ahc_print_devinfo(ahc, devinfo);
+				printf("Echo buffer size= %d\n", echo_size);
+			}
+#endif
+			if (echo_size == 0) {
+				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+				break;
+			}
+
+			/* Generate the buffer pattern */
+			targ->dv_echo_size = echo_size;
+			ahc_linux_generate_dv_pattern(targ);
+			/*
+			 * Setup initial negotiation values.
+			 */
+			ahc_linux_filter_inquiry(ahc, devinfo);
+			break;
+		}
+		case SS_INQ_REFRESH:
+			AHC_SET_DV_STATE(ahc, targ,
+					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		case SS_RETRY:
+			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
+			if (ahc_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ)
+				targ->dv_state_retry--;
+			if (targ->dv_state_retry <= 10)
+				break;
+#ifdef AHC_DEBUG
+			if (ahc_debug & AHC_SHOW_DV) {
+				ahc_print_devinfo(ahc, devinfo);
+				printf("DV REBD reties exhausted\n");
+			}
+#endif
+			/* FALLTHROUGH */
+		case SS_FATAL:
+		default:
+			/*
+			 * Setup initial negotiation values
+			 * and try level 1 DV.
+			 */
+			ahc_linux_filter_inquiry(ahc, devinfo);
+			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_INQ_VERIFY);
+			targ->dv_echo_size = 0;
+			break;
+		}
+		break;
+
+	case AHC_DV_STATE_WEB:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_REB);
+			break;
+		case SS_INQ_REFRESH:
+			AHC_SET_DV_STATE(ahc, targ,
+					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		case SS_RETRY:
+			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
+			if (ahc_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ) {
+				targ->dv_state_retry--;
+			} else if ((status & SSQ_FALLBACK) != 0) {
+				if (ahc_linux_fallback(ahc, devinfo) != 0) {
+					AHC_SET_DV_STATE(ahc, targ,
+							 AHC_DV_STATE_EXIT);
+					break;
+				}
+				/*
+				 * Do not count "falling back"
+				 * against our retries.
+				 */
+				targ->dv_state_retry = 0;
+			}
+			if (targ->dv_state_retry <= 10)
+				break;
+			/* FALLTHROUGH */
+#ifdef AHC_DEBUG
+			if (ahc_debug & AHC_SHOW_DV) {
+				ahc_print_devinfo(ahc, devinfo);
+				printf("DV WEB reties exhausted\n");
+			}
+#endif
+		default:
+			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			break;
+		}
+		break;
+
+	case AHC_DV_STATE_REB:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+			if (memcmp(targ->dv_buffer, targ->dv_buffer1,
+				   targ->dv_echo_size) != 0) {
+				if (ahc_linux_fallback(ahc, devinfo) != 0)
+					AHC_SET_DV_STATE(ahc, targ,
+							 AHC_DV_STATE_EXIT);
+				else
+					AHC_SET_DV_STATE(ahc, targ,
+							 AHC_DV_STATE_WEB);
+				break;
+			}
+			
+			if (targ->dv_buffer != NULL) {
+				free(targ->dv_buffer, M_DEVBUF);
+				targ->dv_buffer = NULL;
+			}
+			if (targ->dv_buffer1 != NULL) {
+				free(targ->dv_buffer1, M_DEVBUF);
+				targ->dv_buffer1 = NULL;
+			}
+			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			break;
+		case SS_INQ_REFRESH:
+			AHC_SET_DV_STATE(ahc, targ,
+					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		case SS_RETRY:
+			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
+			if (ahc_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ) {
+				targ->dv_state_retry--;
+			} else if ((status & SSQ_FALLBACK) != 0) {
+				if (ahc_linux_fallback(ahc, devinfo) != 0) {
+					AHC_SET_DV_STATE(ahc, targ,
+							 AHC_DV_STATE_EXIT);
+					break;
+				}
+				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_WEB);
+			}
+			if (targ->dv_state_retry <= 10) {
+				if ((status & (SSQ_DELAY_RANDOM|SSQ_DELAY))!= 0)
+					scsi_sleep(ahc->our_id*HZ/10);
+				break;
+			}
+#ifdef AHC_DEBUG
+			if (ahc_debug & AHC_SHOW_DV) {
+				ahc_print_devinfo(ahc, devinfo);
+				printf("DV REB reties exhausted\n");
+			}
+#endif
+			/* FALLTHROUGH */
+		default:
+			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			break;
+		}
+		break;
+
+	case AHC_DV_STATE_SU:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+		case SS_INQ_REFRESH:
+			AHC_SET_DV_STATE(ahc, targ,
+					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		default:
+			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			break;
+		}
+		break;
+
+	case AHC_DV_STATE_BUSY:
+		switch (status & SS_MASK) {
+		case SS_NOP:
+		case SS_INQ_REFRESH:
+			AHC_SET_DV_STATE(ahc, targ,
+					 AHC_DV_STATE_INQ_SHORT_ASYNC);
+			break;
+		case SS_TUR:
+		case SS_RETRY:
+			AHC_SET_DV_STATE(ahc, targ, targ->dv_state);
+			if (ahc_cmd_get_transaction_status(cmd)
+			 == CAM_REQUEUE_REQ) {
+				targ->dv_state_retry--;
+			} else if (targ->dv_state_retry < 60) {
+				if ((status & SSQ_DELAY) != 0)
+					scsi_sleep(1 * HZ);
+			} else {
+#ifdef AHC_DEBUG
+				if (ahc_debug & AHC_SHOW_DV) {
+					ahc_print_devinfo(ahc, devinfo);
+					printf("DV BUSY reties exhausted\n");
+				}
+#endif
+				AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			}
+			break;
+		default:
+			AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+			break;
 		}
+		break;
+
+	default:
+		printf("%s: Invalid DV completion state %d\n", ahc_name(ahc),
+		       targ->dv_state);
+		AHC_SET_DV_STATE(ahc, targ, AHC_DV_STATE_EXIT);
+		break;
 	}
-	return (unit);
+}
+
+static void
+ahc_linux_dv_fill_cmd(struct ahc_softc *ahc, struct scsi_cmnd *cmd,
+		      struct ahc_devinfo *devinfo)
+{
+	memset(cmd, 0, sizeof(struct scsi_cmnd));
+	cmd->device = ahc->platform_data->dv_scsi_dev;
+	cmd->scsi_done = ahc_linux_dv_complete;
 }
 
 /*
- * Place the SCSI bus into a known state by either resetting it,
- * or forcing transfer negotiations on the next command to any
- * target.
+ * Synthesize an inquiry command.  On the return trip, it'll be
+ * sniffed and the device transfer settings set for us.
  */
-void
-ahc_linux_initialize_scsi_bus(struct ahc_softc *ahc)
+static void
+ahc_linux_dv_inq(struct ahc_softc *ahc, struct scsi_cmnd *cmd,
+		 struct ahc_devinfo *devinfo, struct ahc_linux_target *targ,
+		 u_int request_length)
 {
-	int i;
-	int numtarg;
-
-	i = 0;
-	numtarg = 0;
-
-	if (aic7xxx_no_reset != 0)
-		ahc->flags &= ~(AHC_RESET_BUS_A|AHC_RESET_BUS_B);
 
-	if ((ahc->flags & AHC_RESET_BUS_A) != 0)
-		ahc_reset_channel(ahc, 'A', /*initiate_reset*/TRUE);
+#ifdef AHC_DEBUG
+	if (ahc_debug & AHC_SHOW_DV) {
+		ahc_print_devinfo(ahc, devinfo);
+		printf("Sending INQ\n");
+	}
+#endif
+	if (targ->inq_data == NULL)
+		targ->inq_data = malloc(AHC_LINUX_DV_INQ_LEN,
+					M_DEVBUF, M_WAITOK);
+	if (targ->dv_state > AHC_DV_STATE_INQ_ASYNC) {
+		if (targ->dv_buffer != NULL)
+			free(targ->dv_buffer, M_DEVBUF);
+		targ->dv_buffer = malloc(AHC_LINUX_DV_INQ_LEN,
+					 M_DEVBUF, M_WAITOK);
+	}
+
+	ahc_linux_dv_fill_cmd(ahc, cmd, devinfo);
+	cmd->sc_data_direction = SCSI_DATA_READ;
+	cmd->cmd_len = 6;
+	cmd->cmnd[0] = INQUIRY;
+	cmd->cmnd[4] = request_length;
+	cmd->request_bufflen = request_length;
+	if (targ->dv_state > AHC_DV_STATE_INQ_ASYNC)
+		cmd->request_buffer = targ->dv_buffer;
 	else
-		numtarg = (ahc->features & AHC_WIDE) ? 16 : 8;
+		cmd->request_buffer = targ->inq_data;
+	memset(cmd->request_buffer, 0, AHC_LINUX_DV_INQ_LEN);
+}
 
-	if ((ahc->features & AHC_TWIN) != 0) {
+static void
+ahc_linux_dv_tur(struct ahc_softc *ahc, struct scsi_cmnd *cmd,
+		 struct ahc_devinfo *devinfo)
+{
 
-		if ((ahc->flags & AHC_RESET_BUS_B) != 0) {
-			ahc_reset_channel(ahc, 'B', /*initiate_reset*/TRUE);
-		} else {
-			if (numtarg == 0)
-				i = 8;
-			numtarg += 8;
-		}
+#ifdef AHC_DEBUG
+	if (ahc_debug & AHC_SHOW_DV) {
+		ahc_print_devinfo(ahc, devinfo);
+		printf("Sending TUR\n");
 	}
+#endif
+	/* Do a TUR to clear out any non-fatal transitional state */
+	ahc_linux_dv_fill_cmd(ahc, cmd, devinfo);
+	cmd->sc_data_direction = SCSI_DATA_NONE;
+	cmd->cmd_len = 6;
+	cmd->cmnd[0] = TEST_UNIT_READY;
+}
 
-	for (; i < numtarg; i++) {
-		struct ahc_devinfo devinfo;
-		struct ahc_initiator_tinfo *tinfo;
-		struct ahc_tmode_tstate *tstate;
-		u_int our_id;
-		u_int target_id;
-		char channel;
+#define AHC_REBD_LEN 4
 
-		channel = 'A';
-		our_id = ahc->our_id;
-		target_id = i;
-		if (i > 7 && (ahc->features & AHC_TWIN) != 0) {
-			channel = 'B';
-			our_id = ahc->our_id_b;
-			target_id = i % 8;
-		}
-		tinfo = ahc_fetch_transinfo(ahc, channel, our_id,
-					    target_id, &tstate);
-		tinfo->goal = tinfo->user;
-		/*
-		 * Don't try negotiations that require PPR messages
-		 * until we successfully retrieve Inquiry data.
-		 */
-		tinfo->goal.ppr_options = 0;
-		if (tinfo->goal.transport_version > SCSI_REV_2)
-			tinfo->goal.transport_version = SCSI_REV_2;
-		ahc_compile_devinfo(&devinfo, our_id, target_id,
-				   CAM_LUN_WILDCARD, channel, ROLE_INITIATOR);
-		ahc_update_neg_request(ahc, &devinfo, tstate,
-				       tinfo, /*force*/FALSE);
-	}
-	/* Give the bus some time to recover */
-	if ((ahc->flags & (AHC_RESET_BUS_A|AHC_RESET_BUS_B)) != 0) {
-		ahc_linux_freeze_sim_queue(ahc);
-		init_timer(&ahc->platform_data->reset_timer);
-		ahc->platform_data->reset_timer.data = (u_long)ahc;
-		ahc->platform_data->reset_timer.expires =
-		    jiffies + (AIC7XXX_RESET_DELAY * HZ)/1000;
-		ahc->platform_data->reset_timer.function =
-		    ahc_linux_release_sim_queue;
-		add_timer(&ahc->platform_data->reset_timer);
+static void
+ahc_linux_dv_rebd(struct ahc_softc *ahc, struct scsi_cmnd *cmd,
+		 struct ahc_devinfo *devinfo, struct ahc_linux_target *targ)
+{
+
+#ifdef AHC_DEBUG
+	if (ahc_debug & AHC_SHOW_DV) {
+		ahc_print_devinfo(ahc, devinfo);
+		printf("Sending REBD\n");
 	}
+#endif
+	if (targ->dv_buffer != NULL)
+		free(targ->dv_buffer, M_DEVBUF);
+	targ->dv_buffer = malloc(AHC_REBD_LEN, M_DEVBUF, M_WAITOK);
+	ahc_linux_dv_fill_cmd(ahc, cmd, devinfo);
+	cmd->sc_data_direction = SCSI_DATA_READ;
+	cmd->cmd_len = 10;
+	cmd->cmnd[0] = READ_BUFFER;
+	cmd->cmnd[1] = 0x0b;
+	scsi_ulto3b(AHC_REBD_LEN, &cmd->cmnd[6]);
+	cmd->request_bufflen = AHC_REBD_LEN;
+	cmd->underflow = cmd->request_bufflen;
+	cmd->request_buffer = targ->dv_buffer;
 }
 
-int
-ahc_platform_alloc(struct ahc_softc *ahc, void *platform_arg)
+static void
+ahc_linux_dv_web(struct ahc_softc *ahc, struct scsi_cmnd *cmd,
+		 struct ahc_devinfo *devinfo, struct ahc_linux_target *targ)
 {
-	ahc->platform_data =
-	    malloc(sizeof(struct ahc_platform_data), M_DEVBUF, M_NOWAIT);
-	if (ahc->platform_data == NULL)
-		return (ENOMEM);
-	memset(ahc->platform_data, 0, sizeof(struct ahc_platform_data));
-	TAILQ_INIT(&ahc->platform_data->completeq);
-	TAILQ_INIT(&ahc->platform_data->device_runq);
-	ahc->platform_data->irq = AHC_LINUX_NOIRQ;
-	ahc->platform_data->hw_dma_mask = 0xFFFFFFFF;
-	ahc_lockinit(ahc);
-	ahc_done_lockinit(ahc);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
-	init_MUTEX_LOCKED(&ahc->platform_data->eh_sem);
-#else
-	ahc->platform_data->eh_sem = MUTEX_LOCKED;
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-	tasklet_init(&ahc->platform_data->runq_tasklet, ahc_runq_tasklet,
-		     (unsigned long)ahc);
+
+#ifdef AHC_DEBUG
+	if (ahc_debug & AHC_SHOW_DV) {
+		ahc_print_devinfo(ahc, devinfo);
+		printf("Sending WEB\n");
+	}
 #endif
-	ahc->seltime = (aic7xxx_seltime & 0x3) << 4;
-	ahc->seltime_b = (aic7xxx_seltime & 0x3) << 4;
-	if (TAILQ_EMPTY(&ahc_tailq))
-		register_reboot_notifier(&ahc_linux_notifier);
-	return (0);
+	ahc_linux_dv_fill_cmd(ahc, cmd, devinfo);
+	cmd->sc_data_direction = SCSI_DATA_WRITE;
+	cmd->cmd_len = 10;
+	cmd->cmnd[0] = WRITE_BUFFER;
+	cmd->cmnd[1] = 0x0a;
+	scsi_ulto3b(targ->dv_echo_size, &cmd->cmnd[6]);
+	cmd->request_bufflen = targ->dv_echo_size;
+	cmd->underflow = cmd->request_bufflen;
+	cmd->request_buffer = targ->dv_buffer;
 }
 
-void
-ahc_platform_free(struct ahc_softc *ahc)
+static void
+ahc_linux_dv_reb(struct ahc_softc *ahc, struct scsi_cmnd *cmd,
+		 struct ahc_devinfo *devinfo, struct ahc_linux_target *targ)
 {
-	if (ahc->platform_data != NULL) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-		tasklet_kill(&ahc->platform_data->runq_tasklet);
-#endif
-		if (ahc->platform_data->host != NULL)
-			scsi_unregister(ahc->platform_data->host);
-		if (ahc->platform_data->irq != AHC_LINUX_NOIRQ)
-			free_irq(ahc->platform_data->irq, ahc);
-		if (ahc->tag == BUS_SPACE_PIO
-		 && ahc->bsh.ioport != 0)
-			release_region(ahc->bsh.ioport, 256);
-		if (ahc->tag == BUS_SPACE_MEMIO
-		 && ahc->bsh.maddr != NULL) {
-			u_long base_addr;
 
-			base_addr = (u_long)ahc->bsh.maddr;
-			base_addr &= PAGE_MASK;
-			iounmap((void *)base_addr);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-			release_mem_region(ahc->platform_data->mem_busaddr,
-					   0x1000);
-#endif
-		}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-		/* XXX Need an instance detach in the PCI code */
-		if (ahc->dev_softc != NULL)
-			ahc->dev_softc->driver = NULL;
-#endif
-		free(ahc->platform_data, M_DEVBUF);
+#ifdef AHC_DEBUG
+	if (ahc_debug & AHC_SHOW_DV) {
+		ahc_print_devinfo(ahc, devinfo);
+		printf("Sending REB\n");
 	}
-	if (TAILQ_EMPTY(&ahc_tailq)) {
-		unregister_reboot_notifier(&ahc_linux_notifier);
-#ifdef CONFIG_PCI
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-		pci_unregister_driver(&aic7xxx_pci_driver);
-#endif
 #endif
-	}
+	ahc_linux_dv_fill_cmd(ahc, cmd, devinfo);
+	cmd->sc_data_direction = SCSI_DATA_READ;
+	cmd->cmd_len = 10;
+	cmd->cmnd[0] = READ_BUFFER;
+	cmd->cmnd[1] = 0x0a;
+	scsi_ulto3b(targ->dv_echo_size, &cmd->cmnd[6]);
+	cmd->request_bufflen = targ->dv_echo_size;
+	cmd->underflow = cmd->request_bufflen;
+	cmd->request_buffer = targ->dv_buffer1;
 }
 
-void
-ahc_platform_freeze_devq(struct ahc_softc *ahc, struct scb *scb)
-{
-	ahc_platform_abort_scbs(ahc, SCB_GET_TARGET(ahc, scb),
-				SCB_GET_CHANNEL(ahc, scb),
-				SCB_GET_LUN(scb), SCB_LIST_NULL,
-				ROLE_UNKNOWN, CAM_REQUEUE_REQ);
+static void
+ahc_linux_dv_su(struct ahc_softc *ahc, struct scsi_cmnd *cmd,
+		struct ahc_devinfo *devinfo,
+		struct ahc_linux_target *targ)
+{
+	u_int le;
+
+	le = SID_IS_REMOVABLE(targ->inq_data) ? SSS_LOEJ : 0;
+
+#ifdef AHC_DEBUG
+	if (ahc_debug & AHC_SHOW_DV) {
+		ahc_print_devinfo(ahc, devinfo);
+		printf("Sending SU\n");
+	}
+#endif
+	ahc_linux_dv_fill_cmd(ahc, cmd, devinfo);
+	cmd->sc_data_direction = SCSI_DATA_NONE;
+	cmd->cmd_len = 6;
+	cmd->cmnd[0] = START_STOP_UNIT;
+	cmd->cmnd[4] = le | SSS_START;
 }
 
-void
-ahc_platform_set_tags(struct ahc_softc *ahc, struct ahc_devinfo *devinfo,
-		      ahc_queue_alg alg)
+static int
+ahc_linux_fallback(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
 {
-	struct ahc_linux_device *dev;
-	int was_queuing;
-	int now_queuing;
-
-	dev = ahc_linux_get_device(ahc, devinfo->channel - 'A',
-				   devinfo->target,
-				   devinfo->lun, /*alloc*/FALSE);
-	if (dev == NULL)
-		return;
-	was_queuing = dev->flags & (AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED);
-	now_queuing = alg != AHC_QUEUE_NONE;
-	if ((dev->flags & AHC_DEV_FREEZE_TIL_EMPTY) == 0
-	 && (was_queuing != now_queuing)
-	 && (dev->active != 0)) {
-		dev->flags |= AHC_DEV_FREEZE_TIL_EMPTY;
-		dev->qfrozen++;
+	struct	ahc_linux_target *targ;
+	struct	ahc_initiator_tinfo *tinfo;
+	struct	ahc_transinfo *goal;
+	struct	ahc_tmode_tstate *tstate;
+	struct	ahc_syncrate *syncrate;
+	u_long	s;
+	u_int	width;
+	u_int	period;
+	u_int	offset;
+	u_int	ppr_options;
+	u_int	cur_speed;
+	u_int	wide_speed;
+	u_int	narrow_speed;
+	u_int	fallback_speed;
+
+#ifdef AHC_DEBUG
+	if (ahc_debug & AHC_SHOW_DV) {
+		ahc_print_devinfo(ahc, devinfo);
+		printf("Trying to fallback\n");
+	}
+#endif
+	ahc_lock(ahc, &s);
+	targ = ahc->platform_data->targets[devinfo->target_offset];
+	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
+				    devinfo->our_scsiid,
+				    devinfo->target, &tstate);
+	goal = &tinfo->goal;
+	width = goal->width;
+	period = goal->period;
+	offset = goal->offset;
+	ppr_options = goal->ppr_options;
+	if (offset == 0)
+		period = AHC_ASYNC_XFER_PERIOD;
+	if (targ->dv_next_narrow_period == 0)
+		targ->dv_next_narrow_period = MAX(period, AHC_SYNCRATE_ULTRA2);
+	if (targ->dv_next_wide_period == 0)
+		targ->dv_next_wide_period = period;
+	if (targ->dv_max_width == 0)
+		targ->dv_max_width = width;
+	if (targ->dv_max_ppr_options == 0)
+		targ->dv_max_ppr_options = ppr_options;
+	if (targ->dv_last_ppr_options == 0)
+		targ->dv_last_ppr_options = ppr_options;
+
+	cur_speed = aic_calc_speed(width, period, offset, AHC_SYNCRATE_MIN);
+	wide_speed = aic_calc_speed(MSG_EXT_WDTR_BUS_16_BIT,
+					  targ->dv_next_wide_period,
+					  MAX_OFFSET,
+					  AHC_SYNCRATE_MIN);
+	narrow_speed = aic_calc_speed(MSG_EXT_WDTR_BUS_8_BIT,
+					    targ->dv_next_narrow_period,
+					    MAX_OFFSET,
+					    AHC_SYNCRATE_MIN);
+	fallback_speed = aic_calc_speed(width, period+1, offset,
+					AHC_SYNCRATE_MIN);
+#ifdef AHC_DEBUG
+	if (ahc_debug & AHC_SHOW_DV) {
+		printf("cur_speed= %d, wide_speed= %d, narrow_speed= %d, "
+		       "fallback_speed= %d\n", cur_speed, wide_speed,
+		       narrow_speed, fallback_speed);
 	}
+#endif
 
-	dev->flags &= ~(AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED|AHC_DEV_PERIODIC_OTAG);
-	if (now_queuing) {
-		u_int usertags;
+	if (cur_speed > 160000) {
+		/*
+		 * Paced/DT/IU_REQ only transfer speeds.  All we
+		 * can do is fallback in terms of syncrate.
+		 */
+		period++;
+	} else if (cur_speed > 80000) {
+		if ((ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
+			/*
+			 * Try without IU_REQ as it may be confusing
+			 * an expander.
+			 */
+			ppr_options &= ~MSG_EXT_PPR_IU_REQ;
+		} else {
+			/*
+			 * Paced/DT only transfer speeds.  All we
+			 * can do is fallback in terms of syncrate.
+			 */
+			period++;
+			ppr_options = targ->dv_max_ppr_options;
+		}
+	} else if (cur_speed > 3300) {
 
-		usertags = ahc_linux_user_tagdepth(ahc, devinfo);
-		if (!was_queuing) {
+		/*
+		 * In this range we the following
+		 * options ordered from highest to
+		 * lowest desireability:
+		 *
+		 * o Wide/DT
+		 * o Wide/non-DT
+		 * o Narrow at a potentally higher sync rate.
+		 *
+		 * All modes are tested with and without IU_REQ
+		 * set since using IUs may confuse an expander.
+		 */
+		if ((ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {
+
+			ppr_options &= ~MSG_EXT_PPR_IU_REQ;
+		} else if ((ppr_options & MSG_EXT_PPR_DT_REQ) != 0) {
 			/*
-			 * Start out agressively and allow our
-			 * dynamic queue depth algorithm to take
-			 * care of the rest.
+			 * Try going non-DT.
 			 */
-			dev->maxtags = usertags;
-			dev->openings = dev->maxtags - dev->active;
+			ppr_options = targ->dv_max_ppr_options;
+			ppr_options &= ~MSG_EXT_PPR_DT_REQ;
+		} else if (targ->dv_last_ppr_options != 0) {
+			/*
+			 * Try without QAS or any other PPR options.
+			 * We may need a non-PPR message to work with
+			 * an expander.  We look at the "last PPR options"
+			 * so we will perform this fallback even if the
+			 * target responded to our PPR negotiation with
+			 * no option bits set.
+			 */
+			ppr_options = 0;
+		} else if (width == MSG_EXT_WDTR_BUS_16_BIT) {
+			/*
+			 * If the next narrow speed is greater than
+			 * the next wide speed, fallback to narrow.
+			 * Otherwise fallback to the next DT/Wide setting.
+			 * The narrow async speed will always be smaller
+			 * than the wide async speed, so handle this case
+			 * specifically.
+			 */
+			ppr_options = targ->dv_max_ppr_options;
+			if (narrow_speed > fallback_speed
+			 || period >= AHC_ASYNC_XFER_PERIOD) {
+				targ->dv_next_wide_period = period+1;
+				width = MSG_EXT_WDTR_BUS_8_BIT;
+				period = targ->dv_next_narrow_period;
+			} else {
+				period++;
+			}
+		} else if ((ahc->features & AHC_WIDE) != 0
+			&& targ->dv_max_width != 0
+			&& wide_speed >= fallback_speed
+			&& (targ->dv_next_wide_period <= AHC_ASYNC_XFER_PERIOD
+			 || period >= AHC_ASYNC_XFER_PERIOD)) {
+
+			/*
+			 * We are narrow.  Try falling back
+			 * to the next wide speed with 
+			 * all supported ppr options set.
+			 */
+			targ->dv_next_narrow_period = period+1;
+			width = MSG_EXT_WDTR_BUS_16_BIT;
+			period = targ->dv_next_wide_period;
+			ppr_options = targ->dv_max_ppr_options;
+		} else {
+			/* Only narrow fallback is allowed. */
+			period++;
+			ppr_options = targ->dv_max_ppr_options;
 		}
-		if (alg == AHC_QUEUE_TAGGED) {
-			dev->flags |= AHC_DEV_Q_TAGGED;
-			if (aic7xxx_periodic_otag != 0)
-				dev->flags |= AHC_DEV_PERIODIC_OTAG;
-		} else
-			dev->flags |= AHC_DEV_Q_BASIC;
 	} else {
-		/* We can only have one opening. */
-		dev->maxtags = 0;
-		dev->openings =  1 - dev->active;
+		ahc_unlock(ahc, &s);
+		return (-1);
+	}
+	offset = MAX_OFFSET;
+	syncrate = ahc_find_syncrate(ahc, &period, &ppr_options,
+				     AHC_SYNCRATE_DT);
+	ahc_set_width(ahc, devinfo, width, AHC_TRANS_GOAL, FALSE);
+	if (period == 0) {
+		period = 0;
+		offset = 0;
+		ppr_options = 0;
+		if (width == MSG_EXT_WDTR_BUS_8_BIT)
+			targ->dv_next_narrow_period = AHC_ASYNC_XFER_PERIOD;
+		else
+			targ->dv_next_wide_period = AHC_ASYNC_XFER_PERIOD;
 	}
+	ahc_set_syncrate(ahc, devinfo, syncrate, period, offset,
+			 ppr_options, AHC_TRANS_GOAL, FALSE);
+	targ->dv_last_ppr_options = ppr_options;
+	ahc_unlock(ahc, &s);
+	return (0);
 }
 
-int
-ahc_platform_abort_scbs(struct ahc_softc *ahc, int target, char channel,
-			int lun, u_int tag, role_t role, uint32_t status)
+static void
+ahc_linux_dv_timeout(struct scsi_cmnd *cmd)
 {
-	int chan;
-	int maxchan;
-	int targ;
-	int maxtarg;
-	int clun;
-	int maxlun;
-	int count;
+	struct	ahc_softc *ahc;
+	struct	scb *scb;
+	u_long	flags;
 
-	if (tag != SCB_LIST_NULL)
-		return (0);
+	ahc = *((struct ahc_softc **)cmd->device->host->hostdata);
+	ahc_lock(ahc, &flags);
 
-	chan = 0;
-	if (channel != ALL_CHANNELS) {
-		chan = channel - 'A';
-		maxchan = chan + 1;
-	} else {
-		maxchan = (ahc->features & AHC_TWIN) ? 2 : 1;
-	}
-	targ = 0;
-	if (target != CAM_TARGET_WILDCARD) {
-		targ = target;
-		maxtarg = targ + 1;
-	} else {
-		maxtarg = (ahc->features & AHC_WIDE) ? 16 : 8;
+#ifdef AHC_DEBUG
+	if (ahc_debug & AHC_SHOW_DV) {
+		printf("%s: Timeout while doing DV command %x.\n",
+		       ahc_name(ahc), cmd->cmnd[0]);
+		ahc_dump_card_state(ahc);
 	}
-	clun = 0;
-	if (lun != CAM_LUN_WILDCARD) {
-		clun = lun;
-		maxlun = clun + 1;
-	} else {
-		maxlun = AHC_NUM_LUNS;
+#endif
+	
+	/*
+	 * Guard against "done race".  No action is
+	 * required if we just completed.
+	 */
+	if ((scb = (struct scb *)cmd->host_scribble) == NULL) {
+		ahc_unlock(ahc, &flags);
+		return;
 	}
 
-	count = 0;
-	for (; chan < maxchan; chan++) {
+	/*
+	 * Command has not completed.  Mark this
+	 * SCB as having failing status prior to
+	 * resetting the bus, so we get the correct
+	 * error code.
+	 */
+	if ((scb->flags & SCB_SENSE) != 0)
+		ahc_set_transaction_status(scb, CAM_AUTOSENSE_FAIL);
+	else
+		ahc_set_transaction_status(scb, CAM_CMD_TIMEOUT);
+	ahc_reset_channel(ahc, cmd->device->channel + 'A', /*initiate*/TRUE);
 
-		for (; targ < maxtarg; targ++) {
+	/*
+	 * Add a minimal bus settle delay for devices that are slow to
+	 * respond after bus resets.
+	 */
+	ahc_linux_freeze_simq(ahc);
+	init_timer(&ahc->platform_data->reset_timer);
+	ahc->platform_data->reset_timer.data = (u_long)ahc;
+	ahc->platform_data->reset_timer.expires = jiffies + HZ / 2;
+	ahc->platform_data->reset_timer.function =
+	    (ahc_linux_callback_t *)ahc_linux_release_simq;
+	add_timer(&ahc->platform_data->reset_timer);
+	if (ahc_linux_next_device_to_run(ahc) != NULL)
+		ahc_schedule_runq(ahc);
+	ahc_linux_run_complete_queue(ahc);
+	ahc_unlock(ahc, &flags);
+}
 
-			for (; clun < maxlun; clun++) {
-				struct ahc_linux_device *dev;
-				struct ahc_busyq *busyq;
-				struct ahc_cmd *acmd;
+static void
+ahc_linux_dv_complete(struct scsi_cmnd *cmd)
+{
+	struct ahc_softc *ahc;
 
-				dev = ahc_linux_get_device(ahc, chan,
-							   targ, clun,
-							   /*alloc*/FALSE);
-				if (dev == NULL)
-					continue;
+	ahc = *((struct ahc_softc **)cmd->device->host->hostdata);
 
-				busyq = &dev->busyq;
-				while ((acmd = TAILQ_FIRST(busyq)) != NULL) {
-					Scsi_Cmnd *cmd;
+	/* Delete the DV timer before it goes off! */
+	scsi_delete_timer(cmd);
 
-					cmd = &acmd_scsi_cmd(acmd);
-					TAILQ_REMOVE(busyq, acmd,
-						     acmd_links.tqe);
-					count++;
-					cmd->result = status << 16;
-					ahc_linux_queue_cmd_complete(ahc, cmd);
-				}
-			}
-		}
-	}
+#ifdef AHC_DEBUG
+	if (ahc_debug & AHC_SHOW_DV)
+		printf("%s:%d:%d: Command completed, status= 0x%x\n",
+		       ahc_name(ahc), cmd->device->channel,
+		       cmd->device->id, cmd->result);
+#endif
 
-	return (count);
+	/* Wake up the state machine */
+	up(&ahc->platform_data->dv_cmd_sem);
 }
 
-/*
- * Sets the queue depth for each SCSI device hanging
- * off the input host adapter.
- */
 static void
-ahc_linux_select_queue_depth(struct Scsi_Host * host,
-			     Scsi_Device * scsi_devs)
+ahc_linux_generate_dv_pattern(struct ahc_linux_target *targ)
 {
-	Scsi_Device *device;
-	struct	ahc_softc *ahc;
-	u_long	flags;
-	int	scbnum;
+	uint16_t b;
+	u_int	 i;
+	u_int	 j;
+
+	if (targ->dv_buffer != NULL)
+		free(targ->dv_buffer, M_DEVBUF);
+	targ->dv_buffer = malloc(targ->dv_echo_size, M_DEVBUF, M_WAITOK);
+	if (targ->dv_buffer1 != NULL)
+		free(targ->dv_buffer1, M_DEVBUF);
+	targ->dv_buffer1 = malloc(targ->dv_echo_size, M_DEVBUF, M_WAITOK);
 
-	ahc = *((struct ahc_softc **)host->hostdata);
-	ahc_lock(ahc, &flags);
-	scbnum = 0;
-	for (device = scsi_devs; device != NULL; device = device->next) {
-		if (device->host == host) {
-			ahc_linux_device_queue_depth(ahc, device);
-			scbnum += device->queue_depth;
+	i = 0;
+	b = 0x0001;
+	for (j = 0 ; i < targ->dv_echo_size; j++) {
+		if (j < 32) {
+			/*
+			 * 32bytes of sequential numbers.
+			 */
+			targ->dv_buffer[i++] = j & 0xff;
+		} else if (j < 48) {
+			/*
+			 * 32bytes of repeating 0x0000, 0xffff.
+			 */
+			targ->dv_buffer[i++] = (j & 0x02) ? 0xff : 0x00;
+		} else if (j < 64) {
+			/*
+			 * 32bytes of repeating 0x5555, 0xaaaa.
+			 */
+			targ->dv_buffer[i++] = (j & 0x02) ? 0xaa : 0x55;
+		} else {
+			/*
+			 * Remaining buffer is filled with a repeating
+			 * patter of:
+			 *
+			 *	 0xffff
+			 *	~0x0001 << shifted once in each loop.
+			 */
+			if (j & 0x02) {
+				if (j & 0x01) {
+					targ->dv_buffer[i++] = ~(b >> 8) & 0xff;
+					b <<= 1;
+					if (b == 0x0000)
+						b = 0x0001;
+				} else {
+					targ->dv_buffer[i++] = (~b & 0xff);
+				}
+			} else {
+				targ->dv_buffer[i++] = 0xff;
+			}
 		}
 	}
-	ahc_unlock(ahc, &flags);
 }
 
 static u_int
@@ -1572,17 +3553,17 @@ ahc_linux_user_tagdepth(struct ahc_softc
 
 	tags = 0;
 	if ((ahc->user_discenable & devinfo->target_mask) != 0) {
-		if (warned_user == 0
-		 && ahc->unit >= NUM_ELEMENTS(aic7xxx_tag_info)) {
+		if (ahc->unit >= NUM_ELEMENTS(aic7xxx_tag_info)) {
+			if (warned_user == 0) {
 
-			printf("aic7xxx: WARNING, insufficient "
-			       "tag_info instances for installed "
-			       "controllers. Using defaults\n");
-			printf("aic7xxx: Please update the "
-			       "aic7xxx_tag_info array in the "
-			       "aic7xxx.c source file.\n");
+				printf(KERN_WARNING
+"aic7xxx: WARNING: Insufficient tag_info instances\n"
+"aic7xxx: for installed controllers. Using defaults\n"
+"aic7xxx: Please update the aic7xxx_tag_info array in\n"
+"aic7xxx: the aic7xxx_osm..c source file.\n");
+				warned_user++;
+			}
 			tags = AHC_MAX_QUEUE;
-			warned_user++;
 		} else {
 			adapter_tag_info_t *tag_info;
 
@@ -1595,74 +3576,75 @@ ahc_linux_user_tagdepth(struct ahc_softc
 	return (tags);
 }
 
+static u_int
+ahc_linux_user_dv_setting(struct ahc_softc *ahc)
+{
+	static int warned_user;
+	int dv;
+
+	if (ahc->unit >= NUM_ELEMENTS(aic7xxx_dv_settings)) {
+		if (warned_user == 0) {
+
+			printf(KERN_WARNING
+"aic7xxx: WARNING: Insufficient dv settings instances\n"
+"aic7xxx: for installed controllers. Using defaults\n"
+"aic7xxx: Please update the aic7xxx_dv_settings array\n"
+"aic7xxx: in the aic7xxx_osm.c source file.\n");
+			warned_user++;
+		}
+		dv = -1;
+	} else {
+
+		dv = aic7xxx_dv_settings[ahc->unit];
+	}
+
+	if (dv < 0) {
+		u_long s;
+
+		/*
+		 * Apply the default.
+		 */
+		/*
+		 * XXX - Enable DV on non-U160 controllers once it
+		 *       has been tested there.
+		 */
+		ahc_lock(ahc, &s);
+		dv = (ahc->features & AHC_DT);
+		if (ahc->seep_config != 0
+		 && ahc->seep_config->signature >= CFSIGNATURE2)
+			dv = (ahc->seep_config->adapter_control & CFENABLEDV);
+		ahc_unlock(ahc, &s);
+	}
+	return (dv);
+}
+
 /*
  * Determines the queue depth for a given device.
  */
 static void
-ahc_linux_device_queue_depth(struct ahc_softc *ahc, Scsi_Device * device)
+ahc_linux_device_queue_depth(struct ahc_softc *ahc,
+			     struct ahc_linux_device *dev)
 {
 	struct	ahc_devinfo devinfo;
 	u_int	tags;
 
 	ahc_compile_devinfo(&devinfo,
-			    device->channel == 0 ? ahc->our_id : ahc->our_id_b,
-			    device->id, device->lun,
-			    device->channel == 0 ? 'A' : 'B',
+			    dev->target->channel == 0
+			  ? ahc->our_id : ahc->our_id_b,
+			    dev->target->target, dev->lun,
+			    dev->target->channel == 0 ? 'A' : 'B',
 			    ROLE_INITIATOR);
 	tags = ahc_linux_user_tagdepth(ahc, &devinfo);
 	if (tags != 0
-	 && device->tagged_supported != 0) {
+	 && dev->scsi_device != NULL
+	 && dev->scsi_device->tagged_supported != 0) {
 
-		device->queue_depth = tags;
 		ahc_set_tags(ahc, &devinfo, AHC_QUEUE_TAGGED);
-		printf("scsi%d:%c:%d:%d: Tagged Queuing enabled.  Depth %d\n",
-	       	       ahc->platform_data->host->host_no, devinfo.channel,
-		       devinfo.target, devinfo.lun, tags);
+		ahc_print_devinfo(ahc, &devinfo);
+		printf("Tagged Queuing enabled.  Depth %d\n", tags);
 	} else {
-		/*
-		 * We allow the OS to queue 2 untagged transactions to
-		 * us at any time even though we can only execute them
-		 * serially on the controller/device.  This should remove
-		 * some latency.
-		 */
-		device->queue_depth = 2;
-	}
-}
-
-/*
- * Queue an SCB to the controller.
- */
-int
-ahc_linux_queue(Scsi_Cmnd * cmd, void (*scsi_done) (Scsi_Cmnd *))
-{
-	struct	 ahc_softc *ahc;
-	struct	 ahc_linux_device *dev;
-	u_long	 flags;
-
-	ahc = *(struct ahc_softc **)cmd->host->hostdata;
-
-	/*
-	 * Save the callback on completion function.
-	 */
-	cmd->scsi_done = scsi_done;
-
-	ahc_lock(ahc, &flags);
-	dev = ahc_linux_get_device(ahc, cmd->channel, cmd->target,
-				   cmd->lun, /*alloc*/TRUE);
-	if (dev == NULL) {
-		ahc_unlock(ahc, &flags);
-		printf("aic7xxx_linux_queue: Unable to allocate device!\n");
-		return (-ENOMEM);
-	}
-	cmd->result = CAM_REQ_INPROG << 16;
-	TAILQ_INSERT_TAIL(&dev->busyq, (struct ahc_cmd *)cmd, acmd_links.tqe);
-	if ((dev->flags & AHC_DEV_ON_RUN_LIST) == 0) {
-		TAILQ_INSERT_TAIL(&ahc->platform_data->device_runq, dev, links);
-		dev->flags |= AHC_DEV_ON_RUN_LIST;
-		ahc_linux_run_device_queues(ahc);
+		ahc_set_tags(ahc, &devinfo, AHC_QUEUE_NONE);
 	}
-	ahc_unlock(ahc, &flags);
-	return (0);
 }
 
 static void
@@ -1686,8 +3668,8 @@ ahc_linux_run_device_queue(struct ahc_so
 		 * Schedule us to run later.  The only reason we are not
 		 * running is because the whole controller Q is frozen.
 		 */
-		if (ahc->platform_data->qfrozen != 0) {
-
+		if (ahc->platform_data->qfrozen != 0
+	 	 && AHC_DV_SIMQ_FROZEN(ahc) == 0) {
 			TAILQ_INSERT_TAIL(&ahc->platform_data->device_runq,
 					  dev, links);
 			dev->flags |= AHC_DEV_ON_RUN_LIST;
@@ -1715,7 +3697,7 @@ ahc_linux_run_device_queue(struct ahc_so
 		 */
 		hscb->control = 0;
 		hscb->scsiid = BUILD_SCSIID(ahc, cmd);
-		hscb->lun = cmd->lun;
+		hscb->lun = cmd->device->lun;
 		mask = SCB_GET_TARGET_MASK(ahc, scb);
 		tinfo = ahc_fetch_transinfo(ahc, SCB_GET_CHANNEL(ahc, scb),
 					    SCB_GET_OUR_ID(scb),
@@ -1728,12 +3710,26 @@ ahc_linux_run_device_queue(struct ahc_so
 		if ((ahc->user_discenable & mask) != 0)
 			hscb->control |= DISCENB;
 
+	 	if (AHC_DV_CMD(cmd) != 0)
+			scb->flags |= SCB_SILENT;
+
 		if ((tstate->auto_negotiate & mask) != 0) {
 			scb->flags |= SCB_AUTO_NEGOTIATE;
 			scb->hscb->control |= MK_MESSAGE;
 		}
 
 		if ((dev->flags & (AHC_DEV_Q_TAGGED|AHC_DEV_Q_BASIC)) != 0) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+			int	msg_bytes;
+			uint8_t tag_msgs[2];
+
+			msg_bytes = scsi_populate_tag_msg(cmd, tag_msgs);
+			if (msg_bytes && tag_msgs[0] != MSG_SIMPLE_TASK) {
+				hscb->control |= tag_msgs[0];
+				if (tag_msgs[0] == MSG_ORDERED_TASK)
+					dev->commands_since_idle_or_otag = 0;
+			} else
+#endif
 			if (dev->commands_since_idle_or_otag == AHC_OTAG_THRESH
 			 && (dev->flags & AHC_DEV_Q_TAGGED) != 0) {
 				hscb->control |= MSG_ORDERED_TASK;
@@ -1763,7 +3759,7 @@ ahc_linux_run_device_queue(struct ahc_so
 
 			cur_seg = (struct scatterlist *)cmd->request_buffer;
 			nseg = pci_map_sg(ahc->dev_softc, cur_seg, cmd->use_sg,
-				 scsi_to_pci_dma_dir(cmd ->sc_data_direction));
+			    scsi_to_pci_dma_dir(cmd->sc_data_direction));
 			end_seg = cur_seg + nseg;
 			/* Copy the segments into the SG list. */
 			sg = scb->sg_list;
@@ -1867,41 +3863,29 @@ ahc_linux_run_device_queue(struct ahc_so
 /*
  * SCSI controller interrupt handler.
  */
-void
+irqreturn_t
 ahc_linux_isr(int irq, void *dev_id, struct pt_regs * regs)
 {
 	struct	ahc_softc *ahc;
-	struct	ahc_cmd *acmd;
 	u_long	flags;
-	struct	ahc_linux_device *next_dev;
+	int	ours;
 
 	ahc = (struct ahc_softc *) dev_id;
 	ahc_lock(ahc, &flags); 
-	ahc_intr(ahc);
-	acmd = TAILQ_FIRST(&ahc->platform_data->completeq);
-	TAILQ_INIT(&ahc->platform_data->completeq);
-	next_dev = ahc_linux_next_device_to_run(ahc);
+	ours = ahc_intr(ahc);
+	if (ahc_linux_next_device_to_run(ahc) != NULL)
+		ahc_schedule_runq(ahc);
+	ahc_linux_run_complete_queue(ahc);
 	ahc_unlock(ahc, &flags);
-	if (next_dev) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-		tasklet_schedule(&ahc->platform_data->runq_tasklet);
-#else
-		ahc_runq_tasklet((unsigned long)ahc);
-#endif
-	}
-	if (acmd != NULL)
-		ahc_linux_run_complete_queue(ahc, acmd);
+	return IRQ_RETVAL(ours);
 }
 
 void
 ahc_platform_flushwork(struct ahc_softc *ahc)
 {
-	struct ahc_cmd *acmd;
 
-	acmd = TAILQ_FIRST(&ahc->platform_data->completeq);
-	TAILQ_INIT(&ahc->platform_data->completeq);
-	if (acmd != NULL)
-		ahc_linux_run_complete_queue(ahc, acmd);
+	while (ahc_linux_run_complete_queue(ahc) != NULL)
+		;
 }
 
 static struct ahc_linux_target*
@@ -1910,6 +3894,10 @@ ahc_linux_alloc_target(struct ahc_softc 
 	struct ahc_linux_target *targ;
 	u_int target_offset;
 
+	target_offset = target;
+	if (channel != 0)
+		target_offset += 8;
+
 	targ = malloc(sizeof(*targ), M_DEVBUG, M_NOWAIT);
 	if (targ == NULL)
 		return (NULL);
@@ -1917,9 +3905,7 @@ ahc_linux_alloc_target(struct ahc_softc 
 	targ->channel = channel;
 	targ->target = target;
 	targ->ahc = ahc;
-	target_offset = target;
-	if (channel != 0)
-		target_offset += 8;
+	targ->flags = AHC_DV_REQUIRED;
 	ahc->platform_data->targets[target_offset] = targ;
 	return (targ);
 }
@@ -1927,12 +3913,41 @@ ahc_linux_alloc_target(struct ahc_softc 
 static void
 ahc_linux_free_target(struct ahc_softc *ahc, struct ahc_linux_target *targ)
 {
+	struct ahc_devinfo devinfo;
+	struct ahc_initiator_tinfo *tinfo;
+	struct ahc_tmode_tstate *tstate;
+	u_int our_id;
 	u_int target_offset;
+	char channel;
 
+	/*
+	 * Force a negotiation to async/narrow on any
+	 * future command to this device unless a bus
+	 * reset occurs between now and that command.
+	 */
+	channel = 'A' + targ->channel;
+	our_id = ahc->our_id;
 	target_offset = targ->target;
-	if (targ->channel != 0)
+	if (targ->channel != 0) {
 		target_offset += 8;
+		our_id = ahc->our_id_b;
+	}
+	tinfo = ahc_fetch_transinfo(ahc, channel, our_id,
+				    targ->target, &tstate);
+	ahc_compile_devinfo(&devinfo, our_id, targ->target, CAM_LUN_WILDCARD,
+			    channel, ROLE_INITIATOR);
+	ahc_set_syncrate(ahc, &devinfo, NULL, 0, 0, 0,
+			 AHC_TRANS_GOAL, /*paused*/FALSE);
+	ahc_set_width(ahc, &devinfo, MSG_EXT_WDTR_BUS_8_BIT,
+		      AHC_TRANS_GOAL, /*paused*/FALSE);
+	ahc_update_neg_request(ahc, &devinfo, tstate, tinfo, AHC_NEG_ALWAYS);
 	ahc->platform_data->targets[target_offset] = NULL;
+	if (targ->inq_data != NULL)
+		free(targ->inq_data, M_DEVBUF);
+	if (targ->dv_buffer != NULL)
+		free(targ->dv_buffer, M_DEVBUF);
+	if (targ->dv_buffer1 != NULL)
+		free(targ->dv_buffer1, M_DEVBUF);
 	free(targ, M_DEVBUF);
 }
 
@@ -1975,43 +3990,16 @@ ahc_linux_free_device(struct ahc_softc *
 {
 	struct ahc_linux_target *targ;
 
-	del_timer(&dev->timer);
+	del_timer_sync(&dev->timer);
 	targ = dev->target;
 	targ->devices[dev->lun] = NULL;
 	free(dev, M_DEVBUF);
 	targ->refcount--;
-	if (targ->refcount == 0)
+	if (targ->refcount == 0
+	 && (targ->flags & AHC_DV_REQUIRED) == 0)
 		ahc_linux_free_target(ahc, targ);
 }
 
-/*
- * Return a string describing the driver.
- */
-const char *
-ahc_linux_info(struct Scsi_Host *host)
-{
-	static char buffer[512];
-	char	ahc_info[256];
-	char   *bp;
-	struct ahc_softc *ahc;
-
-	bp = &buffer[0];
-	ahc = *(struct ahc_softc **)host->hostdata;
-	memset(bp, 0, sizeof(buffer));
-	strcpy(bp, "Adaptec AIC7XXX EISA/VLB/PCI SCSI HBA DRIVER, Rev ");
-	strcat(bp, AIC7XXX_DRIVER_VERSION);
-	strcat(bp, "\n");
-	strcat(bp, "        <");
-	strcat(bp, ahc->description);
-	strcat(bp, ">\n");
-	strcat(bp, "        ");
-	ahc_controller_info(ahc, ahc_info);
-	strcat(bp, ahc_info);
-	strcat(bp, "\n");
-
-	return (bp);
-}
-
 void
 ahc_send_async(struct ahc_softc *ahc, char channel,
 	       u_int target, u_int lun, ac_code code, void *arg)
@@ -2082,7 +4070,31 @@ ahc_send_async(struct ahc_softc *ahc, ch
 		break;
 	}
         case AC_SENT_BDR:
+	{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+		WARN_ON(lun != CAM_LUN_WILDCARD);
+		scsi_report_device_reset(ahc->platform_data->host,
+					 channel - 'A', target);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
+		Scsi_Device *scsi_dev;
+
+		/*
+		 * Find the SCSI device associated with this
+		 * request and indicate that a UA is expected.
+		 */
+		for (scsi_dev = ahc->platform_data->host->host_queue;
+		     scsi_dev != NULL; scsi_dev = scsi_dev->next) {
+			if (channel - 'A' == scsi_dev->channel
+			 && target == scsi_dev->id
+			 && (lun == CAM_LUN_WILDCARD
+			  || lun == scsi_dev->lun)) {
+				scsi_dev->was_reset = 1;
+				scsi_dev->expecting_cc_ua = 1;
+			}
+		}
+#endif
 		break;
+	}
         case AC_BUS_RESET:
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
 		if (ahc->platform_data->host != NULL) {
@@ -2100,10 +4112,10 @@ ahc_send_async(struct ahc_softc *ahc, ch
  * Calls the higher level scsi done function and frees the scb.
  */
 void
-ahc_done(struct ahc_softc *ahc, struct scb * scb)
+ahc_done(struct ahc_softc *ahc, struct scb *scb)
 {
 	Scsi_Cmnd *cmd;
-	struct ahc_linux_device *dev;
+	struct	   ahc_linux_device *dev;
 
 	LIST_REMOVE(scb, pending_links);
 	if ((scb->flags & SCB_UNTAGGEDQ) != 0) {
@@ -2125,27 +4137,41 @@ ahc_done(struct ahc_softc *ahc, struct s
 	dev = scb->platform_data->dev;
 	dev->active--;
 	dev->openings++;
-	ahc_linux_unmap_scb(ahc, scb);
-	if (scb->flags & SCB_SENSE) {
-		memcpy(cmd->sense_buffer, ahc_get_sense_buf(ahc, scb),
-		       MIN(sizeof(struct scsi_sense_data),
-			   sizeof(cmd->sense_buffer)));
-		cmd->result |= (DRIVER_SENSE << 24);
-	} else {
-		/*
-		 * Guard against stale sense data.
-		 * The Linux mid-layer assumes that sense
-		 * was retrieved anytime the first byte of
-		 * the sense buffer looks "sane".
-		 */
-		cmd->sense_buffer[0] = 0;
+	if ((cmd->result & (CAM_DEV_QFRZN << 16)) != 0) {
+		cmd->result &= ~(CAM_DEV_QFRZN << 16);
+		dev->qfrozen--;
 	}
+	ahc_linux_unmap_scb(ahc, scb);
+
+	/*
+	 * Guard against stale sense data.
+	 * The Linux mid-layer assumes that sense
+	 * was retrieved anytime the first byte of
+	 * the sense buffer looks "sane".
+	 */
+	cmd->sense_buffer[0] = 0;
 	if (ahc_get_transaction_status(scb) == CAM_REQ_INPROG) {
 		uint32_t amount_xferred;
 
 		amount_xferred =
 		    ahc_get_transfer_length(scb) - ahc_get_residual(scb);
-		if (amount_xferred < scb->io_ctx->underflow) {
+		if ((scb->flags & SCB_TRANSMISSION_ERROR) != 0) {
+#ifdef AHC_DEBUG
+			if ((ahc_debug & AHC_SHOW_MISC) != 0) {
+				ahc_print_path(ahc, scb);
+				printf("Set CAM_UNCOR_PARITY\n");
+			}
+#endif
+			ahc_set_transaction_status(scb, CAM_UNCOR_PARITY);
+		} else if (amount_xferred < scb->io_ctx->underflow) {
+			u_int i;
+
+			ahc_print_path(ahc, scb);
+			printf("CDB:");
+			for (i = 0; i < scb->io_ctx->cmd_len; i++)
+				printf(" 0x%x", scb->io_ctx->cmnd[i]);
+			printf("\n");
+			ahc_print_path(ahc, scb);
 			printf("Saw underflow (%ld of %ld bytes). "
 			       "Treated as error\n",
 				ahc_get_residual(scb),
@@ -2153,20 +4179,21 @@ ahc_done(struct ahc_softc *ahc, struct s
 			ahc_set_transaction_status(scb, CAM_DATA_RUN_ERR);
 		} else {
 			ahc_set_transaction_status(scb, CAM_REQ_CMP);
-			ahc_linux_sniff_command(ahc, cmd, scb);
 		}
-	} else if (ahc_get_transaction_status(scb) == DID_OK) {
+	} else if (ahc_get_transaction_status(scb) == CAM_SCSI_STATUS_ERROR) {
 		ahc_linux_handle_scsi_status(ahc, dev, scb);
-	} else if (ahc_get_transaction_status(scb) == DID_NO_CONNECT) {
-		/*
-		 * Should a selection timeout kill the device?
-		 * That depends on whether the selection timeout
-		 * is persistent.  Since we have no guarantee that
-		 * the mid-layer will issue an inquiry for this device
-		 * again, we can't just kill it off.
+	} else if (ahc_get_transaction_status(scb) == CAM_SEL_TIMEOUT) {
 		dev->flags |= AHC_DEV_UNCONFIGURED;
-		 */
+		if (AHC_DV_CMD(cmd) == FALSE)
+			dev->target->flags &= ~AHC_DV_REQUIRED;
 	}
+	/*
+	 * Start DV for devices that require it assuming the first command
+	 * sent does not result in a selection timeout.
+	 */
+	if (ahc_get_transaction_status(scb) != CAM_SEL_TIMEOUT
+	 && (dev->target->flags & AHC_DV_REQUIRED) != 0)
+		ahc_linux_start_dv(ahc);
 
 	if (dev->openings == 1
 	 && ahc_get_transaction_status(scb) == CAM_REQ_CMP
@@ -2189,7 +4216,8 @@ ahc_done(struct ahc_softc *ahc, struct s
 
 	if (TAILQ_EMPTY(&dev->busyq)) {
 		if ((dev->flags & AHC_DEV_UNCONFIGURED) != 0
-		 && dev->active == 0)
+		 && dev->active == 0
+	 	 && (dev->flags & AHC_DEV_TIMER_ACTIVE) == 0)
 			ahc_linux_free_device(ahc, dev);
 	} else if ((dev->flags & AHC_DEV_ON_RUN_LIST) == 0) {
 		TAILQ_INSERT_TAIL(&ahc->platform_data->device_runq, dev, links);
@@ -2198,17 +4226,38 @@ ahc_done(struct ahc_softc *ahc, struct s
 
 	if ((scb->flags & SCB_RECOVERY_SCB) != 0) {
 		printf("Recovery SCB completes\n");
-		up(&ahc->platform_data->eh_sem);
+		if (ahc_get_transaction_status(scb) == CAM_BDR_SENT
+		 || ahc_get_transaction_status(scb) == CAM_REQ_ABORTED)
+			ahc_set_transaction_status(scb, CAM_CMD_TIMEOUT);
+		if ((ahc->platform_data->flags & AHC_UP_EH_SEMAPHORE) != 0) {
+			ahc->platform_data->flags &= ~AHC_UP_EH_SEMAPHORE;
+			up(&ahc->platform_data->eh_sem);
+		}
 	}
 
 	ahc_free_scb(ahc, scb);
 	ahc_linux_queue_cmd_complete(ahc, cmd);
+
+	if ((ahc->platform_data->flags & AHC_DV_WAIT_SIMQ_EMPTY) != 0
+	 && LIST_FIRST(&ahc->pending_scbs) == NULL) {
+		ahc->platform_data->flags &= ~AHC_DV_WAIT_SIMQ_EMPTY;
+		up(&ahc->platform_data->dv_sem);
+	}
+		
 }
 
 static void
 ahc_linux_handle_scsi_status(struct ahc_softc *ahc,
 			     struct ahc_linux_device *dev, struct scb *scb)
 {
+	struct	ahc_devinfo devinfo;
+
+	ahc_compile_devinfo(&devinfo,
+			    ahc->our_id,
+			    dev->target->target, dev->lun,
+			    dev->target->channel == 0 ? 'A' : 'B',
+			    ROLE_INITIATOR);
+	
 	/*
 	 * We don't currently trust the mid-layer to
 	 * properly deal with queue full or busy.  So,
@@ -2222,6 +4271,45 @@ ahc_linux_handle_scsi_status(struct ahc_
 	switch (ahc_get_scsi_status(scb)) {
 	default:
 		break;
+	case SCSI_STATUS_CHECK_COND:
+	case SCSI_STATUS_CMD_TERMINATED:
+	{
+		Scsi_Cmnd *cmd;
+
+		/*
+		 * Copy sense information to the OS's cmd
+		 * structure if it is available.
+		 */
+		cmd = scb->io_ctx;
+		if (scb->flags & SCB_SENSE) {
+			u_int sense_size;
+
+			sense_size = MIN(sizeof(struct scsi_sense_data)
+				       - ahc_get_sense_residual(scb),
+					 sizeof(cmd->sense_buffer));
+			memcpy(cmd->sense_buffer,
+			       ahc_get_sense_buf(ahc, scb), sense_size);
+			if (sense_size < sizeof(cmd->sense_buffer))
+				memset(&cmd->sense_buffer[sense_size], 0,
+				       sizeof(cmd->sense_buffer) - sense_size);
+			cmd->result |= (DRIVER_SENSE << 24);
+#ifdef AHC_DEBUG
+			if (ahc_debug & AHC_SHOW_SENSE) {
+				int i;
+
+				printf("Copied %d bytes of sense data:",
+				       sense_size);
+				for (i = 0; i < sense_size; i++) {
+					if ((i & 0xF) == 0)
+						printf("\n");
+					printf("0x%x ", cmd->sense_buffer[i]);
+				}
+				printf("\n");
+			}
+#endif
+		}
+		break;
+	}
 	case SCSI_STATUS_QUEUE_FULL:
 	{
 		/*
@@ -2267,13 +4355,20 @@ ahc_linux_handle_scsi_status(struct ahc_
 			}
 			ahc_set_transaction_status(scb, CAM_REQUEUE_REQ);
 			ahc_set_scsi_status(scb, SCSI_STATUS_OK);
+			ahc_platform_set_tags(ahc, &devinfo,
+				     (dev->flags & AHC_DEV_Q_BASIC)
+				   ? AHC_QUEUE_BASIC : AHC_QUEUE_TAGGED);
 			break;
 		}
 		/*
 		 * Drop down to a single opening, and treat this
-		 * as if the target return BUSY SCSI status.
+		 * as if the target returned BUSY SCSI status.
 		 */
 		dev->openings = 1;
+		ahc_set_scsi_status(scb, SCSI_STATUS_BUSY);
+		ahc_platform_set_tags(ahc, &devinfo,
+			     (dev->flags & AHC_DEV_Q_BASIC)
+			   ? AHC_QUEUE_BASIC : AHC_QUEUE_TAGGED);
 		/* FALLTHROUGH */
 	}
 	case SCSI_STATUS_BUSY:
@@ -2301,206 +4396,280 @@ ahc_linux_handle_scsi_status(struct ahc_
 }
 
 static void
-ahc_linux_filter_command(struct ahc_softc *ahc, Scsi_Cmnd *cmd, struct scb *scb)
+ahc_linux_queue_cmd_complete(struct ahc_softc *ahc, Scsi_Cmnd *cmd)
+{
+	/*
+	 * Typically, the complete queue has very few entries
+	 * queued to it before the queue is emptied by
+	 * ahc_linux_run_complete_queue, so sorting the entries
+	 * by generation number should be inexpensive.
+	 * We perform the sort so that commands that complete
+	 * with an error are retuned in the order origionally
+	 * queued to the controller so that any subsequent retries
+	 * are performed in order.  The underlying ahc routines do
+	 * not guarantee the order that aborted commands will be
+	 * returned to us.
+	 */
+	struct ahc_completeq *completeq;
+	struct ahc_cmd *list_cmd;
+	struct ahc_cmd *acmd;
+
+	/*
+	 * Map CAM error codes into Linux Error codes.  We
+	 * avoid the conversion so that the DV code has the
+	 * full error information available when making
+	 * state change decisions.
+	 */
+	if (AHC_DV_CMD(cmd) == FALSE) {
+		u_int new_status;
+
+		switch (ahc_cmd_get_transaction_status(cmd)) {
+		case CAM_REQ_INPROG:
+		case CAM_REQ_CMP:
+		case CAM_SCSI_STATUS_ERROR:
+			new_status = DID_OK;
+			break;
+		case CAM_REQ_ABORTED:
+			new_status = DID_ABORT;
+			break;
+		case CAM_BUSY:
+			new_status = DID_BUS_BUSY;
+			break;
+		case CAM_REQ_INVALID:
+		case CAM_PATH_INVALID:
+			new_status = DID_BAD_TARGET;
+			break;
+		case CAM_SEL_TIMEOUT:
+			new_status = DID_NO_CONNECT;
+			break;
+		case CAM_SCSI_BUS_RESET:
+		case CAM_BDR_SENT:
+			new_status = DID_RESET;
+			break;
+		case CAM_UNCOR_PARITY:
+			new_status = DID_PARITY;
+			break;
+		case CAM_CMD_TIMEOUT:
+			new_status = DID_TIME_OUT;
+			break;
+		case CAM_UA_ABORT:
+		case CAM_REQ_CMP_ERR:
+		case CAM_AUTOSENSE_FAIL:
+		case CAM_NO_HBA:
+		case CAM_DATA_RUN_ERR:
+		case CAM_UNEXP_BUSFREE:
+		case CAM_SEQUENCE_FAIL:
+		case CAM_CCB_LEN_ERR:
+		case CAM_PROVIDE_FAIL:
+		case CAM_REQ_TERMIO:
+		case CAM_UNREC_HBA_ERROR:
+		case CAM_REQ_TOO_BIG:
+			new_status = DID_ERROR;
+			break;
+		case CAM_REQUEUE_REQ:
+			/*
+			 * If we want the request requeued, make sure there
+			 * are sufficent retries.  In the old scsi error code,
+			 * we used to be able to specify a result code that
+			 * bypassed the retry count.  Now we must use this
+			 * hack.  We also "fake" a check condition with
+			 * a sense code of ABORTED COMMAND.  This seems to
+			 * evoke a retry even if this command is being sent
+			 * via the eh thread.  Ick!  Ick!  Ick!
+			 */
+			if (cmd->retries > 0)
+				cmd->retries--;
+			new_status = DID_OK;
+			ahc_cmd_set_scsi_status(cmd, SCSI_STATUS_CHECK_COND);
+			cmd->result |= (DRIVER_SENSE << 24);
+			memset(cmd->sense_buffer, 0,
+			       sizeof(cmd->sense_buffer));
+			cmd->sense_buffer[0] = SSD_ERRCODE_VALID
+					     | SSD_CURRENT_ERROR;
+			cmd->sense_buffer[2] = SSD_KEY_ABORTED_COMMAND;
+			break;
+		default:
+			/* We should never get here */
+			new_status = DID_ERROR;
+			break;
+		}
+
+		ahc_cmd_set_transaction_status(cmd, new_status);
+	}
+
+	completeq = &ahc->platform_data->completeq;
+	list_cmd = TAILQ_FIRST(completeq);
+	acmd = (struct ahc_cmd *)cmd;
+	while (list_cmd != NULL
+	    && acmd_scsi_cmd(list_cmd).serial_number
+	     < acmd_scsi_cmd(acmd).serial_number)
+		list_cmd = TAILQ_NEXT(list_cmd, acmd_links.tqe);
+	if (list_cmd != NULL)
+		TAILQ_INSERT_BEFORE(list_cmd, acmd, acmd_links.tqe);
+	else
+		TAILQ_INSERT_TAIL(completeq, acmd, acmd_links.tqe);
+}
+
+static void
+ahc_linux_filter_inquiry(struct ahc_softc *ahc, struct ahc_devinfo *devinfo)
 {
-	switch (cmd->cmnd[0]) {
-	case INQUIRY:
-	{
-		struct	ahc_devinfo devinfo;
-		struct	scsi_inquiry *inq;
-		struct	scsi_inquiry_data *sid;
-		struct	ahc_initiator_tinfo *tinfo;
-		struct	ahc_transinfo *user;
-		struct	ahc_transinfo *goal;
-		struct	ahc_transinfo *curr;
-		struct	ahc_tmode_tstate *tstate;
-		struct	ahc_syncrate *syncrate;
-		struct	ahc_linux_device *dev;
-		u_int	scsiid;
-		u_int	maxsync;
-		int	transferred_len;
-		int	minlen;
-		u_int	width;
-		u_int	period;
-		u_int	offset;
-		u_int	ppr_options;
-
-		 /*
-		  * Validate the command.  We only want to filter
-		  * standard inquiry commands, not those querying
-		  * Vital Product Data.
-		  */
-		inq = (struct scsi_inquiry *)cmd->cmnd;
-		if ((inq->byte2 & SI_EVPD) != 0
-		 || inq->page_code != 0)
-			break;
-
-		if (cmd->use_sg != 0) {
-			printf("%s: SG Inquiry response ignored\n",
-			       ahc_name(ahc));
-			break;
-		}
-		transferred_len = ahc_get_transfer_length(scb)
-				- ahc_get_residual(scb);
-		sid = (struct scsi_inquiry_data *)cmd->request_buffer;
+	struct	scsi_inquiry_data *sid;
+	struct	ahc_initiator_tinfo *tinfo;
+	struct	ahc_transinfo *user;
+	struct	ahc_transinfo *goal;
+	struct	ahc_transinfo *curr;
+	struct	ahc_tmode_tstate *tstate;
+	struct	ahc_syncrate *syncrate;
+	struct	ahc_linux_device *dev;
+	u_int	maxsync;
+	u_int	width;
+	u_int	period;
+	u_int	offset;
+	u_int	ppr_options;
+	u_int	trans_version;
+	u_int	prot_version;
 
-		/*
-		 * Determine if this lun actually exists.  If so,
-		 * hold on to its corresponding device structure.
-		 * If not, make sure we release the device and
-		 * don't bother processing the rest of this inquiry
-		 * command.
-		 */
-		dev = ahc_linux_get_device(ahc, cmd->channel,
-					   cmd->target, cmd->lun,
-					   /*alloc*/FALSE);
-		if (transferred_len >= 1
-		 && SID_QUAL(sid) == SID_QUAL_LU_CONNECTED) {
+	/*
+	 * Determine if this lun actually exists.  If so,
+	 * hold on to its corresponding device structure.
+	 * If not, make sure we release the device and
+	 * don't bother processing the rest of this inquiry
+	 * command.
+	 */
+	dev = ahc_linux_get_device(ahc, devinfo->channel - 'A',
+				   devinfo->target, devinfo->lun,
+				   /*alloc*/TRUE);
 
-			dev->flags &= ~AHC_DEV_UNCONFIGURED;
-		} else {
-			dev->flags |= AHC_DEV_UNCONFIGURED;
-			break;
-		}
+	sid = (struct scsi_inquiry_data *)dev->target->inq_data;
+	if (SID_QUAL(sid) == SID_QUAL_LU_CONNECTED) {
 
-		/*
-		 * Update our notion of this device's transfer
-		 * negotiation capabilities.
-		 */
-		scsiid = BUILD_SCSIID(ahc, cmd);
-		ahc_compile_devinfo(&devinfo, SCSIID_OUR_ID(scsiid),
-				    cmd->target, cmd->lun,
-				    SCSIID_CHANNEL(ahc, scsiid),
-				    ROLE_INITIATOR);
-		tinfo = ahc_fetch_transinfo(ahc, devinfo.channel,
-					    devinfo.our_scsiid,
-					    devinfo.target, &tstate);
-		user = &tinfo->user;
-		goal = &tinfo->goal;
-		curr = &tinfo->curr;
-		width = user->width;
-		period = user->period;
-		offset = user->offset;
-		ppr_options = user->ppr_options;
-		minlen = offsetof(struct scsi_inquiry_data, version) + 1;
-		if (transferred_len >= minlen) {
-			curr->protocol_version = SID_ANSI_REV(sid);
+		dev->flags &= ~AHC_DEV_UNCONFIGURED;
+	} else {
+		dev->flags |= AHC_DEV_UNCONFIGURED;
+		return;
+	}
 
-			/*
-			 * Only attempt SPI3 once we've verified that
-			 * the device claims to support SPI3 features.
-			 */
-			if (curr->protocol_version < SCSI_REV_2)
-				curr->transport_version = SID_ANSI_REV(sid);
-			else
-				curr->transport_version = SCSI_REV_2;
-		}
+	/*
+	 * Update our notion of this device's transfer
+	 * negotiation capabilities.
+	 */
+	tinfo = ahc_fetch_transinfo(ahc, devinfo->channel,
+				    devinfo->our_scsiid,
+				    devinfo->target, &tstate);
+	user = &tinfo->user;
+	goal = &tinfo->goal;
+	curr = &tinfo->curr;
+	width = user->width;
+	period = user->period;
+	offset = user->offset;
+	ppr_options = user->ppr_options;
+	trans_version = user->transport_version;
+	prot_version = MIN(user->protocol_version, SID_ANSI_REV(sid));
 
-		minlen = offsetof(struct scsi_inquiry_data, flags) + 1;
-		if (transferred_len >= minlen
-		 && (sid->additional_length + 4) >= minlen) {
-			if ((sid->flags & SID_WBus16) == 0)
-				width = MSG_EXT_WDTR_BUS_8_BIT;
-			if ((sid->flags & SID_Sync) == 0) {
-				period = 0;
-				offset = 0;
-				ppr_options = 0;
-			}
-		} else {
-			/* Keep current settings */
-			break;
-		}
-		minlen = offsetof(struct scsi_inquiry_data, spi3data) + 1;
-		/*
-		 * This is a kludge to deal with inquiry requests that
-		 * are not large enough for us to pull the spi3/4 bits.
-		 * In this case, we assume that a device that tells us
-		 * they can provide inquiry data that spans the SPI3
-		 * bits and says its SCSI3 can handle a PPR request.
-		 * If the inquiry request has sufficient buffer space to
-		 * cover SPI3 bits, we honor them regardless of reported
-		 * SCSI REV.  We also allow any device that has had its
-		 * goal ppr_options set to allow DT speeds to keep that
-		 * option if a short inquiry occurs that would fail the
-		 * normal tests outlined above.
-		 */
-		if ((sid->additional_length + 4) >= minlen) {
-			if (transferred_len >= minlen) {
-				 if ((sid->spi3data & SID_SPI_CLOCK_DT) == 0)
-					ppr_options = 0;
-			} else if ((goal->ppr_options & MSG_EXT_PPR_DT_REQ)== 0)
-				ppr_options = 0;
+	/*
+	 * Only attempt SPI3/4 once we've verified that
+	 * the device claims to support SPI3/4 features.
+	 */
+	if (prot_version < SCSI_REV_2)
+		trans_version = SID_ANSI_REV(sid);
+	else
+		trans_version = SCSI_REV_2;
 
-			if (curr->protocol_version > SCSI_REV_2)
-				curr->transport_version = 3;
-		} else {
-			ppr_options = 0;
-		}
-		ahc_validate_width(ahc, /*tinfo limit*/NULL, &width,
-				   ROLE_UNKNOWN);
-		if ((ahc->features & AHC_ULTRA2) != 0)
-			maxsync = AHC_SYNCRATE_DT;
-		else if ((ahc->features & AHC_ULTRA) != 0)
-			maxsync = AHC_SYNCRATE_ULTRA;
-		else
-			maxsync = AHC_SYNCRATE_FAST;
+	if ((sid->flags & SID_WBus16) == 0)
+		width = MSG_EXT_WDTR_BUS_8_BIT;
+	if ((sid->flags & SID_Sync) == 0) {
+		period = 0;
+		offset = 0;
+		ppr_options = 0;
+	}
+	if ((sid->spi3data & SID_SPI_QAS) == 0)
+		ppr_options &= ~MSG_EXT_PPR_QAS_REQ;
+	if ((sid->spi3data & SID_SPI_CLOCK_DT) == 0)
+		ppr_options &= MSG_EXT_PPR_QAS_REQ;
+	if ((sid->spi3data & SID_SPI_IUS) == 0)
+		ppr_options &= (MSG_EXT_PPR_DT_REQ
+			      | MSG_EXT_PPR_QAS_REQ);
+
+	if (prot_version > SCSI_REV_2
+	 && ppr_options != 0)
+		trans_version = user->transport_version;
+
+	ahc_validate_width(ahc, /*tinfo limit*/NULL, &width, ROLE_UNKNOWN);
+	if ((ahc->features & AHC_ULTRA2) != 0)
+		maxsync = AHC_SYNCRATE_DT;
+	else if ((ahc->features & AHC_ULTRA) != 0)
+		maxsync = AHC_SYNCRATE_ULTRA;
+	else
+		maxsync = AHC_SYNCRATE_FAST;
 
-		syncrate = ahc_find_syncrate(ahc, &period,
-					     &ppr_options, maxsync);
-		ahc_validate_offset(ahc, /*tinfo limit*/NULL, syncrate,
-				    &offset, width, ROLE_UNKNOWN);
-		if (offset == 0 || period == 0) {
-			period = 0;
-			offset = 0;
-			ppr_options = 0;
-		}
-		/* Apply our filtered user settings. */
-		ahc_set_width(ahc, &devinfo, width,
-			      AHC_TRANS_GOAL, /*paused*/FALSE);
-		ahc_set_syncrate(ahc, &devinfo, syncrate, period,
-				 offset, ppr_options, AHC_TRANS_GOAL,
-				 /*paused*/FALSE);
-		break;
-	}
-	default:
-		panic("ahc_linux_filter_command: Unexpected Command type  %x\n",
-		      cmd->cmnd[0]);
-		break;
-	}
+	syncrate = ahc_find_syncrate(ahc, &period, &ppr_options, maxsync);
+	ahc_validate_offset(ahc, /*tinfo limit*/NULL, syncrate,
+			    &offset, width, ROLE_UNKNOWN);
+	if (offset == 0 || period == 0) {
+		period = 0;
+		offset = 0;
+		ppr_options = 0;
+	}
+	/* Apply our filtered user settings. */
+	curr->transport_version = trans_version;
+	curr->protocol_version = prot_version;
+	ahc_set_width(ahc, devinfo, width, AHC_TRANS_GOAL, /*paused*/FALSE);
+	ahc_set_syncrate(ahc, devinfo, syncrate, period,
+			 offset, ppr_options, AHC_TRANS_GOAL,
+			 /*paused*/FALSE);
 }
 
 static void
 ahc_linux_sem_timeout(u_long arg)
 {
-	struct semaphore *sem;
+	struct	ahc_softc *ahc;
+	u_long	s;
+
+	ahc = (struct ahc_softc *)arg;
 
-	sem = (struct semaphore *)arg;
-	up(sem);
+	ahc_lock(ahc, &s);
+	if ((ahc->platform_data->flags & AHC_UP_EH_SEMAPHORE) != 0) {
+		ahc->platform_data->flags &= ~AHC_UP_EH_SEMAPHORE;
+		up(&ahc->platform_data->eh_sem);
+	}
+	ahc_unlock(ahc, &s);
 }
 
 static void
-ahc_linux_freeze_sim_queue(struct ahc_softc *ahc)
+ahc_linux_freeze_simq(struct ahc_softc *ahc)
 {
 	ahc->platform_data->qfrozen++;
-	if (ahc->platform_data->qfrozen == 1)
+	if (ahc->platform_data->qfrozen == 1) {
 		scsi_block_requests(ahc->platform_data->host);
+
+		/* XXX What about Twin channels? */
+		ahc_platform_abort_scbs(ahc, CAM_TARGET_WILDCARD, ALL_CHANNELS,
+					CAM_LUN_WILDCARD, SCB_LIST_NULL,
+					ROLE_INITIATOR, CAM_REQUEUE_REQ);
+	}
 }
 
 static void
-ahc_linux_release_sim_queue(u_long arg)
+ahc_linux_release_simq(u_long arg)
 {
 	struct ahc_softc *ahc;
 	u_long s;
 	int    unblock_reqs;
 
 	ahc = (struct ahc_softc *)arg;
+
 	unblock_reqs = 0;
 	ahc_lock(ahc, &s);
 	if (ahc->platform_data->qfrozen > 0)
 		ahc->platform_data->qfrozen--;
-	if (ahc->platform_data->qfrozen == 0) {
+	if (ahc->platform_data->qfrozen == 0)
 		unblock_reqs = 1;
+	if (AHC_DV_SIMQ_FROZEN(ahc)
+	 && ((ahc->platform_data->flags & AHC_DV_WAIT_SIMQ_RELEASE) != 0)) {
+		ahc->platform_data->flags &= ~AHC_DV_WAIT_SIMQ_RELEASE;
+		up(&ahc->platform_data->dv_sem);
 	}
+	ahc_schedule_runq(ahc);
 	ahc_unlock(ahc, &s);
 	/*
 	 * There is still a race here.  The mid-layer
@@ -2508,14 +4677,8 @@ ahc_linux_release_sim_queue(u_long arg)
 	 * a bottom half handler to run the queues
 	 * so we can unblock with our own lock held.
 	 */
-	if (unblock_reqs) {
+	if (unblock_reqs)
 		scsi_unblock_requests(ahc->platform_data->host);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-		tasklet_schedule(&ahc->platform_data->runq_tasklet);
-#else
-		ahc_runq_tasklet((unsigned long)ahc);
-#endif
-	}
 }
 
 static void
@@ -2534,6 +4697,9 @@ ahc_linux_dev_timed_unfreeze(u_long arg)
 	if (dev->qfrozen == 0
 	 && (dev->flags & AHC_DEV_ON_RUN_LIST) == 0)
 		ahc_linux_run_device_queue(ahc, dev);
+	if (TAILQ_EMPTY(&dev->busyq)
+	 && dev->active == 0)
+		ahc_linux_free_device(ahc, dev);
 	ahc_unlock(ahc, &s);
 }
 
@@ -2549,37 +4715,55 @@ ahc_linux_queue_recovery_cmd(Scsi_Cmnd *
 	u_int  saved_scbptr;
 	u_int  active_scb_index;
 	u_int  last_phase;
+	u_int  saved_scsiid;
+	u_int  cdb_byte;
 	int    retval;
+	int    was_paused;
 	int    paused;
 	int    wait;
 	int    disconnected;
 
+	pending_scb = NULL;
 	paused = FALSE;
 	wait = FALSE;
-	ahc = *(struct ahc_softc **)cmd->host->hostdata;
+	ahc = *(struct ahc_softc **)cmd->device->host->hostdata;
 	acmd = (struct ahc_cmd *)cmd;
 
 	printf("%s:%d:%d:%d: Attempting to queue a%s message\n",
-	       ahc_name(ahc), cmd->channel, cmd->target, cmd->lun,
+	       ahc_name(ahc), cmd->device->channel,
+	       cmd->device->id, cmd->device->lun,
 	       flag == SCB_ABORT ? "n ABORT" : " TARGET RESET");
 
+	printf("CDB:");
+	for (cdb_byte = 0; cdb_byte < cmd->cmd_len; cdb_byte++)
+		printf(" 0x%x", cmd->cmnd[cdb_byte]);
+	printf("\n");
+
 	/*
-	 * It is a bug that the upper layer takes
-	 * this lock just prior to calling us.
+	 * In all versions of Linux, we have to work around
+	 * a major flaw in how the mid-layer is locked down
+	 * if we are to sleep successfully in our error handler
+	 * while allowing our interrupt handler to run.  Since
+	 * the midlayer acquires either the io_request_lock or
+	 * our lock prior to calling us, we must use the
+	 * spin_unlock_irq() method for unlocking our lock.
+	 * This will force interrupts to be enabled on the
+	 * current CPU.  Since the EH thread should not have
+	 * been running with CPU interrupts disabled other than
+	 * by acquiring either the io_request_lock or our own
+	 * lock, this *should* be safe.
 	 */
-	spin_unlock_irq(&io_request_lock);
-
-	ahc_lock(ahc, &s);
+	ahc_midlayer_entrypoint_lock(ahc, &s);
 
 	/*
 	 * First determine if we currently own this command.
 	 * Start by searching the device queue.  If not found
 	 * there, check the pending_scb list.  If not found
 	 * at all, and the system wanted us to just abort the
-	 * command return success.
+	 * command, return success.
 	 */
-	dev = ahc_linux_get_device(ahc, cmd->channel, cmd->target,
-				   cmd->lun, /*alloc*/FALSE);
+	dev = ahc_linux_get_device(ahc, cmd->device->channel, cmd->device->id,
+				   cmd->device->lun, /*alloc*/FALSE);
 
 	if (dev == NULL) {
 		/*
@@ -2587,7 +4771,8 @@ ahc_linux_queue_recovery_cmd(Scsi_Cmnd *
 		 * so we must not still own the command.
 		 */
 		printf("%s:%d:%d:%d: Is not an active device\n",
-		       ahc_name(ahc), cmd->channel, cmd->target, cmd->lun);
+		       ahc_name(ahc), cmd->device->channel, cmd->device->id,
+		       cmd->device->lun);
 		retval = SUCCESS;
 		goto no_cmd;
 	}
@@ -2599,7 +4784,8 @@ ahc_linux_queue_recovery_cmd(Scsi_Cmnd *
 
 	if (list_acmd != NULL) {
 		printf("%s:%d:%d:%d: Command found on device queue\n",
-		       ahc_name(ahc), cmd->channel, cmd->target, cmd->lun);
+		       ahc_name(ahc), cmd->device->channel, cmd->device->id,
+		       cmd->device->lun);
 		if (flag == SCB_ABORT) {
 			TAILQ_REMOVE(&dev->busyq, list_acmd, acmd_links.tqe);
 			cmd->result = DID_ABORT << 16;
@@ -2610,11 +4796,13 @@ ahc_linux_queue_recovery_cmd(Scsi_Cmnd *
 	}
 
 	if ((dev->flags & (AHC_DEV_Q_BASIC|AHC_DEV_Q_TAGGED)) == 0
-	 && ahc_search_untagged_queues(ahc, cmd, cmd->target,
-				       cmd->channel + 'A', cmd->lun,
+	 && ahc_search_untagged_queues(ahc, cmd, cmd->device->id,
+				       cmd->device->channel + 'A',
+				       cmd->device->lun,
 				       CAM_REQ_ABORTED, SEARCH_COMPLETE) != 0) {
 		printf("%s:%d:%d:%d: Command found on untagged queue\n",
-		       ahc_name(ahc), cmd->channel, cmd->target, cmd->lun);
+		       ahc_name(ahc), cmd->device->channel, cmd->device->id,
+		       cmd->device->lun);
 		retval = SUCCESS;
 		goto done;
 	}
@@ -2631,8 +4819,9 @@ ahc_linux_queue_recovery_cmd(Scsi_Cmnd *
 
 		/* Any SCB for this device will do for a target reset */
 		LIST_FOREACH(pending_scb, &ahc->pending_scbs, pending_links) {
-		  	if (ahc_match_scb(ahc, pending_scb, cmd->target,
-					  cmd->channel + 'A', CAM_LUN_WILDCARD,
+		  	if (ahc_match_scb(ahc, pending_scb, cmd->device->id,
+					  cmd->device->channel + 'A',
+					  CAM_LUN_WILDCARD,
 					  SCB_LIST_NULL, ROLE_INITIATOR) == 0)
 				break;
 		}
@@ -2640,7 +4829,8 @@ ahc_linux_queue_recovery_cmd(Scsi_Cmnd *
 
 	if (pending_scb == NULL) {
 		printf("%s:%d:%d:%d: Command not found\n",
-		       ahc_name(ahc), cmd->channel, cmd->target, cmd->lun);
+		       ahc_name(ahc), cmd->device->channel, cmd->device->id,
+		       cmd->device->lun);
 		goto no_cmd;
 	}
 
@@ -2654,52 +4844,47 @@ ahc_linux_queue_recovery_cmd(Scsi_Cmnd *
 
 	/*
 	 * Ensure that the card doesn't do anything
-	 * behind our back and that no selections have occurred
-	 * that have not been serviced.  Also make sure that we
-	 * didn't "just" miss an interrupt that would
-	 * affect this cmd.
-	 */
-	ahc->flags |= AHC_ALL_INTERRUPTS;
-	do {
-		if (paused)
-			ahc_unpause(ahc);
-		ahc_intr(ahc);
-		ahc_pause(ahc);
-		paused = TRUE;
-		ahc_outb(ahc, SCSISEQ, ahc_inb(ahc, SCSISEQ) & ~ENSELO);
-		ahc_clear_critical_section(ahc);
-	} while ((ahc_inb(ahc, INTSTAT) & INT_PEND) != 0
-	      || (ahc_inb(ahc, SSTAT0) & (SELDO|SELINGO)));
-	ahc->flags &= ~AHC_ALL_INTERRUPTS;
-
-	ahc_dump_card_state(ahc);
+	 * behind our back and that we didn't "just" miss
+	 * an interrupt that would affect this cmd.
+	 */
+	was_paused = ahc_is_paused(ahc);
+	ahc_pause_and_flushwork(ahc);
+	paused = TRUE;
 
 	if ((pending_scb->flags & SCB_ACTIVE) == 0) {
 		printf("%s:%d:%d:%d: Command already completed\n",
-		       ahc_name(ahc), cmd->channel, cmd->target, cmd->lun);
+		       ahc_name(ahc), cmd->device->channel, cmd->device->id,
+		       cmd->device->lun);
 		goto no_cmd;
 	}
 
+	printf("%s: At time of recovery, card was %spaused\n",
+	       ahc_name(ahc), was_paused ? "" : "not ");
+	ahc_dump_card_state(ahc);
+
 	disconnected = TRUE;
 	if (flag == SCB_ABORT) {
-		if (ahc_search_qinfifo(ahc, cmd->target, cmd->channel + 'A',
-				       cmd->lun, pending_scb->hscb->tag,
+		if (ahc_search_qinfifo(ahc, cmd->device->id,
+				       cmd->device->channel + 'A',
+				       cmd->device->lun,
+				       pending_scb->hscb->tag,
 				       ROLE_INITIATOR, CAM_REQ_ABORTED,
 				       SEARCH_COMPLETE) > 0) {
 			printf("%s:%d:%d:%d: Cmd aborted from QINFIFO\n",
-			       ahc_name(ahc), cmd->channel, cmd->target,
-					cmd->lun);
+			       ahc_name(ahc), cmd->device->channel,
+					cmd->device->id, cmd->device->lun);
 			retval = SUCCESS;
 			goto done;
 		}
-	} else if (ahc_search_qinfifo(ahc, cmd->target, cmd->channel + 'A',
-				      cmd->lun, pending_scb->hscb->tag,
+	} else if (ahc_search_qinfifo(ahc, cmd->device->id,
+				      cmd->device->channel + 'A',
+				      cmd->device->lun, pending_scb->hscb->tag,
 				      ROLE_INITIATOR, /*status*/0,
 				      SEARCH_COUNT) > 0) {
 		disconnected = FALSE;
 	}
 
-	if (disconnected && (ahc_inb(ahc, SEQ_FLAGS) & IDENTIFY_SEEN) != 0) {
+	if (disconnected && (ahc_inb(ahc, SEQ_FLAGS) & NOT_IDENTIFIED) == 0) {
 		struct scb *bus_scb;
 
 		bus_scb = ahc_lookup_scb(ahc, ahc_inb(ahc, SCB_TAG));
@@ -2707,7 +4892,7 @@ ahc_linux_queue_recovery_cmd(Scsi_Cmnd *
 			disconnected = FALSE;
 		else if (flag != SCB_ABORT
 		      && ahc_inb(ahc, SAVED_SCSIID) == pending_scb->hscb->scsiid
-		      && ahc_inb(ahc, SAVED_LUN) == pending_scb->hscb->lun)
+		      && ahc_inb(ahc, SAVED_LUN) == SCB_GET_LUN(pending_scb))
 			disconnected = FALSE;
 	}
 
@@ -2722,10 +4907,11 @@ ahc_linux_queue_recovery_cmd(Scsi_Cmnd *
 	last_phase = ahc_inb(ahc, LASTPHASE);
 	saved_scbptr = ahc_inb(ahc, SCBPTR);
 	active_scb_index = ahc_inb(ahc, SCB_TAG);
+	saved_scsiid = ahc_inb(ahc, SAVED_SCSIID);
 	if (last_phase != P_BUSFREE
 	 && (pending_scb->hscb->tag == active_scb_index
 	  || (flag == SCB_DEVICE_RESET
-	   && SCSIID_TARGET(ahc, ahc_inb(ahc, SAVED_SCSIID)) == cmd->target))) {
+	   && SCSIID_TARGET(ahc, saved_scsiid) == cmd->device->id))) {
 
 		/*
 		 * We're active on the bus, so assert ATN
@@ -2736,7 +4922,8 @@ ahc_linux_queue_recovery_cmd(Scsi_Cmnd *
 		ahc_outb(ahc, MSG_OUT, HOST_MSG);
 		ahc_outb(ahc, SCSISIGO, last_phase|ATNO);
 		printf("%s:%d:%d:%d: Device is active, asserting ATN\n",
-		       ahc_name(ahc), cmd->channel, cmd->target, cmd->lun);
+		       ahc_name(ahc), cmd->device->channel, cmd->device->id,
+		       cmd->device->lun);
 		wait = TRUE;
 	} else if (disconnected) {
 
@@ -2766,8 +4953,9 @@ ahc_linux_queue_recovery_cmd(Scsi_Cmnd *
 		 * same element in the SCB, SCB_NEXT, for
 		 * both the qinfifo and the disconnected list.
 		 */
-		ahc_search_disc_list(ahc, cmd->target, cmd->channel + 'A',
-				     cmd->lun, pending_scb->hscb->tag,
+		ahc_search_disc_list(ahc, cmd->device->id,
+				     cmd->device->channel + 'A',
+				     cmd->device->lun, pending_scb->hscb->tag,
 				     /*stop_on_first*/TRUE,
 				     /*remove*/TRUE,
 				     /*save_state*/FALSE);
@@ -2790,19 +4978,20 @@ ahc_linux_queue_recovery_cmd(Scsi_Cmnd *
 		 * so we are the next SCB for this target
 		 * to run.
 		 */
-		ahc_search_qinfifo(ahc, cmd->target, cmd->channel + 'A',
-				   cmd->lun, SCB_LIST_NULL, ROLE_INITIATOR,
-				   CAM_REQUEUE_REQ, SEARCH_COMPLETE);
-		ahc_print_path(ahc, pending_scb);
-		printf("Queuing a recovery SCB\n");
+		ahc_search_qinfifo(ahc, cmd->device->id,
+				   cmd->device->channel + 'A',
+				   cmd->device->lun, SCB_LIST_NULL,
+				   ROLE_INITIATOR, CAM_REQUEUE_REQ,
+				   SEARCH_COMPLETE);
 		ahc_qinfifo_requeue_tail(ahc, pending_scb);
 		ahc_outb(ahc, SCBPTR, saved_scbptr);
-		printf("%s:%d:%d:%d: Device is disconnected, re-queuing SCB\n",
-		       ahc_name(ahc), cmd->channel, cmd->target, cmd->lun);
+		ahc_print_path(ahc, pending_scb);
+		printf("Device is disconnected, re-queuing SCB\n");
 		wait = TRUE;
 	} else {
 		printf("%s:%d:%d:%d: Unable to deliver message\n",
-		       ahc_name(ahc), cmd->channel, cmd->target, cmd->lun);
+		       ahc_name(ahc), cmd->device->channel, cmd->device->id,
+		       cmd->device->lun);
 		retval = FAILED;
 		goto done;
 	}
@@ -2822,176 +5011,29 @@ done:
 		struct timer_list timer;
 		int ret;
 
-		ahc_unlock(ahc, &s);
+		ahc->platform_data->flags |= AHC_UP_EH_SEMAPHORE;
+		spin_unlock_irq(&ahc->platform_data->spin_lock);
 		init_timer(&timer);
-		timer.data = (u_long)&ahc->platform_data->eh_sem;
+		timer.data = (u_long)ahc;
 		timer.expires = jiffies + (5 * HZ);
 		timer.function = ahc_linux_sem_timeout;
 		add_timer(&timer);
 		printf("Recovery code sleeping\n");
 		down(&ahc->platform_data->eh_sem);
 		printf("Recovery code awake\n");
-        	ret = del_timer(&timer);
+        	ret = del_timer_sync(&timer);
 		if (ret == 0) {
 			printf("Timer Expired\n");
 			retval = FAILED;
 		}
-		ahc_lock(ahc, &s);
+		spin_lock_irq(&ahc->platform_data->spin_lock);
 	}
-	acmd = TAILQ_FIRST(&ahc->platform_data->completeq);
-	TAILQ_INIT(&ahc->platform_data->completeq);
-	ahc_unlock(ahc, &s);
-	if (acmd != NULL)
-		ahc_linux_run_complete_queue(ahc, acmd);
-	ahc_runq_tasklet((unsigned long)ahc);
-	spin_lock_irq(&io_request_lock);
+	ahc_schedule_runq(ahc);
+	ahc_linux_run_complete_queue(ahc);
+	ahc_midlayer_entrypoint_unlock(ahc, &s);
 	return (retval);
 }
 
-/*
- * Abort the current SCSI command(s).
- */
-int
-ahc_linux_abort(Scsi_Cmnd *cmd)
-{
-	int error;
-
-	error = ahc_linux_queue_recovery_cmd(cmd, SCB_ABORT);
-	if (error != 0)
-		printf("aic7xxx_abort returns 0x%x\n", error);
-	return (error);
-}
-
-/*
- * Attempt to send a target reset message to the device that timed out.
- */
-int
-ahc_linux_dev_reset(Scsi_Cmnd *cmd)
-{
-	int error;
-
-	error = ahc_linux_queue_recovery_cmd(cmd, SCB_DEVICE_RESET);
-	if (error != 0)
-		printf("aic7xxx_dev_reset returns 0x%x\n", error);
-	return (error);
-}
-
-/*
- * Reset the SCSI bus.
- */
-int
-ahc_linux_bus_reset(Scsi_Cmnd *cmd)
-{
-	struct ahc_softc *ahc;
-	struct ahc_cmd *acmd;
-	u_long s;
-	int    found;
-
-	/*
-	 * It is a bug that the upper layer takes
-	 * this lock just prior to calling us.
-	 */
-	spin_unlock_irq(&io_request_lock);
-
-	ahc = *(struct ahc_softc **)cmd->host->hostdata;
-	ahc_lock(ahc, &s);
-	found = ahc_reset_channel(ahc, cmd->channel + 'A',
-				  /*initiate reset*/TRUE);
-	acmd = TAILQ_FIRST(&ahc->platform_data->completeq);
-	TAILQ_INIT(&ahc->platform_data->completeq);
-	ahc_unlock(ahc, &s);
-	if (bootverbose)
-		printf("%s: SCSI bus reset delivered. "
-		       "%d SCBs aborted.\n", ahc_name(ahc), found);
-
-	if (acmd != NULL)
-		ahc_linux_run_complete_queue(ahc, acmd);
-
-	spin_lock_irq(&io_request_lock);
-	return SUCCESS;
-}
-
-/*
- * Return the disk geometry for the given SCSI device.
- */
-int
-ahc_linux_biosparam(Disk *disk, kdev_t dev, int geom[])
-{
-	int	heads;
-	int	sectors;
-	int	cylinders;
-	int	ret;
-	int	extended;
-	struct	ahc_softc *ahc;
-	struct	buffer_head *bh;
-
-	ahc = *((struct ahc_softc **)disk->device->host->hostdata);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,17)
-	bh = bread(MKDEV(MAJOR(dev), MINOR(dev) & ~0xf), 0, block_size(dev));
-#else
-	bh = bread(MKDEV(MAJOR(dev), MINOR(dev) & ~0xf), 0, 1024);
-#endif
-
-	if (bh) {
-		ret = scsi_partsize(bh, disk->capacity,
-				    &geom[2], &geom[0], &geom[1]);
-		brelse(bh);
-		if (ret != -1)
-			return (ret);
-	}
-	heads = 64;
-	sectors = 32;
-	cylinders = disk->capacity / (heads * sectors);
-
-	if (aic7xxx_extended != 0)
-		extended = 1;
-	else if (disk->device->channel == 0)
-		extended = (ahc->flags & AHC_EXTENDED_TRANS_A) != 0;
-	else
-		extended = (ahc->flags & AHC_EXTENDED_TRANS_B) != 0;
-	if (extended && cylinders >= 1024) {
-		heads = 255;
-		sectors = 63;
-		cylinders = disk->capacity / (heads * sectors);
-	}
-	geom[0] = heads;
-	geom[1] = sectors;
-	geom[2] = cylinders;
-	return (0);
-}
-
-/*
- * Free the passed in Scsi_Host memory structures prior to unloading the
- * module.
- */
-int
-ahc_linux_release(struct Scsi_Host * host)
-{
-	struct ahc_softc *ahc;
-	u_long l;
-
-	ahc_list_lock(&l);
-	if (host != NULL) {
-
-		/*
-		 * We should be able to just perform
-		 * the free directly, but check our
-		 * list for extra sanity.
-		 */
-		ahc = ahc_find_softc(*(struct ahc_softc **)host->hostdata);
-		if (ahc != NULL) {
-			u_long s;
-
-			ahc_lock(ahc, &s);
-			ahc_intr_enable(ahc, FALSE);
-			ahc_unlock(ahc, &s);
-			ahc_free(ahc);
-		}
-	}
-	ahc_list_unlock(&l);
-	return (0);
-}
-
 void
 ahc_platform_dump_card_state(struct ahc_softc *ahc)
 {
@@ -3031,8 +5073,57 @@ ahc_platform_dump_card_state(struct ahc_
 	}
 }
 
-#if defined(MODULE) || LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
-static Scsi_Host_Template driver_template = AIC7XXX;
-Scsi_Host_Template *aic7xxx_driver_template = &driver_template;
-#include "../scsi_module.c"
+static int __init
+ahc_linux_init(void)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	return (ahc_linux_detect(&aic7xxx_driver_template) ? 0 : -ENODEV);
+#else
+	scsi_register_module(MODULE_SCSI_HA, &aic7xxx_driver_template);
+	if (aic7xxx_driver_template.present == 0) {
+		scsi_unregister_module(MODULE_SCSI_HA,
+				       &aic7xxx_driver_template);
+		return (-ENODEV);
+	}
+
+	return (0);
+#endif
+}
+
+static void __exit
+ahc_linux_exit(void)
+{
+	struct ahc_softc *ahc;
+	u_long l;
+
+	/*
+	 * Shutdown DV threads before going into the SCSI mid-layer.
+	 * This avoids situations where the mid-layer locks the entire
+	 * kernel so that waiting for our DV threads to exit leads
+	 * to deadlock.
+	 */
+	ahc_list_lock(&l);
+	TAILQ_FOREACH(ahc, &ahc_tailq, links) {
+
+		ahc_linux_kill_dv_thread(ahc);
+	}
+	ahc_list_unlock(&l);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	/*
+	 * In 2.4 we have to unregister from the PCI core _after_
+	 * unregistering from the scsi midlayer to avoid dangling
+	 * references.
+	 */
+	scsi_unregister_module(MODULE_SCSI_HA, &aic7xxx_driver_template);
+#endif
+#ifdef CONFIG_PCI
+	ahc_linux_pci_exit();
+#endif
+#ifdef CONFIG_EISA
+	ahc_linux_eisa_exit();
 #endif
+}
+
+module_init(ahc_linux_init);
+module_exit(ahc_linux_exit);
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx_osm.h linux-5730/drivers/scsi/aic7xxx/aic7xxx_osm.h
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx_osm.h
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx_osm.h
@@ -18,9 +18,7 @@
  * along with this program; see the file COPYING.  If not, write to
  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
  * 
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#82 $
- *
- * Copyright (c) 2000-2001 Adaptec Inc.
+ * Copyright (c) 2000-2003 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -55,7 +53,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#82 $
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm.h#150 $
  *
  */
 #ifndef _AIC7XXX_LINUX_H_
@@ -67,12 +65,11 @@
 #include <linux/delay.h>
 #include <linux/ioport.h>
 #include <linux/pci.h>
+#include <linux/smp_lock.h>
 #include <linux/version.h>
-#ifndef AHC_MODVERSION_FILE
-#define __NO_VERSION__
-#endif
 #include <linux/module.h>
 #include <asm/byteorder.h>
+#include <asm/io.h>
 
 #ifndef KERNEL_VERSION
 #define KERNEL_VERSION(x,y,z) (((x)<<16)+((y)<<8)+(z))
@@ -87,8 +84,9 @@
 #endif
 
 /* Core SCSI definitions */
-#include "../scsi.h"
-#include "../hosts.h"
+#define AIC_LIB_PREFIX ahc
+#include "scsi.h"
+#include "hosts.h"
 
 /* Name space conflict with BSD queue macros */
 #ifdef LIST_HEAD
@@ -98,6 +96,21 @@
 #include "cam.h"
 #include "queue.h"
 #include "scsi_message.h"
+#include "aiclib.h"
+
+/*********************************** Debugging ********************************/
+#ifdef CONFIG_AIC7XXX_DEBUG_ENABLE
+#ifdef CONFIG_AIC7XXX_DEBUG_MASK
+#define AHC_DEBUG 1
+#define AHC_DEBUG_OPTS CONFIG_AIC7XXX_DEBUG_MASK
+#else
+/*
+ * Compile in debugging code, but do not enable any printfs.
+ */
+#define AHC_DEBUG 1
+#endif
+/* No debugging code. */
+#endif
 
 /************************* Forward Declarations *******************************/
 struct ahc_softc;
@@ -137,9 +150,10 @@ typedef Scsi_Cmnd      *ahc_io_ctx_t;
 #endif /* BYTE_ORDER */
 
 /************************* Configuration Data *********************************/
-extern int aic7xxx_no_probe;
+extern u_int aic7xxx_no_probe;
+extern u_int aic7xxx_allow_memio;
 extern int aic7xxx_detect_complete;
-extern Scsi_Host_Template* aic7xxx_driver_template;
+extern Scsi_Host_Template aic7xxx_driver_template;
 
 /***************************** Bus Space/DMA **********************************/
 
@@ -240,176 +254,58 @@ int	ahc_dmamap_unload(struct ahc_softc *
  */
 #define ahc_dmamap_sync(ahc, dma_tag, dmamap, offset, len, op)
 
-/************************** SCSI Constants/Structures *************************/
-#define SCSI_REV_2 2
-#define	SCSI_STATUS_OK			0x00
-#define	SCSI_STATUS_CHECK_COND		0x02
-#define	SCSI_STATUS_COND_MET		0x04
-#define	SCSI_STATUS_BUSY		0x08
-#define SCSI_STATUS_INTERMED		0x10
-#define SCSI_STATUS_INTERMED_COND_MET	0x14
-#define SCSI_STATUS_RESERV_CONFLICT	0x18
-#define SCSI_STATUS_CMD_TERMINATED	0x22
-#define SCSI_STATUS_QUEUE_FULL		0x28
-
-/*
- * 6 byte request sense CDB format.
- */
-struct scsi_sense
-{
-	uint8_t opcode;
-	uint8_t byte2;
-	uint8_t unused[2];
-	uint8_t length;
-	uint8_t control;
-};
+/************************** Timer DataStructures ******************************/
+typedef struct timer_list ahc_timer_t;
 
-struct scsi_sense_data
-{
-	uint8_t	error_code;
-	uint8_t	segment;
-	uint8_t	flags;
-	uint8_t	info[4];
-	uint8_t	extra_len;
-	uint8_t	cmd_spec_info[4];
-	uint8_t add_sense_code;
-	uint8_t add_sense_code_qual;
-	uint8_t	fru;
-	uint8_t	sense_key_spec[3];
-	uint8_t	extra_bytes[14];
-};
+/********************************** Includes **********************************/
+#ifdef CONFIG_AIC7XXX_REG_PRETTY_PRINT
+#define AIC_DEBUG_REGISTERS 1
+#else
+#define AIC_DEBUG_REGISTERS 0
+#endif
+#include "aic7xxx.h"
 
-struct scsi_inquiry
-{ 
-	u_int8_t opcode;
-	u_int8_t byte2;
-#define	SI_EVPD 0x01
-	u_int8_t page_code;
-	u_int8_t reserved;
-	u_int8_t length;
-	u_int8_t control;
-};
+/***************************** Timer Facilities *******************************/
+#define ahc_timer_init init_timer
+#define ahc_timer_stop del_timer_sync
+typedef void ahc_linux_callback_t (u_long);  
+static __inline void ahc_timer_reset(ahc_timer_t *timer, int usec,
+				     ahc_callback_t *func, void *arg);
+static __inline void ahc_scb_timer_reset(struct scb *scb, u_int usec);
 
-struct scsi_inquiry_data
+static __inline void
+ahc_timer_reset(ahc_timer_t *timer, int usec, ahc_callback_t *func, void *arg)
 {
-	uint8_t device;
-#define	SID_TYPE(inq_data) ((inq_data)->device & 0x1f)
-#define	SID_QUAL(inq_data) (((inq_data)->device & 0xE0) >> 5)
-#define	SID_QUAL_LU_CONNECTED	0x00	/*
-					 * The specified peripheral device
-					 * type is currently connected to
-					 * logical unit.  If the target cannot
-					 * determine whether or not a physical
-					 * device is currently connected, it
-					 * shall also use this peripheral
-					 * qualifier when returning the INQUIRY
-					 * data.  This peripheral qualifier
-					 * does not mean that the device is
-					 * ready for access by the initiator.
-					 */
-#define	SID_QUAL_LU_OFFLINE	0x01	/*
-					 * The target is capable of supporting
-					 * the specified peripheral device type
-					 * on this logical unit; however, the
-					 * physical device is not currently
-					 * connected to this logical unit.
-					 */
-#define SID_QUAL_RSVD		0x02
-#define	SID_QUAL_BAD_LU		0x03	/*
-					 * The target is not capable of
-					 * supporting a physical device on
-					 * this logical unit. For this
-					 * peripheral qualifier the peripheral
-					 * device type shall be set to 1Fh to
-					 * provide compatibility with previous
-					 * versions of SCSI. All other
-					 * peripheral device type values are
-					 * reserved for this peripheral
-					 * qualifier.
-					 */
-#define	SID_QUAL_IS_VENDOR_UNIQUE(inq_data) ((SID_QUAL(inq_data) & 0x08) != 0)
-	uint8_t dev_qual2;
-#define	SID_QUAL2	0x7F
-#define	SID_IS_REMOVABLE(inq_data) (((inq_data)->dev_qual2 & 0x80) != 0)
-	uint8_t version;
-#define SID_ANSI_REV(inq_data) ((inq_data)->version & 0x07)
-#define		SCSI_REV_0		0
-#define		SCSI_REV_CCS		1
-#define		SCSI_REV_2		2
-#define		SCSI_REV_SPC		3
-#define		SCSI_REV_SPC2		4
-
-#define SID_ECMA	0x38
-#define SID_ISO		0xC0
-	uint8_t response_format;
-#define SID_AENC	0x80
-#define SID_TrmIOP	0x40
-	uint8_t additional_length;
-	uint8_t reserved[2];
-	uint8_t flags;
-#define	SID_SftRe	0x01
-#define	SID_CmdQue	0x02
-#define	SID_Linked	0x08
-#define	SID_Sync	0x10
-#define	SID_WBus16	0x20
-#define	SID_WBus32	0x40
-#define	SID_RelAdr	0x80
-#define SID_VENDOR_SIZE   8
-	char	 vendor[SID_VENDOR_SIZE];
-#define SID_PRODUCT_SIZE  16
-	char	 product[SID_PRODUCT_SIZE];
-#define SID_REVISION_SIZE 4
-	char	 revision[SID_REVISION_SIZE];
-	/*
-	 * The following fields were taken from SCSI Primary Commands - 2
-	 * (SPC-2) Revision 14, Dated 11 November 1999
-	 */
-#define	SID_VENDOR_SPECIFIC_0_SIZE	20
-	u_int8_t vendor_specific0[SID_VENDOR_SPECIFIC_0_SIZE];
-	/*
-	 * An extension of SCSI Parallel Specific Values
-	 */
-#define	SID_SPI_IUS		0x01
-#define	SID_SPI_QAS		0x02
-#define	SID_SPI_CLOCK_ST	0x00
-#define	SID_SPI_CLOCK_DT	0x04
-#define	SID_SPI_CLOCK_DT_ST	0x0C
-#define	SID_SPI_MASK		0x0F
-	uint8_t spi3data;
-	uint8_t reserved2;
-	/*
-	 * Version Descriptors, stored 2 byte values.
-	 */
-	uint8_t version1[2];
-	uint8_t version2[2];
-	uint8_t version3[2];
-	uint8_t version4[2];
-	uint8_t version5[2];
-	uint8_t version6[2];
-	uint8_t version7[2];
-	uint8_t version8[2];
-
-	uint8_t reserved3[22];
+	struct ahc_softc *ahc;
 
-#define	SID_VENDOR_SPECIFIC_1_SIZE	160
-	uint8_t vendor_specific1[SID_VENDOR_SPECIFIC_1_SIZE];
-};
-
-/********************************** Includes **********************************/
-/* Host template and function declarations referenced by the template. */
-#include "aic7xxx_host.h"
+	ahc = (struct ahc_softc *)arg;
+	del_timer(timer);
+	timer->data = (u_long)arg;
+	timer->expires = jiffies + (usec * HZ)/1000000;
+	timer->function = (ahc_linux_callback_t*)func;
+	add_timer(timer);
+}
 
-/* Core driver definitions */
-#include "aic7xxx.h"
+static __inline void
+ahc_scb_timer_reset(struct scb *scb, u_int usec)
+{
+	mod_timer(&scb->io_ctx->eh_timeout, jiffies + (usec * HZ)/1000000);
+}
 
-/* SMP support */
+/***************************** SMP support ************************************/
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,17)
 #include <linux/spinlock.h>
 #elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,93)
 #include <linux/smp.h>
 #endif
 
-#define AIC7XXX_DRIVER_VERSION  "6.2.8"
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) || defined(SCSI_HAS_HOST_LOCK))
+#define AHC_SCSI_HAS_HOST_LOCK 1
+#else
+#define AHC_SCSI_HAS_HOST_LOCK 0
+#endif
+
+#define AIC7XXX_DRIVER_VERSION "6.2.36"
 
 /**************************** Front End Queues ********************************/
 /*
@@ -444,7 +340,7 @@ struct ahc_cmd {
 /*
  * A per probed device structure used to deal with some error recovery
  * scenarios that the Linux mid-layer code just doesn't know how to
- * handle.  The structure allocated for a device only becomes persistant
+ * handle.  The structure allocated for a device only becomes persistent
  * after a successfully completed inquiry command to the target when
  * that inquiry data indicates a lun is present.
  */
@@ -456,8 +352,9 @@ typedef enum {
 	AHC_DEV_ON_RUN_LIST	 = 0x08, /* Queued to be run later */
 	AHC_DEV_Q_BASIC		 = 0x10, /* Allow basic device queuing */
 	AHC_DEV_Q_TAGGED	 = 0x20, /* Allow full SCSI2 command queueing */
-	AHC_DEV_PERIODIC_OTAG	 = 0x40	 /* Send OTAG to prevent starvation */
-} ahc_dev_flags;
+	AHC_DEV_PERIODIC_OTAG	 = 0x40, /* Send OTAG to prevent starvation */
+	AHC_DEV_SLAVE_CONFIGURED = 0x80	 /* slave_configure() has been called */
+} ahc_linux_dev_flags;
 
 struct ahc_linux_target;
 struct ahc_linux_device {
@@ -500,7 +397,7 @@ struct ahc_linux_device {
 	u_int			tag_success_count;
 #define AHC_TAG_SUCCESS_INTERVAL 50
 
-	ahc_dev_flags		flags;
+	ahc_linux_dev_flags	flags;
 
 	/*
 	 * Per device timer.
@@ -540,16 +437,54 @@ struct ahc_linux_device {
 #define AHC_OTAG_THRESH	500
 
 	int			lun;
+	Scsi_Device	       *scsi_device;
 	struct			ahc_linux_target *target;
 };
 
+typedef enum {
+	AHC_DV_REQUIRED		 = 0x01,
+	AHC_INQ_VALID		 = 0x02,
+	AHC_BASIC_DV		 = 0x04,
+	AHC_ENHANCED_DV		 = 0x08
+} ahc_linux_targ_flags;
+
+/* DV States */
+typedef enum {
+	AHC_DV_STATE_EXIT = 0,
+	AHC_DV_STATE_INQ_SHORT_ASYNC,
+	AHC_DV_STATE_INQ_ASYNC,
+	AHC_DV_STATE_INQ_ASYNC_VERIFY,
+	AHC_DV_STATE_TUR,
+	AHC_DV_STATE_REBD,
+	AHC_DV_STATE_INQ_VERIFY,
+	AHC_DV_STATE_WEB,
+	AHC_DV_STATE_REB,
+	AHC_DV_STATE_SU,
+	AHC_DV_STATE_BUSY
+} ahc_dv_state;
+
 struct ahc_linux_target {
-	struct	ahc_linux_device *devices[AHC_NUM_LUNS];
-	int	channel;
-	int	target;
-	int	refcount;
-	struct	ahc_transinfo last_tinfo;
-	struct	ahc_softc *ahc;
+	struct ahc_linux_device	 *devices[AHC_NUM_LUNS];
+	int			  channel;
+	int			  target;
+	int			  refcount;
+	struct ahc_transinfo	  last_tinfo;
+	struct ahc_softc	 *ahc;
+	ahc_linux_targ_flags	  flags;
+	struct scsi_inquiry_data *inq_data;
+	/*
+	 * The next "fallback" period to use for narrow/wide transfers.
+	 */
+	uint8_t			  dv_next_narrow_period;
+	uint8_t			  dv_next_wide_period;
+	uint8_t			  dv_max_width;
+	uint8_t			  dv_max_ppr_options;
+	uint8_t			  dv_last_ppr_options;
+	u_int			  dv_echo_size;
+	ahc_dv_state		  dv_state;
+	u_int			  dv_state_retry;
+	char			 *dv_buffer;
+	char			 *dv_buffer1;
 };
 
 /********************* Definitions Required by the Core ***********************/
@@ -559,11 +494,26 @@ struct ahc_linux_target {
  * manner and are allocated below 4GB, the number of S/G segments is
  * unrestricted.
  */
-#define        AHC_NSEG 128
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+/*
+ * We dynamically adjust the number of segments in pre-2.5 kernels to
+ * avoid fragmentation issues in the SCSI mid-layer's private memory
+ * allocator.  See aic7xxx_osm.c ahc_linux_size_nseg() for details.
+ */
+extern u_int ahc_linux_nseg;
+#define	AHC_NSEG ahc_linux_nseg
+#define	AHC_LINUX_MIN_NSEG 64
+#else
+#define	AHC_NSEG 128
+#endif
 
 /*
  * Per-SCB OSM storage.
  */
+typedef enum {
+	AHC_UP_EH_SEMAPHORE = 0x1
+} ahc_linux_scb_flags;
+
 struct scb_platform_data {
 	struct ahc_linux_device	*dev;
 	bus_addr_t		 buf_busaddr;
@@ -571,6 +521,8 @@ struct scb_platform_data {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
 	uint32_t		 resid;		/* Transfer residual */
 #endif
+	uint32_t		 sense_resid;	/* Auto-Sense residual */
+	ahc_linux_scb_flags	 flags;
 };
 
 /*
@@ -579,7 +531,16 @@ struct scb_platform_data {
  * alignment restrictions of the various platforms supported by
  * this driver.
  */
+typedef enum {
+	AHC_DV_WAIT_SIMQ_EMPTY	 = 0x01,
+	AHC_DV_WAIT_SIMQ_RELEASE = 0x02,
+	AHC_DV_ACTIVE		 = 0x04,
+	AHC_DV_SHUTDOWN		 = 0x08,
+	AHC_RUN_CMPLT_Q_TIMER	 = 0x10
+} ahc_linux_softc_flags;
+
 TAILQ_HEAD(ahc_completeq, ahc_cmd);
+
 struct ahc_platform_data {
 	/*
 	 * Fields accessed from interrupt context.
@@ -588,21 +549,27 @@ struct ahc_platform_data {
 	TAILQ_HEAD(, ahc_linux_device) device_runq;
 	struct ahc_completeq	 completeq;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,0)
 	spinlock_t		 spin_lock;
-#endif
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 	struct tasklet_struct	 runq_tasklet;
 #endif
 	u_int			 qfrozen;
+	pid_t			 dv_pid;
+	struct timer_list	 completeq_timer;
 	struct timer_list	 reset_timer;
 	struct semaphore	 eh_sem;
+	struct semaphore	 dv_sem;
+	struct semaphore	 dv_cmd_sem;	/* XXX This needs to be in
+						 * the target struct
+						 */
+	struct scsi_device	*dv_scsi_dev;
 	struct Scsi_Host        *host;		/* pointer to scsi host */
 #define AHC_LINUX_NOIRQ	((uint32_t)~0)
 	uint32_t		 irq;		/* IRQ for this adapter */
 	uint32_t		 bios_address;
 	uint32_t		 mem_busaddr;	/* Mem Base Addr */
 	bus_addr_t		 hw_dma_mask;
+	ahc_linux_softc_flags	 flags;
 };
 
 /************************** OS Utility Wrappers *******************************/
@@ -635,7 +602,6 @@ ahc_delay(long usec)
 
 static __inline uint8_t ahc_inb(struct ahc_softc * ahc, long port);
 static __inline void ahc_outb(struct ahc_softc * ahc, long port, uint8_t val);
-static __inline void ahc_outb_reset(struct ahc_softc * ahc, long port, uint8_t val);
 static __inline void ahc_outsb(struct ahc_softc * ahc, long port,
 			       uint8_t *, int count);
 static __inline void ahc_insb(struct ahc_softc * ahc, long port,
@@ -665,22 +631,6 @@ ahc_outb(struct ahc_softc * ahc, long po
 #ifdef MMAPIO
 	if (ahc->tag == BUS_SPACE_MEMIO) {
 		writeb(val, ahc->bsh.maddr + port);
-		readb(ahc->bsh.maddr + HCNTRL); /* flush PCI posting */
-	} else {
-		outb(val, ahc->bsh.ioport + port);
-	}
-#else
-	outb(val, ahc->bsh.ioport + port);
-#endif
-	mb();
-}
-
-static __inline void
-ahc_outb_reset(struct ahc_softc * ahc, long port, uint8_t val)
-{
-#ifdef MMAPIO
-	if (ahc->tag == BUS_SPACE_MEMIO) {
-		writeb(val, ahc->bsh.maddr + port);
 	} else {
 		outb(val, ahc->bsh.ioport + port);
 	}
@@ -741,6 +691,12 @@ static __inline void ahc_lockinit(struct
 static __inline void ahc_lock(struct ahc_softc *, unsigned long *flags);
 static __inline void ahc_unlock(struct ahc_softc *, unsigned long *flags);
 
+/* Lock acquisition and release of the above lock in midlayer entry points. */
+static __inline void ahc_midlayer_entrypoint_lock(struct ahc_softc *,
+						  unsigned long *flags);
+static __inline void ahc_midlayer_entrypoint_unlock(struct ahc_softc *,
+						    unsigned long *flags);
+
 /* Lock held during command compeletion to the upper layer */
 static __inline void ahc_done_lockinit(struct ahc_softc *);
 static __inline void ahc_done_lock(struct ahc_softc *, unsigned long *flags);
@@ -752,7 +708,6 @@ static __inline void ahc_list_lockinit(v
 static __inline void ahc_list_lock(unsigned long *flags);
 static __inline void ahc_list_unlock(unsigned long *flags);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,1,93)
 static __inline void
 ahc_lockinit(struct ahc_softc *ahc)
 {
@@ -762,7 +717,6 @@ ahc_lockinit(struct ahc_softc *ahc)
 static __inline void
 ahc_lock(struct ahc_softc *ahc, unsigned long *flags)
 {
-	*flags = 0;
 	spin_lock_irqsave(&ahc->platform_data->spin_lock, *flags);
 }
 
@@ -773,102 +727,73 @@ ahc_unlock(struct ahc_softc *ahc, unsign
 }
 
 static __inline void
-ahc_done_lockinit(struct ahc_softc *ahc)
-{
-	/* We don't own the iorequest lock, so we don't initialize it. */
-}
-
-static __inline void
-ahc_done_lock(struct ahc_softc *ahc, unsigned long *flags)
-{
-	*flags = 0;
-	spin_lock_irqsave(&io_request_lock, *flags);
-}
-
-static __inline void
-ahc_done_unlock(struct ahc_softc *ahc, unsigned long *flags)
-{
-	spin_unlock_irqrestore(&io_request_lock, *flags);
-}
-
-static __inline void
-ahc_list_lockinit()
-{
-	spin_lock_init(&ahc_list_spinlock);
-}
-
-static __inline void
-ahc_list_lock(unsigned long *flags)
-{
-	*flags = 0;
-	spin_lock_irqsave(&ahc_list_spinlock, *flags);
-}
-
-static __inline void
-ahc_list_unlock(unsigned long *flags)
+ahc_midlayer_entrypoint_lock(struct ahc_softc *ahc, unsigned long *flags)
 {
-	spin_unlock_irqrestore(&ahc_list_spinlock, *flags);
-}
-
-#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0) */
-
-ahc_lockinit(struct ahc_softc *ahc)
-{
-}
-
-static __inline void
-ahc_lock(struct ahc_softc *ahc, unsigned long *flags)
-{
-	*flags = 0;
-	save_flags(*flags);
-	cli();
+	/*
+	 * In 2.5.X and some 2.4.X versions, the midlayer takes our
+	 * lock just before calling us, so we avoid locking again.
+	 * For other kernel versions, the io_request_lock is taken
+	 * just before our entry point is called.  In this case, we
+	 * trade the io_request_lock for our per-softc lock.
+	 */
+#if AHC_SCSI_HAS_HOST_LOCK == 0
+	spin_unlock(&io_request_lock);
+	spin_lock(&ahc->platform_data->spin_lock);
+#endif
 }
 
 static __inline void
-ahc_unlock(struct ahc_softc *ahc, unsigned long *flags)
+ahc_midlayer_entrypoint_unlock(struct ahc_softc *ahc, unsigned long *flags)
 {
-	restore_flags(*flags);
+#if AHC_SCSI_HAS_HOST_LOCK == 0
+	spin_unlock(&ahc->platform_data->spin_lock);
+	spin_lock(&io_request_lock);
+#endif
 }
 
 static __inline void
 ahc_done_lockinit(struct ahc_softc *ahc)
 {
+	/*
+	 * In 2.5.X, our own lock is held during completions.
+	 * In previous versions, the io_request_lock is used.
+	 * In either case, we can't initialize this lock again.
+	 */
 }
 
 static __inline void
 ahc_done_lock(struct ahc_softc *ahc, unsigned long *flags)
 {
-	/*
-	 * The done lock is always held while
-	 * the ahc lock is held so blocking
-	 * interrupts again would have no effect.
-	 */
+#if AHC_SCSI_HAS_HOST_LOCK == 0
+	spin_lock_irqsave(&io_request_lock, *flags);
+#endif
 }
 
 static __inline void
 ahc_done_unlock(struct ahc_softc *ahc, unsigned long *flags)
 {
+#if AHC_SCSI_HAS_HOST_LOCK == 0
+	spin_unlock_irqrestore(&io_request_lock, *flags);
+#endif
 }
 
 static __inline void
-ahc_list_lockinit()
+ahc_list_lockinit(void)
 {
+	spin_lock_init(&ahc_list_spinlock);
 }
 
 static __inline void
 ahc_list_lock(unsigned long *flags)
 {
-	*flags = 0;
-	save_flags(*flags);
-	cli();
+	spin_lock_irqsave(&ahc_list_spinlock, *flags);
 }
 
 static __inline void
 ahc_list_unlock(unsigned long *flags)
 {
-	restore_flags(*flags);
+	spin_unlock_irqrestore(&ahc_list_spinlock, *flags);
 }
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,1,0) */
 
 /******************************* PCI Definitions ******************************/
 /*
@@ -889,6 +814,7 @@ ahc_list_unlock(unsigned long *flags)
 #define PCIM_CMD_BUSMASTEREN	0x0004
 #define PCIM_CMD_MWRICEN	0x0010
 #define PCIM_CMD_PERRESPEN	0x0040
+#define	PCIM_CMD_SERRESPEN	0x0100
 #define PCIR_STATUS		0x06
 #define PCIR_REVID		0x08
 #define PCIR_PROGIF		0x09
@@ -918,26 +844,28 @@ typedef enum
 	AHC_POWER_STATE_D3
 } ahc_power_state;
 
-void ahc_power_state_change(struct ahc_softc *ahc,
-			    ahc_power_state new_state);
 /**************************** VL/EISA Routines ********************************/
-int			 aic7770_linux_probe(Scsi_Host_Template *);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0) \
+  && (defined(__i386__) || defined(__alpha__)) \
+  && (!defined(CONFIG_EISA)))
+#define CONFIG_EISA
+#endif
+
+#ifdef CONFIG_EISA
+extern uint32_t aic7xxx_probe_eisa_vl;
+void			 ahc_linux_eisa_init(void);
+void			 ahc_linux_eisa_exit(void);
 int			 aic7770_map_registers(struct ahc_softc *ahc,
 					       u_int port);
 int			 aic7770_map_int(struct ahc_softc *ahc, u_int irq);
-
-/******************************* PCI Routines *********************************/
-/*
- * We need to use the bios32.h routines if we are kernel version 2.1.92 or less.
- */
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,1,92)
-#if defined(__sparc_v9__) || defined(__powerpc__)
-#error "PPC and Sparc platforms are only support under 2.1.92 and above"
-#endif
-#include <linux/bios32.h>
 #endif
 
-int			 ahc_linux_pci_probe(Scsi_Host_Template *);
+/******************************* PCI Routines *********************************/
+#ifdef CONFIG_PCI
+void			 ahc_power_state_change(struct ahc_softc *ahc,
+						ahc_power_state new_state);
+int			 ahc_linux_pci_init(void);
+void			 ahc_linux_pci_exit(void);
 int			 ahc_pci_map_registers(struct ahc_softc *ahc);
 int			 ahc_pci_map_int(struct ahc_softc *ahc);
 
@@ -1017,6 +945,7 @@ ahc_get_pci_bus(ahc_dev_softc_t pci)
 {
 	return (pci->bus->number);
 }
+#endif
 
 static __inline void ahc_flush_device_writes(struct ahc_softc *);
 static __inline void
@@ -1036,38 +965,104 @@ ahc_flush_device_writes(struct ahc_softc
 #define pci_unmap_single(pdev, buffer, buflen, direction)
 #endif
 
-/*********************** Transaction Access Wrappers **************************/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,3)
+#define ahc_pci_set_dma_mask pci_set_dma_mask
+#else
+/*
+ * Always "return" 0 for success.
+ */
+#define ahc_pci_set_dma_mask(dev_softc, mask)  			\
+	(((dev_softc)->dma_mask = mask) && 0)
+#endif
+/**************************** Proc FS Support *********************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+int	ahc_linux_proc_info(char *, char **, off_t, int, int, int);
+#else
+int	ahc_linux_proc_info(struct Scsi_Host *, char *, char **,
+			    off_t, int, int);
+#endif
+
+/*************************** Domain Validation ********************************/
+#define AHC_DV_CMD(cmd) ((cmd)->scsi_done == ahc_linux_dv_complete)
+#define AHC_DV_SIMQ_FROZEN(ahc)					\
+	((((ahc)->platform_data->flags & AHC_DV_ACTIVE) != 0)	\
+	 && (ahc)->platform_data->qfrozen == 1)
+
+/*********************** Transaction Access Wrappers *************************/
+static __inline void ahc_cmd_set_transaction_status(Scsi_Cmnd *, uint32_t);
 static __inline void ahc_set_transaction_status(struct scb *, uint32_t);
+static __inline void ahc_cmd_set_scsi_status(Scsi_Cmnd *, uint32_t);
+static __inline void ahc_set_scsi_status(struct scb *, uint32_t);
+static __inline uint32_t ahc_cmd_get_transaction_status(Scsi_Cmnd *cmd);
+static __inline uint32_t ahc_get_transaction_status(struct scb *);
+static __inline uint32_t ahc_cmd_get_scsi_status(Scsi_Cmnd *cmd);
+static __inline uint32_t ahc_get_scsi_status(struct scb *);
+static __inline void ahc_set_transaction_tag(struct scb *, int, u_int);
+static __inline u_long ahc_get_transfer_length(struct scb *);
+static __inline int ahc_get_transfer_dir(struct scb *);
+static __inline void ahc_set_residual(struct scb *, u_long);
+static __inline void ahc_set_sense_residual(struct scb *scb, u_long resid);
+static __inline u_long ahc_get_residual(struct scb *);
+static __inline u_long ahc_get_sense_residual(struct scb *);
+static __inline int ahc_perform_autosense(struct scb *);
+static __inline uint32_t ahc_get_sense_bufsize(struct ahc_softc *,
+					       struct scb *);
+static __inline void ahc_notify_xfer_settings_change(struct ahc_softc *,
+						     struct ahc_devinfo *);
+static __inline void ahc_platform_scb_free(struct ahc_softc *ahc,
+					   struct scb *scb);
+static __inline void ahc_freeze_scb(struct scb *scb);
+
+static __inline
+void ahc_cmd_set_transaction_status(Scsi_Cmnd *cmd, uint32_t status)
+{
+	cmd->result &= ~(CAM_STATUS_MASK << 16);
+	cmd->result |= status << 16;
+}
+
 static __inline
 void ahc_set_transaction_status(struct scb *scb, uint32_t status)
 {
-	scb->io_ctx->result &= ~(CAM_STATUS_MASK << 16);
-	scb->io_ctx->result |= status << 16;
+	ahc_cmd_set_transaction_status(scb->io_ctx,status);
+}
+
+static __inline
+void ahc_cmd_set_scsi_status(Scsi_Cmnd *cmd, uint32_t status)
+{
+	cmd->result &= ~0xFFFF;
+	cmd->result |= status;
 }
 
-static __inline void ahc_set_scsi_status(struct scb *, uint32_t);
 static __inline
 void ahc_set_scsi_status(struct scb *scb, uint32_t status)
 {
-	scb->io_ctx->result &= ~0xFFFF;
-	scb->io_ctx->result |= status;
+	ahc_cmd_set_scsi_status(scb->io_ctx, status);
+}
+
+static __inline
+uint32_t ahc_cmd_get_transaction_status(Scsi_Cmnd *cmd)
+{
+	return ((cmd->result >> 16) & CAM_STATUS_MASK);
 }
 
-static __inline uint32_t ahc_get_transaction_status(struct scb *);
 static __inline
 uint32_t ahc_get_transaction_status(struct scb *scb)
 {
-	return ((scb->io_ctx->result >> 16) & CAM_STATUS_MASK);
+	return (ahc_cmd_get_transaction_status(scb->io_ctx));
+}
+
+static __inline
+uint32_t ahc_cmd_get_scsi_status(Scsi_Cmnd *cmd)
+{
+	return (cmd->result & 0xFFFF);
 }
 
-static __inline uint32_t ahc_get_scsi_status(struct scb *);
 static __inline
 uint32_t ahc_get_scsi_status(struct scb *scb)
 {
-	return (scb->io_ctx->result & 0xFFFF);
+	return (ahc_cmd_get_scsi_status(scb->io_ctx));
 }
 
-static __inline void ahc_set_transaction_tag(struct scb *, int, u_int);
 static __inline
 void ahc_set_transaction_tag(struct scb *scb, int enabled, u_int type)
 {
@@ -1077,14 +1072,12 @@ void ahc_set_transaction_tag(struct scb 
 	 */
 }
 
-static __inline u_long ahc_get_transfer_length(struct scb *);
 static __inline
 u_long ahc_get_transfer_length(struct scb *scb)
 {
 	return (scb->platform_data->xfer_len);
 }
 
-static __inline int ahc_get_transfer_dir(struct scb *);
 static __inline
 int ahc_get_transfer_dir(struct scb *scb)
 {
@@ -1109,7 +1102,6 @@ int ahc_get_transfer_dir(struct scb *scb
 #endif
 }
 
-static __inline void ahc_set_residual(struct scb *, u_long);
 static __inline
 void ahc_set_residual(struct scb *scb, u_long resid)
 {
@@ -1120,14 +1112,12 @@ void ahc_set_residual(struct scb *scb, u
 #endif
 }
 
-static __inline void ahc_set_sense_residual(struct scb *, u_long);
 static __inline
 void ahc_set_sense_residual(struct scb *scb, u_long resid)
 {
-	/* This can't be reported in Linux */
+	scb->platform_data->sense_resid = resid;
 }
 
-static __inline u_long ahc_get_residual(struct scb *);
 static __inline
 u_long ahc_get_residual(struct scb *scb)
 {
@@ -1138,7 +1128,12 @@ u_long ahc_get_residual(struct scb *scb)
 #endif
 }
 
-static __inline int ahc_perform_autosense(struct scb *);
+static __inline
+u_long ahc_get_sense_residual(struct scb *scb)
+{
+	return (scb->platform_data->sense_resid);
+}
+
 static __inline
 int ahc_perform_autosense(struct scb *scb)
 {
@@ -1156,8 +1151,6 @@ ahc_get_sense_bufsize(struct ahc_softc *
 	return (sizeof(struct scsi_sense_data));
 }
 
-static __inline void ahc_notify_xfer_settings_change(struct ahc_softc *,
-						     struct ahc_devinfo *);
 static __inline void
 ahc_notify_xfer_settings_change(struct ahc_softc *ahc,
 				struct ahc_devinfo *devinfo)
@@ -1165,8 +1158,6 @@ ahc_notify_xfer_settings_change(struct a
 	/* Nothing to do here for linux */
 }
 
-static __inline void ahc_platform_scb_free(struct ahc_softc *ahc,
-					   struct scb *scb);
 static __inline void
 ahc_platform_scb_free(struct ahc_softc *ahc, struct scb *scb)
 {
@@ -1176,11 +1167,14 @@ ahc_platform_scb_free(struct ahc_softc *
 int	ahc_platform_alloc(struct ahc_softc *ahc, void *platform_arg);
 void	ahc_platform_free(struct ahc_softc *ahc);
 void	ahc_platform_freeze_devq(struct ahc_softc *ahc, struct scb *scb);
-static __inline void	ahc_freeze_scb(struct scb *scb);
+
 static __inline void
 ahc_freeze_scb(struct scb *scb)
 {
-	/* Noting to do here for linux */
+	if ((scb->io_ctx->result & (CAM_DEV_QFRZN << 16)) == 0) {
+                scb->io_ctx->result |= CAM_DEV_QFRZN << 16;
+                scb->platform_data->dev->qfrozen++;
+        }
 }
 
 void	ahc_platform_set_tags(struct ahc_softc *ahc,
@@ -1188,7 +1182,8 @@ void	ahc_platform_set_tags(struct ahc_so
 int	ahc_platform_abort_scbs(struct ahc_softc *ahc, int target,
 				char channel, int lun, u_int tag,
 				role_t role, uint32_t status);
-void	ahc_linux_isr(int irq, void *dev_id, struct pt_regs * regs);
+irqreturn_t
+	ahc_linux_isr(int irq, void *dev_id, struct pt_regs * regs);
 void	ahc_platform_flushwork(struct ahc_softc *ahc);
 int	ahc_softc_comp(struct ahc_softc *, struct ahc_softc *);
 void	ahc_done(struct ahc_softc*, struct scb*);
@@ -1203,5 +1198,5 @@ void	ahc_platform_dump_card_state(struct
 #define AHC_PCI_CONFIG 0
 #endif
 #define bootverbose aic7xxx_verbose
-extern int aic7xxx_verbose;
+extern u_int aic7xxx_verbose;
 #endif /* _AIC7XXX_LINUX_H_ */
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c linux-5730/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c
@@ -36,7 +36,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#32 $
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_osm_pci.c#46 $
  */
 
 #include "aic7xxx_osm.h"
@@ -93,7 +93,7 @@ ahc_linux_pci_dev_remove(struct pci_dev 
 	 * list for extra sanity.
 	 */
 	ahc_list_lock(&l);
-	ahc = ahc_find_softc((struct ahc_softc *)pdev->driver_data);
+	ahc = ahc_find_softc((struct ahc_softc *)pci_get_drvdata(pdev));
 	if (ahc != NULL) {
 		u_long s;
 
@@ -110,6 +110,7 @@ static int
 ahc_linux_pci_dev_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	char		 buf[80];
+	bus_addr_t	 mask_39bit;
 	struct		 ahc_softc *ahc;
 	ahc_dev_softc_t	 pci;
 	struct		 ahc_pci_identity *entry;
@@ -160,19 +161,15 @@ ahc_linux_pci_dev_probe(struct pci_dev *
 	}
 	pci_set_master(pdev);
 
+	mask_39bit = (bus_addr_t)0x7FFFFFFFFFULL;
 	if (sizeof(bus_addr_t) > 4
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,3)
 	 && ahc_linux_get_memsize() > 0x80000000
-	 && pci_set_dma_mask(pdev, 0x7FFFFFFFFFULL) == 0) {
-#else
-	 && ahc_linux_get_memsize() > 0x80000000) {
-
-		ahc->dev_softc->dma_mask = 
-		    (bus_addr_t)(0x7FFFFFFFFFULL & (bus_addr_t)~0);
-#endif
+	 && ahc_pci_set_dma_mask(pdev, mask_39bit) == 0) {
 		ahc->flags |= AHC_39BIT_ADDRESSING;
-		ahc->platform_data->hw_dma_mask =
-		    (bus_addr_t)(0x7FFFFFFFFFULL & (bus_addr_t)~0);
+		ahc->platform_data->hw_dma_mask = mask_39bit;
+	} else {
+		ahc_pci_set_dma_mask(pdev, 0xFFFFFFFF);
+		ahc->platform_data->hw_dma_mask = 0xFFFFFFFF;
 	}
 #endif
 	ahc->dev_softc = pci;
@@ -183,14 +180,21 @@ ahc_linux_pci_dev_probe(struct pci_dev *
 	}
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 	pci_set_drvdata(pdev, ahc);
-	if (aic7xxx_detect_complete)
-		ahc_linux_register_host(ahc, aic7xxx_driver_template);
+	if (aic7xxx_detect_complete) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+		ahc_linux_register_host(ahc, &aic7xxx_driver_template);
+#else
+		printf("aic7xxx: ignoring PCI device found after "
+		       "initialization\n");
+		return (-ENODEV);
+#endif
+	}
 #endif
 	return (0);
 }
 
 int
-ahc_linux_pci_probe(Scsi_Host_Template *template)
+ahc_linux_pci_init(void)
 {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
 	return (pci_module_init(&aic7xxx_pci_driver));
@@ -219,9 +223,18 @@ ahc_linux_pci_probe(Scsi_Host_Template *
 #endif
 }
 
+void
+ahc_linux_pci_exit(void)
+{
+	pci_unregister_driver(&aic7xxx_pci_driver);
+}
+
 static int
 ahc_linux_pci_reserve_io_region(struct ahc_softc *ahc, u_long *base)
 {
+	if (aic7xxx_allow_memio == 0)
+		return (ENOMEM);
+
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,3,0)
 	*base = pci_resource_start(ahc->dev_softc, 0);
 #else
@@ -233,8 +246,7 @@ ahc_linux_pci_reserve_io_region(struct a
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
 	if (check_region(*base, 256) != 0)
 		return (ENOMEM);
-	else
-		request_region(*base, 256, "aic7xxx");
+	request_region(*base, 256, "aic7xxx");
 #else
 	if (request_region(*base, 256, "aic7xxx") == 0)
 		return (ENOMEM);
@@ -314,10 +326,10 @@ ahc_pci_map_registers(struct ahc_softc *
 		 * Do a quick test to see if memory mapped
 		 * I/O is functioning correctly.
 		 */
-		if (ahc_inb(ahc, HCNTRL) == 0xFF) {
+		if (ahc_pci_test_register_access(ahc) != 0) {
 
 			printf("aic7xxx: PCI Device %d:%d:%d "
-			       "failed memory mapped test\n",
+			       "failed memory mapped test.  Using PIO.\n",
 			       ahc_get_pci_bus(ahc->dev_softc),
 			       ahc_get_pci_slot(ahc->dev_softc),
 			       ahc_get_pci_function(ahc->dev_softc));
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx_pci.c linux-5730/drivers/scsi/aic7xxx/aic7xxx_pci.c
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx_pci.c
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx_pci.c
@@ -39,9 +39,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#46 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx_pci.c#69 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aic7xxx_pci.c,v 1.2.2.14 2002/04/29 19:36:31 gibbs Exp $
+ * $FreeBSD$
  */
 
 #ifdef __linux__
@@ -76,7 +76,7 @@ ahc_compose_id(u_int device, u_int vendo
 #define ID_9005_SISL_MASK		0x000FFFFF00000000ull
 #define ID_9005_SISL_ID			0x0005900500000000ull
 #define ID_AIC7850			0x5078900400000000ull
-#define ID_AHA_2902_04_10_15_20_30C	0x5078900478509004ull
+#define ID_AHA_2902_04_10_15_20C_30C	0x5078900478509004ull
 #define ID_AIC7855			0x5578900400000000ull
 #define ID_AIC7859			0x3860900400000000ull
 #define ID_AHA_2930CU			0x3860900438699004ull
@@ -245,9 +245,9 @@ struct ahc_pci_identity ahc_pci_ident_ta
 {
 	/* aic7850 based controllers */
 	{
-		ID_AHA_2902_04_10_15_20_30C,
+		ID_AHA_2902_04_10_15_20C_30C,
 		ID_ALL_MASK,
-		"Adaptec 2902/04/10/15/20/30C SCSI adapter",
+		"Adaptec 2902/04/10/15/20C/30C SCSI adapter",
 		ahc_aic785X_setup
 	},
 	/* aic7860 based controllers */
@@ -641,6 +641,7 @@ const u_int ahc_num_pci_devs = NUM_ELEME
 #define AHC_494X_SLOT_CHANNEL_D	7
 
 #define	DEVCONFIG		0x40
+#define		PCIERRGENDIS	0x80000000ul
 #define		SCBSIZE32	0x00010000ul	/* aic789X only */
 #define		REXTVALID	0x00001000ul	/* ultra cards only */
 #define		MPORTMODE	0x00000400ul	/* aic7870+ only */
@@ -660,6 +661,14 @@ const u_int ahc_num_pci_devs = NUM_ELEME
 #define		CACHESIZE	0x0000003ful	/* only 5 bits */
 #define		LATTIME		0x0000ff00ul
 
+/* PCI STATUS definitions */
+#define	DPE	0x80
+#define SSE	0x40
+#define	RMA	0x20
+#define	RTA	0x10
+#define STA	0x08
+#define DPR	0x01
+
 static int ahc_9005_subdevinfo_valid(uint16_t vendor, uint16_t device,
 				     uint16_t subvendor, uint16_t subdevice);
 static int ahc_ext_scbram_present(struct ahc_softc *ahc);
@@ -687,8 +696,12 @@ static void aic787X_cable_detect(struct 
 static void aic785X_cable_detect(struct ahc_softc *ahc, int *internal50_present,
 				 int *externalcable_present,
 				 int *eeprom_present);
-static void write_brdctl(struct ahc_softc *ahc, uint8_t value);
+static void    write_brdctl(struct ahc_softc *ahc, uint8_t value);
 static uint8_t read_brdctl(struct ahc_softc *ahc);
+static void ahc_pci_intr(struct ahc_softc *ahc);
+static int  ahc_pci_chip_init(struct ahc_softc *ahc);
+static int  ahc_pci_suspend(struct ahc_softc *ahc);
+static int  ahc_pci_resume(struct ahc_softc *ahc);
 
 static int
 ahc_9005_subdevinfo_valid(uint16_t device, uint16_t vendor,
@@ -739,10 +752,7 @@ ahc_find_pci_device(ahc_dev_softc_t pci)
 	device = ahc_pci_read_config(pci, PCIR_DEVICE, /*bytes*/2);
 	subvendor = ahc_pci_read_config(pci, PCIR_SUBVEND_0, /*bytes*/2);
 	subdevice = ahc_pci_read_config(pci, PCIR_SUBDEV_0, /*bytes*/2);
-	full_id = ahc_compose_id(device,
-				 vendor,
-				 subdevice,
-				 subvendor);
+	full_id = ahc_compose_id(device, vendor, subdevice, subvendor);
 
 	/*
 	 * If the second function is not hooked up, ignore it.
@@ -771,18 +781,17 @@ ahc_find_pci_device(ahc_dev_softc_t pci)
 int
 ahc_pci_config(struct ahc_softc *ahc, struct ahc_pci_identity *entry)
 {
-	struct scb_data *shared_scb_data;
-	u_long		 l;
-	u_long		 s;
-	u_int		 command;
-	u_int		 our_id = 0;
-	u_int		 sxfrctl1;
-	u_int		 scsiseq;
-	u_int		 dscommand0;
-	int		 error;
-	uint8_t		 sblkctl;
+	u_long	 l;
+	u_int	 command;
+	u_int	 our_id;
+	u_int	 sxfrctl1;
+	u_int	 scsiseq;
+	u_int	 dscommand0;
+	uint32_t devconfig;
+	int	 error;
+	uint8_t	 sblkctl;
 
-	shared_scb_data = NULL;
+	our_id = 0;
 	error = entry->setup(ahc);
 	if (error != 0)
 		return (error);
@@ -803,6 +812,8 @@ ahc_pci_config(struct ahc_softc *ahc, st
 	 */
 	ahc_intr_enable(ahc, FALSE);
 
+	devconfig = ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, /*bytes*/4);
+
 	/*
 	 * If we need to support high memory, enable dual
 	 * address cycles.  This bit must be set to enable
@@ -810,22 +821,23 @@ ahc_pci_config(struct ahc_softc *ahc, st
 	 * 64bit bus (PCI64BIT set in devconfig).
 	 */
 	if ((ahc->flags & AHC_39BIT_ADDRESSING) != 0) {
-		uint32_t devconfig;
 
 		if (bootverbose)
 			printf("%s: Enabling 39Bit Addressing\n",
 			       ahc_name(ahc));
-		devconfig = ahc_pci_read_config(ahc->dev_softc,
-						DEVCONFIG, /*bytes*/4);
 		devconfig |= DACEN;
-		ahc_pci_write_config(ahc->dev_softc, DEVCONFIG,
-				     devconfig, /*bytes*/4);
 	}
 	
+	/* Ensure that pci error generation, a test feature, is disabled. */
+	devconfig |= PCIERRGENDIS;
+
+	ahc_pci_write_config(ahc->dev_softc, DEVCONFIG, devconfig, /*bytes*/4);
+
 	/* Ensure busmastering is enabled */
-	command = ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND, /*bytes*/1);
+	command = ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND, /*bytes*/2);
 	command |= PCIM_CMD_BUSMASTEREN;
-	ahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, command, /*bytes*/1);
+
+	ahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, command, /*bytes*/2);
 
 	/* On all PCI adapters, we allow SCB paging */
 	ahc->flags |= AHC_PAGESCBS;
@@ -834,7 +846,21 @@ ahc_pci_config(struct ahc_softc *ahc, st
 	if (error != 0)
 		return (error);
 
+	/*
+	 * Disable PCI parity error checking.  Users typically
+	 * do this to work around broken PCI chipsets that get
+	 * the parity timing wrong and thus generate lots of spurious
+	 * errors.  The chip only allows us to disable *all* parity
+	 * error reporting when doing this, so CIO bus, scb ram, and
+	 * scratch ram parity errors will be ignored too.
+	 */
+	if ((ahc->flags & AHC_DISABLE_PCI_PERR) != 0)
+		ahc->seqctl |= FAILDIS;
+
 	ahc->bus_intr = ahc_pci_intr;
+	ahc->bus_chip_init = ahc_pci_chip_init;
+	ahc->bus_suspend = ahc_pci_suspend;
+	ahc->bus_resume = ahc_pci_resume;
 
 	/* Remeber how the card was setup in case there is no SEEPROM */
 	if ((ahc_inb(ahc, HCNTRL) & POWRDN) == 0) {
@@ -851,7 +877,7 @@ ahc_pci_config(struct ahc_softc *ahc, st
 		scsiseq = 0;
 	}
 
-	error = ahc_reset(ahc);
+	error = ahc_reset(ahc, /*reinit*/FALSE);
 	if (error != 0)
 		return (ENXIO);
 
@@ -941,7 +967,8 @@ ahc_pci_config(struct ahc_softc *ahc, st
 		 * a SEEPROM.
 		 */
 		/* See if someone else set us up already */
-		if (scsiseq != 0) {
+		if ((ahc->flags & AHC_NO_BIOS_INIT) == 0
+		 && scsiseq != 0) {
 			printf("%s: Using left over BIOS settings\n",
 				ahc_name(ahc));
 			ahc->flags &= ~AHC_USEDEFAULTS;
@@ -973,6 +1000,35 @@ ahc_pci_config(struct ahc_softc *ahc, st
 	if ((sxfrctl1 & STPWEN) != 0)
 		ahc->flags |= AHC_TERM_ENB_A;
 
+	/*
+	 * Save chip register configuration data for chip resets
+	 * that occur during runtime and resume events.
+	 */
+	ahc->bus_softc.pci_softc.devconfig =
+	    ahc_pci_read_config(ahc->dev_softc, DEVCONFIG, /*bytes*/4);
+	ahc->bus_softc.pci_softc.command =
+	    ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND, /*bytes*/1);
+	ahc->bus_softc.pci_softc.csize_lattime =
+	    ahc_pci_read_config(ahc->dev_softc, CSIZE_LATTIME, /*bytes*/1);
+	ahc->bus_softc.pci_softc.dscommand0 = ahc_inb(ahc, DSCOMMAND0);
+	ahc->bus_softc.pci_softc.dspcistatus = ahc_inb(ahc, DSPCISTATUS);
+	if ((ahc->features & AHC_DT) != 0) {
+		u_int sfunct;
+
+		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
+		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
+		ahc->bus_softc.pci_softc.optionmode = ahc_inb(ahc, OPTIONMODE);
+		ahc->bus_softc.pci_softc.targcrccnt = ahc_inw(ahc, TARGCRCCNT);
+		ahc_outb(ahc, SFUNCT, sfunct);
+		ahc->bus_softc.pci_softc.crccontrol1 =
+		    ahc_inb(ahc, CRCCONTROL1);
+	}
+	if ((ahc->features & AHC_MULTI_FUNC) != 0)
+		ahc->bus_softc.pci_softc.scbbaddr = ahc_inb(ahc, SCBBADDR);
+
+	if ((ahc->features & AHC_ULTRA2) != 0)
+		ahc->bus_softc.pci_softc.dff_thrsh = ahc_inb(ahc, DFF_THRSH);
+
 	/* Core initialization */
 	error = ahc_init(ahc);
 	if (error != 0)
@@ -990,11 +1046,6 @@ ahc_pci_config(struct ahc_softc *ahc, st
 	 * Link this softc in with all other ahc instances.
 	 */
 	ahc_softc_insert(ahc);
-
-	ahc_lock(ahc, &s);
-	ahc_intr_enable(ahc, TRUE);
-	ahc_unlock(ahc, &s);
-
 	ahc_list_unlock(&l);
 	return (0);
 }
@@ -1195,6 +1246,85 @@ done:
 }
 
 /*
+ * Perform some simple tests that should catch situations where
+ * our registers are invalidly mapped.
+ */
+int
+ahc_pci_test_register_access(struct ahc_softc *ahc)
+{
+	int	 error;
+	u_int	 status1;
+	uint32_t cmd;
+	uint8_t	 hcntrl;
+
+	error = EIO;
+
+	/*
+	 * Enable PCI error interrupt status, but suppress NMIs
+	 * generated by SERR raised due to target aborts.
+	 */
+	cmd = ahc_pci_read_config(ahc->dev_softc, PCIR_COMMAND, /*bytes*/2);
+	ahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND,
+			     cmd & ~PCIM_CMD_SERRESPEN, /*bytes*/2);
+
+	/*
+	 * First a simple test to see if any
+	 * registers can be read.  Reading
+	 * HCNTRL has no side effects and has
+	 * at least one bit that is guaranteed to
+	 * be zero so it is a good register to
+	 * use for this test.
+	 */
+	hcntrl = ahc_inb(ahc, HCNTRL);
+	if (hcntrl == 0xFF)
+		goto fail;
+
+	/*
+	 * Next create a situation where write combining
+	 * or read prefetching could be initiated by the
+	 * CPU or host bridge.  Our device does not support
+	 * either, so look for data corruption and/or flagged
+	 * PCI errors.  First pause without causing another
+	 * chip reset.
+	 */
+	hcntrl &= ~CHIPRST;
+	ahc_outb(ahc, HCNTRL, hcntrl|PAUSE);
+	while (ahc_is_paused(ahc) == 0)
+		;
+
+	/* Clear any PCI errors that occurred before our driver attached. */
+	status1 = ahc_pci_read_config(ahc->dev_softc,
+				      PCIR_STATUS + 1, /*bytes*/1);
+	ahc_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,
+			     status1, /*bytes*/1);
+	ahc_outb(ahc, CLRINT, CLRPARERR);
+
+	ahc_outb(ahc, SEQCTL, PERRORDIS);
+	ahc_outb(ahc, SCBPTR, 0);
+	ahc_outl(ahc, SCB_BASE, 0x5aa555aa);
+	if (ahc_inl(ahc, SCB_BASE) != 0x5aa555aa)
+		goto fail;
+
+	status1 = ahc_pci_read_config(ahc->dev_softc,
+				      PCIR_STATUS + 1, /*bytes*/1);
+	if ((status1 & STA) != 0)
+		goto fail;
+
+	error = 0;
+
+fail:
+	/* Silently clear any latched errors. */
+	status1 = ahc_pci_read_config(ahc->dev_softc,
+				      PCIR_STATUS + 1, /*bytes*/1);
+	ahc_pci_write_config(ahc->dev_softc, PCIR_STATUS + 1,
+			     status1, /*bytes*/1);
+	ahc_outb(ahc, CLRINT, CLRPARERR);
+	ahc_outb(ahc, SEQCTL, PERRORDIS|FAILDIS);
+	ahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, cmd, /*bytes*/2);
+	return (error);
+}
+
+/*
  * Check the external port logic for a serial eeprom
  * and termination/cable detection contrls.
  */
@@ -1279,13 +1409,12 @@ check_extport(struct ahc_softc *ahc, u_i
 			int	  i;
 
 			sc_data = (uint16_t *)sc;
-			for (i = 0; i < 32; i++) {
-				uint16_t val;
-				int	 j;
+			for (i = 0; i < 32; i++, sc_data++) {
+				int	j;
 
 				j = i * 2;
-				val = ahc_inb(ahc, SRAM_BASE + j)
-				    | ahc_inb(ahc, SRAM_BASE + j + 1) << 8;
+				*sc_data = ahc_inb(ahc, SRAM_BASE + j)
+					 | ahc_inb(ahc, SRAM_BASE + j + 1) << 8;
 			}
 			have_seeprom = ahc_verify_cksum(sc);
 			if (have_seeprom)
@@ -1329,6 +1458,7 @@ check_extport(struct ahc_softc *ahc, u_i
 	}
 
 	if (have_autoterm) {
+		ahc->flags |= AHC_HAS_TERM_LOGIC;
 		ahc_acquire_seeprom(ahc, &sd);
 		configure_termination(ahc, &sd, sc->adapter_control, sxfrctl1);
 		ahc_release_seeprom(&sd);
@@ -1528,6 +1658,8 @@ configure_termination(struct ahc_softc *
 			aic785X_cable_detect(ahc, &internal50_present,
 					     &externalcable_present,
 					     &eeprom_present);
+			/* Can never support a wide connector. */
+			internal68_present = 0;
 		} else {
 			aic787X_cable_detect(ahc, &internal50_present,
 					     &internal68_present,
@@ -1760,14 +1892,52 @@ aic785X_cable_detect(struct ahc_softc *a
 	spiocap |= EXT_BRDCTL;
 	ahc_outb(ahc, SPIOCAP, spiocap);
 	ahc_outb(ahc, BRDCTL, BRDRW|BRDCS);
+	ahc_flush_device_writes(ahc);
+	ahc_delay(500);
 	ahc_outb(ahc, BRDCTL, 0);
+	ahc_flush_device_writes(ahc);
+	ahc_delay(500);
 	brdctl = ahc_inb(ahc, BRDCTL);
 	*internal50_present = (brdctl & BRDDAT5) ? 0 : 1;
 	*externalcable_present = (brdctl & BRDDAT6) ? 0 : 1;
-
 	*eeprom_present = (ahc_inb(ahc, SPIOCAP) & EEPROM) ? 1 : 0;
 }
 	
+int
+ahc_acquire_seeprom(struct ahc_softc *ahc, struct seeprom_descriptor *sd)
+{
+	int wait;
+
+	if ((ahc->features & AHC_SPIOCAP) != 0
+	 && (ahc_inb(ahc, SPIOCAP) & SEEPROM) == 0)
+		return (0);
+
+	/*
+	 * Request access of the memory port.  When access is
+	 * granted, SEERDY will go high.  We use a 1 second
+	 * timeout which should be near 1 second more than
+	 * is needed.  Reason: after the chip reset, there
+	 * should be no contention.
+	 */
+	SEEPROM_OUTB(sd, sd->sd_MS);
+	wait = 1000;  /* 1 second timeout in msec */
+	while (--wait && ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0)) {
+		ahc_delay(1000);  /* delay 1 msec */
+	}
+	if ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0) {
+		SEEPROM_OUTB(sd, 0); 
+		return (0);
+	}
+	return(1);
+}
+
+void
+ahc_release_seeprom(struct seeprom_descriptor *sd)
+{
+	/* Release access to the memory port and the serial EEPROM. */
+	SEEPROM_OUTB(sd, 0);
+}
+
 static void
 write_brdctl(struct ahc_softc *ahc, uint8_t value)
 {
@@ -1801,8 +1971,7 @@ write_brdctl(struct ahc_softc *ahc, uint
 }
 
 static uint8_t
-read_brdctl(ahc)
-	struct 	ahc_softc *ahc;
+read_brdctl(struct ahc_softc *ahc)
 {
 	uint8_t brdctl;
 	uint8_t value;
@@ -1823,14 +1992,7 @@ read_brdctl(ahc)
 	return (value);
 }
 
-#define	DPE	0x80
-#define SSE	0x40
-#define	RMA	0x20
-#define	RTA	0x10
-#define STA	0x08
-#define DPR	0x01
-
-void
+static void
 ahc_pci_intr(struct ahc_softc *ahc)
 {
 	u_int error;
@@ -1848,6 +2010,7 @@ ahc_pci_intr(struct ahc_softc *ahc)
 	      ahc_inb(ahc, SEQADDR0) | (ahc_inb(ahc, SEQADDR1) << 8));
 
 	if (status1 & DPE) {
+		ahc->pci_target_perr_count++;
 		printf("%s: Data Parity Error Detected during address "
 		       "or write data phase\n", ahc_name(ahc));
 	}
@@ -1879,10 +2042,90 @@ ahc_pci_intr(struct ahc_softc *ahc)
 		ahc_outb(ahc, CLRINT, CLRPARERR);
 	}
 
+	if (ahc->pci_target_perr_count > AHC_PCI_TARGET_PERR_THRESH) {
+		printf(
+"%s: WARNING WARNING WARNING WARNING\n"
+"%s: Too many PCI parity errors observed as a target.\n"
+"%s: Some device on this bus is generating bad parity.\n"
+"%s: This is an error *observed by*, not *generated by*, this controller.\n"
+"%s: PCI parity error checking has been disabled.\n"
+"%s: WARNING WARNING WARNING WARNING\n",
+		       ahc_name(ahc), ahc_name(ahc), ahc_name(ahc),
+		       ahc_name(ahc), ahc_name(ahc), ahc_name(ahc));
+		ahc->seqctl |= FAILDIS;
+		ahc_outb(ahc, SEQCTL, ahc->seqctl);
+	}
 	ahc_unpause(ahc);
 }
 
 static int
+ahc_pci_chip_init(struct ahc_softc *ahc)
+{
+	ahc_outb(ahc, DSCOMMAND0, ahc->bus_softc.pci_softc.dscommand0);
+	ahc_outb(ahc, DSPCISTATUS, ahc->bus_softc.pci_softc.dspcistatus);
+	if ((ahc->features & AHC_DT) != 0) {
+		u_int sfunct;
+
+		sfunct = ahc_inb(ahc, SFUNCT) & ~ALT_MODE;
+		ahc_outb(ahc, SFUNCT, sfunct | ALT_MODE);
+		ahc_outb(ahc, OPTIONMODE, ahc->bus_softc.pci_softc.optionmode);
+		ahc_outw(ahc, TARGCRCCNT, ahc->bus_softc.pci_softc.targcrccnt);
+		ahc_outb(ahc, SFUNCT, sfunct);
+		ahc_outb(ahc, CRCCONTROL1,
+			 ahc->bus_softc.pci_softc.crccontrol1);
+	}
+	if ((ahc->features & AHC_MULTI_FUNC) != 0)
+		ahc_outb(ahc, SCBBADDR, ahc->bus_softc.pci_softc.scbbaddr);
+
+	if ((ahc->features & AHC_ULTRA2) != 0)
+		ahc_outb(ahc, DFF_THRSH, ahc->bus_softc.pci_softc.dff_thrsh);
+
+	return (ahc_chip_init(ahc));
+}
+
+static int
+ahc_pci_suspend(struct ahc_softc *ahc)
+{
+	return (ahc_suspend(ahc));
+}
+
+static int
+ahc_pci_resume(struct ahc_softc *ahc)
+{
+
+	ahc_power_state_change(ahc, AHC_POWER_STATE_D0);
+
+	/*
+	 * We assume that the OS has restored our register
+	 * mappings, etc.  Just update the config space registers
+	 * that the OS doesn't know about and rely on our chip
+	 * reset handler to handle the rest.
+	 */
+	ahc_pci_write_config(ahc->dev_softc, DEVCONFIG, /*bytes*/4,
+			     ahc->bus_softc.pci_softc.devconfig);
+	ahc_pci_write_config(ahc->dev_softc, PCIR_COMMAND, /*bytes*/1,
+			     ahc->bus_softc.pci_softc.command);
+	ahc_pci_write_config(ahc->dev_softc, CSIZE_LATTIME, /*bytes*/1,
+			     ahc->bus_softc.pci_softc.csize_lattime);
+	if ((ahc->flags & AHC_HAS_TERM_LOGIC) != 0) {
+		struct	seeprom_descriptor sd;
+		u_int	sxfrctl1;
+
+		sd.sd_ahc = ahc;
+		sd.sd_control_offset = SEECTL;		
+		sd.sd_status_offset = SEECTL;		
+		sd.sd_dataout_offset = SEECTL;		
+
+		ahc_acquire_seeprom(ahc, &sd);
+		configure_termination(ahc, &sd,
+				      ahc->seep_config->adapter_control,
+				      &sxfrctl1);
+		ahc_release_seeprom(&sd);
+	}
+	return (ahc_resume(ahc));
+}
+
+static int
 ahc_aic785X_setup(struct ahc_softc *ahc)
 {
 	ahc_dev_softc_t pci;
@@ -1896,6 +2139,7 @@ ahc_aic785X_setup(struct ahc_softc *ahc)
 	rev = ahc_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
 	if (rev >= 1)
 		ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
+	ahc->instruction_ram_size = 512;
 	return (0);
 }
 
@@ -1913,16 +2157,15 @@ ahc_aic7860_setup(struct ahc_softc *ahc)
 	rev = ahc_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
 	if (rev >= 1)
 		ahc->bugs |= AHC_PCI_2_1_RETRY_BUG;
+	ahc->instruction_ram_size = 512;
 	return (0);
 }
 
 static int
 ahc_apa1480_setup(struct ahc_softc *ahc)
 {
-	ahc_dev_softc_t pci;
 	int error;
 
-	pci = ahc->dev_softc;
 	error = ahc_aic7860_setup(ahc);
 	if (error != 0)
 		return (error);
@@ -1933,13 +2176,12 @@ ahc_apa1480_setup(struct ahc_softc *ahc)
 static int
 ahc_aic7870_setup(struct ahc_softc *ahc)
 {
-	ahc_dev_softc_t pci;
 
-	pci = ahc->dev_softc;
 	ahc->channel = 'A';
 	ahc->chip = AHC_AIC7870;
 	ahc->features = AHC_AIC7870_FE;
 	ahc->bugs |= AHC_TMODE_WIDEODD_BUG|AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
+	ahc->instruction_ram_size = 512;
 	return (0);
 }
 
@@ -1993,19 +2235,16 @@ ahc_aic7880_setup(struct ahc_softc *ahc)
 	} else {
 		ahc->bugs |= AHC_CACHETHEN_BUG|AHC_PCI_MWI_BUG;
 	}
+	ahc->instruction_ram_size = 512;
 	return (0);
 }
 
 static int
 ahc_aha2940Pro_setup(struct ahc_softc *ahc)
 {
-	ahc_dev_softc_t pci;
-	int error;
 
-	pci = ahc->dev_softc;
 	ahc->flags |= AHC_INT50_SPEEDFLEX;
-	error = ahc_aic7880_setup(ahc);
-	return (0);
+	return (ahc_aic7880_setup(ahc));
 }
 
 static int
@@ -2044,20 +2283,20 @@ ahc_aic7890_setup(struct ahc_softc *ahc)
 	rev = ahc_pci_read_config(pci, PCIR_REVID, /*bytes*/1);
 	if (rev == 0)
 		ahc->bugs |= AHC_AUTOFLUSH_BUG|AHC_CACHETHEN_BUG;
+	ahc->instruction_ram_size = 768;
 	return (0);
 }
 
 static int
 ahc_aic7892_setup(struct ahc_softc *ahc)
 {
-	ahc_dev_softc_t pci;
 
-	pci = ahc->dev_softc;
 	ahc->channel = 'A';
 	ahc->chip = AHC_AIC7892;
 	ahc->features = AHC_AIC7892_FE;
 	ahc->flags |= AHC_NEWEEPROM_FMT;
 	ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
+	ahc->instruction_ram_size = 1024;
 	return (0);
 }
 
@@ -2113,6 +2352,7 @@ ahc_aic7895_setup(struct ahc_softc *ahc)
 	ahc_pci_write_config(pci, DEVCONFIG, devconfig, /*bytes*/1);
 #endif
 	ahc->flags |= AHC_NEWEEPROM_FMT;
+	ahc->instruction_ram_size = 512;
 	return (0);
 }
 
@@ -2127,6 +2367,7 @@ ahc_aic7896_setup(struct ahc_softc *ahc)
 	ahc->features = AHC_AIC7896_FE;
 	ahc->flags |= AHC_NEWEEPROM_FMT;
 	ahc->bugs |= AHC_CACHETHEN_DIS_BUG;
+	ahc->instruction_ram_size = 768;
 	return (0);
 }
 
@@ -2141,6 +2382,7 @@ ahc_aic7899_setup(struct ahc_softc *ahc)
 	ahc->features = AHC_AIC7899_FE;
 	ahc->flags |= AHC_NEWEEPROM_FMT;
 	ahc->bugs |= AHC_SCBCHAN_UPLOAD_BUG;
+	ahc->instruction_ram_size = 1024;
 	return (0);
 }
 
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx_proc.c linux-5730/drivers/scsi/aic7xxx/aic7xxx_proc.c
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx_proc.c
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx_proc.c
@@ -37,7 +37,7 @@
  * String handling code courtesy of Gerard Roudier's <groudier@club-internet.fr>
  * sym driver.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#19 $
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7xxx_proc.c#29 $
  */
 #include "aic7xxx_osm.h"
 #include "aic7xxx_inline.h"
@@ -45,7 +45,6 @@
 
 static void	copy_mem_info(struct info_str *info, char *data, int len);
 static int	copy_info(struct info_str *info, char *fmt, ...);
-static u_int	scsi_calc_syncsrate(u_int period_factor);
 static void	ahc_dump_target_state(struct ahc_softc *ahc,
 				      struct info_str *info,
 				      u_int our_id, char channel,
@@ -54,44 +53,6 @@ static void	ahc_dump_device_state(struct
 				      struct ahc_linux_device *dev);
 static int	ahc_proc_write_seeprom(struct ahc_softc *ahc,
 				       char *buffer, int length);
-				       
-
-int
-ahc_acquire_seeprom(struct ahc_softc *ahc, struct seeprom_descriptor *sd)
-{
-	int wait;
-
-	if ((ahc->features & AHC_SPIOCAP) != 0
-	 && (ahc_inb(ahc, SPIOCAP) & SEEPROM) == 0)
-		return (0);
-
-	/*
-	 * Request access of the memory port.  When access is
-	 * granted, SEERDY will go high.  We use a 1 second
-	 * timeout which should be near 1 second more than
-	 * is needed.  Reason: after the chip reset, there
-	 * should be no contention.
-	 */
-	SEEPROM_OUTB(sd, sd->sd_MS);
-	wait = 1000;  /* 1 second timeout in msec */
-	while (--wait && ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0)) {
-		ahc_delay(1000);  /* delay 1 msec */
-	}
-	if ((SEEPROM_STATUS_INB(sd) & sd->sd_RDY) == 0) {
-		SEEPROM_OUTB(sd, 0); 
-		return (0);
-	}
-	return(1);
-}
-
-
-void
-ahc_release_seeprom(struct seeprom_descriptor *sd)
-{
-	/* Release access to the memory port and the serial EEPROM. */
-	SEEPROM_OUTB(sd, 0);
-}
-
 
 static void
 copy_mem_info(struct info_str *info, char *data, int len)
@@ -135,47 +96,6 @@ copy_info(struct info_str *info, char *f
 	return (len);
 }
 
-/*
- * Table of syncrates that don't follow the "divisible by 4"
- * rule. This table will be expanded in future SCSI specs.
- */
-static struct {
-	u_int period_factor;
-	u_int period;	/* in 10ths of ns */
-} scsi_syncrates[] = {
-	{ 0x09, 125 },	/* FAST-80 */
-	{ 0x0a, 250 },	/* FAST-40 40MHz */
-	{ 0x0b, 303 },	/* FAST-40 33MHz */
-	{ 0x0c, 500 }	/* FAST-20 */
-};
- 
-/*
- * Return the frequency in kHz corresponding to the given
- * sync period factor.
- */
-static u_int
-scsi_calc_syncsrate(u_int period_factor)
-{
-	int i; 
-	int num_syncrates;
- 
-	num_syncrates = sizeof(scsi_syncrates) / sizeof(scsi_syncrates[0]);
-	/* See if the period is in the "exception" table */
-	for (i = 0; i < num_syncrates; i++) {
-
-		if (period_factor == scsi_syncrates[i].period_factor) {
-       			/* Period in kHz */
-			return (10000000 / scsi_syncrates[i].period);
-		}
-	}
-
-	/*
-	 * Wasn't in the table, so use the standard
-	 * 4 times conversion.
-	 */
-	return (10000000 / (period_factor * 4 * 10));
-}
-
 void
 ahc_format_transinfo(struct info_str *info, struct ahc_transinfo *tinfo)
 {
@@ -186,7 +106,7 @@ ahc_format_transinfo(struct info_str *in
         speed = 3300;
         freq = 0;
 	if (tinfo->offset != 0) {
-		freq = scsi_calc_syncsrate(tinfo->period);
+		freq = aic_calc_syncsrate(tinfo->period);
 		speed = freq;
 	}
 	speed *= (0x01 << tinfo->width);
@@ -228,8 +148,9 @@ ahc_dump_target_state(struct ahc_softc *
 
 	tinfo = ahc_fetch_transinfo(ahc, channel, our_id,
 				    target_id, &tstate);
-	copy_info(info, "Channel %c Target %d Negotiation Settings\n",
-		  channel, target_id);
+	if ((ahc->features & AHC_TWIN) != 0)
+		copy_info(info, "Channel %c ", channel);
+	copy_info(info, "Target %d Negotiation Settings\n", target_id);
 	copy_info(info, "\tUser: ");
 	ahc_format_transinfo(info, &tinfo->user);
 	targ = ahc->platform_data->targets[target_offset];
@@ -294,19 +215,8 @@ ahc_proc_write_seeprom(struct ahc_softc 
 	}
 
 	sd.sd_ahc = ahc;
-	if ((ahc->chip & AHC_VL) != 0) {
-		sd.sd_control_offset = SEECTL_2840;
-		sd.sd_status_offset = STATUS_2840;
-		sd.sd_dataout_offset = STATUS_2840;		
-		sd.sd_chip = C46;
-		sd.sd_MS = 0;
-		sd.sd_RDY = EEPROM_TF;
-		sd.sd_CS = CS_2840;
-		sd.sd_CK = CK_2840;
-		sd.sd_DO = DO_2840;
-		sd.sd_DI = DI_2840;
-		have_seeprom = TRUE;
-	} else {
+#if AHC_PCI_CONFIG > 0
+	if ((ahc->chip & AHC_PCI) != 0) {
 		sd.sd_control_offset = SEECTL;
 		sd.sd_status_offset = SEECTL;
 		sd.sd_dataout_offset = SEECTL;
@@ -321,6 +231,23 @@ ahc_proc_write_seeprom(struct ahc_softc 
 		sd.sd_DO = SEEDO;
 		sd.sd_DI = SEEDI;
 		have_seeprom = ahc_acquire_seeprom(ahc, &sd);
+	} else
+#endif
+	if ((ahc->chip & AHC_VL) != 0) {
+		sd.sd_control_offset = SEECTL_2840;
+		sd.sd_status_offset = STATUS_2840;
+		sd.sd_dataout_offset = STATUS_2840;		
+		sd.sd_chip = C46;
+		sd.sd_MS = 0;
+		sd.sd_RDY = EEPROM_TF;
+		sd.sd_CS = CS_2840;
+		sd.sd_CK = CK_2840;
+		sd.sd_DO = DO_2840;
+		sd.sd_DI = DI_2840;
+		have_seeprom = TRUE;
+	} else {
+		printf("ahc_proc_write_seeprom: unsupported adapter type\n");
+		goto done;
 	}
 
 	if (!have_seeprom) {
@@ -344,8 +271,10 @@ ahc_proc_write_seeprom(struct ahc_softc 
 				  sizeof(struct seeprom_config)/2);
 		ahc_read_seeprom(&sd, (uint16_t *)ahc->seep_config,
 				 start_addr, sizeof(struct seeprom_config)/2);
+#if AHC_PCI_CONFIG > 0
 		if ((ahc->chip & AHC_VL) == 0)
 			ahc_release_seeprom(&sd);
+#endif
 		written = length;
 	}
 
@@ -360,8 +289,13 @@ done:
  * Return information to handle /proc support for the driver.
  */
 int
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 ahc_linux_proc_info(char *buffer, char **start, off_t offset,
-		  int length, int hostno, int inout)
+		    int length, int hostno, int inout)
+#else
+ahc_linux_proc_info(struct Scsi_Host *shost, char *buffer, char **start,
+		    off_t offset, int length, int inout)
+#endif
 {
 	struct	ahc_softc *ahc;
 	struct	info_str info;
@@ -373,10 +307,14 @@ ahc_linux_proc_info(char *buffer, char *
 
 	retval = -EINVAL;
 	ahc_list_lock(&s);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
 	TAILQ_FOREACH(ahc, &ahc_tailq, links) {
 		if (ahc->platform_data->host->host_no == hostno)
 			break;
 	}
+#else
+	ahc = ahc_find_softc(*(struct ahc_softc **)shost->hostdata);
+#endif
 
 	if (ahc == NULL)
 		goto done;
@@ -397,8 +335,12 @@ ahc_linux_proc_info(char *buffer, char *
 
 	copy_info(&info, "Adaptec AIC7xxx driver version: %s\n",
 		  AIC7XXX_DRIVER_VERSION);
+	copy_info(&info, "%s\n", ahc->description);
 	ahc_controller_info(ahc, ahc_info);
-	copy_info(&info, "%s\n\n", ahc_info);
+	copy_info(&info, "%s\n", ahc_info);
+	copy_info(&info, "Allocated SCBs: %d, SG List Length: %d\n\n",
+		  ahc->scb_data->numscbs, AHC_NSEG);
+
 
 	if (ahc->seep_config == NULL)
 		copy_info(&info, "No Serial EEPROM\n");
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx_reg.h linux-5730/drivers/scsi/aic7xxx/aic7xxx_reg.h
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx_reg.h
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx_reg.h
@@ -2,9 +2,1066 @@
  * DO NOT EDIT - This file is automatically generated
  *		 from the following source files:
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#43 $
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#30 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#56 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#39 $
  */
+typedef int (ahc_reg_print_t)(u_int, u_int *, u_int);
+typedef struct ahc_reg_parse_entry {
+	char	*name;
+	uint8_t	 value;
+	uint8_t	 mask;
+} ahc_reg_parse_entry_t;
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scsiseq_print;
+#else
+#define ahc_scsiseq_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCSISEQ", 0x00, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_sxfrctl0_print;
+#else
+#define ahc_sxfrctl0_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SXFRCTL0", 0x01, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_sxfrctl1_print;
+#else
+#define ahc_sxfrctl1_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SXFRCTL1", 0x02, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scsisigo_print;
+#else
+#define ahc_scsisigo_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCSISIGO", 0x03, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scsisigi_print;
+#else
+#define ahc_scsisigi_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCSISIGI", 0x03, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scsirate_print;
+#else
+#define ahc_scsirate_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCSIRATE", 0x04, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scsiid_print;
+#else
+#define ahc_scsiid_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCSIID", 0x05, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scsidatl_print;
+#else
+#define ahc_scsidatl_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCSIDATL", 0x06, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scsidath_print;
+#else
+#define ahc_scsidath_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCSIDATH", 0x07, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_stcnt_print;
+#else
+#define ahc_stcnt_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "STCNT", 0x08, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_optionmode_print;
+#else
+#define ahc_optionmode_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "OPTIONMODE", 0x08, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_targcrccnt_print;
+#else
+#define ahc_targcrccnt_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "TARGCRCCNT", 0x0a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_clrsint0_print;
+#else
+#define ahc_clrsint0_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "CLRSINT0", 0x0b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_sstat0_print;
+#else
+#define ahc_sstat0_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SSTAT0", 0x0b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_clrsint1_print;
+#else
+#define ahc_clrsint1_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "CLRSINT1", 0x0c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_sstat1_print;
+#else
+#define ahc_sstat1_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SSTAT1", 0x0c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_sstat2_print;
+#else
+#define ahc_sstat2_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SSTAT2", 0x0d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_sstat3_print;
+#else
+#define ahc_sstat3_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SSTAT3", 0x0e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scsiid_ultra2_print;
+#else
+#define ahc_scsiid_ultra2_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCSIID_ULTRA2", 0x0f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_simode0_print;
+#else
+#define ahc_simode0_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SIMODE0", 0x10, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_simode1_print;
+#else
+#define ahc_simode1_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SIMODE1", 0x11, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scsibusl_print;
+#else
+#define ahc_scsibusl_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCSIBUSL", 0x12, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scsibush_print;
+#else
+#define ahc_scsibush_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCSIBUSH", 0x13, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_sxfrctl2_print;
+#else
+#define ahc_sxfrctl2_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SXFRCTL2", 0x13, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_shaddr_print;
+#else
+#define ahc_shaddr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SHADDR", 0x14, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_seltimer_print;
+#else
+#define ahc_seltimer_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SELTIMER", 0x18, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_selid_print;
+#else
+#define ahc_selid_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SELID", 0x19, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scamctl_print;
+#else
+#define ahc_scamctl_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCAMCTL", 0x1a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_targid_print;
+#else
+#define ahc_targid_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "TARGID", 0x1b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_spiocap_print;
+#else
+#define ahc_spiocap_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SPIOCAP", 0x1b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_brdctl_print;
+#else
+#define ahc_brdctl_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "BRDCTL", 0x1d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_seectl_print;
+#else
+#define ahc_seectl_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SEECTL", 0x1e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_sblkctl_print;
+#else
+#define ahc_sblkctl_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SBLKCTL", 0x1f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_busy_targets_print;
+#else
+#define ahc_busy_targets_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "BUSY_TARGETS", 0x20, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_ultra_enb_print;
+#else
+#define ahc_ultra_enb_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "ULTRA_ENB", 0x30, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_disc_dsb_print;
+#else
+#define ahc_disc_dsb_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "DISC_DSB", 0x32, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_cmdsize_table_tail_print;
+#else
+#define ahc_cmdsize_table_tail_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "CMDSIZE_TABLE_TAIL", 0x34, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_mwi_residual_print;
+#else
+#define ahc_mwi_residual_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "MWI_RESIDUAL", 0x38, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_next_queued_scb_print;
+#else
+#define ahc_next_queued_scb_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "NEXT_QUEUED_SCB", 0x39, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_msg_out_print;
+#else
+#define ahc_msg_out_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "MSG_OUT", 0x3a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_dmaparams_print;
+#else
+#define ahc_dmaparams_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "DMAPARAMS", 0x3b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_seq_flags_print;
+#else
+#define ahc_seq_flags_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SEQ_FLAGS", 0x3c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_saved_scsiid_print;
+#else
+#define ahc_saved_scsiid_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SAVED_SCSIID", 0x3d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_saved_lun_print;
+#else
+#define ahc_saved_lun_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SAVED_LUN", 0x3e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_lastphase_print;
+#else
+#define ahc_lastphase_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "LASTPHASE", 0x3f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_waiting_scbh_print;
+#else
+#define ahc_waiting_scbh_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "WAITING_SCBH", 0x40, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_disconnected_scbh_print;
+#else
+#define ahc_disconnected_scbh_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "DISCONNECTED_SCBH", 0x41, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_free_scbh_print;
+#else
+#define ahc_free_scbh_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "FREE_SCBH", 0x42, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_complete_scbh_print;
+#else
+#define ahc_complete_scbh_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "COMPLETE_SCBH", 0x43, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_hscb_addr_print;
+#else
+#define ahc_hscb_addr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "HSCB_ADDR", 0x44, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_shared_data_addr_print;
+#else
+#define ahc_shared_data_addr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SHARED_DATA_ADDR", 0x48, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_kernel_qinpos_print;
+#else
+#define ahc_kernel_qinpos_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "KERNEL_QINPOS", 0x4c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_qinpos_print;
+#else
+#define ahc_qinpos_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "QINPOS", 0x4d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_qoutpos_print;
+#else
+#define ahc_qoutpos_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "QOUTPOS", 0x4e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_kernel_tqinpos_print;
+#else
+#define ahc_kernel_tqinpos_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "KERNEL_TQINPOS", 0x4f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_tqinpos_print;
+#else
+#define ahc_tqinpos_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "TQINPOS", 0x50, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_arg_1_print;
+#else
+#define ahc_arg_1_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "ARG_1", 0x51, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_arg_2_print;
+#else
+#define ahc_arg_2_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "ARG_2", 0x52, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_last_msg_print;
+#else
+#define ahc_last_msg_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "LAST_MSG", 0x53, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scsiseq_template_print;
+#else
+#define ahc_scsiseq_template_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCSISEQ_TEMPLATE", 0x54, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_ha_274_biosglobal_print;
+#else
+#define ahc_ha_274_biosglobal_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "HA_274_BIOSGLOBAL", 0x56, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_seq_flags2_print;
+#else
+#define ahc_seq_flags2_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SEQ_FLAGS2", 0x57, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scsiconf_print;
+#else
+#define ahc_scsiconf_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCSICONF", 0x5a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_intdef_print;
+#else
+#define ahc_intdef_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "INTDEF", 0x5c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_hostconf_print;
+#else
+#define ahc_hostconf_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "HOSTCONF", 0x5d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_ha_274_biosctrl_print;
+#else
+#define ahc_ha_274_biosctrl_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "HA_274_BIOSCTRL", 0x5f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_seqctl_print;
+#else
+#define ahc_seqctl_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SEQCTL", 0x60, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_seqram_print;
+#else
+#define ahc_seqram_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SEQRAM", 0x61, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_seqaddr0_print;
+#else
+#define ahc_seqaddr0_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SEQADDR0", 0x62, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_seqaddr1_print;
+#else
+#define ahc_seqaddr1_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SEQADDR1", 0x63, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_accum_print;
+#else
+#define ahc_accum_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "ACCUM", 0x64, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_sindex_print;
+#else
+#define ahc_sindex_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SINDEX", 0x65, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_dindex_print;
+#else
+#define ahc_dindex_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "DINDEX", 0x66, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_allones_print;
+#else
+#define ahc_allones_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "ALLONES", 0x69, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_allzeros_print;
+#else
+#define ahc_allzeros_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "ALLZEROS", 0x6a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_none_print;
+#else
+#define ahc_none_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "NONE", 0x6a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_flags_print;
+#else
+#define ahc_flags_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "FLAGS", 0x6b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_sindir_print;
+#else
+#define ahc_sindir_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SINDIR", 0x6c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_dindir_print;
+#else
+#define ahc_dindir_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "DINDIR", 0x6d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_function1_print;
+#else
+#define ahc_function1_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "FUNCTION1", 0x6e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_stack_print;
+#else
+#define ahc_stack_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "STACK", 0x6f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_targ_offset_print;
+#else
+#define ahc_targ_offset_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "TARG_OFFSET", 0x70, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_sram_base_print;
+#else
+#define ahc_sram_base_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SRAM_BASE", 0x70, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_bctl_print;
+#else
+#define ahc_bctl_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "BCTL", 0x84, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_dscommand0_print;
+#else
+#define ahc_dscommand0_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "DSCOMMAND0", 0x84, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_bustime_print;
+#else
+#define ahc_bustime_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "BUSTIME", 0x85, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_dscommand1_print;
+#else
+#define ahc_dscommand1_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "DSCOMMAND1", 0x85, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_busspd_print;
+#else
+#define ahc_busspd_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "BUSSPD", 0x86, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_hs_mailbox_print;
+#else
+#define ahc_hs_mailbox_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "HS_MAILBOX", 0x86, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_dspcistatus_print;
+#else
+#define ahc_dspcistatus_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "DSPCISTATUS", 0x86, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_hcntrl_print;
+#else
+#define ahc_hcntrl_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "HCNTRL", 0x87, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_haddr_print;
+#else
+#define ahc_haddr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "HADDR", 0x88, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_hcnt_print;
+#else
+#define ahc_hcnt_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "HCNT", 0x8c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scbptr_print;
+#else
+#define ahc_scbptr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCBPTR", 0x90, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_intstat_print;
+#else
+#define ahc_intstat_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "INTSTAT", 0x91, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_clrint_print;
+#else
+#define ahc_clrint_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "CLRINT", 0x92, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_error_print;
+#else
+#define ahc_error_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "ERROR", 0x92, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_dfcntrl_print;
+#else
+#define ahc_dfcntrl_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "DFCNTRL", 0x93, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_dfstatus_print;
+#else
+#define ahc_dfstatus_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "DFSTATUS", 0x94, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_dfwaddr_print;
+#else
+#define ahc_dfwaddr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "DFWADDR", 0x95, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_dfraddr_print;
+#else
+#define ahc_dfraddr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "DFRADDR", 0x97, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_dfdat_print;
+#else
+#define ahc_dfdat_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "DFDAT", 0x99, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scbcnt_print;
+#else
+#define ahc_scbcnt_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCBCNT", 0x9a, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_qinfifo_print;
+#else
+#define ahc_qinfifo_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "QINFIFO", 0x9b, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_qincnt_print;
+#else
+#define ahc_qincnt_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "QINCNT", 0x9c, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_qoutfifo_print;
+#else
+#define ahc_qoutfifo_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "QOUTFIFO", 0x9d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_crccontrol1_print;
+#else
+#define ahc_crccontrol1_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "CRCCONTROL1", 0x9d, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_qoutcnt_print;
+#else
+#define ahc_qoutcnt_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "QOUTCNT", 0x9e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scsiphase_print;
+#else
+#define ahc_scsiphase_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCSIPHASE", 0x9e, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_sfunct_print;
+#else
+#define ahc_sfunct_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SFUNCT", 0x9f, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_base_print;
+#else
+#define ahc_scb_base_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_BASE", 0xa0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_cdb_ptr_print;
+#else
+#define ahc_scb_cdb_ptr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_CDB_PTR", 0xa0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_residual_sgptr_print;
+#else
+#define ahc_scb_residual_sgptr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_RESIDUAL_SGPTR", 0xa4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_scsi_status_print;
+#else
+#define ahc_scb_scsi_status_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_SCSI_STATUS", 0xa8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_target_phases_print;
+#else
+#define ahc_scb_target_phases_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_TARGET_PHASES", 0xa9, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_target_data_dir_print;
+#else
+#define ahc_scb_target_data_dir_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_TARGET_DATA_DIR", 0xaa, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_target_itag_print;
+#else
+#define ahc_scb_target_itag_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_TARGET_ITAG", 0xab, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_dataptr_print;
+#else
+#define ahc_scb_dataptr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_DATAPTR", 0xac, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_datacnt_print;
+#else
+#define ahc_scb_datacnt_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_DATACNT", 0xb0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_sgptr_print;
+#else
+#define ahc_scb_sgptr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_SGPTR", 0xb4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_control_print;
+#else
+#define ahc_scb_control_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_CONTROL", 0xb8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_scsiid_print;
+#else
+#define ahc_scb_scsiid_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_SCSIID", 0xb9, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_lun_print;
+#else
+#define ahc_scb_lun_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_LUN", 0xba, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_tag_print;
+#else
+#define ahc_scb_tag_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_TAG", 0xbb, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_cdb_len_print;
+#else
+#define ahc_scb_cdb_len_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_CDB_LEN", 0xbc, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_scsirate_print;
+#else
+#define ahc_scb_scsirate_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_SCSIRATE", 0xbd, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_scsioffset_print;
+#else
+#define ahc_scb_scsioffset_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_SCSIOFFSET", 0xbe, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_next_print;
+#else
+#define ahc_scb_next_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_NEXT", 0xbf, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_64_spare_print;
+#else
+#define ahc_scb_64_spare_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_64_SPARE", 0xc0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_seectl_2840_print;
+#else
+#define ahc_seectl_2840_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SEECTL_2840", 0xc0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_status_2840_print;
+#else
+#define ahc_status_2840_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "STATUS_2840", 0xc1, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scb_64_btt_print;
+#else
+#define ahc_scb_64_btt_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCB_64_BTT", 0xd0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_cchaddr_print;
+#else
+#define ahc_cchaddr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "CCHADDR", 0xe0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_cchcnt_print;
+#else
+#define ahc_cchcnt_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "CCHCNT", 0xe8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_ccsgram_print;
+#else
+#define ahc_ccsgram_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "CCSGRAM", 0xe9, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_ccsgaddr_print;
+#else
+#define ahc_ccsgaddr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "CCSGADDR", 0xea, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_ccsgctl_print;
+#else
+#define ahc_ccsgctl_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "CCSGCTL", 0xeb, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_ccscbram_print;
+#else
+#define ahc_ccscbram_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "CCSCBRAM", 0xec, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_ccscbaddr_print;
+#else
+#define ahc_ccscbaddr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "CCSCBADDR", 0xed, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_ccscbctl_print;
+#else
+#define ahc_ccscbctl_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "CCSCBCTL", 0xee, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_ccscbcnt_print;
+#else
+#define ahc_ccscbcnt_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "CCSCBCNT", 0xef, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_scbbaddr_print;
+#else
+#define ahc_scbbaddr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SCBBADDR", 0xf0, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_ccscbptr_print;
+#else
+#define ahc_ccscbptr_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "CCSCBPTR", 0xf1, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_hnscb_qoff_print;
+#else
+#define ahc_hnscb_qoff_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "HNSCB_QOFF", 0xf4, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_snscb_qoff_print;
+#else
+#define ahc_snscb_qoff_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SNSCB_QOFF", 0xf6, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_sdscb_qoff_print;
+#else
+#define ahc_sdscb_qoff_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SDSCB_QOFF", 0xf8, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_qoff_ctlsta_print;
+#else
+#define ahc_qoff_ctlsta_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "QOFF_CTLSTA", 0xfa, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_dff_thrsh_print;
+#else
+#define ahc_dff_thrsh_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "DFF_THRSH", 0xfb, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_sg_cache_shadow_print;
+#else
+#define ahc_sg_cache_shadow_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SG_CACHE_SHADOW", 0xfc, regvalue, cur_col, wrap)
+#endif
+
+#if AIC_DEBUG_REGISTERS
+ahc_reg_print_t ahc_sg_cache_pre_print;
+#else
+#define ahc_sg_cache_pre_print(regvalue, cur_col, wrap) \
+    ahc_print_register(NULL, 0, "SG_CACHE_PRE", 0xfc, regvalue, cur_col, wrap)
+#endif
+
 
 #define	SCSISEQ         		0x00
 #define		TEMODE          	0x80
@@ -20,9 +1077,9 @@
 #define		CLRCHN          	0x02
 
 #define	SXFRCTL1        		0x02
+#define		STIMESEL        	0x18
 #define		BITBUCKET       	0x80
 #define		SWRAPEN         	0x40
-#define		STIMESEL        	0x18
 #define		ENSTIMER        	0x04
 #define		ACTNEGEN        	0x02
 #define		STPWEN          	0x01
@@ -47,12 +1104,12 @@
 #define		ACKI            	0x01
 
 #define	SCSIRATE        		0x04
-#define		WIDEXFER        	0x80
 #define		SXFR            	0x70
-#define		ENABLE_CRC      	0x40
-#define		SINGLE_EDGE     	0x10
 #define		SOFS            	0x0f
 #define		SXFR_ULTRA2     	0x0f
+#define		WIDEXFER        	0x80
+#define		ENABLE_CRC      	0x40
+#define		SINGLE_EDGE     	0x10
 
 #define	SCSIID          		0x05
 #define	SCSIOFFSET      		0x05
@@ -65,13 +1122,13 @@
 #define	STCNT           		0x08
 
 #define	OPTIONMODE      		0x08
+#define		OPTIONMODE_DEFAULTS	0x03
 #define		AUTORATEEN      	0x80
 #define		AUTOACKEN       	0x40
 #define		ATNMGMNTEN      	0x20
 #define		BUSFREEREV      	0x10
 #define		EXPPHASEDIS     	0x08
 #define		SCSIDATL_IMGEN  	0x04
-#define		OPTIONMODE_DEFAULTS	0x03
 #define		AUTO_MSGOUT_DE  	0x02
 #define		DIS_MSGIN_DUALEDGE	0x01
 
@@ -116,9 +1173,9 @@
 #define		REQINIT         	0x01
 
 #define	SSTAT2          		0x0d
+#define		SFCNT           	0x1f
 #define		OVERRUN         	0x80
 #define		SHVALID         	0x40
-#define		SFCNT           	0x1f
 #define		EXP_ACTIVE      	0x10
 #define		CRCVALERR       	0x08
 #define		CRCENDERR       	0x04
@@ -156,6 +1213,11 @@
 
 #define	SCSIBUSH        		0x13
 
+#define	SXFRCTL2        		0x13
+#define		ASYNC_SETUP     	0x07
+#define		AUTORSTDIS      	0x10
+#define		CMDDMAEN        	0x08
+
 #define	SHADDR          		0x14
 
 #define	SELTIMER        		0x18
@@ -172,11 +1234,11 @@
 #define		ONEBIT          	0x08
 
 #define	SCAMCTL         		0x1a
+#define		SCAMLVL         	0x03
 #define		ENSCAMSELO      	0x80
 #define		CLRSCAMSELID    	0x40
 #define		ALTSTIM         	0x20
 #define		DFLTTID         	0x10
-#define		SCAMLVL         	0x03
 
 #define	TARGID          		0x1b
 
@@ -236,6 +1298,7 @@
 #define	CMDSIZE_TABLE_TAIL		0x34
 
 #define	MWI_RESIDUAL    		0x38
+#define	TARG_IMMEDIATE_SCB		0x38
 
 #define	NEXT_QUEUED_SCB 		0x39
 
@@ -254,7 +1317,8 @@
 #define		FIFORESET       	0x01
 
 #define	SEQ_FLAGS       		0x3c
-#define		IDENTIFY_SEEN   	0x80
+#define		NOT_IDENTIFIED  	0x80
+#define		NO_CDB_SENT     	0x40
 #define		TARGET_CMD_IS_TAGGED	0x40
 #define		DPHASE          	0x20
 #define		TARG_CMD_PENDING	0x10
@@ -273,12 +1337,12 @@
 #define		P_STATUS        	0xc0
 #define		P_MESGOUT       	0xa0
 #define		P_COMMAND       	0x80
-#define		CDI             	0x80
 #define		P_DATAIN        	0x40
-#define		IOI             	0x40
-#define		MSGI            	0x20
 #define		P_BUSFREE       	0x01
 #define		P_DATAOUT       	0x00
+#define		CDI             	0x80
+#define		IOI             	0x40
+#define		MSGI            	0x20
 
 #define	WAITING_SCBH    		0x40
 
@@ -325,8 +1389,6 @@
 #define		ENAUTOATNI      	0x04
 #define		ENAUTOATNP      	0x02
 
-#define	DATA_COUNT_ODD  		0x55
-
 #define	HA_274_BIOSGLOBAL		0x56
 #define	INITIATOR_TAG   		0x56
 #define		HA_274_EXTENDED_TRANS	0x01
@@ -336,15 +1398,15 @@
 #define		SCB_DMA         	0x01
 
 #define	SCSICONF        		0x5a
+#define		HWSCSIID        	0x0f
+#define		HSCSIID         	0x07
 #define		TERM_ENB        	0x80
 #define		RESET_SCSI      	0x40
 #define		ENSPCHK         	0x20
-#define		HWSCSIID        	0x0f
-#define		HSCSIID         	0x07
 
 #define	INTDEF          		0x5c
-#define		EDGE_TRIG       	0x80
 #define		VECTOR          	0x0f
+#define		EDGE_TRIG       	0x80
 
 #define	HOSTCONF        		0x5d
 
@@ -464,13 +1526,13 @@
 #define		PDATA_REINIT    	0x51
 #define		IGN_WIDE_RES    	0x41
 #define		NO_MATCH        	0x31
-#define		NO_IDENT        	0x21
+#define		PROTO_VIOLATION 	0x21
 #define		SEND_REJECT     	0x11
 #define		INT_PEND        	0x0f
+#define		BAD_PHASE       	0x01
 #define		BRKADRINT       	0x08
 #define		SCSIINT         	0x04
 #define		CMDCMPLT        	0x02
-#define		BAD_PHASE       	0x01
 #define		SEQINT          	0x01
 
 #define	CLRINT          		0x92
@@ -509,8 +1571,8 @@
 #define	DFDAT           		0x99
 
 #define	SCBCNT          		0x9a
-#define		SCBAUTO         	0x80
 #define		SCBCNT_MASK     	0x1f
+#define		SCBAUTO         	0x80
 
 #define	QINFIFO         		0x9b
 
@@ -529,11 +1591,11 @@
 #define	QOUTCNT         		0x9e
 
 #define	SCSIPHASE       		0x9e
+#define		DATA_PHASE_MASK 	0x03
 #define		STATUS_PHASE    	0x20
 #define		COMMAND_PHASE   	0x10
 #define		MSG_IN_PHASE    	0x08
 #define		MSG_OUT_PHASE   	0x04
-#define		DATA_PHASE_MASK 	0x03
 #define		DATA_IN_PHASE   	0x02
 #define		DATA_OUT_PHASE  	0x01
 
@@ -559,8 +1621,8 @@
 #define	SCB_DATAPTR     		0xac
 
 #define	SCB_DATACNT     		0xb0
-#define		SG_LAST_SEG     	0x80
 #define		SG_HIGH_ADDR_BITS	0x7f
+#define		SG_LAST_SEG     	0x80
 
 #define	SCB_SGPTR       		0xb4
 #define		SG_RESID_VALID  	0x04
@@ -568,22 +1630,24 @@
 #define		SG_LIST_NULL    	0x01
 
 #define	SCB_CONTROL     		0xb8
+#define		SCB_TAG_TYPE    	0x03
+#define		STATUS_RCVD     	0x80
 #define		TARGET_SCB      	0x80
 #define		DISCENB         	0x40
 #define		TAG_ENB         	0x20
 #define		MK_MESSAGE      	0x10
 #define		ULTRAENB        	0x08
 #define		DISCONNECTED    	0x04
-#define		SCB_TAG_TYPE    	0x03
 
 #define	SCB_SCSIID      		0xb9
 #define		TID             	0xf0
-#define		TWIN_CHNLB      	0x80
 #define		TWIN_TID        	0x70
 #define		OID             	0x0f
+#define		TWIN_CHNLB      	0x80
 
 #define	SCB_LUN         		0xba
-#define		LID             	0xff
+#define		LID             	0x3f
+#define		SCB_XFERLEN_ODD 	0x80
 
 #define	SCB_TAG         		0xbb
 
@@ -603,9 +1667,9 @@
 #define		DO_2840         	0x01
 
 #define	STATUS_2840     		0xc1
-#define		EEPROM_TF       	0x80
 #define		BIOS_SEL        	0x60
 #define		ADSEL           	0x1e
+#define		EEPROM_TF       	0x80
 #define		DI_2840         	0x01
 
 #define	SCB_64_BTT      		0xd0
@@ -649,11 +1713,11 @@
 #define	SDSCB_QOFF      		0xf8
 
 #define	QOFF_CTLSTA     		0xfa
+#define		SCB_QSIZE       	0x07
+#define		SCB_QSIZE_256   	0x06
 #define		SCB_AVAIL       	0x40
 #define		SNSCB_ROLLOVER  	0x20
 #define		SDSCB_ROLLOVER  	0x10
-#define		SCB_QSIZE       	0x07
-#define		SCB_QSIZE_256   	0x06
 
 #define	DFF_THRSH       		0xfb
 #define		WR_DFTHRSH      	0x70
@@ -677,7 +1741,6 @@
 
 #define	SG_CACHE_SHADOW 		0xfc
 #define		SG_ADDR_MASK    	0xf8
-#define		ODD_SEG         	0x04
 #define		LAST_SEG        	0x02
 #define		LAST_SEG_DONE   	0x01
 
@@ -704,8 +1767,10 @@
 #define	SEQ_MAILBOX_SHIFT	0x00
 #define	TARGET_DATA_IN	0x01
 #define	HOST_MSG	0xff
+#define	MAX_OFFSET	0x7f
 #define	BUS_16_BIT	0x01
 #define	SCB_UPLOAD_SIZE	0x20
+#define	STACK_SIZE	0x04
 
 
 /* Downloaded Constant Definitions */
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx_reg_print.c linux-5730/drivers/scsi/aic7xxx/aic7xxx_reg_print.c
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx_reg_print.c
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx_reg_print.c
@@ -0,0 +1,1681 @@
+/*
+ * DO NOT EDIT - This file is automatically generated
+ *		 from the following source files:
+ *
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#56 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#39 $
+ */
+
+#include "aic7xxx_osm.h"
+
+static ahc_reg_parse_entry_t SCSISEQ_parse_table[] = {
+	{ "SCSIRSTO",		0x01, 0x01 },
+	{ "ENAUTOATNP",		0x02, 0x02 },
+	{ "ENAUTOATNI",		0x04, 0x04 },
+	{ "ENAUTOATNO",		0x08, 0x08 },
+	{ "ENRSELI",		0x10, 0x10 },
+	{ "ENSELI",		0x20, 0x20 },
+	{ "ENSELO",		0x40, 0x40 },
+	{ "TEMODE",		0x80, 0x80 }
+};
+
+int
+ahc_scsiseq_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCSISEQ_parse_table, 8, "SCSISEQ",
+	    0x00, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SXFRCTL0_parse_table[] = {
+	{ "CLRCHN",		0x02, 0x02 },
+	{ "SCAMEN",		0x04, 0x04 },
+	{ "SPIOEN",		0x08, 0x08 },
+	{ "CLRSTCNT",		0x10, 0x10 },
+	{ "FAST20",		0x20, 0x20 },
+	{ "DFPEXP",		0x40, 0x40 },
+	{ "DFON",		0x80, 0x80 }
+};
+
+int
+ahc_sxfrctl0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SXFRCTL0_parse_table, 7, "SXFRCTL0",
+	    0x01, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SXFRCTL1_parse_table[] = {
+	{ "STPWEN",		0x01, 0x01 },
+	{ "ACTNEGEN",		0x02, 0x02 },
+	{ "ENSTIMER",		0x04, 0x04 },
+	{ "ENSPCHK",		0x20, 0x20 },
+	{ "SWRAPEN",		0x40, 0x40 },
+	{ "BITBUCKET",		0x80, 0x80 },
+	{ "STIMESEL",		0x18, 0x18 }
+};
+
+int
+ahc_sxfrctl1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SXFRCTL1_parse_table, 7, "SXFRCTL1",
+	    0x02, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SCSISIGO_parse_table[] = {
+	{ "ACKO",		0x01, 0x01 },
+	{ "REQO",		0x02, 0x02 },
+	{ "BSYO",		0x04, 0x04 },
+	{ "SELO",		0x08, 0x08 },
+	{ "ATNO",		0x10, 0x10 },
+	{ "MSGO",		0x20, 0x20 },
+	{ "IOO",		0x40, 0x40 },
+	{ "CDO",		0x80, 0x80 },
+	{ "P_DATAOUT",		0x00, 0x00 },
+	{ "P_DATAIN",		0x40, 0x40 },
+	{ "P_COMMAND",		0x80, 0x80 },
+	{ "P_MESGOUT",		0xa0, 0xa0 },
+	{ "P_STATUS",		0xc0, 0xc0 },
+	{ "PHASE_MASK",		0xe0, 0xe0 },
+	{ "P_MESGIN",		0xe0, 0xe0 }
+};
+
+int
+ahc_scsisigo_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCSISIGO_parse_table, 15, "SCSISIGO",
+	    0x03, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SCSISIGI_parse_table[] = {
+	{ "ACKI",		0x01, 0x01 },
+	{ "REQI",		0x02, 0x02 },
+	{ "BSYI",		0x04, 0x04 },
+	{ "SELI",		0x08, 0x08 },
+	{ "ATNI",		0x10, 0x10 },
+	{ "MSGI",		0x20, 0x20 },
+	{ "IOI",		0x40, 0x40 },
+	{ "CDI",		0x80, 0x80 },
+	{ "P_DATAOUT",		0x00, 0x00 },
+	{ "P_DATAOUT_DT",	0x20, 0x20 },
+	{ "P_DATAIN",		0x40, 0x40 },
+	{ "P_DATAIN_DT",	0x60, 0x60 },
+	{ "P_COMMAND",		0x80, 0x80 },
+	{ "P_MESGOUT",		0xa0, 0xa0 },
+	{ "P_STATUS",		0xc0, 0xc0 },
+	{ "PHASE_MASK",		0xe0, 0xe0 },
+	{ "P_MESGIN",		0xe0, 0xe0 }
+};
+
+int
+ahc_scsisigi_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCSISIGI_parse_table, 17, "SCSISIGI",
+	    0x03, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SCSIRATE_parse_table[] = {
+	{ "SINGLE_EDGE",	0x10, 0x10 },
+	{ "ENABLE_CRC",		0x40, 0x40 },
+	{ "WIDEXFER",		0x80, 0x80 },
+	{ "SXFR_ULTRA2",	0x0f, 0x0f },
+	{ "SOFS",		0x0f, 0x0f },
+	{ "SXFR",		0x70, 0x70 }
+};
+
+int
+ahc_scsirate_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCSIRATE_parse_table, 6, "SCSIRATE",
+	    0x04, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SCSIID_parse_table[] = {
+	{ "TWIN_CHNLB",		0x80, 0x80 },
+	{ "OID",		0x0f, 0x0f },
+	{ "TWIN_TID",		0x70, 0x70 },
+	{ "SOFS_ULTRA2",	0x7f, 0x7f },
+	{ "TID",		0xf0, 0xf0 }
+};
+
+int
+ahc_scsiid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCSIID_parse_table, 5, "SCSIID",
+	    0x05, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scsidatl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCSIDATL",
+	    0x06, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scsidath_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCSIDATH",
+	    0x07, regvalue, cur_col, wrap));
+}
+
+int
+ahc_stcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "STCNT",
+	    0x08, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t OPTIONMODE_parse_table[] = {
+	{ "DIS_MSGIN_DUALEDGE",	0x01, 0x01 },
+	{ "AUTO_MSGOUT_DE",	0x02, 0x02 },
+	{ "SCSIDATL_IMGEN",	0x04, 0x04 },
+	{ "EXPPHASEDIS",	0x08, 0x08 },
+	{ "BUSFREEREV",		0x10, 0x10 },
+	{ "ATNMGMNTEN",		0x20, 0x20 },
+	{ "AUTOACKEN",		0x40, 0x40 },
+	{ "AUTORATEEN",		0x80, 0x80 },
+	{ "OPTIONMODE_DEFAULTS",0x03, 0x03 }
+};
+
+int
+ahc_optionmode_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(OPTIONMODE_parse_table, 9, "OPTIONMODE",
+	    0x08, regvalue, cur_col, wrap));
+}
+
+int
+ahc_targcrccnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "TARGCRCCNT",
+	    0x0a, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t CLRSINT0_parse_table[] = {
+	{ "CLRSPIORDY",		0x02, 0x02 },
+	{ "CLRSWRAP",		0x08, 0x08 },
+	{ "CLRIOERR",		0x08, 0x08 },
+	{ "CLRSELINGO",		0x10, 0x10 },
+	{ "CLRSELDI",		0x20, 0x20 },
+	{ "CLRSELDO",		0x40, 0x40 }
+};
+
+int
+ahc_clrsint0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(CLRSINT0_parse_table, 6, "CLRSINT0",
+	    0x0b, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SSTAT0_parse_table[] = {
+	{ "DMADONE",		0x01, 0x01 },
+	{ "SPIORDY",		0x02, 0x02 },
+	{ "SDONE",		0x04, 0x04 },
+	{ "SWRAP",		0x08, 0x08 },
+	{ "IOERR",		0x08, 0x08 },
+	{ "SELINGO",		0x10, 0x10 },
+	{ "SELDI",		0x20, 0x20 },
+	{ "SELDO",		0x40, 0x40 },
+	{ "TARGET",		0x80, 0x80 }
+};
+
+int
+ahc_sstat0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SSTAT0_parse_table, 9, "SSTAT0",
+	    0x0b, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t CLRSINT1_parse_table[] = {
+	{ "CLRREQINIT",		0x01, 0x01 },
+	{ "CLRPHASECHG",	0x02, 0x02 },
+	{ "CLRSCSIPERR",	0x04, 0x04 },
+	{ "CLRBUSFREE",		0x08, 0x08 },
+	{ "CLRSCSIRSTI",	0x20, 0x20 },
+	{ "CLRATNO",		0x40, 0x40 },
+	{ "CLRSELTIMEO",	0x80, 0x80 }
+};
+
+int
+ahc_clrsint1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(CLRSINT1_parse_table, 7, "CLRSINT1",
+	    0x0c, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SSTAT1_parse_table[] = {
+	{ "REQINIT",		0x01, 0x01 },
+	{ "PHASECHG",		0x02, 0x02 },
+	{ "SCSIPERR",		0x04, 0x04 },
+	{ "BUSFREE",		0x08, 0x08 },
+	{ "PHASEMIS",		0x10, 0x10 },
+	{ "SCSIRSTI",		0x20, 0x20 },
+	{ "ATNTARG",		0x40, 0x40 },
+	{ "SELTO",		0x80, 0x80 }
+};
+
+int
+ahc_sstat1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SSTAT1_parse_table, 8, "SSTAT1",
+	    0x0c, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SSTAT2_parse_table[] = {
+	{ "DUAL_EDGE_ERR",	0x01, 0x01 },
+	{ "CRCREQERR",		0x02, 0x02 },
+	{ "CRCENDERR",		0x04, 0x04 },
+	{ "CRCVALERR",		0x08, 0x08 },
+	{ "EXP_ACTIVE",		0x10, 0x10 },
+	{ "SHVALID",		0x40, 0x40 },
+	{ "OVERRUN",		0x80, 0x80 },
+	{ "SFCNT",		0x1f, 0x1f }
+};
+
+int
+ahc_sstat2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SSTAT2_parse_table, 8, "SSTAT2",
+	    0x0d, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SSTAT3_parse_table[] = {
+	{ "OFFCNT",		0x0f, 0x0f },
+	{ "U2OFFCNT",		0x7f, 0x7f },
+	{ "SCSICNT",		0xf0, 0xf0 }
+};
+
+int
+ahc_sstat3_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SSTAT3_parse_table, 3, "SSTAT3",
+	    0x0e, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SCSIID_ULTRA2_parse_table[] = {
+	{ "OID",		0x0f, 0x0f },
+	{ "TID",		0xf0, 0xf0 }
+};
+
+int
+ahc_scsiid_ultra2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCSIID_ULTRA2_parse_table, 2, "SCSIID_ULTRA2",
+	    0x0f, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SIMODE0_parse_table[] = {
+	{ "ENDMADONE",		0x01, 0x01 },
+	{ "ENSPIORDY",		0x02, 0x02 },
+	{ "ENSDONE",		0x04, 0x04 },
+	{ "ENSWRAP",		0x08, 0x08 },
+	{ "ENIOERR",		0x08, 0x08 },
+	{ "ENSELINGO",		0x10, 0x10 },
+	{ "ENSELDI",		0x20, 0x20 },
+	{ "ENSELDO",		0x40, 0x40 }
+};
+
+int
+ahc_simode0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SIMODE0_parse_table, 8, "SIMODE0",
+	    0x10, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SIMODE1_parse_table[] = {
+	{ "ENREQINIT",		0x01, 0x01 },
+	{ "ENPHASECHG",		0x02, 0x02 },
+	{ "ENSCSIPERR",		0x04, 0x04 },
+	{ "ENBUSFREE",		0x08, 0x08 },
+	{ "ENPHASEMIS",		0x10, 0x10 },
+	{ "ENSCSIRST",		0x20, 0x20 },
+	{ "ENATNTARG",		0x40, 0x40 },
+	{ "ENSELTIMO",		0x80, 0x80 }
+};
+
+int
+ahc_simode1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SIMODE1_parse_table, 8, "SIMODE1",
+	    0x11, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scsibusl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCSIBUSL",
+	    0x12, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scsibush_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCSIBUSH",
+	    0x13, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SXFRCTL2_parse_table[] = {
+	{ "CMDDMAEN",		0x08, 0x08 },
+	{ "AUTORSTDIS",		0x10, 0x10 },
+	{ "ASYNC_SETUP",	0x07, 0x07 }
+};
+
+int
+ahc_sxfrctl2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SXFRCTL2_parse_table, 3, "SXFRCTL2",
+	    0x13, regvalue, cur_col, wrap));
+}
+
+int
+ahc_shaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SHADDR",
+	    0x14, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SELTIMER_parse_table[] = {
+	{ "STAGE1",		0x01, 0x01 },
+	{ "STAGE2",		0x02, 0x02 },
+	{ "STAGE3",		0x04, 0x04 },
+	{ "STAGE4",		0x08, 0x08 },
+	{ "STAGE5",		0x10, 0x10 },
+	{ "STAGE6",		0x20, 0x20 }
+};
+
+int
+ahc_seltimer_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SELTIMER_parse_table, 6, "SELTIMER",
+	    0x18, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SELID_parse_table[] = {
+	{ "ONEBIT",		0x08, 0x08 },
+	{ "SELID_MASK",		0xf0, 0xf0 }
+};
+
+int
+ahc_selid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SELID_parse_table, 2, "SELID",
+	    0x19, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SCAMCTL_parse_table[] = {
+	{ "DFLTTID",		0x10, 0x10 },
+	{ "ALTSTIM",		0x20, 0x20 },
+	{ "CLRSCAMSELID",	0x40, 0x40 },
+	{ "ENSCAMSELO",		0x80, 0x80 },
+	{ "SCAMLVL",		0x03, 0x03 }
+};
+
+int
+ahc_scamctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCAMCTL_parse_table, 5, "SCAMCTL",
+	    0x1a, regvalue, cur_col, wrap));
+}
+
+int
+ahc_targid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "TARGID",
+	    0x1b, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SPIOCAP_parse_table[] = {
+	{ "SSPIOCPS",		0x01, 0x01 },
+	{ "ROM",		0x02, 0x02 },
+	{ "EEPROM",		0x04, 0x04 },
+	{ "SEEPROM",		0x08, 0x08 },
+	{ "EXT_BRDCTL",		0x10, 0x10 },
+	{ "SOFTCMDEN",		0x20, 0x20 },
+	{ "SOFT0",		0x40, 0x40 },
+	{ "SOFT1",		0x80, 0x80 }
+};
+
+int
+ahc_spiocap_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SPIOCAP_parse_table, 8, "SPIOCAP",
+	    0x1b, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t BRDCTL_parse_table[] = {
+	{ "BRDCTL0",		0x01, 0x01 },
+	{ "BRDSTB_ULTRA2",	0x01, 0x01 },
+	{ "BRDCTL1",		0x02, 0x02 },
+	{ "BRDRW_ULTRA2",	0x02, 0x02 },
+	{ "BRDRW",		0x04, 0x04 },
+	{ "BRDDAT2",		0x04, 0x04 },
+	{ "BRDCS",		0x08, 0x08 },
+	{ "BRDDAT3",		0x08, 0x08 },
+	{ "BRDSTB",		0x10, 0x10 },
+	{ "BRDDAT4",		0x10, 0x10 },
+	{ "BRDDAT5",		0x20, 0x20 },
+	{ "BRDDAT6",		0x40, 0x40 },
+	{ "BRDDAT7",		0x80, 0x80 }
+};
+
+int
+ahc_brdctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(BRDCTL_parse_table, 13, "BRDCTL",
+	    0x1d, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SEECTL_parse_table[] = {
+	{ "SEEDI",		0x01, 0x01 },
+	{ "SEEDO",		0x02, 0x02 },
+	{ "SEECK",		0x04, 0x04 },
+	{ "SEECS",		0x08, 0x08 },
+	{ "SEERDY",		0x10, 0x10 },
+	{ "SEEMS",		0x20, 0x20 },
+	{ "EXTARBREQ",		0x40, 0x40 },
+	{ "EXTARBACK",		0x80, 0x80 }
+};
+
+int
+ahc_seectl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SEECTL_parse_table, 8, "SEECTL",
+	    0x1e, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SBLKCTL_parse_table[] = {
+	{ "XCVR",		0x01, 0x01 },
+	{ "SELWIDE",		0x02, 0x02 },
+	{ "ENAB20",		0x04, 0x04 },
+	{ "SELBUSB",		0x08, 0x08 },
+	{ "ENAB40",		0x08, 0x08 },
+	{ "AUTOFLUSHDIS",	0x20, 0x20 },
+	{ "DIAGLEDON",		0x40, 0x40 },
+	{ "DIAGLEDEN",		0x80, 0x80 }
+};
+
+int
+ahc_sblkctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SBLKCTL_parse_table, 8, "SBLKCTL",
+	    0x1f, regvalue, cur_col, wrap));
+}
+
+int
+ahc_busy_targets_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "BUSY_TARGETS",
+	    0x20, regvalue, cur_col, wrap));
+}
+
+int
+ahc_ultra_enb_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "ULTRA_ENB",
+	    0x30, regvalue, cur_col, wrap));
+}
+
+int
+ahc_disc_dsb_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "DISC_DSB",
+	    0x32, regvalue, cur_col, wrap));
+}
+
+int
+ahc_cmdsize_table_tail_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "CMDSIZE_TABLE_TAIL",
+	    0x34, regvalue, cur_col, wrap));
+}
+
+int
+ahc_mwi_residual_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "MWI_RESIDUAL",
+	    0x38, regvalue, cur_col, wrap));
+}
+
+int
+ahc_next_queued_scb_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "NEXT_QUEUED_SCB",
+	    0x39, regvalue, cur_col, wrap));
+}
+
+int
+ahc_msg_out_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "MSG_OUT",
+	    0x3a, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t DMAPARAMS_parse_table[] = {
+	{ "FIFORESET",		0x01, 0x01 },
+	{ "FIFOFLUSH",		0x02, 0x02 },
+	{ "DIRECTION",		0x04, 0x04 },
+	{ "HDMAEN",		0x08, 0x08 },
+	{ "HDMAENACK",		0x08, 0x08 },
+	{ "SDMAEN",		0x10, 0x10 },
+	{ "SDMAENACK",		0x10, 0x10 },
+	{ "SCSIEN",		0x20, 0x20 },
+	{ "WIDEODD",		0x40, 0x40 },
+	{ "PRELOADEN",		0x80, 0x80 }
+};
+
+int
+ahc_dmaparams_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(DMAPARAMS_parse_table, 10, "DMAPARAMS",
+	    0x3b, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SEQ_FLAGS_parse_table[] = {
+	{ "NO_DISCONNECT",	0x01, 0x01 },
+	{ "SPHASE_PENDING",	0x02, 0x02 },
+	{ "DPHASE_PENDING",	0x04, 0x04 },
+	{ "CMDPHASE_PENDING",	0x08, 0x08 },
+	{ "TARG_CMD_PENDING",	0x10, 0x10 },
+	{ "DPHASE",		0x20, 0x20 },
+	{ "NO_CDB_SENT",	0x40, 0x40 },
+	{ "TARGET_CMD_IS_TAGGED",0x40, 0x40 },
+	{ "NOT_IDENTIFIED",	0x80, 0x80 }
+};
+
+int
+ahc_seq_flags_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SEQ_FLAGS_parse_table, 9, "SEQ_FLAGS",
+	    0x3c, regvalue, cur_col, wrap));
+}
+
+int
+ahc_saved_scsiid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SAVED_SCSIID",
+	    0x3d, regvalue, cur_col, wrap));
+}
+
+int
+ahc_saved_lun_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SAVED_LUN",
+	    0x3e, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t LASTPHASE_parse_table[] = {
+	{ "MSGI",		0x20, 0x20 },
+	{ "IOI",		0x40, 0x40 },
+	{ "CDI",		0x80, 0x80 },
+	{ "P_DATAOUT",		0x00, 0x00 },
+	{ "P_BUSFREE",		0x01, 0x01 },
+	{ "P_DATAIN",		0x40, 0x40 },
+	{ "P_COMMAND",		0x80, 0x80 },
+	{ "P_MESGOUT",		0xa0, 0xa0 },
+	{ "P_STATUS",		0xc0, 0xc0 },
+	{ "PHASE_MASK",		0xe0, 0xe0 },
+	{ "P_MESGIN",		0xe0, 0xe0 }
+};
+
+int
+ahc_lastphase_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(LASTPHASE_parse_table, 11, "LASTPHASE",
+	    0x3f, regvalue, cur_col, wrap));
+}
+
+int
+ahc_waiting_scbh_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "WAITING_SCBH",
+	    0x40, regvalue, cur_col, wrap));
+}
+
+int
+ahc_disconnected_scbh_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "DISCONNECTED_SCBH",
+	    0x41, regvalue, cur_col, wrap));
+}
+
+int
+ahc_free_scbh_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "FREE_SCBH",
+	    0x42, regvalue, cur_col, wrap));
+}
+
+int
+ahc_complete_scbh_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "COMPLETE_SCBH",
+	    0x43, regvalue, cur_col, wrap));
+}
+
+int
+ahc_hscb_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "HSCB_ADDR",
+	    0x44, regvalue, cur_col, wrap));
+}
+
+int
+ahc_shared_data_addr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SHARED_DATA_ADDR",
+	    0x48, regvalue, cur_col, wrap));
+}
+
+int
+ahc_kernel_qinpos_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "KERNEL_QINPOS",
+	    0x4c, regvalue, cur_col, wrap));
+}
+
+int
+ahc_qinpos_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "QINPOS",
+	    0x4d, regvalue, cur_col, wrap));
+}
+
+int
+ahc_qoutpos_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "QOUTPOS",
+	    0x4e, regvalue, cur_col, wrap));
+}
+
+int
+ahc_kernel_tqinpos_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "KERNEL_TQINPOS",
+	    0x4f, regvalue, cur_col, wrap));
+}
+
+int
+ahc_tqinpos_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "TQINPOS",
+	    0x50, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t ARG_1_parse_table[] = {
+	{ "CONT_TARG_SESSION",	0x02, 0x02 },
+	{ "CONT_MSG_LOOP",	0x04, 0x04 },
+	{ "EXIT_MSG_LOOP",	0x08, 0x08 },
+	{ "MSGOUT_PHASEMIS",	0x10, 0x10 },
+	{ "SEND_REJ",		0x20, 0x20 },
+	{ "SEND_SENSE",		0x40, 0x40 },
+	{ "SEND_MSG",		0x80, 0x80 }
+};
+
+int
+ahc_arg_1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(ARG_1_parse_table, 7, "ARG_1",
+	    0x51, regvalue, cur_col, wrap));
+}
+
+int
+ahc_arg_2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "ARG_2",
+	    0x52, regvalue, cur_col, wrap));
+}
+
+int
+ahc_last_msg_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "LAST_MSG",
+	    0x53, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SCSISEQ_TEMPLATE_parse_table[] = {
+	{ "ENAUTOATNP",		0x02, 0x02 },
+	{ "ENAUTOATNI",		0x04, 0x04 },
+	{ "ENAUTOATNO",		0x08, 0x08 },
+	{ "ENRSELI",		0x10, 0x10 },
+	{ "ENSELI",		0x20, 0x20 },
+	{ "ENSELO",		0x40, 0x40 }
+};
+
+int
+ahc_scsiseq_template_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCSISEQ_TEMPLATE_parse_table, 6, "SCSISEQ_TEMPLATE",
+	    0x54, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t HA_274_BIOSGLOBAL_parse_table[] = {
+	{ "HA_274_EXTENDED_TRANS",0x01, 0x01 }
+};
+
+int
+ahc_ha_274_biosglobal_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(HA_274_BIOSGLOBAL_parse_table, 1, "HA_274_BIOSGLOBAL",
+	    0x56, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SEQ_FLAGS2_parse_table[] = {
+	{ "SCB_DMA",		0x01, 0x01 },
+	{ "TARGET_MSG_PENDING",	0x02, 0x02 }
+};
+
+int
+ahc_seq_flags2_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SEQ_FLAGS2_parse_table, 2, "SEQ_FLAGS2",
+	    0x57, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SCSICONF_parse_table[] = {
+	{ "ENSPCHK",		0x20, 0x20 },
+	{ "RESET_SCSI",		0x40, 0x40 },
+	{ "TERM_ENB",		0x80, 0x80 },
+	{ "HSCSIID",		0x07, 0x07 },
+	{ "HWSCSIID",		0x0f, 0x0f }
+};
+
+int
+ahc_scsiconf_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCSICONF_parse_table, 5, "SCSICONF",
+	    0x5a, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t INTDEF_parse_table[] = {
+	{ "EDGE_TRIG",		0x80, 0x80 },
+	{ "VECTOR",		0x0f, 0x0f }
+};
+
+int
+ahc_intdef_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(INTDEF_parse_table, 2, "INTDEF",
+	    0x5c, regvalue, cur_col, wrap));
+}
+
+int
+ahc_hostconf_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "HOSTCONF",
+	    0x5d, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t HA_274_BIOSCTRL_parse_table[] = {
+	{ "CHANNEL_B_PRIMARY",	0x08, 0x08 },
+	{ "BIOSMODE",		0x30, 0x30 },
+	{ "BIOSDISABLED",	0x30, 0x30 }
+};
+
+int
+ahc_ha_274_biosctrl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(HA_274_BIOSCTRL_parse_table, 3, "HA_274_BIOSCTRL",
+	    0x5f, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SEQCTL_parse_table[] = {
+	{ "LOADRAM",		0x01, 0x01 },
+	{ "SEQRESET",		0x02, 0x02 },
+	{ "STEP",		0x04, 0x04 },
+	{ "BRKADRINTEN",	0x08, 0x08 },
+	{ "FASTMODE",		0x10, 0x10 },
+	{ "FAILDIS",		0x20, 0x20 },
+	{ "PAUSEDIS",		0x40, 0x40 },
+	{ "PERRORDIS",		0x80, 0x80 }
+};
+
+int
+ahc_seqctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SEQCTL_parse_table, 8, "SEQCTL",
+	    0x60, regvalue, cur_col, wrap));
+}
+
+int
+ahc_seqram_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SEQRAM",
+	    0x61, regvalue, cur_col, wrap));
+}
+
+int
+ahc_seqaddr0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SEQADDR0",
+	    0x62, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SEQADDR1_parse_table[] = {
+	{ "SEQADDR1_MASK",	0x01, 0x01 }
+};
+
+int
+ahc_seqaddr1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SEQADDR1_parse_table, 1, "SEQADDR1",
+	    0x63, regvalue, cur_col, wrap));
+}
+
+int
+ahc_accum_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "ACCUM",
+	    0x64, regvalue, cur_col, wrap));
+}
+
+int
+ahc_sindex_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SINDEX",
+	    0x65, regvalue, cur_col, wrap));
+}
+
+int
+ahc_dindex_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "DINDEX",
+	    0x66, regvalue, cur_col, wrap));
+}
+
+int
+ahc_allones_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "ALLONES",
+	    0x69, regvalue, cur_col, wrap));
+}
+
+int
+ahc_allzeros_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "ALLZEROS",
+	    0x6a, regvalue, cur_col, wrap));
+}
+
+int
+ahc_none_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "NONE",
+	    0x6a, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t FLAGS_parse_table[] = {
+	{ "CARRY",		0x01, 0x01 },
+	{ "ZERO",		0x02, 0x02 }
+};
+
+int
+ahc_flags_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(FLAGS_parse_table, 2, "FLAGS",
+	    0x6b, regvalue, cur_col, wrap));
+}
+
+int
+ahc_sindir_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SINDIR",
+	    0x6c, regvalue, cur_col, wrap));
+}
+
+int
+ahc_dindir_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "DINDIR",
+	    0x6d, regvalue, cur_col, wrap));
+}
+
+int
+ahc_function1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "FUNCTION1",
+	    0x6e, regvalue, cur_col, wrap));
+}
+
+int
+ahc_stack_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "STACK",
+	    0x6f, regvalue, cur_col, wrap));
+}
+
+int
+ahc_targ_offset_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "TARG_OFFSET",
+	    0x70, regvalue, cur_col, wrap));
+}
+
+int
+ahc_sram_base_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SRAM_BASE",
+	    0x70, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t BCTL_parse_table[] = {
+	{ "ENABLE",		0x01, 0x01 },
+	{ "ACE",		0x08, 0x08 }
+};
+
+int
+ahc_bctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(BCTL_parse_table, 2, "BCTL",
+	    0x84, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t DSCOMMAND0_parse_table[] = {
+	{ "CIOPARCKEN",		0x01, 0x01 },
+	{ "USCBSIZE32",		0x02, 0x02 },
+	{ "RAMPS",		0x04, 0x04 },
+	{ "INTSCBRAMSEL",	0x08, 0x08 },
+	{ "EXTREQLCK",		0x10, 0x10 },
+	{ "MPARCKEN",		0x20, 0x20 },
+	{ "DPARCKEN",		0x40, 0x40 },
+	{ "CACHETHEN",		0x80, 0x80 }
+};
+
+int
+ahc_dscommand0_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(DSCOMMAND0_parse_table, 8, "DSCOMMAND0",
+	    0x84, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t BUSTIME_parse_table[] = {
+	{ "BON",		0x0f, 0x0f },
+	{ "BOFF",		0xf0, 0xf0 }
+};
+
+int
+ahc_bustime_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(BUSTIME_parse_table, 2, "BUSTIME",
+	    0x85, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t DSCOMMAND1_parse_table[] = {
+	{ "HADDLDSEL0",		0x01, 0x01 },
+	{ "HADDLDSEL1",		0x02, 0x02 },
+	{ "DSLATT",		0xfc, 0xfc }
+};
+
+int
+ahc_dscommand1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(DSCOMMAND1_parse_table, 3, "DSCOMMAND1",
+	    0x85, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t BUSSPD_parse_table[] = {
+	{ "STBON",		0x07, 0x07 },
+	{ "STBOFF",		0x38, 0x38 },
+	{ "DFTHRSH_75",		0x80, 0x80 },
+	{ "DFTHRSH",		0xc0, 0xc0 },
+	{ "DFTHRSH_100",	0xc0, 0xc0 }
+};
+
+int
+ahc_busspd_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(BUSSPD_parse_table, 5, "BUSSPD",
+	    0x86, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t HS_MAILBOX_parse_table[] = {
+	{ "SEQ_MAILBOX",	0x0f, 0x0f },
+	{ "HOST_TQINPOS",	0x80, 0x80 },
+	{ "HOST_MAILBOX",	0xf0, 0xf0 }
+};
+
+int
+ahc_hs_mailbox_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(HS_MAILBOX_parse_table, 3, "HS_MAILBOX",
+	    0x86, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t DSPCISTATUS_parse_table[] = {
+	{ "DFTHRSH_100",	0xc0, 0xc0 }
+};
+
+int
+ahc_dspcistatus_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(DSPCISTATUS_parse_table, 1, "DSPCISTATUS",
+	    0x86, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t HCNTRL_parse_table[] = {
+	{ "CHIPRST",		0x01, 0x01 },
+	{ "CHIPRSTACK",		0x01, 0x01 },
+	{ "INTEN",		0x02, 0x02 },
+	{ "PAUSE",		0x04, 0x04 },
+	{ "IRQMS",		0x08, 0x08 },
+	{ "SWINT",		0x10, 0x10 },
+	{ "POWRDN",		0x40, 0x40 }
+};
+
+int
+ahc_hcntrl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(HCNTRL_parse_table, 7, "HCNTRL",
+	    0x87, regvalue, cur_col, wrap));
+}
+
+int
+ahc_haddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "HADDR",
+	    0x88, regvalue, cur_col, wrap));
+}
+
+int
+ahc_hcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "HCNT",
+	    0x8c, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scbptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCBPTR",
+	    0x90, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t INTSTAT_parse_table[] = {
+	{ "SEQINT",		0x01, 0x01 },
+	{ "CMDCMPLT",		0x02, 0x02 },
+	{ "SCSIINT",		0x04, 0x04 },
+	{ "BRKADRINT",		0x08, 0x08 },
+	{ "BAD_PHASE",		0x01, 0x01 },
+	{ "INT_PEND",		0x0f, 0x0f },
+	{ "SEND_REJECT",	0x11, 0x11 },
+	{ "PROTO_VIOLATION",	0x21, 0x21 },
+	{ "NO_MATCH",		0x31, 0x31 },
+	{ "IGN_WIDE_RES",	0x41, 0x41 },
+	{ "PDATA_REINIT",	0x51, 0x51 },
+	{ "HOST_MSG_LOOP",	0x61, 0x61 },
+	{ "BAD_STATUS",		0x71, 0x71 },
+	{ "PERR_DETECTED",	0x81, 0x81 },
+	{ "DATA_OVERRUN",	0x91, 0x91 },
+	{ "MKMSG_FAILED",	0xa1, 0xa1 },
+	{ "MISSED_BUSFREE",	0xb1, 0xb1 },
+	{ "SCB_MISMATCH",	0xc1, 0xc1 },
+	{ "NO_FREE_SCB",	0xd1, 0xd1 },
+	{ "OUT_OF_RANGE",	0xe1, 0xe1 },
+	{ "SEQINT_MASK",	0xf1, 0xf1 }
+};
+
+int
+ahc_intstat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(INTSTAT_parse_table, 21, "INTSTAT",
+	    0x91, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t CLRINT_parse_table[] = {
+	{ "CLRSEQINT",		0x01, 0x01 },
+	{ "CLRCMDINT",		0x02, 0x02 },
+	{ "CLRSCSIINT",		0x04, 0x04 },
+	{ "CLRBRKADRINT",	0x08, 0x08 },
+	{ "CLRPARERR",		0x10, 0x10 }
+};
+
+int
+ahc_clrint_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(CLRINT_parse_table, 5, "CLRINT",
+	    0x92, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t ERROR_parse_table[] = {
+	{ "ILLHADDR",		0x01, 0x01 },
+	{ "ILLSADDR",		0x02, 0x02 },
+	{ "ILLOPCODE",		0x04, 0x04 },
+	{ "SQPARERR",		0x08, 0x08 },
+	{ "DPARERR",		0x10, 0x10 },
+	{ "MPARERR",		0x20, 0x20 },
+	{ "PCIERRSTAT",		0x40, 0x40 },
+	{ "CIOPARERR",		0x80, 0x80 }
+};
+
+int
+ahc_error_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(ERROR_parse_table, 8, "ERROR",
+	    0x92, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t DFCNTRL_parse_table[] = {
+	{ "FIFORESET",		0x01, 0x01 },
+	{ "FIFOFLUSH",		0x02, 0x02 },
+	{ "DIRECTION",		0x04, 0x04 },
+	{ "HDMAEN",		0x08, 0x08 },
+	{ "HDMAENACK",		0x08, 0x08 },
+	{ "SDMAEN",		0x10, 0x10 },
+	{ "SDMAENACK",		0x10, 0x10 },
+	{ "SCSIEN",		0x20, 0x20 },
+	{ "WIDEODD",		0x40, 0x40 },
+	{ "PRELOADEN",		0x80, 0x80 }
+};
+
+int
+ahc_dfcntrl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(DFCNTRL_parse_table, 10, "DFCNTRL",
+	    0x93, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t DFSTATUS_parse_table[] = {
+	{ "FIFOEMP",		0x01, 0x01 },
+	{ "FIFOFULL",		0x02, 0x02 },
+	{ "DFTHRESH",		0x04, 0x04 },
+	{ "HDONE",		0x08, 0x08 },
+	{ "MREQPEND",		0x10, 0x10 },
+	{ "FIFOQWDEMP",		0x20, 0x20 },
+	{ "DFCACHETH",		0x40, 0x40 },
+	{ "PRELOAD_AVAIL",	0x80, 0x80 }
+};
+
+int
+ahc_dfstatus_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(DFSTATUS_parse_table, 8, "DFSTATUS",
+	    0x94, regvalue, cur_col, wrap));
+}
+
+int
+ahc_dfwaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "DFWADDR",
+	    0x95, regvalue, cur_col, wrap));
+}
+
+int
+ahc_dfraddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "DFRADDR",
+	    0x97, regvalue, cur_col, wrap));
+}
+
+int
+ahc_dfdat_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "DFDAT",
+	    0x99, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SCBCNT_parse_table[] = {
+	{ "SCBAUTO",		0x80, 0x80 },
+	{ "SCBCNT_MASK",	0x1f, 0x1f }
+};
+
+int
+ahc_scbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCBCNT_parse_table, 2, "SCBCNT",
+	    0x9a, regvalue, cur_col, wrap));
+}
+
+int
+ahc_qinfifo_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "QINFIFO",
+	    0x9b, regvalue, cur_col, wrap));
+}
+
+int
+ahc_qincnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "QINCNT",
+	    0x9c, regvalue, cur_col, wrap));
+}
+
+int
+ahc_qoutfifo_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "QOUTFIFO",
+	    0x9d, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t CRCCONTROL1_parse_table[] = {
+	{ "TARGCRCCNTEN",	0x04, 0x04 },
+	{ "TARGCRCENDEN",	0x08, 0x08 },
+	{ "CRCREQCHKEN",	0x10, 0x10 },
+	{ "CRCENDCHKEN",	0x20, 0x20 },
+	{ "CRCVALCHKEN",	0x40, 0x40 },
+	{ "CRCONSEEN",		0x80, 0x80 }
+};
+
+int
+ahc_crccontrol1_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(CRCCONTROL1_parse_table, 6, "CRCCONTROL1",
+	    0x9d, regvalue, cur_col, wrap));
+}
+
+int
+ahc_qoutcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "QOUTCNT",
+	    0x9e, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SCSIPHASE_parse_table[] = {
+	{ "DATA_OUT_PHASE",	0x01, 0x01 },
+	{ "DATA_IN_PHASE",	0x02, 0x02 },
+	{ "MSG_OUT_PHASE",	0x04, 0x04 },
+	{ "MSG_IN_PHASE",	0x08, 0x08 },
+	{ "COMMAND_PHASE",	0x10, 0x10 },
+	{ "STATUS_PHASE",	0x20, 0x20 },
+	{ "DATA_PHASE_MASK",	0x03, 0x03 }
+};
+
+int
+ahc_scsiphase_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCSIPHASE_parse_table, 7, "SCSIPHASE",
+	    0x9e, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SFUNCT_parse_table[] = {
+	{ "ALT_MODE",		0x80, 0x80 }
+};
+
+int
+ahc_sfunct_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SFUNCT_parse_table, 1, "SFUNCT",
+	    0x9f, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scb_base_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCB_BASE",
+	    0xa0, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scb_cdb_ptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCB_CDB_PTR",
+	    0xa0, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scb_residual_sgptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCB_RESIDUAL_SGPTR",
+	    0xa4, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scb_scsi_status_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCB_SCSI_STATUS",
+	    0xa8, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scb_target_phases_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCB_TARGET_PHASES",
+	    0xa9, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scb_target_data_dir_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCB_TARGET_DATA_DIR",
+	    0xaa, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scb_target_itag_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCB_TARGET_ITAG",
+	    0xab, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scb_dataptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCB_DATAPTR",
+	    0xac, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SCB_DATACNT_parse_table[] = {
+	{ "SG_LAST_SEG",	0x80, 0x80 },
+	{ "SG_HIGH_ADDR_BITS",	0x7f, 0x7f }
+};
+
+int
+ahc_scb_datacnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCB_DATACNT_parse_table, 2, "SCB_DATACNT",
+	    0xb0, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SCB_SGPTR_parse_table[] = {
+	{ "SG_LIST_NULL",	0x01, 0x01 },
+	{ "SG_FULL_RESID",	0x02, 0x02 },
+	{ "SG_RESID_VALID",	0x04, 0x04 }
+};
+
+int
+ahc_scb_sgptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCB_SGPTR_parse_table, 3, "SCB_SGPTR",
+	    0xb4, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SCB_CONTROL_parse_table[] = {
+	{ "DISCONNECTED",	0x04, 0x04 },
+	{ "ULTRAENB",		0x08, 0x08 },
+	{ "MK_MESSAGE",		0x10, 0x10 },
+	{ "TAG_ENB",		0x20, 0x20 },
+	{ "DISCENB",		0x40, 0x40 },
+	{ "TARGET_SCB",		0x80, 0x80 },
+	{ "STATUS_RCVD",	0x80, 0x80 },
+	{ "SCB_TAG_TYPE",	0x03, 0x03 }
+};
+
+int
+ahc_scb_control_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCB_CONTROL_parse_table, 8, "SCB_CONTROL",
+	    0xb8, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SCB_SCSIID_parse_table[] = {
+	{ "TWIN_CHNLB",		0x80, 0x80 },
+	{ "OID",		0x0f, 0x0f },
+	{ "TWIN_TID",		0x70, 0x70 },
+	{ "TID",		0xf0, 0xf0 }
+};
+
+int
+ahc_scb_scsiid_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCB_SCSIID_parse_table, 4, "SCB_SCSIID",
+	    0xb9, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SCB_LUN_parse_table[] = {
+	{ "SCB_XFERLEN_ODD",	0x80, 0x80 },
+	{ "LID",		0x3f, 0x3f }
+};
+
+int
+ahc_scb_lun_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SCB_LUN_parse_table, 2, "SCB_LUN",
+	    0xba, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scb_tag_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCB_TAG",
+	    0xbb, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scb_cdb_len_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCB_CDB_LEN",
+	    0xbc, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scb_scsirate_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCB_SCSIRATE",
+	    0xbd, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scb_scsioffset_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCB_SCSIOFFSET",
+	    0xbe, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scb_next_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCB_NEXT",
+	    0xbf, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scb_64_spare_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCB_64_SPARE",
+	    0xc0, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SEECTL_2840_parse_table[] = {
+	{ "DO_2840",		0x01, 0x01 },
+	{ "CK_2840",		0x02, 0x02 },
+	{ "CS_2840",		0x04, 0x04 }
+};
+
+int
+ahc_seectl_2840_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SEECTL_2840_parse_table, 3, "SEECTL_2840",
+	    0xc0, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t STATUS_2840_parse_table[] = {
+	{ "DI_2840",		0x01, 0x01 },
+	{ "EEPROM_TF",		0x80, 0x80 },
+	{ "ADSEL",		0x1e, 0x1e },
+	{ "BIOS_SEL",		0x60, 0x60 }
+};
+
+int
+ahc_status_2840_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(STATUS_2840_parse_table, 4, "STATUS_2840",
+	    0xc1, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scb_64_btt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCB_64_BTT",
+	    0xd0, regvalue, cur_col, wrap));
+}
+
+int
+ahc_cchaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "CCHADDR",
+	    0xe0, regvalue, cur_col, wrap));
+}
+
+int
+ahc_cchcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "CCHCNT",
+	    0xe8, regvalue, cur_col, wrap));
+}
+
+int
+ahc_ccsgram_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "CCSGRAM",
+	    0xe9, regvalue, cur_col, wrap));
+}
+
+int
+ahc_ccsgaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "CCSGADDR",
+	    0xea, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t CCSGCTL_parse_table[] = {
+	{ "CCSGRESET",		0x01, 0x01 },
+	{ "SG_FETCH_NEEDED",	0x02, 0x02 },
+	{ "CCSGEN",		0x08, 0x08 },
+	{ "CCSGDONE",		0x80, 0x80 }
+};
+
+int
+ahc_ccsgctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(CCSGCTL_parse_table, 4, "CCSGCTL",
+	    0xeb, regvalue, cur_col, wrap));
+}
+
+int
+ahc_ccscbram_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "CCSCBRAM",
+	    0xec, regvalue, cur_col, wrap));
+}
+
+int
+ahc_ccscbaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "CCSCBADDR",
+	    0xed, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t CCSCBCTL_parse_table[] = {
+	{ "CCSCBRESET",		0x01, 0x01 },
+	{ "CCSCBDIR",		0x04, 0x04 },
+	{ "CCSCBEN",		0x08, 0x08 },
+	{ "CCARREN",		0x10, 0x10 },
+	{ "ARRDONE",		0x40, 0x40 },
+	{ "CCSCBDONE",		0x80, 0x80 }
+};
+
+int
+ahc_ccscbctl_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(CCSCBCTL_parse_table, 6, "CCSCBCTL",
+	    0xee, regvalue, cur_col, wrap));
+}
+
+int
+ahc_ccscbcnt_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "CCSCBCNT",
+	    0xef, regvalue, cur_col, wrap));
+}
+
+int
+ahc_scbbaddr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SCBBADDR",
+	    0xf0, regvalue, cur_col, wrap));
+}
+
+int
+ahc_ccscbptr_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "CCSCBPTR",
+	    0xf1, regvalue, cur_col, wrap));
+}
+
+int
+ahc_hnscb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "HNSCB_QOFF",
+	    0xf4, regvalue, cur_col, wrap));
+}
+
+int
+ahc_snscb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SNSCB_QOFF",
+	    0xf6, regvalue, cur_col, wrap));
+}
+
+int
+ahc_sdscb_qoff_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(NULL, 0, "SDSCB_QOFF",
+	    0xf8, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t QOFF_CTLSTA_parse_table[] = {
+	{ "SDSCB_ROLLOVER",	0x10, 0x10 },
+	{ "SNSCB_ROLLOVER",	0x20, 0x20 },
+	{ "SCB_AVAIL",		0x40, 0x40 },
+	{ "SCB_QSIZE_256",	0x06, 0x06 },
+	{ "SCB_QSIZE",		0x07, 0x07 }
+};
+
+int
+ahc_qoff_ctlsta_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(QOFF_CTLSTA_parse_table, 5, "QOFF_CTLSTA",
+	    0xfa, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t DFF_THRSH_parse_table[] = {
+	{ "RD_DFTHRSH_MIN",	0x00, 0x00 },
+	{ "WR_DFTHRSH_MIN",	0x00, 0x00 },
+	{ "RD_DFTHRSH_25",	0x01, 0x01 },
+	{ "RD_DFTHRSH_50",	0x02, 0x02 },
+	{ "RD_DFTHRSH_63",	0x03, 0x03 },
+	{ "RD_DFTHRSH_75",	0x04, 0x04 },
+	{ "RD_DFTHRSH_85",	0x05, 0x05 },
+	{ "RD_DFTHRSH_90",	0x06, 0x06 },
+	{ "RD_DFTHRSH",		0x07, 0x07 },
+	{ "RD_DFTHRSH_MAX",	0x07, 0x07 },
+	{ "WR_DFTHRSH_25",	0x10, 0x10 },
+	{ "WR_DFTHRSH_50",	0x20, 0x20 },
+	{ "WR_DFTHRSH_63",	0x30, 0x30 },
+	{ "WR_DFTHRSH_75",	0x40, 0x40 },
+	{ "WR_DFTHRSH_85",	0x50, 0x50 },
+	{ "WR_DFTHRSH_90",	0x60, 0x60 },
+	{ "WR_DFTHRSH",		0x70, 0x70 },
+	{ "WR_DFTHRSH_MAX",	0x70, 0x70 }
+};
+
+int
+ahc_dff_thrsh_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(DFF_THRSH_parse_table, 18, "DFF_THRSH",
+	    0xfb, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SG_CACHE_SHADOW_parse_table[] = {
+	{ "LAST_SEG_DONE",	0x01, 0x01 },
+	{ "LAST_SEG",		0x02, 0x02 },
+	{ "SG_ADDR_MASK",	0xf8, 0xf8 }
+};
+
+int
+ahc_sg_cache_shadow_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SG_CACHE_SHADOW_parse_table, 3, "SG_CACHE_SHADOW",
+	    0xfc, regvalue, cur_col, wrap));
+}
+
+static ahc_reg_parse_entry_t SG_CACHE_PRE_parse_table[] = {
+	{ "LAST_SEG_DONE",	0x01, 0x01 },
+	{ "LAST_SEG",		0x02, 0x02 },
+	{ "SG_ADDR_MASK",	0xf8, 0xf8 }
+};
+
+int
+ahc_sg_cache_pre_print(u_int regvalue, u_int *cur_col, u_int wrap)
+{
+	return (ahc_print_register(SG_CACHE_PRE_parse_table, 3, "SG_CACHE_PRE",
+	    0xfc, regvalue, cur_col, wrap));
+}
+
diff -urNp linux-5720/drivers/scsi/aic7xxx/aic7xxx_seq.h linux-5730/drivers/scsi/aic7xxx/aic7xxx_seq.h
--- linux-5720/drivers/scsi/aic7xxx/aic7xxx_seq.h
+++ linux-5730/drivers/scsi/aic7xxx/aic7xxx_seq.h
@@ -2,13 +2,13 @@
  * DO NOT EDIT - This file is automatically generated
  *		 from the following source files:
  *
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#43 $
- * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#30 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.seq#56 $
+ * $Id: //depot/aic7xxx/aic7xxx/aic7xxx.reg#39 $
  */
 static uint8_t seqprog[] = {
 	0xb2, 0x00, 0x00, 0x08,
 	0xf7, 0x11, 0x22, 0x08,
-	0x00, 0x65, 0xe4, 0x59,
+	0x00, 0x65, 0xec, 0x59,
 	0xf7, 0x01, 0x02, 0x08,
 	0xff, 0x6a, 0x24, 0x08,
 	0x40, 0x00, 0x40, 0x68,
@@ -21,15 +21,15 @@ static uint8_t seqprog[] = {
 	0x01, 0x4d, 0xc8, 0x30,
 	0x00, 0x4c, 0x12, 0x70,
 	0x01, 0x39, 0xa2, 0x30,
-	0x00, 0x6a, 0xb6, 0x5e,
+	0x00, 0x6a, 0xc0, 0x5e,
 	0x01, 0x51, 0x20, 0x31,
 	0x01, 0x57, 0xae, 0x00,
 	0x0d, 0x6a, 0x76, 0x00,
-	0x00, 0x51, 0x08, 0x5e,
+	0x00, 0x51, 0x12, 0x5e,
 	0x01, 0x51, 0xc8, 0x30,
 	0x00, 0x39, 0xc8, 0x60,
 	0x00, 0xbb, 0x30, 0x70,
-	0xc1, 0x6a, 0xce, 0x5e,
+	0xc1, 0x6a, 0xd8, 0x5e,
 	0x01, 0xbf, 0x72, 0x30,
 	0x01, 0x40, 0x7e, 0x31,
 	0x01, 0x90, 0x80, 0x30,
@@ -42,17 +42,17 @@ static uint8_t seqprog[] = {
 	0x08, 0x6a, 0x18, 0x00,
 	0x08, 0x11, 0x22, 0x00,
 	0x60, 0x0b, 0x00, 0x78,
-	0x40, 0x0b, 0xfc, 0x68,
+	0x40, 0x0b, 0xfa, 0x68,
 	0x80, 0x0b, 0xb6, 0x78,
 	0x20, 0x6a, 0x16, 0x00,
 	0xa4, 0x6a, 0x06, 0x00,
-	0x08, 0x3c, 0x78, 0x00,
+	0x08, 0x6a, 0x78, 0x00,
 	0x01, 0x50, 0xc8, 0x30,
 	0xe0, 0x6a, 0xcc, 0x00,
-	0x48, 0x6a, 0xf2, 0x5d,
+	0x48, 0x6a, 0xfc, 0x5d,
 	0x01, 0x6a, 0xdc, 0x01,
 	0x88, 0x6a, 0xcc, 0x00,
-	0x48, 0x6a, 0xf2, 0x5d,
+	0x48, 0x6a, 0xfc, 0x5d,
 	0x01, 0x6a, 0x26, 0x01,
 	0xf0, 0x19, 0x7a, 0x08,
 	0x0f, 0x18, 0xc8, 0x08,
@@ -63,8 +63,8 @@ static uint8_t seqprog[] = {
 	0x80, 0x3d, 0x7a, 0x00,
 	0x01, 0x3d, 0xd8, 0x31,
 	0x01, 0x3d, 0x32, 0x31,
-	0x10, 0x03, 0x48, 0x79,
-	0x00, 0x65, 0xf4, 0x58,
+	0x10, 0x03, 0x4e, 0x79,
+	0x00, 0x65, 0xf2, 0x58,
 	0x80, 0x66, 0xae, 0x78,
 	0x01, 0x66, 0xd8, 0x31,
 	0x01, 0x66, 0x32, 0x31,
@@ -72,29 +72,29 @@ static uint8_t seqprog[] = {
 	0x40, 0x66, 0x82, 0x68,
 	0x01, 0x3c, 0x78, 0x00,
 	0x10, 0x03, 0x9e, 0x78,
-	0x00, 0x65, 0xf4, 0x58,
+	0x00, 0x65, 0xf2, 0x58,
 	0xe0, 0x66, 0xc8, 0x18,
 	0x00, 0x65, 0xaa, 0x50,
 	0xdd, 0x66, 0xc8, 0x18,
 	0x00, 0x65, 0xaa, 0x48,
 	0x01, 0x66, 0xd8, 0x31,
 	0x01, 0x66, 0x32, 0x31,
-	0x10, 0x03, 0x48, 0x79,
-	0x00, 0x65, 0xf4, 0x58,
+	0x10, 0x03, 0x4e, 0x79,
+	0x00, 0x65, 0xf2, 0x58,
 	0x01, 0x66, 0xd8, 0x31,
 	0x01, 0x66, 0x32, 0x31,
 	0x01, 0x66, 0xac, 0x30,
 	0x40, 0x3c, 0x78, 0x00,
 	0xff, 0x6a, 0xd8, 0x01,
 	0xff, 0x6a, 0x32, 0x01,
-	0x90, 0x3c, 0x78, 0x00,
-	0x02, 0x57, 0x3c, 0x69,
-	0x10, 0x03, 0x3a, 0x69,
-	0x00, 0x65, 0x1e, 0x41,
+	0x10, 0x3c, 0x78, 0x00,
+	0x02, 0x57, 0x40, 0x69,
+	0x10, 0x03, 0x3e, 0x69,
+	0x00, 0x65, 0x20, 0x41,
 	0x02, 0x57, 0xae, 0x00,
 	0x00, 0x65, 0x9e, 0x40,
-	0x61, 0x6a, 0xce, 0x5e,
-	0x08, 0x51, 0x1e, 0x71,
+	0x61, 0x6a, 0xd8, 0x5e,
+	0x08, 0x51, 0x20, 0x71,
 	0x02, 0x0b, 0xb2, 0x78,
 	0x00, 0x65, 0xae, 0x40,
 	0x1a, 0x01, 0x02, 0x00,
@@ -105,8 +105,8 @@ static uint8_t seqprog[] = {
 	0x08, 0x1f, 0xc4, 0x78,
 	0x80, 0x3d, 0x7a, 0x00,
 	0x20, 0x6a, 0x16, 0x00,
-	0x00, 0x65, 0xc4, 0x41,
-	0x00, 0x65, 0xa8, 0x5e,
+	0x00, 0x65, 0xcc, 0x41,
+	0x00, 0x65, 0xb2, 0x5e,
 	0x00, 0x65, 0x12, 0x40,
 	0x20, 0x11, 0xd2, 0x68,
 	0x20, 0x6a, 0x18, 0x00,
@@ -123,169 +123,169 @@ static uint8_t seqprog[] = {
 	0x80, 0x65, 0xca, 0x00,
 	0x01, 0x65, 0x00, 0x34,
 	0x01, 0x54, 0x00, 0x34,
-	0x1a, 0x01, 0x02, 0x00,
-	0x08, 0xb8, 0xf0, 0x78,
+	0x08, 0xb8, 0xee, 0x78,
 	0x20, 0x01, 0x02, 0x00,
 	0x02, 0xbd, 0x08, 0x34,
 	0x01, 0xbd, 0x08, 0x34,
 	0x08, 0x01, 0x02, 0x00,
-	0x02, 0x0b, 0xf6, 0x78,
+	0x02, 0x0b, 0xf4, 0x78,
 	0xf7, 0x01, 0x02, 0x08,
 	0x01, 0x06, 0xcc, 0x34,
 	0xb2, 0x00, 0x00, 0x08,
 	0x01, 0x40, 0x20, 0x31,
 	0x01, 0xbf, 0x80, 0x30,
 	0x01, 0xb9, 0x7a, 0x30,
-	0x01, 0xba, 0x7c, 0x30,
+	0x3f, 0xba, 0x7c, 0x08,
 	0x00, 0x65, 0xea, 0x58,
-	0x80, 0x0b, 0xbe, 0x79,
-	0xe4, 0x6a, 0x64, 0x5d,
+	0x80, 0x0b, 0xc4, 0x79,
+	0x12, 0x01, 0x02, 0x00,
+	0x01, 0xab, 0xac, 0x30,
+	0xe4, 0x6a, 0x6e, 0x5d,
 	0x40, 0x6a, 0x16, 0x00,
-	0x80, 0xba, 0x7a, 0x5d,
-	0x20, 0xb8, 0x16, 0x79,
-	0x20, 0x6a, 0x7a, 0x5d,
-	0x00, 0xab, 0x7a, 0x5d,
+	0x80, 0x3e, 0x84, 0x5d,
+	0x20, 0xb8, 0x18, 0x79,
+	0x20, 0x6a, 0x84, 0x5d,
+	0x00, 0xab, 0x84, 0x5d,
 	0x01, 0xa9, 0x78, 0x30,
-	0x10, 0xb8, 0x1e, 0x79,
-	0xe4, 0x6a, 0x64, 0x5d,
+	0x10, 0xb8, 0x20, 0x79,
+	0xe4, 0x6a, 0x6e, 0x5d,
 	0x00, 0x65, 0xae, 0x40,
-	0x10, 0x03, 0x38, 0x69,
-	0x08, 0x3c, 0x54, 0x69,
-	0x04, 0x3c, 0x8c, 0x69,
-	0x02, 0x3c, 0x92, 0x69,
-	0x01, 0x3c, 0x3e, 0x79,
-	0x01, 0x6a, 0xa2, 0x30,
-	0x00, 0x65, 0x9e, 0x59,
-	0x04, 0x51, 0x2c, 0x61,
-	0x00, 0x6a, 0xb6, 0x5e,
+	0x10, 0x03, 0x3c, 0x69,
+	0x08, 0x3c, 0x5a, 0x69,
+	0x04, 0x3c, 0x92, 0x69,
+	0x02, 0x3c, 0x98, 0x69,
+	0x01, 0x3c, 0x44, 0x79,
+	0xff, 0x6a, 0x70, 0x00,
+	0x00, 0x65, 0xa4, 0x59,
+	0x00, 0x6a, 0xc0, 0x5e,
+	0xff, 0x38, 0x30, 0x71,
 	0x0d, 0x6a, 0x76, 0x00,
-	0x00, 0xbb, 0x08, 0x5e,
-	0x00, 0x65, 0xec, 0x58,
-	0x00, 0x65, 0x16, 0x41,
+	0x00, 0x38, 0x12, 0x5e,
+	0x00, 0x65, 0xea, 0x58,
+	0x12, 0x01, 0x02, 0x00,
+	0x00, 0x65, 0x18, 0x41,
 	0xa4, 0x6a, 0x06, 0x00,
-	0x00, 0x65, 0xf4, 0x58,
+	0x00, 0x65, 0xf2, 0x58,
+	0xfd, 0x57, 0xae, 0x08,
 	0x00, 0x65, 0xae, 0x40,
-	0xe4, 0x6a, 0x64, 0x5d,
-	0x20, 0x3c, 0x44, 0x79,
-	0x02, 0x6a, 0x7a, 0x5d,
-	0x04, 0x6a, 0x7a, 0x5d,
-	0x01, 0x03, 0x46, 0x69,
+	0xe4, 0x6a, 0x6e, 0x5d,
+	0x20, 0x3c, 0x4a, 0x79,
+	0x02, 0x6a, 0x84, 0x5d,
+	0x04, 0x6a, 0x84, 0x5d,
+	0x01, 0x03, 0x4c, 0x69,
 	0xf7, 0x11, 0x22, 0x08,
 	0xff, 0x6a, 0x24, 0x08,
 	0xff, 0x6a, 0x06, 0x08,
 	0x01, 0x6a, 0x7e, 0x00,
-	0x00, 0x65, 0x9e, 0x59,
+	0x00, 0x65, 0xa4, 0x59,
 	0x00, 0x65, 0x04, 0x40,
 	0x80, 0x86, 0xc8, 0x08,
 	0x01, 0x4f, 0xc8, 0x30,
-	0x00, 0x50, 0x66, 0x61,
-	0xc4, 0x6a, 0x64, 0x5d,
-	0x40, 0x3c, 0x62, 0x79,
-	0x28, 0x6a, 0x7a, 0x5d,
-	0x00, 0x65, 0x46, 0x41,
-	0x08, 0x6a, 0x7a, 0x5d,
-	0x00, 0x65, 0x46, 0x41,
-	0x84, 0x6a, 0x64, 0x5d,
-	0x00, 0x65, 0xf4, 0x58,
+	0x00, 0x50, 0x6c, 0x61,
+	0xc4, 0x6a, 0x6e, 0x5d,
+	0x40, 0x3c, 0x68, 0x79,
+	0x28, 0x6a, 0x84, 0x5d,
+	0x00, 0x65, 0x4c, 0x41,
+	0x08, 0x6a, 0x84, 0x5d,
+	0x00, 0x65, 0x4c, 0x41,
+	0x84, 0x6a, 0x6e, 0x5d,
+	0x00, 0x65, 0xf2, 0x58,
 	0x01, 0x66, 0xc8, 0x30,
 	0x01, 0x64, 0xd8, 0x31,
 	0x01, 0x64, 0x32, 0x31,
 	0x5b, 0x64, 0xc8, 0x28,
 	0x30, 0x64, 0xca, 0x18,
 	0x01, 0x6c, 0xc8, 0x30,
-	0xff, 0x64, 0x88, 0x79,
+	0xff, 0x64, 0x8e, 0x79,
 	0x08, 0x01, 0x02, 0x00,
-	0x02, 0x0b, 0x7a, 0x79,
-	0x01, 0x64, 0x80, 0x61,
+	0x02, 0x0b, 0x80, 0x79,
+	0x01, 0x64, 0x86, 0x61,
 	0xf7, 0x01, 0x02, 0x08,
 	0x01, 0x06, 0xd8, 0x31,
 	0x01, 0x06, 0x32, 0x31,
 	0xff, 0x64, 0xc8, 0x18,
-	0xff, 0x64, 0x7a, 0x69,
+	0xff, 0x64, 0x80, 0x69,
 	0xf7, 0x3c, 0x78, 0x08,
-	0x00, 0x65, 0x1e, 0x41,
+	0x00, 0x65, 0x20, 0x41,
 	0x40, 0xaa, 0x7e, 0x10,
-	0x04, 0xaa, 0x64, 0x5d,
+	0x04, 0xaa, 0x6e, 0x5d,
 	0x00, 0x65, 0x56, 0x42,
-	0xc4, 0x6a, 0x64, 0x5d,
+	0xc4, 0x6a, 0x6e, 0x5d,
 	0xc0, 0x6a, 0x7e, 0x00,
-	0x00, 0xa8, 0x7a, 0x5d,
+	0x00, 0xa8, 0x84, 0x5d,
 	0xe4, 0x6a, 0x06, 0x00,
-	0x00, 0x6a, 0x7a, 0x5d,
-	0x00, 0x65, 0x46, 0x41,
-	0x10, 0x3c, 0xa2, 0x69,
-	0x00, 0xbb, 0x84, 0x44,
+	0x00, 0x6a, 0x84, 0x5d,
+	0x00, 0x65, 0x4c, 0x41,
+	0x10, 0x3c, 0xa8, 0x69,
+	0x00, 0xbb, 0x8a, 0x44,
 	0x18, 0x6a, 0xda, 0x01,
 	0x01, 0x69, 0xd8, 0x31,
 	0x1c, 0x6a, 0xd0, 0x01,
 	0x09, 0xee, 0xdc, 0x01,
-	0x80, 0xee, 0xaa, 0x79,
+	0x80, 0xee, 0xb0, 0x79,
 	0xff, 0x6a, 0xdc, 0x09,
 	0x01, 0x93, 0x26, 0x01,
 	0x03, 0x6a, 0x2a, 0x01,
 	0x01, 0x69, 0x32, 0x31,
-	0x1c, 0x6a, 0xd6, 0x5d,
+	0x1c, 0x6a, 0xe0, 0x5d,
 	0x0a, 0x93, 0x26, 0x01,
-	0x00, 0x65, 0x9e, 0x5e,
+	0x00, 0x65, 0xa8, 0x5e,
 	0x01, 0x50, 0xa0, 0x18,
 	0x02, 0x6a, 0x22, 0x05,
+	0x1a, 0x01, 0x02, 0x00,
 	0x80, 0x6a, 0x74, 0x00,
-	0x80, 0x3c, 0x78, 0x00,
+	0x40, 0x6a, 0x78, 0x00,
 	0x40, 0x6a, 0x16, 0x00,
-	0x00, 0x65, 0xce, 0x5d,
+	0x00, 0x65, 0xd8, 0x5d,
 	0x01, 0x3f, 0xc8, 0x30,
 	0xbf, 0x64, 0x56, 0x7a,
-	0x80, 0x64, 0xaa, 0x73,
-	0xa0, 0x64, 0x08, 0x74,
-	0xc0, 0x64, 0xfc, 0x73,
-	0xe0, 0x64, 0x38, 0x74,
-	0x01, 0x6a, 0xce, 0x5e,
-	0x00, 0x65, 0xc4, 0x41,
+	0x80, 0x64, 0x9e, 0x73,
+	0xa0, 0x64, 0x00, 0x74,
+	0xc0, 0x64, 0xf4, 0x73,
+	0xe0, 0x64, 0x30, 0x74,
+	0x01, 0x6a, 0xd8, 0x5e,
+	0x00, 0x65, 0xcc, 0x41,
 	0xf7, 0x11, 0x22, 0x08,
 	0x01, 0x06, 0xd4, 0x30,
 	0xff, 0x6a, 0x24, 0x08,
 	0xf7, 0x01, 0x02, 0x08,
-	0x09, 0x0c, 0xde, 0x79,
+	0x09, 0x0c, 0xe6, 0x79,
 	0x08, 0x0c, 0x04, 0x68,
-	0xb1, 0x6a, 0xce, 0x5e,
+	0xb1, 0x6a, 0xd8, 0x5e,
 	0xff, 0x6a, 0x26, 0x09,
 	0x12, 0x01, 0x02, 0x00,
 	0x02, 0x6a, 0x08, 0x30,
 	0xff, 0x6a, 0x08, 0x08,
 	0xdf, 0x01, 0x02, 0x08,
 	0x01, 0x6a, 0x7e, 0x00,
-	0xff, 0x6a, 0x78, 0x0c,
+	0xc0, 0x6a, 0x78, 0x04,
 	0xff, 0x6a, 0xc8, 0x08,
 	0x08, 0xa4, 0x48, 0x19,
 	0x00, 0xa5, 0x4a, 0x21,
 	0x00, 0xa6, 0x4c, 0x21,
 	0x00, 0xa7, 0x4e, 0x25,
-	0x08, 0xeb, 0xd2, 0x7e,
-	0x80, 0xeb, 0xfe, 0x79,
+	0x08, 0xeb, 0xdc, 0x7e,
+	0x80, 0xeb, 0x06, 0x7a,
 	0xff, 0x6a, 0xd6, 0x09,
-	0x08, 0xeb, 0x02, 0x6a,
+	0x08, 0xeb, 0x0a, 0x6a,
 	0xff, 0x6a, 0xd4, 0x0c,
-	0x80, 0xa3, 0xd2, 0x6e,
-	0x88, 0xeb, 0x18, 0x72,
-	0x08, 0xeb, 0xd2, 0x6e,
-	0x04, 0xea, 0x1c, 0xe2,
-	0x08, 0xee, 0xd2, 0x6e,
+	0x80, 0xa3, 0xdc, 0x6e,
+	0x88, 0xeb, 0x20, 0x72,
+	0x08, 0xeb, 0xdc, 0x6e,
+	0x04, 0xea, 0x24, 0xe2,
+	0x08, 0xee, 0xdc, 0x6e,
 	0x04, 0x6a, 0xd0, 0x81,
 	0x05, 0xa4, 0xc0, 0x89,
 	0x03, 0xa5, 0xc2, 0x31,
 	0x09, 0x6a, 0xd6, 0x05,
-	0x00, 0x65, 0x00, 0x5a,
+	0x00, 0x65, 0x08, 0x5a,
 	0x06, 0xa4, 0xd4, 0x89,
-	0x80, 0x94, 0xd2, 0x7e,
+	0x80, 0x94, 0xdc, 0x7e,
 	0x07, 0xe9, 0x10, 0x31,
-	0x01, 0x8c, 0x24, 0x7a,
-	0x01, 0x55, 0xaa, 0x10,
 	0x01, 0xe9, 0x46, 0x31,
-	0x00, 0xa3, 0xb0, 0x5e,
-	0x00, 0x65, 0xf2, 0x59,
+	0x00, 0xa3, 0xba, 0x5e,
+	0x00, 0x65, 0xfa, 0x59,
 	0x01, 0xa4, 0xca, 0x30,
-	0x01, 0x55, 0x30, 0x7a,
-	0x04, 0x65, 0xca, 0x00,
 	0x80, 0xa3, 0x34, 0x7a,
 	0x02, 0x65, 0xca, 0x00,
 	0x01, 0x65, 0xf8, 0x31,
@@ -294,168 +294,162 @@ static uint8_t seqprog[] = {
 	0x01, 0x8c, 0xc8, 0x30,
 	0x00, 0x88, 0xc8, 0x18,
 	0x02, 0x64, 0xc8, 0x88,
-	0xff, 0x64, 0xd2, 0x7e,
+	0xff, 0x64, 0xdc, 0x7e,
 	0xff, 0x8d, 0x4a, 0x6a,
 	0xff, 0x8e, 0x4a, 0x6a,
 	0x03, 0x8c, 0xd4, 0x98,
-	0x00, 0x65, 0xd2, 0x56,
+	0x00, 0x65, 0xdc, 0x56,
 	0x01, 0x64, 0x70, 0x30,
 	0xff, 0x64, 0xc8, 0x10,
 	0x01, 0x64, 0xc8, 0x18,
 	0x00, 0x8c, 0x18, 0x19,
 	0xff, 0x8d, 0x1a, 0x21,
 	0xff, 0x8e, 0x1c, 0x25,
-	0x80, 0x3c, 0x5a, 0x6a,
-	0x21, 0x6a, 0xce, 0x46,
+	0xc0, 0x3c, 0x5a, 0x7a,
+	0x21, 0x6a, 0xd8, 0x5e,
 	0xa8, 0x6a, 0x76, 0x00,
 	0x79, 0x6a, 0x76, 0x00,
 	0x40, 0x3f, 0x62, 0x6a,
 	0x04, 0x3b, 0x76, 0x00,
 	0x04, 0x6a, 0xd4, 0x81,
 	0x20, 0x3c, 0x6a, 0x7a,
-	0x51, 0x6a, 0xce, 0x5e,
-	0x00, 0x65, 0x84, 0x42,
+	0x51, 0x6a, 0xd8, 0x5e,
+	0x00, 0x65, 0x82, 0x42,
 	0x20, 0x3c, 0x78, 0x00,
-	0x00, 0xb3, 0xb0, 0x5e,
+	0x00, 0xb3, 0xba, 0x5e,
 	0x07, 0xac, 0x10, 0x31,
 	0x05, 0xb3, 0x46, 0x31,
 	0x88, 0x6a, 0xcc, 0x00,
-	0xac, 0x6a, 0xe4, 0x5d,
+	0xac, 0x6a, 0xee, 0x5d,
 	0xa3, 0x6a, 0xcc, 0x00,
-	0xb3, 0x6a, 0xe8, 0x5d,
+	0xb3, 0x6a, 0xf2, 0x5d,
 	0x00, 0x65, 0x3a, 0x5a,
 	0xfd, 0xa4, 0x48, 0x09,
-	0x01, 0x8c, 0xaa, 0x08,
 	0x03, 0x8c, 0x10, 0x30,
-	0x00, 0x65, 0xdc, 0x5d,
-	0x01, 0xa4, 0x96, 0x7a,
+	0x00, 0x65, 0xe6, 0x5d,
+	0x01, 0xa4, 0x94, 0x7a,
 	0x04, 0x3b, 0x76, 0x08,
 	0x01, 0x3b, 0x26, 0x31,
 	0x80, 0x02, 0x04, 0x00,
-	0x10, 0x0c, 0x8c, 0x7a,
-	0x03, 0x9e, 0x8e, 0x6a,
+	0x10, 0x0c, 0x8a, 0x7a,
+	0x03, 0x9e, 0x8c, 0x6a,
 	0x7f, 0x02, 0x04, 0x08,
-	0x91, 0x6a, 0xce, 0x5e,
-	0x00, 0x65, 0xc4, 0x41,
+	0x91, 0x6a, 0xd8, 0x5e,
+	0x00, 0x65, 0xcc, 0x41,
 	0x01, 0xa4, 0xca, 0x30,
-	0x80, 0xa3, 0x9c, 0x7a,
+	0x80, 0xa3, 0x9a, 0x7a,
 	0x02, 0x65, 0xca, 0x00,
-	0x01, 0x55, 0xa0, 0x7a,
-	0x04, 0x65, 0xca, 0x00,
 	0x01, 0x65, 0xf8, 0x31,
 	0x01, 0x3b, 0x26, 0x31,
-	0x00, 0x65, 0x06, 0x5a,
-	0x01, 0xfc, 0xae, 0x6a,
-	0x80, 0x0b, 0xa4, 0x6a,
-	0x10, 0x0c, 0xa4, 0x7a,
-	0x20, 0x93, 0xa4, 0x6a,
+	0x00, 0x65, 0x0e, 0x5a,
+	0x01, 0xfc, 0xa8, 0x6a,
+	0x80, 0x0b, 0x9e, 0x6a,
+	0x10, 0x0c, 0x9e, 0x7a,
+	0x20, 0x93, 0x9e, 0x6a,
 	0x02, 0x93, 0x26, 0x01,
-	0x02, 0xfc, 0xb8, 0x7a,
-	0x40, 0x0d, 0xd2, 0x6a,
+	0x02, 0xfc, 0xb2, 0x7a,
+	0x40, 0x0d, 0xc6, 0x6a,
 	0x01, 0xa4, 0x48, 0x01,
-	0x00, 0x65, 0xd2, 0x42,
-	0x40, 0x0d, 0xbe, 0x6a,
-	0x00, 0x65, 0x06, 0x5a,
-	0x00, 0x65, 0xb0, 0x42,
-	0x80, 0xfc, 0xc8, 0x7a,
-	0x80, 0xa4, 0xc8, 0x6a,
+	0x00, 0x65, 0xc6, 0x42,
+	0x40, 0x0d, 0xb8, 0x6a,
+	0x00, 0x65, 0x0e, 0x5a,
+	0x00, 0x65, 0xaa, 0x42,
+	0x80, 0xfc, 0xc2, 0x7a,
+	0x80, 0xa4, 0xc2, 0x6a,
 	0xff, 0xa5, 0x4a, 0x19,
 	0xff, 0xa6, 0x4c, 0x21,
 	0xff, 0xa7, 0x4e, 0x21,
 	0xf8, 0xfc, 0x48, 0x09,
-	0xff, 0x6a, 0xaa, 0x08,
-	0x04, 0xfc, 0xd0, 0x7a,
-	0x01, 0x55, 0xaa, 0x00,
-	0xff, 0x6a, 0x46, 0x09,
-	0x04, 0x3b, 0xea, 0x6a,
+	0x7f, 0xa3, 0x46, 0x09,
+	0x04, 0x3b, 0xe2, 0x6a,
 	0x02, 0x93, 0x26, 0x01,
-	0x01, 0x94, 0xd4, 0x7a,
-	0x01, 0x94, 0xd4, 0x7a,
-	0x01, 0x94, 0xd4, 0x7a,
-	0x01, 0x94, 0xd4, 0x7a,
-	0x01, 0x94, 0xd4, 0x7a,
-	0x01, 0xa4, 0xe8, 0x7a,
-	0x01, 0xfc, 0xe2, 0x7a,
-	0x01, 0x94, 0xea, 0x6a,
-	0x00, 0x65, 0x84, 0x42,
-	0x01, 0x94, 0xe8, 0x7a,
-	0x10, 0x94, 0xea, 0x6a,
+	0x01, 0x94, 0xc8, 0x7a,
+	0x01, 0x94, 0xc8, 0x7a,
+	0x01, 0x94, 0xc8, 0x7a,
+	0x01, 0x94, 0xc8, 0x7a,
+	0x01, 0x94, 0xc8, 0x7a,
+	0x01, 0xa4, 0xe0, 0x7a,
+	0x01, 0xfc, 0xd6, 0x7a,
+	0x01, 0x94, 0xe2, 0x6a,
+	0x01, 0x94, 0xe2, 0x6a,
+	0x01, 0x94, 0xe2, 0x6a,
+	0x00, 0x65, 0x82, 0x42,
+	0x01, 0x94, 0xe0, 0x7a,
+	0x10, 0x94, 0xe2, 0x6a,
 	0xd7, 0x93, 0x26, 0x09,
-	0x28, 0x93, 0xee, 0x6a,
+	0x28, 0x93, 0xe6, 0x6a,
 	0x01, 0x85, 0x0a, 0x01,
-	0x02, 0xfc, 0xf6, 0x6a,
+	0x02, 0xfc, 0xee, 0x6a,
 	0x01, 0x14, 0x46, 0x31,
 	0xff, 0x6a, 0x10, 0x09,
 	0xfe, 0x85, 0x0a, 0x09,
-	0xff, 0x38, 0x04, 0x6b,
-	0x80, 0xa3, 0x04, 0x7b,
-	0x80, 0x0b, 0x02, 0x7b,
-	0x04, 0x3b, 0x04, 0x7b,
+	0xff, 0x38, 0xfc, 0x6a,
+	0x80, 0xa3, 0xfc, 0x7a,
+	0x80, 0x0b, 0xfa, 0x7a,
+	0x04, 0x3b, 0xfc, 0x7a,
 	0xbf, 0x3b, 0x76, 0x08,
 	0x01, 0x3b, 0x26, 0x31,
-	0x00, 0x65, 0x06, 0x5a,
-	0x01, 0x0b, 0x12, 0x6b,
-	0x10, 0x0c, 0x06, 0x7b,
-	0x04, 0x93, 0x10, 0x6b,
-	0x01, 0x94, 0x0e, 0x7b,
-	0x10, 0x94, 0x10, 0x6b,
+	0x00, 0x65, 0x0e, 0x5a,
+	0x01, 0x0b, 0x0a, 0x6b,
+	0x10, 0x0c, 0xfe, 0x7a,
+	0x04, 0x93, 0x08, 0x6b,
+	0x01, 0x94, 0x06, 0x7b,
+	0x10, 0x94, 0x08, 0x6b,
 	0xc7, 0x93, 0x26, 0x09,
 	0x01, 0x99, 0xd4, 0x30,
-	0x38, 0x93, 0x14, 0x6b,
-	0xff, 0x08, 0x66, 0x6b,
-	0xff, 0x09, 0x66, 0x6b,
-	0xff, 0x0a, 0x66, 0x6b,
-	0xff, 0x38, 0x30, 0x7b,
+	0x38, 0x93, 0x0c, 0x6b,
+	0xff, 0x08, 0x5a, 0x6b,
+	0xff, 0x09, 0x5a, 0x6b,
+	0xff, 0x0a, 0x5a, 0x6b,
+	0xff, 0x38, 0x28, 0x7b,
 	0x04, 0x14, 0x10, 0x31,
 	0x01, 0x38, 0x18, 0x31,
 	0x02, 0x6a, 0x1a, 0x31,
 	0x88, 0x6a, 0xcc, 0x00,
-	0x14, 0x6a, 0xea, 0x5d,
-	0x00, 0x38, 0xd6, 0x5d,
+	0x14, 0x6a, 0xf4, 0x5d,
+	0x00, 0x38, 0xe0, 0x5d,
 	0xff, 0x6a, 0x70, 0x08,
-	0x00, 0x65, 0x5c, 0x43,
-	0x80, 0xa3, 0x36, 0x7b,
+	0x00, 0x65, 0x54, 0x43,
+	0x80, 0xa3, 0x2e, 0x7b,
 	0x01, 0xa4, 0x48, 0x01,
-	0x00, 0x65, 0x66, 0x43,
-	0x08, 0xeb, 0x3c, 0x7b,
-	0x00, 0x65, 0x06, 0x5a,
-	0x08, 0xeb, 0x38, 0x6b,
+	0x00, 0x65, 0x5a, 0x43,
+	0x08, 0xeb, 0x34, 0x7b,
+	0x00, 0x65, 0x0e, 0x5a,
+	0x08, 0xeb, 0x30, 0x6b,
 	0x07, 0xe9, 0x10, 0x31,
 	0x01, 0xe9, 0xca, 0x30,
 	0x01, 0x65, 0x46, 0x31,
-	0x00, 0x6a, 0xb0, 0x5e,
+	0x00, 0x6a, 0xba, 0x5e,
 	0x88, 0x6a, 0xcc, 0x00,
-	0xa4, 0x6a, 0xea, 0x5d,
-	0x08, 0x6a, 0xd6, 0x5d,
+	0xa4, 0x6a, 0xf4, 0x5d,
+	0x08, 0x6a, 0xe0, 0x5d,
 	0x0d, 0x93, 0x26, 0x01,
-	0x00, 0x65, 0x9e, 0x5e,
+	0x00, 0x65, 0xa8, 0x5e,
 	0x88, 0x6a, 0xcc, 0x00,
-	0x00, 0x65, 0x80, 0x5e,
+	0x00, 0x65, 0x8a, 0x5e,
 	0x01, 0x99, 0x46, 0x31,
-	0x00, 0xa3, 0xb0, 0x5e,
+	0x00, 0xa3, 0xba, 0x5e,
 	0x01, 0x88, 0x10, 0x31,
 	0x00, 0x65, 0x3a, 0x5a,
-	0x00, 0x65, 0xf2, 0x59,
+	0x00, 0x65, 0xfa, 0x59,
 	0x03, 0x8c, 0x10, 0x30,
-	0x00, 0x65, 0xdc, 0x5d,
-	0x01, 0x8c, 0x64, 0x7b,
-	0x01, 0x55, 0xaa, 0x10,
-	0x80, 0x0b, 0x84, 0x6a,
-	0x80, 0x0b, 0x6e, 0x6b,
-	0x01, 0x0c, 0x68, 0x7b,
-	0x10, 0x0c, 0x84, 0x7a,
-	0x03, 0x9e, 0x84, 0x6a,
-	0x00, 0x65, 0xfc, 0x59,
-	0x00, 0x6a, 0xb0, 0x5e,
-	0x01, 0xa4, 0x8e, 0x6b,
-	0xff, 0x38, 0x84, 0x7b,
+	0x00, 0x65, 0xe6, 0x5d,
+	0x80, 0x0b, 0x82, 0x6a,
+	0x80, 0x0b, 0x62, 0x6b,
+	0x01, 0x0c, 0x5c, 0x7b,
+	0x10, 0x0c, 0x82, 0x7a,
+	0x03, 0x9e, 0x82, 0x6a,
+	0x00, 0x65, 0x04, 0x5a,
+	0x00, 0x6a, 0xba, 0x5e,
+	0x01, 0xa4, 0x82, 0x6b,
+	0xff, 0x38, 0x78, 0x7b,
 	0x01, 0x38, 0xc8, 0x30,
 	0x00, 0x08, 0x40, 0x19,
 	0xff, 0x6a, 0xc8, 0x08,
 	0x00, 0x09, 0x42, 0x21,
 	0x00, 0x0a, 0x44, 0x21,
 	0xff, 0x6a, 0x70, 0x08,
-	0x00, 0x65, 0x86, 0x43,
+	0x00, 0x65, 0x7a, 0x43,
 	0x03, 0x08, 0x40, 0x31,
 	0x03, 0x08, 0x40, 0x31,
 	0x01, 0x08, 0x40, 0x31,
@@ -464,19 +458,19 @@ static uint8_t seqprog[] = {
 	0xfd, 0xb4, 0x68, 0x09,
 	0x12, 0x01, 0x02, 0x00,
 	0x12, 0x01, 0x02, 0x00,
-	0x04, 0x3c, 0xc4, 0x79,
+	0x04, 0x3c, 0xcc, 0x79,
 	0xfb, 0x3c, 0x78, 0x08,
-	0x04, 0x93, 0x1e, 0x79,
-	0x01, 0x0c, 0x9a, 0x6b,
-	0x01, 0x55, 0x1e, 0x79,
-	0x80, 0x04, 0x1e, 0x79,
-	0xe4, 0x6a, 0x64, 0x5d,
-	0x23, 0x6a, 0x7a, 0x5d,
-	0x01, 0x6a, 0x7a, 0x5d,
-	0x00, 0x65, 0x1e, 0x41,
-	0x00, 0x65, 0xc4, 0x41,
-	0x80, 0x3c, 0xae, 0x6b,
-	0x21, 0x6a, 0xce, 0x46,
+	0x04, 0x93, 0x20, 0x79,
+	0x01, 0x0c, 0x8e, 0x6b,
+	0x80, 0xba, 0x20, 0x79,
+	0x80, 0x04, 0x20, 0x79,
+	0xe4, 0x6a, 0x6e, 0x5d,
+	0x23, 0x6a, 0x84, 0x5d,
+	0x01, 0x6a, 0x84, 0x5d,
+	0x00, 0x65, 0x20, 0x41,
+	0x00, 0x65, 0xcc, 0x41,
+	0x80, 0x3c, 0xa2, 0x7b,
+	0x21, 0x6a, 0xd8, 0x5e,
 	0x01, 0xbc, 0x18, 0x31,
 	0x02, 0x6a, 0x1a, 0x31,
 	0x02, 0x6a, 0xf8, 0x01,
@@ -486,16 +480,16 @@ static uint8_t seqprog[] = {
 	0xff, 0x6a, 0x12, 0x08,
 	0xff, 0x6a, 0x14, 0x08,
 	0xf3, 0xbc, 0xd4, 0x18,
-	0xa0, 0x6a, 0xd4, 0x53,
+	0xa0, 0x6a, 0xc8, 0x53,
 	0x04, 0xa0, 0x10, 0x31,
 	0xac, 0x6a, 0x26, 0x01,
 	0x04, 0xa0, 0x10, 0x31,
 	0x03, 0x08, 0x18, 0x31,
 	0x88, 0x6a, 0xcc, 0x00,
-	0xa0, 0x6a, 0xea, 0x5d,
-	0x00, 0xbc, 0xd6, 0x5d,
+	0xa0, 0x6a, 0xf4, 0x5d,
+	0x00, 0xbc, 0xe0, 0x5d,
 	0x3d, 0x6a, 0x26, 0x01,
-	0x00, 0x65, 0xec, 0x43,
+	0x00, 0x65, 0xe0, 0x43,
 	0xff, 0x6a, 0x10, 0x09,
 	0xa4, 0x6a, 0x26, 0x01,
 	0x0c, 0xa0, 0x32, 0x31,
@@ -505,117 +499,128 @@ static uint8_t seqprog[] = {
 	0x36, 0x6a, 0x26, 0x01,
 	0x02, 0x93, 0x26, 0x01,
 	0x35, 0x6a, 0x26, 0x01,
-	0x00, 0x65, 0x92, 0x5e,
-	0x00, 0x65, 0x92, 0x5e,
+	0x00, 0x65, 0x9c, 0x5e,
+	0x00, 0x65, 0x9c, 0x5e,
 	0x02, 0x93, 0x26, 0x01,
-	0x04, 0x0b, 0xf0, 0x6b,
-	0x10, 0x0c, 0xec, 0x7b,
-	0x01, 0x03, 0xf0, 0x6b,
-	0x20, 0x93, 0xec, 0x6b,
+	0xbf, 0x3c, 0x78, 0x08,
+	0x04, 0x0b, 0xe6, 0x6b,
+	0x10, 0x0c, 0xe2, 0x7b,
+	0x01, 0x03, 0xe6, 0x6b,
+	0x20, 0x93, 0xe8, 0x6b,
+	0x04, 0x0b, 0xee, 0x6b,
+	0x40, 0x3c, 0x78, 0x00,
 	0xc7, 0x93, 0x26, 0x09,
-	0x38, 0x93, 0xf6, 0x6b,
-	0x10, 0x01, 0x02, 0x00,
-	0x00, 0x65, 0xc4, 0x41,
-	0x80, 0x3c, 0x00, 0x6c,
-	0x21, 0x6a, 0xce, 0x46,
+	0x38, 0x93, 0xf0, 0x6b,
+	0x00, 0x65, 0xcc, 0x41,
+	0x80, 0x3c, 0x56, 0x6c,
 	0x01, 0x06, 0x50, 0x31,
-	0x00, 0x65, 0xc4, 0x41,
+	0x80, 0xb8, 0x70, 0x01,
+	0x00, 0x65, 0xcc, 0x41,
 	0x10, 0x3f, 0x06, 0x00,
 	0x10, 0x6a, 0x06, 0x00,
 	0x01, 0x3a, 0xca, 0x30,
-	0x80, 0x65, 0x24, 0x64,
-	0x10, 0xb8, 0x48, 0x6c,
-	0xc0, 0xba, 0xca, 0x00,
-	0x40, 0xb8, 0x14, 0x6c,
+	0x80, 0x65, 0x1c, 0x64,
+	0x10, 0xb8, 0x40, 0x6c,
+	0xc0, 0x3e, 0xca, 0x00,
+	0x40, 0xb8, 0x0c, 0x6c,
 	0xbf, 0x65, 0xca, 0x08,
-	0x20, 0xb8, 0x28, 0x7c,
+	0x20, 0xb8, 0x20, 0x7c,
 	0x01, 0x65, 0x0c, 0x30,
-	0x00, 0x65, 0xce, 0x5d,
-	0xa0, 0x3f, 0x30, 0x64,
+	0x00, 0x65, 0xd8, 0x5d,
+	0xa0, 0x3f, 0x28, 0x64,
 	0x23, 0xb8, 0x0c, 0x08,
-	0x00, 0x65, 0xce, 0x5d,
-	0xa0, 0x3f, 0x30, 0x64,
-	0x00, 0xbb, 0x28, 0x44,
-	0xff, 0x65, 0x28, 0x64,
-	0x00, 0x65, 0x48, 0x44,
+	0x00, 0x65, 0xd8, 0x5d,
+	0xa0, 0x3f, 0x28, 0x64,
+	0x00, 0xbb, 0x20, 0x44,
+	0xff, 0x65, 0x20, 0x64,
+	0x00, 0x65, 0x40, 0x44,
 	0x40, 0x6a, 0x18, 0x00,
 	0x01, 0x65, 0x0c, 0x30,
-	0x00, 0x65, 0xce, 0x5d,
-	0xa0, 0x3f, 0x04, 0x74,
+	0x00, 0x65, 0xd8, 0x5d,
+	0xa0, 0x3f, 0xfc, 0x73,
 	0x40, 0x6a, 0x18, 0x00,
 	0x01, 0x3a, 0xa6, 0x30,
 	0x08, 0x6a, 0x74, 0x00,
-	0x00, 0x65, 0xc4, 0x41,
-	0x64, 0x6a, 0x5e, 0x5d,
-	0x80, 0x64, 0xce, 0x6c,
-	0x04, 0x64, 0x94, 0x74,
-	0x02, 0x64, 0xa2, 0x74,
-	0x00, 0x6a, 0x64, 0x74,
-	0x03, 0x64, 0xc0, 0x74,
-	0x23, 0x64, 0x50, 0x74,
-	0x08, 0x64, 0x60, 0x74,
-	0x61, 0x6a, 0xce, 0x5e,
-	0x00, 0x65, 0xce, 0x5d,
-	0x08, 0x51, 0xc6, 0x71,
-	0x00, 0x65, 0x48, 0x44,
-	0x80, 0x04, 0x5e, 0x7c,
-	0x51, 0x6a, 0x54, 0x5d,
-	0x01, 0x51, 0x5e, 0x64,
-	0x01, 0xa4, 0x5a, 0x7c,
-	0x01, 0x55, 0x60, 0x7c,
-	0x41, 0x6a, 0xce, 0x5e,
-	0x00, 0x65, 0x60, 0x44,
-	0x07, 0x6a, 0x4a, 0x5d,
+	0x00, 0x65, 0xcc, 0x41,
+	0x64, 0x6a, 0x68, 0x5d,
+	0x80, 0x64, 0xd8, 0x6c,
+	0x04, 0x64, 0x9a, 0x74,
+	0x02, 0x64, 0xaa, 0x74,
+	0x00, 0x6a, 0x60, 0x74,
+	0x03, 0x64, 0xc8, 0x74,
+	0x23, 0x64, 0x48, 0x74,
+	0x08, 0x64, 0x5c, 0x74,
+	0x61, 0x6a, 0xd8, 0x5e,
+	0x00, 0x65, 0xd8, 0x5d,
+	0x08, 0x51, 0xce, 0x71,
+	0x00, 0x65, 0x40, 0x44,
+	0x80, 0x04, 0x5a, 0x7c,
+	0x51, 0x6a, 0x5e, 0x5d,
+	0x01, 0x51, 0x5a, 0x64,
+	0x01, 0xa4, 0x52, 0x7c,
+	0x80, 0xba, 0x5c, 0x6c,
+	0x41, 0x6a, 0xd8, 0x5e,
+	0x00, 0x65, 0x5c, 0x44,
+	0x21, 0x6a, 0xd8, 0x5e,
+	0x00, 0x65, 0x5c, 0x44,
+	0x07, 0x6a, 0x54, 0x5d,
 	0x01, 0x06, 0xd4, 0x30,
-	0x00, 0x65, 0xc4, 0x41,
-	0x10, 0xb8, 0x68, 0x7c,
-	0xa1, 0x6a, 0xce, 0x5e,
-	0x01, 0xb4, 0x6e, 0x6c,
-	0x02, 0xb4, 0x70, 0x6c,
-	0x01, 0xa4, 0x70, 0x7c,
-	0xff, 0xa8, 0x80, 0x7c,
+	0x00, 0x65, 0xcc, 0x41,
+	0x80, 0xb8, 0x56, 0x7c,
+	0xc0, 0x3c, 0x6a, 0x7c,
+	0x80, 0x3c, 0x56, 0x6c,
+	0xff, 0xa8, 0x6a, 0x6c,
+	0x40, 0x3c, 0x56, 0x6c,
+	0x10, 0xb8, 0x6e, 0x7c,
+	0xa1, 0x6a, 0xd8, 0x5e,
+	0x01, 0xb4, 0x74, 0x6c,
+	0x02, 0xb4, 0x76, 0x6c,
+	0x01, 0xa4, 0x76, 0x7c,
+	0xff, 0xa8, 0x86, 0x7c,
 	0x04, 0xb4, 0x68, 0x01,
 	0x01, 0x6a, 0x76, 0x00,
-	0x00, 0xbb, 0x08, 0x5e,
-	0xff, 0xa8, 0x80, 0x7c,
-	0x71, 0x6a, 0xce, 0x5e,
-	0x40, 0x51, 0x80, 0x64,
-	0x00, 0x65, 0xa8, 0x5e,
-	0x00, 0x65, 0xd6, 0x41,
-	0x00, 0xbb, 0x84, 0x5c,
-	0x00, 0x65, 0xd6, 0x41,
-	0x00, 0x65, 0xa8, 0x5e,
+	0x00, 0xbb, 0x12, 0x5e,
+	0xff, 0xa8, 0x86, 0x7c,
+	0x71, 0x6a, 0xd8, 0x5e,
+	0x40, 0x51, 0x86, 0x64,
+	0x00, 0x65, 0xb2, 0x5e,
+	0x00, 0x65, 0xde, 0x41,
+	0x00, 0xbb, 0x8a, 0x5c,
+	0x00, 0x65, 0xde, 0x41,
+	0x00, 0x65, 0xb2, 0x5e,
 	0x01, 0x65, 0xa2, 0x30,
 	0x01, 0xf8, 0xc8, 0x30,
 	0x01, 0x4e, 0xc8, 0x30,
-	0x00, 0x6a, 0xac, 0xdd,
-	0x00, 0x51, 0xbe, 0x5d,
+	0x00, 0x6a, 0xb6, 0xdd,
+	0x00, 0x51, 0xc8, 0x5d,
 	0x01, 0x4e, 0x9c, 0x18,
 	0x02, 0x6a, 0x22, 0x05,
+	0xc0, 0x3c, 0x56, 0x6c,
 	0x04, 0xb8, 0x70, 0x01,
-	0x00, 0x65, 0xca, 0x5e,
-	0x20, 0xb8, 0xd6, 0x69,
+	0x00, 0x65, 0xd4, 0x5e,
+	0x20, 0xb8, 0xde, 0x69,
 	0x01, 0xbb, 0xa2, 0x30,
-	0x01, 0xba, 0x7c, 0x30,
-	0x00, 0xb9, 0xc4, 0x5c,
-	0x00, 0x65, 0xd6, 0x41,
+	0x3f, 0xba, 0x7c, 0x08,
+	0x00, 0xb9, 0xce, 0x5c,
+	0x00, 0x65, 0xde, 0x41,
 	0x01, 0x06, 0xd4, 0x30,
-	0x20, 0x3c, 0xc4, 0x79,
-	0x20, 0x3c, 0x60, 0x7c,
-	0x01, 0xa4, 0xb0, 0x7c,
+	0x20, 0x3c, 0xcc, 0x79,
+	0x20, 0x3c, 0x5c, 0x7c,
+	0x01, 0xa4, 0xb8, 0x7c,
 	0x01, 0xb4, 0x68, 0x01,
-	0x00, 0x65, 0xc4, 0x41,
-	0x00, 0x65, 0x60, 0x44,
+	0x00, 0x65, 0xcc, 0x41,
+	0x00, 0x65, 0x5c, 0x44,
 	0x04, 0x14, 0x58, 0x31,
 	0x01, 0x06, 0xd4, 0x30,
 	0x08, 0xa0, 0x60, 0x31,
 	0xac, 0x6a, 0xcc, 0x00,
-	0x14, 0x6a, 0xea, 0x5d,
+	0x14, 0x6a, 0xf4, 0x5d,
 	0x01, 0x06, 0xd4, 0x30,
-	0xa0, 0x6a, 0xe2, 0x5d,
-	0x00, 0x65, 0xc4, 0x41,
+	0xa0, 0x6a, 0xec, 0x5d,
+	0x00, 0x65, 0xcc, 0x41,
 	0xdf, 0x3c, 0x78, 0x08,
-	0x00, 0x65, 0x60, 0x44,
+	0x12, 0x01, 0x02, 0x00,
+	0x00, 0x65, 0x5c, 0x44,
 	0x4c, 0x65, 0xcc, 0x28,
 	0x01, 0x3e, 0x20, 0x31,
 	0xd0, 0x66, 0xcc, 0x18,
@@ -626,102 +631,102 @@ static uint8_t seqprog[] = {
 	0xd0, 0x65, 0xca, 0x18,
 	0x01, 0x3e, 0x20, 0x31,
 	0x30, 0x65, 0xd4, 0x18,
-	0x00, 0x65, 0xdc, 0x4c,
+	0x00, 0x65, 0xe6, 0x4c,
 	0xe1, 0x6a, 0x22, 0x01,
 	0xff, 0x6a, 0xd4, 0x08,
 	0x20, 0x65, 0xd4, 0x18,
-	0x00, 0x65, 0xe4, 0x54,
+	0x00, 0x65, 0xee, 0x54,
 	0xe1, 0x6a, 0x22, 0x01,
 	0xff, 0x6a, 0xd4, 0x08,
 	0x20, 0x65, 0xca, 0x18,
 	0xe0, 0x65, 0xd4, 0x18,
-	0x00, 0x65, 0xee, 0x4c,
+	0x00, 0x65, 0xf8, 0x4c,
 	0xe1, 0x6a, 0x22, 0x01,
 	0xff, 0x6a, 0xd4, 0x08,
 	0xd0, 0x65, 0xd4, 0x18,
-	0x00, 0x65, 0xf6, 0x54,
+	0x00, 0x65, 0x00, 0x55,
 	0xe1, 0x6a, 0x22, 0x01,
 	0xff, 0x6a, 0xd4, 0x08,
 	0x01, 0x6c, 0xa2, 0x30,
-	0xff, 0x51, 0x08, 0x75,
-	0x00, 0x51, 0x84, 0x5d,
+	0xff, 0x51, 0x12, 0x75,
+	0x00, 0x51, 0x8e, 0x5d,
 	0x01, 0x51, 0x20, 0x31,
-	0x00, 0x65, 0x2a, 0x45,
-	0x01, 0xba, 0xc8, 0x30,
-	0x00, 0x3e, 0x2a, 0x75,
-	0x00, 0x65, 0xa6, 0x5e,
+	0x00, 0x65, 0x34, 0x45,
+	0x3f, 0xba, 0xc8, 0x08,
+	0x00, 0x3e, 0x34, 0x75,
+	0x00, 0x65, 0xb0, 0x5e,
 	0x80, 0x3c, 0x78, 0x00,
 	0x01, 0x06, 0xd4, 0x30,
-	0x00, 0x65, 0xce, 0x5d,
+	0x00, 0x65, 0xd8, 0x5d,
 	0x01, 0x3c, 0x78, 0x00,
-	0xe0, 0x3f, 0x46, 0x65,
+	0xe0, 0x3f, 0x50, 0x65,
 	0x02, 0x3c, 0x78, 0x00,
-	0x20, 0x12, 0x46, 0x65,
-	0x51, 0x6a, 0x54, 0x5d,
-	0x00, 0x51, 0x84, 0x5d,
-	0x51, 0x6a, 0x54, 0x5d,
+	0x20, 0x12, 0x50, 0x65,
+	0x51, 0x6a, 0x5e, 0x5d,
+	0x00, 0x51, 0x8e, 0x5d,
+	0x51, 0x6a, 0x5e, 0x5d,
 	0x01, 0x51, 0x20, 0x31,
 	0x04, 0x3c, 0x78, 0x00,
 	0x01, 0xb9, 0xc8, 0x30,
-	0x00, 0x3d, 0x44, 0x65,
+	0x00, 0x3d, 0x4e, 0x65,
 	0x08, 0x3c, 0x78, 0x00,
-	0x01, 0xba, 0xc8, 0x30,
-	0x00, 0x3e, 0x44, 0x65,
+	0x3f, 0xba, 0xc8, 0x08,
+	0x00, 0x3e, 0x4e, 0x65,
 	0x10, 0x3c, 0x78, 0x00,
-	0x04, 0xb8, 0x44, 0x7d,
+	0x04, 0xb8, 0x4e, 0x7d,
 	0xfb, 0xb8, 0x70, 0x09,
-	0x20, 0xb8, 0x3a, 0x6d,
+	0x20, 0xb8, 0x44, 0x6d,
 	0x01, 0x90, 0xc8, 0x30,
 	0xff, 0x6a, 0xa2, 0x00,
-	0x00, 0x3d, 0xc4, 0x5c,
+	0x00, 0x3d, 0xce, 0x5c,
 	0x01, 0x64, 0x20, 0x31,
-	0x80, 0x6a, 0x78, 0x00,
-	0x00, 0x65, 0xec, 0x58,
-	0x10, 0xb8, 0x60, 0x7c,
-	0xff, 0x6a, 0x4a, 0x5d,
-	0x00, 0x65, 0x60, 0x44,
-	0x00, 0x65, 0xa6, 0x5e,
-	0x31, 0x6a, 0xce, 0x5e,
-	0x00, 0x65, 0x60, 0x44,
+	0xff, 0x6a, 0x78, 0x08,
+	0x00, 0x65, 0xea, 0x58,
+	0x10, 0xb8, 0x5c, 0x7c,
+	0xff, 0x6a, 0x54, 0x5d,
+	0x00, 0x65, 0x5c, 0x44,
+	0x00, 0x65, 0xb0, 0x5e,
+	0x31, 0x6a, 0xd8, 0x5e,
+	0x00, 0x65, 0x5c, 0x44,
 	0x10, 0x3f, 0x06, 0x00,
 	0x10, 0x6a, 0x06, 0x00,
 	0x01, 0x65, 0x74, 0x34,
-	0x81, 0x6a, 0xce, 0x5e,
-	0x00, 0x65, 0x56, 0x45,
+	0x81, 0x6a, 0xd8, 0x5e,
+	0x00, 0x65, 0x60, 0x45,
 	0x01, 0x06, 0xd4, 0x30,
-	0x01, 0x0c, 0x56, 0x7d,
-	0x04, 0x0c, 0x50, 0x6d,
+	0x01, 0x0c, 0x60, 0x7d,
+	0x04, 0x0c, 0x5a, 0x6d,
 	0xe0, 0x03, 0x7e, 0x08,
-	0xe0, 0x3f, 0xc4, 0x61,
+	0xe0, 0x3f, 0xcc, 0x61,
 	0x01, 0x65, 0xcc, 0x30,
 	0x01, 0x12, 0xda, 0x34,
 	0x01, 0x06, 0xd4, 0x34,
-	0x01, 0x03, 0x64, 0x6d,
+	0x01, 0x03, 0x6e, 0x6d,
 	0x40, 0x03, 0xcc, 0x08,
 	0x01, 0x65, 0x06, 0x30,
 	0x40, 0x65, 0xc8, 0x08,
-	0x00, 0x66, 0x72, 0x75,
-	0x40, 0x65, 0x72, 0x7d,
-	0x00, 0x65, 0x72, 0x5d,
+	0x00, 0x66, 0x7c, 0x75,
+	0x40, 0x65, 0x7c, 0x7d,
+	0x00, 0x65, 0x7c, 0x5d,
 	0xff, 0x6a, 0xd4, 0x08,
 	0xff, 0x6a, 0xd4, 0x08,
 	0xff, 0x6a, 0xd4, 0x08,
 	0xff, 0x6a, 0xd4, 0x0c,
 	0x08, 0x01, 0x02, 0x00,
-	0x02, 0x0b, 0x7c, 0x7d,
+	0x02, 0x0b, 0x86, 0x7d,
 	0x01, 0x65, 0x0c, 0x30,
-	0x02, 0x0b, 0x80, 0x7d,
+	0x02, 0x0b, 0x8a, 0x7d,
 	0xf7, 0x01, 0x02, 0x0c,
 	0x01, 0x65, 0xc8, 0x30,
-	0xff, 0x41, 0xa4, 0x75,
+	0xff, 0x41, 0xae, 0x75,
 	0x01, 0x41, 0x20, 0x31,
 	0xff, 0x6a, 0xa4, 0x00,
-	0x00, 0x65, 0x94, 0x45,
-	0xff, 0xbf, 0xa4, 0x75,
+	0x00, 0x65, 0x9e, 0x45,
+	0xff, 0xbf, 0xae, 0x75,
 	0x01, 0x90, 0xa4, 0x30,
 	0x01, 0xbf, 0x20, 0x31,
-	0x00, 0xbb, 0x8e, 0x65,
-	0xff, 0x52, 0xa2, 0x75,
+	0x00, 0xbb, 0x98, 0x65,
+	0xff, 0x52, 0xac, 0x75,
 	0x01, 0xbf, 0xcc, 0x30,
 	0x01, 0x90, 0xca, 0x30,
 	0x01, 0x52, 0x20, 0x31,
@@ -729,28 +734,28 @@ static uint8_t seqprog[] = {
 	0x01, 0x65, 0x20, 0x35,
 	0x01, 0xbf, 0x82, 0x34,
 	0x01, 0x64, 0xa2, 0x30,
-	0x00, 0x6a, 0xb6, 0x5e,
+	0x00, 0x6a, 0xc0, 0x5e,
 	0x0d, 0x6a, 0x76, 0x00,
-	0x00, 0x51, 0x08, 0x46,
+	0x00, 0x51, 0x12, 0x46,
 	0x01, 0x65, 0xa4, 0x30,
 	0xe0, 0x6a, 0xcc, 0x00,
-	0x48, 0x6a, 0xfc, 0x5d,
+	0x48, 0x6a, 0x06, 0x5e,
 	0x01, 0x6a, 0xd0, 0x01,
 	0x01, 0x6a, 0xdc, 0x05,
 	0x88, 0x6a, 0xcc, 0x00,
-	0x48, 0x6a, 0xfc, 0x5d,
-	0x01, 0x6a, 0xd6, 0x5d,
+	0x48, 0x6a, 0x06, 0x5e,
+	0x01, 0x6a, 0xe0, 0x5d,
 	0x01, 0x6a, 0x26, 0x05,
 	0x01, 0x65, 0xd8, 0x31,
 	0x09, 0xee, 0xdc, 0x01,
-	0x80, 0xee, 0xc2, 0x7d,
+	0x80, 0xee, 0xcc, 0x7d,
 	0xff, 0x6a, 0xdc, 0x0d,
 	0x01, 0x65, 0x32, 0x31,
 	0x0a, 0x93, 0x26, 0x01,
-	0x00, 0x65, 0x9e, 0x46,
-	0x81, 0x6a, 0xce, 0x5e,
-	0x01, 0x0c, 0xce, 0x7d,
-	0x04, 0x0c, 0xcc, 0x6d,
+	0x00, 0x65, 0xa8, 0x46,
+	0x81, 0x6a, 0xd8, 0x5e,
+	0x01, 0x0c, 0xd8, 0x7d,
+	0x04, 0x0c, 0xd6, 0x6d,
 	0xe0, 0x03, 0x06, 0x08,
 	0xe0, 0x03, 0x7e, 0x0c,
 	0x01, 0x65, 0x18, 0x31,
@@ -769,7 +774,7 @@ static uint8_t seqprog[] = {
 	0x01, 0x6c, 0xda, 0x34,
 	0x3d, 0x64, 0xa4, 0x28,
 	0x55, 0x64, 0xc8, 0x28,
-	0x00, 0x65, 0xfc, 0x45,
+	0x00, 0x65, 0x06, 0x46,
 	0x2e, 0x64, 0xa4, 0x28,
 	0x66, 0x64, 0xc8, 0x28,
 	0x00, 0x6c, 0xda, 0x18,
@@ -780,63 +785,63 @@ static uint8_t seqprog[] = {
 	0x00, 0x6c, 0xda, 0x24,
 	0x01, 0x65, 0xc8, 0x30,
 	0xe0, 0x6a, 0xcc, 0x00,
-	0x44, 0x6a, 0xf8, 0x5d,
+	0x44, 0x6a, 0x02, 0x5e,
 	0x01, 0x90, 0xe2, 0x31,
-	0x04, 0x3b, 0x1c, 0x7e,
+	0x04, 0x3b, 0x26, 0x7e,
 	0x30, 0x6a, 0xd0, 0x01,
 	0x20, 0x6a, 0xd0, 0x01,
 	0x1d, 0x6a, 0xdc, 0x01,
-	0xdc, 0xee, 0x18, 0x66,
-	0x00, 0x65, 0x34, 0x46,
+	0xdc, 0xee, 0x22, 0x66,
+	0x00, 0x65, 0x3e, 0x46,
 	0x20, 0x6a, 0xd0, 0x01,
 	0x01, 0x6a, 0xdc, 0x01,
 	0x20, 0xa0, 0xd8, 0x31,
 	0x09, 0xee, 0xdc, 0x01,
-	0x80, 0xee, 0x24, 0x7e,
+	0x80, 0xee, 0x2e, 0x7e,
 	0x11, 0x6a, 0xdc, 0x01,
-	0x50, 0xee, 0x28, 0x66,
+	0x50, 0xee, 0x32, 0x66,
 	0x20, 0x6a, 0xd0, 0x01,
 	0x09, 0x6a, 0xdc, 0x01,
-	0x88, 0xee, 0x2e, 0x66,
+	0x88, 0xee, 0x38, 0x66,
 	0x19, 0x6a, 0xdc, 0x01,
-	0xd8, 0xee, 0x32, 0x66,
+	0xd8, 0xee, 0x3c, 0x66,
 	0xff, 0x6a, 0xdc, 0x09,
-	0x18, 0xee, 0x36, 0x6e,
+	0x18, 0xee, 0x40, 0x6e,
 	0xff, 0x6a, 0xd4, 0x0c,
 	0x88, 0x6a, 0xcc, 0x00,
-	0x44, 0x6a, 0xf8, 0x5d,
-	0x20, 0x6a, 0xd6, 0x5d,
+	0x44, 0x6a, 0x02, 0x5e,
+	0x20, 0x6a, 0xe0, 0x5d,
 	0x01, 0x3b, 0x26, 0x31,
-	0x04, 0x3b, 0x50, 0x6e,
+	0x04, 0x3b, 0x5a, 0x6e,
 	0xa0, 0x6a, 0xca, 0x00,
 	0x20, 0x65, 0xc8, 0x18,
-	0x00, 0x65, 0x8e, 0x5e,
-	0x00, 0x65, 0x48, 0x66,
+	0x00, 0x65, 0x98, 0x5e,
+	0x00, 0x65, 0x52, 0x66,
 	0x0a, 0x93, 0x26, 0x01,
-	0x00, 0x65, 0x9e, 0x46,
+	0x00, 0x65, 0xa8, 0x46,
 	0xa0, 0x6a, 0xcc, 0x00,
 	0xff, 0x6a, 0xc8, 0x08,
-	0x20, 0x94, 0x54, 0x6e,
-	0x10, 0x94, 0x56, 0x6e,
-	0x08, 0x94, 0x70, 0x6e,
-	0x08, 0x94, 0x70, 0x6e,
-	0x08, 0x94, 0x70, 0x6e,
+	0x20, 0x94, 0x5e, 0x6e,
+	0x10, 0x94, 0x60, 0x6e,
+	0x08, 0x94, 0x7a, 0x6e,
+	0x08, 0x94, 0x7a, 0x6e,
+	0x08, 0x94, 0x7a, 0x6e,
 	0xff, 0x8c, 0xc8, 0x10,
 	0xc1, 0x64, 0xc8, 0x18,
 	0xf8, 0x64, 0xc8, 0x08,
 	0x01, 0x99, 0xda, 0x30,
-	0x00, 0x66, 0x64, 0x66,
-	0xc0, 0x66, 0xa0, 0x76,
+	0x00, 0x66, 0x6e, 0x66,
+	0xc0, 0x66, 0xaa, 0x76,
 	0x60, 0x66, 0xc8, 0x18,
 	0x3d, 0x64, 0xc8, 0x28,
-	0x00, 0x65, 0x54, 0x46,
+	0x00, 0x65, 0x5e, 0x46,
 	0xf7, 0x93, 0x26, 0x09,
-	0x08, 0x93, 0x72, 0x6e,
+	0x08, 0x93, 0x7c, 0x6e,
 	0x00, 0x62, 0xc4, 0x18,
-	0x00, 0x65, 0x9e, 0x5e,
-	0x00, 0x65, 0x7e, 0x5e,
-	0x00, 0x65, 0x7e, 0x5e,
-	0x00, 0x65, 0x7e, 0x5e,
+	0x00, 0x65, 0xa8, 0x5e,
+	0x00, 0x65, 0x88, 0x5e,
+	0x00, 0x65, 0x88, 0x5e,
+	0x00, 0x65, 0x88, 0x5e,
 	0x01, 0x99, 0xda, 0x30,
 	0x01, 0x99, 0xda, 0x30,
 	0x01, 0x99, 0xda, 0x30,
@@ -853,11 +858,11 @@ static uint8_t seqprog[] = {
 	0x01, 0x6c, 0x32, 0x31,
 	0x01, 0x6c, 0x32, 0x31,
 	0x01, 0x6c, 0x32, 0x35,
-	0x08, 0x94, 0x9e, 0x7e,
+	0x08, 0x94, 0xa8, 0x7e,
 	0xf7, 0x93, 0x26, 0x09,
-	0x08, 0x93, 0xa2, 0x6e,
+	0x08, 0x93, 0xac, 0x6e,
 	0xff, 0x6a, 0xd4, 0x0c,
-	0x04, 0xb8, 0xca, 0x6e,
+	0x04, 0xb8, 0xd4, 0x6e,
 	0x01, 0x42, 0x7e, 0x31,
 	0xff, 0x6a, 0x76, 0x01,
 	0x01, 0x90, 0x84, 0x34,
@@ -865,14 +870,14 @@ static uint8_t seqprog[] = {
 	0x01, 0x85, 0x0a, 0x01,
 	0x7f, 0x65, 0x10, 0x09,
 	0xfe, 0x85, 0x0a, 0x0d,
-	0xff, 0x42, 0xc6, 0x66,
-	0xff, 0x41, 0xbe, 0x66,
-	0xd1, 0x6a, 0xce, 0x5e,
+	0xff, 0x42, 0xd0, 0x66,
+	0xff, 0x41, 0xc8, 0x66,
+	0xd1, 0x6a, 0xd8, 0x5e,
 	0xff, 0x6a, 0xca, 0x04,
 	0x01, 0x41, 0x20, 0x31,
 	0x01, 0xbf, 0x82, 0x30,
 	0x01, 0x6a, 0x76, 0x00,
-	0x00, 0xbb, 0x08, 0x46,
+	0x00, 0xbb, 0x12, 0x46,
 	0x01, 0x42, 0x20, 0x31,
 	0x01, 0xbf, 0x84, 0x34,
 	0x01, 0x41, 0x7e, 0x31,
@@ -882,420 +887,421 @@ static uint8_t seqprog[] = {
 	0xff, 0x6a, 0xd4, 0x0c
 };
 
-static int aic_patch23_func(struct ahc_softc *ahc);
+typedef int ahc_patch_func_t (struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch23_func;
 
 static int
-aic_patch23_func(struct ahc_softc *ahc)
+ahc_patch23_func(struct ahc_softc *ahc)
 {
 	return ((ahc->bugs & AHC_SCBCHAN_UPLOAD_BUG) != 0);
 }
 
-static int aic_patch22_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch22_func;
 
 static int
-aic_patch22_func(struct ahc_softc *ahc)
+ahc_patch22_func(struct ahc_softc *ahc)
 {
 	return ((ahc->features & AHC_CMD_CHAN) == 0);
 }
 
-static int aic_patch21_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch21_func;
 
 static int
-aic_patch21_func(struct ahc_softc *ahc)
+ahc_patch21_func(struct ahc_softc *ahc)
 {
 	return ((ahc->features & AHC_QUEUE_REGS) == 0);
 }
 
-static int aic_patch20_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch20_func;
 
 static int
-aic_patch20_func(struct ahc_softc *ahc)
+ahc_patch20_func(struct ahc_softc *ahc)
 {
 	return ((ahc->features & AHC_WIDE) != 0);
 }
 
-static int aic_patch19_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch19_func;
 
 static int
-aic_patch19_func(struct ahc_softc *ahc)
+ahc_patch19_func(struct ahc_softc *ahc)
 {
 	return ((ahc->flags & AHC_SCB_BTT) != 0);
 }
 
-static int aic_patch18_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch18_func;
 
 static int
-aic_patch18_func(struct ahc_softc *ahc)
+ahc_patch18_func(struct ahc_softc *ahc)
 {
 	return ((ahc->bugs & AHC_PCI_2_1_RETRY_BUG) != 0);
 }
 
-static int aic_patch17_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch17_func;
 
 static int
-aic_patch17_func(struct ahc_softc *ahc)
+ahc_patch17_func(struct ahc_softc *ahc)
 {
 	return ((ahc->flags & AHC_TMODE_WIDEODD_BUG) != 0);
 }
 
-static int aic_patch16_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch16_func;
 
 static int
-aic_patch16_func(struct ahc_softc *ahc)
+ahc_patch16_func(struct ahc_softc *ahc)
 {
 	return ((ahc->bugs & AHC_AUTOFLUSH_BUG) != 0);
 }
 
-static int aic_patch15_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch15_func;
 
 static int
-aic_patch15_func(struct ahc_softc *ahc)
+ahc_patch15_func(struct ahc_softc *ahc)
 {
 	return ((ahc->features & AHC_ULTRA2) == 0);
 }
 
-static int aic_patch14_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch14_func;
 
 static int
-aic_patch14_func(struct ahc_softc *ahc)
+ahc_patch14_func(struct ahc_softc *ahc)
 {
 	return ((ahc->bugs & AHC_PCI_MWI_BUG) != 0 && ahc->pci_cachesize != 0);
 }
 
-static int aic_patch13_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch13_func;
 
 static int
-aic_patch13_func(struct ahc_softc *ahc)
+ahc_patch13_func(struct ahc_softc *ahc)
 {
 	return ((ahc->flags & AHC_39BIT_ADDRESSING) != 0);
 }
 
-static int aic_patch12_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch12_func;
 
 static int
-aic_patch12_func(struct ahc_softc *ahc)
+ahc_patch12_func(struct ahc_softc *ahc)
 {
 	return ((ahc->features & AHC_HS_MAILBOX) != 0);
 }
 
-static int aic_patch11_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch11_func;
 
 static int
-aic_patch11_func(struct ahc_softc *ahc)
+ahc_patch11_func(struct ahc_softc *ahc)
 {
 	return ((ahc->features & AHC_ULTRA) != 0);
 }
 
-static int aic_patch10_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch10_func;
 
 static int
-aic_patch10_func(struct ahc_softc *ahc)
+ahc_patch10_func(struct ahc_softc *ahc)
 {
 	return ((ahc->features & AHC_MULTI_TID) != 0);
 }
 
-static int aic_patch9_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch9_func;
 
 static int
-aic_patch9_func(struct ahc_softc *ahc)
+ahc_patch9_func(struct ahc_softc *ahc)
 {
 	return ((ahc->features & AHC_CMD_CHAN) != 0);
 }
 
-static int aic_patch8_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch8_func;
 
 static int
-aic_patch8_func(struct ahc_softc *ahc)
+ahc_patch8_func(struct ahc_softc *ahc)
 {
 	return ((ahc->flags & AHC_INITIATORROLE) != 0);
 }
 
-static int aic_patch7_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch7_func;
 
 static int
-aic_patch7_func(struct ahc_softc *ahc)
+ahc_patch7_func(struct ahc_softc *ahc)
 {
 	return ((ahc->flags & AHC_TARGETROLE) != 0);
 }
 
-static int aic_patch6_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch6_func;
 
 static int
-aic_patch6_func(struct ahc_softc *ahc)
+ahc_patch6_func(struct ahc_softc *ahc)
 {
 	return ((ahc->features & AHC_DT) == 0);
 }
 
-static int aic_patch5_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch5_func;
 
 static int
-aic_patch5_func(struct ahc_softc *ahc)
+ahc_patch5_func(struct ahc_softc *ahc)
 {
 	return ((ahc->flags & AHC_SEQUENCER_DEBUG) != 0);
 }
 
-static int aic_patch4_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch4_func;
 
 static int
-aic_patch4_func(struct ahc_softc *ahc)
+ahc_patch4_func(struct ahc_softc *ahc)
 {
 	return ((ahc->flags & AHC_PAGESCBS) != 0);
 }
 
-static int aic_patch3_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch3_func;
 
 static int
-aic_patch3_func(struct ahc_softc *ahc)
+ahc_patch3_func(struct ahc_softc *ahc)
 {
 	return ((ahc->features & AHC_QUEUE_REGS) != 0);
 }
 
-static int aic_patch2_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch2_func;
 
 static int
-aic_patch2_func(struct ahc_softc *ahc)
+ahc_patch2_func(struct ahc_softc *ahc)
 {
 	return ((ahc->features & AHC_TWIN) != 0);
 }
 
-static int aic_patch1_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch1_func;
 
 static int
-aic_patch1_func(struct ahc_softc *ahc)
+ahc_patch1_func(struct ahc_softc *ahc)
 {
 	return ((ahc->features & AHC_ULTRA2) != 0);
 }
 
-static int aic_patch0_func(struct ahc_softc *ahc);
+static ahc_patch_func_t ahc_patch0_func;
 
 static int
-aic_patch0_func(struct ahc_softc *ahc)
+ahc_patch0_func(struct ahc_softc *ahc)
 {
 	return (0);
 }
 
-typedef int patch_func_t (struct ahc_softc *ahc);
 static struct patch {
-	patch_func_t	*patch_func;
-	uint32_t	begin	   :10,
-			skip_instr :10,
-			skip_patch :12;
+	ahc_patch_func_t		*patch_func;
+	uint32_t		 begin		:10,
+				 skip_instr	:10,
+				 skip_patch	:12;
 } patches[] = {
-	{ aic_patch1_func, 4, 1, 1 },
-	{ aic_patch2_func, 6, 2, 1 },
-	{ aic_patch2_func, 9, 1, 1 },
-	{ aic_patch3_func, 11, 1, 2 },
-	{ aic_patch0_func, 12, 2, 1 },
-	{ aic_patch4_func, 15, 1, 2 },
-	{ aic_patch0_func, 16, 1, 1 },
-	{ aic_patch5_func, 22, 2, 1 },
-	{ aic_patch3_func, 27, 1, 2 },
-	{ aic_patch0_func, 28, 1, 1 },
-	{ aic_patch6_func, 34, 1, 1 },
-	{ aic_patch7_func, 37, 54, 19 },
-	{ aic_patch8_func, 37, 1, 1 },
-	{ aic_patch9_func, 42, 3, 2 },
-	{ aic_patch0_func, 45, 3, 1 },
-	{ aic_patch10_func, 49, 1, 2 },
-	{ aic_patch0_func, 50, 2, 3 },
-	{ aic_patch1_func, 50, 1, 2 },
-	{ aic_patch0_func, 51, 1, 1 },
-	{ aic_patch2_func, 53, 2, 1 },
-	{ aic_patch9_func, 55, 1, 2 },
-	{ aic_patch0_func, 56, 1, 1 },
-	{ aic_patch9_func, 60, 1, 2 },
-	{ aic_patch0_func, 61, 1, 1 },
-	{ aic_patch9_func, 71, 1, 2 },
-	{ aic_patch0_func, 72, 1, 1 },
-	{ aic_patch9_func, 75, 1, 2 },
-	{ aic_patch0_func, 76, 1, 1 },
-	{ aic_patch9_func, 79, 1, 2 },
-	{ aic_patch0_func, 80, 1, 1 },
-	{ aic_patch8_func, 91, 9, 4 },
-	{ aic_patch1_func, 93, 1, 2 },
-	{ aic_patch0_func, 94, 1, 1 },
-	{ aic_patch2_func, 96, 2, 1 },
-	{ aic_patch2_func, 105, 4, 1 },
-	{ aic_patch1_func, 109, 1, 2 },
-	{ aic_patch0_func, 110, 2, 3 },
-	{ aic_patch2_func, 110, 1, 2 },
-	{ aic_patch0_func, 111, 1, 1 },
-	{ aic_patch7_func, 112, 4, 2 },
-	{ aic_patch0_func, 116, 1, 1 },
-	{ aic_patch11_func, 118, 2, 1 },
-	{ aic_patch1_func, 120, 1, 2 },
-	{ aic_patch0_func, 121, 1, 1 },
-	{ aic_patch7_func, 122, 4, 1 },
-	{ aic_patch7_func, 132, 91, 11 },
-	{ aic_patch4_func, 151, 1, 1 },
-	{ aic_patch1_func, 165, 1, 1 },
-	{ aic_patch12_func, 170, 1, 2 },
-	{ aic_patch0_func, 171, 1, 1 },
-	{ aic_patch9_func, 182, 1, 2 },
-	{ aic_patch0_func, 183, 1, 1 },
-	{ aic_patch9_func, 192, 1, 2 },
-	{ aic_patch0_func, 193, 1, 1 },
-	{ aic_patch9_func, 209, 6, 2 },
-	{ aic_patch0_func, 215, 6, 1 },
-	{ aic_patch8_func, 223, 19, 2 },
-	{ aic_patch1_func, 237, 1, 1 },
-	{ aic_patch1_func, 244, 1, 2 },
-	{ aic_patch0_func, 245, 2, 2 },
-	{ aic_patch11_func, 246, 1, 1 },
-	{ aic_patch9_func, 254, 31, 3 },
-	{ aic_patch1_func, 270, 14, 2 },
-	{ aic_patch13_func, 275, 1, 1 },
-	{ aic_patch14_func, 285, 14, 1 },
-	{ aic_patch1_func, 301, 1, 2 },
-	{ aic_patch0_func, 302, 1, 1 },
-	{ aic_patch9_func, 305, 1, 1 },
-	{ aic_patch13_func, 310, 1, 1 },
-	{ aic_patch9_func, 311, 2, 2 },
-	{ aic_patch0_func, 313, 4, 1 },
-	{ aic_patch14_func, 317, 1, 1 },
-	{ aic_patch15_func, 320, 2, 3 },
-	{ aic_patch9_func, 320, 1, 2 },
-	{ aic_patch0_func, 321, 1, 1 },
-	{ aic_patch6_func, 326, 1, 2 },
-	{ aic_patch0_func, 327, 1, 1 },
-	{ aic_patch1_func, 331, 50, 11 },
-	{ aic_patch6_func, 340, 2, 4 },
-	{ aic_patch7_func, 340, 1, 1 },
-	{ aic_patch8_func, 341, 1, 1 },
-	{ aic_patch0_func, 342, 1, 1 },
-	{ aic_patch16_func, 343, 1, 1 },
-	{ aic_patch6_func, 362, 6, 3 },
-	{ aic_patch16_func, 362, 5, 1 },
-	{ aic_patch0_func, 368, 5, 1 },
-	{ aic_patch13_func, 376, 5, 1 },
-	{ aic_patch0_func, 381, 54, 17 },
-	{ aic_patch14_func, 381, 1, 1 },
-	{ aic_patch7_func, 383, 2, 2 },
-	{ aic_patch17_func, 384, 1, 1 },
-	{ aic_patch9_func, 387, 1, 1 },
-	{ aic_patch18_func, 394, 1, 1 },
-	{ aic_patch14_func, 399, 9, 3 },
-	{ aic_patch9_func, 400, 3, 2 },
-	{ aic_patch0_func, 403, 3, 1 },
-	{ aic_patch9_func, 411, 6, 2 },
-	{ aic_patch0_func, 417, 9, 2 },
-	{ aic_patch13_func, 417, 1, 1 },
-	{ aic_patch13_func, 426, 2, 1 },
-	{ aic_patch14_func, 428, 1, 1 },
-	{ aic_patch9_func, 430, 1, 2 },
-	{ aic_patch0_func, 431, 1, 1 },
-	{ aic_patch7_func, 434, 1, 1 },
-	{ aic_patch7_func, 435, 1, 1 },
-	{ aic_patch8_func, 436, 3, 3 },
-	{ aic_patch6_func, 437, 1, 2 },
-	{ aic_patch0_func, 438, 1, 1 },
-	{ aic_patch9_func, 439, 1, 1 },
-	{ aic_patch15_func, 440, 1, 2 },
-	{ aic_patch13_func, 440, 1, 1 },
-	{ aic_patch14_func, 442, 9, 4 },
-	{ aic_patch9_func, 442, 1, 1 },
-	{ aic_patch9_func, 449, 2, 1 },
-	{ aic_patch0_func, 451, 4, 3 },
-	{ aic_patch9_func, 451, 1, 2 },
-	{ aic_patch0_func, 452, 3, 1 },
-	{ aic_patch1_func, 456, 2, 1 },
-	{ aic_patch7_func, 458, 10, 2 },
-	{ aic_patch0_func, 468, 1, 1 },
-	{ aic_patch8_func, 469, 109, 23 },
-	{ aic_patch1_func, 471, 3, 2 },
-	{ aic_patch0_func, 474, 5, 3 },
-	{ aic_patch9_func, 474, 2, 2 },
-	{ aic_patch0_func, 476, 3, 1 },
-	{ aic_patch1_func, 481, 2, 2 },
-	{ aic_patch0_func, 483, 6, 3 },
-	{ aic_patch9_func, 483, 2, 2 },
-	{ aic_patch0_func, 485, 3, 1 },
-	{ aic_patch1_func, 491, 2, 2 },
-	{ aic_patch0_func, 493, 9, 7 },
-	{ aic_patch9_func, 493, 5, 6 },
-	{ aic_patch19_func, 493, 1, 2 },
-	{ aic_patch0_func, 494, 1, 1 },
-	{ aic_patch19_func, 496, 1, 2 },
-	{ aic_patch0_func, 497, 1, 1 },
-	{ aic_patch0_func, 498, 4, 1 },
-	{ aic_patch6_func, 502, 3, 2 },
-	{ aic_patch0_func, 505, 1, 1 },
-	{ aic_patch1_func, 508, 1, 1 },
-	{ aic_patch6_func, 514, 1, 2 },
-	{ aic_patch0_func, 515, 1, 1 },
-	{ aic_patch20_func, 552, 7, 1 },
-	{ aic_patch3_func, 580, 1, 2 },
-	{ aic_patch0_func, 581, 1, 1 },
-	{ aic_patch21_func, 584, 1, 1 },
-	{ aic_patch8_func, 586, 104, 33 },
-	{ aic_patch4_func, 587, 1, 1 },
-	{ aic_patch1_func, 593, 2, 2 },
-	{ aic_patch0_func, 595, 1, 1 },
-	{ aic_patch1_func, 598, 1, 2 },
-	{ aic_patch0_func, 599, 1, 1 },
-	{ aic_patch9_func, 600, 3, 3 },
-	{ aic_patch15_func, 601, 1, 1 },
-	{ aic_patch0_func, 603, 4, 1 },
-	{ aic_patch19_func, 611, 2, 2 },
-	{ aic_patch0_func, 613, 1, 1 },
-	{ aic_patch19_func, 617, 10, 3 },
-	{ aic_patch5_func, 619, 8, 1 },
-	{ aic_patch0_func, 627, 9, 2 },
-	{ aic_patch5_func, 628, 8, 1 },
-	{ aic_patch4_func, 638, 1, 2 },
-	{ aic_patch0_func, 639, 1, 1 },
-	{ aic_patch19_func, 640, 1, 2 },
-	{ aic_patch0_func, 641, 3, 2 },
-	{ aic_patch4_func, 643, 1, 1 },
-	{ aic_patch5_func, 644, 1, 1 },
-	{ aic_patch5_func, 647, 1, 1 },
-	{ aic_patch5_func, 649, 1, 1 },
-	{ aic_patch4_func, 651, 2, 2 },
-	{ aic_patch0_func, 653, 2, 1 },
-	{ aic_patch5_func, 655, 1, 1 },
-	{ aic_patch5_func, 658, 1, 1 },
-	{ aic_patch5_func, 661, 1, 1 },
-	{ aic_patch19_func, 665, 1, 1 },
-	{ aic_patch19_func, 668, 1, 1 },
-	{ aic_patch4_func, 674, 1, 1 },
-	{ aic_patch6_func, 677, 1, 2 },
-	{ aic_patch0_func, 678, 1, 1 },
-	{ aic_patch7_func, 690, 16, 1 },
-	{ aic_patch4_func, 706, 20, 1 },
-	{ aic_patch9_func, 727, 4, 2 },
-	{ aic_patch0_func, 731, 4, 1 },
-	{ aic_patch9_func, 735, 4, 2 },
-	{ aic_patch0_func, 739, 3, 1 },
-	{ aic_patch6_func, 745, 1, 1 },
-	{ aic_patch22_func, 747, 14, 1 },
-	{ aic_patch7_func, 761, 3, 1 },
-	{ aic_patch9_func, 773, 24, 8 },
-	{ aic_patch19_func, 777, 1, 2 },
-	{ aic_patch0_func, 778, 1, 1 },
-	{ aic_patch15_func, 783, 4, 2 },
-	{ aic_patch0_func, 787, 7, 3 },
-	{ aic_patch23_func, 787, 5, 2 },
-	{ aic_patch0_func, 792, 2, 1 },
-	{ aic_patch0_func, 797, 42, 3 },
-	{ aic_patch18_func, 809, 18, 2 },
-	{ aic_patch0_func, 827, 1, 1 },
-	{ aic_patch4_func, 851, 1, 1 },
-	{ aic_patch4_func, 852, 3, 2 },
-	{ aic_patch0_func, 855, 1, 1 },
-	{ aic_patch13_func, 856, 3, 1 },
-	{ aic_patch4_func, 859, 12, 1 }
+	{ ahc_patch1_func, 4, 1, 1 },
+	{ ahc_patch2_func, 6, 2, 1 },
+	{ ahc_patch2_func, 9, 1, 1 },
+	{ ahc_patch3_func, 11, 1, 2 },
+	{ ahc_patch0_func, 12, 2, 1 },
+	{ ahc_patch4_func, 15, 1, 2 },
+	{ ahc_patch0_func, 16, 1, 1 },
+	{ ahc_patch5_func, 22, 2, 1 },
+	{ ahc_patch3_func, 27, 1, 2 },
+	{ ahc_patch0_func, 28, 1, 1 },
+	{ ahc_patch6_func, 34, 1, 1 },
+	{ ahc_patch7_func, 37, 54, 19 },
+	{ ahc_patch8_func, 37, 1, 1 },
+	{ ahc_patch9_func, 42, 3, 2 },
+	{ ahc_patch0_func, 45, 3, 1 },
+	{ ahc_patch10_func, 49, 1, 2 },
+	{ ahc_patch0_func, 50, 2, 3 },
+	{ ahc_patch1_func, 50, 1, 2 },
+	{ ahc_patch0_func, 51, 1, 1 },
+	{ ahc_patch2_func, 53, 2, 1 },
+	{ ahc_patch9_func, 55, 1, 2 },
+	{ ahc_patch0_func, 56, 1, 1 },
+	{ ahc_patch9_func, 60, 1, 2 },
+	{ ahc_patch0_func, 61, 1, 1 },
+	{ ahc_patch9_func, 71, 1, 2 },
+	{ ahc_patch0_func, 72, 1, 1 },
+	{ ahc_patch9_func, 75, 1, 2 },
+	{ ahc_patch0_func, 76, 1, 1 },
+	{ ahc_patch9_func, 79, 1, 2 },
+	{ ahc_patch0_func, 80, 1, 1 },
+	{ ahc_patch8_func, 91, 9, 4 },
+	{ ahc_patch1_func, 93, 1, 2 },
+	{ ahc_patch0_func, 94, 1, 1 },
+	{ ahc_patch2_func, 96, 2, 1 },
+	{ ahc_patch2_func, 105, 4, 1 },
+	{ ahc_patch1_func, 109, 1, 2 },
+	{ ahc_patch0_func, 110, 2, 3 },
+	{ ahc_patch2_func, 110, 1, 2 },
+	{ ahc_patch0_func, 111, 1, 1 },
+	{ ahc_patch7_func, 112, 4, 2 },
+	{ ahc_patch0_func, 116, 1, 1 },
+	{ ahc_patch11_func, 117, 2, 1 },
+	{ ahc_patch1_func, 119, 1, 2 },
+	{ ahc_patch0_func, 120, 1, 1 },
+	{ ahc_patch7_func, 121, 4, 1 },
+	{ ahc_patch7_func, 131, 95, 11 },
+	{ ahc_patch4_func, 151, 1, 1 },
+	{ ahc_patch1_func, 168, 1, 1 },
+	{ ahc_patch12_func, 173, 1, 2 },
+	{ ahc_patch0_func, 174, 1, 1 },
+	{ ahc_patch9_func, 185, 1, 2 },
+	{ ahc_patch0_func, 186, 1, 1 },
+	{ ahc_patch9_func, 195, 1, 2 },
+	{ ahc_patch0_func, 196, 1, 1 },
+	{ ahc_patch9_func, 212, 6, 2 },
+	{ ahc_patch0_func, 218, 6, 1 },
+	{ ahc_patch8_func, 226, 20, 2 },
+	{ ahc_patch1_func, 241, 1, 1 },
+	{ ahc_patch1_func, 248, 1, 2 },
+	{ ahc_patch0_func, 249, 2, 2 },
+	{ ahc_patch11_func, 250, 1, 1 },
+	{ ahc_patch9_func, 258, 27, 3 },
+	{ ahc_patch1_func, 274, 10, 2 },
+	{ ahc_patch13_func, 277, 1, 1 },
+	{ ahc_patch14_func, 285, 14, 1 },
+	{ ahc_patch1_func, 301, 1, 2 },
+	{ ahc_patch0_func, 302, 1, 1 },
+	{ ahc_patch9_func, 305, 1, 1 },
+	{ ahc_patch13_func, 310, 1, 1 },
+	{ ahc_patch9_func, 311, 2, 2 },
+	{ ahc_patch0_func, 313, 4, 1 },
+	{ ahc_patch14_func, 317, 1, 1 },
+	{ ahc_patch15_func, 319, 2, 3 },
+	{ ahc_patch9_func, 319, 1, 2 },
+	{ ahc_patch0_func, 320, 1, 1 },
+	{ ahc_patch6_func, 325, 1, 2 },
+	{ ahc_patch0_func, 326, 1, 1 },
+	{ ahc_patch1_func, 330, 47, 11 },
+	{ ahc_patch6_func, 337, 2, 4 },
+	{ ahc_patch7_func, 337, 1, 1 },
+	{ ahc_patch8_func, 338, 1, 1 },
+	{ ahc_patch0_func, 339, 1, 1 },
+	{ ahc_patch16_func, 340, 1, 1 },
+	{ ahc_patch6_func, 356, 6, 3 },
+	{ ahc_patch16_func, 356, 5, 1 },
+	{ ahc_patch0_func, 362, 7, 1 },
+	{ ahc_patch13_func, 372, 5, 1 },
+	{ ahc_patch0_func, 377, 52, 17 },
+	{ ahc_patch14_func, 377, 1, 1 },
+	{ ahc_patch7_func, 379, 2, 2 },
+	{ ahc_patch17_func, 380, 1, 1 },
+	{ ahc_patch9_func, 383, 1, 1 },
+	{ ahc_patch18_func, 390, 1, 1 },
+	{ ahc_patch14_func, 395, 9, 3 },
+	{ ahc_patch9_func, 396, 3, 2 },
+	{ ahc_patch0_func, 399, 3, 1 },
+	{ ahc_patch9_func, 407, 6, 2 },
+	{ ahc_patch0_func, 413, 9, 2 },
+	{ ahc_patch13_func, 413, 1, 1 },
+	{ ahc_patch13_func, 422, 2, 1 },
+	{ ahc_patch14_func, 424, 1, 1 },
+	{ ahc_patch9_func, 426, 1, 2 },
+	{ ahc_patch0_func, 427, 1, 1 },
+	{ ahc_patch7_func, 428, 1, 1 },
+	{ ahc_patch7_func, 429, 1, 1 },
+	{ ahc_patch8_func, 430, 3, 3 },
+	{ ahc_patch6_func, 431, 1, 2 },
+	{ ahc_patch0_func, 432, 1, 1 },
+	{ ahc_patch9_func, 433, 1, 1 },
+	{ ahc_patch15_func, 434, 1, 2 },
+	{ ahc_patch13_func, 434, 1, 1 },
+	{ ahc_patch14_func, 436, 9, 4 },
+	{ ahc_patch9_func, 436, 1, 1 },
+	{ ahc_patch9_func, 443, 2, 1 },
+	{ ahc_patch0_func, 445, 4, 3 },
+	{ ahc_patch9_func, 445, 1, 2 },
+	{ ahc_patch0_func, 446, 3, 1 },
+	{ ahc_patch1_func, 450, 2, 1 },
+	{ ahc_patch7_func, 452, 10, 2 },
+	{ ahc_patch0_func, 462, 1, 1 },
+	{ ahc_patch8_func, 463, 118, 22 },
+	{ ahc_patch1_func, 465, 3, 2 },
+	{ ahc_patch0_func, 468, 5, 3 },
+	{ ahc_patch9_func, 468, 2, 2 },
+	{ ahc_patch0_func, 470, 3, 1 },
+	{ ahc_patch1_func, 475, 2, 2 },
+	{ ahc_patch0_func, 477, 6, 3 },
+	{ ahc_patch9_func, 477, 2, 2 },
+	{ ahc_patch0_func, 479, 3, 1 },
+	{ ahc_patch1_func, 485, 2, 2 },
+	{ ahc_patch0_func, 487, 9, 7 },
+	{ ahc_patch9_func, 487, 5, 6 },
+	{ ahc_patch19_func, 487, 1, 2 },
+	{ ahc_patch0_func, 488, 1, 1 },
+	{ ahc_patch19_func, 490, 1, 2 },
+	{ ahc_patch0_func, 491, 1, 1 },
+	{ ahc_patch0_func, 492, 4, 1 },
+	{ ahc_patch6_func, 497, 3, 2 },
+	{ ahc_patch0_func, 500, 1, 1 },
+	{ ahc_patch6_func, 510, 1, 2 },
+	{ ahc_patch0_func, 511, 1, 1 },
+	{ ahc_patch20_func, 548, 7, 1 },
+	{ ahc_patch3_func, 583, 1, 2 },
+	{ ahc_patch0_func, 584, 1, 1 },
+	{ ahc_patch21_func, 587, 1, 1 },
+	{ ahc_patch8_func, 589, 106, 33 },
+	{ ahc_patch4_func, 591, 1, 1 },
+	{ ahc_patch1_func, 597, 2, 2 },
+	{ ahc_patch0_func, 599, 1, 1 },
+	{ ahc_patch1_func, 602, 1, 2 },
+	{ ahc_patch0_func, 603, 1, 1 },
+	{ ahc_patch9_func, 604, 3, 3 },
+	{ ahc_patch15_func, 605, 1, 1 },
+	{ ahc_patch0_func, 607, 4, 1 },
+	{ ahc_patch19_func, 616, 2, 2 },
+	{ ahc_patch0_func, 618, 1, 1 },
+	{ ahc_patch19_func, 622, 10, 3 },
+	{ ahc_patch5_func, 624, 8, 1 },
+	{ ahc_patch0_func, 632, 9, 2 },
+	{ ahc_patch5_func, 633, 8, 1 },
+	{ ahc_patch4_func, 643, 1, 2 },
+	{ ahc_patch0_func, 644, 1, 1 },
+	{ ahc_patch19_func, 645, 1, 2 },
+	{ ahc_patch0_func, 646, 3, 2 },
+	{ ahc_patch4_func, 648, 1, 1 },
+	{ ahc_patch5_func, 649, 1, 1 },
+	{ ahc_patch5_func, 652, 1, 1 },
+	{ ahc_patch5_func, 654, 1, 1 },
+	{ ahc_patch4_func, 656, 2, 2 },
+	{ ahc_patch0_func, 658, 2, 1 },
+	{ ahc_patch5_func, 660, 1, 1 },
+	{ ahc_patch5_func, 663, 1, 1 },
+	{ ahc_patch5_func, 666, 1, 1 },
+	{ ahc_patch19_func, 670, 1, 1 },
+	{ ahc_patch19_func, 673, 1, 1 },
+	{ ahc_patch4_func, 679, 1, 1 },
+	{ ahc_patch6_func, 682, 1, 2 },
+	{ ahc_patch0_func, 683, 1, 1 },
+	{ ahc_patch7_func, 695, 16, 1 },
+	{ ahc_patch4_func, 711, 20, 1 },
+	{ ahc_patch9_func, 732, 4, 2 },
+	{ ahc_patch0_func, 736, 4, 1 },
+	{ ahc_patch9_func, 740, 4, 2 },
+	{ ahc_patch0_func, 744, 3, 1 },
+	{ ahc_patch6_func, 750, 1, 1 },
+	{ ahc_patch22_func, 752, 14, 1 },
+	{ ahc_patch7_func, 766, 3, 1 },
+	{ ahc_patch9_func, 778, 24, 8 },
+	{ ahc_patch19_func, 782, 1, 2 },
+	{ ahc_patch0_func, 783, 1, 1 },
+	{ ahc_patch15_func, 788, 4, 2 },
+	{ ahc_patch0_func, 792, 7, 3 },
+	{ ahc_patch23_func, 792, 5, 2 },
+	{ ahc_patch0_func, 797, 2, 1 },
+	{ ahc_patch0_func, 802, 42, 3 },
+	{ ahc_patch18_func, 814, 18, 2 },
+	{ ahc_patch0_func, 832, 1, 1 },
+	{ ahc_patch4_func, 856, 1, 1 },
+	{ ahc_patch4_func, 857, 3, 2 },
+	{ ahc_patch0_func, 860, 1, 1 },
+	{ ahc_patch13_func, 861, 3, 1 },
+	{ ahc_patch4_func, 864, 12, 1 }
 };
+
 static struct cs {
-	u_int16_t	begin;
-	u_int16_t	end;
+	uint16_t	begin;
+	uint16_t	end;
 } critical_sections[] = {
 	{ 11, 18 },
 	{ 21, 30 },
-	{ 706, 722 },
-	{ 852, 855 },
-	{ 859, 865 },
-	{ 867, 869 },
-	{ 869, 871 }
+	{ 711, 727 },
+	{ 857, 860 },
+	{ 864, 870 },
+	{ 872, 874 },
+	{ 874, 876 }
 };
+
 static const int num_critical_sections = sizeof(critical_sections)
 				       / sizeof(*critical_sections);
diff -urNp linux-5720/drivers/scsi/aic7xxx/aicasm/Makefile linux-5730/drivers/scsi/aic7xxx/aicasm/Makefile
--- linux-5720/drivers/scsi/aic7xxx/aicasm/Makefile
+++ linux-5730/drivers/scsi/aic7xxx/aicasm/Makefile
@@ -10,9 +10,10 @@ GENHDRS=	aicdb.h $(YSRCS:.y=.h)
 GENSRCS=	$(YSRCS:.y=.c) $(LSRCS:.l=.c)
 
 SRCS=	${CSRCS} ${GENSRCS}
-CLEANFILES= ${GENSRCS} ${GENHDRS} $(YSRCS:.y=.output)
+LIBS=	-ldb
+clean-files:= ${GENSRCS} ${GENHDRS} $(YSRCS:.y=.output) $(PROG)
 # Override default kernel CFLAGS.  This is a userland app.
-AICASM_CFLAGS:= -I/usr/include -I. -ldb
+AICASM_CFLAGS:= -I/usr/include -I.
 YFLAGS= -d
 
 NOMAN=	noman
@@ -30,7 +31,7 @@ LFLAGS= -d
 endif
 
 $(PROG):  ${GENHDRS} $(SRCS)
-	$(AICASM_CC) $(AICASM_CFLAGS) $(SRCS) -o $(PROG)
+	$(AICASM_CC) $(AICASM_CFLAGS) $(SRCS) -o $(PROG) $(LIBS)
 
 aicdb.h:
 	@if [ -e "/usr/include/db3/db_185.h" ]; then		\
@@ -46,7 +47,7 @@ aicdb.h:
 	 fi
 
 clean:
-	rm -f $(CLEANFILES) $(PROG)
+	rm -f $(clean-files)
 
 aicasm_gram.c aicasm_gram.h: aicasm_gram.y
 	$(YACC) $(YFLAGS) -b $(<:.y=) $<
diff -urNp linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm.c linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm.c
--- linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm.c
+++ linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm.c
@@ -2,7 +2,7 @@
  * Aic7xxx SCSI host adapter firmware asssembler
  *
  * Copyright (c) 1997, 1998, 2000, 2001 Justin T. Gibbs.
- * Copyright (c) 2001 Adaptec Inc.
+ * Copyright (c) 2001, 2002 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -37,9 +37,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#16 $
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm.c#22 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm.c,v 1.28.2.5 2002/04/29 19:36:36 gibbs Exp $
+ * $FreeBSD$
  */
 #include <sys/types.h>
 #include <sys/mman.h>
@@ -85,12 +85,15 @@ static int check_patch(patch_t **start_p
 struct path_list search_path;
 int includes_search_curdir;
 char *appname;
+char *stock_include_file;
 FILE *ofile;
 char *ofilename;
 char *regfilename;
 FILE *regfile;
 char *listfilename;
 FILE *listfile;
+char *regdiagfilename;
+FILE *regdiagfile;
 int   src_mode;
 int   dst_mode;
 
@@ -140,7 +143,7 @@ main(int argc, char *argv[])
 	yydebug = 0;
 	mmdebug = 0;
 #endif
-	while ((ch = getopt(argc, argv, "d:l:n:o:r:I:O:")) != -1) {
+	while ((ch = getopt(argc, argv, "d:i:l:n:o:p:r:I:")) != -1) {
 		switch(ch) {
 		case 'd':
 #if DEBUG
@@ -160,6 +163,9 @@ main(int argc, char *argv[])
 			     "information", EX_SOFTWARE);
 #endif
 			break;
+		case 'i':
+			stock_include_file = optarg;
+			break;
 		case 'l':
 			/* Create a program listing */
 			if ((listfile = fopen(optarg, "w")) == NULL) {
@@ -184,6 +190,14 @@ main(int argc, char *argv[])
 			}
 			ofilename = optarg;
 			break;
+		case 'p':
+			/* Create Register Diagnostic "printing" Functions */
+			if ((regdiagfile = fopen(optarg, "w")) == NULL) {
+				perror(optarg);
+				stop(NULL, EX_CANTCREAT);
+			}
+			regdiagfilename = optarg;
+			break;
 		case 'r':
 			if ((regfile = fopen(optarg, "w")) == NULL) {
 				perror(optarg);
@@ -245,6 +259,14 @@ main(int argc, char *argv[])
 		/* NOTREACHED */
 	}
 
+	if (regdiagfile != NULL
+	 && (regfile == NULL || stock_include_file == NULL)) {
+		fprintf(stderr,
+			"%s: The -p option requires the -r and -i options.\n",
+			appname);
+		usage();
+		/* NOTREACHED */
+	}
 	symtable_open();
 	inputfilename = *argv;
 	include_file(*argv, SOURCE_FILE);
@@ -271,9 +293,8 @@ main(int argc, char *argv[])
 
 		if (ofile != NULL)
 			output_code();
-		if (regfile != NULL) {
-			symtable_dump(regfile);
-		}
+		if (regfile != NULL)
+			symtable_dump(regfile, regdiagfile);
 		if (listfile != NULL)
 			output_listing(inputfilename);
 	}
@@ -288,10 +309,10 @@ usage()
 {
 
 	(void)fprintf(stderr,
-"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]
-			[-r register_output_file] [-l program_list_file]
-			input_file\n",
-			appname);
+"usage: %-16s [-nostdinc] [-I-] [-I directory] [-o output_file]\n"
+"	[-r register_output_file [-p register_diag_file -i includefile]]\n"
+"	[-l program_list_file]\n"
+"	input_file\n", appname);
 	exit(EX_USAGE);
 }
 
@@ -335,11 +356,11 @@ output_code()
 
 	instrcount = 0;
 	fprintf(ofile,
-"/*
- * DO NOT EDIT - This file is automatically generated
- *		 from the following source files:
- *
-%s */\n", versions);
+"/*\n"
+" * DO NOT EDIT - This file is automatically generated\n"
+" *		 from the following source files:\n"
+" *\n"
+"%s */\n", versions);
 
 	fprintf(ofile, "static uint8_t seqprog[] = {\n");
 	for (cur_instr = STAILQ_FIRST(&seq_program);
@@ -370,49 +391,54 @@ output_code()
 	/*
 	 *  Output patch information.  Patch functions first.
 	 */
+	fprintf(ofile,
+"typedef int %spatch_func_t (%s);\n", prefix, patch_arg_list);
+
 	for (cur_node = SLIST_FIRST(&patch_functions);
 	     cur_node != NULL;
 	     cur_node = SLIST_NEXT(cur_node,links)) {
 		fprintf(ofile,
-"static int aic_patch%d_func(%s);
-
-static int
-aic_patch%d_func(%s)
-{
-	return (%s);
-}\n\n",
+"static %spatch_func_t %spatch%d_func;\n"
+"\n"
+"static int\n"
+"%spatch%d_func(%s)\n"
+"{\n"
+"	return (%s);\n"
+"}\n\n",
+			prefix,
+			prefix,
 			cur_node->symbol->info.condinfo->func_num,
-			patch_arg_list,
+			prefix,
 			cur_node->symbol->info.condinfo->func_num,
 			patch_arg_list,
 			cur_node->symbol->name);
 	}
 
 	fprintf(ofile,
-"typedef int patch_func_t (%s);
-static struct patch {
-	patch_func_t	*patch_func;
-	uint32_t	begin	   :10,
-			skip_instr :10,
-			skip_patch :12;
-} patches[] = {\n", patch_arg_list);
+"static struct patch {\n"
+"	%spatch_func_t		*patch_func;\n"
+"	uint32_t		 begin		:10,\n"
+"				 skip_instr	:10,\n"
+"				 skip_patch	:12;\n"
+"} patches[] = {\n", prefix);
 
 	for (cur_patch = STAILQ_FIRST(&patches);
 	     cur_patch != NULL;
 	     cur_patch = STAILQ_NEXT(cur_patch,links)) {
-		fprintf(ofile, "%s\t{ aic_patch%d_func, %d, %d, %d }",
+		fprintf(ofile, "%s\t{ %spatch%d_func, %d, %d, %d }",
 			cur_patch == STAILQ_FIRST(&patches) ? "" : ",\n",
+			prefix,
 			cur_patch->patch_func, cur_patch->begin,
 			cur_patch->skip_instr, cur_patch->skip_patch);
 	}
 
-	fprintf(ofile, "\n};\n");
+	fprintf(ofile, "\n};\n\n");
 
 	fprintf(ofile,
-"static struct cs {
-	u_int16_t	begin;
-	u_int16_t	end;
-} critical_sections[] = {\n");
+"static struct cs {\n"
+"	uint16_t	begin;\n"
+"	uint16_t	end;\n"
+"} critical_sections[] = {\n");
 
 	for (cs = TAILQ_FIRST(&cs_tailq);
 	     cs != NULL;
@@ -422,11 +448,11 @@ static struct patch {
 			cs->begin_addr, cs->end_addr);
 	}
 
-	fprintf(ofile, "\n};\n");
+	fprintf(ofile, "\n};\n\n");
 
 	fprintf(ofile,
-"static const int num_critical_sections = sizeof(critical_sections)
-				       / sizeof(*critical_sections);\n");
+"static const int num_critical_sections = sizeof(critical_sections)\n"
+"				       / sizeof(*critical_sections);\n");
 
 	fprintf(stderr, "%s: %d instructions used\n", appname, instrcount);
 }
diff -urNp linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm.h linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm.h
--- linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm.h
+++ linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm.h
@@ -2,7 +2,7 @@
  * Assembler for the sequencer program downloaded to Aic7xxx SCSI host adapters
  *
  * Copyright (c) 1997 Justin T. Gibbs.
- * Copyright (c) 2001 Adaptec Inc.
+ * Copyright (c) 2001, 2002 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -37,9 +37,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#10 $
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm.h#14 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm.h,v 1.11.2.4 2002/04/29 19:36:36 gibbs Exp $
+ * $FreeBSD$
  */
 
 #ifdef __linux__
@@ -76,8 +76,10 @@ extern struct scope_list scope_stack;
 extern struct symlist patch_functions;
 extern int includes_search_curdir;		/* False if we've seen -I- */
 extern char *appname;
+extern char *stock_include_file;
 extern int yylineno;
 extern char *yyfilename;
+extern char *prefix;
 extern char *patch_arg_list;
 extern char *versions;
 extern int   src_mode;
diff -urNp linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y
--- linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y
+++ linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm_gram.y
@@ -3,7 +3,7 @@
  * Parser for the Aic7xxx SCSI Host adapter sequencer assembler.
  *
  * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
- * Copyright (c) 2001 Adaptec Inc.
+ * Copyright (c) 2001, 2002 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -38,9 +38,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#15 $
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_gram.y#29 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_gram.y,v 1.11.2.5 2002/04/29 19:36:36 gibbs Exp $
+ * $FreeBSD$
  */
 
 #include <sys/types.h>
@@ -64,11 +64,14 @@
 
 int yylineno;
 char *yyfilename;
+char stock_prefix[] = "aic_";
+char *prefix = stock_prefix;
 char *patch_arg_list;
 char *versions;
 static char errbuf[255];
 static char regex_pattern[255];
 static symbol_t *cur_symbol;
+static symbol_t *field_symbol;
 static symbol_t *scb_or_sram_symbol;
 static symtype cur_symtype;
 static symbol_ref_t accumulator;
@@ -82,8 +85,10 @@ static int num_srams;
 static int sram_or_scb_offset;
 static int download_constant_count;
 static int in_critical_section;
+static u_int enum_increment;
+static u_int enum_next_value;
 
-static void process_bitmask(int mask_type, symbol_t *sym, int mask);
+static void process_field(int field_type, symbol_t *sym, int mask);
 static void initialize_symbol(symbol_t *symbol);
 static void add_macro_arg(const char *argtext, int position);
 static void add_macro_body(const char *bodytext);
@@ -152,7 +157,9 @@ static int  is_download_const(expression
 
 %token T_END_CS
 
-%token T_BIT
+%token T_FIELD
+
+%token T_ENUM
 
 %token T_MASK
 
@@ -162,7 +169,7 @@ static int  is_download_const(expression
 
 %token <sym> T_CEXPR
 
-%token T_EOF T_INCLUDE T_VERSION T_PATCH_ARG_LIST
+%token T_EOF T_INCLUDE T_VERSION T_PREFIX T_PATCH_ARG_LIST
 
 %token <value> T_SHR T_SHL T_ROR T_ROL
 
@@ -202,7 +209,7 @@ static int  is_download_const(expression
 
 %type <value> export ret f1_opcode f2_opcode jmp_jc_jnc_call jz_jnz je_jne
 
-%type <value> numerical_value mode_value mode_list macro_arglist
+%type <value> mode_value mode_list macro_arglist
 
 %left '|'
 %left '&'
@@ -216,6 +223,8 @@ static int  is_download_const(expression
 program:
 	include
 |	program include
+|	prefix
+|	program prefix
 |	patch_arg_list
 |	program patch_arg_list
 |	version
@@ -257,6 +266,18 @@ include:
 	}
 ;
 
+prefix:
+	T_PREFIX '=' T_STRING
+	{
+		if (prefix != stock_prefix)
+			stop("Prefix multiply defined",
+			     EX_DATAERR);
+		prefix = strdup($3);
+		if (prefix == NULL)
+			stop("Unable to record prefix", EX_SOFTWARE);
+	}
+;
+
 patch_arg_list:
 	T_PATCH_ARG_LIST '=' T_STRING
 	{
@@ -326,7 +347,8 @@ reg_attribute:		
 |	size
 |	access_mode
 |	modes
-|	bit_defn
+|	field_defn
+|	enum_defn
 |	mask_defn
 |	alias
 |	accumulator
@@ -418,17 +440,68 @@ mode_value:
 	}
 ;
 
-bit_defn:
-	T_BIT T_SYMBOL T_NUMBER
+field_defn:
+	T_FIELD
+		{
+			field_symbol = NULL;
+			enum_next_value = 0;
+			enum_increment = 1;
+		}
+	'{' enum_entry_list '}'
+|	T_FIELD T_SYMBOL expression
+		{
+			process_field(FIELD, $2, $3.value);
+			field_symbol = $2;
+			enum_next_value = 0;
+			enum_increment = 0x01 << (ffs($3.value) - 1);
+		}
+	'{' enum_entry_list '}'
+|	T_FIELD T_SYMBOL expression
+	{
+		process_field(FIELD, $2, $3.value);
+	}
+;
+
+enum_defn:
+	T_ENUM
+		{
+			field_symbol = NULL;
+			enum_next_value = 0;
+			enum_increment = 1;
+		}
+	'{' enum_entry_list '}'
+|	T_ENUM T_SYMBOL expression
+		{
+			process_field(ENUM, $2, $3.value);
+			field_symbol = $2;
+			enum_next_value = 0;
+			enum_increment = 0x01 << (ffs($3.value) - 1);
+		}
+	'{' enum_entry_list '}'
+;
+
+enum_entry_list:
+	enum_entry
+|	enum_entry_list ',' enum_entry
+;
+
+enum_entry:
+	T_SYMBOL
 	{
-		process_bitmask(BIT, $2, $3);
+		process_field(ENUM_ENTRY, $1, enum_next_value);
+		enum_next_value += enum_increment;
+	}
+|	T_SYMBOL expression
+	{
+		process_field(ENUM_ENTRY, $1, $2.value);
+		enum_next_value = $2.value + enum_increment;
 	}
 ;
 
 mask_defn:
 	T_MASK T_SYMBOL expression
 	{
-		process_bitmask(MASK, $2, $3.value);
+		process_field(MASK, $2, $3.value);
 	}
 ;
 
@@ -608,8 +681,10 @@ expression:
 			$$.value = symbol->info.rinfo->address;
 			break;
 		case MASK:
-		case BIT:
-			$$.value = symbol->info.minfo->mask;
+		case FIELD:
+		case ENUM:
+		case ENUM_ENTRY:
+			$$.value = symbol->info.finfo->value;
 			break;
 		case DOWNLOAD_CONST:
 		case CONST:
@@ -632,7 +707,7 @@ expression:
 ;
 
 constant:
-	T_CONST T_SYMBOL numerical_value
+	T_CONST T_SYMBOL expression 
 	{
 		if ($2->type != UNINITIALIZED) {
 			stop("Re-definition of symbol as a constant",
@@ -641,7 +716,7 @@ constant:
 		}
 		$2->type = CONST;
 		initialize_symbol($2);
-		$2->info.cinfo->value = $3;
+		$2->info.cinfo->value = $3.value;
 	}
 |	T_CONST T_SYMBOL T_DOWNLOAD
 	{
@@ -709,17 +784,6 @@ macro_arglist:
 	}
 ;
 
-numerical_value:
-	T_NUMBER
-	{
-		$$ = $1;
-	}
-|	'-' T_NUMBER
-	{
-		$$ = -$2;
-	}
-;
-
 scratch_ram:
 	T_SRAM '{'
 		{
@@ -862,6 +926,8 @@ immediate_or_a:
 |	T_A
 	{
 		SLIST_INIT(&$$.referenced_syms);
+		symlist_add(&$$.referenced_syms, accumulator.symbol,
+			    SYMLIST_INSERT_HEAD);
 		$$.value = 0;
 	}
 ;
@@ -917,6 +983,7 @@ critical_section_start:
 		cs->begin_addr = instruction_ptr;
 		in_critical_section = TRUE;
 	}
+;
 
 critical_section_end:
 	T_END_CS ';'
@@ -931,6 +998,7 @@ critical_section_end:
 		cs->end_addr = instruction_ptr;
 		in_critical_section = FALSE;
 	}
+;
 
 export:
 	{ $$ = 0; }
@@ -1161,9 +1229,22 @@ code:
 ;
 
 code:
-	T_MVI destination ',' immediate_or_a ret ';'
+	T_MVI destination ',' immediate ret ';'
 	{
-		format_1_instr(AIC_OP_OR, &$2, &$4, &allzeros, $5);
+		if ($4.value == 0
+		 && is_download_const(&$4) == 0) {
+			expression_t immed;
+
+			/*
+			 * Allow move immediates of 0 so that macros,
+			 * that can't know the immediate's value and
+			 * otherwise compensate, still work.
+			 */
+			make_expression(&immed, 1);
+			format_1_instr(AIC_OP_BMOV, &$2, &immed, &allzeros, $5);
+		} else {
+			format_1_instr(AIC_OP_OR, &$2, &$4, &allzeros, $5);
+		}
 	}
 ;
 
@@ -1298,7 +1379,7 @@ code:
 %%
 
 static void
-process_bitmask(int mask_type, symbol_t *sym, int mask)
+process_field(int field_type, symbol_t *sym, int value)
 {
 	/*
 	 * Add the current register to its
@@ -1308,52 +1389,54 @@ process_bitmask(int mask_type, symbol_t 
 	 * the "allowed bits" of this register.
 	 */
 	if (sym->type == UNINITIALIZED) {
-		sym->type = mask_type;
+		sym->type = field_type;
 		initialize_symbol(sym);
-		if (mask_type == BIT) {
-			if (mask == 0) {
-				stop("Bitmask with no bits set", EX_DATAERR);
-				/* NOTREACHED */
-			}
-			if ((mask & ~(0x01 << (ffs(mask) - 1))) != 0) {
-				stop("Bitmask with more than one bit set",
-				     EX_DATAERR);
+		sym->info.finfo->value = value;
+		if (field_type != ENUM_ENTRY) {
+			if (field_type != MASK && value == 0) {
+				stop("Empty Field, or Enum", EX_DATAERR);
 				/* NOTREACHED */
 			}
+			sym->info.finfo->value = value;
+			sym->info.finfo->mask = value;
+		} else if (field_symbol != NULL) {
+			sym->info.finfo->mask = field_symbol->info.finfo->value;
+		} else {
+			sym->info.finfo->mask = 0xFF;
 		}
-		sym->info.minfo->mask = mask;
-	} else if (sym->type != mask_type) {
-		stop("Bit definition mirrors a definition of the same "
+	} else if (sym->type != field_type) {
+		stop("Field definition mirrors a definition of the same "
 		     " name, but a different type", EX_DATAERR);
 		/* NOTREACHED */
-	} else if (mask != sym->info.minfo->mask) {
-		stop("Bitmask redefined with a conflicting value", EX_DATAERR);
+	} else if (value != sym->info.finfo->value) {
+		stop("Field redefined with a conflicting value", EX_DATAERR);
 		/* NOTREACHED */
 	}
 	/* Fail if this symbol is already listed */
-	if (symlist_search(&(sym->info.minfo->symrefs),
+	if (symlist_search(&(sym->info.finfo->symrefs),
 			   cur_symbol->name) != NULL) {
-		stop("Bitmask defined multiple times for register", EX_DATAERR);
+		stop("Field defined multiple times for register", EX_DATAERR);
 		/* NOTREACHED */
 	}
-	symlist_add(&(sym->info.minfo->symrefs), cur_symbol,
+	symlist_add(&(sym->info.finfo->symrefs), cur_symbol,
 		    SYMLIST_INSERT_HEAD);
-	cur_symbol->info.rinfo->valid_bitmask |= mask;
+	cur_symbol->info.rinfo->valid_bitmask |= sym->info.finfo->mask;
 	cur_symbol->info.rinfo->typecheck_masks = TRUE;
+	symlist_add(&(cur_symbol->info.rinfo->fields), sym, SYMLIST_SORT);
 }
 
 static void
 initialize_symbol(symbol_t *symbol)
 {
 	switch (symbol->type) {
-        case UNINITIALIZED:
+	case UNINITIALIZED:
 		stop("Call to initialize_symbol with type field unset",
 		     EX_SOFTWARE);
 		/* NOTREACHED */
 		break;
-        case REGISTER:
-        case SRAMLOC:
-        case SCBLOC:
+	case REGISTER:
+	case SRAMLOC:
+	case SCBLOC:
 		symbol->info.rinfo =
 		    (struct reg_info *)malloc(sizeof(struct reg_info));
 		if (symbol->info.rinfo == NULL) {
@@ -1362,6 +1445,7 @@ initialize_symbol(symbol_t *symbol)
 		}
 		memset(symbol->info.rinfo, 0,
 		       sizeof(struct reg_info));
+		SLIST_INIT(&(symbol->info.rinfo->fields));
 		/*
 		 * Default to allowing access in all register modes
 		 * or to the mode specified by the SCB or SRAM space
@@ -1373,7 +1457,7 @@ initialize_symbol(symbol_t *symbol)
 		else
 			symbol->info.rinfo->modes = ~0;
 		break;
-        case ALIAS:
+	case ALIAS:
 		symbol->info.ainfo =
 		    (struct alias_info *)malloc(sizeof(struct alias_info));
 		if (symbol->info.ainfo == NULL) {
@@ -1383,19 +1467,21 @@ initialize_symbol(symbol_t *symbol)
 		memset(symbol->info.ainfo, 0,
 		       sizeof(struct alias_info));
 		break;
-        case MASK:
-        case BIT:
-		symbol->info.minfo =
-		    (struct mask_info *)malloc(sizeof(struct mask_info));
-		if (symbol->info.minfo == NULL) {
-			stop("Can't create bitmask info", EX_SOFTWARE);
+	case MASK:
+	case FIELD:
+	case ENUM:
+	case ENUM_ENTRY:
+		symbol->info.finfo =
+		    (struct field_info *)malloc(sizeof(struct field_info));
+		if (symbol->info.finfo == NULL) {
+			stop("Can't create field info", EX_SOFTWARE);
 			/* NOTREACHED */
 		}
-		memset(symbol->info.minfo, 0, sizeof(struct mask_info));
-		SLIST_INIT(&(symbol->info.minfo->symrefs));
+		memset(symbol->info.finfo, 0, sizeof(struct field_info));
+		SLIST_INIT(&(symbol->info.finfo->symrefs));
 		break;
-        case CONST:
-        case DOWNLOAD_CONST:
+	case CONST:
+	case DOWNLOAD_CONST:
 		symbol->info.cinfo =
 		    (struct const_info *)malloc(sizeof(struct const_info));
 		if (symbol->info.cinfo == NULL) {
@@ -1577,7 +1663,6 @@ format_1_instr(int opcode, symbol_ref_t 
 		case AIC_OP_OR:
 			dst_value = src_value | immed->value;
 			break;
-			break;
 		case AIC_OP_BMOV:
 			dst_value = src_value;
 			break;
@@ -1586,9 +1671,9 @@ format_1_instr(int opcode, symbol_ref_t 
 		}
 		src_mode = dst_value & 0xF;
 		dst_mode = (dst_value >> 4) & 0xF;
-cant_update:
 	}
 
+cant_update:
 	symlist_free(&immed->referenced_syms);
 	instruction_ptr++;
 }
@@ -1763,11 +1848,13 @@ type_check(symbol_t *symbol, expression_
 		    node != NULL;
 		    node = node->links.sle_next) {
 			if ((node->symbol->type == MASK
-			  || node->symbol->type == BIT)
-			 && symlist_search(&node->symbol->info.minfo->symrefs,
+			  || node->symbol->type == FIELD
+			  || node->symbol->type == ENUM
+			  || node->symbol->type == ENUM_ENTRY)
+			 && symlist_search(&node->symbol->info.finfo->symrefs,
 					   symbol->name) == NULL) {
 				snprintf(errbuf, sizeof(errbuf),
-					 "Invalid bit or mask %s "
+					 "Invalid field or mask %s "
 					 "for register %s",
 					 node->symbol->name, symbol->name);
 				stop(errbuf, EX_DATAERR);
diff -urNp linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h
--- linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h
+++ linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm_insformat.h
@@ -37,9 +37,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#9 $
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_insformat.h#11 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_insformat.h,v 1.3.2.3 2002/04/29 19:36:36 gibbs Exp $
+ * $FreeBSD$
  */
 
 struct ins_format1 {
diff -urNp linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y
--- linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y
+++ linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm_macro_gram.y
@@ -38,9 +38,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_gram.y#5 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_macro_gram.y,v 1.1.2.1 2002/04/29 19:36:36 gibbs Exp $
+ * $FreeBSD$
  */
 
 #include <sys/types.h>
diff -urNp linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l
--- linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l
+++ linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm_macro_scan.l
@@ -38,13 +38,14 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id$
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_macro_scan.l#7 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_macro_scan.l,v 1.1.2.1 2002/04/29 19:36:36 gibbs Exp $
+ * $FreeBSD$
  */
 
 #include <sys/types.h>
 
+#include <inttypes.h>
 #include <limits.h>
 #include <regex.h>
 #include <stdio.h>
diff -urNp linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l
--- linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l
+++ linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm_scan.l
@@ -3,7 +3,7 @@
  * Lexical Analyzer for the Aic7xxx SCSI Host adapter sequencer assembler.
  *
  * Copyright (c) 1997, 1998, 2000 Justin T. Gibbs.
- * Copyright (c) 2001 Adaptec Inc.
+ * Copyright (c) 2001, 2002 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -38,13 +38,14 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#11 $
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_scan.l#18 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_scan.l,v 1.13.2.4 2002/04/29 19:36:36 gibbs Exp $
+ * $FreeBSD$
  */
 
 #include <sys/types.h>
 
+#include <inttypes.h>
 #include <limits.h>
 #include <regex.h>
 #include <stdio.h>
@@ -131,6 +132,7 @@ if[ \t]*\(		{
 			}
 
 VERSION			{ return T_VERSION; }
+PREFIX			{ return T_PREFIX; }
 PATCH_ARG_LIST		{ return T_PATCH_ARG_LIST; }
 \"			{
 				string_buf_ptr = string_buf;
@@ -173,7 +175,8 @@ BEGIN_CRITICAL		{ return T_BEGIN_CS; }
 END_CRITICAL		{ return T_END_CS; }
 SET_SRC_MODE		{ return T_SET_SRC_MODE; }
 SET_DST_MODE		{ return T_SET_DST_MODE; }
-bit			{ return T_BIT; }
+field			{ return T_FIELD; }
+enum			{ return T_ENUM; }
 mask			{ return T_MASK; }
 alias			{ return T_ALIAS; }
 size			{ return T_SIZE; }
diff -urNp linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c
--- linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c
+++ linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.c
@@ -2,6 +2,7 @@
  * Aic7xxx SCSI host adapter firmware asssembler symbol table implementation
  *
  * Copyright (c) 1997 Justin T. Gibbs.
+ * Copyright (c) 2002 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -36,9 +37,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#14 $
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.c#24 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_symbol.c,v 1.11.2.4 2002/04/29 19:36:36 gibbs Exp $
+ * $FreeBSD$
  */
 
 #include <sys/types.h>
@@ -49,6 +50,7 @@
 #include <db.h>
 #endif
 #include <fcntl.h>
+#include <inttypes.h>
 #include <regex.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -72,6 +74,8 @@ symbol_create(char *name)
 	}
 	memset(new_symbol, 0, sizeof(*new_symbol));
 	new_symbol->name = strdup(name);
+	if (new_symbol->name == NULL)
+		 stop("Unable to strdup symbol name", EX_SOFTWARE);
 	new_symbol->type = UNINITIALIZED;
 	return (new_symbol);
 }
@@ -98,10 +102,12 @@ symbol_delete(symbol_t *symbol)
 			free(symbol->info.ainfo);
 		break;
 	case MASK:
-	case BIT:
-		if (symbol->info.minfo != NULL) {
-			symlist_free(&symbol->info.minfo->symrefs);
-			free(symbol->info.minfo);
+	case FIELD:
+	case ENUM:
+	case ENUM_ENTRY:
+		if (symbol->info.finfo != NULL) {
+			symlist_free(&symbol->info.finfo->symrefs);
+			free(symbol->info.finfo);
 		}
 		break;
 	case DOWNLOAD_CONST:
@@ -222,17 +228,19 @@ symlist_add(symlist_t *symlist, symbol_t
 	newnode->symbol = symbol;
 	if (how == SYMLIST_SORT) {
 		symbol_node_t *curnode;
-		int mask;
+		int field;
 
-		mask = FALSE;
+		field = FALSE;
 		switch(symbol->type) {
 		case REGISTER:
 		case SCBLOC:
 		case SRAMLOC:
 			break;
-		case BIT:
+		case FIELD:
 		case MASK:
-			mask = TRUE;
+		case ENUM:
+		case ENUM_ENTRY:
+			field = TRUE;
 			break;
 		default:
 			stop("symlist_add: Invalid symbol type for sorting",
@@ -242,9 +250,12 @@ symlist_add(symlist_t *symlist, symbol_t
 
 		curnode = SLIST_FIRST(symlist);
 		if (curnode == NULL
-		 || (mask && (curnode->symbol->info.minfo->mask >
-		              newnode->symbol->info.minfo->mask))
-		 || (!mask && (curnode->symbol->info.rinfo->address >
+		 || (field
+		  && (curnode->symbol->type > newnode->symbol->type
+		   || (curnode->symbol->type == newnode->symbol->type
+		    && (curnode->symbol->info.finfo->value >
+			newnode->symbol->info.finfo->value))))
+		 || (!field && (curnode->symbol->info.rinfo->address >
 		               newnode->symbol->info.rinfo->address))) {
 			SLIST_INSERT_HEAD(symlist, newnode, links);
 			return;
@@ -259,10 +270,14 @@ symlist_add(symlist_t *symlist, symbol_t
 				symbol_t *cursymbol;
 
 				cursymbol = SLIST_NEXT(curnode, links)->symbol;
-				if ((mask && (cursymbol->info.minfo->mask >
-				              symbol->info.minfo->mask))
-				 || (!mask &&(cursymbol->info.rinfo->address >
-				              symbol->info.rinfo->address))){
+				if ((field
+		  		  && (cursymbol->type > symbol->type
+				   || (cursymbol->type == symbol->type
+				    && (cursymbol->info.finfo->value >
+					symbol->info.finfo->value))))
+				 || (!field
+				   && (cursymbol->info.rinfo->address >
+				       symbol->info.rinfo->address))) {
 					SLIST_INSERT_AFTER(curnode, newnode,
 							   links);
 					break;
@@ -307,20 +322,160 @@ symlist_merge(symlist_t *symlist_dest, s
 }
 
 void
-symtable_dump(FILE *ofile)
+aic_print_file_prologue(FILE *ofile)
+{
+
+	if (ofile == NULL)
+		return;
+
+	fprintf(ofile,
+"/*\n"
+" * DO NOT EDIT - This file is automatically generated\n"
+" *		 from the following source files:\n"
+" *\n"
+"%s */\n",
+		versions);
+}
+
+void
+aic_print_include(FILE *dfile, char *include_file)
+{
+
+	if (dfile == NULL)
+		return;
+	fprintf(dfile, "\n#include \"%s\"\n\n", include_file);
+}
+
+void
+aic_print_reg_dump_types(FILE *ofile)
+{
+	if (ofile == NULL)
+		return;
+		
+	fprintf(ofile,
+"typedef int (%sreg_print_t)(u_int, u_int *, u_int);\n"
+"typedef struct %sreg_parse_entry {\n"
+"	char	*name;\n"
+"	uint8_t	 value;\n"
+"	uint8_t	 mask;\n"
+"} %sreg_parse_entry_t;\n"
+"\n",
+		prefix, prefix, prefix);
+}
+
+static void
+aic_print_reg_dump_start(FILE *dfile, symbol_node_t *regnode)
+{
+	if (dfile == NULL)
+		return;
+
+	fprintf(dfile,
+"static %sreg_parse_entry_t %s_parse_table[] = {\n",
+		prefix,
+		regnode->symbol->name);
+}
+
+static void
+aic_print_reg_dump_end(FILE *ofile, FILE *dfile,
+		       symbol_node_t *regnode, u_int num_entries)
+{
+	char *lower_name;
+	char *letter;
+
+	lower_name = strdup(regnode->symbol->name);
+	if (lower_name == NULL)
+		 stop("Unable to strdup symbol name", EX_SOFTWARE);
+	
+	for (letter = lower_name; *letter != '\0'; letter++)
+		*letter = tolower(*letter);
+
+	if (dfile != NULL) {
+		if (num_entries != 0)
+			fprintf(dfile,
+"\n"
+"};\n"
+"\n");
+
+		fprintf(dfile,
+"int\n"
+"%s%s_print(u_int regvalue, u_int *cur_col, u_int wrap)\n"
+"{\n"
+"	return (%sprint_register(%s%s, %d, \"%s\",\n"
+"	    0x%02x, regvalue, cur_col, wrap));\n"
+"}\n"
+"\n",
+			prefix,
+			lower_name,
+			prefix,
+			num_entries != 0 ? regnode->symbol->name : "NULL",
+			num_entries != 0 ? "_parse_table" : "",
+			num_entries,
+			regnode->symbol->name,
+			regnode->symbol->info.rinfo->address);
+	}
+
+	fprintf(ofile,
+"#if AIC_DEBUG_REGISTERS\n"
+"%sreg_print_t %s%s_print;\n"
+"#else\n"
+"#define %s%s_print(regvalue, cur_col, wrap) \\\n"
+"    %sprint_register(NULL, 0, \"%s\", 0x%02x, regvalue, cur_col, wrap)\n"
+"#endif\n"
+"\n",
+		prefix,
+		prefix,
+		lower_name,
+		prefix,
+		lower_name,
+		prefix,
+		regnode->symbol->name,
+		regnode->symbol->info.rinfo->address);
+}
+
+static void
+aic_print_reg_dump_entry(FILE *dfile, symbol_node_t *curnode)
+{
+	int num_tabs;
+
+	if (dfile == NULL)
+		return;
+
+	fprintf(dfile,
+"	{ \"%s\",",
+		curnode->symbol->name);
+
+	num_tabs = 3 - (strlen(curnode->symbol->name) + 5) / 8;
+
+	while (num_tabs-- > 0)
+		fputc('\t', dfile);
+	fprintf(dfile, "0x%02x, 0x%02x }",
+		curnode->symbol->info.finfo->value,
+		curnode->symbol->info.finfo->mask);
+}
+
+void
+symtable_dump(FILE *ofile, FILE *dfile)
 {
 	/*
 	 * Sort the registers by address with a simple insertion sort.
 	 * Put bitmasks next to the first register that defines them.
 	 * Put constants at the end.
 	 */
-	symlist_t registers;
-	symlist_t masks;
-	symlist_t constants;
-	symlist_t download_constants;
-	symlist_t aliases;
-	symlist_t exported_labels;
-	u_int	  i;
+	symlist_t	 registers;
+	symlist_t	 masks;
+	symlist_t	 constants;
+	symlist_t	 download_constants;
+	symlist_t	 aliases;
+	symlist_t	 exported_labels;
+	symbol_node_t	*curnode;
+	symbol_node_t	*regnode;
+	DBT		 key;
+	DBT		 data;
+	int		 flag;
+	u_int		 i;
+
+	if (symtable == NULL)
+		return;
 
 	SLIST_INIT(&registers);
 	SLIST_INIT(&masks);
@@ -328,173 +483,195 @@ symtable_dump(FILE *ofile)
 	SLIST_INIT(&download_constants);
 	SLIST_INIT(&aliases);
 	SLIST_INIT(&exported_labels);
+	flag = R_FIRST;
+	while (symtable->seq(symtable, &key, &data, flag) == 0) {
+		symbol_t *cursym;
 
-	if (symtable != NULL) {
-		DBT	 key;
-		DBT	 data;
-		int	 flag = R_FIRST;
+		memcpy(&cursym, data.data, sizeof(cursym));
+		switch(cursym->type) {
+		case REGISTER:
+		case SCBLOC:
+		case SRAMLOC:
+			symlist_add(&registers, cursym, SYMLIST_SORT);
+			break;
+		case MASK:
+		case FIELD:
+		case ENUM:
+		case ENUM_ENTRY:
+			symlist_add(&masks, cursym, SYMLIST_SORT);
+			break;
+		case CONST:
+			symlist_add(&constants, cursym,
+				    SYMLIST_INSERT_HEAD);
+			break;
+		case DOWNLOAD_CONST:
+			symlist_add(&download_constants, cursym,
+				    SYMLIST_INSERT_HEAD);
+			break;
+		case ALIAS:
+			symlist_add(&aliases, cursym,
+				    SYMLIST_INSERT_HEAD);
+			break;
+		case LABEL:
+			if (cursym->info.linfo->exported == 0)
+				break;
+			symlist_add(&exported_labels, cursym,
+				    SYMLIST_INSERT_HEAD);
+			break;
+		default:
+			break;
+		}
+		flag = R_NEXT;
+	}
 
-		while (symtable->seq(symtable, &key, &data, flag) == 0) {
-			symbol_t *cursym;
+	/* Register dianostic functions/declarations first. */
+	aic_print_file_prologue(ofile);
+	aic_print_reg_dump_types(ofile);
+	aic_print_file_prologue(dfile);
+	aic_print_include(dfile, stock_include_file);
+	SLIST_FOREACH(curnode, &registers, links) {
 
-			memcpy(&cursym, data.data, sizeof(cursym));
-			switch(cursym->type) {
-			case REGISTER:
-			case SCBLOC:
-			case SRAMLOC:
-				symlist_add(&registers, cursym, SYMLIST_SORT);
-				break;
-			case MASK:
-			case BIT:
-				symlist_add(&masks, cursym, SYMLIST_SORT);
-				break;
-			case CONST:
-				symlist_add(&constants, cursym,
-					    SYMLIST_INSERT_HEAD);
-				break;
-			case DOWNLOAD_CONST:
-				symlist_add(&download_constants, cursym,
-					    SYMLIST_INSERT_HEAD);
-				break;
-			case ALIAS:
-				symlist_add(&aliases, cursym,
-					    SYMLIST_INSERT_HEAD);
-				break;
-			case LABEL:
-				if (cursym->info.linfo->exported == 0)
-					break;
-				symlist_add(&exported_labels, cursym,
-					    SYMLIST_INSERT_HEAD);
-				break;
-			default:
-				break;
+		switch(curnode->symbol->type) {
+		case REGISTER:
+		case SCBLOC:
+		case SRAMLOC:
+		{
+			symlist_t	*fields;
+			symbol_node_t	*fieldnode;
+			int		 num_entries;
+
+			num_entries = 0;
+			fields = &curnode->symbol->info.rinfo->fields;
+			SLIST_FOREACH(fieldnode, fields, links) {
+				if (num_entries == 0)
+					aic_print_reg_dump_start(dfile,
+								 curnode);
+				else if (dfile != NULL)
+					fputs(",\n", dfile);
+				num_entries++;
+				aic_print_reg_dump_entry(dfile, fieldnode);
 			}
-			flag = R_NEXT;
+			aic_print_reg_dump_end(ofile, dfile,
+					       curnode, num_entries);
+		}
+		default:
+			break;
 		}
+	}
 
-		/* Put in the masks and bits */
-		while (SLIST_FIRST(&masks) != NULL) {
-			symbol_node_t *curnode;
-			symbol_node_t *regnode;
-			char *regname;
+	/* Fold in the masks and bits */
+	while (SLIST_FIRST(&masks) != NULL) {
+		char *regname;
 
-			curnode = SLIST_FIRST(&masks);
-			SLIST_REMOVE_HEAD(&masks, links);
+		curnode = SLIST_FIRST(&masks);
+		SLIST_REMOVE_HEAD(&masks, links);
 
-			regnode =
-			    SLIST_FIRST(&curnode->symbol->info.minfo->symrefs);
-			regname = regnode->symbol->name;
-			regnode = symlist_search(&registers, regname);
-			SLIST_INSERT_AFTER(regnode, curnode, links);
-		}
+		regnode = SLIST_FIRST(&curnode->symbol->info.finfo->symrefs);
+		regname = regnode->symbol->name;
+		regnode = symlist_search(&registers, regname);
+		SLIST_INSERT_AFTER(regnode, curnode, links);
+	}
 
-		/* Add the aliases */
-		while (SLIST_FIRST(&aliases) != NULL) {
-			symbol_node_t *curnode;
-			symbol_node_t *regnode;
-			char *regname;
+	/* Add the aliases */
+	while (SLIST_FIRST(&aliases) != NULL) {
+		char *regname;
 
-			curnode = SLIST_FIRST(&aliases);
-			SLIST_REMOVE_HEAD(&aliases, links);
+		curnode = SLIST_FIRST(&aliases);
+		SLIST_REMOVE_HEAD(&aliases, links);
 
-			regname = curnode->symbol->info.ainfo->parent->name;
-			regnode = symlist_search(&registers, regname);
-			SLIST_INSERT_AFTER(regnode, curnode, links);
-		}
+		regname = curnode->symbol->info.ainfo->parent->name;
+		regnode = symlist_search(&registers, regname);
+		SLIST_INSERT_AFTER(regnode, curnode, links);
+	}
 
-		/* Output what we have */
-		fprintf(ofile,
-"/*
- * DO NOT EDIT - This file is automatically generated
- *		 from the following source files:
- *
-%s */\n", versions);
-		while (SLIST_FIRST(&registers) != NULL) {
-			symbol_node_t *curnode;
-			u_int value;
-			char *tab_str;
-			char *tab_str2;
-
-			curnode = SLIST_FIRST(&registers);
-			SLIST_REMOVE_HEAD(&registers, links);
-			switch(curnode->symbol->type) {
-			case REGISTER:
-			case SCBLOC:
-			case SRAMLOC:
-				fprintf(ofile, "\n");
-				value = curnode->symbol->info.rinfo->address;
-				tab_str = "\t";
-				tab_str2 = "\t\t";
-				break;
-			case ALIAS:
-			{
-				symbol_t *parent;
-
-				parent = curnode->symbol->info.ainfo->parent;
-				value = parent->info.rinfo->address;
-				tab_str = "\t";
-				tab_str2 = "\t\t";
-				break;
-			}
-			case MASK:
-			case BIT:
-				value = curnode->symbol->info.minfo->mask;
-				tab_str = "\t\t";
-				tab_str2 = "\t";
-				break;
-			default:
-				value = 0; /* Quiet compiler */
-				tab_str = NULL;
-				tab_str2 = NULL;
-				stop("symtable_dump: Invalid symbol type "
-				     "encountered", EX_SOFTWARE);
-				break;
-			}
-			fprintf(ofile, "#define%s%-16s%s0x%02x\n",
-				tab_str, curnode->symbol->name, tab_str2,
-				value);
-			free(curnode);
-		}
-		fprintf(ofile, "\n\n");
-
-		while (SLIST_FIRST(&constants) != NULL) {
-			symbol_node_t *curnode;
-
-			curnode = SLIST_FIRST(&constants);
-			SLIST_REMOVE_HEAD(&constants, links);
-			fprintf(ofile, "#define\t%-8s\t0x%02x\n",
-				curnode->symbol->name,
-				curnode->symbol->info.cinfo->value);
-			free(curnode);
+	/* Output generated #defines. */
+	while (SLIST_FIRST(&registers) != NULL) {
+		symbol_node_t *curnode;
+		u_int value;
+		char *tab_str;
+		char *tab_str2;
+
+		curnode = SLIST_FIRST(&registers);
+		SLIST_REMOVE_HEAD(&registers, links);
+		switch(curnode->symbol->type) {
+		case REGISTER:
+		case SCBLOC:
+		case SRAMLOC:
+			fprintf(ofile, "\n");
+			value = curnode->symbol->info.rinfo->address;
+			tab_str = "\t";
+			tab_str2 = "\t\t";
+			break;
+		case ALIAS:
+		{
+			symbol_t *parent;
+
+			parent = curnode->symbol->info.ainfo->parent;
+			value = parent->info.rinfo->address;
+			tab_str = "\t";
+			tab_str2 = "\t\t";
+			break;
 		}
+		case MASK:
+		case FIELD:
+		case ENUM:
+		case ENUM_ENTRY:
+			value = curnode->symbol->info.finfo->value;
+			tab_str = "\t\t";
+			tab_str2 = "\t";
+			break;
+		default:
+			value = 0; /* Quiet compiler */
+			tab_str = NULL;
+			tab_str2 = NULL;
+			stop("symtable_dump: Invalid symbol type "
+			     "encountered", EX_SOFTWARE);
+			break;
+		}
+		fprintf(ofile, "#define%s%-16s%s0x%02x\n",
+			tab_str, curnode->symbol->name, tab_str2,
+			value);
+		free(curnode);
+	}
+	fprintf(ofile, "\n\n");
 
-		
-		fprintf(ofile, "\n\n/* Downloaded Constant Definitions */\n");
+	while (SLIST_FIRST(&constants) != NULL) {
+		symbol_node_t *curnode;
+
+		curnode = SLIST_FIRST(&constants);
+		SLIST_REMOVE_HEAD(&constants, links);
+		fprintf(ofile, "#define\t%-8s\t0x%02x\n",
+			curnode->symbol->name,
+			curnode->symbol->info.cinfo->value);
+		free(curnode);
+	}
 
-		for (i = 0; SLIST_FIRST(&download_constants) != NULL; i++) {
-			symbol_node_t *curnode;
+	
+	fprintf(ofile, "\n\n/* Downloaded Constant Definitions */\n");
 
-			curnode = SLIST_FIRST(&download_constants);
-			SLIST_REMOVE_HEAD(&download_constants, links);
-			fprintf(ofile, "#define\t%-8s\t0x%02x\n",
-				curnode->symbol->name,
-				curnode->symbol->info.cinfo->value);
-			free(curnode);
-		}
-		fprintf(ofile, "#define\tDOWNLOAD_CONST_COUNT\t0x%02x\n", i);
-
-		fprintf(ofile, "\n\n/* Exported Labels */\n");
-
-		while (SLIST_FIRST(&exported_labels) != NULL) {
-			symbol_node_t *curnode;
-
-			curnode = SLIST_FIRST(&exported_labels);
-			SLIST_REMOVE_HEAD(&exported_labels, links);
-			fprintf(ofile, "#define\tLABEL_%-8s\t0x%02x\n",
-				curnode->symbol->name,
-				curnode->symbol->info.linfo->address);
-			free(curnode);
-		}
+	for (i = 0; SLIST_FIRST(&download_constants) != NULL; i++) {
+		symbol_node_t *curnode;
+
+		curnode = SLIST_FIRST(&download_constants);
+		SLIST_REMOVE_HEAD(&download_constants, links);
+		fprintf(ofile, "#define\t%-8s\t0x%02x\n",
+			curnode->symbol->name,
+			curnode->symbol->info.cinfo->value);
+		free(curnode);
+	}
+	fprintf(ofile, "#define\tDOWNLOAD_CONST_COUNT\t0x%02x\n", i);
+
+	fprintf(ofile, "\n\n/* Exported Labels */\n");
+
+	while (SLIST_FIRST(&exported_labels) != NULL) {
+		symbol_node_t *curnode;
+
+		curnode = SLIST_FIRST(&exported_labels);
+		SLIST_REMOVE_HEAD(&exported_labels, links);
+		fprintf(ofile, "#define\tLABEL_%-8s\t0x%02x\n",
+			curnode->symbol->name,
+			curnode->symbol->info.linfo->address);
+		free(curnode);
 	}
 }
 
diff -urNp linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h
--- linux-5720/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h
+++ linux-5730/drivers/scsi/aic7xxx/aicasm/aicasm_symbol.h
@@ -2,6 +2,7 @@
  * Aic7xxx SCSI host adapter firmware asssembler symbol table definitions
  *
  * Copyright (c) 1997 Justin T. Gibbs.
+ * Copyright (c) 2002 Adaptec Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -36,9 +37,9 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGES.
  *
- * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#11 $
+ * $Id: //depot/aic7xxx/aic7xxx/aicasm/aicasm_symbol.h#17 $
  *
- * $FreeBSD: src/sys/dev/aic7xxx/aicasm/aicasm_symbol.h,v 1.11.2.3 2002/04/29 19:36:36 gibbs Exp $
+ * $FreeBSD$
  */
 
 #ifdef __linux__
@@ -53,8 +54,10 @@ typedef enum {
 	ALIAS,
 	SCBLOC,
 	SRAMLOC,
+	ENUM_ENTRY,
+	FIELD,
 	MASK,
-	BIT,
+	ENUM,
 	CONST,
 	DOWNLOAD_CONST,
 	LABEL,
@@ -68,20 +71,22 @@ typedef enum {
 	RW = 0x03
 }amode_t;
 
+typedef SLIST_HEAD(symlist, symbol_node) symlist_t;
+
 struct reg_info {
-	u_int	 address;
-	int	 size;
-	amode_t	 mode;
-	u_int8_t valid_bitmask;
-	u_int8_t modes;
-	int	 typecheck_masks;
+	u_int	  address;
+	int	  size;
+	amode_t	  mode;
+	symlist_t fields;
+	uint8_t	  valid_bitmask;
+	uint8_t	  modes;
+	int	  typecheck_masks;
 };
 
-typedef SLIST_HEAD(symlist, symbol_node) symlist_t;
-
-struct mask_info {
+struct field_info {
 	symlist_t symrefs;
-	u_int8_t mask;
+	uint8_t	  value;
+	uint8_t	  mask;
 };
 
 struct const_info {
@@ -125,7 +130,7 @@ typedef struct symbol {
 	symtype	type;
 	union	{
 		struct reg_info	  *rinfo;
-		struct mask_info  *minfo;
+		struct field_info *finfo;
 		struct const_info *cinfo;
 		struct alias_info *ainfo;
 		struct label_info *linfo;
@@ -178,25 +183,25 @@ TAILQ_HEAD(cs_tailq, critical_section);
 SLIST_HEAD(scope_list, scope);
 TAILQ_HEAD(scope_tailq, scope);
 
-void	symbol_delete __P((symbol_t *symbol));
+void	symbol_delete(symbol_t *symbol);
 
-void	symtable_open __P((void));
+void	symtable_open(void);
 
-void	symtable_close __P((void));
+void	symtable_close(void);
 
 symbol_t *
-	symtable_get __P((char *name));
+	symtable_get(char *name);
 
 symbol_node_t *
-	symlist_search __P((symlist_t *symlist, char *symname));
+	symlist_search(symlist_t *symlist, char *symname);
 
 void
-	symlist_add __P((symlist_t *symlist, symbol_t *symbol, int how));
+	symlist_add(symlist_t *symlist, symbol_t *symbol, int how);
 #define SYMLIST_INSERT_HEAD	0x00
 #define SYMLIST_SORT		0x01
 
-void	symlist_free __P((symlist_t *symlist));
+void	symlist_free(symlist_t *symlist);
 
-void	symlist_merge __P((symlist_t *symlist_dest, symlist_t *symlist_src1,
-			   symlist_t *symlist_src2));
-void	symtable_dump __P((FILE *ofile));
+void	symlist_merge(symlist_t *symlist_dest, symlist_t *symlist_src1,
+		      symlist_t *symlist_src2);
+void	symtable_dump(FILE *ofile, FILE *dfile);
diff -urNp linux-5720/drivers/scsi/aic7xxx/aiclib.c linux-5730/drivers/scsi/aic7xxx/aiclib.c
--- linux-5720/drivers/scsi/aic7xxx/aiclib.c
+++ linux-5730/drivers/scsi/aic7xxx/aiclib.c
@@ -0,0 +1,1413 @@
+/*
+ * Implementation of Utility functions for all SCSI device types.
+ *
+ * Copyright (c) 1997, 1998, 1999 Justin T. Gibbs.
+ * Copyright (c) 1997, 1998 Kenneth D. Merry.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification, immediately at the beginning of the file.
+ * 2. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/sys/cam/scsi/scsi_all.c,v 1.38 2002/09/23 04:56:35 mjacob Exp $
+ * $Id$
+ */
+
+#include <linux/blk.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>
+#include <linux/version.h>
+
+/* Core SCSI definitions */
+#include "scsi.h"
+#include "hosts.h"
+#include "aiclib.h"
+#include "cam.h"
+
+#ifndef FALSE
+#define FALSE   0
+#endif /* FALSE */
+#ifndef TRUE
+#define TRUE    1
+#endif /* TRUE */
+#ifndef ERESTART
+#define ERESTART        -1              /* restart syscall */
+#endif
+#ifndef EJUSTRETURN
+#define EJUSTRETURN     -2              /* don't modify regs, just return */
+#endif
+
+static int	ascentrycomp(const void *key, const void *member);
+static int	senseentrycomp(const void *key, const void *member);
+static void	fetchtableentries(int sense_key, int asc, int ascq,
+				  struct scsi_inquiry_data *,
+				  const struct sense_key_table_entry **,
+				  const struct asc_table_entry **);
+static void *	scsibsearch(const void *key, const void *base, size_t nmemb,
+			    size_t size,
+			    int (*compar)(const void *, const void *));
+typedef int (cam_quirkmatch_t)(caddr_t, caddr_t);
+static int	cam_strmatch(const u_int8_t *str, const u_int8_t *pattern,
+			     int str_len);
+static caddr_t	cam_quirkmatch(caddr_t target, caddr_t quirk_table,
+			       int num_entries, int entry_size,
+			       cam_quirkmatch_t *comp_func);
+
+#define SCSI_NO_SENSE_STRINGS 1
+#if !defined(SCSI_NO_SENSE_STRINGS)
+#define SST(asc, ascq, action, desc) \
+	asc, ascq, action, desc
+#else 
+static const char empty_string[] = "";
+
+#define SST(asc, ascq, action, desc) \
+	asc, ascq, action, empty_string
+#endif 
+
+static const struct sense_key_table_entry sense_key_table[] = 
+{
+	{ SSD_KEY_NO_SENSE, SS_NOP, "NO SENSE" },
+	{ SSD_KEY_RECOVERED_ERROR, SS_NOP|SSQ_PRINT_SENSE, "RECOVERED ERROR" },
+	{
+	  SSD_KEY_NOT_READY, SS_TUR|SSQ_MANY|SSQ_DECREMENT_COUNT|EBUSY,
+	  "NOT READY"
+	},
+	{ SSD_KEY_MEDIUM_ERROR, SS_RDEF, "MEDIUM ERROR" },
+	{ SSD_KEY_HARDWARE_ERROR, SS_RDEF, "HARDWARE FAILURE" },
+	{ SSD_KEY_ILLEGAL_REQUEST, SS_FATAL|EINVAL, "ILLEGAL REQUEST" },
+	{ SSD_KEY_UNIT_ATTENTION, SS_FATAL|ENXIO, "UNIT ATTENTION" },
+	{ SSD_KEY_DATA_PROTECT, SS_FATAL|EACCES, "DATA PROTECT" },
+	{ SSD_KEY_BLANK_CHECK, SS_FATAL|ENOSPC, "BLANK CHECK" },
+	{ SSD_KEY_Vendor_Specific, SS_FATAL|EIO, "Vendor Specific" },
+	{ SSD_KEY_COPY_ABORTED, SS_FATAL|EIO, "COPY ABORTED" },
+	{ SSD_KEY_ABORTED_COMMAND, SS_RDEF, "ABORTED COMMAND" },
+	{ SSD_KEY_EQUAL, SS_NOP, "EQUAL" },
+	{ SSD_KEY_VOLUME_OVERFLOW, SS_FATAL|EIO, "VOLUME OVERFLOW" },
+	{ SSD_KEY_MISCOMPARE, SS_NOP, "MISCOMPARE" },
+	{ SSD_KEY_RESERVED, SS_FATAL|EIO, "RESERVED" }
+};
+
+static const int sense_key_table_size =
+    sizeof(sense_key_table)/sizeof(sense_key_table[0]);
+
+static struct asc_table_entry quantum_fireball_entries[] = {
+	{SST(0x04, 0x0b, SS_START|SSQ_DECREMENT_COUNT|ENXIO, 
+	     "Logical unit not ready, initializing cmd. required")}
+};
+
+static struct asc_table_entry sony_mo_entries[] = {
+	{SST(0x04, 0x00, SS_START|SSQ_DECREMENT_COUNT|ENXIO,
+	     "Logical unit not ready, cause not reportable")}
+};
+
+static struct scsi_sense_quirk_entry sense_quirk_table[] = {
+	{
+		/*
+		 * The Quantum Fireball ST and SE like to return 0x04 0x0b when
+		 * they really should return 0x04 0x02.  0x04,0x0b isn't
+		 * defined in any SCSI spec, and it isn't mentioned in the
+		 * hardware manual for these drives.
+		 */
+		{T_DIRECT, SIP_MEDIA_FIXED, "QUANTUM", "FIREBALL S*", "*"},
+		/*num_sense_keys*/0,
+		sizeof(quantum_fireball_entries)/sizeof(struct asc_table_entry),
+		/*sense key entries*/NULL,
+		quantum_fireball_entries
+	},
+	{
+		/*
+		 * This Sony MO drive likes to return 0x04, 0x00 when it
+		 * isn't spun up.
+		 */
+		{T_DIRECT, SIP_MEDIA_REMOVABLE, "SONY", "SMO-*", "*"},
+		/*num_sense_keys*/0,
+		sizeof(sony_mo_entries)/sizeof(struct asc_table_entry),
+		/*sense key entries*/NULL,
+		sony_mo_entries
+	}
+};
+
+static const int sense_quirk_table_size =
+    sizeof(sense_quirk_table)/sizeof(sense_quirk_table[0]);
+
+static struct asc_table_entry asc_table[] = {
+/*
+ * From File: ASC-NUM.TXT
+ * SCSI ASC/ASCQ Assignments
+ * Numeric Sorted Listing
+ * as of  5/12/97
+ *
+ * D - DIRECT ACCESS DEVICE (SBC)                     device column key
+ * .T - SEQUENTIAL ACCESS DEVICE (SSC)               -------------------
+ * . L - PRINTER DEVICE (SSC)                           blank = reserved
+ * .  P - PROCESSOR DEVICE (SPC)                     not blank = allowed
+ * .  .W - WRITE ONCE READ MULTIPLE DEVICE (SBC)
+ * .  . R - CD DEVICE (MMC)
+ * .  .  S - SCANNER DEVICE (SGC)
+ * .  .  .O - OPTICAL MEMORY DEVICE (SBC)
+ * .  .  . M - MEDIA CHANGER DEVICE (SMC)
+ * .  .  .  C - COMMUNICATION DEVICE (SSC)
+ * .  .  .  .A - STORAGE ARRAY DEVICE (SCC)
+ * .  .  .  . E - ENCLOSURE SERVICES DEVICE (SES)
+ * DTLPWRSOMCAE        ASC   ASCQ  Action  Description
+ * ------------        ----  ----  ------  -----------------------------------*/
+/* DTLPWRSOMCAE */{SST(0x00, 0x00, SS_NOP,
+			"No additional sense information") },
+/*  T    S      */{SST(0x00, 0x01, SS_RDEF,
+			"Filemark detected") },
+/*  T    S      */{SST(0x00, 0x02, SS_RDEF,
+			"End-of-partition/medium detected") },
+/*  T           */{SST(0x00, 0x03, SS_RDEF,
+			"Setmark detected") },
+/*  T    S      */{SST(0x00, 0x04, SS_RDEF,
+			"Beginning-of-partition/medium detected") },
+/*  T    S      */{SST(0x00, 0x05, SS_RDEF,
+			"End-of-data detected") },
+/* DTLPWRSOMCAE */{SST(0x00, 0x06, SS_RDEF,
+			"I/O process terminated") },
+/*      R       */{SST(0x00, 0x11, SS_FATAL|EBUSY,
+			"Audio play operation in progress") },
+/*      R       */{SST(0x00, 0x12, SS_NOP,
+			"Audio play operation paused") },
+/*      R       */{SST(0x00, 0x13, SS_NOP,
+			"Audio play operation successfully completed") },
+/*      R       */{SST(0x00, 0x14, SS_RDEF,
+			"Audio play operation stopped due to error") },
+/*      R       */{SST(0x00, 0x15, SS_NOP,
+			"No current audio status to return") },
+/* DTLPWRSOMCAE */{SST(0x00, 0x16, SS_FATAL|EBUSY,
+			"Operation in progress") },
+/* DTL WRSOM AE */{SST(0x00, 0x17, SS_RDEF,
+			"Cleaning requested") },
+/* D   W  O     */{SST(0x01, 0x00, SS_RDEF,
+			"No index/sector signal") },
+/* D   WR OM    */{SST(0x02, 0x00, SS_RDEF,
+			"No seek complete") },
+/* DTL W SO     */{SST(0x03, 0x00, SS_RDEF,
+			"Peripheral device write fault") },
+/*  T           */{SST(0x03, 0x01, SS_RDEF,
+			"No write current") },
+/*  T           */{SST(0x03, 0x02, SS_RDEF,
+			"Excessive write errors") },
+/* DTLPWRSOMCAE */{SST(0x04, 0x00,
+			SS_TUR|SSQ_DELAY|SSQ_MANY|SSQ_DECREMENT_COUNT|EIO,
+			"Logical unit not ready, cause not reportable") },
+/* DTLPWRSOMCAE */{SST(0x04, 0x01,
+			SS_TUR|SSQ_DELAY|SSQ_MANY|SSQ_DECREMENT_COUNT|EBUSY,
+			"Logical unit is in process of becoming ready") },
+/* DTLPWRSOMCAE */{SST(0x04, 0x02, SS_START|SSQ_DECREMENT_COUNT|ENXIO,
+			"Logical unit not ready, initializing cmd. required") },
+/* DTLPWRSOMCAE */{SST(0x04, 0x03, SS_FATAL|ENXIO,
+			"Logical unit not ready, manual intervention required")},
+/* DTL    O     */{SST(0x04, 0x04, SS_FATAL|EBUSY,
+			"Logical unit not ready, format in progress") },
+/* DT  W  OMCA  */{SST(0x04, 0x05, SS_FATAL|EBUSY,
+			"Logical unit not ready, rebuild in progress") },
+/* DT  W  OMCA  */{SST(0x04, 0x06, SS_FATAL|EBUSY,
+			"Logical unit not ready, recalculation in progress") },
+/* DTLPWRSOMCAE */{SST(0x04, 0x07, SS_FATAL|EBUSY,
+			"Logical unit not ready, operation in progress") },
+/*      R       */{SST(0x04, 0x08, SS_FATAL|EBUSY,
+			"Logical unit not ready, long write in progress") },
+/* DTL WRSOMCAE */{SST(0x05, 0x00, SS_RDEF,
+			"Logical unit does not respond to selection") },
+/* D   WR OM    */{SST(0x06, 0x00, SS_RDEF,
+			"No reference position found") },
+/* DTL WRSOM    */{SST(0x07, 0x00, SS_RDEF,
+			"Multiple peripheral devices selected") },
+/* DTL WRSOMCAE */{SST(0x08, 0x00, SS_RDEF,
+			"Logical unit communication failure") },
+/* DTL WRSOMCAE */{SST(0x08, 0x01, SS_RDEF,
+			"Logical unit communication time-out") },
+/* DTL WRSOMCAE */{SST(0x08, 0x02, SS_RDEF,
+			"Logical unit communication parity error") },
+/* DT   R OM    */{SST(0x08, 0x03, SS_RDEF,
+			"Logical unit communication crc error (ultra-dma/32)")},
+/* DT  WR O     */{SST(0x09, 0x00, SS_RDEF,
+			"Track following error") },
+/*     WR O     */{SST(0x09, 0x01, SS_RDEF,
+			"Tracking servo failure") },
+/*     WR O     */{SST(0x09, 0x02, SS_RDEF,
+			"Focus servo failure") },
+/*     WR O     */{SST(0x09, 0x03, SS_RDEF,
+			"Spindle servo failure") },
+/* DT  WR O     */{SST(0x09, 0x04, SS_RDEF,
+			"Head select fault") },
+/* DTLPWRSOMCAE */{SST(0x0A, 0x00, SS_FATAL|ENOSPC,
+			"Error log overflow") },
+/* DTLPWRSOMCAE */{SST(0x0B, 0x00, SS_RDEF,
+			"Warning") },
+/* DTLPWRSOMCAE */{SST(0x0B, 0x01, SS_RDEF,
+			"Specified temperature exceeded") },
+/* DTLPWRSOMCAE */{SST(0x0B, 0x02, SS_RDEF,
+			"Enclosure degraded") },
+/*  T   RS      */{SST(0x0C, 0x00, SS_RDEF,
+			"Write error") },
+/* D   W  O     */{SST(0x0C, 0x01, SS_NOP|SSQ_PRINT_SENSE,
+			"Write error - recovered with auto reallocation") },
+/* D   W  O     */{SST(0x0C, 0x02, SS_RDEF,
+			"Write error - auto reallocation failed") },
+/* D   W  O     */{SST(0x0C, 0x03, SS_RDEF,
+			"Write error - recommend reassignment") },
+/* DT  W  O     */{SST(0x0C, 0x04, SS_RDEF,
+			"Compression check miscompare error") },
+/* DT  W  O     */{SST(0x0C, 0x05, SS_RDEF,
+			"Data expansion occurred during compression") },
+/* DT  W  O     */{SST(0x0C, 0x06, SS_RDEF,
+			"Block not compressible") },
+/*      R       */{SST(0x0C, 0x07, SS_RDEF,
+			"Write error - recovery needed") },
+/*      R       */{SST(0x0C, 0x08, SS_RDEF,
+			"Write error - recovery failed") },
+/*      R       */{SST(0x0C, 0x09, SS_RDEF,
+			"Write error - loss of streaming") },
+/*      R       */{SST(0x0C, 0x0A, SS_RDEF,
+			"Write error - padding blocks added") },
+/* D   W  O     */{SST(0x10, 0x00, SS_RDEF,
+			"ID CRC or ECC error") },
+/* DT  WRSO     */{SST(0x11, 0x00, SS_RDEF,
+			"Unrecovered read error") },
+/* DT  W SO     */{SST(0x11, 0x01, SS_RDEF,
+			"Read retries exhausted") },
+/* DT  W SO     */{SST(0x11, 0x02, SS_RDEF,
+			"Error too long to correct") },
+/* DT  W SO     */{SST(0x11, 0x03, SS_RDEF,
+			"Multiple read errors") },
+/* D   W  O     */{SST(0x11, 0x04, SS_RDEF,
+			"Unrecovered read error - auto reallocate failed") },
+/*     WR O     */{SST(0x11, 0x05, SS_RDEF,
+			"L-EC uncorrectable error") },
+/*     WR O     */{SST(0x11, 0x06, SS_RDEF,
+			"CIRC unrecovered error") },
+/*     W  O     */{SST(0x11, 0x07, SS_RDEF,
+			"Data re-synchronization error") },
+/*  T           */{SST(0x11, 0x08, SS_RDEF,
+			"Incomplete block read") },
+/*  T           */{SST(0x11, 0x09, SS_RDEF,
+			"No gap found") },
+/* DT     O     */{SST(0x11, 0x0A, SS_RDEF,
+			"Miscorrected error") },
+/* D   W  O     */{SST(0x11, 0x0B, SS_RDEF,
+			"Unrecovered read error - recommend reassignment") },
+/* D   W  O     */{SST(0x11, 0x0C, SS_RDEF,
+			"Unrecovered read error - recommend rewrite the data")},
+/* DT  WR O     */{SST(0x11, 0x0D, SS_RDEF,
+			"De-compression CRC error") },
+/* DT  WR O     */{SST(0x11, 0x0E, SS_RDEF,
+			"Cannot decompress using declared algorithm") },
+/*      R       */{SST(0x11, 0x0F, SS_RDEF,
+			"Error reading UPC/EAN number") },
+/*      R       */{SST(0x11, 0x10, SS_RDEF,
+			"Error reading ISRC number") },
+/*      R       */{SST(0x11, 0x11, SS_RDEF,
+			"Read error - loss of streaming") },
+/* D   W  O     */{SST(0x12, 0x00, SS_RDEF,
+			"Address mark not found for id field") },
+/* D   W  O     */{SST(0x13, 0x00, SS_RDEF,
+			"Address mark not found for data field") },
+/* DTL WRSO     */{SST(0x14, 0x00, SS_RDEF,
+			"Recorded entity not found") },
+/* DT  WR O     */{SST(0x14, 0x01, SS_RDEF,
+			"Record not found") },
+/*  T           */{SST(0x14, 0x02, SS_RDEF,
+			"Filemark or setmark not found") },
+/*  T           */{SST(0x14, 0x03, SS_RDEF,
+			"End-of-data not found") },
+/*  T           */{SST(0x14, 0x04, SS_RDEF,
+			"Block sequence error") },
+/* DT  W  O     */{SST(0x14, 0x05, SS_RDEF,
+			"Record not found - recommend reassignment") },
+/* DT  W  O     */{SST(0x14, 0x06, SS_RDEF,
+			"Record not found - data auto-reallocated") },
+/* DTL WRSOM    */{SST(0x15, 0x00, SS_RDEF,
+			"Random positioning error") },
+/* DTL WRSOM    */{SST(0x15, 0x01, SS_RDEF,
+			"Mechanical positioning error") },
+/* DT  WR O     */{SST(0x15, 0x02, SS_RDEF,
+			"Positioning error detected by read of medium") },
+/* D   W  O     */{SST(0x16, 0x00, SS_RDEF,
+			"Data synchronization mark error") },
+/* D   W  O     */{SST(0x16, 0x01, SS_RDEF,
+			"Data sync error - data rewritten") },
+/* D   W  O     */{SST(0x16, 0x02, SS_RDEF,
+			"Data sync error - recommend rewrite") },
+/* D   W  O     */{SST(0x16, 0x03, SS_NOP|SSQ_PRINT_SENSE,
+			"Data sync error - data auto-reallocated") },
+/* D   W  O     */{SST(0x16, 0x04, SS_RDEF,
+			"Data sync error - recommend reassignment") },
+/* DT  WRSO     */{SST(0x17, 0x00, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data with no error correction applied") },
+/* DT  WRSO     */{SST(0x17, 0x01, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data with retries") },
+/* DT  WR O     */{SST(0x17, 0x02, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data with positive head offset") },
+/* DT  WR O     */{SST(0x17, 0x03, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data with negative head offset") },
+/*     WR O     */{SST(0x17, 0x04, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data with retries and/or CIRC applied") },
+/* D   WR O     */{SST(0x17, 0x05, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data using previous sector id") },
+/* D   W  O     */{SST(0x17, 0x06, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data without ECC - data auto-reallocated") },
+/* D   W  O     */{SST(0x17, 0x07, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data without ECC - recommend reassignment")},
+/* D   W  O     */{SST(0x17, 0x08, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data without ECC - recommend rewrite") },
+/* D   W  O     */{SST(0x17, 0x09, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data without ECC - data rewritten") },
+/* D   W  O     */{SST(0x18, 0x00, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data with error correction applied") },
+/* D   WR O     */{SST(0x18, 0x01, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data with error corr. & retries applied") },
+/* D   WR O     */{SST(0x18, 0x02, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data - data auto-reallocated") },
+/*      R       */{SST(0x18, 0x03, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data with CIRC") },
+/*      R       */{SST(0x18, 0x04, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data with L-EC") },
+/* D   WR O     */{SST(0x18, 0x05, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data - recommend reassignment") },
+/* D   WR O     */{SST(0x18, 0x06, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data - recommend rewrite") },
+/* D   W  O     */{SST(0x18, 0x07, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered data with ECC - data rewritten") },
+/* D      O     */{SST(0x19, 0x00, SS_RDEF,
+			"Defect list error") },
+/* D      O     */{SST(0x19, 0x01, SS_RDEF,
+			"Defect list not available") },
+/* D      O     */{SST(0x19, 0x02, SS_RDEF,
+			"Defect list error in primary list") },
+/* D      O     */{SST(0x19, 0x03, SS_RDEF,
+			"Defect list error in grown list") },
+/* DTLPWRSOMCAE */{SST(0x1A, 0x00, SS_RDEF,
+			"Parameter list length error") },
+/* DTLPWRSOMCAE */{SST(0x1B, 0x00, SS_RDEF,
+			"Synchronous data transfer error") },
+/* D      O     */{SST(0x1C, 0x00, SS_RDEF,
+			"Defect list not found") },
+/* D      O     */{SST(0x1C, 0x01, SS_RDEF,
+			"Primary defect list not found") },
+/* D      O     */{SST(0x1C, 0x02, SS_RDEF,
+			"Grown defect list not found") },
+/* D   W  O     */{SST(0x1D, 0x00, SS_FATAL,
+			"Miscompare during verify operation" )},
+/* D   W  O     */{SST(0x1E, 0x00, SS_NOP|SSQ_PRINT_SENSE,
+			"Recovered id with ecc correction") },
+/* D      O     */{SST(0x1F, 0x00, SS_RDEF,
+			"Partial defect list transfer") },
+/* DTLPWRSOMCAE */{SST(0x20, 0x00, SS_FATAL|EINVAL,
+			"Invalid command operation code") },
+/* DT  WR OM    */{SST(0x21, 0x00, SS_FATAL|EINVAL,
+			"Logical block address out of range" )},
+/* DT  WR OM    */{SST(0x21, 0x01, SS_FATAL|EINVAL,
+			"Invalid element address") },
+/* D            */{SST(0x22, 0x00, SS_FATAL|EINVAL,
+			"Illegal function") }, /* Deprecated. Use 20 00, 24 00, or 26 00 instead */
+/* DTLPWRSOMCAE */{SST(0x24, 0x00, SS_FATAL|EINVAL,
+			"Invalid field in CDB") },
+/* DTLPWRSOMCAE */{SST(0x25, 0x00, SS_FATAL|ENXIO,
+			"Logical unit not supported") },
+/* DTLPWRSOMCAE */{SST(0x26, 0x00, SS_FATAL|EINVAL,
+			"Invalid field in parameter list") },
+/* DTLPWRSOMCAE */{SST(0x26, 0x01, SS_FATAL|EINVAL,
+			"Parameter not supported") },
+/* DTLPWRSOMCAE */{SST(0x26, 0x02, SS_FATAL|EINVAL,
+			"Parameter value invalid") },
+/* DTLPWRSOMCAE */{SST(0x26, 0x03, SS_FATAL|EINVAL,
+			"Threshold parameters not supported") },
+/* DTLPWRSOMCAE */{SST(0x26, 0x04, SS_FATAL|EINVAL,
+			"Invalid release of active persistent reservation") },
+/* DT  W  O     */{SST(0x27, 0x00, SS_FATAL|EACCES,
+			"Write protected") },
+/* DT  W  O     */{SST(0x27, 0x01, SS_FATAL|EACCES,
+			"Hardware write protected") },
+/* DT  W  O     */{SST(0x27, 0x02, SS_FATAL|EACCES,
+			"Logical unit software write protected") },
+/*  T           */{SST(0x27, 0x03, SS_FATAL|EACCES,
+			"Associated write protect") },
+/*  T           */{SST(0x27, 0x04, SS_FATAL|EACCES,
+			"Persistent write protect") },
+/*  T           */{SST(0x27, 0x05, SS_FATAL|EACCES,
+			"Permanent write protect") },
+/* DTLPWRSOMCAE */{SST(0x28, 0x00, SS_RDEF,
+			"Not ready to ready change, medium may have changed") },
+/* DTLPWRSOMCAE */{SST(0x28, 0x01, SS_FATAL|ENXIO,
+			"Import or export element accessed") },
+/*
+ * XXX JGibbs - All of these should use the same errno, but I don't think
+ * ENXIO is the correct choice.  Should we borrow from the networking
+ * errnos?  ECONNRESET anyone?
+ */
+/* DTLPWRSOMCAE */{SST(0x29, 0x00, SS_RDEF,
+			"Power on, reset, or bus device reset occurred") },
+/* DTLPWRSOMCAE */{SST(0x29, 0x01, SS_RDEF,
+			"Power on occurred") },
+/* DTLPWRSOMCAE */{SST(0x29, 0x02, SS_RDEF,
+			"Scsi bus reset occurred") },
+/* DTLPWRSOMCAE */{SST(0x29, 0x03, SS_RDEF,
+			"Bus device reset function occurred") },
+/* DTLPWRSOMCAE */{SST(0x29, 0x04, SS_RDEF,
+			"Device internal reset") },
+/* DTLPWRSOMCAE */{SST(0x29, 0x05, SS_RDEF,
+			"Transceiver mode changed to single-ended") },
+/* DTLPWRSOMCAE */{SST(0x29, 0x06, SS_RDEF,
+			"Transceiver mode changed to LVD") },
+/* DTL WRSOMCAE */{SST(0x2A, 0x00, SS_RDEF,
+			"Parameters changed") },
+/* DTL WRSOMCAE */{SST(0x2A, 0x01, SS_RDEF,
+			"Mode parameters changed") },
+/* DTL WRSOMCAE */{SST(0x2A, 0x02, SS_RDEF,
+			"Log parameters changed") },
+/* DTLPWRSOMCAE */{SST(0x2A, 0x03, SS_RDEF,
+			"Reservations preempted") },
+/* DTLPWRSO C   */{SST(0x2B, 0x00, SS_RDEF,
+			"Copy cannot execute since host cannot disconnect") },
+/* DTLPWRSOMCAE */{SST(0x2C, 0x00, SS_RDEF,
+			"Command sequence error") },
+/*       S      */{SST(0x2C, 0x01, SS_RDEF,
+			"Too many windows specified") },
+/*       S      */{SST(0x2C, 0x02, SS_RDEF,
+			"Invalid combination of windows specified") },
+/*      R       */{SST(0x2C, 0x03, SS_RDEF,
+			"Current program area is not empty") },
+/*      R       */{SST(0x2C, 0x04, SS_RDEF,
+			"Current program area is empty") },
+/*  T           */{SST(0x2D, 0x00, SS_RDEF,
+			"Overwrite error on update in place") },
+/* DTLPWRSOMCAE */{SST(0x2F, 0x00, SS_RDEF,
+			"Commands cleared by another initiator") },
+/* DT  WR OM    */{SST(0x30, 0x00, SS_RDEF,
+			"Incompatible medium installed") },
+/* DT  WR O     */{SST(0x30, 0x01, SS_RDEF,
+			"Cannot read medium - unknown format") },
+/* DT  WR O     */{SST(0x30, 0x02, SS_RDEF,
+			"Cannot read medium - incompatible format") },
+/* DT           */{SST(0x30, 0x03, SS_RDEF,
+			"Cleaning cartridge installed") },
+/* DT  WR O     */{SST(0x30, 0x04, SS_RDEF,
+			"Cannot write medium - unknown format") },
+/* DT  WR O     */{SST(0x30, 0x05, SS_RDEF,
+			"Cannot write medium - incompatible format") },
+/* DT  W  O     */{SST(0x30, 0x06, SS_RDEF,
+			"Cannot format medium - incompatible medium") },
+/* DTL WRSOM AE */{SST(0x30, 0x07, SS_RDEF,
+			"Cleaning failure") },
+/*      R       */{SST(0x30, 0x08, SS_RDEF,
+			"Cannot write - application code mismatch") },
+/*      R       */{SST(0x30, 0x09, SS_RDEF,
+			"Current session not fixated for append") },
+/* DT  WR O     */{SST(0x31, 0x00, SS_RDEF,
+			"Medium format corrupted") },
+/* D L  R O     */{SST(0x31, 0x01, SS_RDEF,
+			"Format command failed") },
+/* D   W  O     */{SST(0x32, 0x00, SS_RDEF,
+			"No defect spare location available") },
+/* D   W  O     */{SST(0x32, 0x01, SS_RDEF,
+			"Defect list update failure") },
+/*  T           */{SST(0x33, 0x00, SS_RDEF,
+			"Tape length error") },
+/* DTLPWRSOMCAE */{SST(0x34, 0x00, SS_RDEF,
+			"Enclosure failure") },
+/* DTLPWRSOMCAE */{SST(0x35, 0x00, SS_RDEF,
+			"Enclosure services failure") },
+/* DTLPWRSOMCAE */{SST(0x35, 0x01, SS_RDEF,
+			"Unsupported enclosure function") },
+/* DTLPWRSOMCAE */{SST(0x35, 0x02, SS_RDEF,
+			"Enclosure services unavailable") },
+/* DTLPWRSOMCAE */{SST(0x35, 0x03, SS_RDEF,
+			"Enclosure services transfer failure") },
+/* DTLPWRSOMCAE */{SST(0x35, 0x04, SS_RDEF,
+			"Enclosure services transfer refused") },
+/*   L          */{SST(0x36, 0x00, SS_RDEF,
+			"Ribbon, ink, or toner failure") },
+/* DTL WRSOMCAE */{SST(0x37, 0x00, SS_RDEF,
+			"Rounded parameter") },
+/* DTL WRSOMCAE */{SST(0x39, 0x00, SS_RDEF,
+			"Saving parameters not supported") },
+/* DTL WRSOM    */{SST(0x3A, 0x00, SS_NOP,
+			"Medium not present") },
+/* DT  WR OM    */{SST(0x3A, 0x01, SS_NOP,
+			"Medium not present - tray closed") },
+/* DT  WR OM    */{SST(0x3A, 0x01, SS_NOP,
+			"Medium not present - tray open") },
+/* DT  WR OM    */{SST(0x3A, 0x03, SS_NOP,
+			"Medium not present - Loadable") },
+/* DT  WR OM    */{SST(0x3A, 0x04, SS_NOP,
+			"Medium not present - medium auxiliary "
+			"memory accessible") },
+/* DT  WR OM    */{SST(0x3A, 0xFF, SS_NOP, NULL) },/* Range 0x05->0xFF */
+/*  TL          */{SST(0x3B, 0x00, SS_RDEF,
+			"Sequential positioning error") },
+/*  T           */{SST(0x3B, 0x01, SS_RDEF,
+			"Tape position error at beginning-of-medium") },
+/*  T           */{SST(0x3B, 0x02, SS_RDEF,
+			"Tape position error at end-of-medium") },
+/*   L          */{SST(0x3B, 0x03, SS_RDEF,
+			"Tape or electronic vertical forms unit not ready") },
+/*   L          */{SST(0x3B, 0x04, SS_RDEF,
+			"Slew failure") },
+/*   L          */{SST(0x3B, 0x05, SS_RDEF,
+			"Paper jam") },
+/*   L          */{SST(0x3B, 0x06, SS_RDEF,
+			"Failed to sense top-of-form") },
+/*   L          */{SST(0x3B, 0x07, SS_RDEF,
+			"Failed to sense bottom-of-form") },
+/*  T           */{SST(0x3B, 0x08, SS_RDEF,
+			"Reposition error") },
+/*       S      */{SST(0x3B, 0x09, SS_RDEF,
+			"Read past end of medium") },
+/*       S      */{SST(0x3B, 0x0A, SS_RDEF,
+			"Read past beginning of medium") },
+/*       S      */{SST(0x3B, 0x0B, SS_RDEF,
+			"Position past end of medium") },
+/*  T    S      */{SST(0x3B, 0x0C, SS_RDEF,
+			"Position past beginning of medium") },
+/* DT  WR OM    */{SST(0x3B, 0x0D, SS_FATAL|ENOSPC,
+			"Medium destination element full") },
+/* DT  WR OM    */{SST(0x3B, 0x0E, SS_RDEF,
+			"Medium source element empty") },
+/*      R       */{SST(0x3B, 0x0F, SS_RDEF,
+			"End of medium reached") },
+/* DT  WR OM    */{SST(0x3B, 0x11, SS_RDEF,
+			"Medium magazine not accessible") },
+/* DT  WR OM    */{SST(0x3B, 0x12, SS_RDEF,
+			"Medium magazine removed") },
+/* DT  WR OM    */{SST(0x3B, 0x13, SS_RDEF,
+			"Medium magazine inserted") },
+/* DT  WR OM    */{SST(0x3B, 0x14, SS_RDEF,
+			"Medium magazine locked") },
+/* DT  WR OM    */{SST(0x3B, 0x15, SS_RDEF,
+			"Medium magazine unlocked") },
+/* DTLPWRSOMCAE */{SST(0x3D, 0x00, SS_RDEF,
+			"Invalid bits in identify message") },
+/* DTLPWRSOMCAE */{SST(0x3E, 0x00, SS_RDEF,
+			"Logical unit has not self-configured yet") },
+/* DTLPWRSOMCAE */{SST(0x3E, 0x01, SS_RDEF,
+			"Logical unit failure") },
+/* DTLPWRSOMCAE */{SST(0x3E, 0x02, SS_RDEF,
+			"Timeout on logical unit") },
+/* DTLPWRSOMCAE */{SST(0x3F, 0x00, SS_RDEF,
+			"Target operating conditions have changed") },
+/* DTLPWRSOMCAE */{SST(0x3F, 0x01, SS_RDEF,
+			"Microcode has been changed") },
+/* DTLPWRSOMC   */{SST(0x3F, 0x02, SS_RDEF,
+			"Changed operating definition") },
+/* DTLPWRSOMCAE */{SST(0x3F, 0x03, SS_INQ_REFRESH|SSQ_DECREMENT_COUNT,
+			"Inquiry data has changed") },
+/* DT  WR OMCAE */{SST(0x3F, 0x04, SS_RDEF,
+			"Component device attached") },
+/* DT  WR OMCAE */{SST(0x3F, 0x05, SS_RDEF,
+			"Device identifier changed") },
+/* DT  WR OMCAE */{SST(0x3F, 0x06, SS_RDEF,
+			"Redundancy group created or modified") },
+/* DT  WR OMCAE */{SST(0x3F, 0x07, SS_RDEF,
+			"Redundancy group deleted") },
+/* DT  WR OMCAE */{SST(0x3F, 0x08, SS_RDEF,
+			"Spare created or modified") },
+/* DT  WR OMCAE */{SST(0x3F, 0x09, SS_RDEF,
+			"Spare deleted") },
+/* DT  WR OMCAE */{SST(0x3F, 0x0A, SS_RDEF,
+			"Volume set created or modified") },
+/* DT  WR OMCAE */{SST(0x3F, 0x0B, SS_RDEF,
+			"Volume set deleted") },
+/* DT  WR OMCAE */{SST(0x3F, 0x0C, SS_RDEF,
+			"Volume set deassigned") },
+/* DT  WR OMCAE */{SST(0x3F, 0x0D, SS_RDEF,
+			"Volume set reassigned") },
+/* DTLPWRSOMCAE */{SST(0x3F, 0x0E, SS_RDEF,
+			"Reported luns data has changed") },
+/* DTLPWRSOMCAE */{SST(0x3F, 0x0F, SS_RETRY|SSQ_DECREMENT_COUNT
+				 | SSQ_DELAY_RANDOM|EBUSY,
+			"Echo buffer overwritten") },
+/* DT  WR OM   B*/{SST(0x3F, 0x0F, SS_RDEF, "Medium Loadable") },
+/* DT  WR OM   B*/{SST(0x3F, 0x0F, SS_RDEF,
+			"Medium auxiliary memory accessible") },
+/* D            */{SST(0x40, 0x00, SS_RDEF,
+			"Ram failure") }, /* deprecated - use 40 NN instead */
+/* DTLPWRSOMCAE */{SST(0x40, 0x80, SS_RDEF,
+			"Diagnostic failure: ASCQ = Component ID") },
+/* DTLPWRSOMCAE */{SST(0x40, 0xFF, SS_RDEF|SSQ_RANGE,
+			NULL) },/* Range 0x80->0xFF */
+/* D            */{SST(0x41, 0x00, SS_RDEF,
+			"Data path failure") }, /* deprecated - use 40 NN instead */
+/* D            */{SST(0x42, 0x00, SS_RDEF,
+			"Power-on or self-test failure") }, /* deprecated - use 40 NN instead */
+/* DTLPWRSOMCAE */{SST(0x43, 0x00, SS_RDEF,
+			"Message error") },
+/* DTLPWRSOMCAE */{SST(0x44, 0x00, SS_RDEF,
+			"Internal target failure") },
+/* DTLPWRSOMCAE */{SST(0x45, 0x00, SS_RDEF,
+			"Select or reselect failure") },
+/* DTLPWRSOMC   */{SST(0x46, 0x00, SS_RDEF,
+			"Unsuccessful soft reset") },
+/* DTLPWRSOMCAE */{SST(0x47, 0x00, SS_RDEF|SSQ_FALLBACK,
+			"SCSI parity error") },
+/* DTLPWRSOMCAE */{SST(0x47, 0x01, SS_RDEF|SSQ_FALLBACK,
+			"Data Phase CRC error detected") },
+/* DTLPWRSOMCAE */{SST(0x47, 0x02, SS_RDEF|SSQ_FALLBACK,
+			"SCSI parity error detected during ST data phase") },
+/* DTLPWRSOMCAE */{SST(0x47, 0x03, SS_RDEF|SSQ_FALLBACK,
+			"Information Unit iuCRC error") },
+/* DTLPWRSOMCAE */{SST(0x47, 0x04, SS_RDEF|SSQ_FALLBACK,
+			"Asynchronous information protection error detected") },
+/* DTLPWRSOMCAE */{SST(0x47, 0x05, SS_RDEF|SSQ_FALLBACK,
+			"Protocol server CRC error") },
+/* DTLPWRSOMCAE */{SST(0x48, 0x00, SS_RDEF|SSQ_FALLBACK,
+			"Initiator detected error message received") },
+/* DTLPWRSOMCAE */{SST(0x49, 0x00, SS_RDEF,
+			"Invalid message error") },
+/* DTLPWRSOMCAE */{SST(0x4A, 0x00, SS_RDEF,
+			"Command phase error") },
+/* DTLPWRSOMCAE */{SST(0x4B, 0x00, SS_RDEF,
+			"Data phase error") },
+/* DTLPWRSOMCAE */{SST(0x4C, 0x00, SS_RDEF,
+			"Logical unit failed self-configuration") },
+/* DTLPWRSOMCAE */{SST(0x4D, 0x00, SS_RDEF,
+			"Tagged overlapped commands: ASCQ = Queue tag ID") },
+/* DTLPWRSOMCAE */{SST(0x4D, 0xFF, SS_RDEF|SSQ_RANGE,
+			NULL)}, /* Range 0x00->0xFF */
+/* DTLPWRSOMCAE */{SST(0x4E, 0x00, SS_RDEF,
+			"Overlapped commands attempted") },
+/*  T           */{SST(0x50, 0x00, SS_RDEF,
+			"Write append error") },
+/*  T           */{SST(0x50, 0x01, SS_RDEF,
+			"Write append position error") },
+/*  T           */{SST(0x50, 0x02, SS_RDEF,
+			"Position error related to timing") },
+/*  T     O     */{SST(0x51, 0x00, SS_RDEF,
+			"Erase failure") },
+/*  T           */{SST(0x52, 0x00, SS_RDEF,
+			"Cartridge fault") },
+/* DTL WRSOM    */{SST(0x53, 0x00, SS_RDEF,
+			"Media load or eject failed") },
+/*  T           */{SST(0x53, 0x01, SS_RDEF,
+			"Unload tape failure") },
+/* DT  WR OM    */{SST(0x53, 0x02, SS_RDEF,
+			"Medium removal prevented") },
+/*    P         */{SST(0x54, 0x00, SS_RDEF,
+			"Scsi to host system interface failure") },
+/*    P         */{SST(0x55, 0x00, SS_RDEF,
+			"System resource failure") },
+/* D      O     */{SST(0x55, 0x01, SS_FATAL|ENOSPC,
+			"System buffer full") },
+/*      R       */{SST(0x57, 0x00, SS_RDEF,
+			"Unable to recover table-of-contents") },
+/*        O     */{SST(0x58, 0x00, SS_RDEF,
+			"Generation does not exist") },
+/*        O     */{SST(0x59, 0x00, SS_RDEF,
+			"Updated block read") },
+/* DTLPWRSOM    */{SST(0x5A, 0x00, SS_RDEF,
+			"Operator request or state change input") },
+/* DT  WR OM    */{SST(0x5A, 0x01, SS_RDEF,
+			"Operator medium removal request") },
+/* DT  W  O     */{SST(0x5A, 0x02, SS_RDEF,
+			"Operator selected write protect") },
+/* DT  W  O     */{SST(0x5A, 0x03, SS_RDEF,
+			"Operator selected write permit") },
+/* DTLPWRSOM    */{SST(0x5B, 0x00, SS_RDEF,
+			"Log exception") },
+/* DTLPWRSOM    */{SST(0x5B, 0x01, SS_RDEF,
+			"Threshold condition met") },
+/* DTLPWRSOM    */{SST(0x5B, 0x02, SS_RDEF,
+			"Log counter at maximum") },
+/* DTLPWRSOM    */{SST(0x5B, 0x03, SS_RDEF,
+			"Log list codes exhausted") },
+/* D      O     */{SST(0x5C, 0x00, SS_RDEF,
+			"RPL status change") },
+/* D      O     */{SST(0x5C, 0x01, SS_NOP|SSQ_PRINT_SENSE,
+			"Spindles synchronized") },
+/* D      O     */{SST(0x5C, 0x02, SS_RDEF,
+			"Spindles not synchronized") },
+/* DTLPWRSOMCAE */{SST(0x5D, 0x00, SS_RDEF,
+			"Failure prediction threshold exceeded") },
+/* DTLPWRSOMCAE */{SST(0x5D, 0xFF, SS_RDEF,
+			"Failure prediction threshold exceeded (false)") },
+/* DTLPWRSO CA  */{SST(0x5E, 0x00, SS_RDEF,
+			"Low power condition on") },
+/* DTLPWRSO CA  */{SST(0x5E, 0x01, SS_RDEF,
+			"Idle condition activated by timer") },
+/* DTLPWRSO CA  */{SST(0x5E, 0x02, SS_RDEF,
+			"Standby condition activated by timer") },
+/* DTLPWRSO CA  */{SST(0x5E, 0x03, SS_RDEF,
+			"Idle condition activated by command") },
+/* DTLPWRSO CA  */{SST(0x5E, 0x04, SS_RDEF,
+			"Standby condition activated by command") },
+/*       S      */{SST(0x60, 0x00, SS_RDEF,
+			"Lamp failure") },
+/*       S      */{SST(0x61, 0x00, SS_RDEF,
+			"Video acquisition error") },
+/*       S      */{SST(0x61, 0x01, SS_RDEF,
+			"Unable to acquire video") },
+/*       S      */{SST(0x61, 0x02, SS_RDEF,
+			"Out of focus") },
+/*       S      */{SST(0x62, 0x00, SS_RDEF,
+			"Scan head positioning error") },
+/*      R       */{SST(0x63, 0x00, SS_RDEF,
+			"End of user area encountered on this track") },
+/*      R       */{SST(0x63, 0x01, SS_FATAL|ENOSPC,
+			"Packet does not fit in available space") },
+/*      R       */{SST(0x64, 0x00, SS_RDEF,
+			"Illegal mode for this track") },
+/*      R       */{SST(0x64, 0x01, SS_RDEF,
+			"Invalid packet size") },
+/* DTLPWRSOMCAE */{SST(0x65, 0x00, SS_RDEF,
+			"Voltage fault") },
+/*       S      */{SST(0x66, 0x00, SS_RDEF,
+			"Automatic document feeder cover up") },
+/*       S      */{SST(0x66, 0x01, SS_RDEF,
+			"Automatic document feeder lift up") },
+/*       S      */{SST(0x66, 0x02, SS_RDEF,
+			"Document jam in automatic document feeder") },
+/*       S      */{SST(0x66, 0x03, SS_RDEF,
+			"Document miss feed automatic in document feeder") },
+/*           A  */{SST(0x67, 0x00, SS_RDEF,
+			"Configuration failure") },
+/*           A  */{SST(0x67, 0x01, SS_RDEF,
+			"Configuration of incapable logical units failed") },
+/*           A  */{SST(0x67, 0x02, SS_RDEF,
+			"Add logical unit failed") },
+/*           A  */{SST(0x67, 0x03, SS_RDEF,
+			"Modification of logical unit failed") },
+/*           A  */{SST(0x67, 0x04, SS_RDEF,
+			"Exchange of logical unit failed") },
+/*           A  */{SST(0x67, 0x05, SS_RDEF,
+			"Remove of logical unit failed") },
+/*           A  */{SST(0x67, 0x06, SS_RDEF,
+			"Attachment of logical unit failed") },
+/*           A  */{SST(0x67, 0x07, SS_RDEF,
+			"Creation of logical unit failed") },
+/*           A  */{SST(0x68, 0x00, SS_RDEF,
+			"Logical unit not configured") },
+/*           A  */{SST(0x69, 0x00, SS_RDEF,
+			"Data loss on logical unit") },
+/*           A  */{SST(0x69, 0x01, SS_RDEF,
+			"Multiple logical unit failures") },
+/*           A  */{SST(0x69, 0x02, SS_RDEF,
+			"Parity/data mismatch") },
+/*           A  */{SST(0x6A, 0x00, SS_RDEF,
+			"Informational, refer to log") },
+/*           A  */{SST(0x6B, 0x00, SS_RDEF,
+			"State change has occurred") },
+/*           A  */{SST(0x6B, 0x01, SS_RDEF,
+			"Redundancy level got better") },
+/*           A  */{SST(0x6B, 0x02, SS_RDEF,
+			"Redundancy level got worse") },
+/*           A  */{SST(0x6C, 0x00, SS_RDEF,
+			"Rebuild failure occurred") },
+/*           A  */{SST(0x6D, 0x00, SS_RDEF,
+			"Recalculate failure occurred") },
+/*           A  */{SST(0x6E, 0x00, SS_RDEF,
+			"Command to logical unit failed") },
+/*  T           */{SST(0x70, 0x00, SS_RDEF,
+			"Decompression exception short: ASCQ = Algorithm ID") },
+/*  T           */{SST(0x70, 0xFF, SS_RDEF|SSQ_RANGE,
+			NULL) }, /* Range 0x00 -> 0xFF */
+/*  T           */{SST(0x71, 0x00, SS_RDEF,
+			"Decompression exception long: ASCQ = Algorithm ID") },
+/*  T           */{SST(0x71, 0xFF, SS_RDEF|SSQ_RANGE,
+			NULL) }, /* Range 0x00 -> 0xFF */	
+/*      R       */{SST(0x72, 0x00, SS_RDEF,
+			"Session fixation error") },
+/*      R       */{SST(0x72, 0x01, SS_RDEF,
+			"Session fixation error writing lead-in") },
+/*      R       */{SST(0x72, 0x02, SS_RDEF,
+			"Session fixation error writing lead-out") },
+/*      R       */{SST(0x72, 0x03, SS_RDEF,
+			"Session fixation error - incomplete track in session") },
+/*      R       */{SST(0x72, 0x04, SS_RDEF,
+			"Empty or partially written reserved track") },
+/*      R       */{SST(0x73, 0x00, SS_RDEF,
+			"CD control error") },
+/*      R       */{SST(0x73, 0x01, SS_RDEF,
+			"Power calibration area almost full") },
+/*      R       */{SST(0x73, 0x02, SS_FATAL|ENOSPC,
+			"Power calibration area is full") },
+/*      R       */{SST(0x73, 0x03, SS_RDEF,
+			"Power calibration area error") },
+/*      R       */{SST(0x73, 0x04, SS_RDEF,
+			"Program memory area update failure") },
+/*      R       */{SST(0x73, 0x05, SS_RDEF,
+			"program memory area is full") }
+};
+
+static const int asc_table_size = sizeof(asc_table)/sizeof(asc_table[0]);
+
+struct asc_key
+{
+	int asc;
+	int ascq;
+};
+
+static int
+ascentrycomp(const void *key, const void *member)
+{
+	int asc;
+	int ascq;
+	const struct asc_table_entry *table_entry;
+
+	asc = ((const struct asc_key *)key)->asc;
+	ascq = ((const struct asc_key *)key)->ascq;
+	table_entry = (const struct asc_table_entry *)member;
+
+	if (asc >= table_entry->asc) {
+
+		if (asc > table_entry->asc)
+			return (1);
+
+		if (ascq <= table_entry->ascq) {
+			/* Check for ranges */
+			if (ascq == table_entry->ascq
+		 	 || ((table_entry->action & SSQ_RANGE) != 0
+		  	   && ascq >= (table_entry - 1)->ascq))
+				return (0);
+			return (-1);
+		}
+		return (1);
+	}
+	return (-1);
+}
+
+static int
+senseentrycomp(const void *key, const void *member)
+{
+	int sense_key;
+	const struct sense_key_table_entry *table_entry;
+
+	sense_key = *((const int *)key);
+	table_entry = (const struct sense_key_table_entry *)member;
+
+	if (sense_key >= table_entry->sense_key) {
+		if (sense_key == table_entry->sense_key)
+			return (0);
+		return (1);
+	}
+	return (-1);
+}
+
+static void
+fetchtableentries(int sense_key, int asc, int ascq,
+		  struct scsi_inquiry_data *inq_data,
+		  const struct sense_key_table_entry **sense_entry,
+		  const struct asc_table_entry **asc_entry)
+{
+	void *match;
+	const struct asc_table_entry *asc_tables[2];
+	const struct sense_key_table_entry *sense_tables[2];
+	struct asc_key asc_ascq;
+	size_t asc_tables_size[2];
+	size_t sense_tables_size[2];
+	int num_asc_tables;
+	int num_sense_tables;
+	int i;
+
+	/* Default to failure */
+	*sense_entry = NULL;
+	*asc_entry = NULL;
+	match = NULL;
+	if (inq_data != NULL)
+		match = cam_quirkmatch((void *)inq_data,
+				       (void *)sense_quirk_table,
+				       sense_quirk_table_size,
+				       sizeof(*sense_quirk_table),
+				       aic_inquiry_match);
+
+	if (match != NULL) {
+		struct scsi_sense_quirk_entry *quirk;
+
+		quirk = (struct scsi_sense_quirk_entry *)match;
+		asc_tables[0] = quirk->asc_info;
+		asc_tables_size[0] = quirk->num_ascs;
+		asc_tables[1] = asc_table;
+		asc_tables_size[1] = asc_table_size;
+		num_asc_tables = 2;
+		sense_tables[0] = quirk->sense_key_info;
+		sense_tables_size[0] = quirk->num_sense_keys;
+		sense_tables[1] = sense_key_table;
+		sense_tables_size[1] = sense_key_table_size;
+		num_sense_tables = 2;
+	} else {
+		asc_tables[0] = asc_table;
+		asc_tables_size[0] = asc_table_size;
+		num_asc_tables = 1;
+		sense_tables[0] = sense_key_table;
+		sense_tables_size[0] = sense_key_table_size;
+		num_sense_tables = 1;
+	}
+
+	asc_ascq.asc = asc;
+	asc_ascq.ascq = ascq;
+	for (i = 0; i < num_asc_tables; i++) {
+		void *found_entry;
+
+		found_entry = scsibsearch(&asc_ascq, asc_tables[i],
+					  asc_tables_size[i],
+					  sizeof(**asc_tables),
+					  ascentrycomp);
+
+		if (found_entry) {
+			*asc_entry = (struct asc_table_entry *)found_entry;
+			break;
+		}
+	}
+
+	for (i = 0; i < num_sense_tables; i++) {
+		void *found_entry;
+
+		found_entry = scsibsearch(&sense_key, sense_tables[i],
+					  sense_tables_size[i],
+					  sizeof(**sense_tables),
+					  senseentrycomp);
+
+		if (found_entry) {
+			*sense_entry =
+			    (struct sense_key_table_entry *)found_entry;
+			break;
+		}
+	}
+}
+
+static void *
+scsibsearch(const void *key, const void *base, size_t nmemb, size_t size,
+		 int (*compar)(const void *, const void *))
+{
+	const void *entry;
+	u_int l;
+	u_int u;
+	u_int m;
+
+	l = -1;
+	u = nmemb;
+	while (l + 1 != u) {
+		m = (l + u) / 2;
+		entry = base + m * size;
+		if (compar(key, entry) > 0)
+			l = m;
+		else
+			u = m;
+	}
+
+	entry = base + u * size;
+	if (u == nmemb
+	 || compar(key, entry) != 0)
+		return (NULL);
+
+	return ((void *)entry);
+}
+
+/*
+ * Compare string with pattern, returning 0 on match.
+ * Short pattern matches trailing blanks in name,
+ * wildcard '*' in pattern matches rest of name,
+ * wildcard '?' matches a single non-space character.
+ */
+static int
+cam_strmatch(const uint8_t *str, const uint8_t *pattern, int str_len)
+{
+
+	while (*pattern != '\0'&& str_len > 0) {  
+
+		if (*pattern == '*') {
+			return (0);
+		}
+		if ((*pattern != *str)
+		 && (*pattern != '?' || *str == ' ')) {
+			return (1);
+		}
+		pattern++;
+		str++;
+		str_len--;
+	}
+	while (str_len > 0 && *str++ == ' ')
+		str_len--;
+
+	return (str_len);
+}
+
+static caddr_t
+cam_quirkmatch(caddr_t target, caddr_t quirk_table, int num_entries,
+	       int entry_size, cam_quirkmatch_t *comp_func)
+{
+	for (; num_entries > 0; num_entries--, quirk_table += entry_size) {
+		if ((*comp_func)(target, quirk_table) == 0)
+			return (quirk_table);
+	}
+	return (NULL);
+}
+
+void
+aic_sense_desc(int sense_key, int asc, int ascq,
+	       struct scsi_inquiry_data *inq_data,
+	       const char **sense_key_desc, const char **asc_desc)
+{
+	const struct asc_table_entry *asc_entry;
+	const struct sense_key_table_entry *sense_entry;
+
+	fetchtableentries(sense_key, asc, ascq,
+			  inq_data,
+			  &sense_entry,
+			  &asc_entry);
+
+	*sense_key_desc = sense_entry->desc;
+
+	if (asc_entry != NULL)
+		*asc_desc = asc_entry->desc;
+	else if (asc >= 0x80 && asc <= 0xff)
+		*asc_desc = "Vendor Specific ASC";
+	else if (ascq >= 0x80 && ascq <= 0xff)
+		*asc_desc = "Vendor Specific ASCQ";
+	else
+		*asc_desc = "Reserved ASC/ASCQ pair";
+}
+
+/*
+ * Given sense and device type information, return the appropriate action.
+ * If we do not understand the specific error as identified by the ASC/ASCQ
+ * pair, fall back on the more generic actions derived from the sense key.
+ */
+aic_sense_action
+aic_sense_error_action(struct scsi_sense_data *sense_data,
+		       struct scsi_inquiry_data *inq_data, uint32_t sense_flags)
+{
+	const struct asc_table_entry *asc_entry;
+	const struct sense_key_table_entry *sense_entry;
+	int error_code, sense_key, asc, ascq;
+	aic_sense_action action;
+
+	scsi_extract_sense(sense_data, &error_code, &sense_key, &asc, &ascq);
+
+	if (error_code == SSD_DEFERRED_ERROR) {
+		/*
+		 * XXX dufault@FreeBSD.org
+		 * This error doesn't relate to the command associated
+		 * with this request sense.  A deferred error is an error
+		 * for a command that has already returned GOOD status
+		 * (see SCSI2 8.2.14.2).
+		 *
+		 * By my reading of that section, it looks like the current
+		 * command has been cancelled, we should now clean things up
+		 * (hopefully recovering any lost data) and then retry the
+		 * current command.  There are two easy choices, both wrong:
+		 *
+		 * 1. Drop through (like we had been doing), thus treating
+		 *    this as if the error were for the current command and
+		 *    return and stop the current command.
+		 * 
+		 * 2. Issue a retry (like I made it do) thus hopefully
+		 *    recovering the current transfer, and ignoring the
+		 *    fact that we've dropped a command.
+		 *
+		 * These should probably be handled in a device specific
+		 * sense handler or punted back up to a user mode daemon
+		 */
+		action = SS_RETRY|SSQ_DECREMENT_COUNT|SSQ_PRINT_SENSE;
+	} else {
+		fetchtableentries(sense_key, asc, ascq,
+				  inq_data,
+				  &sense_entry,
+				  &asc_entry);
+
+		/*
+		 * Override the 'No additional Sense' entry (0,0)
+		 * with the error action of the sense key.
+		 */
+		if (asc_entry != NULL
+		 && (asc != 0 || ascq != 0))
+			action = asc_entry->action;
+		else
+			action = sense_entry->action;
+
+		if (sense_key == SSD_KEY_RECOVERED_ERROR) {
+			/*
+			 * The action succeeded but the device wants
+			 * the user to know that some recovery action
+			 * was required.
+			 */
+			action &= ~(SS_MASK|SSQ_MASK|SS_ERRMASK);
+			action |= SS_NOP|SSQ_PRINT_SENSE;
+		} else if (sense_key == SSD_KEY_ILLEGAL_REQUEST) {
+			if ((sense_flags & SF_QUIET_IR) != 0)
+				action &= ~SSQ_PRINT_SENSE;
+		} else if (sense_key == SSD_KEY_UNIT_ATTENTION) {
+			if ((sense_flags & SF_RETRY_UA) != 0
+			 && (action & SS_MASK) == SS_FAIL) {
+				action &= ~(SS_MASK|SSQ_MASK);
+				action |= SS_RETRY|SSQ_DECREMENT_COUNT|
+					  SSQ_PRINT_SENSE;
+			}
+		}
+	}
+
+	if ((sense_flags & SF_PRINT_ALWAYS) != 0)
+		action |= SSQ_PRINT_SENSE;
+	else if ((sense_flags & SF_NO_PRINT) != 0)
+		action &= ~SSQ_PRINT_SENSE;
+
+	return (action);
+}
+
+/*      
+ * Try make as good a match as possible with
+ * available sub drivers
+ */
+int
+aic_inquiry_match(caddr_t inqbuffer, caddr_t table_entry)
+{
+	struct scsi_inquiry_pattern *entry;
+	struct scsi_inquiry_data *inq;
+ 
+	entry = (struct scsi_inquiry_pattern *)table_entry;
+	inq = (struct scsi_inquiry_data *)inqbuffer;
+
+	if (((SID_TYPE(inq) == entry->type)
+	  || (entry->type == T_ANY))
+	 && (SID_IS_REMOVABLE(inq) ? entry->media_type & SIP_MEDIA_REMOVABLE
+				   : entry->media_type & SIP_MEDIA_FIXED)
+	 && (cam_strmatch(inq->vendor, entry->vendor, sizeof(inq->vendor)) == 0)
+	 && (cam_strmatch(inq->product, entry->product,
+			  sizeof(inq->product)) == 0)
+	 && (cam_strmatch(inq->revision, entry->revision,
+			  sizeof(inq->revision)) == 0)) {
+		return (0);
+	}
+        return (-1);
+}
+
+/*
+ * Table of syncrates that don't follow the "divisible by 4"
+ * rule. This table will be expanded in future SCSI specs.
+ */
+static struct {
+	u_int period_factor;
+	u_int period;	/* in 100ths of ns */
+} scsi_syncrates[] = {
+	{ 0x08, 625 },	/* FAST-160 */
+	{ 0x09, 1250 },	/* FAST-80 */
+	{ 0x0a, 2500 },	/* FAST-40 40MHz */
+	{ 0x0b, 3030 },	/* FAST-40 33MHz */
+	{ 0x0c, 5000 }	/* FAST-20 */
+};
+
+/*
+ * Return the frequency in kHz corresponding to the given
+ * sync period factor.
+ */
+u_int
+aic_calc_syncsrate(u_int period_factor)
+{
+	int i;
+	int num_syncrates;
+
+	num_syncrates = sizeof(scsi_syncrates) / sizeof(scsi_syncrates[0]);
+	/* See if the period is in the "exception" table */
+	for (i = 0; i < num_syncrates; i++) {
+
+		if (period_factor == scsi_syncrates[i].period_factor) {
+			/* Period in kHz */
+			return (100000000 / scsi_syncrates[i].period);
+		}
+	}
+
+	/*
+	 * Wasn't in the table, so use the standard
+	 * 4 times conversion.
+	 */
+	return (10000000 / (period_factor * 4 * 10));
+}
+
+/*
+ * Return speed in KB/s.
+ */
+u_int
+aic_calc_speed(u_int width, u_int period, u_int offset, u_int min_rate)
+{
+	u_int freq;
+
+	if (offset != 0 && period < min_rate)
+		freq  = aic_calc_syncsrate(period);
+	else
+		/* Roughly 3.3MB/s for async */
+		freq  = 3300;
+	freq <<= width;
+	return (freq);
+}
+
+uint32_t
+aic_error_action(struct scsi_cmnd *cmd, struct scsi_inquiry_data *inq_data,
+		 cam_status status, u_int scsi_status)
+{
+	aic_sense_action  err_action;
+	int		  sense;
+
+	sense  = (cmd->result >> 24) == DRIVER_SENSE;
+
+	switch (status) {
+	case CAM_REQ_CMP:
+		err_action = SS_NOP;
+		break;
+	case CAM_AUTOSENSE_FAIL:
+	case CAM_SCSI_STATUS_ERROR:
+
+		switch (scsi_status) {
+		case SCSI_STATUS_OK:
+		case SCSI_STATUS_COND_MET:
+		case SCSI_STATUS_INTERMED:
+		case SCSI_STATUS_INTERMED_COND_MET:
+			err_action = SS_NOP;
+			break;
+		case SCSI_STATUS_CMD_TERMINATED:
+		case SCSI_STATUS_CHECK_COND:
+			if (sense != 0) {
+				struct scsi_sense_data *sense;
+
+				sense = (struct scsi_sense_data *)
+				    &cmd->sense_buffer;
+				err_action =
+				    aic_sense_error_action(sense, inq_data, 0);
+
+			} else {
+				err_action = SS_RETRY|SSQ_FALLBACK
+					   | SSQ_DECREMENT_COUNT|EIO;
+			}
+			break;
+		case SCSI_STATUS_QUEUE_FULL:
+		case SCSI_STATUS_BUSY:
+			err_action = SS_RETRY|SSQ_DELAY|SSQ_MANY
+				   | SSQ_DECREMENT_COUNT|EBUSY;
+			break;
+		case SCSI_STATUS_RESERV_CONFLICT:
+		default:
+			err_action = SS_FAIL|EBUSY;
+			break;
+		}
+		break;
+	case CAM_CMD_TIMEOUT:
+	case CAM_REQ_CMP_ERR:
+	case CAM_UNEXP_BUSFREE:
+	case CAM_UNCOR_PARITY:
+	case CAM_DATA_RUN_ERR:
+		err_action = SS_RETRY|SSQ_FALLBACK|EIO;
+		break;
+	case CAM_UA_ABORT:
+	case CAM_UA_TERMIO:
+	case CAM_MSG_REJECT_REC:
+	case CAM_SEL_TIMEOUT:
+		err_action = SS_FAIL|EIO;
+		break;
+	case CAM_REQ_INVALID:
+	case CAM_PATH_INVALID:
+	case CAM_DEV_NOT_THERE:
+	case CAM_NO_HBA:
+	case CAM_PROVIDE_FAIL:
+	case CAM_REQ_TOO_BIG:		
+	case CAM_RESRC_UNAVAIL:
+	case CAM_BUSY:
+	default:
+		/* panic??  These should never occur in our application. */
+		err_action = SS_FAIL|EIO;
+		break;
+	case CAM_SCSI_BUS_RESET:
+	case CAM_BDR_SENT:		
+	case CAM_REQUEUE_REQ:
+		/* Unconditional requeue */
+		err_action = SS_RETRY;
+		break;
+	}
+
+	return (err_action);
+}
+
+char *
+aic_parse_brace_option(char *opt_name, char *opt_arg, char *end, int depth,
+		       aic_option_callback_t *callback, u_long callback_arg)
+{
+	char	*tok_end;
+	char	*tok_end2;
+	int      i;
+	int      instance;
+	int	 targ;
+	int	 done;
+	char	 tok_list[] = {'.', ',', '{', '}', '\0'};
+
+	/* All options use a ':' name/arg separator */
+	if (*opt_arg != ':')
+		return (opt_arg);
+	opt_arg++;
+	instance = -1;
+	targ = -1;
+	done = FALSE;
+	/*
+	 * Restore separator that may be in
+	 * the middle of our option argument.
+	 */
+	tok_end = strchr(opt_arg, '\0');
+	if (tok_end < end)
+		*tok_end = ',';
+	while (!done) {
+		switch (*opt_arg) {
+		case '{':
+			if (instance == -1) {
+				instance = 0;
+			} else {
+				if (depth > 1) {
+					if (targ == -1)
+						targ = 0;
+				} else {
+					printf("Malformed Option %s\n",
+					       opt_name);
+					done = TRUE;
+				}
+			}
+			opt_arg++;
+			break;
+		case '}':
+			if (targ != -1)
+				targ = -1;
+			else if (instance != -1)
+				instance = -1;
+			opt_arg++;
+			break;
+		case ',':
+		case '.':
+			if (instance == -1)
+				done = TRUE;
+			else if (targ >= 0)
+				targ++;
+			else if (instance >= 0)
+				instance++;
+			opt_arg++;
+			break;
+		case '\0':
+			done = TRUE;
+			break;
+		default:
+			tok_end = end;
+			for (i = 0; tok_list[i]; i++) {
+				tok_end2 = strchr(opt_arg, tok_list[i]);
+				if ((tok_end2) && (tok_end2 < tok_end))
+					tok_end = tok_end2;
+			}
+			callback(callback_arg, instance, targ,
+				 simple_strtol(opt_arg, NULL, 0));
+			opt_arg = tok_end;
+			break;
+		}
+	}
+	return (opt_arg);
+}
diff -urNp linux-5720/drivers/scsi/aic7xxx/aiclib.h linux-5730/drivers/scsi/aic7xxx/aiclib.h
--- linux-5720/drivers/scsi/aic7xxx/aiclib.h
+++ linux-5730/drivers/scsi/aic7xxx/aiclib.h
@@ -0,0 +1,1046 @@
+/*
+ * Largely written by Julian Elischer (julian@tfs.com)
+ * for TRW Financial Systems.
+ *
+ * TRW Financial Systems, in accordance with their agreement with Carnegie
+ * Mellon University, makes this software available to CMU to distribute
+ * or use in any manner that they see fit as long as this message is kept with
+ * the software. For this reason TFS also grants any other persons or
+ * organisations permission to use or modify this software.
+ *
+ * TFS supplies this software to be publicly redistributed
+ * on the understanding that TFS is not responsible for the correct
+ * functioning of this software in any circumstances.
+ *
+ * Ported to run under 386BSD by Julian Elischer (julian@tfs.com) Sept 1992
+ *
+ * $FreeBSD: src/sys/cam/scsi/scsi_all.h,v 1.21 2002/10/08 17:12:44 ken Exp $
+ *
+ * Copyright (c) 2003 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id$
+ */
+
+#ifndef	_AICLIB_H
+#define _AICLIB_H
+
+/*
+ * Linux Interrupt Support.
+ */
+#ifndef IRQ_RETVAL
+typedef void irqreturn_t;
+#define	IRQ_RETVAL(x)
+#endif
+
+/*
+ * SCSI command format
+ */
+
+/*
+ * Define dome bits that are in ALL (or a lot of) scsi commands
+ */
+#define SCSI_CTL_LINK		0x01
+#define SCSI_CTL_FLAG		0x02
+#define SCSI_CTL_VENDOR		0xC0
+#define	SCSI_CMD_LUN		0xA0	/* these two should not be needed */
+#define	SCSI_CMD_LUN_SHIFT	5	/* LUN in the cmd is no longer SCSI */
+
+#define SCSI_MAX_CDBLEN		16	/* 
+					 * 16 byte commands are in the 
+					 * SCSI-3 spec 
+					 */
+/* 6byte CDBs special case 0 length to be 256 */
+#define SCSI_CDB6_LEN(len)	((len) == 0 ? 256 : len)
+
+/*
+ * This type defines actions to be taken when a particular sense code is
+ * received.  Right now, these flags are only defined to take up 16 bits,
+ * but can be expanded in the future if necessary.
+ */
+typedef enum {
+	SS_NOP		= 0x000000, /* Do nothing */
+	SS_RETRY	= 0x010000, /* Retry the command */
+	SS_FAIL		= 0x020000, /* Bail out */
+	SS_START	= 0x030000, /* Send a Start Unit command to the device,
+				     * then retry the original command.
+				     */
+	SS_TUR		= 0x040000, /* Send a Test Unit Ready command to the
+				     * device, then retry the original command.
+				     */
+	SS_REQSENSE	= 0x050000, /* Send a RequestSense command to the
+				     * device, then retry the original command.
+				     */
+	SS_INQ_REFRESH	= 0x060000,
+	SS_MASK		= 0xff0000
+} aic_sense_action;
+
+typedef enum {
+	SSQ_NONE		= 0x0000,
+	SSQ_DECREMENT_COUNT	= 0x0100,  /* Decrement the retry count */
+	SSQ_MANY		= 0x0200,  /* send lots of recovery commands */
+	SSQ_RANGE		= 0x0400,  /*
+					    * This table entry represents the
+					    * end of a range of ASCQs that
+					    * have identical error actions
+					    * and text.
+					    */
+	SSQ_PRINT_SENSE		= 0x0800,
+	SSQ_DELAY		= 0x1000,  /* Delay before retry. */
+	SSQ_DELAY_RANDOM	= 0x2000,  /* Randomized delay before retry. */
+	SSQ_FALLBACK		= 0x4000,  /* Do a speed fallback to recover */
+	SSQ_MASK		= 0xff00
+} aic_sense_action_qualifier;
+
+/* Mask for error status values */
+#define SS_ERRMASK	0xff
+
+/* The default, retyable, error action */
+#define SS_RDEF		SS_RETRY|SSQ_DECREMENT_COUNT|SSQ_PRINT_SENSE|EIO
+
+/* The retyable, error action, with table specified error code */
+#define SS_RET		SS_RETRY|SSQ_DECREMENT_COUNT|SSQ_PRINT_SENSE
+
+/* Fatal error action, with table specified error code */
+#define SS_FATAL	SS_FAIL|SSQ_PRINT_SENSE
+
+struct scsi_generic
+{
+	uint8_t opcode;
+	uint8_t bytes[11];
+};
+
+struct scsi_request_sense
+{
+	uint8_t opcode;
+	uint8_t byte2;
+	uint8_t unused[2];
+	uint8_t length;
+	uint8_t control;
+};
+
+struct scsi_test_unit_ready
+{
+	uint8_t opcode;
+	uint8_t byte2;
+	uint8_t unused[3];
+	uint8_t control;
+};
+
+struct scsi_send_diag
+{
+	uint8_t opcode;
+	uint8_t byte2;
+#define	SSD_UOL		0x01
+#define	SSD_DOL		0x02
+#define	SSD_SELFTEST	0x04
+#define	SSD_PF		0x10
+	uint8_t unused[1];
+	uint8_t paramlen[2];
+	uint8_t control;
+};
+
+struct scsi_sense
+{
+	uint8_t opcode;
+	uint8_t byte2;
+	uint8_t unused[2];
+	uint8_t length;
+	uint8_t control;
+};
+
+struct scsi_inquiry
+{
+	uint8_t opcode;
+	uint8_t byte2;
+#define	SI_EVPD 0x01
+	uint8_t page_code;
+	uint8_t reserved;
+	uint8_t length;
+	uint8_t control;
+};
+
+struct scsi_mode_sense_6
+{
+	uint8_t opcode;
+	uint8_t byte2;
+#define	SMS_DBD				0x08
+	uint8_t page;
+#define	SMS_PAGE_CODE 			0x3F
+#define SMS_VENDOR_SPECIFIC_PAGE	0x00
+#define SMS_DISCONNECT_RECONNECT_PAGE	0x02
+#define SMS_PERIPHERAL_DEVICE_PAGE	0x09
+#define SMS_CONTROL_MODE_PAGE		0x0A
+#define SMS_ALL_PAGES_PAGE		0x3F
+#define	SMS_PAGE_CTRL_MASK		0xC0
+#define	SMS_PAGE_CTRL_CURRENT 		0x00
+#define	SMS_PAGE_CTRL_CHANGEABLE 	0x40
+#define	SMS_PAGE_CTRL_DEFAULT 		0x80
+#define	SMS_PAGE_CTRL_SAVED 		0xC0
+	uint8_t unused;
+	uint8_t length;
+	uint8_t control;
+};
+
+struct scsi_mode_sense_10
+{
+	uint8_t opcode;
+	uint8_t byte2;		/* same bits as small version */
+	uint8_t page; 		/* same bits as small version */
+	uint8_t unused[4];
+	uint8_t length[2];
+	uint8_t control;
+};
+
+struct scsi_mode_select_6
+{
+	uint8_t opcode;
+	uint8_t byte2;
+#define	SMS_SP	0x01
+#define	SMS_PF	0x10
+	uint8_t unused[2];
+	uint8_t length;
+	uint8_t control;
+};
+
+struct scsi_mode_select_10
+{
+	uint8_t opcode;
+	uint8_t byte2;		/* same bits as small version */
+	uint8_t unused[5];
+	uint8_t length[2];
+	uint8_t control;
+};
+
+/*
+ * When sending a mode select to a tape drive, the medium type must be 0.
+ */
+struct scsi_mode_hdr_6
+{
+	uint8_t datalen;
+	uint8_t medium_type;
+	uint8_t dev_specific;
+	uint8_t block_descr_len;
+};
+
+struct scsi_mode_hdr_10
+{
+	uint8_t datalen[2];
+	uint8_t medium_type;
+	uint8_t dev_specific;
+	uint8_t reserved[2];
+	uint8_t block_descr_len[2];
+};
+
+struct scsi_mode_block_descr
+{
+	uint8_t density_code;
+	uint8_t num_blocks[3];
+	uint8_t reserved;
+	uint8_t block_len[3];
+};
+
+struct scsi_log_sense
+{
+	uint8_t opcode;
+	uint8_t byte2;
+#define	SLS_SP				0x01
+#define	SLS_PPC				0x02
+	uint8_t page;
+#define	SLS_PAGE_CODE 			0x3F
+#define	SLS_ALL_PAGES_PAGE		0x00
+#define	SLS_OVERRUN_PAGE		0x01
+#define	SLS_ERROR_WRITE_PAGE		0x02
+#define	SLS_ERROR_READ_PAGE		0x03
+#define	SLS_ERROR_READREVERSE_PAGE	0x04
+#define	SLS_ERROR_VERIFY_PAGE		0x05
+#define	SLS_ERROR_NONMEDIUM_PAGE	0x06
+#define	SLS_ERROR_LASTN_PAGE		0x07
+#define	SLS_PAGE_CTRL_MASK		0xC0
+#define	SLS_PAGE_CTRL_THRESHOLD		0x00
+#define	SLS_PAGE_CTRL_CUMULATIVE	0x40
+#define	SLS_PAGE_CTRL_THRESH_DEFAULT	0x80
+#define	SLS_PAGE_CTRL_CUMUL_DEFAULT	0xC0
+	uint8_t reserved[2];
+	uint8_t paramptr[2];
+	uint8_t length[2];
+	uint8_t control;
+};
+
+struct scsi_log_select
+{
+	uint8_t opcode;
+	uint8_t byte2;
+/*	SLS_SP				0x01 */
+#define	SLS_PCR				0x02
+	uint8_t page;
+/*	SLS_PAGE_CTRL_MASK		0xC0 */
+/*	SLS_PAGE_CTRL_THRESHOLD		0x00 */
+/*	SLS_PAGE_CTRL_CUMULATIVE	0x40 */
+/*	SLS_PAGE_CTRL_THRESH_DEFAULT	0x80 */
+/*	SLS_PAGE_CTRL_CUMUL_DEFAULT	0xC0 */
+	uint8_t reserved[4];
+	uint8_t length[2];
+	uint8_t control;
+};
+
+struct scsi_log_header
+{
+	uint8_t page;
+	uint8_t reserved;
+	uint8_t datalen[2];
+};
+
+struct scsi_log_param_header {
+	uint8_t param_code[2];
+	uint8_t param_control;
+#define	SLP_LP				0x01
+#define	SLP_LBIN			0x02
+#define	SLP_TMC_MASK			0x0C
+#define	SLP_TMC_ALWAYS			0x00
+#define	SLP_TMC_EQUAL			0x04
+#define	SLP_TMC_NOTEQUAL		0x08
+#define	SLP_TMC_GREATER			0x0C
+#define	SLP_ETC				0x10
+#define	SLP_TSD				0x20
+#define	SLP_DS				0x40
+#define	SLP_DU				0x80
+	uint8_t param_len;
+};
+
+struct scsi_control_page {
+	uint8_t page_code;
+	uint8_t page_length;
+	uint8_t rlec;
+#define SCB_RLEC			0x01	/*Report Log Exception Cond*/
+	uint8_t queue_flags;
+#define SCP_QUEUE_ALG_MASK		0xF0
+#define SCP_QUEUE_ALG_RESTRICTED	0x00
+#define SCP_QUEUE_ALG_UNRESTRICTED	0x10
+#define SCP_QUEUE_ERR			0x02	/*Queued I/O aborted for CACs*/
+#define SCP_QUEUE_DQUE			0x01	/*Queued I/O disabled*/
+	uint8_t eca_and_aen;
+#define SCP_EECA			0x80	/*Enable Extended CA*/
+#define SCP_RAENP			0x04	/*Ready AEN Permission*/
+#define SCP_UAAENP			0x02	/*UA AEN Permission*/
+#define SCP_EAENP			0x01	/*Error AEN Permission*/
+	uint8_t reserved;
+	uint8_t aen_holdoff_period[2];
+};
+
+struct scsi_reserve
+{
+	uint8_t opcode;
+	uint8_t byte2;
+	uint8_t unused[2];
+	uint8_t length;
+	uint8_t control;
+};
+
+struct scsi_release
+{
+	uint8_t opcode;
+	uint8_t byte2;
+	uint8_t unused[2];
+	uint8_t length;
+	uint8_t control;
+};
+
+struct scsi_prevent
+{
+	uint8_t opcode;
+	uint8_t byte2;
+	uint8_t unused[2];
+	uint8_t how;
+	uint8_t control;
+};
+#define	PR_PREVENT 0x01
+#define PR_ALLOW   0x00
+
+struct scsi_sync_cache
+{
+	uint8_t opcode;
+	uint8_t byte2;
+	uint8_t begin_lba[4];
+	uint8_t reserved;
+	uint8_t lb_count[2];
+	uint8_t control;	
+};
+
+
+struct scsi_changedef
+{
+	uint8_t opcode;
+	uint8_t byte2;
+	uint8_t unused1;
+	uint8_t how;
+	uint8_t unused[4];
+	uint8_t datalen;
+	uint8_t control;
+};
+
+struct scsi_read_buffer
+{
+	uint8_t opcode;
+	uint8_t byte2;
+#define	RWB_MODE		0x07
+#define	RWB_MODE_HDR_DATA	0x00
+#define	RWB_MODE_DATA		0x02
+#define	RWB_MODE_DOWNLOAD	0x04
+#define	RWB_MODE_DOWNLOAD_SAVE	0x05
+        uint8_t buffer_id;
+        uint8_t offset[3];
+        uint8_t length[3];
+        uint8_t control;
+};
+
+struct scsi_write_buffer
+{
+	uint8_t opcode;
+	uint8_t byte2;
+	uint8_t buffer_id;
+	uint8_t offset[3];
+	uint8_t length[3];
+	uint8_t control;
+};
+
+struct scsi_rw_6
+{
+	uint8_t opcode;
+	uint8_t addr[3];
+/* only 5 bits are valid in the MSB address byte */
+#define	SRW_TOPADDR	0x1F
+	uint8_t length;
+	uint8_t control;
+};
+
+struct scsi_rw_10
+{
+	uint8_t opcode;
+#define	SRW10_RELADDR	0x01
+#define SRW10_FUA	0x08
+#define	SRW10_DPO	0x10
+	uint8_t byte2;
+	uint8_t addr[4];
+	uint8_t reserved;
+	uint8_t length[2];
+	uint8_t control;
+};
+
+struct scsi_rw_12
+{
+	uint8_t opcode;
+#define	SRW12_RELADDR	0x01
+#define SRW12_FUA	0x08
+#define	SRW12_DPO	0x10
+	uint8_t byte2;
+	uint8_t addr[4];
+	uint8_t length[4];
+	uint8_t reserved;
+	uint8_t control;
+};
+
+struct scsi_start_stop_unit
+{
+	uint8_t opcode;
+	uint8_t byte2;
+#define	SSS_IMMED		0x01
+	uint8_t reserved[2];
+	uint8_t how;
+#define	SSS_START		0x01
+#define	SSS_LOEJ		0x02
+	uint8_t control;
+};
+
+#define SC_SCSI_1 0x01
+#define SC_SCSI_2 0x03
+
+/*
+ * Opcodes
+ */
+
+#define	TEST_UNIT_READY		0x00
+#define REQUEST_SENSE		0x03
+#define	READ_6			0x08
+#define WRITE_6			0x0a
+#define INQUIRY			0x12
+#define MODE_SELECT_6		0x15
+#define MODE_SENSE_6		0x1a
+#define START_STOP_UNIT		0x1b
+#define START_STOP		0x1b
+#define RESERVE      		0x16
+#define RELEASE      		0x17
+#define	RECEIVE_DIAGNOSTIC	0x1c
+#define	SEND_DIAGNOSTIC		0x1d
+#define PREVENT_ALLOW		0x1e
+#define	READ_CAPACITY		0x25
+#define	READ_10			0x28
+#define WRITE_10		0x2a
+#define POSITION_TO_ELEMENT	0x2b
+#define	SYNCHRONIZE_CACHE	0x35
+#define	WRITE_BUFFER            0x3b
+#define	READ_BUFFER             0x3c
+#define	CHANGE_DEFINITION	0x40
+#define	LOG_SELECT		0x4c
+#define	LOG_SENSE		0x4d
+#ifdef XXXCAM
+#define	MODE_SENSE_10		0x5A
+#endif
+#define	MODE_SELECT_10		0x55
+#define MOVE_MEDIUM     	0xa5
+#define READ_12			0xa8
+#define WRITE_12		0xaa
+#define READ_ELEMENT_STATUS	0xb8
+
+
+/*
+ * Device Types
+ */
+#define T_DIRECT	0x00
+#define T_SEQUENTIAL	0x01
+#define T_PRINTER	0x02
+#define T_PROCESSOR	0x03
+#define T_WORM		0x04
+#define T_CDROM		0x05
+#define T_SCANNER 	0x06
+#define T_OPTICAL 	0x07
+#define T_CHANGER	0x08
+#define T_COMM		0x09
+#define T_ASC0		0x0a
+#define T_ASC1		0x0b
+#define	T_STORARRAY	0x0c
+#define	T_ENCLOSURE	0x0d
+#define	T_RBC		0x0e
+#define	T_OCRW		0x0f
+#define T_NODEVICE	0x1F
+#define	T_ANY		0xFF	/* Used in Quirk table matches */
+
+#define T_REMOV		1
+#define	T_FIXED		0
+
+/*
+ * This length is the initial inquiry length used by the probe code, as    
+ * well as the legnth necessary for aic_print_inquiry() to function 
+ * correctly.  If either use requires a different length in the future, 
+ * the two values should be de-coupled.
+ */
+#define	SHORT_INQUIRY_LENGTH	36
+
+struct scsi_inquiry_data
+{
+	uint8_t device;
+#define	SID_TYPE(inq_data) ((inq_data)->device & 0x1f)
+#define	SID_QUAL(inq_data) (((inq_data)->device & 0xE0) >> 5)
+#define	SID_QUAL_LU_CONNECTED	0x00	/*
+					 * The specified peripheral device
+					 * type is currently connected to
+					 * logical unit.  If the target cannot
+					 * determine whether or not a physical
+					 * device is currently connected, it
+					 * shall also use this peripheral
+					 * qualifier when returning the INQUIRY
+					 * data.  This peripheral qualifier
+					 * does not mean that the device is
+					 * ready for access by the initiator.
+					 */
+#define	SID_QUAL_LU_OFFLINE	0x01	/*
+					 * The target is capable of supporting
+					 * the specified peripheral device type
+					 * on this logical unit; however, the
+					 * physical device is not currently
+					 * connected to this logical unit.
+					 */
+#define SID_QUAL_RSVD		0x02
+#define	SID_QUAL_BAD_LU		0x03	/*
+					 * The target is not capable of
+					 * supporting a physical device on
+					 * this logical unit. For this
+					 * peripheral qualifier the peripheral
+					 * device type shall be set to 1Fh to
+					 * provide compatibility with previous
+					 * versions of SCSI. All other
+					 * peripheral device type values are
+					 * reserved for this peripheral
+					 * qualifier.
+					 */
+#define	SID_QUAL_IS_VENDOR_UNIQUE(inq_data) ((SID_QUAL(inq_data) & 0x08) != 0)
+	uint8_t dev_qual2;
+#define	SID_QUAL2	0x7F
+#define	SID_IS_REMOVABLE(inq_data) (((inq_data)->dev_qual2 & 0x80) != 0)
+	uint8_t version;
+#define SID_ANSI_REV(inq_data) ((inq_data)->version & 0x07)
+#define		SCSI_REV_0		0
+#define		SCSI_REV_CCS		1
+#define		SCSI_REV_2		2
+#define		SCSI_REV_SPC		3
+#define		SCSI_REV_SPC2		4
+
+#define SID_ECMA	0x38
+#define SID_ISO		0xC0
+	uint8_t response_format;
+#define SID_AENC	0x80
+#define SID_TrmIOP	0x40
+	uint8_t additional_length;
+	uint8_t reserved[2];
+	uint8_t flags;
+#define	SID_SftRe	0x01
+#define	SID_CmdQue	0x02
+#define	SID_Linked	0x08
+#define	SID_Sync	0x10
+#define	SID_WBus16	0x20
+#define	SID_WBus32	0x40
+#define	SID_RelAdr	0x80
+#define SID_VENDOR_SIZE   8
+	char	 vendor[SID_VENDOR_SIZE];
+#define SID_PRODUCT_SIZE  16
+	char	 product[SID_PRODUCT_SIZE];
+#define SID_REVISION_SIZE 4
+	char	 revision[SID_REVISION_SIZE];
+	/*
+	 * The following fields were taken from SCSI Primary Commands - 2
+	 * (SPC-2) Revision 14, Dated 11 November 1999
+	 */
+#define	SID_VENDOR_SPECIFIC_0_SIZE	20
+	uint8_t vendor_specific0[SID_VENDOR_SPECIFIC_0_SIZE];
+	/*
+	 * An extension of SCSI Parallel Specific Values
+	 */
+#define	SID_SPI_IUS		0x01
+#define	SID_SPI_QAS		0x02
+#define	SID_SPI_CLOCK_ST	0x00
+#define	SID_SPI_CLOCK_DT	0x04
+#define	SID_SPI_CLOCK_DT_ST	0x0C
+#define	SID_SPI_MASK		0x0F
+	uint8_t spi3data;
+	uint8_t reserved2;
+	/*
+	 * Version Descriptors, stored 2 byte values.
+	 */
+	uint8_t version1[2];
+	uint8_t version2[2];
+	uint8_t version3[2];
+	uint8_t version4[2];
+	uint8_t version5[2];
+	uint8_t version6[2];
+	uint8_t version7[2];
+	uint8_t version8[2];
+
+	uint8_t reserved3[22];
+
+#define	SID_VENDOR_SPECIFIC_1_SIZE	160
+	uint8_t vendor_specific1[SID_VENDOR_SPECIFIC_1_SIZE];
+};
+
+struct scsi_vpd_unit_serial_number
+{
+	uint8_t device;
+	uint8_t page_code;
+#define SVPD_UNIT_SERIAL_NUMBER	0x80
+	uint8_t reserved;
+	uint8_t length; /* serial number length */
+#define SVPD_SERIAL_NUM_SIZE 251
+	uint8_t serial_num[SVPD_SERIAL_NUM_SIZE];
+};
+
+struct scsi_read_capacity
+{
+	uint8_t opcode;
+	uint8_t byte2;
+	uint8_t addr[4];
+	uint8_t unused[3];
+	uint8_t control;
+};
+
+struct scsi_read_capacity_data
+{
+	uint8_t addr[4];
+	uint8_t length[4];
+};
+
+struct scsi_report_luns
+{
+	uint8_t opcode;
+	uint8_t byte2;
+	uint8_t unused[3];
+	uint8_t addr[4];
+	uint8_t control;
+};
+
+struct scsi_report_luns_data {
+	uint8_t length[4];	/* length of LUN inventory, in bytes */
+	uint8_t reserved[4];	/* unused */
+	/*
+	 * LUN inventory- we only support the type zero form for now.
+	 */
+	struct {
+		uint8_t lundata[8];
+	} luns[1];
+};
+#define	RPL_LUNDATA_ATYP_MASK	0xc0	/* MBZ for type 0 lun */
+#define	RPL_LUNDATA_T0LUN	1	/* @ lundata[1] */
+
+
+struct scsi_sense_data
+{
+	uint8_t error_code;
+#define	SSD_ERRCODE			0x7F
+#define		SSD_CURRENT_ERROR	0x70
+#define		SSD_DEFERRED_ERROR	0x71
+#define	SSD_ERRCODE_VALID	0x80	
+	uint8_t segment;
+	uint8_t flags;
+#define	SSD_KEY				0x0F
+#define		SSD_KEY_NO_SENSE	0x00
+#define		SSD_KEY_RECOVERED_ERROR	0x01
+#define		SSD_KEY_NOT_READY	0x02
+#define		SSD_KEY_MEDIUM_ERROR	0x03
+#define		SSD_KEY_HARDWARE_ERROR	0x04
+#define		SSD_KEY_ILLEGAL_REQUEST	0x05
+#define		SSD_KEY_UNIT_ATTENTION	0x06
+#define		SSD_KEY_DATA_PROTECT	0x07
+#define		SSD_KEY_BLANK_CHECK	0x08
+#define		SSD_KEY_Vendor_Specific	0x09
+#define		SSD_KEY_COPY_ABORTED	0x0a
+#define		SSD_KEY_ABORTED_COMMAND	0x0b		
+#define		SSD_KEY_EQUAL		0x0c
+#define		SSD_KEY_VOLUME_OVERFLOW	0x0d
+#define		SSD_KEY_MISCOMPARE	0x0e
+#define		SSD_KEY_RESERVED	0x0f			
+#define	SSD_ILI		0x20
+#define	SSD_EOM		0x40
+#define	SSD_FILEMARK	0x80
+	uint8_t info[4];
+	uint8_t extra_len;
+	uint8_t cmd_spec_info[4];
+	uint8_t add_sense_code;
+	uint8_t add_sense_code_qual;
+	uint8_t fru;
+	uint8_t sense_key_spec[3];
+#define	SSD_SCS_VALID		0x80
+#define SSD_FIELDPTR_CMD	0x40
+#define SSD_BITPTR_VALID	0x08
+#define SSD_BITPTR_VALUE	0x07
+#define SSD_MIN_SIZE 18
+	uint8_t extra_bytes[14];
+#define SSD_FULL_SIZE sizeof(struct scsi_sense_data)
+};
+
+struct scsi_mode_header_6
+{
+	uint8_t data_length;	/* Sense data length */
+	uint8_t medium_type;
+	uint8_t dev_spec;
+	uint8_t blk_desc_len;
+};
+
+struct scsi_mode_header_10
+{
+	uint8_t data_length[2];/* Sense data length */
+	uint8_t medium_type;
+	uint8_t dev_spec;
+	uint8_t unused[2];
+	uint8_t blk_desc_len[2];
+};
+
+struct scsi_mode_page_header
+{
+	uint8_t page_code;
+	uint8_t page_length;
+};
+
+struct scsi_mode_blk_desc
+{
+	uint8_t density;
+	uint8_t nblocks[3];
+	uint8_t reserved;
+	uint8_t blklen[3];
+};
+
+#define	SCSI_DEFAULT_DENSITY	0x00	/* use 'default' density */
+#define	SCSI_SAME_DENSITY	0x7f	/* use 'same' density- >= SCSI-2 only */
+
+
+/*
+ * Status Byte
+ */
+#define	SCSI_STATUS_OK			0x00
+#define	SCSI_STATUS_CHECK_COND		0x02
+#define	SCSI_STATUS_COND_MET		0x04
+#define	SCSI_STATUS_BUSY		0x08
+#define SCSI_STATUS_INTERMED		0x10
+#define SCSI_STATUS_INTERMED_COND_MET	0x14
+#define SCSI_STATUS_RESERV_CONFLICT	0x18
+#define SCSI_STATUS_CMD_TERMINATED	0x22	/* Obsolete in SAM-2 */
+#define SCSI_STATUS_QUEUE_FULL		0x28
+#define SCSI_STATUS_ACA_ACTIVE		0x30
+#define SCSI_STATUS_TASK_ABORTED	0x40
+
+struct scsi_inquiry_pattern {
+	uint8_t   type;
+	uint8_t   media_type;
+#define	SIP_MEDIA_REMOVABLE	0x01
+#define	SIP_MEDIA_FIXED		0x02
+	const char *vendor;
+	const char *product;
+	const char *revision;
+}; 
+
+struct scsi_static_inquiry_pattern {
+	uint8_t   type;
+	uint8_t   media_type;
+	char       vendor[SID_VENDOR_SIZE+1];
+	char       product[SID_PRODUCT_SIZE+1];
+	char       revision[SID_REVISION_SIZE+1];
+};
+
+struct scsi_sense_quirk_entry {
+	struct scsi_inquiry_pattern	inq_pat;
+	int				num_sense_keys;
+	int				num_ascs;
+	struct sense_key_table_entry	*sense_key_info;
+	struct asc_table_entry		*asc_info;
+};
+
+struct sense_key_table_entry {
+	uint8_t    sense_key;
+	uint32_t   action;
+	const char *desc;
+};
+
+struct asc_table_entry {
+	uint8_t    asc;
+	uint8_t    ascq;
+	uint32_t   action;
+	const char *desc;
+};
+
+struct op_table_entry {
+	uint8_t    opcode;
+	uint16_t   opmask;
+	const char  *desc;
+};
+
+struct scsi_op_quirk_entry {
+	struct scsi_inquiry_pattern	inq_pat;
+	int				num_ops;
+	struct op_table_entry		*op_table;
+};
+
+typedef enum {
+	SSS_FLAG_NONE		= 0x00,
+	SSS_FLAG_PRINT_COMMAND	= 0x01
+} scsi_sense_string_flags;
+
+extern const char *scsi_sense_key_text[];
+
+/************************* Large Disk Handling ********************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static __inline int aic_sector_div(u_long capacity, int heads, int sectors);
+
+static __inline int
+aic_sector_div(u_long capacity, int heads, int sectors)
+{
+	return (capacity / (heads * sectors));
+}
+#else
+static __inline int aic_sector_div(sector_t capacity, int heads, int sectors);
+
+static __inline int
+aic_sector_div(sector_t capacity, int heads, int sectors)
+{
+	/* ugly, ugly sector_div calling convention.. */
+	sector_div(capacity, (heads * sectors));
+	return (int)capacity;
+}
+#endif
+
+/**************************** Module Library Hack *****************************/
+/*
+ * What we'd like to do is have a single "scsi library" module that both the
+ * aic7xxx and aic79xx drivers could load and depend on.  A cursory examination
+ * of implementing module dependencies in Linux (handling the install and
+ * initrd cases) does not look promissing.  For now, we just duplicate this
+ * code in both drivers using a simple symbol renaming scheme that hides this
+ * hack from the drivers.
+ */
+#define AIC_LIB_ENTRY_CONCAT(x, prefix)	prefix ## x
+#define	AIC_LIB_ENTRY_EXPAND(x, prefix) AIC_LIB_ENTRY_CONCAT(x, prefix)
+#define AIC_LIB_ENTRY(x)		AIC_LIB_ENTRY_EXPAND(x, AIC_LIB_PREFIX)
+
+#define	aic_sense_desc			AIC_LIB_ENTRY(_sense_desc)
+#define	aic_sense_error_action		AIC_LIB_ENTRY(_sense_error_action)
+#define	aic_error_action		AIC_LIB_ENTRY(_error_action)
+#define	aic_op_desc			AIC_LIB_ENTRY(_op_desc)
+#define	aic_cdb_string			AIC_LIB_ENTRY(_cdb_string)
+#define aic_print_inquiry		AIC_LIB_ENTRY(_print_inquiry)
+#define aic_calc_syncsrate		AIC_LIB_ENTRY(_calc_syncrate)
+#define	aic_calc_syncparam		AIC_LIB_ENTRY(_calc_syncparam)
+#define	aic_calc_speed			AIC_LIB_ENTRY(_calc_speed)
+#define	aic_inquiry_match		AIC_LIB_ENTRY(_inquiry_match)
+#define	aic_static_inquiry_match	AIC_LIB_ENTRY(_static_inquiry_match)
+#define	aic_parse_brace_option		AIC_LIB_ENTRY(_parse_brace_option)
+
+/******************************************************************************/
+
+void			aic_sense_desc(int /*sense_key*/, int /*asc*/,
+				       int /*ascq*/, struct scsi_inquiry_data*,
+				       const char** /*sense_key_desc*/,
+				       const char** /*asc_desc*/);
+aic_sense_action	aic_sense_error_action(struct scsi_sense_data*,
+					       struct scsi_inquiry_data*,
+					       uint32_t /*sense_flags*/);
+uint32_t		aic_error_action(struct scsi_cmnd *,
+					 struct scsi_inquiry_data *,
+					 cam_status, u_int);
+
+#define	SF_RETRY_UA	0x01
+#define SF_NO_PRINT	0x02
+#define SF_QUIET_IR	0x04	/* Be quiet about Illegal Request reponses */
+#define SF_PRINT_ALWAYS	0x08
+
+
+const char *	aic_op_desc(uint16_t /*opcode*/, struct scsi_inquiry_data*);
+char *		aic_cdb_string(uint8_t* /*cdb_ptr*/, char* /*cdb_string*/,
+			       size_t /*len*/);
+void		aic_print_inquiry(struct scsi_inquiry_data*);
+
+u_int		aic_calc_syncsrate(u_int /*period_factor*/);
+u_int		aic_calc_syncparam(u_int /*period*/);
+u_int		aic_calc_speed(u_int width, u_int period, u_int offset,
+			       u_int min_rate);
+	
+int		aic_inquiry_match(caddr_t /*inqbuffer*/,
+				  caddr_t /*table_entry*/);
+int		aic_static_inquiry_match(caddr_t /*inqbuffer*/,
+					 caddr_t /*table_entry*/);
+
+typedef void aic_option_callback_t(u_long, int, int, int32_t);
+char *		aic_parse_brace_option(char *opt_name, char *opt_arg,
+				       char *end, int depth,
+				       aic_option_callback_t *, u_long);
+
+static __inline void	 scsi_extract_sense(struct scsi_sense_data *sense,
+					    int *error_code, int *sense_key,
+					    int *asc, int *ascq);
+static __inline void	 scsi_ulto2b(uint32_t val, uint8_t *bytes);
+static __inline void	 scsi_ulto3b(uint32_t val, uint8_t *bytes);
+static __inline void	 scsi_ulto4b(uint32_t val, uint8_t *bytes);
+static __inline uint32_t scsi_2btoul(uint8_t *bytes);
+static __inline uint32_t scsi_3btoul(uint8_t *bytes);
+static __inline int32_t	 scsi_3btol(uint8_t *bytes);
+static __inline uint32_t scsi_4btoul(uint8_t *bytes);
+
+static __inline void scsi_extract_sense(struct scsi_sense_data *sense,
+				       int *error_code, int *sense_key,
+				       int *asc, int *ascq)
+{
+	*error_code = sense->error_code & SSD_ERRCODE;
+	*sense_key = sense->flags & SSD_KEY;
+	*asc = (sense->extra_len >= 5) ? sense->add_sense_code : 0;
+	*ascq = (sense->extra_len >= 6) ? sense->add_sense_code_qual : 0;
+}
+
+static __inline void
+scsi_ulto2b(uint32_t val, uint8_t *bytes)
+{
+
+	bytes[0] = (val >> 8) & 0xff;
+	bytes[1] = val & 0xff;
+}
+
+static __inline void
+scsi_ulto3b(uint32_t val, uint8_t *bytes)
+{
+
+	bytes[0] = (val >> 16) & 0xff;
+	bytes[1] = (val >> 8) & 0xff;
+	bytes[2] = val & 0xff;
+}
+
+static __inline void
+scsi_ulto4b(uint32_t val, uint8_t *bytes)
+{
+
+	bytes[0] = (val >> 24) & 0xff;
+	bytes[1] = (val >> 16) & 0xff;
+	bytes[2] = (val >> 8) & 0xff;
+	bytes[3] = val & 0xff;
+}
+
+static __inline uint32_t
+scsi_2btoul(uint8_t *bytes)
+{
+	uint32_t rv;
+
+	rv = (bytes[0] << 8) |
+	     bytes[1];
+	return (rv);
+}
+
+static __inline uint32_t
+scsi_3btoul(uint8_t *bytes)
+{
+	uint32_t rv;
+
+	rv = (bytes[0] << 16) |
+	     (bytes[1] << 8) |
+	     bytes[2];
+	return (rv);
+}
+
+static __inline int32_t 
+scsi_3btol(uint8_t *bytes)
+{
+	uint32_t rc = scsi_3btoul(bytes);
+ 
+	if (rc & 0x00800000)
+		rc |= 0xff000000;
+
+	return (int32_t) rc;
+}
+
+static __inline uint32_t
+scsi_4btoul(uint8_t *bytes)
+{
+	uint32_t rv;
+
+	rv = (bytes[0] << 24) |
+	     (bytes[1] << 16) |
+	     (bytes[2] << 8) |
+	     bytes[3];
+	return (rv);
+}
+
+#endif /*_AICLIB_H */
diff -urNp linux-5720/drivers/scsi/aic7xxx/cam.h linux-5730/drivers/scsi/aic7xxx/cam.h
--- linux-5720/drivers/scsi/aic7xxx/cam.h
+++ linux-5730/drivers/scsi/aic7xxx/cam.h
@@ -29,13 +29,13 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#11 $
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/cam.h#15 $
  */
 
 #ifndef _AIC7XXX_CAM_H
 #define _AIC7XXX_CAM_H 1
 
-/* Provide a mapping from CAM constructs to Linux SCSI constructs */
+#include <linux/types.h>
 
 #define	CAM_BUS_WILDCARD ((u_int)~0)
 #define	CAM_TARGET_WILDCARD ((u_int)~0)
@@ -43,56 +43,34 @@
 
 /* CAM Status field values */
 typedef enum {
-	/* CCB request is in progress */
-	CAM_REQ_INPROG		= 0x3F, /* Some value unused by Linux */
-	/* CCB request completed without error */
-	CAM_REQ_CMP		= DID_OK,
-	/* CCB request aborted by the host */
-	CAM_REQ_ABORTED		= DID_ABORT,
-	/* Unable to abort CCB request */
-	CAM_UA_ABORT		= DID_ERROR,
-	/* CCB request completed with an error */
-	CAM_REQ_CMP_ERR		= DID_ERROR,
-	/* CAM subsytem is busy */
-	CAM_BUSY		= DID_BUS_BUSY,
-	/* CCB request was invalid */
-	CAM_REQ_INVALID		= DID_BAD_TARGET,
-	/* Supplied Path ID is invalid */
-	CAM_PATH_INVALID	= DID_BAD_TARGET,
-	/* Target Selection Timeout */
-	CAM_SEL_TIMEOUT		= DID_NO_CONNECT,
-	/* Command timeout */
-	CAM_CMD_TIMEOUT		= DID_ERROR, /*
-					      * Should never occur in Linux
-					      * as the upper level code
-					      * handles all timeout processing.
-					      */
-	/* SCSI error, look at error code in CCB */
-	CAM_SCSI_STATUS_ERROR	= DID_OK, /* Linux looks at status byte */
-	/* SCSI Bus Reset Sent/Received */
-	CAM_SCSI_BUS_RESET	= DID_RESET,
-	/* Uncorrectable parity error occurred */
-	CAM_UNCOR_PARITY	= DID_PARITY,
-	/* Autosense: request sense cmd fail */
-	CAM_AUTOSENSE_FAIL	= DID_ERROR,
-	/* No HBA Detected Error */
-	CAM_NO_HBA		= DID_ERROR,
-	/* Data Overrun error */
-	CAM_DATA_RUN_ERR	= DID_ERROR,
-	/* Unexpected Bus Free */
-	CAM_UNEXP_BUSFREE	= DID_ERROR,
-	/* CCB length supplied is inadequate */
-	CAM_CCB_LEN_ERR		= DID_ERROR,
-	/* Unable to provide requested capability */
-	CAM_PROVIDE_FAIL	= DID_ERROR,
-	/* A SCSI BDR msg was sent to target */
-	CAM_BDR_SENT		= DID_RESET,
-	/* CCB request terminated by the host */
-	CAM_REQ_TERMIO		= DID_ERROR,
-	/* Unrecoverable Host Bus Adapter Error */
-	CAM_UNREC_HBA_ERROR	= DID_ERROR,
-	/* The request was too large for this host */
-	CAM_REQ_TOO_BIG		= DID_ERROR,
+	CAM_REQ_INPROG,		/* CCB request is in progress */
+	CAM_REQ_CMP,		/* CCB request completed without error */
+	CAM_REQ_ABORTED,	/* CCB request aborted by the host */
+	CAM_UA_ABORT,		/* Unable to abort CCB request */
+	CAM_REQ_CMP_ERR,	/* CCB request completed with an error */
+	CAM_BUSY,		/* CAM subsytem is busy */
+	CAM_REQ_INVALID,	/* CCB request was invalid */
+	CAM_PATH_INVALID,	/* Supplied Path ID is invalid */
+	CAM_SEL_TIMEOUT,	/* Target Selection Timeout */
+	CAM_CMD_TIMEOUT,	/* Command timeout */
+	CAM_SCSI_STATUS_ERROR,	/* SCSI error, look at error code in CCB */
+	CAM_SCSI_BUS_RESET,	/* SCSI Bus Reset Sent/Received */
+	CAM_UNCOR_PARITY,	/* Uncorrectable parity error occurred */
+	CAM_AUTOSENSE_FAIL,	/* Autosense: request sense cmd fail */
+	CAM_NO_HBA,		/* No HBA Detected Error */
+	CAM_DATA_RUN_ERR,	/* Data Overrun error */
+	CAM_UNEXP_BUSFREE,	/* Unexpected Bus Free */
+	CAM_SEQUENCE_FAIL,	/* Protocol Violation */
+	CAM_CCB_LEN_ERR,	/* CCB length supplied is inadequate */
+	CAM_PROVIDE_FAIL,	/* Unable to provide requested capability */
+	CAM_BDR_SENT,		/* A SCSI BDR msg was sent to target */
+	CAM_REQ_TERMIO,		/* CCB request terminated by the host */
+	CAM_UNREC_HBA_ERROR,	/* Unrecoverable Host Bus Adapter Error */
+	CAM_REQ_TOO_BIG,	/* The request was too large for this host */
+	CAM_UA_TERMIO,		/* Unable to terminate I/O CCB request */
+	CAM_MSG_REJECT_REC,	/* Message Reject Received */
+	CAM_DEV_NOT_THERE,	/* SCSI Device Not Installed/there */
+	CAM_RESRC_UNAVAIL,	/* Resource Unavailable */
 	/*
 	 * This request should be requeued to preserve
 	 * transaction ordering.  This typically occurs
@@ -101,7 +79,8 @@ typedef enum {
 	 * requests for the target at the sim level
 	 * back into the XPT queue.
 	 */
-	CAM_REQUEUE_REQ		= DID_BUS_BUSY,
+	CAM_REQUEUE_REQ,
+	CAM_DEV_QFRZN		= 0x40,
 
 	CAM_STATUS_MASK		= 0x3F
 } cam_status;
diff -urNp linux-5720/drivers/scsi/aic7xxx/scsi_iu.h linux-5730/drivers/scsi/aic7xxx/scsi_iu.h
--- linux-5720/drivers/scsi/aic7xxx/scsi_iu.h
+++ linux-5730/drivers/scsi/aic7xxx/scsi_iu.h
@@ -28,4 +28,12 @@ struct scsi_status_iu_header
     (12 + (((siu)->flags & SIU_RSPVALID)		\
 	? scsi_4btoul((siu)->pkt_failures_length)	\
 	: 0))
+
+#define	SIU_TASKMGMT_NONE		0x00
+#define	SIU_TASKMGMT_ABORT_TASK		0x01
+#define	SIU_TASKMGMT_ABORT_TASK_SET	0x02
+#define	SIU_TASKMGMT_CLEAR_TASK_SET	0x04
+#define	SIU_TASKMGMT_LUN_RESET		0x08
+#define	SIU_TASKMGMT_TARGET_RESET	0x20
+#define	SIU_TASKMGMT_CLEAR_ACA		0x40
 #endif /*_SCSI_SCSI_IU_H*/
diff -urNp linux-5720/drivers/scsi/aic7xxx_old.c linux-5730/drivers/scsi/aic7xxx_old.c
--- linux-5720/drivers/scsi/aic7xxx_old.c
+++ linux-5730/drivers/scsi/aic7xxx_old.c
@@ -9775,36 +9775,48 @@ aic7xxx_detect(Scsi_Host_Template *templ
           pci_write_config_dword(pdev, DEVCONFIG, devconfig);
 #endif /* AIC7XXX_STRICT_PCI_SETUP */
 
-          if(temp_p->base && check_region(temp_p->base, MAXREG - MINREG))
+	  if (temp_p->base == 0 && temp_p->mbase == 0)
+	  {
+            printk("aic7xxx: <%s> at PCI %d/%d/%d\n", 
+              board_names[aic_pdevs[i].board_name_index],
+              temp_p->pci_bus,
+              PCI_SLOT(temp_p->pci_device_fn),
+              PCI_FUNC(temp_p->pci_device_fn));
+            printk("aic7xxx: Invalid I/O & Mem port addresses, ignoring.\n");
+            kfree(temp_p);
+            temp_p = NULL;
+            continue;
+          }
+	    
+          if (temp_p->irq == 0)
           {
             printk("aic7xxx: <%s> at PCI %d/%d/%d\n", 
               board_names[aic_pdevs[i].board_name_index],
               temp_p->pci_bus,
               PCI_SLOT(temp_p->pci_device_fn),
               PCI_FUNC(temp_p->pci_device_fn));
-            printk("aic7xxx: I/O ports already in use, ignoring.\n");
+            printk("aic7xxx: Controller disabled by BIOS, ignoring.\n");
             kfree(temp_p);
             temp_p = NULL;
             continue;
           }
 
-          temp_p->unpause = INTEN;
-          temp_p->pause = temp_p->unpause | PAUSE;
-          if ( ((temp_p->base == 0) &&
-                (temp_p->mbase == 0)) ||
-               (temp_p->irq == 0) )
+          if(pci_request_regions(temp_p->pdev, "aic7xxx"))
           {
             printk("aic7xxx: <%s> at PCI %d/%d/%d\n", 
               board_names[aic_pdevs[i].board_name_index],
               temp_p->pci_bus,
               PCI_SLOT(temp_p->pci_device_fn),
               PCI_FUNC(temp_p->pci_device_fn));
-            printk("aic7xxx: Controller disabled by BIOS, ignoring.\n");
+            printk("aic7xxx: Unable to reserve PCI regions, ignoring.\n");
             kfree(temp_p);
             temp_p = NULL;
             continue;
           }
 
+          temp_p->unpause = INTEN;
+          temp_p->pause = temp_p->unpause | PAUSE;
+
 #ifdef MMAPIO
           if ( !(temp_p->base) || !(temp_p->flags & AHC_MULTI_CHANNEL) ||
                ((temp_p->chip != (AHC_AIC7870 | AHC_PCI)) &&
@@ -9844,6 +9856,7 @@ aic7xxx_detect(Scsi_Host_Template *templ
                     PCI_SLOT(temp_p->pci_device_fn),
                     PCI_FUNC(temp_p->pci_device_fn));
                   printk("aic7xxx: Controller disabled by BIOS, ignoring.\n");
+		  pci_release_regions(temp_p->pdev);
                   kfree(temp_p);
                   temp_p = NULL;
                   continue;
@@ -9854,12 +9867,6 @@ aic7xxx_detect(Scsi_Host_Template *templ
 #endif
 
           /*
-           * Lock out other contenders for our i/o space.
-           */
-          if(temp_p->base)
-            request_region(temp_p->base, MAXREG - MINREG, "aic7xxx");
-
-          /*
            * We HAVE to make sure the first pause_sequencer() and all other
            * subsequent I/O that isn't PCI config space I/O takes place
            * after the MMAPed I/O region is configured and tested.  The
@@ -9895,7 +9902,14 @@ aic7xxx_detect(Scsi_Host_Template *templ
 
           if (aic7xxx_chip_reset(temp_p) == -1)
           {
-            release_region(temp_p->base, MAXREG - MINREG);
+#ifdef MMAPIO
+            if (temp_p->maddr)
+	    {
+	      iounmap((void *) (((unsigned long) temp_p->maddr) & PAGE_MASK));
+              temp_p->maddr = 0;
+	    }
+#endif
+            pci_release_regions(temp_p->pdev);
             kfree(temp_p);
             temp_p = NULL;
             continue;
@@ -10207,7 +10221,7 @@ aic7xxx_detect(Scsi_Host_Template *templ
   {
     base = SLOTBASE(slot) + MINREG;
 
-    if (check_region(base, MAXREG - MINREG))
+    if (request_region(base, MAXREG - MINREG, "aic7xxx") == NULL)
     {
       /*
        * Some other driver has staked a
@@ -10221,19 +10235,17 @@ aic7xxx_detect(Scsi_Host_Template *templ
     if (type == -1)
     {
       slot++;
+      release_region(base, MAXREG - MINREG);
       continue;
     }
     temp_p = kmalloc(sizeof(struct aic7xxx_host), GFP_ATOMIC);
     if (temp_p == NULL)
     {
       printk(KERN_WARNING "aic7xxx: Unable to allocate device space.\n");
+      release_region(base, MAXREG - MINREG);
       slot++;
       continue; /* back to the beginning of the while loop */
     }
-    /*
-     * Lock out other contenders for our i/o space.
-     */
-    request_region(base, MAXREG - MINREG, "aic7xxx");
 
     /*
      * Pause the card preserving the IRQ type.  Allow the operator
@@ -11790,14 +11802,20 @@ aic7xxx_release(struct Scsi_Host *host)
 
   if(p->irq)
     free_irq(p->irq, p);
-  if(p->base)
-    release_region(p->base, MAXREG - MINREG);
+  if(p->pdev)
+  {
 #ifdef MMAPIO
-  if(p->maddr)
+    if(p->maddr)
+    {
+      iounmap((void *) (((unsigned long) p->maddr) & PAGE_MASK));
+    }
+#endif /* MMAPIO */
+    pci_release_regions(p->pdev);
+  }
+  else
   {
-    iounmap((void *) (((unsigned long) p->maddr) & PAGE_MASK));
+    release_region(p->base, MAXREG - MINREG);
   }
-#endif /* MMAPIO */
   prev = NULL;
   next = first_aic7xxx;
   while(next != NULL)
