diff -urNp linux-7130/include/linux/sysctl.h linux-7140/include/linux/sysctl.h
--- linux-7130/include/linux/sysctl.h
+++ linux-7140/include/linux/sysctl.h
@@ -156,6 +156,7 @@ enum
 	VM_HUGETLB_POOL=23,	/* int: size of the hugetlb pool, in MB */
 	VM_DCACHE_PRIORITY=24,	/* int: priority of the dcache pool */
 	VM_INACTIVE_CLEAN_PERCENT=25, /* int: percent of inactive thats clean */
+	VM_STACK_DEFER_THRESHOLD=26, /* int: softirq-defer threshold */
 	VM_SKIP_MAPPED_PAGES=27,/* int: don't reclaim pages w/active mappings */
 	VM_OOM_KILL=28,		/* int: limit on concurrent OOM kills */
 	VM_KSCAND_WORK_PERCENT=29, /* int: % of work on each kscand iteration */
diff -urNp linux-7130/kernel/softirq.c linux-7140/kernel/softirq.c
--- linux-7130/kernel/softirq.c
+++ linux-7140/kernel/softirq.c
@@ -18,6 +18,11 @@
 #include <linux/tqueue.h>
 
 /*
+ * Defer softirqs to ksoftirqd if free stack less than this.
+ */
+unsigned int stack_defer_threshold = (THREAD_SIZE <= 8192) ? 2048 : 4096;
+
+/*
    - No shared variables, all the data are CPU local.
    - If a softirq needs serialization, let it serialize itself
      by its own spinlocks.
@@ -75,6 +80,21 @@ asmlinkage void do_softirq()
 	if (pending) {
 		struct softirq_action *h;
 
+#if !defined(CONFIG_PARISC) && !defined(CONFIG_ARCH_S390)
+		{
+			unsigned long esp = (unsigned long)&esp;
+			unsigned long tsk = (unsigned long)current;
+
+			if (unlikely(esp < tsk + sizeof(struct task_struct) +
+			    stack_defer_threshold) && esp >= tsk &&
+			    tsk != (unsigned long)ksoftirqd_task(cpu)) {
+				wakeup_softirqd(cpu);
+				local_irq_restore(flags);
+				return;
+			}
+		}
+#endif /* !CONFIG_PARISC && !CONFIG_ARCH_S390 */
+
 		mask = ~pending;
 		local_bh_disable();
 restart:
diff -urNp linux-7130/kernel/sysctl.c linux-7140/kernel/sysctl.c
--- linux-7130/kernel/sysctl.c
+++ linux-7140/kernel/sysctl.c
@@ -46,6 +46,7 @@ int sercons_escape_char = -1;
 /* External variables not in a header file. */
 extern int panic_timeout;
 extern int dcache_priority;
+extern unsigned int stack_defer_threshold;
 extern int C_A_D;
 extern int bdf_prm[], bdflush_min[], bdflush_max[];
 extern int sysctl_overcommit_memory;
@@ -383,6 +384,9 @@ static ctl_table vm_table[] = {
 	{VM_INACTIVE_CLEAN_PERCENT, "inactive_clean_percent",
 		&inactive_clean_percent, sizeof(inactive_clean_percent),
 		0644, NULL, &proc_dointvec},
+	{VM_STACK_DEFER_THRESHOLD, "stack_defer_threshold",
+		&stack_defer_threshold, sizeof(stack_defer_threshold),
+		0644, NULL, &proc_dointvec},
 	{VM_SKIP_MAPPED_PAGES, "skip_mapped_pages",
 		&skip_mapped_pages, sizeof(skip_mapped_pages),
 		0644, NULL, &proc_dointvec},
