diff -urNp linux-1240/include/linux/mm.h linux-1250/include/linux/mm.h
--- linux-1240/include/linux/mm.h
+++ linux-1250/include/linux/mm.h
@@ -293,9 +293,6 @@ typedef struct page {
  * active, inactive_dirty and inactive_clean lists are protected by
  * the lru lock, and *NOT* by the usual PG_locked bit!
  *
- * PG_skip is used on sparc/sparc64 architectures to "skip" certain
- * parts of the address space.
- *
  * PG_error is set to indicate that an I/O error occurred on this page.
  *
  * PG_arch_1 is an architecture specific page state bit.  The generic
@@ -318,7 +315,7 @@ typedef struct page {
 #define PG_inactive_laundry	 8
 #define PG_inactive_clean	 9
 #define PG_slab			10
-#define PG_skip			11
+#define PG_invalidated		11	/* Page invalidated by direct IO */
 #define PG_highmem		12
 #define PG_checked		13	/* kill me in 2.5.<early>. */
 #define PG_arch_1		14
@@ -524,6 +521,10 @@ extern void FASTCALL(set_page_dirty(stru
 #define ClearPageSync(page)	clear_bit(PG_sync, &(page)->flags)
 #define TestClearPageSync(page)	test_and_clear_bit(PG_sync, &(page)->flags)
 
+#define SetPageInvalidated(page) set_bit(PG_invalidated, &(page)->flags)
+#define ClearPageInvalidated(page) clear_bit(PG_invalidated, &(page)->flags)
+#define PageInvalidated(page)   test_bit(PG_invalidated, &(page)->flags)
+
 #ifdef CONFIG_HIGHMEM
 #define PageHighMem(page)		test_bit(PG_highmem, &(page)->flags)
 #else
diff -urNp linux-1240/mm/filemap.c linux-1250/mm/filemap.c
--- linux-1240/mm/filemap.c
+++ linux-1250/mm/filemap.c
@@ -358,6 +358,7 @@ static inline int invalidate_this_page2(
 	 * The page is locked and we hold the pagecache_lock as well
 	 * so both page_count(page) and page->buffers stays constant here.
 	 */
+	SetPageInvalidated(page);
 	if (page_count(page) == 1 + !!page->buffers) {
 		/* Restart after this page */
 		list_del(head);
@@ -1638,6 +1639,7 @@ page_not_up_to_date:
 
 readpage:
 		/* ... and start the actual read. The read will unlock the page. */
+		ClearPageInvalidated(page);
 		error = mapping->a_ops->readpage(filp, page);
 
 		if (!error) {
@@ -1648,9 +1650,25 @@ readpage:
 			generic_file_readahead(reada_ok, filp, inode, page, flags);
 			if (!(flags & F_ATOMIC))
 				wait_on_page(page);
-			if (Page_Uptodate(page))
+			if (Page_Uptodate(page) ||
+			    (PageInvalidated(page) && !PageError(page)))
 				goto page_ok;
 			error = (flags & F_ATOMIC) ? -EWOULDBLOCKIO : -EIO;
+			/* Ugly --- if we're racing against another
+			 * instance of generic_file_read(), the
+			 * PageInvalidated flag can have been cleared by
+			 * now.  We can avoid that race by taking the
+			 * page lock again on this rare path and testing
+			 * once more. */
+			if (error == -EIO) {
+				lock_page(page);
+				if (Page_Uptodate(page) ||
+				    (PageInvalidated(page) && !PageError(page))) {
+					unlock_page(page);
+					goto page_ok;
+				}
+				unlock_page(page);
+			}
 		}
 
 		/* UHHUH! A synchronous read error occurred. Report it */
