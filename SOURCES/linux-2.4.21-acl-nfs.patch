--- linux-2.4.20/fs/nfs/dir.c.xattracl	2003-06-02 17:26:24.000000000 -0400
+++ linux-2.4.20/fs/nfs/dir.c	2003-06-02 17:26:25.000000000 -0400
@@ -1228,6 +1228,7 @@ out:
 int
 nfs_permission(struct inode *inode, int mask)
 {
+	struct nfs_server *server = NFS_SERVER(inode);
 	struct nfs_access_cache *cache = &NFS_I(inode)->cache_access;
 	struct rpc_cred *cred;
 	int mode = inode->i_mode;
@@ -1252,7 +1253,7 @@ nfs_permission(struct inode *inode, int 
 			return -EACCES;
 	}
 
-	if (!NFS_PROTO(inode)->access)
+	if ((server->flags & NFS_MOUNT_NOACL) || !NFS_PROTO(inode)->access)
 		goto out_notsup;
 	cred = rpcauth_lookupcred(NFS_CLIENT(inode)->cl_auth, 0);
 	if (cache->cred == cred
--- linux-2.4.20/fs/nfs/inode.c.xattracl	2003-06-02 17:26:16.000000000 -0400
+++ linux-2.4.20/fs/nfs/inode.c	2003-06-02 17:26:25.000000000 -0400
@@ -586,6 +586,7 @@ static int nfs_show_options(struct seq_f
 		{ NFS_MOUNT_NOAC, ",noac", "" },
 		{ NFS_MOUNT_NONLM, ",nolock", ",lock" },
 		{ NFS_MOUNT_BROKEN_SUID, ",broken_suid", "" },
+		{ NFS_MOUNT_NOACL, ",noacl", "" },
 		{ 0, NULL, NULL }
 	};
 	struct proc_nfs_info *nfs_infop;
--- linux-2.4.20/fs/nfsd/nfs3xdr.c.xattracl	2003-06-02 17:26:14.000000000 -0400
+++ linux-2.4.20/fs/nfsd/nfs3xdr.c	2003-06-02 17:26:25.000000000 -0400
@@ -157,9 +157,24 @@ static inline u32 *
 encode_fattr3(struct svc_rqst *rqstp, u32 *p, struct svc_fh *fhp)
 {
 	struct inode	*inode = fhp->fh_dentry->d_inode;
+	mode_t		mode = inode->i_mode;
 
+	if (IS_POSIXACL(inode) &&
+	    nfs_permission_mode == NFS_FILE_MODE_PERMISSION_BITS_SECURE) {
+		struct posix_acl *acl = nfsd_get_posix_acl(fhp,ACL_TYPE_ACCESS);
+
+		if (IS_ERR(acl))
+			return 0;
+		else if (acl) {
+			int error = posix_acl_masq_nfs_mode(acl, &mode);
+			posix_acl_release(acl);
+			if (error)
+				return 0;
+		}
+	}
+  
 	*p++ = htonl(nfs3_ftypes[(inode->i_mode & S_IFMT) >> 12]);
-	*p++ = htonl((u32) inode->i_mode);
+	*p++ = htonl((u32) mode);
 	*p++ = htonl((u32) inode->i_nlink);
 	*p++ = htonl((u32) nfsd_ruid(rqstp, inode->i_uid));
 	*p++ = htonl((u32) nfsd_rgid(rqstp, inode->i_gid));
--- linux-2.4.20/fs/nfsd/nfsctl.c.xattracl	2002-08-02 20:39:45.000000000 -0400
+++ linux-2.4.20/fs/nfsd/nfsctl.c	2003-06-02 17:26:25.000000000 -0400
@@ -7,6 +7,7 @@
  */
 
 #include <linux/config.h>
+#include <linux/init.h>
 #include <linux/module.h>
 #include <linux/version.h>
 
@@ -299,15 +300,55 @@ done:
 	return err;
 }
 
+/*
+   About the nfs_permission_mode module parameter:
+
+   With Posix Access Control Lists, pre-NFS3 clients and older Linux
+   NFSv3 clients in some cases mis-interpret the file mode permission
+   bits, and either allow the remote user to read data she is not
+   permitted to, or deny the user read access that should be granted.
+   (With proper NFSv3, the access RPC is used to check access, and
+   access decisions are not implemented on the client.)
+
+   The nfs_permission_mode module parameter can either send the mode
+   permission bits (inode->i_mode & S_IRWXUGO) of files that have
+   Access Control Lists unchanged, or remove all permissions that
+   might lead to wrong decisions on the client machine.
+   
+   The file mode permission bits should only be set to 'unchanged' in
+   an environment where it is known that all NFSv3 clients use the
+   access RPC.  (The file mode permission bits for NFSv2 clients are
+   always "secured".)
+
+   Default value changed from _SECURE to _UNCHANGED since _SECURE may
+   lead to user surprise.
+*/
+int nfs_permission_mode = NFS_FILE_MODE_PERMISSION_BITS_UNCHANGED;
+
 EXPORT_NO_SYMBOLS;
 MODULE_AUTHOR("Olaf Kirch <okir@monad.swb.de>");
 MODULE_LICENSE("GPL");
 
+MODULE_PARM(nfs_permission_mode, "i");
+MODULE_PARM_DESC(nfs_permission_mode,
+               "nfsd file mode permission bits: 0=unchanged, 1=secure (0)");
+
 #ifdef MODULE
 struct nfsd_linkage nfsd_linkage_s = {
 	do_nfsservctl: handle_sys_nfsservctl,
 	owner: THIS_MODULE,
 };
+#else
+static int __init
+nfs_permission_mode_setup(char *str)
+{
+	nfs_permission_mode = simple_strtol(str, &str, 10) ?
+		NFS_FILE_MODE_PERMISSION_BITS_SECURE :
+		NFS_FILE_MODE_PERMISSION_BITS_UNCHANGED;
+	return 0;
+}
+
+__setup("nfs_permission_mode=", nfs_permission_mode_setup);
 #endif
 
 /*
--- linux-2.4.20/fs/nfsd/nfssvc.c.xattracl	2003-06-02 17:26:19.000000000 -0400
+++ linux-2.4.20/fs/nfsd/nfssvc.c	2003-06-02 17:26:25.000000000 -0400
@@ -155,6 +155,7 @@ static void
 nfsd(struct svc_rqst *rqstp)
 {
 	struct svc_serv	*serv = rqstp->rq_server;
+	struct fs_struct *fsp;
 	int		err;
 	struct nfsd_list me;
 
@@ -165,6 +166,19 @@ nfsd(struct svc_rqst *rqstp)
 	sprintf(current->comm, "nfsd");
 	current->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;
 
+	/* Make sure umask is 0.
+	 * This is required by the new ACL code which does the umask
+	 * munging below vfs_create() level.
+	 */
+	fsp = copy_fs_struct(current->fs);
+	if (fsp == NULL) {
+		printk("Unable to start nfsd thread: out of memory\n");
+		goto out;
+	}
+	exit_fs(current);
+	current->fs = fsp;
+	fsp->umask = 0;
+
 	nfsdstats.th_cnt++;
 	/* Let svc_process check client's authentication. */
 	rqstp->rq_auth = 1;
@@ -246,6 +260,7 @@ nfsd(struct svc_rqst *rqstp)
 	list_del(&me.list);
 	nfsdstats.th_cnt --;
 
+out:
 	/* Release the thread */
 	svc_exit_thread(rqstp);
 
--- linux-2.4.20/fs/nfsd/nfsxdr.c.xattracl	2003-06-02 17:26:14.000000000 -0400
+++ linux-2.4.20/fs/nfsd/nfsxdr.c	2003-06-02 17:26:25.000000000 -0400
@@ -135,10 +135,25 @@ static inline u32 *
 encode_fattr(struct svc_rqst *rqstp, u32 *p, struct svc_fh *fhp)
 {
 	struct inode *inode = fhp->fh_dentry->d_inode;
+ 	mode_t mode = inode->i_mode;
 	int type = (inode->i_mode & S_IFMT);
+  
+	if (IS_POSIXACL(inode) &&
+	    nfs_permission_mode == NFS_FILE_MODE_PERMISSION_BITS_SECURE) {
+		struct posix_acl *acl = nfsd_get_posix_acl(fhp,ACL_TYPE_ACCESS);
+
+		if (IS_ERR(acl))
+			return 0;
+		else if (acl) {
+			int error = posix_acl_masq_nfs_mode(acl, &mode);
+			posix_acl_release(acl);
+			if (error)
+				return 0;
+		}
+	}
 
 	*p++ = htonl(nfs_ftypes[type >> 12]);
-	*p++ = htonl((u32) inode->i_mode);
+	*p++ = htonl((u32) mode);
 	*p++ = htonl((u32) inode->i_nlink);
 	*p++ = htonl((u32) nfsd_ruid(rqstp, inode->i_uid));
 	*p++ = htonl((u32) nfsd_rgid(rqstp, inode->i_gid));
--- linux-2.4.20/fs/nfsd/vfs.c.xattracl	2003-06-02 17:26:16.000000000 -0400
+++ linux-2.4.20/fs/nfsd/vfs.c	2003-06-02 17:26:25.000000000 -0400
@@ -22,6 +22,7 @@
 #include <linux/errno.h>
 #include <linux/locks.h>
 #include <linux/fs.h>
+#include <linux/xattr_acl.h>
 #include <linux/major.h>
 #include <linux/ext2_fs.h>
 #include <linux/proc_fs.h>
@@ -1588,3 +1589,101 @@ nfsd_racache_init(int cache_size)
 	nfsdstats.ra_size = cache_size;
 	return 0;
 }
+
+#ifdef CONFIG_FS_POSIX_ACL
+struct posix_acl *
+nfsd_get_posix_acl(struct svc_fh *fhp, int type)
+{
+	struct inode *inode = fhp->fh_dentry->d_inode;
+	char *name;
+	void *value = NULL;
+	ssize_t size;
+	struct posix_acl *acl;
+
+	if (!IS_POSIXACL(inode) || !inode->i_op || !inode->i_op->getxattr)
+		return ERR_PTR(-EOPNOTSUPP);
+	switch(type) {
+		case ACL_TYPE_ACCESS:
+			name = XATTR_NAME_ACL_ACCESS;
+			break;
+		case ACL_TYPE_DEFAULT:
+			name = XATTR_NAME_ACL_DEFAULT;
+			break;
+		default:
+			return ERR_PTR(-EOPNOTSUPP);
+	}
+
+	if (!fhp->fh_locked)
+		fh_lock(fhp);  /* unlocking is done automatically */
+	lock_kernel();  /* goes away in 2.5 */
+
+	size = inode->i_op->getxattr(fhp->fh_dentry, name, NULL, 0);
+	if (size < 0) {
+		acl = ERR_PTR(size);
+		goto getout;
+	} else if (size > 0) {
+		value = kmalloc(size, GFP_KERNEL);
+		if (!value) {
+			acl = ERR_PTR(-ENOMEM);
+			goto getout;
+		}
+		size = inode->i_op->getxattr(fhp->fh_dentry, name, value, size);
+		if (size < 0) {
+			acl = ERR_PTR(size);
+			goto getout;
+		}
+	}
+	acl = posix_acl_from_xattr(value, size);
+
+getout:
+	kfree(value);
+	unlock_kernel();  /* goes away in 2.5 */
+	return acl;
+}
+
+int
+nfsd_set_posix_acl(struct svc_fh *fhp, int type, struct posix_acl *acl)
+{
+	struct inode *inode = fhp->fh_dentry->d_inode;
+	char *name;
+	void *value = NULL;
+	size_t size;
+	int error;
+
+	if (!IS_POSIXACL(inode) || !inode->i_op || !inode->i_op->setxattr)
+		return -EOPNOTSUPP;
+	switch(type) {
+		case ACL_TYPE_ACCESS:
+			name = XATTR_NAME_ACL_ACCESS;
+			break;
+		case ACL_TYPE_DEFAULT:
+			name = XATTR_NAME_ACL_DEFAULT;
+			break;
+		default:
+			return -EOPNOTSUPP;
+	}
+
+	if (acl && acl->a_count) {
+		size = xattr_acl_size(acl->a_count);
+		value = kmalloc(size, GFP_KERNEL);
+		if (!value)
+			return -ENOMEM;
+		size = posix_acl_to_xattr(acl, value, size);
+		if (size < 0) {
+			error = size;
+			goto getout;
+		}
+	} else
+		size = 0;
+
+	if (!fhp->fh_locked)
+		fh_lock(fhp);  /* unlocking is done automatically */
+	lock_kernel();  /* goes away in 2.5 */
+	error = inode->i_op->setxattr(fhp->fh_dentry, name, value, size, 0);
+	unlock_kernel();  /* goes away in 2.5 */
+
+getout:
+	kfree(value);
+	return error;
+}
+#endif
--- linux-2.4.20/kernel/Makefile.xattracl	2003-06-02 17:26:20.000000000 -0400
+++ linux-2.4.20/kernel/Makefile	2003-06-02 17:27:29.000000000 -0400
@@ -9,7 +9,8 @@
 
 O_TARGET := kernel.o
 
-export-objs = signal.o sys.o kmod.o context.o ksyms.o pm.o exec_domain.o printk.o cpufreq.o profile.o module.o
+export-objs = signal.o sys.o kmod.o context.o ksyms.o pm.o exec_domain.o \
+	      printk.o cpufreq.o profile.o module.o fork.o
 
 obj-y     = sched.o dma.o fork.o exec_domain.o panic.o printk.o profile.o \
 	    module.o exit.o itimer.o info.o time.o softirq.o resource.o \
--- linux-2.4.20/kernel/fork.c.xattracl	2003-06-02 17:26:21.000000000 -0400
+++ linux-2.4.20/kernel/fork.c	2003-06-02 17:26:25.000000000 -0400
@@ -1115,3 +1115,5 @@ void __init proc_caches_init(void)
 	if(!mm_cachep)
 		panic("vma_init: Cannot alloc mm_struct SLAB cache");
 }
+
+EXPORT_SYMBOL(copy_fs_struct);
--- linux-2.4.20/include/linux/nfsd/nfsd.h.xattracl	2002-11-28 18:53:15.000000000 -0500
+++ linux-2.4.20/include/linux/nfsd/nfsd.h	2003-06-02 17:26:25.000000000 -0400
@@ -15,6 +15,7 @@
 #include <linux/unistd.h>
 #include <linux/dirent.h>
 #include <linux/fs.h>
+#include <linux/posix_acl.h>
 
 #include <linux/nfsd/debug.h>
 #include <linux/nfsd/nfsfh.h>
@@ -127,6 +128,22 @@ int		nfsd_statfs(struct svc_rqst *, stru
 int		nfsd_notify_change(struct inode *, struct iattr *);
 int		nfsd_permission(struct svc_export *, struct dentry *, int);
 
+#ifdef CONFIG_FS_POSIX_ACL
+struct posix_acl *nfsd_get_posix_acl(struct svc_fh *, int);
+int nfsd_set_posix_acl(struct svc_fh *, int, struct posix_acl *);
+#else
+static inline struct posix_acl *
+nfsd_get_posix_acl(struct svc_fh *fhp, int acl_type)
+{
+	return ERR_PTR(-EOPNOTSUPP);
+}
+static inline int
+nfsd_set_posix_acl(struct svc_fh *fhp, int type, struct posix_acl *acl)
+{
+	return -EOPNOTSUPP;
+}
+#endif
+
 
 /*
  * lockd binding
@@ -185,6 +202,12 @@ void		nfsd_lockd_unexport(struct svc_cli
  */
 extern struct timeval	nfssvc_boot;
 
+/* nfs_permission_mode module/kernel parameter */
+#define NFS_FILE_MODE_PERMISSION_BITS_UNCHANGED 0
+#define NFS_FILE_MODE_PERMISSION_BITS_SECURE 1
+
+extern int nfs_permission_mode;
+
 #endif /* __KERNEL__ */
 
 #endif /* LINUX_NFSD_NFSD_H */
--- linux-2.4.20/include/linux/nfs_mount.h.xattracl	2001-11-22 14:47:41.000000000 -0500
+++ linux-2.4.20/include/linux/nfs_mount.h	2003-06-02 17:26:25.000000000 -0400
@@ -53,6 +53,7 @@ struct nfs_mount_data {
 #define NFS_MOUNT_KERBEROS	0x0100	/* 3 */
 #define NFS_MOUNT_NONLM		0x0200	/* 3 */
 #define NFS_MOUNT_BROKEN_SUID	0x0400	/* 4 */
+#define NFS_MOUNT_NOACL		0x0800  /* 4 */
 #define NFS_MOUNT_FLAGMASK	0xFFFF
 
 #endif
