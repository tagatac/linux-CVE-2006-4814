diff -urNp linux-8160/arch/ppc64/kernel/Makefile linux-8161/arch/ppc64/kernel/Makefile
--- linux-8160/arch/ppc64/kernel/Makefile
+++ linux-8161/arch/ppc64/kernel/Makefile
@@ -17,7 +17,7 @@ all: $(KHEAD) kernel.o
 
 O_TARGET := kernel.o
 
-export-objs         := ppc_ksyms.o setup.o vio.o
+export-objs         := ppc_ksyms.o setup.o udbg.o vio.o
 
 obj-y               :=	ppc_ksyms.o setup.o entry.o traps.o irq.o idle.o \
 			time.o process.o signal.o syscalls.o misc.o ptrace.o \
diff -urNp linux-8160/arch/ppc64/kernel/iSeries_setup.c linux-8161/arch/ppc64/kernel/iSeries_setup.c
--- linux-8160/arch/ppc64/kernel/iSeries_setup.c
+++ linux-8161/arch/ppc64/kernel/iSeries_setup.c
@@ -333,6 +333,10 @@ iSeries_init_early(void)
 	ppc_md.kbd_leds          	= NULL;
 	ppc_md.kbd_init_hw       	= NULL;
 
+	ppc_md.udbg_putc		= udbg_putc;
+	ppc_md.udbg_getc		= udbg_getc;
+	ppc_md.udbg_getc_poll		= udbg_getc_poll;
+	
 #if defined(CONFIG_MAGIC_SYSRQ)
 	ppc_md.ppc_kbd_sysrq_xlate	= NULL;
 #endif
diff -urNp linux-8160/arch/ppc64/kernel/udbg.c linux-8161/arch/ppc64/kernel/udbg.c
--- linux-8160/arch/ppc64/kernel/udbg.c
+++ linux-8161/arch/ppc64/kernel/udbg.c
@@ -23,6 +23,39 @@
 #include <asm/uaccess.h>
 #include <asm/machdep.h>
 
+#if defined(CONFIG_ICOM)||defined(CONFIG_ICOM_MODULE)
+
+#include <asm/io.h>		/* writeb */
+#include <linux/mm.h>		/* gfp_kernel */
+#include <linux/slab.h>		/* kfree */
+#include <linux/serial.h>	/* struct async_icount */
+#include <linux/icom_udbg.h>	/* icom structures */
+#include <asm/iSeries/HvLpConfig.h>  /* getLps */
+
+#include <linux/module.h> /* export_symbol */
+
+void iCom_sercons_putchar(unsigned char);
+char iCom_sercons_getchar(void);
+
+char recvd[256];
+int input_buf_loc = 0;
+/* lock for access to the card. */
+static spinlock_t serial_lock = SPIN_LOCK_UNLOCKED;
+
+struct icom_adapter *icom_adapter_info;
+
+#define ICOM_STARTED 0x1
+static spinlock_t udbg_state_lock = SPIN_LOCK_UNLOCKED;
+volatile unsigned int udbg_state=0;
+
+/* #define ICOM_TRACE */
+
+#ifdef ICOM_TRACE
+void TRACE(struct icom_port *icom_port_ptr, u32 trace_pt,
+	   u32 trace_data);
+#endif
+#endif /* ICOM */
+
 struct NS16550 {
 	/* this struct must be packed */
 	unsigned char rbr;  /* 0 */
@@ -69,9 +102,36 @@ udbg_init_uart(void *comport)
 	}
 }
 
+/* '1' to indicate started. '0' to indicate stopped. */
+int
+iCom_udbg_started(int s) {
+#if defined(CONFIG_ICOM)||defined(CONFIG_ICOM_MODULE)
+    spin_lock(&udbg_state_lock);
+    if (s==1) {
+	udbg_state |= ICOM_STARTED;
+	printk("iCom_udbg_started\n");
+    }
+    else if (s==0) {
+	udbg_state &= ~ICOM_STARTED;
+	printk("iCom_udbg_ stopped\n");
+    }
+    spin_unlock(&udbg_state_lock);
+    return (udbg_state & ICOM_STARTED);
+#else
+    return 0;
+#endif  /* icom */
+}
+
 void
 udbg_putc(unsigned char c)
 {
+#if defined(CONFIG_ICOM)||defined(CONFIG_ICOM_MODULE)
+    if (iCom_udbg_started(-1)) {
+	if (iCom_sercons_putchar)
+	    iCom_sercons_putchar(c);
+	return;
+    }
+#endif
 	if ( udbg_comport ) {
 		while ((udbg_comport->lsr & LSR_THRE) == 0)
 			/* wait for idle */;
@@ -90,6 +150,9 @@ udbg_putc(unsigned char c)
 
 int udbg_getc_poll(void)
 {
+        if (iCom_udbg_started(-1)) {
+	   return -1;                    /* wms - this might be a problem */
+        }
 	if (udbg_comport) {
 		if ((udbg_comport->lsr & LSR_DR) != 0)
 			return udbg_comport->rbr;
@@ -102,6 +165,12 @@ int udbg_getc_poll(void)
 unsigned char
 udbg_getc(void)
 {
+#if defined(CONFIG_ICOM)||defined(CONFIG_ICOM_MODULE)
+        if (iCom_udbg_started(-1)) {
+	    if (iCom_sercons_getchar) 
+		return iCom_sercons_getchar();
+        }
+#endif
 	if ( udbg_comport ) {
 		while ((udbg_comport->lsr & LSR_DR) == 0)
 			/* wait for char */;
@@ -245,3 +314,302 @@ udbg_ifdebug(unsigned long flags)
 {
 	return (flags & naca->debug_switch);
 }
+
+#if defined(CONFIG_ICOM)||defined(CONFIG_ICOM_MODULE)
+/* Udbg/Icom interface functions below. */
+
+/* the following sercons functions provide basic card operation for using the serial port as a debugger. they assume that the debugging is being done on the first port on the first card initialized.  */
+void clear_recv_buffers(struct icom_port *icom_port_ptr) {
+    /* */
+    memset((char *)icom_port_ptr->recv_buf, 0, RCV_BUFF_SZ);
+    icom_port_ptr->statStg->rcv[0].flags = 0;
+    icom_port_ptr->statStg->rcv[0].leLength = 0;
+    icom_port_ptr->statStg->rcv[0].WorkingLength =
+      (unsigned short int)cpu_to_le16(RCV_BUFF_SZ);
+
+    memset((char *)icom_port_ptr->recv_buf+2048, 0, RCV_BUFF_SZ);
+    icom_port_ptr->statStg->rcv[1].flags = 0;
+    icom_port_ptr->statStg->rcv[1].leLength = 0;
+    icom_port_ptr->statStg->rcv[1].WorkingLength =
+      (unsigned short int)cpu_to_le16(RCV_BUFF_SZ);
+}
+
+/* notes: string parameter to mdm_poll function must be 256 chars long */
+static int mdm_poll(struct icom_port *icom_port_ptr, char *string) {
+    int status = 0;
+    int loop_count = 0;
+    unsigned char cmdReg;
+
+   /* init string to null */
+    memset(string, 0, 256);
+
+   /* set DTR RTS up */
+    writeb(0xC0,&icom_port_ptr->dram->osr);
+
+   /* make sure we're in send/rcv mode */
+    cmdReg = readb(&icom_port_ptr->dram->CmdReg);
+    writeb(cmdReg | CMD_XMIT_RCV_ENABLE,&icom_port_ptr->dram->CmdReg);
+
+   /* check for data on modem */
+    while (!status && (loop_count++ < 50))
+    {
+	HvCallCfg_getLps();
+
+	if(cpu_to_le16(icom_port_ptr->statStg->rcv[0].flags) & SA_FL_RCV_DONE)
+	{
+	    int length;
+	    length = min(256,cpu_to_le16(icom_port_ptr->statStg->rcv[0].leLength));
+	   /* copy received data to string */
+	    strncat(string, (char *)icom_port_ptr->recv_buf,length);
+	   /* reset the buffer */
+	    memset((char *)icom_port_ptr->recv_buf, 0, RCV_BUFF_SZ);
+	    icom_port_ptr->statStg->rcv[0].flags = 0;
+	    icom_port_ptr->statStg->rcv[0].leLength = 0;
+	    icom_port_ptr->statStg->rcv[0].WorkingLength = (unsigned short int)cpu_to_le16(RCV_BUFF_SZ);
+	    status = 1;
+	}
+	else if(cpu_to_le16(icom_port_ptr->statStg->rcv[1].flags) & SA_FL_RCV_DONE)
+	{
+	   /* copy received data to string */
+	    int length;
+	    length = min(256,cpu_to_le16(icom_port_ptr->statStg->rcv[1].leLength));
+	    strncat(string, (char *)icom_port_ptr->recv_buf + 2048,length);
+	   /* reset the buffer */
+	    memset((char *)icom_port_ptr->recv_buf+2048, 0, RCV_BUFF_SZ);
+	    icom_port_ptr->statStg->rcv[1].flags = 0;
+	    icom_port_ptr->statStg->rcv[1].leLength = 0;
+	    icom_port_ptr->statStg->rcv[1].WorkingLength = (unsigned short int)cpu_to_le16(RCV_BUFF_SZ);
+	    status=1;
+	}
+    }
+
+    /* clear interrupts */
+    writew(0x3FFF,(void *)icom_port_ptr->int_reg);
+
+    return status;
+}
+
+static void mdm_send(struct icom_port *icom_port_ptr, char *mdm_cmnd,
+		     int cmnd_length) {
+
+    unsigned char     cmdReg;
+    unsigned long int offset;
+    char	tmp_byte;
+    int index;
+
+    if (0 == cmnd_length) {
+
+    /* turn on DTR and RTS */
+	writeb(0xC0,&icom_port_ptr->dram->osr);
+	tmp_byte = readb(&(icom_port_ptr->dram->HDLCConfigReg));
+	tmp_byte |= HDLC_HDW_FLOW;
+	writeb(tmp_byte, &(icom_port_ptr->dram->HDLCConfigReg));
+
+    /* initialize transmit and receive operations */
+	offset = (unsigned long int)&icom_port_ptr->statStg->rcv[0] - (unsigned long int)icom_port_ptr->statStg;
+	writel(icom_port_ptr->statStg_pci + offset,&icom_port_ptr->dram->RcvStatusAddr);
+	icom_port_ptr->next_rcv = 0;
+	icom_port_ptr->put_length = 0;
+	*icom_port_ptr->xmitRestart = 0;
+	writel(icom_port_ptr->xmitRestart_pci,&icom_port_ptr->dram->XmitStatusAddr);
+	writeb(CMD_XMIT_RCV_ENABLE,&icom_port_ptr->dram->CmdReg);
+
+    /* wait for CTS */
+	for (index=0; index < 20; index++) {
+	    current->state = TASK_INTERRUPTIBLE;
+	    schedule_timeout(HZ/100); /* HZ = .01 second */
+	    if (readb(&icom_port_ptr->dram->isr) & ICOM_CTS) break;
+	}
+	if (index == 20) printk("iCom:  WARNING CTS not up in 200ms for BATs\n");
+	current->state = TASK_INTERRUPTIBLE;
+	schedule_timeout(HZ); /* HZ = 1 second */
+	return;
+    }
+
+  /* clear target receive buffers 1 and 2 */
+    memset(icom_port_ptr->recv_buf,0,4096);
+
+    memcpy(icom_port_ptr->xmit_buf, mdm_cmnd, cmnd_length);
+
+    icom_port_ptr->statStg->xmit[0].flags = (unsigned short int)cpu_to_le16(SA_FLAGS_READY_TO_XMIT);
+    icom_port_ptr->statStg->xmit[0].leLength = (unsigned short int)cpu_to_le16(cmnd_length);
+    offset = (unsigned long int)&icom_port_ptr->statStg->xmit[0] - (unsigned long int)icom_port_ptr->statStg;
+    *icom_port_ptr->xmitRestart = cpu_to_le32(icom_port_ptr->statStg_pci + offset);
+
+    cmdReg = readb(&icom_port_ptr->dram->CmdReg);
+    writeb(cmdReg | CMD_XMIT_RCV_ENABLE,&icom_port_ptr->dram->CmdReg);
+
+    writeb(START_XMIT,&icom_port_ptr->dram->StartXmitCmd);
+#ifdef ICOM_TRACE
+    TRACE(icom_port_ptr,TRACE_WRITE_START,cmnd_length);
+#endif
+}
+
+void mdm_check_send(struct icom_port *icom_port_ptr, char *mdm_cmnd,
+		    int cmnd_length) {
+    unsigned char status;
+    int loops = 0;
+
+    /* check other modem and see if it is ready	*/
+    status = readb(&icom_port_ptr->dram->isr);
+
+    /* spin for a few to let the char appear */
+    while( 1 || !(status & ICOM_DSR) || 
+	   !(status & ICOM_CTS) ) {
+	status = readb(&icom_port_ptr->dram->isr);/* pause and check again */
+	if(loops++ > 900){
+	    break;
+	}
+	HvCallCfg_getLps();
+    }
+    mdm_send(icom_port_ptr, mdm_cmnd, cmnd_length);
+}
+
+/* basic setup to get the card working 
+   Just set speed, character and parity */
+void iCom_sercons_init(void) {
+	int index;
+	char config2 = ICOM_ACFG_DRIVE1;
+	char config3, tmp_byte;
+	extern char recvd[256];
+
+	struct icom_port *icom_port_ptr = &(icom_adapter_info[0].port_info[0]);
+
+	config2 |= ICOM_ACFG_8BPC; /*set 8 bits per char */
+	config2 |= ICOM_ACFG_2STOP_BIT; /*set to 2 stop bits */
+	/*config2 |= ICOM_ACFG_PARITY_ENAB; parity enabled */
+	/*config2 |= ICOM_ACFG_PARITY_ODD; odd parity */
+	
+	/* set baud to 9600 */
+	for(index = 0; index < BAUD_TABLE_LIMIT; index++){
+		if (icom_acfg_baud[index] == 9600){
+			config3 = index;
+			break;
+		}
+	}
+
+	writeb(config3, &(icom_port_ptr->dram->async_config3) );
+  	writeb(config2, &(icom_port_ptr->dram->async_config2) );
+  	tmp_byte = readb(&(icom_port_ptr->dram->HDLCConfigReg));
+  	tmp_byte |= HDLC_PPP_PURE_ASYNC | HDLC_FF_FILL | HDLC_HDW_FLOW;
+  	writeb(tmp_byte,&(icom_port_ptr->dram->HDLCConfigReg));
+  	writeb(0x01, &(icom_port_ptr->dram->FlagFillIdleTimer)); /* 0.1 seconds */
+  	writeb(0xFF, &(icom_port_ptr->dram->ier)); /* enable modem signal interrupts */
+
+	writeb(CMD_RESTART, &(icom_port_ptr->dram->CmdReg));
+	/* Looks like there is a timing window between prior writeb and the
+             first mdm_send call.   Todo:  attempt to replace this for() with a readb(), should force the writeb operation to complete. */
+	for(index = 0; index < 100; index++)
+		;
+
+	/* call mdm_send with cmd length 0 to take initialization path */
+	mdm_send( &(icom_adapter_info[0].port_info[0]), NULL, 0);
+
+	/* let udbg know card is OK to print to */
+        iCom_udbg_started(1);
+	recvd[0]=0;
+}
+
+char iCom_sercons_poll(void) {
+	int status;
+	char str[256];
+
+	spin_lock(&serial_lock); /*lock */
+	status = mdm_poll(&(icom_adapter_info[0].port_info[0]), str);
+	spin_unlock(&serial_lock); /* lock */
+	if(status)
+		return str[0];
+	return -1;
+}
+
+char iCom_sercons_getchar(void) {
+	char c;
+
+	spin_lock(&serial_lock); /*lock*/
+	
+	/* clear the input buffers  */
+	/* clear_recv_buffers(&(icom_adapter_info[0].port_info[0])); */
+
+	if (recvd[input_buf_loc] != 0){
+		c = recvd[input_buf_loc];
+		input_buf_loc++;
+	} else {
+		/* loop until something is in the buffers */
+	    while( !(mdm_poll(&(icom_adapter_info[0].port_info[0]), recvd)) ){
+		;
+	    }
+	    c = recvd[0];
+	    input_buf_loc = 1;
+	}
+	
+	spin_unlock(&serial_lock); /*lock*/
+	
+	return c;
+}
+
+void iCom_sercons_putchar(unsigned char c) {
+
+	char ch = c;
+
+	if(ch == -1)
+		return;
+	
+	spin_lock(&serial_lock);
+	
+	/*if ch is a new line print a carriage return as well */
+        if(ch == '\n' || ch =='\r') {
+                ch = '\n';
+                mdm_check_send( &(icom_adapter_info[0].port_info[0]), &ch, 1);
+		ch = '\r';
+                mdm_check_send( &(icom_adapter_info[0].port_info[0]), &ch, 1);
+        } 
+	else /* try to send directly to modem */
+        	mdm_check_send( &(icom_adapter_info[0].port_info[0]), &ch, 1);
+
+	spin_unlock(&serial_lock);
+}
+
+#ifdef ICOM_TRACE
+void TRACE(struct icom_port *icom_port_ptr, u32 trace_pt,
+	   u32 trace_data) {
+    u32 *tp_start, *tp_end, **tp_next;
+
+    if (trace_pt == TRACE_GET_MEM) {
+	if (icom_port_ptr->trace_blk != 0) return;
+	icom_port_ptr->trace_blk = kmalloc(TRACE_BLK_SZ,GFP_KERNEL);
+	memset(icom_port_ptr->trace_blk, 0,TRACE_BLK_SZ);
+	icom_port_ptr->trace_blk[0] = (unsigned long)icom_port_ptr->trace_blk + 3*sizeof(unsigned long);
+	icom_port_ptr->trace_blk[1] = (unsigned long)icom_port_ptr->trace_blk + TRACE_BLK_SZ;
+	icom_port_ptr->trace_blk[2] = icom_port_ptr->trace_blk[0];
+    }
+    if (icom_port_ptr->trace_blk == 0) return;
+
+    if (trace_pt == TRACE_RET_MEM) {
+	kfree(icom_port_ptr->trace_blk);
+	icom_port_ptr->trace_blk = 0;
+	return;
+    }
+
+    tp_start  = (u32 *)icom_port_ptr->trace_blk[0];
+    tp_end    = (u32 *)icom_port_ptr->trace_blk[1];
+    tp_next   = (u32 **)&icom_port_ptr->trace_blk[2];
+
+    if (trace_data != 0) {
+	**tp_next = trace_data;
+	*tp_next = *tp_next + 1;
+	if (*tp_next == tp_end) *tp_next = tp_start;
+	**tp_next = TRACE_WITH_DATA | trace_pt;
+    }
+    else
+	**tp_next = trace_pt;
+
+    *tp_next = *tp_next + 1;
+    if (*tp_next == tp_end) *tp_next = tp_start;
+}
+#endif
+
+EXPORT_SYMBOL(recvd);
+EXPORT_SYMBOL(iCom_sercons_init);
+EXPORT_SYMBOL(icom_adapter_info);
+
+#endif /* ICOM */
diff -urNp linux-8160/drivers/char/Makefile linux-8161/drivers/char/Makefile
--- linux-8160/drivers/char/Makefile
+++ linux-8161/drivers/char/Makefile
@@ -24,7 +24,7 @@ obj-y	 += mem.o tty_io.o n_tty.o tty_ioc
 export-objs     :=	busmouse.o console.o keyboard.o sysrq.o \
 			misc.o pty.o random.o selection.o serial.o \
 			sonypi.o tty_io.o tty_ioctl.o generic_serial.o \
-			au1000_gpio.o hp_psaux.o nvram.o scx200.o
+			au1000_gpio.o hp_psaux.o nvram.o scx200.o icom.o
 
 mod-subdirs	:=	joystick ftape drm drm-4.0 pcmcia
 
diff -urNp linux-8160/drivers/char/icom.c linux-8161/drivers/char/icom.c
--- linux-8160/drivers/char/icom.c
+++ linux-8161/drivers/char/icom.c
@@ -75,10 +75,15 @@ MODULE_LICENSE("GPL");
 
 #include <asm/iSeries/iSeries_pci.h>
 #include <asm/iSeries/iSeries_dma.h>
+#include <asm/iSeries/HvCallCfg.h>
 #endif
 
+
 /* adapter code loads */
 #include "icom.h"
+/* icom structure declarations. */
+#include <linux/icom_udbg.h>
+
 
 #define ICOM_TRACE /* enable port trace capabilities */
 
@@ -122,94 +127,6 @@ static const struct pci_device_id icom_p
 };
 MODULE_DEVICE_TABLE(pci, icom_pci_table);
 
-/*
- * adapter defines and structures
- */
-#define ICOM_CONTROL_START_A         0x00000008
-#define ICOM_CONTROL_STOP_A          0x00000004
-#define ICOM_CONTROL_START_B         0x00000002
-#define ICOM_CONTROL_STOP_B          0x00000001
-#define ICOM_CONTROL_START_C         0x00000008
-#define ICOM_CONTROL_STOP_C          0x00000004
-#define ICOM_CONTROL_START_D         0x00000002
-#define ICOM_CONTROL_STOP_D          0x00000001
-#define ICOM_IRAM_OFFSET             0x1000
-#define ICOM_DCE_IRAM_OFFSET         0x0A00
-#define ICOM_CABLE_ID_VALID          0x01
-#define ICOM_CABLE_ID_MASK           0xF0
-#define ICOM_DISABLE                 0x80
-#define CMD_XMIT_RCV_ENABLE          0xC0
-#define CMD_XMIT_ENABLE              0x40
-#define CMD_RCV_DISABLE              0x00
-#define CMD_RCV_ENABLE               0x80
-#define CMD_RESTART                  0x01
-#define CMD_HOLD_XMIT                0x02
-#define CMD_SND_BREAK                0x04
-#define RS232_CABLE                  0x06
-#define V24_CABLE                    0x0E
-#define V35_CABLE                    0x0C
-#define V36_CABLE                    0x02
-#define NO_CABLE                     0x00
-#define START_DOWNLOAD               0x80
-#define ICOM_INT_MASK_PRC_A          0x00003FFF
-#define ICOM_INT_MASK_PRC_B          0x3FFF0000
-#define ICOM_INT_MASK_PRC_C          0x00003FFF
-#define ICOM_INT_MASK_PRC_D          0x3FFF0000
-#define INT_RCV_COMPLETED            0x1000
-#define INT_XMIT_COMPLETED           0x2000
-#define INT_IDLE_DETECT              0x0800
-#define INT_RCV_DISABLED             0x0400
-#define INT_XMIT_DISABLED            0x0200
-#define INT_RCV_XMIT_SHUTDOWN        0x0100
-#define INT_FATAL_ERROR              0x0080
-#define INT_CABLE_PULL               0x0020
-#define INT_SIGNAL_CHANGE            0x0010
-#define HDLC_PPP_PURE_ASYNC          0x02
-#define HDLC_FF_FILL                 0x00
-#define HDLC_HDW_FLOW                0x01
-#define START_XMIT                   0x80
-#define ICOM_ACFG_DRIVE1             0x20
-#define ICOM_ACFG_NO_PARITY          0x00
-#define ICOM_ACFG_PARITY_ENAB        0x02
-#define ICOM_ACFG_PARITY_ODD         0x01
-#define ICOM_ACFG_8BPC               0x00
-#define ICOM_ACFG_7BPC               0x04
-#define ICOM_ACFG_6BPC               0x08
-#define ICOM_ACFG_5BPC               0x0C
-#define ICOM_ACFG_1STOP_BIT          0x00
-#define ICOM_ACFG_2STOP_BIT          0x10
-#define ICOM_DTR                     0x80
-#define ICOM_RTS                     0x40
-#define ICOM_RI                      0x08
-#define ICOM_DSR                     0x80
-#define ICOM_DCD                     0x20
-#define ICOM_CTS                     0x40
-
-#define BAUD_TABLE_LIMIT             20
-static int icom_acfg_baud[] = {
-    300,
-    600,
-    900,
-    1200,
-    1800,
-    2400,
-    3600,
-    4800,
-    7200,
-    9600,
-    14400,
-    19200,
-    28800,
-    38400,
-    57600,
-    76800,
-    115200,
-    153600,
-    230400,
-    307200,
-    460800
-};
-
 static int                active_adapters;
 static struct tty_driver  serial_driver;
 static int                serial_refcount = 0;
@@ -217,201 +134,7 @@ static struct tty_struct *serial_table[M
 static struct termios    *serial_termios[MAX_PORTS];
 static struct termios    *serial_termios_locked[MAX_PORTS];
 
-struct icom_regs {
-    u32                  control;        /* Adapter Control Register     */
-    u32                  interrupt;      /* Adapter Interrupt Register   */
-    u32                  int_mask;       /* Adapter Interrupt Mask Reg   */
-    u32                  int_pri;        /* Adapter Interrupt Priority r */
-    u32                  int_reg_b;      /* Adapter non-masked Interrupt */
-    u32                  resvd01;
-    u32                  resvd02;
-    u32                  resvd03;
-    u32                  control_2;      /* Adapter Control Register 2   */
-    u32                  interrupt_2;    /* Adapter Interrupt Register 2 */
-    u32                  int_mask_2;     /* Adapter Interrupt Mask 2     */
-    u32                  int_pri_2;      /* Adapter Interrupt Prior 2    */
-    u32                  int_reg_2b;     /* Adapter non-masked 2         */
-};
-
-struct func_dram {
-    u32                 reserved[108];          /* 0-1B0   reserved by personality code */
-    u32                 RcvStatusAddr;          /* 1B0-1B3 Status Address for Next rcv */
-    u8                  RcvStnAddr;             /* 1B4     Receive Station Addr */
-    u8                  IdleState;              /* 1B5     Idle State */
-    u8                  IdleMonitor;            /* 1B6     Idle Monitor */
-    u8                  FlagFillIdleTimer;      /* 1B7     Flag Fill Idle Timer */
-    u32                 XmitStatusAddr;         /* 1B8-1BB Transmit Status Address */
-    u8                  StartXmitCmd;           /* 1BC     Start Xmit Command */
-    u8                  HDLCConfigReg;          /* 1BD     Reserved */
-    u8                  CauseCode;              /* 1BE     Cause code for fatal error */
-    u8                  xchar;                  /* 1BF     High priority send */
-    u32                 reserved3;              /* 1C0-1C3 Reserved */
-    u8                  PrevCmdReg;             /* 1C4     Reserved */
-    u8                  CmdReg;                 /* 1C5     Command Register */
-    u8                  async_config2;          /* 1C6     Async Config Byte 2*/
-    u8                  async_config3;          /* 1C7     Async Config Byte 3*/
-    u8                  dce_resvd[20];          /* 1C8-1DB DCE Rsvd           */
-    u8                  dce_resvd21;            /* 1DC     DCE Rsvd (21st byte*/
-    u8                  misc_flags;             /* 1DD     misc flags         */
-#define V2_HARDWARE     0x40
-#define ICOM_HDW_ACTIVE 0x01
-    u8                  call_length;            /* 1DE     Phone #/CFI buff ln*/
-    u8                  call_length2;           /* 1DF     Upper byte (unused)*/
-    u32                 call_addr;              /* 1E0-1E3 Phn #/CFI buff addr*/
-    u16                 timer_value;            /* 1E4-1E5 general timer value*/
-    u8                  timer_command;          /* 1E6     general timer cmd  */
-    u8                  dce_command;            /* 1E7     dce command reg    */
-    u8                  dce_cmd_status;         /* 1E8     dce command stat   */
-    u8                  x21_r1_ioff;            /* 1E9     dce ready counter  */
-    u8                  x21_r0_ioff;            /* 1EA     dce not ready ctr  */
-    u8                  x21_ralt_ioff;          /* 1EB     dce CNR counter    */
-    u8                  x21_r1_ion;             /* 1EC     dce ready I on ctr */
-    u8                  rsvd_ier;               /* 1ED     Rsvd for IER (if ne*/
-    u8                  ier;                    /* 1EE     Interrupt Enable   */
-    u8                  isr;                    /* 1EF     Input Signal Reg   */
-    u8                  osr;                    /* 1F0     Output Signal Reg  */
-    u8                  reset;                  /* 1F1     Reset/Reload Reg   */
-    u8                  disable;                /* 1F2     Disable Reg        */
-    u8                  sync;                   /* 1F3     Sync Reg           */
-    u8                  error_stat;             /* 1F4     Error Status       */
-    u8                  cable_id;               /* 1F5     Cable ID           */
-    u8                  cs_length;              /* 1F6     CS Load Length     */
-    u8                  mac_length;             /* 1F7     Mac Load Length    */
-    u32                 cs_load_addr;           /* 1F8-1FB Call Load PCI Addr */
-    u32                 mac_load_addr;          /* 1FC-1FF Mac Load PCI Addr  */
-};
-
-#define NUM_XBUFFS 1
-#define NUM_RBUFFS 2
-#define RCV_BUFF_SZ 0x0200
-#define XMIT_BUFF_SZ 0x1000
-struct statusArea {
-    /**********************************************/
-    /* Transmit Status Area                       */
-    /**********************************************/
-    struct {
-        u32                    leNext;         /* Next entry in Little Endian on Adapter */
-        u32                    leNextASD;
-        u32                    leBuffer;       /* Buffer for entry in LE for Adapter */
-        u16                    leLengthASD;
-        u16                    leOffsetASD;
-        u16                    leLength;       /* Length of data in segment */
-        u16                    flags;
-#define SA_FLAGS_DONE           0x0080          /* Done with Segment */
-#define SA_FLAGS_CONTINUED      0x8000          /* More Segments */
-#define SA_FLAGS_IDLE           0x4000          /* Mark IDLE after frm */
-#define SA_FLAGS_READY_TO_XMIT  0x0800
-#define SA_FLAGS_STAT_MASK      0x007F
-    } xmit[NUM_XBUFFS];
-
-    /**********************************************/
-    /* Receive Status Area                        */
-    /**********************************************/
-    struct {
-        u32                    leNext;         /* Next entry in Little Endian on Adapter */
-        u32                    leNextASD;
-        u32                    leBuffer;       /* Buffer for entry in LE for Adapter */
-        u16                    WorkingLength;  /* size of segment */
-        u16                    reserv01;
-        u16                    leLength;       /* Length of data in segment */
-        u16                    flags;
-#define SA_FL_RCV_DONE           0x0010          /* Data ready */
-#define SA_FLAGS_OVERRUN         0x0040
-#define SA_FLAGS_PARITY_ERROR    0x0080 
-#define SA_FLAGS_FRAME_ERROR     0x0001
-#define SA_FLAGS_FRAME_TRUNC     0x0002
-#define SA_FLAGS_BREAK_DET       0x0004    /* set conditionally by device driver, not hardware */
-#define SA_FLAGS_RCV_MASK        0xFFE6
-    } rcv[NUM_RBUFFS];
-};
-
-struct icom_port {
-    u8                    imbed_modem;
-#define   ICOM_UNKNOWN       1
-#define   ICOM_RVX           2
-#define   ICOM_IMBED_MODEM   3
-    unsigned char         cable_id;
-    int                   open_active_count;
-    struct tty_struct     *tty;
-    unsigned long         event;
-    struct tq_struct      tqueue;
-    int                   flags;
-    int                   xmit_fifo_size;
-    int                   baud_base;
-    wait_queue_head_t     close_wait;
-    wait_queue_head_t     open_wait;
-    wait_queue_head_t     delta_msr_wait;
-    int                   blocked_open;
-    unsigned short        close_delay;
-    unsigned short        closing_wait;
-    unsigned long         timeout;
-    long                  session; /* Session of opening process */
-    long                  pgrp; /* pgrp of opening process */
-    unsigned char         read_status_mask;
-    unsigned char         ignore_status_mask;
-    struct async_icount	  icount;	
-    struct termios        normal_termios;
-    struct termios        callout_termios;
-    unsigned long         int_reg;
-    struct icom_regs      *global_reg;
-    struct func_dram      *dram;
-    int                   adapter;
-    int                   port;
-    int                   minor_number;
-    struct statusArea     *statStg;
-    dma_addr_t            statStg_pci;
-    u32                   *xmitRestart;
-    dma_addr_t            xmitRestart_pci;
-    unsigned char         *xmit_buf;
-    dma_addr_t            xmit_buf_pci;
-    unsigned char         *recv_buf;
-    dma_addr_t            recv_buf_pci;
-    int                   next_rcv;
-    int                   put_length;
-    int                   passed_diags;
-    int                   status;
-#define ICOM_PORT_ACTIVE  1 /* Port exists. */
-#define ICOM_PORT_OFF     0 /* Port does not exist. */
-    int                   load_in_progress;
-    u32                   tpr;
-#define NUM_ERROR_ENTRIES 16
-    u32                   error_data[NUM_ERROR_ENTRIES];
-    u32                   thread_status;
-#define STATUS_INIT 0x99999999
-#define STATUS_PASS 0 
-    unsigned long         *trace_blk;
-};
-
-static struct icom_adapter {
-    unsigned long      base_addr;
-    unsigned char      slot;
-    unsigned char      irq_number;
-    struct pci_dev     *pci_dev;
-    struct icom_port   port_info[4];
-    int                version;
-#define ADAPTER_V1   0x0001
-#define ADAPTER_V2   0x0002
-    u32                subsystem_id;
-#define FOUR_PORT_MODEL				0x02521014
-#define V2_TWO_PORTS_RVX			0x021A1014
-#define V2_ONE_PORT_RVX_ONE_PORT_IMBED_MDM	0x02511014
-    int                numb_ports;
-    unsigned int       saved_bar;
-    unsigned int       saved_command_reg;
-    u32                tpr;
-    u32                error_data[NUM_ERROR_ENTRIES];
-    u32                diag_int1;
-    u32                diag_int2;
-    u32                diag_int_pri1;
-    u32                diag_int_pri2;
-    u32                diag_int_reset1;
-    u32                diag_int_reset2;
-    u32                resources;
-#define HAVE_MALLOC_1	        0x00000001
-#define HAVE_INT_HANDLE		0x00000010
-    u32                *malloc_addr_1;
-    dma_addr_t         malloc_addr_1_pci;
-} *icom_adapter_info;
+extern struct icom_adapter *icom_adapter_info;
 
 struct mthread
 {
@@ -811,9 +534,12 @@ static void load_code (struct icom_port 
      * check Cable ID
      */
     cable_id = readb(&icom_port_info->dram->cable_id);
+
     if (cable_id & ICOM_CABLE_ID_VALID) {
         /* Get cable ID into the lower 4 bits (standard form) */
+	printk(KERN_INFO"icom: cable_id (%d) -> ",cable_id);
         cable_id = (cable_id & ICOM_CABLE_ID_MASK) >> 4;
+	printk(KERN_INFO"icom: cable_id (%d)\n",cable_id);
         icom_port_info->cable_id = cable_id;
     }
     else {
@@ -1213,7 +939,8 @@ static int startup(struct icom_port *ico
     cable_id = (raw_cable_id & ICOM_CABLE_ID_MASK) >> 4;
 
     /* Check Cable ID is RS232 */
-    if (!(raw_cable_id & ICOM_CABLE_ID_VALID) || (cable_id != RS232_CABLE))
+/*  if (!(raw_cable_id & ICOM_CABLE_ID_VALID) || (cable_id != RS232_CABLE)) */
+    if (0)
     {
         /* reload adapter code, pick up any potential changes in cable id */
         if (icom_port_info->load_in_progress) {
@@ -3305,6 +3032,10 @@ static int icom_init(void)
         /* lastly, register unique ioctl */
         register_ioctl32_conversion(0x4300,NULL);
 
+#ifdef CONFIG_PPC_ISERIES
+	iCom_sercons_init();
+#endif
+
         return 0;
     }
     else {
@@ -5218,7 +4949,7 @@ static u32 __init diag_main(struct icom_
     }
     else {
 #ifdef icom_debug
-        printkx(KERN_ERR"icom: Diagnostic FAILED ********\n");
+        printk(KERN_ERR"icom: Diagnostic FAILED ********\n");
 #endif
     }
 
diff -urNp linux-8160/drivers/char/icom.h linux-8161/drivers/char/icom.h
--- linux-8160/drivers/char/icom.h
+++ linux-8161/drivers/char/icom.h
@@ -19,96 +19,6 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
-#define TRACE_BLK_SZ         1024
-#define TRACE_WITH_DATA      0x80000000
-#define TRACE_TIME           0x40000000
-#define TRACE_GET_MEM        0x20000000
-#define TRACE_RET_MEM        0x10000000
-#define TRACE_GET_PORT_MEM   0x00000001
-#define TRACE_FOD_ADDR       0x00000005
-#define TRACE_FOD_XBUFF      0x00000006
-#define TRACE_FID_ADDR       0x00000007
-#define TRACE_FID_RBUFF      0x00000008
-#define TRACE_RET_PORT_MEM   0x00000100
-#define TRACE_LOAD_MEM       0x00000200
-#define TRACE_CHANGE_SPEED   0x00000300
-#define TRACE_PARENB         0x00000301
-#define TRACE_PARODD         0x00000302
-#define TRACE_XR_ENAB        0x00000303
-#define TRACE_STARTUP        0x00000400
-#define TRACE_CABLE_ID       0x00000401
-#define TRACE_SHUTDOWN       0x00000500
-#define TRACE_DEVICE_NUMB    0x00000600
-#define TRACE_STARTUP_ERROR  0x00000601
-#define TRACE_CLOSE          0x00000700
-#define TRACE_CLOSE_HANGUP   0x00000701
-#define TRACE_OPEN_ACTIVE    0x00000702
-#define TRACE_WRITE          0x00000800
-#define TRACE_WRITE_FULL     0x00000801
-#define TRACE_WRITE_NODATA   0x00000802
-#define TRACE_WRITE_START    0x00000803
-#define TRACE_PUT_CHAR       0x00000900
-#define TRACE_PUT_FULL       0x00000901
-#define TRACE_FLUSH_CHAR     0x00000a00
-#define TRACE_START_FLUSH    0x00000a01
-#define TRACE_WRITE_ROOM     0x00000b00
-#define TRACE_CHARS_IN_BUFF  0x00000c00
-#define TRACE_CHARS_REMAIN   0x00000c01
-#define TRACE_GET_MODEM      0x00000d00
-#define TRACE_SET_MODEM      0x00000e00
-#define TRACE_RAISE_RTS      0x00000e01
-#define TRACE_RAISE_DTR      0x00000e02
-#define TRACE_LOWER_RTS      0x00000e03
-#define TRACE_LOWER_DTR      0x00000e04
-#define TRACE_GET_SERIAL     0x00000f00
-#define TRACE_SET_SERIAL     0x00001000
-#define TRACE_SET_LSR        0x00001100
-#define TRACE_IOCTL          0x00001200
-#define TRACE_IOCTL_IGNORE   0x00001201
-#define TRACE_SEND_XCHAR     0x00001300
-#define TRACE_QUICK_WRITE    0x00001301
-#define TRACE_THROTTLE       0x00001400
-#define TRACE_UNTHROTTLE     0x00001500
-#define TRACE_SET_TERMIOS    0x00001600
-#define TRACE_STOP           0x00001700
-#define TRACE_START          0x00001800
-#define TRACE_HANGUP         0x00001900
-#define TRACE_BREAK          0x00001a00
-#define TRACE_WAIT_UNTIL_SENT  0x00001b00
-#define TRACE_FLUSH_BUFFER     0x00001c00
-#define TRACE_CHECK_MODEM      0x00001d00
-#define TRACE_CTS_UP           0x00001d01
-#define TRACE_CTS_DOWN         0x00001d02
-#define TRACE_INTERRUPT        0x00001e00
-#define TRACE_XMIT_COMPLETE    0x00001e01
-#define TRACE_RCV_COMPLETE     0x00001e02
-#define TRACE_FID_STATUS       0x00001e03
-#define TRACE_RCV_COUNT        0x00001e04
-#define TRACE_REAL_COUNT       0x00001e05
-#define TRACE_BREAK_DET        0x00001e06
-#define TRACE_IGNORE_CHAR      0x00001e07
-#define TRACE_PARITY_ERROR     0x00001e08
-#define TRACE_XMIT_DISABLED    0x00001e09
-#define TRACE_WAKEUP           0x00001f00
-#define TRACE_CLEAR_INTERRUPTS 0x0000ff00
-#define TRACE_START_PROC_A     0x0000ff01
-#define TRACE_START_PROC_B     0x0000ff02
-#define TRACE_STOP_PROC_A      0x0000ff03
-#define TRACE_STOP_PROC_B      0x0000ff04
-#define TRACE_RAISE_DTR_RTS    0x0000ff05
-#define TRACE_START_PROC_C     0x0000ff06
-#define TRACE_START_PROC_D     0x0000ff07
-#define TRACE_STOP_PROC_C      0x0000ff08
-#define TRACE_STOP_PROC_D      0x0000ff09
-#define TRACE_ENABLE_INTERRUPTS_PA 0x0000ff0a
-#define TRACE_ENABLE_INTERRUPTS_PB 0x0000ff0b
-#define TRACE_ENABLE_INTERRUPTS_PC 0x0000ff0c
-#define TRACE_ENABLE_INTERRUPTS_PD 0x0000ff0d
-#define TRACE_DIS_INTERRUPTS_PA 0x0000ff0e
-#define TRACE_DIS_INTERRUPTS_PB 0x0000ff0f
-#define TRACE_DIS_INTERRUPTS_PC 0x0000ff10
-#define TRACE_DIS_INTERRUPTS_PD 0x0000ff11
-#define TRACE_DROP_DTR_RTS   0x0000ff12
 
 #ifndef TRACE_ONLY
 
@@ -291,7 +201,9 @@
 #define DIAG_SMINTWRP_NOT_CONNECT_FAIL_TPR      0xCD700FA0
 #define DIAG_SMINTWRP_NOT_OK_FAIL1_TPR          0xCD700FB0
 #define DIAG_SMINTWRP_END_TPR                   0xCD700FC0
- 
+
+#endif
+
 static unsigned char callSetup[1968] = 
           {0xBD,0xD9,0x23,0x00,0xDD,0xDD,0x18,0x05,0x23,0x80,0x3E,0x7F,0x23,0x00,0x3E,0x7C,
            0x23,0x10,0x3E,0xB7,0x3E,0xB5,0x23,0x20,0x3E,0xB6,0x3E,0xB4,0xA2,0x0A,0x86,0x0A,
@@ -991,4 +903,3 @@ static unsigned char towrapdiag[1376] = 
            0x3E,0x06,0x3E,0x08,0x68,0x6A,0x23,0x55,0x3E,0x00,0x23,0x1D,0x3E,0x00,0x68,0x6D,
            0x82,0xF4,0x02,0xA9,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
 
-#endif
diff -urNp linux-8160/include/linux/icom_udbg.h linux-8161/include/linux/icom_udbg.h
--- linux-8160/include/linux/icom_udbg.h
+++ linux-8161/include/linux/icom_udbg.h
@@ -0,0 +1,401 @@
+/*
+ * iCom_udbg.h
+ *
+ * Copyright (C) 2001 Michael Anderson, IBM Corporation
+ *
+ * Serial device driver include file.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#define TRACE_BLK_SZ         1024
+#define TRACE_WITH_DATA      0x80000000
+#define TRACE_TIME           0x40000000
+#define TRACE_GET_MEM        0x20000000
+#define TRACE_RET_MEM        0x10000000
+#define TRACE_GET_PORT_MEM   0x00000001
+#define TRACE_FOD_ADDR       0x00000005
+#define TRACE_FOD_XBUFF      0x00000006
+#define TRACE_FID_ADDR       0x00000007
+#define TRACE_FID_RBUFF      0x00000008
+#define TRACE_RET_PORT_MEM   0x00000100
+#define TRACE_LOAD_MEM       0x00000200
+#define TRACE_CHANGE_SPEED   0x00000300
+#define TRACE_PARENB         0x00000301
+#define TRACE_PARODD         0x00000302
+#define TRACE_XR_ENAB        0x00000303
+#define TRACE_STARTUP        0x00000400
+#define TRACE_CABLE_ID       0x00000401
+#define TRACE_SHUTDOWN       0x00000500
+#define TRACE_DEVICE_NUMB    0x00000600
+#define TRACE_STARTUP_ERROR  0x00000601
+#define TRACE_CLOSE          0x00000700
+#define TRACE_CLOSE_HANGUP   0x00000701
+#define TRACE_OPEN_ACTIVE    0x00000702
+#define TRACE_WRITE          0x00000800
+#define TRACE_WRITE_FULL     0x00000801
+#define TRACE_WRITE_NODATA   0x00000802
+#define TRACE_WRITE_START    0x00000803
+#define TRACE_PUT_CHAR       0x00000900
+#define TRACE_PUT_FULL       0x00000901
+#define TRACE_FLUSH_CHAR     0x00000a00
+#define TRACE_START_FLUSH    0x00000a01
+#define TRACE_WRITE_ROOM     0x00000b00
+#define TRACE_CHARS_IN_BUFF  0x00000c00
+#define TRACE_CHARS_REMAIN   0x00000c01
+#define TRACE_GET_MODEM      0x00000d00
+#define TRACE_SET_MODEM      0x00000e00
+#define TRACE_RAISE_RTS      0x00000e01
+#define TRACE_RAISE_DTR      0x00000e02
+#define TRACE_LOWER_RTS      0x00000e03
+#define TRACE_LOWER_DTR      0x00000e04
+#define TRACE_GET_SERIAL     0x00000f00
+#define TRACE_SET_SERIAL     0x00001000
+#define TRACE_SET_LSR        0x00001100
+#define TRACE_IOCTL          0x00001200
+#define TRACE_IOCTL_IGNORE   0x00001201
+#define TRACE_SEND_XCHAR     0x00001300
+#define TRACE_QUICK_WRITE    0x00001301
+#define TRACE_THROTTLE       0x00001400
+#define TRACE_UNTHROTTLE     0x00001500
+#define TRACE_SET_TERMIOS    0x00001600
+#define TRACE_STOP           0x00001700
+#define TRACE_START          0x00001800
+#define TRACE_HANGUP         0x00001900
+#define TRACE_BREAK          0x00001a00
+#define TRACE_WAIT_UNTIL_SENT  0x00001b00
+#define TRACE_FLUSH_BUFFER     0x00001c00
+#define TRACE_CHECK_MODEM      0x00001d00
+#define TRACE_CTS_UP           0x00001d01
+#define TRACE_CTS_DOWN         0x00001d02
+#define TRACE_INTERRUPT        0x00001e00
+#define TRACE_XMIT_COMPLETE    0x00001e01
+#define TRACE_RCV_COMPLETE     0x00001e02
+#define TRACE_FID_STATUS       0x00001e03
+#define TRACE_RCV_COUNT        0x00001e04
+#define TRACE_REAL_COUNT       0x00001e05
+#define TRACE_BREAK_DET        0x00001e06
+#define TRACE_IGNORE_CHAR      0x00001e07
+#define TRACE_PARITY_ERROR     0x00001e08
+#define TRACE_XMIT_DISABLED    0x00001e09
+#define TRACE_WAKEUP           0x00001f00
+#define TRACE_CLEAR_INTERRUPTS 0x0000ff00
+#define TRACE_START_PROC_A     0x0000ff01
+#define TRACE_START_PROC_B     0x0000ff02
+#define TRACE_STOP_PROC_A      0x0000ff03
+#define TRACE_STOP_PROC_B      0x0000ff04
+#define TRACE_RAISE_DTR_RTS    0x0000ff05
+#define TRACE_START_PROC_C     0x0000ff06
+#define TRACE_START_PROC_D     0x0000ff07
+#define TRACE_STOP_PROC_C      0x0000ff08
+#define TRACE_STOP_PROC_D      0x0000ff09
+#define TRACE_ENABLE_INTERRUPTS_PA 0x0000ff0a
+#define TRACE_ENABLE_INTERRUPTS_PB 0x0000ff0b
+#define TRACE_ENABLE_INTERRUPTS_PC 0x0000ff0c
+#define TRACE_ENABLE_INTERRUPTS_PD 0x0000ff0d
+#define TRACE_DIS_INTERRUPTS_PA 0x0000ff0e
+#define TRACE_DIS_INTERRUPTS_PB 0x0000ff0f
+#define TRACE_DIS_INTERRUPTS_PC 0x0000ff10
+#define TRACE_DIS_INTERRUPTS_PD 0x0000ff11
+#define TRACE_DROP_DTR_RTS   0x0000ff12
+
+#define BAUD_TABLE_LIMIT             20
+static int icom_acfg_baud[] = {
+    300,
+    600,
+    900,
+    1200,
+    1800,
+    2400,
+    3600,
+    4800,
+    7200,
+    9600,
+    14400,
+    19200,
+    28800,
+    38400,
+    57600,
+    76800,
+    115200,
+    153600,
+    230400,
+    307200,
+    460800
+};
+
+struct icom_regs {
+    u32                  control;        /* Adapter Control Register     */
+    u32                  interrupt;      /* Adapter Interrupt Register   */
+    u32                  int_mask;       /* Adapter Interrupt Mask Reg   */
+    u32                  int_pri;        /* Adapter Interrupt Priority r */
+    u32                  int_reg_b;      /* Adapter non-masked Interrupt */
+    u32                  resvd01;
+    u32                  resvd02;
+    u32                  resvd03;
+    u32                  control_2;      /* Adapter Control Register 2   */
+    u32                  interrupt_2;    /* Adapter Interrupt Register 2 */
+    u32                  int_mask_2;     /* Adapter Interrupt Mask 2     */
+    u32                  int_pri_2;      /* Adapter Interrupt Prior 2    */
+    u32                  int_reg_2b;     /* Adapter non-masked 2         */
+};
+
+struct func_dram {
+    u32                 reserved[108];          /* 0-1B0   reserved by personality code */
+    u32                 RcvStatusAddr;          /* 1B0-1B3 Status Address for Next rcv */
+    u8                  RcvStnAddr;             /* 1B4     Receive Station Addr */
+    u8                  IdleState;              /* 1B5     Idle State */
+    u8                  IdleMonitor;            /* 1B6     Idle Monitor */
+    u8                  FlagFillIdleTimer;      /* 1B7     Flag Fill Idle Timer */
+    u32                 XmitStatusAddr;         /* 1B8-1BB Transmit Status Address */
+    u8                  StartXmitCmd;           /* 1BC     Start Xmit Command */
+    u8                  HDLCConfigReg;          /* 1BD     Reserved */
+    u8                  CauseCode;              /* 1BE     Cause code for fatal error */
+    u8                  xchar;                  /* 1BF     High priority send */
+    u32                 reserved3;              /* 1C0-1C3 Reserved */
+    u8                  PrevCmdReg;             /* 1C4     Reserved */
+    u8                  CmdReg;                 /* 1C5     Command Register */
+    u8                  async_config2;          /* 1C6     Async Config Byte 2*/
+    u8                  async_config3;          /* 1C7     Async Config Byte 3*/
+    u8                  dce_resvd[20];          /* 1C8-1DB DCE Rsvd           */
+    u8                  dce_resvd21;            /* 1DC     DCE Rsvd (21st byte*/
+    u8                  misc_flags;             /* 1DD     misc flags         */
+#define V2_HARDWARE     0x40
+#define ICOM_HDW_ACTIVE 0x01
+    u8                  call_length;            /* 1DE     Phone #/CFI buff ln*/
+    u8                  call_length2;           /* 1DF     Upper byte (unused)*/
+    u32                 call_addr;              /* 1E0-1E3 Phn #/CFI buff addr*/
+    u16                 timer_value;            /* 1E4-1E5 general timer value*/
+    u8                  timer_command;          /* 1E6     general timer cmd  */
+    u8                  dce_command;            /* 1E7     dce command reg    */
+    u8                  dce_cmd_status;         /* 1E8     dce command stat   */
+    u8                  x21_r1_ioff;            /* 1E9     dce ready counter  */
+    u8                  x21_r0_ioff;            /* 1EA     dce not ready ctr  */
+    u8                  x21_ralt_ioff;          /* 1EB     dce CNR counter    */
+    u8                  x21_r1_ion;             /* 1EC     dce ready I on ctr */
+    u8                  rsvd_ier;               /* 1ED     Rsvd for IER (if ne*/
+    u8                  ier;                    /* 1EE     Interrupt Enable   */
+    u8                  isr;                    /* 1EF     Input Signal Reg   */
+    u8                  osr;                    /* 1F0     Output Signal Reg  */
+    u8                  reset;                  /* 1F1     Reset/Reload Reg   */
+    u8                  disable;                /* 1F2     Disable Reg        */
+    u8                  sync;                   /* 1F3     Sync Reg           */
+    u8                  error_stat;             /* 1F4     Error Status       */
+    u8                  cable_id;               /* 1F5     Cable ID           */
+    u8                  cs_length;              /* 1F6     CS Load Length     */
+    u8                  mac_length;             /* 1F7     Mac Load Length    */
+    u32                 cs_load_addr;           /* 1F8-1FB Call Load PCI Addr */
+    u32                 mac_load_addr;          /* 1FC-1FF Mac Load PCI Addr  */
+};
+
+/*
+ * adapter defines and structures
+ */
+#define ICOM_CONTROL_START_A         0x00000008
+#define ICOM_CONTROL_STOP_A          0x00000004
+#define ICOM_CONTROL_START_B         0x00000002
+#define ICOM_CONTROL_STOP_B          0x00000001
+#define ICOM_CONTROL_START_C         0x00000008
+#define ICOM_CONTROL_STOP_C          0x00000004
+#define ICOM_CONTROL_START_D         0x00000002
+#define ICOM_CONTROL_STOP_D          0x00000001
+#define ICOM_IRAM_OFFSET             0x1000
+#define ICOM_DCE_IRAM_OFFSET         0x0A00
+#define ICOM_CABLE_ID_VALID          0x01
+#define ICOM_CABLE_ID_MASK           0xF0
+#define ICOM_DISABLE                 0x80
+#define CMD_XMIT_RCV_ENABLE          0xC0
+#define CMD_XMIT_ENABLE              0x40
+#define CMD_RCV_DISABLE              0x00
+#define CMD_RCV_ENABLE               0x80
+#define CMD_RESTART                  0x01
+#define CMD_HOLD_XMIT                0x02
+#define CMD_SND_BREAK                0x04
+#define RS232_CABLE                  0x06
+#define V24_CABLE                    0x0E
+#define V35_CABLE                    0x0C
+#define V36_CABLE                    0x02
+#define NO_CABLE                     0x00
+#define START_DOWNLOAD               0x80
+#define ICOM_INT_MASK_PRC_A          0x00003FFF
+#define ICOM_INT_MASK_PRC_B          0x3FFF0000
+#define ICOM_INT_MASK_PRC_C          0x00003FFF
+#define ICOM_INT_MASK_PRC_D          0x3FFF0000
+#define INT_RCV_COMPLETED            0x1000
+#define INT_XMIT_COMPLETED           0x2000
+#define INT_IDLE_DETECT              0x0800
+#define INT_RCV_DISABLED             0x0400
+#define INT_XMIT_DISABLED            0x0200
+#define INT_RCV_XMIT_SHUTDOWN        0x0100
+#define INT_FATAL_ERROR              0x0080
+#define INT_CABLE_PULL               0x0020
+#define INT_SIGNAL_CHANGE            0x0010
+#define HDLC_PPP_PURE_ASYNC          0x02
+#define HDLC_FF_FILL                 0x00
+#define HDLC_HDW_FLOW                0x01
+#define START_XMIT                   0x80
+#define ICOM_ACFG_DRIVE1             0x20
+#define ICOM_ACFG_NO_PARITY          0x00
+#define ICOM_ACFG_PARITY_ENAB        0x02
+#define ICOM_ACFG_PARITY_ODD         0x01
+#define ICOM_ACFG_8BPC               0x00
+#define ICOM_ACFG_7BPC               0x04
+#define ICOM_ACFG_6BPC               0x08
+#define ICOM_ACFG_5BPC               0x0C
+#define ICOM_ACFG_1STOP_BIT          0x00
+#define ICOM_ACFG_2STOP_BIT          0x10
+#define ICOM_DTR                     0x80
+#define ICOM_RTS                     0x40
+#define ICOM_RI                      0x08
+#define ICOM_DSR                     0x80
+#define ICOM_DCD                     0x20
+#define ICOM_CTS                     0x40
+
+#define NUM_XBUFFS 1
+#define NUM_RBUFFS 2
+#define RCV_BUFF_SZ 0x0200
+#define XMIT_BUFF_SZ 0x1000
+struct statusArea {
+    /**********************************************/
+    /* Transmit Status Area                       */
+    /**********************************************/
+    struct {
+        u32                    leNext;         /* Next entry in Little Endian on Adapter */
+        u32                    leNextASD;
+        u32                    leBuffer;       /* Buffer for entry in LE for Adapter */
+        u16                    leLengthASD;
+        u16                    leOffsetASD;
+        u16                    leLength;       /* Length of data in segment */
+        u16                    flags;
+#define SA_FLAGS_DONE           0x0080          /* Done with Segment */
+#define SA_FLAGS_CONTINUED      0x8000          /* More Segments */
+#define SA_FLAGS_IDLE           0x4000          /* Mark IDLE after frm */
+#define SA_FLAGS_READY_TO_XMIT  0x0800
+#define SA_FLAGS_STAT_MASK      0x007F
+    } xmit[NUM_XBUFFS];
+
+    /**********************************************/
+    /* Receive Status Area                        */
+    /**********************************************/
+    struct {
+        u32                    leNext;         /* Next entry in Little Endian on Adapter */
+        u32                    leNextASD;
+        u32                    leBuffer;       /* Buffer for entry in LE for Adapter */
+        u16                    WorkingLength;  /* size of segment */
+        u16                    reserv01;
+        u16                    leLength;       /* Length of data in segment */
+        u16                    flags;
+#define SA_FL_RCV_DONE           0x0010          /* Data ready */
+#define SA_FLAGS_OVERRUN         0x0040
+#define SA_FLAGS_PARITY_ERROR    0x0080 
+#define SA_FLAGS_FRAME_ERROR     0x0001
+#define SA_FLAGS_FRAME_TRUNC     0x0002
+#define SA_FLAGS_BREAK_DET       0x0004    /* set conditionally by device driver, not hardware */
+#define SA_FLAGS_RCV_MASK        0xFFE6
+    } rcv[NUM_RBUFFS];
+};
+
+struct icom_port {
+    u8                    imbed_modem;
+#define   ICOM_UNKNOWN       1
+#define   ICOM_RVX           2
+#define   ICOM_IMBED_MODEM   3
+    unsigned char         cable_id;
+    int                   open_active_count;
+    struct tty_struct     *tty;
+    unsigned long         event;
+    struct tq_struct      tqueue;
+    int                   flags;
+    int                   xmit_fifo_size;
+    int                   baud_base;
+    wait_queue_head_t     close_wait;
+    wait_queue_head_t     open_wait;
+    wait_queue_head_t     delta_msr_wait;
+    int                   blocked_open;
+    unsigned short        close_delay;
+    unsigned short        closing_wait;
+    unsigned long         timeout;
+    long                  session; /* Session of opening process */
+    long                  pgrp; /* pgrp of opening process */
+    unsigned char         read_status_mask;
+    unsigned char         ignore_status_mask;
+    struct async_icount	  icount;	
+    struct termios        normal_termios;
+    struct termios        callout_termios;
+    unsigned long         int_reg;
+    struct icom_regs      *global_reg;
+    struct func_dram      *dram;
+    int                   adapter;
+    int                   port;
+    int                   minor_number;
+    struct statusArea     *statStg;
+    dma_addr_t            statStg_pci;
+    u32                   *xmitRestart;
+    dma_addr_t            xmitRestart_pci;
+    unsigned char         *xmit_buf;
+    dma_addr_t            xmit_buf_pci;
+    unsigned char         *recv_buf;
+    dma_addr_t            recv_buf_pci;
+    int                   next_rcv;
+    int                   put_length;
+    int                   passed_diags;
+    int                   status;
+#define ICOM_PORT_ACTIVE  1 /* Port exists. */
+#define ICOM_PORT_OFF     0 /* Port does not exist. */
+    int                   load_in_progress;
+    u32                   tpr;
+#define NUM_ERROR_ENTRIES 16
+    u32                   error_data[NUM_ERROR_ENTRIES];
+    u32                   thread_status;
+#define STATUS_INIT 0x99999999
+#define STATUS_PASS 0 
+    unsigned long         *trace_blk;
+};
+
+struct icom_adapter {
+    unsigned long      base_addr;
+    unsigned long      base_addr_pci;
+    unsigned char      slot;
+    unsigned char      irq_number;
+    struct pci_dev     *pci_dev;
+    struct icom_port   port_info[4];
+    int                version;
+#define ADAPTER_V1   0x0001
+#define ADAPTER_V2   0x0002
+    u32                subsystem_id;
+#define FOUR_PORT_MODEL				0x02521014
+#define V2_TWO_PORTS_RVX			0x021A1014
+#define V2_ONE_PORT_RVX_ONE_PORT_IMBED_MDM	0x02511014
+    int                numb_ports;
+    unsigned int       saved_bar;
+    unsigned int       saved_command_reg;
+    u32                tpr;
+    u32                error_data[NUM_ERROR_ENTRIES];
+    u32                diag_int1;
+    u32                diag_int2;
+    u32                diag_int_pri1;
+    u32                diag_int_pri2;
+    u32                diag_int_reset1;
+    u32                diag_int_reset2;
+    u32                resources;
+#define HAVE_MALLOC_1	        0x00000001
+#define HAVE_INT_HANDLE		0x00000010
+    u32                *malloc_addr_1;
+    dma_addr_t         malloc_addr_1_pci;
+};
+
+/* prototype */
+void iCom_sercons_init(void);
+
