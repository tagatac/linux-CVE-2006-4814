diff -urNp linux-278/arch/ia64/kernel/mca.c linux-279/arch/ia64/kernel/mca.c
--- linux-278/arch/ia64/kernel/mca.c
+++ linux-279/arch/ia64/kernel/mca.c
@@ -723,6 +723,7 @@ ia64_mca_wakeup_ipi_wait(void)
 			irr = ia64_get_irr3();
 			break;
 		}
+		cpu_relax();
 	} while (!(irr & (1UL << irr_bit))) ;
 }
 
diff -urNp linux-278/arch/ia64/kernel/process.c linux-279/arch/ia64/kernel/process.c
--- linux-278/arch/ia64/kernel/process.c
+++ linux-279/arch/ia64/kernel/process.c
@@ -145,6 +145,10 @@ default_idle (void)
 #ifdef CONFIG_IA64_PAL_IDLE
 	if (use_pal_halt && !current->need_resched)
 		safe_halt();
+	else
+		cpu_relax();
+#else
+	cpu_relax();
 #endif
 }
 
diff -urNp linux-278/arch/ia64/kernel/setup.c linux-279/arch/ia64/kernel/setup.c
--- linux-278/arch/ia64/kernel/setup.c
+++ linux-279/arch/ia64/kernel/setup.c
@@ -4,10 +4,15 @@
  * Copyright (C) 1998-2001 Hewlett-Packard Co
  *	David Mosberger-Tang <davidm@hpl.hp.com>
  *	Stephane Eranian <eranian@hpl.hp.com>
- * Copyright (C) 2000, Rohit Seth <rohit.seth@intel.com>
+ * Copyright (C) 2000, 2004 Intel Corp
+ * 	Rohit Seth <rohit.seth@intel.com>
+ * 	Suresh Siddha <suresh.b.siddha@intel.com>
+ * 	Gordon Jin <gordon.jin@intel.com>
  * Copyright (C) 1999 VA Linux Systems
  * Copyright (C) 1999 Walt Drummond <drummond@valinux.com>
  *
+ * 12/26/04 S.Siddha, G.Jin, R.Seth
+ *			Add multi-threading and multi-core detection
  * 11/12/01 D.Mosberger Convert get_cpuinfo() to seq_file based show_cpuinfo().
  * 04/04/00 D.Mosberger renamed cpu_initialized to cpu_online_map
  * 03/31/00 R.Seth	cpu_initialized and current->processor fixes
@@ -60,6 +65,7 @@ extern int blk_nohighio;
 #else
  struct cpuinfo_ia64 _cpu_data[NR_CPUS] __attribute__ ((section ("__special_page_section")));
 #endif
+struct cpuinfo_ia64_topology _cpu_data_topology[NR_CPUS];
 
 unsigned long ia64_cycles_per_usec;
 struct ia64_boot_param *ia64_boot_param;
@@ -284,6 +290,34 @@ find_memory (void)
 #endif
 }
 
+#ifdef CONFIG_SMP
+static void
+check_for_logical_procs (void)
+{
+	pal_logical_to_physical_t info;
+	s64 status;
+
+	status = ia64_pal_logical_to_phys(0, &info);
+	if (status == -1) {
+		printk(KERN_INFO "No logical to physical processor mapping "
+		       "available\n");
+		return;
+	}
+	if (status) {
+		printk(KERN_ERR "ia64_pal_logical_to_phys failed with %ld\n",
+		       status);
+		return;
+	}
+	/*
+	 * Total number of siblings that BSP has.  Though not all of them 
+	 * may have booted successfully. The correct number of siblings 
+	 * booted is in info.overview_num_log.
+	 */
+	smp_num_siblings = info.overview_tpc;
+	smp_num_cpucores = info.overview_cpp;
+}
+#endif
+
 void __init
 setup_arch (char **cmdline_p)
 {
@@ -354,6 +388,16 @@ setup_arch (char **cmdline_p)
 
 #ifdef CONFIG_SMP
 	cpu_physical_id(0) = hard_smp_processor_id();
+
+	check_for_logical_procs();
+	if (smp_num_cpucores > 1)
+		printk(KERN_INFO
+		       "cpu package is Multi-Core capable: number of cores=%d\n",
+		       smp_num_cpucores);
+	if (smp_num_siblings > 1)
+		printk(KERN_INFO
+		       "cpu package is Multi-Threading capable: number of siblings=%d\n",
+		       smp_num_siblings);
 #endif
 
 	cpu_init();	/* initialize the bootstrap CPU */
@@ -411,6 +455,7 @@ show_cpuinfo (struct seq_file *m, void *
 #endif
 	char family[32], features[128], *cp;
 	struct cpuinfo_ia64 *c = v;
+	struct cpuinfo_ia64_topology *ct = cpu_data_topology(cpum);
 	unsigned long mask;
 
 	mask = c->features;
@@ -450,12 +495,23 @@ show_cpuinfo (struct seq_file *m, void *
 		   "cpu regs   : %u\n"
 		   "cpu MHz    : %lu.%06lu\n"
 		   "itc MHz    : %lu.%06lu\n"
-		   "BogoMIPS   : %lu.%02lu\n\n",
+		   "BogoMIPS   : %lu.%02lu\n",
 		   cpum, c->vendor, family, c->model, c->revision, c->archrev,
 		   features, c->ppn, c->number,
 		   c->proc_freq / 1000000, c->proc_freq % 1000000,
 		   c->itc_freq / 1000000, c->itc_freq % 1000000,
 		   lpj*HZ/500000, (lpj*HZ/5000) % 100);
+#ifdef CONFIG_SMP
+ 	seq_printf(m, "siblings   : %u\n", ct->num_log);
+ 	if (ct->threads_per_core > 1 || ct->cores_per_socket > 1)
+ 		seq_printf(m,
+ 			   "physical id: %u\n"
+ 			   "core id    : %u\n"
+ 			   "thread id  : %u\n",
+ 			   ct->socket_id, ct->core_id, ct->thread_id);
+#endif
+ 	seq_printf(m,"\n");
+
 	return 0;
 }
 
@@ -517,6 +573,7 @@ identify_cpu (struct cpuinfo_ia64 *c)
 	pal_status_t status;
 	unsigned long impl_va_msb = 50, phys_addr_size = 44;	/* Itanium defaults */
 	int i;
+	struct cpuinfo_ia64_topology *ct;
 
 	for (i = 0; i < 5; ++i)
 		cpuid.bits[i] = ia64_get_cpuid(i);
@@ -524,6 +581,15 @@ identify_cpu (struct cpuinfo_ia64 *c)
 	memcpy(c->vendor, cpuid.field.vendor, 16);
 #ifdef CONFIG_SMP
 	c->processor = smp_processor_id();
+	ct = cpu_data_topology(c->processor);
+	
+ 	/* below default values will be overwritten  by identify_siblings() 
+ 	 * for Multi-Threading/Multi-Core capable cpu's
+	 */
+ 	ct->threads_per_core = ct->cores_per_socket = ct->num_log = 1;
+ 	ct->socket_id = -1;
+
+ 	identify_siblings(ct);
 #endif
 	c->ppn = cpuid.field.ppn;
 	c->number = cpuid.field.number;
@@ -677,7 +743,6 @@ cpu_init (void)
 
 	platform_cpu_init();
 }
-
 static int __init highio_setup(char *str)
 {
        printk("ia64: disabling HIGHMEM block I/O\n");
diff -urNp linux-278/arch/ia64/kernel/smp.c linux-279/arch/ia64/kernel/smp.c
--- linux-278/arch/ia64/kernel/smp.c
+++ linux-279/arch/ia64/kernel/smp.c
@@ -243,11 +243,11 @@ smp_call_function_single (int cpuid, voi
 
 	/* Wait for response */
 	while (atomic_read(&data.started) != cpus)
-		barrier();
+		cpu_relax();
 
 	if (wait)
 		while (atomic_read(&data.finished) != cpus)
-			barrier();
+			cpu_relax();
 	call_data = NULL;
 
 	spin_unlock_bh(&call_lock);
@@ -297,11 +297,11 @@ smp_call_function (void (*func) (void *i
 
 	/* Wait for response */
 	while (atomic_read(&data.started) != cpus)
-		barrier();
+		cpu_relax();
 
 	if (wait)
 		while (atomic_read(&data.finished) != cpus)
-			barrier();
+			cpu_relax();
 	call_data = NULL;
 
 	spin_unlock_bh(&call_lock);
diff -urNp linux-278/arch/ia64/kernel/smpboot.c linux-279/arch/ia64/kernel/smpboot.c
--- linux-278/arch/ia64/kernel/smpboot.c
+++ linux-279/arch/ia64/kernel/smpboot.c
@@ -2,6 +2,14 @@
  * SMP boot-related support
  *
  * Copyright (C) 2001 David Mosberger-Tang <davidm@hpl.hp.com>
+ * Copyright (C) 2001, 2004-2005 Intel Corp
+ * 	Rohit Seth <rohit.seth@intel.com>
+ * 	Suresh Siddha <suresh.b.siddha@intel.com>
+ * 	Gordon Jin <gordon.jin@intel.com>
+ *
+ * 04/12/26 Jin Gordon <gordon.jin@intel.com>
+ * 04/12/26 Rohit Seth <rohit.seth@intel.com>
+ *						Add multi-threading and multi-core detection
  *
  * 01/05/16 Rohit Seth <rohit.seth@intel.com>	Moved SMP booting functions from smp.c to here.
  * 01/04/27 David Mosberger <davidm@hpl.hp.com>	Added ITC synching code.
@@ -85,6 +93,9 @@ int smp_num_cpus = 1;
 /* Bitmask of currently online CPUs */
 volatile unsigned long cpu_online_map;
 
+int smp_num_siblings = 1;
+int smp_num_cpucores = 1;
+
 /* which logical CPU number maps to which CPU (physical APIC ID) */
 volatile int ia64_cpu_to_sapicid[NR_CPUS];
 
@@ -584,3 +595,102 @@ init_smp_config(void)
  */
 unsigned long cache_decay_ticks=10;
 
+/*
+ * mt_info[] is a temporary store for all info returned by
+ * PAL_LOGICAL_TO_PHYSICAL, to be copied into cpuinfo_ia64 when the
+ * specific cpu comes.
+ */
+static struct {
+	__u32   socket_id;
+	__u16   core_id;
+	__u16   thread_id;
+	__u16   proc_fixed_addr;
+} mt_info[NR_CPUS] __initdata;
+static int mt_info_index __initdata;
+
+/*
+ * Search the mt_info to find out if this socket's cid/tid information is
+ * cached or not. If the socket exists, fill in the core_id and thread_id 
+ * in cpuinfo
+ */
+static int __init
+check_for_new_socket(__u16 logical_address, struct cpuinfo_ia64_topology *c)
+{
+	int i;
+	__u32 sid = c->socket_id;
+
+	for (i = 0; i < mt_info_index; i++) {
+		if (mt_info[i].proc_fixed_addr == logical_address
+		    && mt_info[i].socket_id == sid) {
+			c->core_id = mt_info[i].core_id;
+			c->thread_id = mt_info[i].thread_id;
+			return 1; /* not a new socket */
+		}
+	}
+	return 0;
+}
+
+/*
+ * identify_siblings(cpu) gets called from identify_cpu. This populates the 
+ * information related to logical execution units in per_cpu_data structure.
+ */
+void __init
+identify_siblings(struct cpuinfo_ia64_topology *c)
+{
+	s64 status;
+	u16 pltid;
+	u64 proc_fixed_addr;
+	int count, i;
+	pal_logical_to_physical_t info;
+
+	if (smp_num_cpucores == 1 && smp_num_siblings == 1)
+		return;
+
+	if ((status = ia64_pal_logical_to_phys(0, &info)) != PAL_STATUS_SUCCESS) {
+		printk(KERN_ERR "ia64_pal_logical_to_phys failed with %ld\n",
+		       status);
+		return;
+	}
+	if ((status = ia64_sal_physical_id_info(&pltid)) != PAL_STATUS_SUCCESS) {
+		printk(KERN_ERR "ia64_sal_pltid failed with %ld\n", status);
+		return;
+	}
+	if ((status = ia64_pal_fixed_addr(&proc_fixed_addr)) != PAL_STATUS_SUCCESS) {
+		printk(KERN_ERR "ia64_pal_fixed_addr failed with %ld\n", status);
+		return;
+	}
+
+	c->socket_id =  (pltid << 8) | info.overview_ppid;
+	c->cores_per_socket = info.overview_cpp;
+	c->threads_per_core = info.overview_tpc;
+	count = c->num_log = info.overview_num_log;
+
+	/* If the thread and core id information is already cached, then
+	 * we will simply update cpu_info and return. Otherwise, we will
+	 * do the PAL calls and cache core and thread id's of all the siblings.
+	 */
+	if (check_for_new_socket(proc_fixed_addr, c))
+		return;
+
+	for (i = 0; i < count; i++) {
+		if (i && (status = ia64_pal_logical_to_phys(i, &info))
+			  != PAL_STATUS_SUCCESS) {
+                	printk(KERN_ERR "ia64_pal_logical_to_phys failed"
+					" with %ld\n", status);
+                	return;
+		}
+		if (info.log2_la == proc_fixed_addr) {
+			c->core_id = info.log1_cid;
+			c->thread_id = info.log1_tid;
+		}
+
+		if (mt_info_index >= NR_CPUS)
+			continue;
+
+		mt_info[mt_info_index].socket_id = c->socket_id;
+		mt_info[mt_info_index].core_id = info.log1_cid;
+		mt_info[mt_info_index].thread_id = info.log1_tid;
+		mt_info[mt_info_index].proc_fixed_addr = info.log2_la;
+		++mt_info_index;
+	}
+}
diff -urNp linux-278/include/asm-ia64/delay.h linux-279/include/asm-ia64/delay.h
--- linux-278/include/asm-ia64/delay.h
+++ linux-279/include/asm-ia64/delay.h
@@ -79,7 +79,7 @@ udelay (unsigned long usecs)
 	unsigned long cycles = usecs*local_cpu_data->cyc_per_usec;
 
 	while (ia64_get_itc() - start < cycles)
-		/* skip */;
+		cpu_relax();
 }
 
 static __inline__ void
diff -urNp linux-278/include/asm-ia64/pal.h linux-279/include/asm-ia64/pal.h
--- linux-278/include/asm-ia64/pal.h
+++ linux-279/include/asm-ia64/pal.h
@@ -69,6 +69,7 @@
 #define PAL_REGISTER_INFO	39	/* return AR and CR register information*/
 #define PAL_SHUTDOWN		40	/* enter processor shutdown state */
 #define PAL_PREFETCH_VISIBILITY	41
+#define PAL_LOGICAL_TO_PHYSICAL 42	/* returns information on logical to physical processor mapping */
 
 #define PAL_COPY_PAL		256	/* relocate PAL procedures and PAL PMI */
 #define PAL_HALT_INFO		257	/* return the low power capabilities of processor */
@@ -1548,6 +1549,73 @@ ia64_pal_prefetch_visibility (void)
 	return iprv.status;
 }
 
+/* data structure for getting information on logical to physical mappings */
+typedef union pal_log_overview_u {
+	struct {
+		u64	num_log		:16,	/* Total number of logical
+						 * processors on this die
+						 */
+			tpc		:8,	/* Threads per core */
+			reserved3	:8,	/* Reserved */
+			cpp		:8,	/* Cores per processor */
+			reserved2	:8,	/* Reserved */
+			ppid		:8,	/* Physical processor ID */
+			reserved1	:8;	/* Reserved */
+	} overview_bits;
+	u64 overview_data;
+} pal_log_overview_t;
+
+typedef union pal_proc_n_log_info1_u{
+	struct {
+		u64	tid		:16,	/* Thread id */
+			reserved2	:16,	/* Reserved */
+			cid		:16,	/* Core id */
+			reserved1	:16;	/* Reserved */
+	} ppli1_bits;
+	u64	ppli1_data;
+} pal_proc_n_log_info1_t;
+
+typedef union pal_proc_n_log_info2_u {
+	struct {
+		u64	la		:16,	/* Logical address */
+			reserved	:48;	/* Reserved */
+	} ppli2_bits;
+	u64	ppli2_data;
+} pal_proc_n_log_info2_t;
+
+typedef struct pal_logical_to_physical_s
+{
+	pal_log_overview_t overview;
+	pal_proc_n_log_info1_t ppli1;
+	pal_proc_n_log_info2_t ppli2;
+} pal_logical_to_physical_t;
+
+#define overview_num_log	overview.overview_bits.num_log
+#define overview_tpc		overview.overview_bits.tpc
+#define overview_cpp		overview.overview_bits.cpp
+#define overview_ppid		overview.overview_bits.ppid
+#define log1_tid		ppli1.ppli1_bits.tid
+#define log1_cid		ppli1.ppli1_bits.cid
+#define log2_la			ppli2.ppli2_bits.la
+
+/* Get information on logical to physical processor mappings. */
+static inline s64
+ia64_pal_logical_to_phys(u64 proc_number, pal_logical_to_physical_t *mapping)
+{
+	struct ia64_pal_retval iprv;
+
+	PAL_CALL(iprv, PAL_LOGICAL_TO_PHYSICAL, proc_number, 0, 0);
+
+	if (iprv.status == PAL_STATUS_SUCCESS)
+	{
+		if (proc_number == 0)
+			mapping->overview.overview_data = iprv.v0;
+		mapping->ppli1.ppli1_data = iprv.v1;
+		mapping->ppli2.ppli2_data = iprv.v2;
+	}
+
+	return iprv.status;
+}
 #endif /* __ASSEMBLY__ */
 
 #endif /* __KERNEL__ */
diff -urNp linux-278/include/asm-ia64/processor.h linux-279/include/asm-ia64/processor.h
--- linux-278/include/asm-ia64/processor.h
+++ linux-279/include/asm-ia64/processor.h
@@ -195,6 +195,16 @@ struct cpuinfo_ia64 {
 	__u64 platform_specific;
 } __attribute__ ((aligned (PAGE_SIZE)));
 
+struct cpuinfo_ia64_topology {
+	__u32 socket_id;	/* physical processor socket id */
+	__u16 core_id;		/* core id */
+	__u16 thread_id;	/* thread id */
+	__u16 num_log;		/* Total number of logical processors on
+				 * this socket that were successfully booted */
+	__u8  cores_per_socket;	/* Cores per processor socket */
+	__u8  threads_per_core;	/* Threads per core */
+};
+
 /*
  * The "local" data pointer.  It points to the per-CPU data of the currently executing
  * CPU, much like "current" points to the per-task data of the currently executing task.
@@ -219,6 +229,9 @@ struct cpuinfo_ia64 {
 # define cpu_data(cpu)		(&_cpu_data[cpu])
 #endif
 
+extern struct cpuinfo_ia64_topology _cpu_data_topology[NR_CPUS];
+#define cpu_data_topology(cpu)	(&_cpu_data_topology[cpu])
+
 extern void identify_cpu (struct cpuinfo_ia64 *);
 extern void print_cpu_info (struct cpuinfo_ia64 *);
 
diff -urNp linux-278/include/asm-ia64/sal.h linux-279/include/asm-ia64/sal.h
--- linux-278/include/asm-ia64/sal.h
+++ linux-279/include/asm-ia64/sal.h
@@ -88,6 +88,7 @@ extern spinlock_t sal_lock;
 #define SAL_PCI_CONFIG_READ		0x01000010
 #define SAL_PCI_CONFIG_WRITE		0x01000011
 #define SAL_FREQ_BASE			0x01000012
+#define SAL_PHYSICAL_ID_INFO		0x01000013
 
 #define SAL_UPDATE_PAL			0x01000020
 
@@ -810,6 +811,17 @@ ia64_sal_info_event_irqsafe (int sal_inf
     sal_info_type != SAL_INFO_TYPE_INIT;
 }
 
+/* Get physical processor die mapping in the platform. */
+static inline s64
+ia64_sal_physical_id_info(u16 *splid)
+{
+	struct ia64_sal_retval isrv;
+	SAL_CALL(isrv, SAL_PHYSICAL_ID_INFO, 0, 0, 0, 0, 0, 0, 0);
+	if (splid)
+		*splid = isrv.v0;
+	return isrv.status;
+}
+
 extern unsigned long sal_platform_features;
 
 extern int (*salinfo_platform_oemdata)(const u8 *, u8 **, u64 *);
diff -urNp linux-278/include/asm-ia64/smp.h linux-279/include/asm-ia64/smp.h
--- linux-278/include/asm-ia64/smp.h
+++ linux-279/include/asm-ia64/smp.h
@@ -37,6 +37,8 @@ extern struct smp_boot_data {
 extern char no_int_routing __initdata;
 
 extern volatile unsigned long cpu_online_map;
+extern int smp_num_siblings;
+extern int smp_num_cpucores;
 extern unsigned long ipi_base_addr;
 extern unsigned char smp_int_redirect;
 extern int smp_num_cpus;
@@ -129,7 +131,7 @@ extern void smp_do_timer (struct pt_regs
 
 extern int smp_call_function_single (int cpuid, void (*func) (void *info), void *info,
 				     int retry, int wait);
-
+extern void identify_siblings (struct cpuinfo_ia64_topology *);
 
 #endif /* CONFIG_SMP */
 #endif /* _ASM_IA64_SMP_H */
