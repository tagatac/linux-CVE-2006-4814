diff -urNp linux-358/arch/ppc64/kernel/ppc_ksyms.c linux-359/arch/ppc64/kernel/ppc_ksyms.c
--- linux-358/arch/ppc64/kernel/ppc_ksyms.c
+++ linux-359/arch/ppc64/kernel/ppc_ksyms.c
@@ -290,6 +290,7 @@ EXPORT_SYMBOL(get_wchan);
 EXPORT_SYMBOL(console_drivers);
 #ifdef CONFIG_XMON
 EXPORT_SYMBOL(xmon);
+EXPORT_SYMBOL(xmon_enabled);
 #endif
 
 #if defined(CONFIG_KGDB) || defined(CONFIG_XMON)
diff -urNp linux-358/arch/ppc64/kernel/setup.c linux-359/arch/ppc64/kernel/setup.c
--- linux-358/arch/ppc64/kernel/setup.c
+++ linux-359/arch/ppc64/kernel/setup.c
@@ -73,6 +73,7 @@ unsigned long decr_overclock_proc0_set =
 
 #ifdef CONFIG_XMON
 extern void xmon_map_scc(void);
+extern int xmon_set_enabled(void);
 #endif
 
 #ifdef CONFIG_KDB
@@ -492,7 +493,9 @@ void __init setup_arch(char **cmdline_p)
 	ppc64_boot_msg(0x12, "Setup Arch");
 #ifdef CONFIG_XMON
 	xmon_map_scc();
-	if (strstr(cmd_line, "xmon"))
+	if (strstr(cmd_line, "xmon=on") || strstr(cmd_line, "xmon=early"))
+		xmon_set_enabled();
+	if (strstr(cmd_line, "xmon=early"))
 		xmon(0);
 #endif /* CONFIG_XMON */
 
diff -urNp linux-358/arch/ppc64/kernel/traps.c linux-359/arch/ppc64/kernel/traps.c
--- linux-358/arch/ppc64/kernel/traps.c
+++ linux-359/arch/ppc64/kernel/traps.c
@@ -51,6 +51,7 @@ extern void bad_page_fault(struct pt_reg
 extern int fwnmi_active;
 
 #ifdef CONFIG_XMON
+extern int xmon_enabled;
 extern void xmon(struct pt_regs *regs);
 extern int xmon_bpt(struct pt_regs *regs);
 extern int xmon_sstep(struct pt_regs *regs);
@@ -165,7 +166,7 @@ SystemResetException(struct pt_regs *reg
 	}
 #if defined(CONFIG_XMON)
 	xmon(regs);
-	if (smp_processor_id() == 0)
+	if (xmon_enabled && (smp_processor_id() == 0))
 		udbg_printf("leaving xmon...\n");
 #endif
 #if defined(CONFIG_KDB)
diff -urNp linux-358/arch/ppc64/xmon/start.c linux-359/arch/ppc64/xmon/start.c
--- linux-358/arch/ppc64/xmon/start.c
+++ linux-359/arch/ppc64/xmon/start.c
@@ -8,7 +8,6 @@
  */
 #include <linux/string.h>
 #include <linux/kernel.h>
-#include <linux/sysrq.h>
 #include <linux/fs.h>
 #include <asm/machdep.h>
 #include <asm/io.h>
@@ -53,22 +52,9 @@ void buf_access(void)
 }
 #endif
 
-static void sysrq_handle_xmon(int key, struct pt_regs *pt_regs, struct kbd_struct *kbd, struct tty_struct *tty) 
-{
-  xmon(pt_regs);
-}
-static struct sysrq_key_op sysrq_xmon_op = 
-{
-	.handler =	sysrq_handle_xmon,
-	.help_msg =	"xmon",
-	.action_msg =	"Entering xmon\n",
-};
-
 void
 xmon_map_scc(void)
 {
-	/* This maybe isn't the best place to register sysrq 'x' */
-	__sysrq_put_key_op('x', &sysrq_xmon_op);
 #ifndef USE_UDBG
 	/* should already be mapped by the kernel boot */
 	sccd = (volatile unsigned char *) (((unsigned long)comport1));
diff -urNp linux-358/arch/ppc64/xmon/xmon.c linux-359/arch/ppc64/xmon/xmon.c
--- linux-358/arch/ppc64/xmon/xmon.c
+++ linux-359/arch/ppc64/xmon/xmon.c
@@ -15,6 +15,8 @@
 #include <linux/mm.h>
 #include <linux/reboot.h>
 #include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/sysrq.h>
 #include <asm/ptrace.h>
 #include <asm/string.h>
 #include <asm/prom.h>
@@ -192,6 +194,35 @@ extern inline void sync(void)
 	asm volatile("sync; isync");
 }
 
+/*
+ * xmon can only be enabled via the boot command line. If either
+ * "xmon=on" or "xmon=early" is set, xmon is turned on by setting
+ * xmon_enabled to true. Additionally, if "xmon=early" was set,
+ * xmon will be entered during setup_arch.
+ */
+static void sysrq_handle_xmon(int key, struct pt_regs *pt_regs, 
+			      struct kbd_struct *kbd, struct tty_struct *tty)
+{
+	xmon(pt_regs);
+}
+static struct sysrq_key_op sysrq_xmon_op =
+{
+	.handler =	sysrq_handle_xmon,
+	.help_msg =	"xmon",
+	.action_msg =	"Entering xmon\n",
+};
+
+int xmon_enabled = 0;
+
+int __init
+xmon_set_enabled(void)
+{
+	printk("Enabling xmon\n");
+	xmon_enabled = 1;
+	__sysrq_put_key_op('x', &sysrq_xmon_op);
+	return 1;
+}
+
 /* (Ref: 64-bit PowerPC ELF ABI Supplement; Ian Lance Taylor, Zembu Labs).
  A PPC stack frame looks like this:
 
@@ -219,6 +250,9 @@ xmon(struct pt_regs *excp)
 	int cmd = 0;
 	unsigned long msr;
 
+	if (!xmon_enabled)
+		return;
+
 	if (excp == NULL) {
 		/* Ok, grab regs as they are now.
 		 This won't do a particularly good job because the
@@ -228,7 +262,9 @@ xmon(struct pt_regs *excp)
 		 caller's state.
 		 */
 		asm volatile ("std	0,0(%0)\n\
-			std	1,8(%0)\n\
+			ld	0,0(1)\n\
+			std	0,8(%0)\n\
+			ld	0,0(%0)\n\
 			std	2,16(%0)\n\
 			std	3,24(%0)\n\
 			std	4,32(%0)\n\
diff -urNp linux-358/include/asm-ppc64/page.h linux-359/include/asm-ppc64/page.h
--- linux-358/include/asm-ppc64/page.h
+++ linux-359/include/asm-ppc64/page.h
@@ -124,9 +124,13 @@ typedef unsigned long pgprot_t;
 #ifdef CONFIG_XMON
 #include <asm/ptrace.h>
 extern void xmon(struct pt_regs *excp);
+extern int xmon_enabled;
 #define BUG() do { \
 	printk("kernel BUG at %s:%d!\n", __FILE__, __LINE__); \
-	xmon(0); \
+	if (xmon_enabled) \
+		xmon(0); \
+	else \
+		__asm__ __volatile__(".long " BUG_ILLEGAL_INSTR); \
 } while (0)
 #elif defined(CONFIG_KDB)
 #include <asm/ptrace.h>
