--- linux-2.4.20/mm/page_alloc.c	Thu Mar 27 22:47:30 2003
+++ linux-2.4.20/mm/page_alloc.c	Thu Mar 27 19:28:35 2003
@@ -895,6 +895,31 @@
 
 #define LONG_ALIGN(x) (((x)+(sizeof(long))-1)&~((sizeof(long))-1))
 
+static unsigned long memmap_init(struct page *start, struct page *end,
+	int zone, unsigned long start_paddr, int highmem) 
+{
+	struct page *page;
+
+	for (page = start; page < end; page++) {
+		set_page_zone(page, zone);
+		set_page_count(page, 0);
+		SetPageReserved(page);
+		INIT_LIST_HEAD(&page->list);
+		if (!highmem)
+			set_page_address(page, __va(start_paddr));
+		start_paddr += PAGE_SIZE;
+	}
+	return start_paddr;
+}
+
+#ifdef HAVE_ARCH_MEMMAP_INIT
+#define MEMMAP_INIT(start, end, zone, paddr, highmem) \
+	arch_memmap_init(memmap_init, start, end, zone, paddr, highmem)
+#else
+#define MEMMAP_INIT(start, end, zone, paddr, highmem) \
+	memmap_init(start, end, zone, paddr, highmem)
+#endif
+
 /*
  * Set up the zone data structures:
  *   - mark all pages reserved
@@ -1048,16 +1073,10 @@
 		 * up by free_all_bootmem() once the early boot process is
 		 * done. Non-atomic initialization, single-pass.
 		 */
-		for (i = 0; i < size; i++) {
-			struct page *page = mem_map + offset + i;
-			set_page_zone(page, nid * MAX_NR_ZONES + j);
-			set_page_count(page, 0);
-			SetPageReserved(page);
-			INIT_LIST_HEAD(&page->list);
-			if (j != ZONE_HIGHMEM)
-				set_page_address(page, __va(zone_start_paddr));
-			zone_start_paddr += PAGE_SIZE;
-		}
+		zone_start_paddr = MEMMAP_INIT(mem_map + offset,
+				mem_map + offset + size,
+				nid * MAX_NR_ZONES + j, zone_start_paddr,
+				(j == ZONE_HIGHMEM ? 1 : 0));
 
 		offset += size;
 		for (i = 0; ; i++) {
