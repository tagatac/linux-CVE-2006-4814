diff -urNp linux-5450/fs/nfs/direct.c linux-5460/fs/nfs/direct.c
--- linux-5450/fs/nfs/direct.c
+++ linux-5460/fs/nfs/direct.c
@@ -47,14 +47,14 @@
 #define NFSDBG_FACILITY		(NFSDBG_PAGECACHE | NFSDBG_VFS)
 #define VERF_SIZE		(2 * sizeof(__u32))
 
-static /* inline */ int
+static inline int
 nfs_direct_read_rpc(struct file *file, struct nfs_readargs *arg)
 {
 	int result;
 	struct inode * inode = file->f_dentry->d_inode;
 	struct nfs_fattr fattr;
-        struct rpc_message msg;
-        struct nfs_readres res = { &fattr, arg->count, 0 };
+	struct rpc_message msg;
+	struct nfs_readres res = { &fattr, arg->count, 0 };
 
 #ifdef CONFIG_NFS_V3
 	msg.rpc_proc = (NFS_PROTO(inode)->version == 3) ?
@@ -66,24 +66,24 @@ nfs_direct_read_rpc(struct file *file, s
         msg.rpc_resp = &res;
 
 	lock_kernel();
-        msg.rpc_cred = nfs_file_cred(file);
-        fattr.valid = 0;
-        result = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);
+	msg.rpc_cred = nfs_file_cred(file);
+	fattr.valid = 0;
+	result = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);
 	nfs_refresh_inode(inode, &fattr);
 	unlock_kernel();
 
 	return result;
 }
 
-static /* inline */ int
+static inline int
 nfs_direct_write_rpc(struct file *file, struct nfs_writeargs *arg,
 	struct nfs_writeverf *verf)
 {
 	int result;
 	struct inode *inode = file->f_dentry->d_inode;
 	struct nfs_fattr fattr;
-        struct rpc_message msg;
-        struct nfs_writeres res = { &fattr, verf, 0 };
+	struct rpc_message msg;
+	struct nfs_writeres res = { &fattr, verf, 0 };
 
 #ifdef CONFIG_NFS_V3
 	msg.rpc_proc = (NFS_PROTO(inode)->version == 3) ?
@@ -92,12 +92,12 @@ nfs_direct_write_rpc(struct file *file, 
 	msg.rpc_proc = NFSPROC_WRITE;
 #endif
 	msg.rpc_argp = arg;
-        msg.rpc_resp = &res;
+	msg.rpc_resp = &res;
 
 	lock_kernel();
 	msg.rpc_cred = get_rpccred(nfs_file_cred(file));
 	fattr.valid = 0;
-        result = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);
+	result = rpc_call_sync(NFS_CLIENT(inode), &msg, 0);
 	nfs_write_attributes(inode, &fattr);
 	put_rpccred(msg.rpc_cred);
 	unlock_kernel();
@@ -107,15 +107,16 @@ nfs_direct_write_rpc(struct file *file, 
 		if (result > 0) {
 			if ((arg->stable == NFS_FILE_SYNC) &&
 			    (verf->committed != NFS_FILE_SYNC)) {
-				printk(KERN_ERR __FUNCTION__
-				": server didn't sync stable write request\n");
+				printk(KERN_ERR
+				"%s: server didn't sync stable write request\n",
+				__FUNCTION__);
 				return -EIO;
 			}
 
 			if (result != arg->count) {
-				printk(KERN_INFO __FUNCTION__
-					": short write, count=%u, result=%d\n",
-							arg->count, result);
+				printk(KERN_INFO
+					"%s: short write, count=%u, result=%d\n",
+					__FUNCTION__, arg->count, result);
 			}
 		}
 		return result;
@@ -131,7 +132,7 @@ nfs_direct_write_rpc(struct file *file, 
 }
 
 #ifdef CONFIG_NFS_V3
-static /* inline */ int
+static inline int
 nfs_direct_commit_rpc(struct inode *inode, loff_t offset, size_t count,
 	struct nfs_writeverf *verf)
 {
@@ -168,58 +169,59 @@ nfs_direct_read(struct file *file, struc
 	size_t count)
 {
 	int curpage, total;
+	int result = 0;
 	struct inode *inode = file->f_dentry->d_inode;
 	int rsize = NFS_SERVER(inode)->rsize;
-	struct page **src = iobuf->maplist,
-		    **end = iobuf->maplist + iobuf->nr_pages;
 	struct page *pages[NFS_READ_MAXIOV];
-	struct nfs_readargs args = { NFS_FH(inode),
-				     offset,
-				     0,
-				     iobuf->offset,
+	struct nfs_readargs args = { NFS_FH(inode), offset, 0, iobuf->offset,
 				     pages };
 
 	total = 0;
 	curpage = 0;
-        while (count) {
-		int request, result;
-		struct page **dst = pages;
-
-                request = count;
-                if (count > rsize)
-                        request = rsize;
+	while (count) {
+		int len, request;
+		struct page **dest = pages;
+
+		request = count;
+		if (count > rsize)
+			request = rsize;
 		args.count = request;
+		args.offset = offset;
+		args.pgbase = (iobuf->offset + total) & ~PAGE_MASK;
+		len = PAGE_SIZE - args.pgbase;
 
 		do {
-			if (!*src)
-				return -EFAULT;
+			struct page *page = iobuf->maplist[curpage];
+
+			if (curpage >= iobuf->nr_pages || !page) {
+				result = -EFAULT;
+				goto out_err;
+			}
 
-			*dst++ = *src;
+			*dest++ = page;
 			/* zero after the first iov */
-			if (request < PAGE_SIZE)
+			if (request < len)
 				break;
-			request -= PAGE_SIZE;
-			src++;
-		} while (request != 0 && src != end);
+			request -= len;
+			len = PAGE_SIZE;
+			curpage++;
+		} while (request != 0);
 
                 result = nfs_direct_read_rpc(file, &args);
 
-                if (result < 0) {
-			if (result == -EISDIR)
-				total = -EINVAL;
-			else
-                        	total = result;
+                if (result < 0)
                         break;
-                }
 
                 total += result;
                 if (result < args.count)   /* NFSv2ism */
                         break;
                 count -= result;
-		args.offset += result;
-		args.pgbase += result;
-	        args.pgbase &= ~PAGE_MASK;
+                offset += result;
         };
+out_err:
+
+	if (!total)
+		return result;
 	return total;
 }
 
@@ -238,12 +240,14 @@ nfs_direct_write(struct file *file, stru
 {
 	int curpage, total;
 	int need_commit = 0;
+	int result = 0;
 	loff_t save_offset = offset;
 	struct inode *inode = file->f_dentry->d_inode;
 	int wsize = NFS_SERVER(inode)->wsize;
 	struct nfs_writeverf first_verf, ret_verf;
 	struct page *pages[NFS_WRITE_MAXIOV];
-        struct nfs_writeargs args = { NFS_FH(inode), 0, 0, NFS_FILE_SYNC, 0, pages };
+        struct nfs_writeargs args = { NFS_FH(inode), 0, 0, NFS_FILE_SYNC, 0,
+				pages };
 
 #ifdef CONFIG_NFS_V3
 	if ((NFS_PROTO(inode)->version == 3) && (count > wsize) &&
@@ -254,37 +258,39 @@ nfs_direct_write(struct file *file, stru
 retry:
 	total = 0;
 	curpage = 0;
-        while (count) {
-		int request, result;
+	while (count) {
+		int len, request;
 		struct page **dest = pages;
 
-                request = count;
-                if (count > wsize)
-                        request = wsize;
+		request = count;
+		if (count > wsize)
+			request = wsize;
 		args.count = request;
 		args.offset = offset;
 		args.pgbase = (iobuf->offset + total) & ~PAGE_MASK;
+		len = PAGE_SIZE - args.pgbase;
 
 		do {
 			struct page *page = iobuf->maplist[curpage];
 
-			if (!page)
-				return -EFAULT;
+			if (curpage >= iobuf->nr_pages || !page) {
+				result = -EFAULT;
+				goto out_err;
+			}
 
 			*dest++ = page;
 			/* zero after the first iov */
-			if (request > PAGE_SIZE)
+			if (request < len)
 				break;
-			request -= PAGE_SIZE;
+			request -= len;
+			len = PAGE_SIZE;
 			curpage++;
-		} while (request != 0 && curpage < iobuf->nr_pages);
+		} while (request != 0);
 
-                result = nfs_direct_write_rpc(file, &args, &ret_verf);
+		result = nfs_direct_write_rpc(file, &args, &ret_verf);
 
-                if (result < 0) {
-                        total = result;
-                        break;
-                }
+		if (result < 0)
+			break;
 
 		if (!total)
 			memcpy(&first_verf.verifier, &ret_verf.verifier,
@@ -296,11 +302,12 @@ retry:
 				goto print_retry;
 		}
 
-                total += result;
-                count -= result;
-                offset += result;
-        };
+		total += result;
+		count -= result;
+		offset += result;
+	};
 
+out_err:
 	/*
 	 * Commit data written so far, even in the event of an error
 	 */
@@ -313,11 +320,13 @@ retry:
 			goto print_retry;
 	}
 
+	if (!total)
+		return result;
 	return total;
 
 print_retry:
-	printk(KERN_INFO __FUNCTION__
-		": detected server restart; retrying with FILE_SYNC\n");
+	printk(KERN_INFO "%s: detected server restart; retrying with FILE_SYNC\n",
+			__FUNCTION__);
 	args.stable = NFS_FILE_SYNC;
 	offset = save_offset;
 	count = iobuf->length;
@@ -343,10 +352,14 @@ nfs_direct_IO(int rw, struct file *file,
 	unsigned long blocknr, int blocksize)
 {
 	int result = -EINVAL;
+	unsigned int o_append = file->f_flags & O_APPEND;
 	size_t count = iobuf->length;
 	struct dentry *dentry = file->f_dentry;
 	struct inode *inode = dentry->d_inode;
-	loff_t offset = blocknr << inode->i_blkbits;
+	loff_t offset = (loff_t) blocknr << inode->i_blkbits;
+
+	if (!o_append)
+		up(&inode->i_sem);
 
 	switch (rw) {
 	case READ:
@@ -369,6 +382,209 @@ nfs_direct_IO(int rw, struct file *file,
 		break;
 	}
 
+	if (!o_append)
+		down(&inode->i_sem);
+
 	dfprintk(VFS, "NFS: direct_IO result = %d\n", result);
 	return result;
 }
+
+static int
+nfs_precheck_file_write(struct file *file, struct inode *inode, size_t *count,
+	loff_t *ppos)
+{
+	ssize_t		err;
+	unsigned long	limit = current->rlim[RLIMIT_FSIZE].rlim_cur;
+	loff_t		pos = *ppos;
+	
+	err = -EINVAL;
+	if (pos < 0)
+		goto out;
+
+	err = file->f_error;
+	if (err) {
+		file->f_error = 0;
+		goto out;
+	}
+
+	if (file->f_flags & O_APPEND)
+		*ppos = pos = inode->i_size;
+
+	err = -EFBIG;
+	if (limit != RLIM_INFINITY) {
+		if (pos >= limit) {
+			send_sig(SIGXFSZ, current, 0);
+			goto out;
+		}
+		if (pos > 0xFFFFFFFFULL)
+			*count = 0;
+		else if (*count > limit - (u32)pos)
+			*count = limit - (u32)pos;
+	}
+
+	if ( pos + *count > MAX_NON_LFS && !(file->f_flags&O_LARGEFILE)) {
+		if (pos >= MAX_NON_LFS) {
+			send_sig(SIGXFSZ, current, 0);
+			goto out;
+		}
+		if (*count > MAX_NON_LFS - (u32)pos)
+			*count = MAX_NON_LFS - (u32)pos;
+	}
+
+	err = 0;
+	if (*count == 0)
+		goto out;
+
+out:
+	return err;
+}
+
+/*
+ * Based on generic_file_direct_IO, but no need to hold the i_sem here,
+ * and we don't need any of the silly block alignment semantics.
+ */
+static ssize_t
+nfs_file_direct_IO(int rw, struct file *filp, char *buf, size_t count,
+	loff_t offset)
+{
+	ssize_t retval, progress;
+	int chunk_size, iosize, new_iobuf;
+	struct kiobuf *iobuf;
+	struct address_space *mapping = filp->f_dentry->d_inode->i_mapping;
+	struct inode *inode = mapping->host;
+
+	new_iobuf = 0;
+	iobuf = filp->f_iobuf;
+	if (test_and_set_bit(0, &filp->f_iobuf_lock)) {
+		/*
+		 * A parallel read/write is using the preallocated iobuf
+		 * so just run slow and allocate a new one.
+		 */
+		retval = alloc_kiovec(1, &iobuf);
+		if (retval)
+			goto out;
+		new_iobuf = 1;
+	}
+
+	retval = filemap_fdatasync(mapping);
+	if (retval == 0)
+		retval = nfs_wb_all(inode);
+	if (retval == 0)
+		retval = filemap_fdatawait(mapping);
+	if (retval < 0)
+		goto out_free;
+
+	progress = retval = 0;
+	chunk_size = KIO_MAX_ATOMIC_IO << 10;
+	while (count > 0) {
+		iosize = count;
+		if (iosize > chunk_size)
+			iosize = chunk_size;
+
+		retval = map_user_kiobuf(rw, iobuf, (unsigned long) buf, iosize);
+		if (retval)
+			break;
+
+		switch (rw) {
+		case READ:
+			retval = nfs_direct_read(filp, iobuf, offset+progress, iosize);
+			if (retval > 0)
+				mark_dirty_kiobuf(iobuf, retval);
+			break;
+		case WRITE:
+			retval = nfs_direct_write(filp, iobuf, offset+progress, iosize);
+			break;
+		}
+
+		if (retval >= 0) {
+			count -= retval;
+			buf += retval;
+			progress += retval;
+		}
+
+		unmap_kiobuf(iobuf);
+
+		if (retval != iosize)
+			break;
+	}
+
+	if (progress)
+		retval = progress;
+
+ out_free:
+	if (!new_iobuf)
+		clear_bit(0, &filp->f_iobuf_lock);
+	else
+		free_kiovec(1, &iobuf);
+ out:	
+	return retval;
+}
+
+ssize_t
+nfs_file_direct_read(struct file * file, char * buf, size_t count, loff_t *ppos)
+{
+	loff_t pos = *ppos;
+	struct dentry *dentry = file->f_dentry;
+	struct inode *inode = file->f_dentry->d_inode->i_mapping->host;
+	ssize_t retval;
+
+	dfprintk(VFS, "nfs: direct read(%s/%s, %lu@%lu)\n",
+		dentry->d_parent->d_name.name, dentry->d_name.name,
+		(unsigned long) count, (unsigned long) *ppos);
+
+	if ((ssize_t) count < 0)
+		return -EINVAL;
+	if (!access_ok(VERIFY_WRITE, buf, count))
+		return -EFAULT;
+	if (!count)
+		return 0;
+
+	down_read(&inode->i_alloc_sem);
+	retval = nfs_file_direct_IO(READ, file, buf, count, pos);
+	if (retval > 0)
+		*ppos = pos + retval;
+	up_read(&inode->i_alloc_sem);
+
+	return retval;
+}
+
+ssize_t
+nfs_file_direct_write(struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+	int o_append = file->f_flags & O_APPEND;
+	loff_t pos = *ppos;
+	struct dentry *dentry = file->f_dentry;
+	struct address_space *mapping = file->f_dentry->d_inode->i_mapping;
+	struct inode *inode = mapping->host;
+	ssize_t retval;
+
+	dfprintk(VFS, "nfs: direct write(%s/%s(%ld), %lu@%lu)\n",
+		dentry->d_parent->d_name.name, dentry->d_name.name,
+		inode->i_ino, (unsigned long) count, (unsigned long) *ppos);
+
+	if ((ssize_t) count < 0)
+		return -EINVAL;
+	if (!access_ok(VERIFY_READ, buf, count))
+		return -EFAULT;
+
+	down_read(&inode->i_alloc_sem);
+	if (o_append)
+		down(&inode->i_sem);
+	
+	retval = nfs_precheck_file_write(file, inode, &count, &pos);
+	if (retval != 0 || count == 0)
+		goto out;
+	
+	retval = nfs_file_direct_IO(WRITE, file, buf, count, pos);
+	if (retval > 0) {
+		*ppos = pos + retval;
+		invalidate_inode_pages2(mapping);
+	}
+
+out:
+	if (o_append)
+		up(&inode->i_sem);
+	up_read(&inode->i_alloc_sem);
+
+	return retval;
+}
diff -urNp linux-5450/fs/nfs/file.c linux-5460/fs/nfs/file.c
--- linux-5450/fs/nfs/file.c
+++ linux-5460/fs/nfs/file.c
@@ -124,6 +124,11 @@ nfs_file_read(struct file * file, char *
 	struct inode * inode = dentry->d_inode;
 	ssize_t result;
 
+#ifdef CONFIG_NFS_DIRECTIO
+	if (file->f_flags & O_DIRECT)
+		return nfs_file_direct_read(file, buf, count, ppos);
+#endif
+
 	dfprintk(VFS, "nfs: read(%s/%s, %lu@%lu)\n",
 		dentry->d_parent->d_name.name, dentry->d_name.name,
 		(unsigned long) count, (unsigned long) *ppos);
@@ -245,6 +250,11 @@ nfs_file_write(struct file *file, const 
 	struct inode * inode = dentry->d_inode;
 	ssize_t result;
 
+#ifdef CONFIG_NFS_DIRECTIO
+	if (file->f_flags & O_DIRECT)
+		return nfs_file_direct_write(file, (char *)buf, count, ppos);
+#endif
+
 	dfprintk(VFS, "nfs: write(%s/%s(%ld), %lu@%lu)\n",
 		dentry->d_parent->d_name.name, dentry->d_name.name,
 		inode->i_ino, (unsigned long) count, (unsigned long) *ppos);
diff -urNp linux-5450/fs/nfs/inode.c linux-5460/fs/nfs/inode.c
--- linux-5450/fs/nfs/inode.c
+++ linux-5460/fs/nfs/inode.c
@@ -276,11 +276,6 @@ nfs_setup_superblock(struct super_block 
 	if (!server->wsize)
 		server->wsize = nfs_block_size(fsinfo.wtpref, NULL);
 
-	/* NFSv3: we don't have bsize, but rather rtmult and wtmult... */
-	if (!fsinfo.wtmult)
-		fsinfo.wtmult = 512;
-	sb->s_blocksize = nfs_block_bits(fsinfo.wtmult, &sb->s_blocksize_bits);
-
 	if (server->rsize > fsinfo.rtmax)
 		server->rsize = fsinfo.rtmax;
 	if (server->wsize > fsinfo.wtmax)
@@ -298,6 +293,8 @@ nfs_setup_superblock(struct super_block 
                 server->wsize = server->wpages << PAGE_CACHE_SHIFT;
 	}
 
+	sb->s_blocksize = nfs_block_bits(server->wsize, &sb->s_blocksize_bits);
+
 	server->dtsize = nfs_block_size(fsinfo.dtpref, NULL);
 	if (server->dtsize > PAGE_CACHE_SIZE)
 		server->dtsize = PAGE_CACHE_SIZE;
diff -urNp linux-5450/include/linux/nfs_fs.h linux-5460/include/linux/nfs_fs.h
--- linux-5450/include/linux/nfs_fs.h
+++ linux-5460/include/linux/nfs_fs.h
@@ -285,6 +285,8 @@ extern int  nfs_scan_lru_read_timeout(st
  * linux/fs/nfs/direct.c
  */
 extern int  nfs_direct_IO(int, struct file *, struct kiobuf *, unsigned long, int);
+extern ssize_t	nfs_file_direct_read(struct file *, char *, size_t, loff_t *);
+extern ssize_t	nfs_file_direct_write(struct file *, char *, size_t, loff_t *);
 
 /*
  * linux/fs/mount_clnt.c
diff -urNp linux-5450/kernel/ksyms.c linux-5460/kernel/ksyms.c
--- linux-5450/kernel/ksyms.c
+++ linux-5460/kernel/ksyms.c
@@ -219,6 +219,7 @@ EXPORT_SYMBOL(invalidate_bdev);
 EXPORT_SYMBOL(invalidate_inodes);
 EXPORT_SYMBOL(invalidate_device);
 EXPORT_SYMBOL(invalidate_inode_pages);
+EXPORT_SYMBOL(invalidate_inode_pages2);
 EXPORT_SYMBOL(truncate_inode_pages);
 EXPORT_SYMBOL(fsync_dev);
 EXPORT_SYMBOL_GPL(fsync_dev_lockfs);
@@ -464,6 +465,7 @@ EXPORT_SYMBOL(map_user_kiobuf);
 EXPORT_SYMBOL(unmap_kiobuf);
 EXPORT_SYMBOL(lock_kiovec);
 EXPORT_SYMBOL(unlock_kiovec);
+EXPORT_SYMBOL(mark_dirty_kiobuf);
 EXPORT_SYMBOL(brw_kiovec);
 EXPORT_SYMBOL(kiobuf_wait_for_io);
 
