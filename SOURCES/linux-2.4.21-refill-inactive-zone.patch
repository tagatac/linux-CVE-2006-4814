diff -urNp linux-1220/mm/vmscan.c linux-1223/mm/vmscan.c
--- linux-1220/mm/vmscan.c
+++ linux-1223/mm/vmscan.c
@@ -25,6 +25,7 @@
 #include <linux/highmem.h>
 #include <linux/file.h>
 #include <linux/mm_inline.h>
+#include <linux/kernel.h>
 
 #include <asm/pgalloc.h>
 
@@ -513,115 +514,130 @@ struct cache_limits cache_limits = {
  */
 int refill_inactive_zone(struct zone_struct * zone, int priority, int target)
 {
-	int maxscan = (zone->active_anon_pages + zone->active_cache_pages) >> priority;
 	struct list_head * page_lru;
 	struct page * page;
 	int over_rsslimit;
 	int progress = 0;
-	int reclaim_anon = 0;
-	int reclaim_cache = 1;
+	int cache_percent, total_active, cache_work, anon_work, cache_goal, maxscan;
 
-	/* Take the lock while messing with the list... */
-	lru_lock(zone);
 	if (target < BATCH_WORK_AMOUNT)
 		target = BATCH_WORK_AMOUNT;
 
-	if (cache_ratio(zone) < cache_limits.borrow)
-		reclaim_anon = 1;
-	if (cache_ratio(zone) < cache_limits.min)
-		reclaim_cache = 0;
-	/* Could happen if the sysadmin sets borrow below min... */
-	if (!reclaim_anon && !reclaim_cache)
-		reclaim_cache = reclaim_anon = 1;
-
-	while (maxscan-- && zone->active_anon_pages + zone->active_cache_pages > 0 && target > 0) {
-		int anon_work = 0, cache_work = 0;
-		if (reclaim_anon)
-			anon_work = BATCH_WORK_AMOUNT;
-		if (reclaim_cache)
-			cache_work = BATCH_WORK_AMOUNT;
-
-		while (--anon_work >= 0 && zone->active_anon_pages) {
-			if (list_empty(&zone->active_anon_list[0])) {
-				kachunk_anon(zone);
-				continue;
-			}
+	/* Take the lock while messing with the list... */
+	lru_lock(zone);
 
-			page_lru = zone->active_anon_list[0].prev;
-			page = list_entry(page_lru, struct page, lru);
+	/* active cache should be at cache_limits.borrow */
+	total_active = zone->active_anon_pages + zone->active_cache_pages;
+	cache_goal = total_active * cache_limits.borrow/100;
+	cache_goal = min(cache_goal, (total_active * cache_limits.max / 100));
+	cache_goal = max(cache_goal, (total_active * cache_limits.min / 100));
+
+	/* Calculate number of cache pages to deactivate so it's at cache_limits.borrow.
+	 * -If the cache is currently at cache_limits.borrow then deactivate 50% from cache 
+	 *  and 50% from anon to keep it that way.
+	 * -Otherwise deactivate a number of pages from the cache thats proportional to
+	 *  how far it's currently above or below cache_limits.borrow.
+	 * -The difference is then deactivated from the anon active lists.
+	 * -Finally, we always attempt to deactivate something from both cache and anon.
+	 */
+	if (zone->active_cache_pages >= cache_goal)
+		cache_percent = 50 + ((zone->active_cache_pages-cache_goal)*50/(total_active-cache_goal+1));
+	else
+		cache_percent = 50 - ((cache_goal-zone->active_cache_pages)*50/cache_goal+1);
+	cache_work = cache_percent * target/100;
+
+	/* never below min or above max */
+	if (zone->active_cache_pages < (total_active * cache_limits.min / 100))
+		cache_work = 0;
+	if (zone->active_cache_pages > (total_active * cache_limits.max / 100))
+		cache_work = target;
+
+	/* anon pages makes up the rest */
+	anon_work = target - cache_work;
+
+	/* anon first */
+	maxscan = zone->active_anon_pages;
+	while (maxscan-- > 0 && anon_work > 0 && zone->active_anon_pages) {
+		if (list_empty(&zone->active_anon_list[0])) {
+			kachunk_anon(zone);
+			continue;
+		}
 
-			/* Wrong page on list?! (list corruption, should not happen) */
-			BUG_ON(unlikely(!PageActiveAnon(page)));
-		
-			/* Needed to follow page->mapping */
-			if (TryLockPage(page)) {
-				/* The page is already locked. This for sure means
-				 * someone is doing stuff with it which makes it
-				 * active by definition ;)
-				 */
-				del_page_from_active_anon_list(page);
-				add_page_to_active_anon_list(page, INITIAL_AGE);
-				continue;
-			}
+		page_lru = zone->active_anon_list[0].prev;
+		page = list_entry(page_lru, struct page, lru);
 
-			/*
-			 * Do aging on the pages.
+		/* Wrong page on list?! (list corruption, should not happen) */
+		BUG_ON(unlikely(!PageActiveAnon(page)));
+	
+		/* Needed to follow page->mapping */
+		if (TryLockPage(page)) {
+			/* The page is already locked. This for sure means
+			 * someone is doing stuff with it which makes it
+			 * active by definition ;)
 			 */
-			pte_chain_lock(page);
-			if (page_referenced(page, &over_rsslimit) && !over_rsslimit) {
-				pte_chain_unlock(page);
-				age_page_up_nolock(page, 0);
-				UnlockPage(page);
-				continue;
-			}
-			pte_chain_unlock(page);
+			del_page_from_active_anon_list(page);
+			add_page_to_active_anon_list(page, INITIAL_AGE);
+			continue;
+		}
 
-			deactivate_page_nolock(page);
-			target--;
-			progress++;
+		/*
+		 * Do aging on the pages.
+		 */
+		pte_chain_lock(page);
+		if (page_referenced(page, &over_rsslimit) && !over_rsslimit) {
+			pte_chain_unlock(page);
+			age_page_up_nolock(page, 0);
 			UnlockPage(page);
+			continue;
 		}
+		pte_chain_unlock(page);
 
-		while (--cache_work >= 0 && zone->active_cache_pages) {
-			if (list_empty(&zone->active_cache_list[0])) {
-				kachunk_cache(zone);
-				continue;
-			}
-
-			page_lru = zone->active_cache_list[0].prev;
-			page = list_entry(page_lru, struct page, lru);
+		deactivate_page_nolock(page);
+		anon_work--;
+		progress++;
+		UnlockPage(page);
+	}
+	/* then cache */
+	maxscan = zone->active_cache_pages;
+	while (maxscan-- > 0 && cache_work > 0 && zone->active_cache_pages) {
+		if (list_empty(&zone->active_cache_list[0])) {
+			kachunk_cache(zone);
+			continue;
+		}
 
-			/* Wrong page on list?! (list corruption, should not happen) */
-			BUG_ON(unlikely(!PageActiveCache(page)));
-		
-			/* Needed to follow page->mapping */
-			if (TryLockPage(page)) {
-				/* The page is already locked. This for sure means
-				 * someone is doing stuff with it which makes it
-				 * active by definition ;)
-				 */
-				del_page_from_active_cache_list(page);
-				add_page_to_active_cache_list(page, INITIAL_AGE);
-				continue;
-			}
+		page_lru = zone->active_cache_list[0].prev;
+		page = list_entry(page_lru, struct page, lru);
 
-			/*
-			 * Do aging on the pages.
+		/* Wrong page on list?! (list corruption, should not happen) */
+		BUG_ON(unlikely(!PageActiveCache(page)));
+	
+		/* Needed to follow page->mapping */
+		if (TryLockPage(page)) {
+			/* The page is already locked. This for sure means
+			 * someone is doing stuff with it which makes it
+			 * active by definition ;)
 			 */
-			pte_chain_lock(page);
-			if (page_referenced(page, &over_rsslimit) && !over_rsslimit) {
-				pte_chain_unlock(page);
-				age_page_up_nolock(page, 0);
-				UnlockPage(page);
-				continue;
-			}
-			pte_chain_unlock(page);
+			del_page_from_active_cache_list(page);
+			add_page_to_active_cache_list(page, INITIAL_AGE);
+			continue;
+		}
 
-			deactivate_page_nolock(page);
-			target--;
-			progress++;
+		/*
+		 * Do aging on the pages.
+		 */
+		pte_chain_lock(page);
+		if (page_referenced(page, &over_rsslimit) && !over_rsslimit) {
+			pte_chain_unlock(page);
+			age_page_up_nolock(page, 0);
 			UnlockPage(page);
+			continue;
 		}
+		pte_chain_unlock(page);
+
+		deactivate_page_nolock(page);
+		cache_work--;
+		progress++;
+		UnlockPage(page);
 	}
 	lru_unlock(zone);
 
