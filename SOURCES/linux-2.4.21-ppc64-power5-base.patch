diff -urNp linux-365/arch/ppc64/Makefile linux-370/arch/ppc64/Makefile
--- linux-365/arch/ppc64/Makefile
+++ linux-370/arch/ppc64/Makefile
@@ -19,11 +19,11 @@ ifeq ($(shell uname -m),ppc64)
 CHECKS		= checks
 endif
 
-HAS_BIARCH      := $(shell if gcc -m64 -S -o /dev/null -xc /dev/null > /dev/null 2>&1; then echo y; else echo n; fi;)
+HAS_BIARCH      := $(shell if $(CC) -m64 -S -o /dev/null -xc /dev/null > /dev/null 2>&1; then echo y; else echo n; fi;)
 ifeq ($(HAS_BIARCH),y)
 AS              := $(AS) -64
 LD              := $(LD) -m elf64ppc
-CC		:= gcc -m64
+CC		:= $(CC) -m64
 endif
 
 LINKFLAGS	= -T arch/ppc64/vmlinux.lds -Bstatic \
@@ -32,6 +32,11 @@ CFLAGS		:= $(CFLAGS) -fsigned-char -msof
 		-Wno-uninitialized -mminimal-toc -fno-builtin
 CPP		= $(CC) -E $(CFLAGS)
 
+HAVE_ZERO_BSS := $(shell if $(CC) -fno-zero-initialized-in-bss -S -o /dev/null -xc /dev/null > /dev/null 2>&1; then echo y; else echo n; fi)
+
+ifeq ($(HAVE_ZERO_BSS),y)
+CFLAGS		+= -fno-zero-initialized-in-bss
+endif
 
 HEAD := arch/ppc64/kernel/head.o
 
diff -urNp linux-365/arch/ppc64/boot/Makefile linux-370/arch/ppc64/boot/Makefile
--- linux-365/arch/ppc64/boot/Makefile
+++ linux-370/arch/ppc64/boot/Makefile
@@ -103,7 +103,7 @@ zImage.o: $(TOPDIR)/vmlinux
 
 vmlinux .config System.map: % : $(TOPDIR)/% zImage.o
 	cp $(TOPDIR)/$@ kernel-$@
-	[ "$@" = "vmlinux" ] && strip kernel-$@ || :
+	[ "$@" = "vmlinux" ] && $(CROSS_COMPILE)strip kernel-$@ || :
 	gzip -vf9 kernel-$@
 	$(OBJCOPY) zImage.o \
 		--add-section=.kernel:$@=kernel-$@.gz \
diff -urNp linux-365/arch/ppc64/kernel/chrp_setup.c linux-370/arch/ppc64/kernel/chrp_setup.c
--- linux-365/arch/ppc64/kernel/chrp_setup.c
+++ linux-370/arch/ppc64/kernel/chrp_setup.c
@@ -327,22 +327,22 @@ chrp_init(unsigned long r3, unsigned lon
 	hypertas = get_property(dn, "ibm,hypertas-functions", &len);
 	if (hypertas) {
 	    while (len > 0){
-		int i;
+		int i, hypertas_len;
 	    /* check value against table of strings */
 		for(i=0; i < FIRMWARE_MAX_FEATURES ;i++) {
 		    if ((firmware_features_table[i].name) && (strcmp(firmware_features_table[i].name,hypertas))==0) {
 		    /* we have a match */
-			cur_cpu_spec->firmware_features |= (1UL << firmware_features_table[i].val );
+			cur_cpu_spec->firmware_features |= (firmware_features_table[i].val);
 			break;
 		    } 
 		}
-		int hypertas_len = strlen(hypertas);
+		hypertas_len = strlen(hypertas);
 		len -= hypertas_len +1;
 		hypertas+= hypertas_len +1;
 	    }
 	}
-	udbg_printf("firmware_features bitmask: 0x%x \n",cur_cpu_spec->firmware_features);
-
+	printk(KERN_INFO "firmware_features = 0x%lx\n",
+	       cur_cpu_spec->firmware_features);
 }
 
 void __chrp
@@ -353,6 +353,8 @@ chrp_progress(char *s, unsigned short he
 	char *os;
 	static int display_character, set_indicator;
 	static int max_width;
+	static spinlock_t progress_lock = SPIN_LOCK_UNLOCKED;
+	static int pending_newline = 0;  /* did last write end with unprinted newline? */
 
 	if (!rtas.base)
 		return;
@@ -376,26 +378,72 @@ chrp_progress(char *s, unsigned short he
 		return;
 	}
 
-	rtas_call(display_character, 1, 1, NULL, '\r');
+	spin_lock(&progress_lock);
+
+	/* Last write ended with newline, but we didn't print it since
+	 * it would just clear the bottom line of output. Print it now
+	 * instead.
+	 *
+	 * If no newline is pending, print a CR to start output at the
+	 * beginning of the line.
+	 */
+	if (pending_newline) {
+		rtas_call(display_character, 1, 1, NULL, '\r');
+		rtas_call(display_character, 1, 1, NULL, '\n');
+		pending_newline = 0;
+	} else
+		rtas_call(display_character, 1, 1, NULL, '\r');
 
 	width = max_width;
 	os = s;
-	while ( *os )
+	while (*os)
 	{
-		if ( (*os == '\n') || (*os == '\r') )
+		if (*os == '\n' || *os == '\r') {
+			/* Blank to end of line. */
+			while (width-- > 0)
+				rtas_call(display_character, 1, 1, NULL, ' ');
+
+			/* If newline is the last character, save it
+			 * until next call to avoid bumping up the
+			 * display output.
+			 */
+			if (*os == '\n' && !os[1]) {
+				pending_newline = 1;
+				spin_unlock(&progress_lock);
+				return;
+			}
+
+			/* RTAS wants CR-LF, not just LF */
+
+			if (*os == '\n') {
+				rtas_call(display_character, 1, 1, NULL, '\r');
+				rtas_call(display_character, 1, 1, NULL, '\n');
+			} else {
+				/* CR might be used to re-draw a line, so we'll
+				 * leave it alone and not add LF.
+				 */
+				rtas_call(display_character, 1, 1, NULL, *os);
+			}
+
 			width = max_width;
-		else
+		} else {
 			width--;
-		rtas_call(display_character, 1, 1, NULL, *os++ );
+			rtas_call(display_character, 1, 1, NULL, *os);
+		}
+
+		os++;
+
 		/* if we overwrite the screen length */
-		if ( width == 0 )
-			while ( (*os != 0) && (*os != '\n') && (*os != '\r') )
+		if (width <= 0)
+			while ((*os != 0) && (*os != '\n') && (*os != '\r'))
 				os++;
 	}
 
 	/* Blank to end of line. */
 	while ( width-- > 0 )
 		rtas_call(display_character, 1, 1, NULL, ' ' );
+
+	spin_unlock(&progress_lock);
 }
 
 extern void setup_default_decr(void);
diff -urNp linux-365/arch/ppc64/kernel/cputable.c linux-370/arch/ppc64/kernel/cputable.c
--- linux-365/arch/ppc64/kernel/cputable.c
+++ linux-370/arch/ppc64/kernel/cputable.c
@@ -121,6 +121,24 @@ struct cpu_spec	cpu_specs[] = {
 	     __setup_cpu_power4,
 	     COMMON_PPC64_FW
     },
+    {	/* Power5 */
+	    0xffff0000, 0x003a0000, "POWER5 (gr)",
+	    CPU_FTR_SPLIT_ID_CACHE | CPU_FTR_USE_TB | CPU_FTR_HPTE_TABLE |
+	    CPU_FTR_PPCAS_ARCH_V2,
+	    COMMON_USER_PPC64,
+	    128, 128,
+	    __setup_cpu_power4,
+	    COMMON_PPC64_FW
+    },
+    {	/* Power5 */
+	    0xffff0000, 0x003b0000, "POWER5 (gs)",
+	    CPU_FTR_SPLIT_ID_CACHE | CPU_FTR_USE_TB | CPU_FTR_HPTE_TABLE |
+	    CPU_FTR_PPCAS_ARCH_V2,
+	    COMMON_USER_PPC64,
+	    128, 128,
+	    __setup_cpu_power4,
+	    COMMON_PPC64_FW
+    },
     {	/* default match */
 	    0x00000000, 0x00000000, "(Power4-Compatible)",
   	    CPU_FTR_SPLIT_ID_CACHE | CPU_FTR_USE_TB | CPU_FTR_HPTE_TABLE |
@@ -144,4 +162,13 @@ firmware_feature_t firmware_features_tab
     {FW_FEATURE_DUMP,		"hcall-dump"},
     {FW_FEATURE_INTERRUPT,	"hcall-interrupt"},
     {FW_FEATURE_MIGRATE,	"hcall-migrate"},
+    {FW_FEATURE_PERFMON,	"hcall-perfmon"},
+    {FW_FEATURE_CRQ,    	"hcall-crq"},
+    {FW_FEATURE_VIO,	        "hcall-vio"},
+    {FW_FEATURE_RDMA,	        "hcall-rdma"},
+    {FW_FEATURE_LLAN,	        "hcall-lLAN"},
+    {FW_FEATURE_BULK,   	"hcall-bulk"},
+    {FW_FEATURE_XDABR,  	"hcall-xdabr"},
+    {FW_FEATURE_MULTITCE,	"hcall-multi-tce"},
+    {FW_FEATURE_SPLPAR,	        "hcall-splpar"},
 };
diff -urNp linux-365/arch/ppc64/kernel/entry.S linux-370/arch/ppc64/kernel/entry.S
--- linux-365/arch/ppc64/kernel/entry.S
+++ linux-370/arch/ppc64/kernel/entry.S
@@ -404,6 +404,11 @@ END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
 	std	r0,THREAD+KSP(r13)	/* save kernel stack pointer */
 	std	r1,PACAKSAVE(r4)	/* save exception stack pointer */
 1:
+	mfmsr	r0
+	li	r2, MSR_RI
+	andc	r0,r0,r2
+	mtmsrd	r0,1
+
 	ld	r0,_MSR(r1)
 	mtspr	SRR1,r0
 	ld	r2,_CCR(r1)
@@ -495,6 +500,12 @@ _STATIC(rtas_return_loc)
 	mfspr	r4,SPRG3	        /* Get PACA */
 	SET_REG_TO_CONST(r5, KERNELBASE)
         sub     r4,r4,r5                /* RELOC the PACA base pointer */
+
+	mfmsr	r6			/* Clear RI while SRR0/1 are live */
+	li	r0,MSR_RI
+	andc	r6,r6,r0
+	sync
+	mtmsrd	r6
         
         ld	r1,PACAR1(r4)           /* Restore our SP */
 	LOADADDR(r3,.rtas_restore_regs)
diff -urNp linux-365/arch/ppc64/kernel/head.S linux-370/arch/ppc64/kernel/head.S
--- linux-365/arch/ppc64/kernel/head.S
+++ linux-370/arch/ppc64/kernel/head.S
@@ -143,6 +143,10 @@ __secondary_hold_acknowledge:
  * All of it must fit below the first exception vector at 0x100.
  */
 _GLOBAL(__secondary_hold)
+	mfmsr	r24
+	ori	r24,r24,MSR_RI
+	mtmsrd	r24			/* RI on */
+
 	/* Grab our linux cpu number */
 	mr      r24,r3
 
@@ -214,7 +218,7 @@ _GLOBAL(__secondary_hold)
 		                        /*   assumes *_common < 16b   */ \
 	mfmsr   r23;                                                     \
 	rotldi  r23,r23,4;                                               \
-	ori     r23,r23,0x30B;          /* Set IR, DR, SF, ISF, HV    */ \
+	ori     r23,r23,0x32B;          /* Set IR, DR, RI, SF, ISF, HV*/ \
 	rotldi  r23,r23,60;             /* for generic handlers       */ \
 	mtspr   SRR0,r22;                                                \
 	mtspr   SRR1,r23;                                                \
@@ -632,6 +636,12 @@ fast_exception_return:
 	REST_GPR(0, r1)
 	REST_8GPRS(2, r1)
 	REST_4GPRS(10, r1)
+
+	mfmsr	r20
+	li	r21, MSR_RI
+	andc	r20,r20,r21
+	mtmsrd	r20,1
+
 	mtspr   SRR1,r23
 	mtspr   SRR0,r22
 	REST_4GPRS(20, r1)
@@ -1166,6 +1176,12 @@ _GLOBAL(do_stab_bolted)
 	lwz	r23,EX_CCR(r21)		/* get saved CR */
 	/* note that this is almost identical to maskable_exception_exit */
 	mtcr    r23                     /* restore CR */
+
+	mfmsr	r22
+	li	r23, MSR_RI
+	andc	r22,r22,r23
+	mtmsrd	r22,1
+
 	ld	r22,EX_SRR0(r21)	/* Get SRR0 from exc. frame */
 	ld	r23,EX_SRR1(r21)	/* Get SRR1 from exc. frame */
 	mtspr	SRR0,r22
@@ -1240,7 +1256,6 @@ SLB_NUM_ENTRIES = 64
 	beq-	2b
 	
 	/* Invalidate the old entry */
-	slbmfee r21,r22
 	lis	r23,-2049
 	ori	r23,r23,65535
 	and	r21,r21,r23
@@ -1274,6 +1289,12 @@ SLB_NUM_ENTRIES = 64
 	lwz	r23,EX_CCR(r21)		/* get saved CR */
 	/* note that this is almost identical to maskable_exception_exit */
 	mtcr    r23                     /* restore CR */
+
+	mfmsr	r22
+	li	r23, MSR_RI
+	andc	r22,r22,r23
+	mtmsrd	r22,1
+
 	ld	r22,EX_SRR0(r21)	/* Get SRR0 from exc. frame */
 	ld	r23,EX_SRR1(r21)	/* Get SRR1 from exc. frame */
 	mtspr	SRR0,r22
@@ -1903,9 +1924,13 @@ _GLOBAL(__secondary_start)
 	bne   	98f
 	mfspr	r3,PVR
 	srwi	r3,r3,16
-	cmpwi	r3,0x37         /* SStar */
+	cmpwi	r3,0x37         /* SStar  */
+	beq	97f
+	cmpwi	r3,0x36         /* IStar  */
+	beq	97f
+	cmpwi	r3,0x34         /* Pulsar */
 	bne	98f
-	li	r3,H_SET_ASR    /* hcall = H_SET_ASR */
+97:	li	r3,H_SET_ASR    /* hcall = H_SET_ASR */
 	HSC     		/* Invoking hcall */
 	b	99f
 98:                             /* !(rpa hypervisor) || !(sstar) */
@@ -1972,6 +1997,10 @@ _STATIC(start_here_pSeries)
 	bl	.reloc_offset
 	mr	r26,r3
 
+	mfmsr	r6
+	ori	r6,r6,MSR_RI
+	mtmsrd	r6			/* RI on */
+
 	/* setup the systemcfg pointer which is needed by *tab_initialize  */
 	LOADADDR(r6,systemcfg)
 	sub	r6,r6,r26                /* addr of the variable systemcfg */
@@ -2058,8 +2087,12 @@ _STATIC(start_here_pSeries)
 	mfspr	r3,PVR
 	srwi	r3,r3,16
 	cmpwi	r3,0x37         /* SStar */
+	beq	97f
+	cmpwi	r3,0x36         /* IStar  */
+	beq	97f
+	cmpwi	r3,0x34         /* Pulsar */
 	bne	98f
-	li	r3,H_SET_ASR    /* hcall = H_SET_ASR */
+97:	li	r3,H_SET_ASR    /* hcall = H_SET_ASR */
 	HSC     	        /* Invoking hcall */
 	b     	99f
 98:                 /* This is not a hypervisor machine */
diff -urNp linux-365/arch/ppc64/kernel/htab.c linux-370/arch/ppc64/kernel/htab.c
--- linux-365/arch/ppc64/kernel/htab.c
+++ linux-370/arch/ppc64/kernel/htab.c
@@ -1179,7 +1179,7 @@ repeat:
                 "mr    5, %3\n"
                 "mr    6, %4\n"
                 "mr    7, %5\n"
-                HSC    
+		HVSC
                 "mr    %0, 3\n"
                 "mr    %1, 4\n"
 		: "=r" (lpar_rc), "=r" (slot)
@@ -1200,7 +1200,7 @@ repeat:
 			      "mr    5, %3\n"
 			      "mr    6, %4\n"
 			      "mr    7, %5\n"
-			      HSC    
+			      HVSC
 			      "mr    %0, 3\n"
 			      "mr    %1, 4\n"
 			      : "=r" (lpar_rc), "=r" (slot)
diff -urNp linux-365/arch/ppc64/kernel/idle.c linux-370/arch/ppc64/kernel/idle.c
--- linux-365/arch/ppc64/kernel/idle.c
+++ linux-370/arch/ppc64/kernel/idle.c
@@ -2,7 +2,12 @@
  * Idle daemon for PowerPC.  Idle daemon will handle any action
  * that needs to be taken when the system becomes idle.
  *
- * Written by Cort Dougan (cort@cs.nmt.edu)
+ * Originally Written by Cort Dougan (cort@cs.nmt.edu)
+ *
+ * iSeries supported added by Mike Corrigan <mikejc@us.ibm.com>
+ *
+ * Additional shared processor, SMT, and firmware support
+ *    Copyright (c) 2003 Dave Engebretsen <engebret@us.ibm.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -10,6 +15,7 @@
  * 2 of the License, or (at your option) any later version.
  */
 #include <linux/config.h>
+#include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/sched.h>
 #include <linux/kernel.h>
@@ -28,17 +34,20 @@
 #include <asm/processor.h>
 #include <asm/mmu.h>
 #include <asm/cache.h>
+#include <asm/cputable.h>
 
 #include <asm/time.h>
 #include <asm/iSeries/LparData.h>
 #include <asm/iSeries/HvCall.h>
 #include <asm/iSeries/ItLpQueue.h>
 
+int (*idle_loop)(void);
+
 #ifdef CONFIG_PPC_ISERIES
 static void yield_shared_processor(void)
 {
 	struct paca_struct *lpaca = get_paca();
-	
+
 	HvCall_setEnabledInterrupts(HvCall_MaskIPI |
 				    HvCall_MaskLpEvent |
 				    HvCall_MaskLpProd |
@@ -50,12 +59,19 @@ static void yield_shared_processor(void)
 		 * We want to be woken up when the next decrementer is
 		 * to fire.  
 		 */
-		HvCall_yieldProcessor(HvCall_YieldTimed, 
-				      lpaca->next_jiffy_update_tb);	  
+		__cli();
+		lpaca->yielded = 1;        /* Indicate a prod is desired */
+		lpaca->xLpPaca.xIdle = 1;  /* Inform the HV we are idle  */
 
-		/* 
-		 * The decrementer stops during the yield.  Force a fake 
-		 * decrementer here and let the timer_interrupt code sort 
+		HvCall_yieldProcessor(HvCall_YieldTimed,
+				      lpaca->next_jiffy_update_tb);
+
+		lpaca->yielded = 0;        /* Back to IPI's */
+		__sti();
+
+		/*
+		 * The decrementer stops during the yield.  Force a fake
+		 * decrementer here and let the timer_interrupt code sort
 		 * out the actual time.
 		 */
 		lpaca->xLpPaca.xIntDword.xFields.xDecrInt = 1;
@@ -63,65 +79,215 @@ static void yield_shared_processor(void)
 	  
 	process_iSeries_events();
 }
-#endif /* CONFIG_PPC_ISERIES */
 
-int idled(void)
+int idle_iSeries(void)
 {
 	struct paca_struct *lpaca;
 	long oldval;
-#ifdef CONFIG_PPC_ISERIES
 	unsigned long CTRL;
-#endif
 
-#ifdef CONFIG_PPC_ISERIES
 	/* ensure iSeries run light will be out when idle */
 	current->thread.flags &= ~PPC_FLAG_RUN_LIGHT;
 	CTRL = mfspr(CTRLF);
 	CTRL &= ~RUNLATCH;
 	mtspr(CTRLT, CTRL);
-#endif
 
 	lpaca = get_paca();
 
 	for (;;) {
-#ifdef CONFIG_PPC_ISERIES
 		if ( lpaca->xLpPaca.xSharedProc ) {
 			if ( ItLpQueue_isLpIntPending( lpaca->lpQueuePtr ) )
 				process_iSeries_events();
 			if ( !current->need_resched )
 				yield_shared_processor();
-		}
-		else 
-#endif
-		{
+		} else {
 			/* Avoid an IPI by setting need_resched */
 			oldval = xchg(&current->need_resched, -1);
 			if (!oldval) {
 				while(current->need_resched == -1) {
-#ifdef CONFIG_PPC_ISERIES
 					HMT_medium();
 					if ( ItLpQueue_isLpIntPending( lpaca->lpQueuePtr ) )
 						process_iSeries_events();
-#endif
 					HMT_low();
 				}
 			}
 		}
 		HMT_medium();
 		if (current->need_resched) {
+			lpaca->xLpPaca.xIdle = 0;
 			schedule();
 			check_pgt_cache();
 		}
 	}
 	return 0;
 }
+#endif
+
+int idle_default(void)
+{
+	long oldval;
+
+	for (;;) {
+		/* Avoid an IPI by setting need_resched */
+		oldval = xchg(&current->need_resched, -1);
+		if (!oldval) {
+			while(current->need_resched == -1) {
+				HMT_low();
+			}
+		}
+		HMT_medium();
+		if (current->need_resched) {
+			schedule();
+			check_pgt_cache();
+		}
+	}
+	return 0;
+}
+
+int idle_dedicated(void)
+{
+	long oldval;
+	struct paca_struct *lpaca = get_paca(), *ppaca;
+	unsigned long start_snooze;
+
+	ppaca = &paca[(lpaca->xPacaIndex) ^ 1];
+
+	for (;;) {
+		/* Indicate to the HV that we are idle.  Now would be
+		 * a good time to find other work to dispatch. */
+		lpaca->xLpPaca.xIdle = 1;
+
+		/* Avoid an IPI by setting need_resched */
+		oldval = xchg(&current->need_resched, -1);
+		if (!oldval) {
+			start_snooze = __get_tb();
+			while(current->need_resched == -1) {
+				if (__get_tb() <
+				    (start_snooze +
+				     naca->smt_snooze_delay*tb_ticks_per_usec)) {
+					HMT_low(); /* Low thread priority */
+					continue;
+				}
+
+				HMT_very_low(); /* Low power mode */
+
+				/* If the SMT mode is system controlled & the
+				 * partner thread is doing work, switch into
+				 * ST mode.
+				 */
+				if((naca->smt_state == SMT_DYNAMIC) &&
+				   (!(ppaca->xLpPaca.xIdle))) {
+					/* need_resched could be 1 or -1 at this
+					 * point.  If it is -1, set it to 0, so
+					 * an IPI/Prod is sent.  If it is 1, keep
+					 * it that way & schedule work.
+					 */
+					oldval = xchg(&current->need_resched, 0);
+					if(oldval == 1) {
+						current->need_resched = oldval;
+						break;
+					}
+
+					/* DRENG: Go HMT_medium here ? */
+					__cli();
+					lpaca->yielded = 1;
+
+					/* SMT dynamic mode.  Cede will result
+					 * in this thread going dormant, if the
+					 * partner thread is still doing work.
+					 * Thread wakes up if partner goes idle,
+					 * an interrupt is presented, or a prod
+					 * occurs.  Returning from the cede
+					 * enables external interrupts.
+					 */
+					cede_processor();
+
+					lpaca->yielded = 0;
+				} else {
+					/* Give the HV an opportunity at the
+					 * processor, since we are not doing
+					 * any work.
+					 */
+					poll_pending();
+				}
+			}
+		}
+		HMT_medium();
+		if (current->need_resched) {
+			lpaca->xLpPaca.xIdle = 0;
+			schedule();
+			check_pgt_cache();
+		}
+	}
+	return 0;
+}
+
+int idle_shared(void)
+{
+	struct paca_struct *lpaca = get_paca();
+
+	for (;;) {
+		/* Indicate to the HV that we are idle.  Now would be
+		 * a good time to find other work to dispatch. */
+		lpaca->xLpPaca.xIdle = 1;
+
+		if (!current->need_resched) {
+			__cli();
+			lpaca->yielded = 1;
 
 /*
- * SMP entry into the idle task - calls the same thing as the
- * non-smp versions. -- Cort
+			 * Yield the processor to the hypervisor.  We return if
+			 * an external interrupt occurs (which are driven prior
+			 * to returning here) or if a prod occurs from another
+			 * processor.  When returning here, external interrupts
+			 * are enabled.
  */
+			cede_processor();
+
+			lpaca->yielded = 0;
+		}
+
+		HMT_medium();
+		if (current->need_resched) {
+			lpaca->xLpPaca.xIdle = 0;
+			schedule();
+			check_pgt_cache();
+		}
+	}
+
+	return 0;
+}
+
 int cpu_idle(void)
 {
-	idled();
+	idle_loop();
 	return 0; 
 }
+
+int idle_setup(void)
+{
+#ifdef CONFIG_PPC_ISERIES
+	idle_loop = idle_iSeries;
+#else
+	if (systemcfg->platform & PLATFORM_PSERIES) {
+		if (cur_cpu_spec->firmware_features & FW_FEATURE_SPLPAR) {
+			if(get_paca()->xLpPaca.xSharedProc) {
+				printk("idle = idle_shared\n");
+				idle_loop = idle_shared;
+			} else {
+				printk("idle = idle_dedicated\n");
+				idle_loop = idle_dedicated;
+			}
+		} else {
+			printk("idle = idle_default\n");
+			idle_loop = idle_default;
+		}
+	} else {
+		printk("idle_setup: unknown platform, use idle_default\n");
+		idle_loop = idle_default;
+	}
+#endif
+
+	return 1;
+}
+
diff -urNp linux-365/arch/ppc64/kernel/pSeries_hvCall.S linux-370/arch/ppc64/kernel/pSeries_hvCall.S
--- linux-365/arch/ppc64/kernel/pSeries_hvCall.S
+++ linux-370/arch/ppc64/kernel/pSeries_hvCall.S
@@ -23,7 +23,7 @@
 /*
  * hcall interface to pSeries LPAR
  */
-#define HSC .long 0x44000022
+#define HVSC	.long 0x44000022
 
 /* long plpar_hcall(unsigned long opcode,	 R3 
 		 unsigned long arg1,		 R4 
@@ -45,7 +45,7 @@ _GLOBAL(plpar_hcall)
         std     r9,-16(r1)
         std     r10,-24(r1)
 	
-	HSC                     /* invoke the hypervisor */
+	HVSC                    /* invoke the hypervisor */
 
         ld      r10,-8(r1)      /* Fetch r4-r7 ret args. */
         std     r4,0(r10)
@@ -60,11 +60,85 @@ _GLOBAL(plpar_hcall)
 	blr                     /* return r3 = status */
 
 
+/* long plpar_hcall_4out(unsigned long opcode,	 R3
+		 unsigned long arg1,		 R4
+		 unsigned long arg2,		 R5
+		 unsigned long arg3,		 R6
+		 unsigned long arg4,		 R7
+		 unsigned long *out1,	(r4)	 R8
+		 unsigned long *out2,	(r5)	 R9
+		 unsigned long *out3,   (r6)     R10
+		 unsigned long *out4);	(r7)	 112(R1). From Parameter save area. 
+ */
+_GLOBAL(plpar_hcall_4out)
+	mfcr	r0
+	std	r0,-8(r1)
+	ld      r14,112(r1)
+	stdu	r1,-48(r1)
+
+	std     r8,32(r1)       /* Save out ptrs. */
+	std     r9,24(r1)
+	std     r10,16(r1)
+	std     r14,8(r1)
+
+	HVSC                    /* invoke the hypervisor */
+
+	ld      r14,32(r1)      /* Fetch r4-r7 ret args. */
+	std     r4,0(r14)
+	ld      r14,24(r1)
+	std     r5,0(r14)
+	ld      r14,16(r1)
+	std     r6,0(r14)
+	ld      r14,8(r1)
+	std     r7,0(r14)
+
+	ld	r1,0(r1) 
+	ld	r0,-8(r1)
+	mtcrf	0xff,r0
+	blr                     /* return r3 = status */
+
+
 /* Simple interface with no output values (other than status) */
 _GLOBAL(plpar_hcall_norets)
 	mfcr	r0
 	std	r0,-8(r1)
-	HSC                     /* invoke the hypervisor */
+	HVSC                    /* invoke the hypervisor */
+	ld	r0,-8(r1)
+	mtcrf	0xff,r0
+	blr                     /* return r3 = status */
+
+
+/* long plpar_hcall_8arg_2ret(unsigned long opcode,		 R3
+				unsigned long arg1,		 R4
+				unsigned long arg2,		 R5
+				unsigned long arg3,		 R6
+				unsigned long arg4,		 R7
+				unsigned long arg5,		 R8
+				unsigned long arg6,		 R9
+				unsigned long arg7,		 R10
+				unsigned long arg8,		 112(R1)
+				unsigned long *out1);		 120(R1)
+
+ */
+
+	.text
+_GLOBAL(plpar_hcall_8arg_2ret)
+	mfcr	r0
+
+	ld	r11, 112(r1) /* put arg8 and out1 in R11 and R12 */
+	ld	r12, 120(r1)
+
+	std	r0,-8(r1)
+	stdu	r1,-32(r1)
+
+	std	r12,-8(r1)      /* Save out ptr */
+
+	HVSC                     /* invoke the hypervisor */
+
+	ld	r10,-8(r1)      /* Fetch r4 ret arg */
+	std	r4,0(r10)
+
+	ld	r1,0(r1)
 	ld	r0,-8(r1)
 	mtcrf	0xff,r0
 	blr                     /* return r3 = status */
diff -urNp linux-365/arch/ppc64/kernel/pSeries_lpar.c linux-370/arch/ppc64/kernel/pSeries_lpar.c
--- linux-365/arch/ppc64/kernel/pSeries_lpar.c
+++ linux-370/arch/ppc64/kernel/pSeries_lpar.c
@@ -35,6 +35,41 @@
 #include <linux/pci.h>
 #include <asm/naca.h>
 #include <asm/hvcall.h>
+long poll_pending(void)
+{
+	unsigned long dummy;
+	return plpar_hcall(H_POLL_PENDING, 0, 0, 0, 0,
+			   &dummy, &dummy, &dummy);
+}
+
+long prod_processor(void)
+{
+	plpar_hcall_norets(H_PROD);
+	return(0);
+}
+
+long cede_processor(void)
+{
+	plpar_hcall_norets(H_CEDE);
+	return(0);
+}
+
+long register_vpa(unsigned long flags, unsigned long proc, unsigned long vpa)
+{
+	plpar_hcall_norets(H_REGISTER_VPA, flags, proc, vpa);
+	return(0);
+}
+
+void vpa_init(int cpu)
+{
+	unsigned long flags;
+
+	/* Register the Virtual Processor Area (VPA) */
+	printk(KERN_INFO "register_vpa: cpu 0x%x\n", cpu);
+	flags = 1UL << (63 - 18);
+	paca[cpu].xLpPaca.xSLBCount = 64; /* SLB restore highwater mark */
+	register_vpa(flags, cpu, __pa((unsigned long)&(paca[cpu].xLpPaca)));
+}
 
 long plpar_tce_get(unsigned long liobn,
 		   unsigned long ioba,
@@ -212,6 +247,7 @@ xics_ops pSeriesLP_ops = {
 
 
 int vtermno;	/* virtual terminal# for udbg  */
+int udbgwait = 0;
 
 static void udbg_putcLP(unsigned char c)
 {
@@ -261,6 +297,9 @@ static int udbg_getc_pollLP(void)
 static unsigned char udbg_getcLP(void)
 {
 	int ch;
+	udbgwait = 1;
+	mb();
+
 	for (;;) {
 		ch = udbg_getc_pollLP();
 		if (ch == -1) {
@@ -269,9 +308,12 @@ static unsigned char udbg_getcLP(void)
 			for (delay=0; delay < 2000000; delay++)
 				;
 		} else {
-			return ch;
+			break;
 		}
 	}
+	udbgwait = 0;
+	mb();
+	return ch;
 }
 
 
@@ -281,6 +323,9 @@ int hvc_get_chars(int index, char *buf, 
 {
 	unsigned long got;
 
+	if (udbgwait)
+		return 0;
+
 	if (plpar_hcall(H_GET_TERM_CHAR, index, 0, 0, 0, &got,
 		(unsigned long *)buf, (unsigned long *)buf+1) == H_Success) {
 		/*
@@ -318,24 +363,114 @@ int hvc_put_chars(int index, const char 
 	return -1;
 }
 
+/* return the number of client vterms present */
+/* XXX this requires an interface change to handle multiple discontiguous
+ * vterms */
 int hvc_count(int *start_termno)
 {
 	u32 *termno;
-	struct device_node *dn;
+	struct device_node *rtas;
+	struct device_node *vtys;
 
-	if ((dn = find_path_device("/rtas")) != NULL) {
-		if ((termno = (u32 *)get_property(dn, "ibm,termno", 0)) != NULL) {
+	/* consider only the first vty node.
+	 * we should _always_ be able to find one. however, it may not be compatible
+	 * with hvterm1, in which case hvc_console can't use it. */
+	vtys = find_devices("vty");
+	if (vtys && device_is_compatible(vtys, "hvterm1")) {
+		termno = (u32 *)get_property(vtys, "reg", 0);
+		if (start_termno && termno)
+			*start_termno = *termno;
+		return 1; /* we can't support >1 with this interface */
+	}
+
+	/* no vty nodes; use the /rtas/ibm,termno property */
+	printk(KERN_ERR "%s: couldn't find a 'vty' node\n", __FUNCTION__);
+	if ((rtas = find_path_device("/rtas")) != NULL) {
+		if ((termno = (u32 *)get_property(rtas, "ibm,termno", 0)) != NULL) {
 			if (start_termno)
 				*start_termno = termno[0];
 			return termno[1];
 		}
 	}
+
+	/* couldn't find any vterms */
 	return 0;
 }
 
 #ifndef CONFIG_PPC_ISERIES
 void pSeries_lpar_mm_init(void);
 
+/* returns 0 if couldn't find or use /chosen/stdout as console */
+static int find_udbg_vterm(void)
+{
+	struct device_node *stdout_node;
+	u32 *termno;
+	char *name;
+	int found = 0;
+
+	/* find the boot console from /chosen/stdout */
+	if (!of_stdout_device) {
+		printk(KERN_WARNING "couldn't get path from /chosen/stdout!\n");
+		return found;
+	}
+	stdout_node = find_path_device(of_stdout_device);
+	if (!stdout_node) {
+		printk(KERN_WARNING "couldn't find node from /chosen/stdout\n");
+		return found;
+	}
+
+	/* now we have the stdout node; figure out what type of device it is. */
+	name = (char *)get_property(stdout_node, "name", 0);
+	if (!name) {
+		printk(KERN_WARNING "stdout node missing 'name' property!\n");
+		return found;
+	}
+
+	if (strncmp(name, "vty", 3) == 0) {
+		char *compatible;
+		compatible = (char *)get_property(stdout_node, "compatible", 0);
+		if (compatible && (strncmp(compatible, "hvterm1", 7) == 0)) {
+			termno = (u32 *)get_property(stdout_node, "reg", 0);
+			if (termno) {
+				vtermno = termno[0];
+				ppc_md.udbg_putc = udbg_putcLP;
+				ppc_md.udbg_getc = udbg_getcLP;
+				ppc_md.udbg_getc_poll = udbg_getc_pollLP;
+				found = 1;
+			}
+		} else {
+			/* XXX implement udbg_putcLP_vtty for hvterm-protocol1 case */
+			printk(KERN_WARNING "%s doesn't speak hvterm1; "
+				"can't print udbg messages\n", of_stdout_device);
+		}
+	} else if (strncmp(name, "rtas", 4)) {
+		/* according to firmware, this should never happen. to be removed */
+		printk(KERN_ERR "ATTENTION: /chosen/stdout should be /vdevice/vty@0!\n"
+			"Please report this to linuxppc64-dev@lists.linuxppc.org\n");
+
+		/* "ibm,termno" property is a pair of numbers. The first is the
+		 * starting termno (the one we use) and the second is the number
+		 * of terminals. */
+		termno = (u32 *)get_property(stdout_node, "ibm,termno", 0);
+		if (termno) {
+			vtermno = termno[0];
+			ppc_md.udbg_putc = udbg_putcLP;
+			ppc_md.udbg_getc = udbg_getcLP;
+			ppc_md.udbg_getc_poll = udbg_getc_pollLP;
+			found = 1;
+		}
+	} else if (strncmp(name, "serial", 6)) {
+		/* XXX fix ISA serial console */
+		printk(KERN_WARNING "serial stdout on LPAR ('%s')! "
+			"can't print udbg messages\n", of_stdout_device);
+	} else {
+		printk(KERN_WARNING "don't know how to print to stdout '%s'\n",
+			of_stdout_device);
+	}
+
+	return found;
+}
+
 /* This is called early in setup.c.
  * Use it to setup page table ppc_md stuff as well as udbg.
  */
@@ -352,23 +487,12 @@ void pSeriesLP_init_early(void)
 	pSeries_pcibios_init_early();
 
 	/* The keyboard is not useful in the LPAR environment.
-	 * Leave all the interfaces NULL.
+	 * Leave all ppc_md keyboard interfaces NULL.
 	 */
 
-	/* lookup the first virtual terminal number in case we don't have a com port.
-	 * Zero is probably correct in case someone calls udbg before the init.
-	 * The property is a pair of numbers.  The first is the starting termno (the
-	 * one we use) and the second is the number of terminals.
-	 */
-	u32 *termno;
-	struct device_node *np = find_path_device("/rtas");
-	if (np) {
-		termno = (u32 *)get_property(np, "ibm,termno", 0);
-		if (termno)
-			vtermno = termno[0];
+	if (0 == find_udbg_vterm()) {
+		printk(KERN_WARNING
+				"can't use stdout; can't print early debug messages.\n");
 	}
-	ppc_md.udbg_putc = udbg_putcLP;
-	ppc_md.udbg_getc = udbg_getcLP;
-	ppc_md.udbg_getc_poll = udbg_getc_pollLP;
 }
 #endif
diff -urNp linux-365/arch/ppc64/kernel/pci_dma.c linux-370/arch/ppc64/kernel/pci_dma.c
--- linux-365/arch/ppc64/kernel/pci_dma.c
+++ linux-370/arch/ppc64/kernel/pci_dma.c
@@ -97,11 +97,8 @@ void free_tce_range_nolock(struct TceTab
 			   unsigned order );
 
 /* allocates a range of tces and sets them to the pages  */
-static inline dma_addr_t get_tces( struct TceTable *, 
-				   unsigned order, 
-				   void *page, 
-				   unsigned numPages,
-				   int direction );
+dma_addr_t get_tces(struct TceTable *, unsigned order, void *page,
+		    unsigned numPages, int direction);
 
 static long test_tce_range( struct TceTable *, 
 			    long tcenum, 
@@ -219,7 +216,7 @@ static void tce_build_pSeries(struct Tce
  * Build a TceTable structure.  This contains a multi-level bit map which
  * is used to manage allocation of the tce space.
  */
-static struct TceTable *build_tce_table( struct TceTable * tbl )
+struct TceTable *build_tce_table(struct TceTable * tbl)
 {
 	unsigned long bits, bytes, totalBytes;
 	unsigned long numBits[NUM_TCE_LEVELS], numBytes[NUM_TCE_LEVELS];
@@ -527,7 +524,8 @@ static long test_tce_range( struct TceTa
 	return retval;
 }
 
-static inline dma_addr_t get_tces( struct TceTable *tbl, unsigned order, void *page, unsigned numPages, int direction )
+inline dma_addr_t get_tces(struct TceTable *tbl, unsigned order,
+			   void *page, unsigned numPages, int direction)
 {
 	long tcenum;
 	unsigned long uaddr;
@@ -587,8 +585,8 @@ static void tce_free_one_pSeries( struct
 
 }
 
-static void tce_free(struct TceTable *tbl, dma_addr_t dma_addr, 
-			     unsigned order, unsigned num_pages)
+void tce_free(struct TceTable *tbl, dma_addr_t dma_addr,
+	      unsigned order, unsigned num_pages)
 {
 	long tcenum, total_tces, free_tce;
 	unsigned i;
@@ -714,12 +712,6 @@ void create_tce_tables_for_busesLP(struc
 	for (ln=bus_list->next; ln != bus_list; ln=ln->next) {
 		bus = pci_bus_b(ln);
 		busdn = PCI_GET_DN(bus);
-		/* NOTE: there should never be a window declared on a bus when
-		 * child devices also have a window.  If this should ever be
-		 * architected, we probably want children to have priority.
-		 * In reality, the PHB containing ISA has the property, but otherwise
-		 * it is the pci-bridges that have the property.
-		 */
 		dma_window = (u32 *)get_property(busdn, "ibm,dma-window", 0);
 		if (dma_window) {
 			/* Busno hasn't been copied yet.
@@ -728,6 +720,7 @@ void create_tce_tables_for_busesLP(struc
 			busdn->busno = bus->number;
 			create_pci_bus_tce_table((unsigned long)busdn);
 		}
+		/* look for a window on a bridge even if the PHB had one */
 		create_tce_tables_for_busesLP(&bus->children);
 	}
 }
@@ -1066,7 +1059,7 @@ void pci_free_consistent(struct pci_dev 
  	/* Client asked for way to much space.  This is checked later anyway */
 	/* It is easier to debug here for the drivers than in the tce tables.*/
  	if(order >= NUM_TCE_LEVELS) {
- 		printk("PCI_DMA: pci_free_consistent size to large: 0x%lx \n",size);
+ 		printk("PCI_DMA: pci_free_consistent size too large: 0x%lx \n",size);
  		return;
  	}
 	
@@ -1105,13 +1098,14 @@ dma_addr_t pci_map_single(struct pci_dev
  	/* Client asked for way to much space.  This is checked later anyway */
 	/* It is easier to debug here for the drivers than in the tce tables.*/
  	if(order >= NUM_TCE_LEVELS) {
- 		panic("PCI_DMA: pci_map_single size too large: 0x%lx \n", size);
+		panic("PCI_DMA: pci_map_single size too large: 0x%lx \n", size);
  		return dma_handle;
  	}
 
 	tbl = get_tce_table(hwdev); 
 
 	if ( tbl ) {
+		/* get_tces panics if there are no entries available */
 		dma_handle = get_tces( tbl, order, vaddr, nPages, direction );
 		dma_handle |= ( uaddr & ~PAGE_MASK );
 	} else {
@@ -1138,7 +1132,7 @@ void pci_unmap_single( struct pci_dev *h
  	/* Client asked for way to much space.  This is checked later anyway */
 	/* It is easier to debug here for the drivers than in the tce tables.*/
  	if(order >= NUM_TCE_LEVELS) {
- 		printk("PCI_DMA: pci_unmap_single size to large: 0x%lx \n",size);
+ 		printk("PCI_DMA: pci_unmap_single size too large: 0x%lx \n",size);
  		return;
  	}
 	
@@ -1305,7 +1299,8 @@ static dma_addr_t create_tces_sg( struct
  	/* Client asked for way to much space.  This is checked later anyway */
 	/* It is easier to debug here for the drivers than in the tce tables.*/
  	if(order >= NUM_TCE_LEVELS) {
-		printk("PCI_DMA: create_tces_sg size to large: 0x%x \n",(numTces << PAGE_SHIFT));
+		printk("PCI_DMA: create_tces_sg size too large: 0x%llx \n",(numTces << PAGE_SHIFT));
+		panic("numTces is off");
  		return NO_TCE;
  	}
 
@@ -1356,7 +1351,7 @@ static dma_addr_t create_tces_sg( struct
 		   		numTces, (unsigned)(tcenum - starttcenum));
 
 	} else {
-		panic("PCI_DMA: TCE allocation failure in create_tces_sg. 0x%p 0x%lx\n",
+		panic("PCI_DMA: TCE allocation failure in create_tces_sg. 0x%p 0x%x\n",
 		      tbl, order);
 	}
 
@@ -1371,8 +1366,6 @@ int pci_map_sg( struct pci_dev *hwdev, s
 	dma_addr_t dma_handle;
 	void *address;
 
-	PPCDBG(PPCDBG_TCE, "pci_map_sg:\n");
-	PPCDBG(PPCDBG_TCE, "\thwdev = 0x%16.16lx, sg = 0x%16.16lx, direction = 0x%16.16lx, nents = 0x%16.16lx\n", hwdev, sg, direction, nents);	
 	/* Fast path for a single entry scatterlist */
 	if ( nents == 1 ) {
 		address = sg->address ? sg->address :
@@ -1435,7 +1428,7 @@ void pci_unmap_sg( struct pci_dev *hwdev
 	/* It is easier to debug here for the drivers than in the tce tables.*/
  	if(order >= NUM_TCE_LEVELS) {
 		printk("PCI_DMA: dma_start_page:0x%lx  dma_end_page:0x%lx\n",dma_start_page,dma_end_page);
-		printk("PCI_DMA: pci_unmap_sg size to large: 0x%x \n",(numTces << PAGE_SHIFT));
+		printk("PCI_DMA: pci_unmap_sg size too large: 0x%x \n",(numTces << PAGE_SHIFT));
  		return;
  	}
 	
diff -urNp linux-365/arch/ppc64/kernel/pmc.c linux-370/arch/ppc64/kernel/pmc.c
--- linux-365/arch/ppc64/kernel/pmc.c
+++ linux-370/arch/ppc64/kernel/pmc.c
@@ -74,7 +74,6 @@ struct mm_struct btmalloc_mm = {pgd     
                                 page_table_lock : SPIN_LOCK_UNLOCKED};
 
 extern spinlock_t hash_table_lock[];
-extern inline unsigned long get_lock_slot(unsigned long vpn);
 
 char *
 ppc64_pmc_stab(int file)
diff -urNp linux-365/arch/ppc64/kernel/proc_pmc.c linux-370/arch/ppc64/kernel/proc_pmc.c
--- linux-365/arch/ppc64/kernel/proc_pmc.c
+++ linux-370/arch/ppc64/kernel/proc_pmc.c
@@ -58,6 +58,8 @@ spinlock_t proc_ppc64_lock;
 static int proc_ppc64_page_read(char *page, char **start, off_t off,
 				int count, int *eof, void *data);
 static void proc_ppc64_create_paca(int num, struct proc_dir_entry *paca_dir);
+void proc_ppc64_create_smt(void);
+
 int proc_ppc64_pmc_find_file(void *data);
 int proc_ppc64_pmc_read(char *page, char **start, off_t off,
 			int count, int *eof, char *buffer);
@@ -182,6 +184,8 @@ void proc_ppc64_init(void)
 		rtas_proc_dir = proc_mkdir("rtas", proc_ppc64_root);
 	}
 
+	proc_ppc64_create_smt();
+
 	/* Create the /proc/ppc64/pcifr for the Pci Flight Recorder.	 */
 	proc_pciFr_init(proc_ppc64_root);
 
@@ -449,6 +453,7 @@ static ssize_t read_profile(struct file 
 static ssize_t write_profile(struct file * file, const char * buf,
 			     size_t count, loff_t *ppos)
 {
+	return(0);
 }
 
 static ssize_t read_trace(struct file *file, char *buf,
@@ -473,6 +478,7 @@ static ssize_t read_trace(struct file *f
 static ssize_t write_trace(struct file * file, const char * buf,
 			     size_t count, loff_t *ppos)
 {
+	return(0);
 }
 
 static ssize_t read_timeslice(struct file *file, char *buf,
@@ -498,6 +504,7 @@ static ssize_t read_timeslice(struct fil
 static ssize_t write_timeslice(struct file * file, const char * buf,
 			       size_t count, loff_t *ppos)
 {
+	return(0);
 }
 
 int 
@@ -1069,3 +1076,85 @@ static int nacamap_mmap( struct file *fi
 	remap_page_range( vma->vm_start, __pa(dp->data), dp->size, vma->vm_page_prot );
 	return 0;
 }
+
+static int proc_ppc64_smt_snooze_read(char *page, char **start, off_t off,
+				      int count, int *eof, void *data)
+{
+	if (naca->smt_snooze_delay)
+		return sprintf(page, "%lu\n", naca->smt_snooze_delay);
+	else
+		return sprintf(page, "disabled\n");
+}
+
+static int proc_ppc64_smt_snooze_write(struct file* file, const char *buffer,
+				       unsigned long count, void *data)
+{
+	unsigned long val;
+	char val_string[22];
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EACCES;
+
+	if (count > sizeof(val_string) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(val_string, buffer, count))
+		return -EFAULT;
+
+	val_string[count] = '\0';
+
+	if (val_string[0] == '0' && (val_string[1] == '\n' || val_string[1] == '\0')) {
+		naca->smt_snooze_delay = 0;
+		return count;
+	}
+
+	val = simple_strtoul(val_string, NULL, 10);
+	if (val != 0)
+		naca->smt_snooze_delay = val;
+	else
+		return -EINVAL;
+
+	return count;
+}
+
+static int proc_ppc64_smt_state_read(char *page, char **start, off_t off,
+				      int count, int *eof, void *data)
+{
+	switch(naca->smt_state) {
+	case SMT_OFF:
+		return sprintf(page, "off\n");
+		break;
+	case SMT_ON:
+		return sprintf(page, "on\n");
+		break;
+	case SMT_DYNAMIC:
+		return sprintf(page, "dynamic\n");
+		break;
+	default:
+		return sprintf(page, "unknown\n");
+		break;
+	}
+}
+
+void proc_ppc64_create_smt(void)
+{
+	struct proc_dir_entry *ent_snooze =
+		create_proc_entry("smt-snooze-delay", S_IRUGO | S_IWUSR,
+				  proc_ppc64_root);
+	struct proc_dir_entry *ent_enabled =
+		create_proc_entry("smt-enabled", S_IRUGO | S_IWUSR,
+				  proc_ppc64_root);
+	if (ent_snooze) {
+		ent_snooze->nlink = 1;
+		ent_snooze->data = NULL;
+		ent_snooze->read_proc = (void *)proc_ppc64_smt_snooze_read;
+		ent_snooze->write_proc = (void *)proc_ppc64_smt_snooze_write;
+	}
+
+	if (ent_enabled) {
+		ent_enabled->nlink = 1;
+		ent_enabled->data = NULL;
+		ent_enabled->read_proc = (void *)proc_ppc64_smt_state_read;
+		ent_enabled->write_proc = NULL;
+	}
+}
diff -urNp linux-365/arch/ppc64/kernel/prom.c linux-370/arch/ppc64/kernel/prom.c
--- linux-365/arch/ppc64/kernel/prom.c
+++ linux-370/arch/ppc64/kernel/prom.c
@@ -145,11 +145,18 @@ static unsigned long interpret_pci_props
 static interpret_func interpret_isa_props;
 static interpret_func interpret_root_props;
 
+/*
+ * Properties whose value is longer than this get excluded from our
+ * copy of the device tree. This value does need to be big enough to
+ * ensure that we don't lose things like the interrupt-map property
+ * on a PCI-PCI bridge.
+ */
+#define MAX_PROPERTY_LENGTH	(1UL * 1024 * 1024)
+
 #ifndef FB_MAX			/* avoid pulling in all of the fb stuff */
 #define FB_MAX	8
 #endif
 
-
 struct prom_t prom = {
 	0,			/* entry */
 	0,			/* chosen */
@@ -165,7 +172,6 @@ struct prom_t prom = {
 #endif
 };
 
-
 char *prom_display_paths[FB_MAX] __initdata = { 0, };
 unsigned int prom_num_displays = 0;
 char *of_stdout_device = 0;
@@ -184,8 +190,17 @@ struct _of_tce_table of_tce_table[MAX_PH
 char *bootpath = 0;
 char *bootdevice = 0;
 
+#define MAX_CPU_THREADS 2
 int boot_cpuid = 0;
 
+/*
+ * 'ramdisk_start' is used to ensure the initrd image is not overwritten
+ * when the device tree is constructed in memory.
+ */
+#ifdef CONFIG_BLK_DEV_INITRD
+unsigned long ramdisk_start = 0;
+#endif
+
 struct device_node *allnodes = 0;
 
 #define UNDEFINED_IRQ 0xffff
@@ -944,12 +959,21 @@ prom_initialize_tce_table(void)
 			minsize = 4UL << 20;
 		}
 
-		/* Even though we read what OF wants, we just set the table
-		 * size to 4 MB.  This is enough to map 2GB of PCI DMA space.
-		 * By doing this, we avoid the pitfalls of trying to DMA to
-		 * MMIO space and the DMA alias hole.
+		/*
+		 * Even though we read what OF wants, we just set the table
+ 		 * size to 4 MB.  This is enough to map 2GB of PCI DMA space.
+ 		 * By doing this, we avoid the pitfalls of trying to DMA to
+ 		 * MMIO space and the DMA alias hole.
+		 *
+ 		 * On POWER4, firmware sets the TCE region by assuming
+ 		 * each TCE table is 8MB. Using this memory for anything
+ 		 * else will impact performance, so we always allocate 8MB.
+ 		 * Anton
 		 */
-		minsize = 4UL << 20;
+		if (__is_processor(PV_POWER4) || __is_processor(PV_POWER4p))
+			minsize = 8UL << 20;
+		else
+			minsize = 4UL << 20;
 
 		/* Align to the greater of the align or size */
 		align = (minalign < minsize) ? minsize : minalign;
@@ -997,9 +1021,12 @@ prom_initialize_tce_table(void)
 			*tce_entryp = tce_entry;
 		}
 
+		/* It seems OF doesn't null-terminate the path :-( */
+		memset(path, 0, sizeof(path));
+
 		/* Call OF to setup the TCE hardware */
 		if (call_prom(RELOC("package-to-path"), 3, 1, node,
-                             path, 255) <= 0) {
+                             path, sizeof(path)-1) <= 0) {
                         prom_print(RELOC("package-to-path failed\n"));
                 } else {
                         prom_print(RELOC("opened "));
@@ -1062,12 +1089,16 @@ prom_hold_cpus(unsigned long mem)
 	unsigned long offset = reloc_offset();
 	char type[64], *path;
 	int cpuid = 0;
+	unsigned int interrupt_server[MAX_CPU_THREADS];
+	unsigned int cpu_threads, hw_cpu_num;
+	int propsize;
 	extern void __secondary_hold(void);
         extern unsigned long __secondary_hold_spinloop;
         extern unsigned long __secondary_hold_acknowledge;
         unsigned long *spinloop     = __v2a(&__secondary_hold_spinloop);
         unsigned long *acknowledge  = __v2a(&__secondary_hold_acknowledge);
         unsigned long secondary_hold = (unsigned long)__v2a(*PTRRELOC((unsigned long *)__secondary_hold));
+        struct naca_struct *_naca = RELOC(naca);
         struct systemcfg *_systemcfg = RELOC(systemcfg);
 	struct paca_struct *_xPaca = PTRRELOC(&paca[0]);
 	struct prom_t *_prom = PTRRELOC(&prom);
@@ -1124,18 +1155,12 @@ prom_hold_cpus(unsigned long mem)
 		call_prom(RELOC("getprop"), 4, 1, node, RELOC("reg"),
 			  &reg, sizeof(reg));
 
-		/* Only need to start secondary procs, not ourself. */
-		if ( reg == _prom->cpu )
-			continue;
-
 		path = (char *) mem;
 		memset(path, 0, 256);
 		if ((long) call_prom(RELOC("package-to-path"), 3, 1,
 				     node, path, 255) < 0)
 			continue;
 
-		cpuid++;
-
 #ifdef DEBUG_PROM
 		prom_print_nl();
 		prom_print(RELOC("cpuid        = 0x"));
@@ -1145,10 +1170,8 @@ prom_hold_cpus(unsigned long mem)
 		prom_print_hex(reg);
 		prom_print_nl();
 #endif
-		_xPaca[cpuid].xHwProcNum = reg;
-
-		prom_print(RELOC("starting cpu "));
-		prom_print(path);
+		if (cpuid < NR_CPUS)
+			_xPaca[cpuid].xHwProcNum = reg;
 
 		/* Init the acknowledge var which will be reset by
 		 * the secondary cpu when it awakens from its OF
@@ -1156,47 +1179,87 @@ prom_hold_cpus(unsigned long mem)
 		 */
 		*acknowledge = (unsigned long)-1;
 
-#ifdef DEBUG_PROM
-		prom_print(RELOC("    3) spinloop       = 0x"));
-		prom_print_hex(spinloop);
-		prom_print_nl();
-		prom_print(RELOC("    3) *spinloop      = 0x"));
-		prom_print_hex(*spinloop);
-		prom_print_nl();
-		prom_print(RELOC("    3) acknowledge    = 0x"));
-		prom_print_hex(acknowledge);
-		prom_print_nl();
-		prom_print(RELOC("    3) *acknowledge   = 0x"));
-		prom_print_hex(*acknowledge);
-		prom_print_nl();
-		prom_print(RELOC("    3) secondary_hold = 0x"));
-		prom_print_hex(secondary_hold);
-		prom_print_nl();
-		prom_print(RELOC("    3) cpuid = 0x"));
-		prom_print_hex(cpuid);
-		prom_print_nl();
+		propsize = call_prom(RELOC("getprop"), 4, 1, node,
+				     RELOC("ibm,ppc-interrupt-server#s"),
+				     &interrupt_server,
+				     sizeof(interrupt_server));
+		if (propsize < 0) {
+			/* no property.  old hardware has no SMT */
+			cpu_threads = 1;
+			interrupt_server[0] = reg; /* fake it with phys id */
+		} else {
+			/* We have a threaded processor */
+			cpu_threads = propsize / sizeof(u32);
+			if (cpu_threads > MAX_CPU_THREADS) {
+				prom_print(RELOC("SMT: too many threads!\nSMT: found "));
+				prom_print_hex(cpu_threads);
+				prom_print(RELOC(", max is "));
+				prom_print_hex(MAX_CPU_THREADS);
+				prom_print_nl();
+				cpu_threads = 1; /* ToDo: panic? */
+			}
+		}
+
+		hw_cpu_num = interrupt_server[0];
+		if (hw_cpu_num != _prom->cpu) {
+			/* Primary Thread of non-boot cpu */
+			prom_print_hex(cpuid);
+			prom_print(RELOC(" : starting cpu "));
+			prom_print(path);
+			prom_print(RELOC("..."));
+			call_prom(RELOC("start-cpu"), 3, 0, node,
+				  secondary_hold, cpuid);
+
+			for ( i = 0 ; (i < 100000000) && 
+				(*acknowledge == ((unsigned long)-1)); i++ ) ;
+
+			if (*acknowledge == cpuid) {
+				prom_print(RELOC("ok\n"));
+				/* We have to get every CPU out of OF,
+				 * even if we never start it. */
+				if (cpuid >= NR_CPUS) {
+					cpuid++;
+					continue;
+				}
+#ifdef CONFIG_SMP
+				/* Set the number of active processors. */
+				_systemcfg->processorCount++;
+				set_bit(cpuid, &RELOC(cpu_online_map));
+				set_bit(cpuid, &RELOC(cpu_available_map));
 #endif
-		call_prom(RELOC("start-cpu"), 3, 0, node, secondary_hold, cpuid);
-		prom_print(RELOC("..."));
-		for ( i = 0 ; (i < 100000000) && 
-			      (*acknowledge == ((unsigned long)-1)); i++ ) ;
-#ifdef DEBUG_PROM
-		{
-			unsigned long *p = 0x0;
-			prom_print(RELOC("    4) 0x0 = 0x"));
-			prom_print_hex(*p);
+			} else {
+				prom_print(RELOC("failed: "));
+				prom_print_hex(*acknowledge);
+				prom_print_nl();
+				/* prom_panic(RELOC("cpu failed to start")); */
+			}
+		}
+#ifdef CONFIG_SMP
+		else {
+			prom_print_hex(cpuid);
+			prom_print(RELOC(" : booting  cpu "));
+			prom_print(path);
 			prom_print_nl();
+			set_bit(cpuid, &RELOC(cpu_online_map));
+			set_bit(cpuid, &RELOC(cpu_available_map));
 		}
-#endif
-		if (*acknowledge == cpuid) {
-			prom_print(RELOC("ok\n"));
-			/* Set the number of active processors. */
-			_systemcfg->processorCount++;
-		} else {
-			prom_print(RELOC("failed: "));
-			prom_print_hex(*acknowledge);
+
+		/* Init paca for secondary threads.   They start later. */
+		for (i=1; i < cpu_threads; i++) {
+			prom_print_hex(interrupt_server[i]);
+			prom_print(RELOC(" : preparing thread ... "));
+			if (_naca->smt_state && cpuid < NR_CPUS-1) {
+				cpuid++;
+				_xPaca[cpuid].xHwProcNum = interrupt_server[i];
+				set_bit(cpuid, &RELOC(cpu_available_map));
+				prom_print(RELOC("available"));
+			} else {
+				prom_print(RELOC("not available"));
+			}
 			prom_print_nl();
 		}
+#endif
+		cpuid++;
 	}
 #ifdef CONFIG_HMT
 	/* Only enable HMT on processors that provide support. */
@@ -1238,11 +1301,114 @@ prom_hold_cpus(unsigned long mem)
 	}
 #endif
 	
+	if (cpuid >= NR_CPUS)
+		prom_print(RELOC("WARNING: maximum CPUs (" __stringify(NR_CPUS)
+				 ") exceeded: ignoring extras\n"));
+
 #ifdef DEBUG_PROM
 	prom_print(RELOC("prom_hold_cpus: end...\n"));
 #endif
 }
 
+static void
+smt_setup(void)
+{
+	char *p, *q;
+	char my_smt_enabled = SMT_DYNAMIC;
+	unsigned long my_smt_snooze_delay;
+	ihandle prom_options = NULL;
+	char option[9];
+	unsigned long offset = reloc_offset();
+	struct naca_struct *_naca = RELOC(naca);
+	char found = 0;
+
+	if (strstr(RELOC(cmd_line), RELOC("smt-enabled="))) {
+		for (q = RELOC(cmd_line); 
+		    (p = strstr(q, RELOC("smt-enabled="))) != 0; ) {
+			q = p + 12;
+			if (p > RELOC(cmd_line) && p[-1] != ' ')
+				continue;
+			found = 1;
+			if (q[0] == 'o' && q[1] == 'f' &&
+			    q[2] == 'f' && (q[3] == ' ' || q[3] == '\0')) {
+				my_smt_enabled = SMT_OFF;
+			} else if (q[0]=='o' && q[1] == 'n' &&
+				   (q[2] == ' ' || q[2] == '\0')) {
+				my_smt_enabled = SMT_ON;
+			} else {
+				my_smt_enabled = SMT_DYNAMIC;
+			}
+		}
+	}
+	if (!found) {
+		prom_options = (ihandle)call_prom(RELOC("finddevice"), 1, 1, RELOC("/options"));
+		if (prom_options != (ihandle) -1) {
+			call_prom(RELOC("getprop"),
+				4, 1, prom_options,
+				RELOC("ibm,smt-enabled"),
+				option, sizeof(option));
+			if (option[0] != 0) {
+				found = 1;
+				if (!strcmp(option, RELOC("off")))
+					my_smt_enabled = SMT_OFF;
+				else if (!strcmp(option, RELOC("on")))
+					my_smt_enabled = SMT_ON;
+				else
+					my_smt_enabled = SMT_DYNAMIC;
+			}
+		}
+	}
+
+	if (!found )
+		my_smt_enabled = SMT_DYNAMIC; /* default to on */
+
+	found = 0;
+	if (my_smt_enabled) {
+		if (strstr(RELOC(cmd_line), RELOC("smt-snooze-delay="))) {
+			for (q = RELOC(cmd_line); (p = strstr(q, RELOC("smt-snooze-delay="))) != 0; ) {
+				q = p + 17;
+				if (p > RELOC(cmd_line) && p[-1] != ' ')
+					continue;
+				found = 1;
+				/* Don't use simple_strtoul() because _ctype & others aren't RELOC'd */
+				my_smt_snooze_delay = 0;
+				while (*q >= '0' && *q <= '9') {
+					my_smt_snooze_delay = my_smt_snooze_delay * 10 + *q - '0';
+					q++;
+				}
+			}
+		}
+
+		if (!found) {
+			prom_options = (ihandle)call_prom(RELOC("finddevice"), 1, 1, RELOC("/options"));
+			if (prom_options != (ihandle) -1) {
+				call_prom(RELOC("getprop"),
+					4, 1, prom_options,
+					RELOC("ibm,smt-snooze-delay"),
+					option, sizeof(option));
+				if (option[0] != 0) {
+					found = 1;
+					/* Don't use simple_strtoul() because _ctype & others aren't RELOC'd */
+					my_smt_snooze_delay = 0;
+					q = option;
+					while (*q >= '0' && *q <= '9') {
+						my_smt_snooze_delay = my_smt_snooze_delay * 10 + *q - '0';
+						q++;
+					}
+				}
+			}
+		}
+
+		if (!found) {
+			my_smt_snooze_delay = 0; /* default value */
+		}
+	} else {
+		my_smt_snooze_delay = 0; /* default value */
+	}
+	_naca->smt_snooze_delay = my_smt_snooze_delay;
+	_naca->smt_state = my_smt_enabled;
+}
+
 #ifdef CONFIG_PPCDBG
 extern char *trace_names[];	/* defined in udbg.c -- need a better interface */
 
@@ -1348,6 +1514,21 @@ prom_parse_cmd_line(char *line)
 #endif
 }
 
+static void __init prom_close_stdin(void)
+{
+	unsigned long offset = reloc_offset();
+	struct prom_t *_prom = PTRRELOC(&prom);
+	u32 val;
+
+	if ((long)call_prom(RELOC("getprop"), 4, 1, _prom->chosen,
+			RELOC("stdin"), &val,
+			sizeof(val)) <= 0)
+		return;
+
+	call_prom(RELOC("close"), 1, 0, val);
+}
+
+
 /*
  * We enter here early on, when the Open Firmware prom is still
  * handling exceptions and the MMU hash table for us.
@@ -1560,6 +1741,8 @@ prom_init(unsigned long r3, unsigned lon
         /* Initialize some system info into the Naca early... */
         mem = prom_initialize_naca(mem);
 
+	smt_setup();
+
         /* If we are on an SMP machine, then we *MUST* do the
          * following, regardless of whether we have an SMP
          * kernel or not.
@@ -1601,6 +1784,9 @@ prom_init(unsigned long r3, unsigned lon
 		phys = (unsigned long)_prom->args.rets[3];
 	}
 
+	/* in case stdin is USB and still active */
+	prom_close_stdin();
+
 	/* If OpenFirmware version >= 3, then use quiesce call */
 	if (_prom->version >= 3) {
 		prom_print(RELOC("Calling quiesce ...\n"));
@@ -1795,6 +1981,10 @@ copy_device_tree(unsigned long mem_start
 	unsigned long offset = reloc_offset();
 	unsigned long mem_end = mem_start + (8<<20);
 
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (RELOC(ramdisk_start) && RELOC(ramdisk_start) > mem_start)
+		mem_end = RELOC(ramdisk_start) - 1;
+#endif
 	root = call_prom(RELOC("peer"), 1, 1, (phandle)0);
 	if (root == (phandle)0) {
 		prom_print(RELOC("couldn't get device tree root\n"));
@@ -1804,11 +1994,19 @@ copy_device_tree(unsigned long mem_start
 	mem_start = DOUBLEWORD_ALIGN(mem_start);
 	new_start = inspect_node(root, 0, mem_start, mem_end, &allnextp);
 	*allnextp = 0;
+	if (new_start > mem_end) {
+		prom_print(RELOC("Insufficient space for device tree:"));
+		prom_print(RELOC("  size allocated = 0x"));
+		prom_print_hex(mem_end - mem_start);
+		prom_print(RELOC(",  size required = 0x"));
+		prom_print_hex(new_start - mem_start);
+		prom_print_nl();
+		prom_exit();
+	}
 	return new_start;
 }
 
-__init
-static unsigned long
+static unsigned long __init
 inspect_node(phandle node, struct device_node *dad,
 	     unsigned long mem_start, unsigned long mem_end,
 	     struct device_node ***allnextpp)
@@ -1854,12 +2052,45 @@ inspect_node(phandle node, struct device
 		pp->length = (int)(long)
 			call_prom(RELOC("getprop"), 4, 1, node, namep,
 				  valp, mem_end - mem_start);
-		if (pp->length < 0)
+		if (pp->length < 0) 
 			continue;
+		if (pp->length > MAX_PROPERTY_LENGTH) {
+			char path[128];
+
+			prom_print(RELOC("WARNING: ignoring large property "));
+			/* It seems OF doesn't null-terminate the path :-( */
+			memset(path, 0, sizeof(path));
+			if (call_prom(RELOC("package-to-path"), 3, 1, node,
+                            path, sizeof(path)-1) > 0)
+				prom_print(path);
+			prom_print(namep);
+			prom_print(RELOC(" length 0x"));
+			prom_print_hex(pp->length);
+			prom_print_nl();
+
+			continue; 
+		}
 		mem_start = DOUBLEWORD_ALIGN(mem_start + pp->length);
 		*prev_propp = PTRUNRELOC(pp);
 		prev_propp = &pp->next;
 	}
+
+	/* Add a "linux_phandle" value */
+	if (np->node != NULL) {
+		u32 ibm_phandle = 0;
+		int len;
+
+		/* First see if "ibm,phandle" exists and use its value */
+		len = (int) call_prom(RELOC("getprop"), 4, 1, node,
+				      RELOC("ibm,phandle"),
+				      &ibm_phandle, sizeof(ibm_phandle));
+		if (len < 0) {
+			np->linux_phandle = np->node;
+		} else {
+			np->linux_phandle = ibm_phandle;
+		}
+	}
+
 	*prev_propp = 0;
 
 	/* get the node's full name */
@@ -2361,7 +2592,7 @@ find_phandle(phandle ph)
 	struct device_node *np;
 
 	for (np = allnodes; np != 0; np = np->allnext)
-		if (np->node == ph)
+		if (np->linux_phandle == ph)
 			return np;
 	return NULL;
 }
@@ -2450,6 +2681,26 @@ print_properties(struct device_node *np)
 }
 #endif
 
+#if 0
+void print_allnodes()
+{
+	struct device_node *np;
+	struct property *pp;
+
+
+	for (np = allnodes; np != 0; np = np->allnext) {
+		if (np->name)
+			printk("Device Node %s, n_addrs %d, n_intrs %d\n",
+			       np->name, np->n_addrs, np->n_intrs);
+		if (np->properties) {
+			for (pp = np->properties; pp != 0; pp = pp->next)
+			  printk("       Property %s, length %d\n",
+				 pp->name, pp->length);
+		}
+	}
+}
+
+#endif
 
 void __init
 abort()
@@ -2497,6 +2748,7 @@ prom_bi_rec_reserve(unsigned long mem)
 			switch (rec->tag) {
 #ifdef CONFIG_BLK_DEV_INITRD
 			case BI_INITRD:
+				RELOC(ramdisk_start) = rec->data[0];
 				lmb_reserve(rec->data[0], rec->data[1]);
 				break;
 #endif /* CONFIG_BLK_DEV_INITRD */
diff -urNp linux-365/arch/ppc64/kernel/setup.c linux-370/arch/ppc64/kernel/setup.c
--- linux-365/arch/ppc64/kernel/setup.c
+++ linux-370/arch/ppc64/kernel/setup.c
@@ -37,6 +37,7 @@
 #include <asm/paca.h>
 #include <asm/ppcdebug.h>
 #include <asm/time.h>
+#include <asm/cputable.h>
 #ifdef CONFIG_KDB
 #include <linux/kdb.h>
 #endif
@@ -48,6 +49,8 @@ extern unsigned long loops_per_jiffy;
 extern int preferred_console;  /* from kernel/printk.c */
 extern int blk_nohighio;
 
+extern int is_js20;
+
 extern unsigned long embedded_sysmap_start;
 extern unsigned long embedded_sysmap_end;
 
@@ -65,6 +68,7 @@ extern void iSeries_init_early( void );
 extern void pSeries_init_early( void );
 extern void pSeriesLP_init_early(void);
 extern void mm_init_ppc64( void ); 
+extern void pseries_secondary_smp_init(unsigned long);
 
 unsigned long decr_overclock = 1;
 unsigned long decr_overclock_proc0 = 1;
@@ -111,6 +115,8 @@ struct console udbg_console = {
 void setup_system(unsigned long r3, unsigned long r4, unsigned long r5,
 		  unsigned long r6, unsigned long r7)
 {
+	unsigned int ret, i;
+
 	/* This should be fixed properly in kernel/resource.c */
 	iomem_resource.end = MEM_SPACE_LIMIT;
 
@@ -148,7 +154,30 @@ void setup_system(unsigned long r3, unsi
 		udbg_printf("---- start early boot console ----\n");
 	}
 
-	printk("Starting Linux PPC64 %s\n", UTS_RELEASE);
+	if (systemcfg->platform & PLATFORM_PSERIES) {
+		finish_device_tree();
+		chrp_init(r3, r4, r5, r6, r7);
+#ifdef CONFIG_JS20
+		/* 
+		 * Workaround for firmware bug on Power Blades which
+		 * incorrectly claims "hcall-splpar" is supported on
+		 * these platforms 
+		 */
+		if (is_js20) 
+			cur_cpu_spec->firmware_features &= ~FW_FEATURE_SPLPAR;
+#endif
+		/* Start secondary threads on SMT systems */
+		for (i = 0; i < NR_CPUS; i++) {
+			if(cpu_available(i)  && !cpu_possible(i)) {
+				printk("%16.16lx : starting thread\n", i);
+				rtas_call(rtas_token("start-cpu"), 3, 1,
+					  (void *)&ret,
+					  i, *((unsigned long *)pseries_secondary_smp_init), i);
+				set_bit(i, &cpu_online_map);
+				systemcfg->processorCount++;
+			}
+		}
+	}
 
 	printk("-----------------------------------------------------\n");
 	printk("naca                          = 0x%p\n", naca);
@@ -165,13 +194,16 @@ void setup_system(unsigned long r3, unsi
 	printk("htab_data.num_ptegs           = 0x%lx\n", htab_data.htab_num_ptegs);
 	printk("-----------------------------------------------------\n");
 
-	if (systemcfg->platform & PLATFORM_PSERIES) {
-		finish_device_tree();
-		chrp_init(r3, r4, r5, r6, r7);
-	}
+	printk("Starting Linux PPC64 %s\n", UTS_RELEASE);
 
 	mm_init_ppc64();
 
+	if (cur_cpu_spec->firmware_features & FW_FEATURE_SPLPAR) {
+		vpa_init(0);
+	}
+
+	idle_setup();
+
 	switch (systemcfg->platform) {
 	    case PLATFORM_ISERIES_LPAR:
 		iSeries_init();
@@ -441,8 +473,7 @@ int parse_bootinfo(void)
 			memcpy(cmd_line, (void *)rec->data, rec->size);
 			break;
 		case BI_SYSMAP:
-			sysmap = (char *)((rec->data[0] >= (KERNELBASE))
-					? rec->data[0] : (unsigned long)__va(rec->data[0]));
+			sysmap = (char *)__va(rec->data[0]);
 			sysmap_size = rec->data[1];
 			break;
 #ifdef CONFIG_BLK_DEV_INITRD
diff -urNp linux-365/arch/ppc64/kernel/smp.c linux-370/arch/ppc64/kernel/smp.c
--- linux-365/arch/ppc64/kernel/smp.c
+++ linux-370/arch/ppc64/kernel/smp.c
@@ -52,6 +52,7 @@
 #include <asm/ppcdebug.h>
 #include "open_pic.h"
 #include <asm/machdep.h>
+#include <asm/cputable.h>
 #if defined(CONFIG_DUMP) || defined(CONFIG_DUMP_MODULE)
 int (*dump_ipi_function_ptr)(struct pt_regs *);
 #include <linux/dump.h>
@@ -72,7 +73,10 @@ cycles_t cacheflush_time;
 unsigned long cache_decay_ticks = HZ/100;
 static int max_cpus __initdata = NR_CPUS;
 
-unsigned long cpu_online_map;
+
+/* These are initialized because we set them before BSS is cleared.  Sigh... */
+unsigned long cpu_available_map = 1;
+unsigned long cpu_online_map = 1;
 
 volatile unsigned long cpu_callin_map[NR_CPUS] = {0,};
 
@@ -435,7 +439,16 @@ void smp_message_recv(int msg, struct pt
 
 void smp_send_reschedule(int cpu)
 {
-	smp_message_pass(cpu, PPC_MSG_RESCHEDULE, 0, 0);
+	if ((systemcfg->platform & PLATFORM_LPAR) &&
+	    (paca[cpu].yielded == 1)) {
+#ifdef CONFIG_PPC_ISERIES
+		HvCall_sendLpProd(cpu);
+#else
+		prod_processor(cpu);
+#endif
+	} else {
+		smp_message_pass(cpu, PPC_MSG_RESCHEDULE, 0, 0);
+	}
 }
 
 #ifdef CONFIG_XMON
@@ -565,6 +578,7 @@ int smp_call_function (void (*func) (voi
 	ret = 0;
 
  out:
+	call_data = NULL;
 	HMT_medium();
 	spin_unlock_bh(&call_lock);
 	return ret;
@@ -572,9 +586,20 @@ int smp_call_function (void (*func) (voi
 
 void smp_call_function_interrupt(void)
 {
-	void (*func) (void *info) = call_data->func;
-	void *info = call_data->info;
-	int wait = call_data->wait;
+	void (*func) (void *info);
+	void *info;
+	int wait;
+
+
+	/* call_data will be NULL if the sender timed out while
+	 * waiting on us to receive the call.
+	 */
+	if (!call_data)
+		return;
+
+	func = call_data->func;
+	info = call_data->info;
+	wait = call_data->wait;
 
 	/*
 	 * Notify initiating CPU that I've grabbed the data and am
@@ -780,16 +805,35 @@ void __init initialize_secondary(void)
 {
 }
 
+extern unsigned int default_distrib_server;
 /* Activate a secondary processor. */
 int start_secondary(void *unused)
 {
 	int cpu; 
+        unsigned long status = 0;
 
 	cpu = current->cpu;
 	atomic_inc(&init_mm.mm_count);
 	current->active_mm = &init_mm;
 	smp_callin();
 
+	get_paca()->yielded = 0;
+
+#ifdef CONFIG_PPC_PSERIES
+	if (cur_cpu_spec->firmware_features & FW_FEATURE_SPLPAR) {
+		vpa_init(cpu);
+	}
+
+#ifdef CONFIG_IRQ_ALL_CPUS
+	/* Put the calling processor into the GIQ.  This is really only 
+	 * necessary from a secondary thread as the OF start-cpu interface
+	 * performs this function for us on primary threads.
+	 */
+	rtas_call(rtas_token("set-indicator"), 3, 1, &status, 9005,
+                  default_distrib_server, 1UL);
+#endif
+#endif
+
 	/* Go into the idle loop. */
 	return cpu_idle(NULL);
 }
diff -urNp linux-365/arch/ppc64/kernel/traps.c linux-370/arch/ppc64/kernel/traps.c
--- linux-365/arch/ppc64/kernel/traps.c
+++ linux-370/arch/ppc64/kernel/traps.c
@@ -480,7 +480,7 @@ KernelFPUnavailableException(struct pt_r
 {
 	printk("Illegal floating point used in kernel (task=0x%016lx, pc=0x%016lx, trap=0x%08x)\n",
 		(unsigned long)current, regs->nip, (unsigned int)regs->trap);
-	panic("Unrecoverable FP Unavailable Exception in Kernel");
+	_exception(SIGFPE, NULL, regs);
 }
 
 
diff -urNp linux-365/arch/ppc64/kernel/udbg.c linux-370/arch/ppc64/kernel/udbg.c
--- linux-365/arch/ppc64/kernel/udbg.c
+++ linux-370/arch/ppc64/kernel/udbg.c
@@ -131,7 +131,7 @@ udbg_write(const char *s, int n)
 	int remain = n;
 	char c;
 	if (!ppc_md.udbg_putc)
-		for (;;);	/* stop here for cpuctl */
+		return 0;
 	if ( s && *s != '\0' ) {
 		while ( (( c = *s++ ) != '\0') && (remain-- > 0)) {
 			ppc_md.udbg_putc(c);
diff -urNp linux-365/arch/ppc64/xmon/start.c linux-370/arch/ppc64/xmon/start.c
--- linux-365/arch/ppc64/xmon/start.c
+++ linux-370/arch/ppc64/xmon/start.c
@@ -209,6 +209,8 @@ xmon_readchar(void)
 	for (;;) {
 		switch (xmon_read(xmon_stdin, &ch, 1)) {
 		case 1:
+			if (ch == 0)
+				continue;
 			return ch;
 		case -1:
 			xmon_printf("read(stdin) returned -1\r\n", 0, 0);
diff -urNp linux-365/include/asm-ppc64/cputable.h linux-370/include/asm-ppc64/cputable.h
--- linux-365/include/asm-ppc64/cputable.h
+++ linux-370/include/asm-ppc64/cputable.h
@@ -77,7 +77,17 @@ extern struct cpu_spec		*cur_cpu_spec;
 #define FW_FEATURE_PERF		(1UL<<7)	
 #define FW_FEATURE_DUMP		(1UL<<8)	
 #define FW_FEATURE_INTERRUPT	(1UL<<9)	
-#define FW_FEATURE_MIGRATE	(1UL<<10)	
+#define FW_FEATURE_MIGRATE	(1UL<<10)
+#define FW_FEATURE_TERM		(1UL<<11)
+#define FW_FEATURE_PERFMON	(1UL<<12)
+#define FW_FEATURE_CRQ   	(1UL<<13)
+#define FW_FEATURE_VIO   	(1UL<<14)
+#define FW_FEATURE_RDMA   	(1UL<<15)
+#define FW_FEATURE_LLAN   	(1UL<<16)
+#define FW_FEATURE_BULK   	(1UL<<17)
+#define FW_FEATURE_XDABR   	(1UL<<18)
+#define FW_FEATURE_MULTITCE   	(1UL<<19)
+#define FW_FEATURE_SPLPAR   	(1UL<<20)
 
 typedef struct {
     unsigned long val;
diff -urNp linux-365/include/asm-ppc64/hvcall.h linux-370/include/asm-ppc64/hvcall.h
--- linux-365/include/asm-ppc64/hvcall.h
+++ linux-370/include/asm-ppc64/hvcall.h
@@ -9,6 +9,14 @@
 #define H_PTEG_Full	-6	/* PTEG is full */
 #define H_Not_Found	-7	/* PTE was not found" */
 #define H_Reserved_DABR	-8	/* DABR address is reserved by the hypervisor on this processor" */
+#define H_NoMem                 -9
+#define H_Authority            -10
+#define H_Permission           -11
+#define H_Dropped              -12
+#define H_SourceParm           -13
+#define H_DestParm             -14
+#define H_RemoteParm           -15
+#define H_Resource             -16
 
 /* Flags */
 #define H_LARGE_PAGE		(1UL<<(63-16))
@@ -58,8 +66,23 @@
 #define H_IPOLL			0x70
 #define H_XIRR			0x74
 #define H_PERFMON		0x7c
+#define H_MIGRATE_DMA		0x78
+#define H_REGISTER_VPA		0xDC
+#define H_CEDE			0xE0
+#define H_CONFER		0xE4
+#define H_PROD			0xE8
+#define H_GET_PPP		0xEC
+#define H_SET_PPP		0xF0
+#define H_SET_PURR		0xF4
+#define H_PIC			0xF8
+#define H_REG_CRQ		0xFC
+#define H_FREE_CRQ		0x100
+#define H_VIO_SIGNAL		0x104
+#define H_SEND_CRQ		0x108
+#define H_COPY_RDMA		0x110
+#define H_POLL_PENDING		0x1D8
 
-#define HSC			".long 0x44000022\n"
+#define HVSC			".long 0x44000022\n"
 #define H_ENTER_r3		"li	3, 0x08\n"
 
 /* plpar_hcall() -- Generic call interface using above opcodes
@@ -84,3 +107,34 @@ long plpar_hcall(unsigned long opcode,
  */
 long plpar_hcall_norets(unsigned long opcode, ...);
 
+/*
+ * Special hcall interface for ibmveth support.
+ * Takes 8 input parms. Returns a rc and stores the
+ * R4 return value in *out1.
+ */
+long plpar_hcall_8arg_2ret(unsigned long opcode,
+			unsigned long arg1,
+			unsigned long arg2,
+			unsigned long arg3,
+			unsigned long arg4,
+			unsigned long arg5,
+			unsigned long arg6,
+			unsigned long arg7,
+			unsigned long arg8,
+			unsigned long *out1);
+
+
+/* plpar_hcall_4out()
+ *
+ * same as plpar_hcall except with 4 output arguments.
+ *
+ */
+long plpar_hcall_4out(unsigned long opcode,
+		      unsigned long arg1,
+		      unsigned long arg2,
+		      unsigned long arg3,
+		      unsigned long arg4,
+		      unsigned long *out1,
+		      unsigned long *out2,
+		      unsigned long *out3,
+		      unsigned long *out4);
diff -urNp linux-365/include/asm-ppc64/iSeries/HvCall.h linux-370/include/asm-ppc64/iSeries/HvCall.h
--- linux-365/include/asm-ppc64/iSeries/HvCall.h
+++ linux-370/include/asm-ppc64/iSeries/HvCall.h
@@ -196,6 +196,12 @@ static inline void		HvCall_sendIPI(struc
 }
 
 //=====================================================================
+static inline void              HvCall_sendLpProd(HvLpIndex lpindex)
+{
+	HvCall1( HvCallBaseSendLpProd, lpindex );
+}
+
+//=====================================================================
 static inline void		HvCall_terminateMachineSrc(void)
 {
 	HvCall0( HvCallBaseTerminateMachineSrc );
diff -urNp linux-365/include/asm-ppc64/iSeries/ItLpPaca.h linux-370/include/asm-ppc64/iSeries/ItLpPaca.h
--- linux-365/include/asm-ppc64/iSeries/ItLpPaca.h
+++ linux-370/include/asm-ppc64/iSeries/ItLpPaca.h
@@ -110,7 +110,14 @@ struct ItLpPaca
 	u64     xPDCSavedSPRG1;         // Saved SPRG1 for PMC int      x68-x6F
 	u64     xPDCSavedSRR0;          // Saved SRR0 for PMC int       x70-x77
 	volatile u32 xVirtualDecr;	// Virtual DECR for shared procsx78-x7B
-	u32	    xRsvd2_2;		// Reserved			x7C-x7F
+#ifndef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for mod linkage */
+	u16     xSLBCount;              // # of SLBs to maintain        x7C-x7D
+	u8      xIdle;                  // Indicate OS is idle          x7E
+	u8      xRsvd2_2;               // Reserved                     x7F
+#else
+	u32	xRsvd2_2;		// Reserved			x7C-x7F
+#endif
+
 
 //=============================================================================
 // CACHE_LINE_3 0x0100 - 0x007F: This line is shared with other processors
diff -urNp linux-365/include/asm-ppc64/memory.h linux-370/include/asm-ppc64/memory.h
--- linux-365/include/asm-ppc64/memory.h
+++ linux-370/include/asm-ppc64/memory.h
@@ -43,22 +43,28 @@ static inline void isync(void)
 
 /* Macros for adjusting thread priority (hardware multi-threading) */
 
-#if defined(CONFIG_PPC_ISERIES) || defined(CONFIG_HMT)
+#define HMT_very_low()     asm volatile("or 31,31,31       # very low priority")
 #define HMT_low()	asm volatile("or 1,1,1		# low priority")
+#define HMT_medium_low()   asm volatile("or 6,6,6          # medium low priority")
 #define HMT_medium()	asm volatile("or 2,2,2		# medium priority")
+#define HMT_medium_high()  asm volatile("or 5,5,5          # medium high priority")
 #define HMT_high()	asm volatile("or 3,3,3		# high priority")
 
+#define HMT_VERY_LOW            "\tor   31,31,31        # very low priority\n"
 #define HMT_LOW		"\tor	1,1,1		# low priority\n"
+#define HMT_MEDIUM_LOW          "\tor   6,6,6           # medium low priority\n"
 #define HMT_MEDIUM	"\tor	2,2,2		# medium priority\n"
+#define HMT_MEDIUM_HIGH         "\tor   5,5,5           # medium high priority\n"
 #define HMT_HIGH	"\tor	3,3,3		# high priority\n"
-#else
-#define HMT_low()	do { } while(0)
-#define HMT_medium()	do { } while(0)
-#define HMT_high()	do { } while(0)
 
-#define HMT_LOW
-#define HMT_MEDIUM
-#define HMT_LOW
-#endif
+/*
+ * Various operational modes for SMT
+ * Off    : never run threaded
+ * On     : always run threaded
+ * Dynamic: Allow the system to switch modes as needed
+ */
+#define SMT_OFF      0
+#define SMT_ON       1
+#define SMT_DYNAMIC  2
 
 #endif
diff -urNp linux-365/include/asm-ppc64/mmu.h linux-370/include/asm-ppc64/mmu.h
--- linux-365/include/asm-ppc64/mmu.h
+++ linux-370/include/asm-ppc64/mmu.h
@@ -191,6 +191,7 @@ void create_valid_hpte( unsigned long sl
 			unsigned long prpn, unsigned hash,
 			void * ptep, unsigned hpteflags,
 			unsigned bolted );
+unsigned long get_lock_slot(unsigned long vpn);
 
 #define PD_SHIFT (10+12)		/* Page directory */
 #define PD_MASK  0x02FF
diff -urNp linux-365/include/asm-ppc64/naca.h linux-370/include/asm-ppc64/naca.h
--- linux-365/include/asm-ppc64/naca.h
+++ linux-370/include/asm-ppc64/naca.h
@@ -35,7 +35,17 @@ struct naca_struct {
 	u32 dCacheL1LinesPerPage;	/* L1 d-cache lines / page   0x64 */
 	u32 iCacheL1LogLineSize;	/* L1 i-cache line size Log2 0x68 */
 	u32 iCacheL1LinesPerPage;	/* L1 i-cache lines / page   0x6c */
+#ifndef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for mod linkage */
+	u64 smt_snooze_delay;           /* Delay (in usec) before    0x70 */
+					/* entering ST mode               */
+	u8  smt_state;                  /* 0 = SMT off               0x78 */
+					/* 1 = SMT on                     */
+					/* 2 = SMT dynamic                */
+	u8  resv0[7];                   /* Reserved           0x79 - 0x7F */
+#else
 	u64 resv0[2];                   /* Reserved           0x70 - 0x7F */
+#endif
+
 };
 
 extern struct naca_struct *naca;
diff -urNp linux-365/include/asm-ppc64/paca.h linux-370/include/asm-ppc64/paca.h
--- linux-365/include/asm-ppc64/paca.h
+++ linux-370/include/asm-ppc64/paca.h
@@ -96,7 +96,14 @@ struct paca_struct {
 	u64 pgtable_cache_sz;		/*					0x18 */
 	u64 next_jiffy_update_tb;	/* TB value for next jiffy update	0x20 */
 	u32 lpEvent_count;		/* lpEvents processed			0x28 */
+#ifndef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for mod linkage */
+	u8  yielded;                    /* 0 = this processor is running        0x2c */
+					/* 1 = this processor is yielded             */
+	u8  rsvd2[128-5*8-1*4-1];	/*					0x69 */
+#else
 	u8  rsvd2[128-5*8-1*4];		/*					0x68 */
+#endif
+
 
 /*=====================================================================================
  * CACHE_LINE_3 0x0100 - 0x017F
@@ -149,7 +156,13 @@ struct paca_struct {
  * CACHE_LINE_20-30
  *=====================================================================================
  */
+#ifndef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for mod linkage */
+	u64 slb_shadow[0x20];
+	u64 dispatch_log;
+	u8  rsvd6[0x400 - 0x8];
+#else
 	u8 rsvd6[0x500];
+#endif
 
 /*=====================================================================================
  * CACHE_LINE_31 0x0F00 - 0x0F7F Exception stack
@@ -171,4 +184,6 @@ struct paca_struct {
 	u8 guard[0x1000];               /* ... and then hang 'em         */ 
 };
 
+#define get_hard_smp_processor_id(CPU) (paca[(CPU)].xHwProcNum)
+
 #endif /* _PPC64_PACA_H */
diff -urNp linux-365/include/asm-ppc64/processor.h linux-370/include/asm-ppc64/processor.h
--- linux-365/include/asm-ppc64/processor.h
+++ linux-370/include/asm-ppc64/processor.h
@@ -494,6 +494,7 @@
 #define PLATFORM_PSERIES      0x0100
 #define PLATFORM_PSERIES_LPAR 0x0101
 #define PLATFORM_ISERIES_LPAR 0x0201
+#define PLATFORM_LPAR         0x0001
 	
 /*
  * List of interrupt controllers.
diff -urNp linux-365/include/asm-ppc64/prom.h linux-370/include/asm-ppc64/prom.h
--- linux-365/include/asm-ppc64/prom.h
+++ linux-370/include/asm-ppc64/prom.h
@@ -15,8 +15,14 @@
  * 2 of the License, or (at your option) any later version.
  */
 
-#define PTRRELOC(x)     ((typeof(x))((unsigned long)(x) - offset))
-#define PTRUNRELOC(x)   ((typeof(x))((unsigned long)(x) + offset))
+static inline unsigned long __hide(unsigned long x)
+{
+	asm volatile("" : "=&r" (x) : "0" (x));
+	return x;
+}
+
+#define PTRRELOC(x)     ((typeof(x))__hide((unsigned long)(x) - offset))
+#define PTRUNRELOC(x)   ((typeof(x))__hide((unsigned long)(x) + offset))
 #define RELOC(x)        (*PTRRELOC(&(x)))
 
 #define LONG_LSW(X) (((unsigned long)X) & 0xffffffff)
@@ -142,6 +148,9 @@ struct device_node {
 	struct	device_node *sibling;
 	struct	device_node *next;	/* next device of same type */
 	struct	device_node *allnext;	/* next in list of all nodes */
+#ifndef __GENKSYMS__ /* preserve KMI/ABI ksyms compatibility for mod linkage */
+	phandle linux_phandle;
+#endif
 };
 
 typedef u32 prom_arg_t;
diff -urNp linux-365/include/asm-ppc64/smp.h linux-370/include/asm-ppc64/smp.h
--- linux-365/include/asm-ppc64/smp.h
+++ linux-370/include/asm-ppc64/smp.h
@@ -20,7 +20,7 @@
 #include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/threads.h>	/* for NR_CPUS */
-
+#include <asm/bitops.h>
 
 #ifndef __ASSEMBLY__
 #ifdef CONFIG_SMP
@@ -33,6 +33,7 @@ struct current_set_struct {
 };
 
 extern unsigned long cpu_online_map;
+extern unsigned long cpu_available_map;
 
 extern void smp_message_pass(int target, int msg, unsigned long data, int wait);
 extern void smp_store_cpu_info(int id);
@@ -43,11 +44,8 @@ extern void smp_message_recv(int, struct
 
 /* Newer 2.5 Linux kernels have cpu_possible. This provides equivalent function
    for the older 2.4 kernels */
-extern unsigned long cpu_online_map;
-static inline int cpu_possible(int cpu)
-{
-	return (cpu_online_map & (1<<(cpu)));
-} 
+#define cpu_possible(cpu)	test_bit((cpu), &cpu_online_map)
+#define cpu_available(cpu)	test_bit((cpu), &cpu_available_map)
 
 #define NO_PROC_ID		0xFF            /* No processor magic marker */
 #define PROC_CHANGE_PENALTY	20
@@ -74,8 +72,11 @@ extern volatile unsigned long cpu_callin
 void smp_init_iSeries(void);
 void smp_init_pSeries(void);
 
+#else /* CONFIG_SMP */
+#define cpu_possible(cpu)	((cpu) == 0)
+#define cpu_available(cpu)	((cpu) == 0)
+
 #endif /* !(CONFIG_SMP) */
 #endif /* __ASSEMBLY__ */
-#define get_hard_smp_processor_id(CPU) (paca[(CPU)].xHwProcNum)
 #endif /* !(_PPC64_SMP_H) */
 #endif /* __KERNEL__ */
diff -urNp linux-365/include/asm-ppc64/system.h linux-370/include/asm-ppc64/system.h
--- linux-365/include/asm-ppc64/system.h
+++ linux-370/include/asm-ppc64/system.h
@@ -69,6 +69,7 @@ extern void cvt_fd(float *from, double *
 extern void cvt_df(double *from, float *to, unsigned long *fpscr);
 extern int abs(int);
 extern void cacheable_memzero(void *p, unsigned int nb);
+extern void vpa_init(int cpu);
 
 #ifdef CONFIG_JS20
 extern int is_js20;
diff -urNp linux-365/include/asm-ppc64/unistd.h linux-370/include/asm-ppc64/unistd.h
--- linux-365/include/asm-ppc64/unistd.h
+++ linux-370/include/asm-ppc64/unistd.h
@@ -248,178 +248,104 @@
 #define __NR_tgkill		250
 #define __NR_rtas		255
 
-#define __NR(n)	#n
-
-
-#define __syscall_return(type) \
-	return (__sc_err & 0x10000000 ? errno = __sc_ret, __sc_ret = -1 : 0), \
-	       (type) __sc_ret
-
-#define __syscall_clobbers \
-	"r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12"
+/* On powerpc a system call basically clobbers the same registers like a
+ * function call, with the exception of LR (which is needed for the
+ * "sc; bnslr" sequence) and CR (where only CR0.SO is clobbered to signal
+ * an error return status).
+ */
 
-#define _syscall0(type,name)						\
-type name(void)								\
-{									\
+#define __syscall_nr(nr, type, name, args...)				\
 	unsigned long __sc_ret, __sc_err;				\
 	{								\
-		register unsigned long __sc_0 __asm__ ("r0");		\
-		register unsigned long __sc_3 __asm__ ("r3");		\
-									\
-		__sc_0 = __NR_##name;					\
-		__asm__ __volatile__					\
-			("sc           \n\t"				\
-			 "mfcr %1      "				\
-			: "=&r" (__sc_3), "=&r" (__sc_0)		\
-			: "0"   (__sc_3), "1"   (__sc_0)		\
-			: __syscall_clobbers);				\
+		register unsigned long __sc_0  __asm__ ("r0");		\
+		register unsigned long __sc_3  __asm__ ("r3");		\
+		register unsigned long __sc_4  __asm__ ("r4");		\
+		register unsigned long __sc_5  __asm__ ("r5");		\
+		register unsigned long __sc_6  __asm__ ("r6");		\
+		register unsigned long __sc_7  __asm__ ("r7");		\
+									\
+		__sc_loadargs_##nr(name, args);				\
+		__asm__ __volatile__					\
+			("sc           \n\t"				\
+			 "mfcr %0      "				\
+			: "=&r" (__sc_0),				\
+			  "=&r" (__sc_3),  "=&r" (__sc_4),		\
+			  "=&r" (__sc_5),  "=&r" (__sc_6),		\
+			  "=&r" (__sc_7)				\
+			: __sc_asm_input_##nr				\
+			: "cr0", "ctr", "memory",			\
+			  "r8", "r9", "r10","r11", "r12");		\
 		__sc_ret = __sc_3;					\
 		__sc_err = __sc_0;					\
 	}								\
-	__syscall_return (type);					\
+	if (__sc_err & 0x10000000)					\
+	{								\
+		errno = __sc_ret;					\
+		__sc_ret = -1;						\
+	}								\
+	return (type) __sc_ret
+
+#define __sc_loadargs_0(name, dummy...)					\
+	__sc_0 = __NR_##name
+#define __sc_loadargs_1(name, arg1)					\
+	__sc_loadargs_0(name);						\
+	__sc_3 = (unsigned long) (arg1)
+#define __sc_loadargs_2(name, arg1, arg2)				\
+	__sc_loadargs_1(name, arg1);					\
+	__sc_4 = (unsigned long) (arg2)
+#define __sc_loadargs_3(name, arg1, arg2, arg3)				\
+	__sc_loadargs_2(name, arg1, arg2);				\
+	__sc_5 = (unsigned long) (arg3)
+#define __sc_loadargs_4(name, arg1, arg2, arg3, arg4)			\
+	__sc_loadargs_3(name, arg1, arg2, arg3);			\
+	__sc_6 = (unsigned long) (arg4)
+#define __sc_loadargs_5(name, arg1, arg2, arg3, arg4, arg5)		\
+	__sc_loadargs_4(name, arg1, arg2, arg3, arg4);			\
+	__sc_7 = (unsigned long) (arg5)
+
+#define __sc_asm_input_0 "0" (__sc_0)
+#define __sc_asm_input_1 __sc_asm_input_0, "1" (__sc_3)
+#define __sc_asm_input_2 __sc_asm_input_1, "2" (__sc_4)
+#define __sc_asm_input_3 __sc_asm_input_2, "3" (__sc_5)
+#define __sc_asm_input_4 __sc_asm_input_3, "4" (__sc_6)
+#define __sc_asm_input_5 __sc_asm_input_4, "5" (__sc_7)
+
+#define _syscall0(type,name)						\
+type name(void)								\
+{									\
+	__syscall_nr(0, type, name);					\
 }
 
 #define _syscall1(type,name,type1,arg1)					\
 type name(type1 arg1)							\
 {									\
-	unsigned long __sc_ret, __sc_err;				\
-	{								\
-		register unsigned long __sc_0 __asm__ ("r0");		\
-		register unsigned long __sc_3 __asm__ ("r3");		\
-									\
-		__sc_3 = (unsigned long) (arg1);			\
-		__sc_0 = __NR_##name;					\
-		__asm__ __volatile__					\
-			("sc           \n\t"				\
-			 "mfcr %1      "				\
-			: "=&r" (__sc_3), "=&r" (__sc_0)		\
-			: "0"   (__sc_3), "1"   (__sc_0)		\
-			: __syscall_clobbers);				\
-		__sc_ret = __sc_3;					\
-		__sc_err = __sc_0;					\
-	}								\
-	__syscall_return (type);					\
+	__syscall_nr(1, type, name, arg1);				\
 }
 
 #define _syscall2(type,name,type1,arg1,type2,arg2)			\
 type name(type1 arg1, type2 arg2)					\
 {									\
-	unsigned long __sc_ret, __sc_err;				\
-	{								\
-		register unsigned long __sc_0 __asm__ ("r0");		\
-		register unsigned long __sc_3 __asm__ ("r3");		\
-		register unsigned long __sc_4 __asm__ ("r4");		\
-									\
-		__sc_3 = (unsigned long) (arg1);			\
-		__sc_4 = (unsigned long) (arg2);			\
-		__sc_0 = __NR_##name;					\
-		__asm__ __volatile__					\
-			("sc           \n\t"				\
-			 "mfcr %1      "				\
-			: "=&r" (__sc_3), "=&r" (__sc_0)		\
-			: "0"   (__sc_3), "1"   (__sc_0),		\
-			  "r"   (__sc_4)				\
-			: __syscall_clobbers);				\
-		__sc_ret = __sc_3;					\
-		__sc_err = __sc_0;					\
-	}								\
-	__syscall_return (type);					\
+	__syscall_nr(2, type, name, arg1, arg2);			\
 }
 
 #define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3)		\
 type name(type1 arg1, type2 arg2, type3 arg3)				\
 {									\
-	unsigned long __sc_ret, __sc_err;				\
-	{								\
-		register unsigned long __sc_0 __asm__ ("r0");		\
-		register unsigned long __sc_3 __asm__ ("r3");		\
-		register unsigned long __sc_4 __asm__ ("r4");		\
-		register unsigned long __sc_5 __asm__ ("r5");		\
-									\
-		__sc_3 = (unsigned long) (arg1);			\
-		__sc_4 = (unsigned long) (arg2);			\
-		__sc_5 = (unsigned long) (arg3);			\
-		__sc_0 = __NR_##name;					\
-		__asm__ __volatile__					\
-			("sc           \n\t"				\
-			 "mfcr %1      "				\
-			: "=&r" (__sc_3), "=&r" (__sc_0)		\
-			: "0"   (__sc_3), "1"   (__sc_0),		\
-			  "r"   (__sc_4),				\
-			  "r"   (__sc_5)				\
-			: __syscall_clobbers);				\
-		__sc_ret = __sc_3;					\
-		__sc_err = __sc_0;					\
-	}								\
-	__syscall_return (type);					\
+	__syscall_nr(3, type, name, arg1, arg2, arg3);			\
 }
 
 #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4) \
 type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4)		\
 {									\
-	unsigned long __sc_ret, __sc_err;				\
-	{								\
-		register unsigned long __sc_0 __asm__ ("r0");		\
-		register unsigned long __sc_3 __asm__ ("r3");		\
-		register unsigned long __sc_4 __asm__ ("r4");		\
-		register unsigned long __sc_5 __asm__ ("r5");		\
-		register unsigned long __sc_6 __asm__ ("r6");		\
-									\
-		__sc_3 = (unsigned long) (arg1);			\
-		__sc_4 = (unsigned long) (arg2);			\
-		__sc_5 = (unsigned long) (arg3);			\
-		__sc_6 = (unsigned long) (arg4);			\
-		__sc_0 = __NR_##name;					\
-		__asm__ __volatile__					\
-			("sc           \n\t"				\
-			 "mfcr %1      "				\
-			: "=&r" (__sc_3), "=&r" (__sc_0)		\
-			: "0"   (__sc_3), "1"   (__sc_0),		\
-			  "r"   (__sc_4),				\
-			  "r"   (__sc_5),				\
-			  "r"   (__sc_6)				\
-			: __syscall_clobbers);				\
-		__sc_ret = __sc_3;					\
-		__sc_err = __sc_0;					\
-	}								\
-	__syscall_return (type);					\
+	__syscall_nr(4, type, name, arg1, arg2, arg3, arg4);		\
 }
 
 #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,type5,arg5) \
 type name(type1 arg1, type2 arg2, type3 arg3, type4 arg4, type5 arg5)	\
 {									\
-	unsigned long __sc_ret, __sc_err;				\
-	{								\
-		register unsigned long __sc_0 __asm__ ("r0");		\
-		register unsigned long __sc_3 __asm__ ("r3");		\
-		register unsigned long __sc_4 __asm__ ("r4");		\
-		register unsigned long __sc_5 __asm__ ("r5");		\
-		register unsigned long __sc_6 __asm__ ("r6");		\
-		register unsigned long __sc_7 __asm__ ("r7");		\
-									\
-		__sc_3 = (unsigned long) (arg1);			\
-		__sc_4 = (unsigned long) (arg2);			\
-		__sc_5 = (unsigned long) (arg3);			\
-		__sc_6 = (unsigned long) (arg4);			\
-		__sc_7 = (unsigned long) (arg5);			\
-		__sc_0 = __NR_##name;					\
-		__asm__ __volatile__					\
-			("sc           \n\t"				\
-			 "mfcr %1      "				\
-			: "=&r" (__sc_3), "=&r" (__sc_0)		\
-			: "0"   (__sc_3), "1"   (__sc_0),		\
-			  "r"   (__sc_4),				\
-			  "r"   (__sc_5),				\
-			  "r"   (__sc_6),				\
-			  "r"   (__sc_7)				\
-			: __syscall_clobbers);				\
-		__sc_ret = __sc_3;					\
-		__sc_err = __sc_0;					\
-	}								\
-	__syscall_return (type);					\
+	__syscall_nr(5, type, name, arg1, arg2, arg3, arg4, arg5);	\
 }
 
-
 #ifdef __KERNEL_SYSCALLS__
 
 /*
