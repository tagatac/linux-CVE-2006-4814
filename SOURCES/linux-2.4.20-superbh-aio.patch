--- linux-2.4.20/fs/buffer.c.=K0001=.orig
+++ linux-2.4.20/fs/buffer.c
@@ -3314,6 +3314,7 @@ int brw_kvec_async(int rw, kvec_cb_t cb,
 
 	struct brw_cb	*brw_cb;
 	int		can_do_varyio = get_blkdev_varyio(dev);
+	struct buffer_head *bh_prev;
 
 	if (!vec->nr)
 		BUG();
@@ -3351,7 +3352,8 @@ int brw_kvec_async(int rw, kvec_cb_t cb,
 
 	brw_cb->cb = cb;
 	brw_cb->nr = 0;
-
+	bh_prev = NULL;
+	
 	/* This is ugly.  FIXME. */
 	for (i=0, veclet=vec->veclet; i<vec->nr; i++,veclet++) {
 		struct page *page = veclet->page;
@@ -3387,11 +3389,17 @@ int brw_kvec_async(int rw, kvec_cb_t cb,
 			init_buffer(tmp, end_buffer_io_kiobuf_async, NULL);
 			tmp->b_dev = dev;
 			tmp->b_blocknr = blknr;
+			tmp->b_rsector = blknr << (sector_shift - 9);
 			blknr += (iosize / sector_size);
 			tmp->b_state = (1 << BH_Mapped) | (1 << BH_Lock)
 					| (1 << BH_Req);
 			tmp->b_private = brw_cb;
 
+			tmp->b_reqnext = NULL;
+			if (bh_prev)
+				bh_prev->b_reqnext = tmp;
+			bh_prev = tmp;
+			
 			if (rw == WRITE) {
 				set_bit(BH_Uptodate, &tmp->b_state);
 				clear_bit(BH_Dirty, &tmp->b_state);
@@ -3414,15 +3422,8 @@ int brw_kvec_async(int rw, kvec_cb_t cb,
 submit:
 	atomic_set(&brw_cb->io_count, brw_cb->nr+1);
 	/* okay, we've setup all our io requests, now fire them off! */
-	if (can_do_varyio)
-		for (i=0; i<brw_cb->nr; i++) {
-			struct buffer_head *tmp = brw_cb->bh[i];
-			tmp->b_rsector = tmp->b_blocknr << (sector_shift - 9);
-			submit_bh_rsector(rw, tmp);
-		}
-	else
-		for (i=0; i<brw_cb->nr; i++) 
-			submit_bh(rw, brw_cb->bh[i]);
+	if (brw_cb->nr)
+		submit_bh_linked(rw, brw_cb->bh[0]);
 	brw_cb_put(brw_cb);
 	run_task_queue(&tq_disk);
 	return 0;
